{
  "content": {
    "base64": "IyBiYXNoL3pzaCBnaXQgcHJvbXB0IHN1cHBvcnQKIwojIENvcHlyaWdodCAoQykgMjAwNiwyMDA3IFNoYXduIE8uIFBlYXJjZSA8c3BlYXJjZUBzcGVhcmNlLm9yZz4KIyBEaXN0cmlidXRlZCB1bmRlciB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UsIHZlcnNpb24gMi4wLgojCiMgVGhpcyBzY3JpcHQgYWxsb3dzIHlvdSB0byBzZWUgdGhlIGN1cnJlbnQgYnJhbmNoIGluIHlvdXIgcHJvbXB0LgojCiMgVG8gZW5hYmxlOgojCiMgICAgMSkgQ29weSB0aGlzIGZpbGUgdG8gc29tZXdoZXJlIChlLmcuIH4vLmdpdC1wcm9tcHQuc2gpLgojICAgIDIpIEFkZCB0aGUgZm9sbG93aW5nIGxpbmUgdG8geW91ciAuYmFzaHJjLy56c2hyYzoKIyAgICAgICAgc291cmNlIH4vLmdpdC1wcm9tcHQuc2gKIyAgICAzYSkgQ2hhbmdlIHlvdXIgUFMxIHRvIGNhbGwgX19naXRfcHMxIGFzCiMgICAgICAgIGNvbW1hbmQtc3Vic3RpdHV0aW9uOgojICAgICAgICBCYXNoOiBQUzE9J1tcdUBcaCBcVyQoX19naXRfcHMxICIgKCVzKSIpXVwkICcKIyAgICAgICAgWlNIOiAgUFMxPSdbJW5AJW0gJWMkKF9fZ2l0X3BzMSAiICglcykiKV1cJCAnCiMgICAgICAgIHRoZSBvcHRpb25hbCBhcmd1bWVudCB3aWxsIGJlIHVzZWQgYXMgZm9ybWF0IHN0cmluZy4KIyAgICAzYikgQWx0ZXJuYXRpdmVseSwgaWYgeW91IGFyZSB1c2luZyBiYXNoLCBfX2dpdF9wczEgY2FuIGJlCiMgICAgICAgIHVzZWQgZm9yIFBST01QVF9DT01NQU5EIHdpdGggdHdvIHBhcmFtZXRlcnMsIDxwcmU+IGFuZAojICAgICAgICA8cG9zdD4sIHdoaWNoIGFyZSBzdHJpbmdzIHlvdSB3b3VsZCBwdXQgaW4gJFBTMSBiZWZvcmUKIyAgICAgICAgYW5kIGFmdGVyIHRoZSBzdGF0dXMgc3RyaW5nIGdlbmVyYXRlZCBieSB0aGUgZ2l0LXByb21wdAojICAgICAgICBtYWNoaW5lcnkuICBlLmcuCiMgICAgICAgICAgIFBST01QVF9DT01NQU5EPSdfX2dpdF9wczEgIlx1QFxoOlx3IiAiXFxcJCAiJwojICAgICAgICB3aWxsIHNob3cgdXNlcm5hbWUsIGF0LXNpZ24sIGhvc3QsIGNvbG9uLCBjd2QsIHRoZW4KIyAgICAgICAgdmFyaW91cyBzdGF0dXMgc3RyaW5nLCBmb2xsb3dlZCBieSBkb2xsYXIgYW5kIFNQLCBhcwojICAgICAgICB5b3VyIHByb21wdC4KIyAgICAgICAgT3B0aW9uYWxseSwgeW91IGNhbiBzdXBwbHkgYSB0aGlyZCBhcmd1bWVudCB3aXRoIGEgcHJpbnRmCiMgICAgICAgIGZvcm1hdCBzdHJpbmcgdG8gZmluZXR1bmUgdGhlIG91dHB1dCBvZiB0aGUgYnJhbmNoIHN0YXR1cwojCiMgVGhlIGFyZ3VtZW50IHRvIF9fZ2l0X3BzMSB3aWxsIGJlIGRpc3BsYXllZCBvbmx5IGlmIHlvdSBhcmUgY3VycmVudGx5CiMgaW4gYSBnaXQgcmVwb3NpdG9yeS4gIFRoZSAlcyB0b2tlbiB3aWxsIGJlIHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50CiMgYnJhbmNoLgojCiMgSW4gYWRkaXRpb24sIGlmIHlvdSBzZXQgR0lUX1BTMV9TSE9XRElSVFlTVEFURSB0byBhIG5vbmVtcHR5IHZhbHVlLAojIHVuc3RhZ2VkICgqKSBhbmQgc3RhZ2VkICgrKSBjaGFuZ2VzIHdpbGwgYmUgc2hvd24gbmV4dCB0byB0aGUgYnJhbmNoCiMgbmFtZS4gIFlvdSBjYW4gY29uZmlndXJlIHRoaXMgcGVyLXJlcG9zaXRvcnkgd2l0aCB0aGUKIyBiYXNoLnNob3dEaXJ0eVN0YXRlIHZhcmlhYmxlLCB3aGljaCBkZWZhdWx0cyB0byB0cnVlIG9uY2UKIyBHSVRfUFMxX1NIT1dESVJUWVNUQVRFIGlzIGVuYWJsZWQuCiMKIyBZb3UgY2FuIGFsc28gc2VlIGlmIGN1cnJlbnRseSBzb21ldGhpbmcgaXMgc3Rhc2hlZCwgYnkgc2V0dGluZwojIEdJVF9QUzFfU0hPV1NUQVNIU1RBVEUgdG8gYSBub25lbXB0eSB2YWx1ZS4gSWYgc29tZXRoaW5nIGlzIHN0YXNoZWQsCiMgdGhlbiBhICckJyB3aWxsIGJlIHNob3duIG5leHQgdG8gdGhlIGJyYW5jaCBuYW1lLgojCiMgSWYgeW91IHdvdWxkIGxpa2UgdG8gc2VlIGlmIHRoZXJlJ3JlIHVudHJhY2tlZCBmaWxlcywgdGhlbiB5b3UgY2FuIHNldAojIEdJVF9QUzFfU0hPV1VOVFJBQ0tFREZJTEVTIHRvIGEgbm9uZW1wdHkgdmFsdWUuIElmIHRoZXJlJ3JlIHVudHJhY2tlZAojIGZpbGVzLCB0aGVuIGEgJyUnIHdpbGwgYmUgc2hvd24gbmV4dCB0byB0aGUgYnJhbmNoIG5hbWUuCiMKIyBJZiB5b3Ugd291bGQgbGlrZSB0byBzZWUgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBIRUFEIGFuZCBpdHMgdXBzdHJlYW0sCiMgc2V0IEdJVF9QUzFfU0hPV1VQU1RSRUFNPSJhdXRvIi4gIEEgIjwiIGluZGljYXRlcyB5b3UgYXJlIGJlaGluZCwgIj4iCiMgaW5kaWNhdGVzIHlvdSBhcmUgYWhlYWQsICI8PiIgaW5kaWNhdGVzIHlvdSBoYXZlIGRpdmVyZ2VkIGFuZCAiPSIKIyBpbmRpY2F0ZXMgdGhhdCB0aGVyZSBpcyBubyBkaWZmZXJlbmNlLiBZb3UgY2FuIGZ1cnRoZXIgY29udHJvbAojIGJlaGF2aW91ciBieSBzZXR0aW5nIEdJVF9QUzFfU0hPV1VQU1RSRUFNIHRvIGEgc3BhY2Utc2VwYXJhdGVkIGxpc3QKIyBvZiB2YWx1ZXM6CiMKIyAgICAgdmVyYm9zZSAgICAgICBzaG93IG51bWJlciBvZiBjb21taXRzIGFoZWFkL2JlaGluZCAoKy8tKSB1cHN0cmVhbQojICAgICBsZWdhY3kgICAgICAgIGRvbid0IHVzZSB0aGUgJy0tY291bnQnIG9wdGlvbiBhdmFpbGFibGUgaW4gcmVjZW50CiMgICAgICAgICAgICAgICAgICAgdmVyc2lvbnMgb2YgZ2l0LXJldi1saXN0CiMgICAgIGdpdCAgICAgICAgICAgYWx3YXlzIGNvbXBhcmUgSEVBRCB0byBAe3Vwc3RyZWFtfQojICAgICBzdm4gICAgICAgICAgIGFsd2F5cyBjb21wYXJlIEhFQUQgdG8geW91ciBTVk4gdXBzdHJlYW0KIwojIEJ5IGRlZmF1bHQsIF9fZ2l0X3BzMSB3aWxsIGNvbXBhcmUgSEVBRCB0byB5b3VyIFNWTiB1cHN0cmVhbSBpZiBpdCBjYW4KIyBmaW5kIG9uZSwgb3IgQHt1cHN0cmVhbX0gb3RoZXJ3aXNlLiAgT25jZSB5b3UgaGF2ZSBzZXQKIyBHSVRfUFMxX1NIT1dVUFNUUkVBTSwgeW91IGNhbiBvdmVycmlkZSBpdCBvbiBhIHBlci1yZXBvc2l0b3J5IGJhc2lzIGJ5CiMgc2V0dGluZyB0aGUgYmFzaC5zaG93VXBzdHJlYW0gY29uZmlnIHZhcmlhYmxlLgojCiMgSWYgeW91IHdvdWxkIGxpa2UgYSBjb2xvcmVkIGhpbnQgYWJvdXQgdGhlIGN1cnJlbnQgZGlydHkgc3RhdGUsIHNldAojIEdJVF9QUzFfU0hPV0NPTE9SSElOVFMgdG8gYSBub25lbXB0eSB2YWx1ZS4gVGhlIGNvbG9ycyBhcmUgYmFzZWQgb24KIyB0aGUgY29sb3JlZCBvdXRwdXQgb2YgImdpdCBzdGF0dXMgLXNiIi4KIwojIF9fZ2l0ZGlyIGFjY2VwdHMgMCBvciAxIGFyZ3VtZW50cyAoaS5lLiwgbG9jYXRpb24pCiMgcmV0dXJucyBsb2NhdGlvbiBvZiAuZ2l0IHJlcG8KX19naXRkaXIgKCkKewoJIyBOb3RlOiB0aGlzIGZ1bmN0aW9uIGlzIGR1cGxpY2F0ZWQgaW4gZ2l0LWNvbXBsZXRpb24uYmFzaAoJIyBXaGVuIHVwZGF0aW5nIGl0LCBtYWtlIHN1cmUgeW91IHVwZGF0ZSB0aGUgb3RoZXIgb25lIHRvIG1hdGNoLgoJaWYgWyAteiAiJHsxLX0iIF07IHRoZW4KCQlpZiBbIC1uICIke19fZ2l0X2Rpci19IiBdOyB0aGVuCgkJCWVjaG8gIiRfX2dpdF9kaXIiCgkJZWxpZiBbIC1uICIke0dJVF9ESVItfSIgXTsgdGhlbgoJCQl0ZXN0IC1kICIke0dJVF9ESVItfSIgfHwgcmV0dXJuIDEKCQkJZWNobyAiJEdJVF9ESVIiCgkJZWxpZiBbIC1kIC5naXQgXTsgdGhlbgoJCQllY2hvIC5naXQKCQllbHNlCgkJCWdpdCByZXYtcGFyc2UgLS1naXQtZGlyIDI+L2Rldi9udWxsCgkJZmkKCWVsaWYgWyAtZCAiJDEvLmdpdCIgXTsgdGhlbgoJCWVjaG8gIiQxLy5naXQiCgllbHNlCgkJZWNobyAiJDEiCglmaQp9CgojIHN0b3JlcyB0aGUgZGl2ZXJnZW5jZSBmcm9tIHVwc3RyZWFtIGluICRwCiMgdXNlZCBieSBHSVRfUFMxX1NIT1dVUFNUUkVBTQpfX2dpdF9wczFfc2hvd191cHN0cmVhbSAoKQp7Cglsb2NhbCBrZXkgdmFsdWUKCWxvY2FsIHN2bl9yZW1vdGUgc3ZuX3VybF9wYXR0ZXJuIGNvdW50IG4KCWxvY2FsIHVwc3RyZWFtPWdpdCBsZWdhY3k9IiIgdmVyYm9zZT0iIgoKCXN2bl9yZW1vdGU9KCkKCSMgZ2V0IHNvbWUgY29uZmlnIG9wdGlvbnMgZnJvbSBnaXQtY29uZmlnCglsb2NhbCBvdXRwdXQ9IiQoZ2l0IGNvbmZpZyAteiAtLWdldC1yZWdleHAgJ14oc3ZuLXJlbW90ZVwuLipcLnVybHxiYXNoXC5zaG93dXBzdHJlYW0pJCcgMj4vZGV2L251bGwgfCB0ciAnXDBcbicgJ1xuICcpIgoJd2hpbGUgcmVhZCAtciBrZXkgdmFsdWU7IGRvCgkJY2FzZSAiJGtleSIgaW4KCQliYXNoLnNob3d1cHN0cmVhbSkKCQkJR0lUX1BTMV9TSE9XVVBTVFJFQU09IiR2YWx1ZSIKCQkJaWYgW1sgLXogIiR7R0lUX1BTMV9TSE9XVVBTVFJFQU19IiBdXTsgdGhlbgoJCQkJcD0iIgoJCQkJcmV0dXJuCgkJCWZpCgkJCTs7CgkJc3ZuLXJlbW90ZS4qLnVybCkKCQkJc3ZuX3JlbW90ZVsgJCgoJHsjc3ZuX3JlbW90ZVtAXX0gKyAxKSkgXT0iJHZhbHVlIgoJCQlzdm5fdXJsX3BhdHRlcm4rPSJcXHwkdmFsdWUiCgkJCXVwc3RyZWFtPXN2bitnaXQgIyBkZWZhdWx0IHVwc3RyZWFtIGlzIFNWTiBpZiBhdmFpbGFibGUsIGVsc2UgZ2l0CgkJCTs7CgkJZXNhYwoJZG9uZSA8PDwgIiRvdXRwdXQiCgoJIyBwYXJzZSBjb25maWd1cmF0aW9uIHZhbHVlcwoJZm9yIG9wdGlvbiBpbiAke0dJVF9QUzFfU0hPV1VQU1RSRUFNfTsgZG8KCQljYXNlICIkb3B0aW9uIiBpbgoJCWdpdHxzdm4pIHVwc3RyZWFtPSIkb3B0aW9uIiA7OwoJCXZlcmJvc2UpIHZlcmJvc2U9MSA7OwoJCWxlZ2FjeSkgIGxlZ2FjeT0xICA7OwoJCWVzYWMKCWRvbmUKCgkjIEZpbmQgb3VyIHVwc3RyZWFtCgljYXNlICIkdXBzdHJlYW0iIGluCglnaXQpICAgIHVwc3RyZWFtPSJAe3Vwc3RyZWFtfSIgOzsKCXN2biopCgkJIyBnZXQgdGhlIHVwc3RyZWFtIGZyb20gdGhlICJnaXQtc3ZuLWlkOiAuLi4iIGluIGEgY29tbWl0IG1lc3NhZ2UKCQkjIChnaXQtc3ZuIHVzZXMgZXNzZW50aWFsbHkgdGhlIHNhbWUgcHJvY2VkdXJlIGludGVybmFsbHkpCgkJbG9jYWwgc3ZuX3Vwc3RyZWFtPSgkKGdpdCBsb2cgLS1maXJzdC1wYXJlbnQgLTEgXAoJCQkJCS0tZ3JlcD0iXmdpdC1zdm4taWQ6IFwoJHtzdm5fdXJsX3BhdHRlcm4jPz99XCkiIDI+L2Rldi9udWxsKSkKCQlpZiBbWyAwIC1uZSAkeyNzdm5fdXBzdHJlYW1bQF19IF1dOyB0aGVuCgkJCXN2bl91cHN0cmVhbT0ke3N2bl91cHN0cmVhbVsgJHsjc3ZuX3Vwc3RyZWFtW0BdfSAtIDIgXX0KCQkJc3ZuX3Vwc3RyZWFtPSR7c3ZuX3Vwc3RyZWFtJUAqfQoJCQlsb2NhbCBuX3N0b3A9IiR7I3N2bl9yZW1vdGVbQF19IgoJCQlmb3IgKChuPTE7IG4gPD0gbl9zdG9wOyBuKyspKTsgZG8KCQkJCXN2bl91cHN0cmVhbT0ke3N2bl91cHN0cmVhbSMke3N2bl9yZW1vdGVbJG5dfX0KCQkJZG9uZQoKCQkJaWYgW1sgLXogIiRzdm5fdXBzdHJlYW0iIF1dOyB0aGVuCgkJCQkjIGRlZmF1bHQgYnJhbmNoIG5hbWUgZm9yIGNoZWNrb3V0cyB3aXRoIG5vIGxheW91dDoKCQkJCXVwc3RyZWFtPSR7R0lUX1NWTl9JRDotZ2l0LXN2bn0KCQkJZWxzZQoJCQkJdXBzdHJlYW09JHtzdm5fdXBzdHJlYW0jL30KCQkJZmkKCQllbGlmIFtbICJzdm4rZ2l0IiA9ICIkdXBzdHJlYW0iIF1dOyB0aGVuCgkJCXVwc3RyZWFtPSJAe3Vwc3RyZWFtfSIKCQlmaQoJCTs7Cgllc2FjCgoJIyBGaW5kIGhvdyBtYW55IGNvbW1pdHMgd2UgYXJlIGFoZWFkL2JlaGluZCBvdXIgdXBzdHJlYW0KCWlmIFtbIC16ICIkbGVnYWN5IiBdXTsgdGhlbgoJCWNvdW50PSIkKGdpdCByZXYtbGlzdCAtLWNvdW50IC0tbGVmdC1yaWdodCBcCgkJCQkiJHVwc3RyZWFtIi4uLkhFQUQgMj4vZGV2L251bGwpIgoJZWxzZQoJCSMgcHJvZHVjZSBlcXVpdmFsZW50IG91dHB1dCB0byAtLWNvdW50IGZvciBvbGRlciB2ZXJzaW9ucyBvZiBnaXQKCQlsb2NhbCBjb21taXRzCgkJaWYgY29tbWl0cz0iJChnaXQgcmV2LWxpc3QgLS1sZWZ0LXJpZ2h0ICIkdXBzdHJlYW0iLi4uSEVBRCAyPi9kZXYvbnVsbCkiCgkJdGhlbgoJCQlsb2NhbCBjb21taXQgYmVoaW5kPTAgYWhlYWQ9MAoJCQlmb3IgY29tbWl0IGluICRjb21taXRzCgkJCWRvCgkJCQljYXNlICIkY29tbWl0IiBpbgoJCQkJIjwiKikgKChiZWhpbmQrKykpIDs7CgkJCQkqKSAgICAoKGFoZWFkKyspKSAgOzsKCQkJCWVzYWMKCQkJZG9uZQoJCQljb3VudD0iJGJlaGluZAkkYWhlYWQiCgkJZWxzZQoJCQljb3VudD0iIgoJCWZpCglmaQoKCSMgY2FsY3VsYXRlIHRoZSByZXN1bHQKCWlmIFtbIC16ICIkdmVyYm9zZSIgXV07IHRoZW4KCQljYXNlICIkY291bnQiIGluCgkJIiIpICMgbm8gdXBzdHJlYW0KCQkJcD0iIiA7OwoJCSIwCTAiKSAjIGVxdWFsIHRvIHVwc3RyZWFtCgkJCXA9Ij0iIDs7CgkJIjAJIiopICMgYWhlYWQgb2YgdXBzdHJlYW0KCQkJcD0iPiIgOzsKCQkqIgkwIikgIyBiZWhpbmQgdXBzdHJlYW0KCQkJcD0iPCIgOzsKCQkqKQkgICAgIyBkaXZlcmdlZCBmcm9tIHVwc3RyZWFtCgkJCXA9Ijw+IiA7OwoJCWVzYWMKCWVsc2UKCQljYXNlICIkY291bnQiIGluCgkJIiIpICMgbm8gdXBzdHJlYW0KCQkJcD0iIiA7OwoJCSIwCTAiKSAjIGVxdWFsIHRvIHVwc3RyZWFtCgkJCXA9IiB1PSIgOzsKCQkiMAkiKikgIyBhaGVhZCBvZiB1cHN0cmVhbQoJCQlwPSIgdSske2NvdW50IzAJfSIgOzsKCQkqIgkwIikgIyBiZWhpbmQgdXBzdHJlYW0KCQkJcD0iIHUtJHtjb3VudCUJMH0iIDs7CgkJKikJICAgICMgZGl2ZXJnZWQgZnJvbSB1cHN0cmVhbQoJCQlwPSIgdSske2NvdW50IyoJfS0ke2NvdW50JQkqfSIgOzsKCQllc2FjCglmaQoKfQoKCiMgX19naXRfcHMxIGFjY2VwdHMgMCBvciAxIGFyZ3VtZW50cyAoaS5lLiwgZm9ybWF0IHN0cmluZykKIyB3aGVuIGNhbGxlZCBmcm9tIFBTMSB1c2luZyBjb21tYW5kIHN1YnN0aXR1dGlvbgojIGluIHRoaXMgbW9kZSBpdCBwcmludHMgdGV4dCB0byBhZGQgdG8gYmFzaCBQUzEgcHJvbXB0IChpbmNsdWRlcyBicmFuY2ggbmFtZSkKIwojIF9fZ2l0X3BzMSByZXF1aXJlcyAyIG9yIDMgYXJndW1lbnRzIHdoZW4gY2FsbGVkIGZyb20gUFJPTVBUX0NPTU1BTkQgKHBjKQojIGluIHRoYXQgY2FzZSBpdCBfc2V0c18gUFMxLiBUaGUgYXJndW1lbnRzIGFyZSBwYXJ0cyBvZiBhIFBTMSBzdHJpbmcuCiMgd2hlbiB0d28gYXJndW1lbnRzIGFyZSBnaXZlbiwgdGhlIGZpcnN0IGlzIHByZXBlbmRlZCBhbmQgdGhlIHNlY29uZCBhcHBlbmRlZAojIHRvIHRoZSBzdGF0ZSBzdHJpbmcgd2hlbiBhc3NpZ25lZCB0byBQUzEuCiMgVGhlIG9wdGlvbmFsIHRoaXJkIHBhcmFtZXRlciB3aWxsIGJlIHVzZWQgYXMgcHJpbnRmIGZvcm1hdCBzdHJpbmcgdG8gZnVydGhlcgojIGN1c3RvbWl6ZSB0aGUgb3V0cHV0IG9mIHRoZSBnaXQtc3RhdHVzIHN0cmluZy4KIyBJbiB0aGlzIG1vZGUgeW91IGNhbiByZXF1ZXN0IGNvbG9yZWQgaGludHMgdXNpbmcgR0lUX1BTMV9TSE9XQ09MT1JISU5UUz10cnVlCl9fZ2l0X3BzMSAoKQp7Cglsb2NhbCBwY21vZGU9bm8KCWxvY2FsIGRldGFjaGVkPW5vCglsb2NhbCBwczFwY19zdGFydD0nXHVAXGg6XHcgJwoJbG9jYWwgcHMxcGNfZW5kPSdcJCAnCglsb2NhbCBwcmludGZfZm9ybWF0PScgKCVzKScKCgljYXNlICIkIyIgaW4KCQkyfDMpCXBjbW9kZT15ZXMKCQkJcHMxcGNfc3RhcnQ9IiQxIgoJCQlwczFwY19lbmQ9IiQyIgoJCQlwcmludGZfZm9ybWF0PSIkezM6LSRwcmludGZfZm9ybWF0fSIKCQk7OwoJCTB8MSkJcHJpbnRmX2Zvcm1hdD0iJHsxOi0kcHJpbnRmX2Zvcm1hdH0iCgkJOzsKCQkqKQlyZXR1cm4KCQk7OwoJZXNhYwoKCWxvY2FsIGc9IiQoX19naXRkaXIpIgoJaWYgWyAteiAiJGciIF07IHRoZW4KCQlpZiBbICRwY21vZGUgPSB5ZXMgXTsgdGhlbgoJCQkjSW4gUEMgbW9kZSBQUzEgYWx3YXlzIG5lZWRzIHRvIGJlIHNldAoJCQlQUzE9IiRwczFwY19zdGFydCRwczFwY19lbmQiCgkJZmkKCWVsc2UKCQlsb2NhbCByPSIiCgkJbG9jYWwgYj0iIgoJCWlmIFsgLWYgIiRnL3JlYmFzZS1tZXJnZS9pbnRlcmFjdGl2ZSIgXTsgdGhlbgoJCQlyPSJ8UkVCQVNFLWkiCgkJCWI9IiQoY2F0ICIkZy9yZWJhc2UtbWVyZ2UvaGVhZC1uYW1lIikiCgkJZWxpZiBbIC1kICIkZy9yZWJhc2UtbWVyZ2UiIF07IHRoZW4KCQkJcj0ifFJFQkFTRS1tIgoJCQliPSIkKGNhdCAiJGcvcmViYXNlLW1lcmdlL2hlYWQtbmFtZSIpIgoJCWVsc2UKCQkJaWYgWyAtZCAiJGcvcmViYXNlLWFwcGx5IiBdOyB0aGVuCgkJCQlpZiBbIC1mICIkZy9yZWJhc2UtYXBwbHkvcmViYXNpbmciIF07IHRoZW4KCQkJCQlyPSJ8UkVCQVNFIgoJCQkJZWxpZiBbIC1mICIkZy9yZWJhc2UtYXBwbHkvYXBwbHlpbmciIF07IHRoZW4KCQkJCQlyPSJ8QU0iCgkJCQllbHNlCgkJCQkJcj0ifEFNL1JFQkFTRSIKCQkJCWZpCgkJCWVsaWYgWyAtZiAiJGcvTUVSR0VfSEVBRCIgXTsgdGhlbgoJCQkJcj0ifE1FUkdJTkciCgkJCWVsaWYgWyAtZiAiJGcvQ0hFUlJZX1BJQ0tfSEVBRCIgXTsgdGhlbgoJCQkJcj0ifENIRVJSWS1QSUNLSU5HIgoJCQllbGlmIFsgLWYgIiRnL0JJU0VDVF9MT0ciIF07IHRoZW4KCQkJCXI9InxCSVNFQ1RJTkciCgkJCWZpCgoJCQliPSIkKGdpdCBzeW1ib2xpYy1yZWYgSEVBRCAyPi9kZXYvbnVsbCkiIHx8IHsKCQkJCWRldGFjaGVkPXllcwoJCQkJYj0iJCgKCQkJCWNhc2UgIiR7R0lUX1BTMV9ERVNDUklCRV9TVFlMRS19IiBpbgoJCQkJKGNvbnRhaW5zKQoJCQkJCWdpdCBkZXNjcmliZSAtLWNvbnRhaW5zIEhFQUQgOzsKCQkJCShicmFuY2gpCgkJCQkJZ2l0IGRlc2NyaWJlIC0tY29udGFpbnMgLS1hbGwgSEVBRCA7OwoJCQkJKGRlc2NyaWJlKQoJCQkJCWdpdCBkZXNjcmliZSBIRUFEIDs7CgkJCQkoKiB8IGRlZmF1bHQpCgkJCQkJZ2l0IGRlc2NyaWJlIC0tdGFncyAtLWV4YWN0LW1hdGNoIEhFQUQgOzsKCQkJCWVzYWMgMj4vZGV2L251bGwpIiB8fAoKCQkJCWI9IiQoY3V0IC1jMS03ICIkZy9IRUFEIiAyPi9kZXYvbnVsbCkuLi4iIHx8CgkJCQliPSJ1bmtub3duIgoJCQkJYj0iKCRiKSIKCQkJfQoJCWZpCgoJCWxvY2FsIHc9IiIKCQlsb2NhbCBpPSIiCgkJbG9jYWwgcz0iIgoJCWxvY2FsIHU9IiIKCQlsb2NhbCBjPSIiCgkJbG9jYWwgcD0iIgoKCQlpZiBbICJ0cnVlIiA9ICIkKGdpdCByZXYtcGFyc2UgLS1pcy1pbnNpZGUtZ2l0LWRpciAyPi9kZXYvbnVsbCkiIF07IHRoZW4KCQkJaWYgWyAidHJ1ZSIgPSAiJChnaXQgcmV2LXBhcnNlIC0taXMtYmFyZS1yZXBvc2l0b3J5IDI+L2Rldi9udWxsKSIgXTsgdGhlbgoJCQkJYz0iQkFSRToiCgkJCWVsc2UKCQkJCWI9IkdJVF9ESVIhIgoJCQlmaQoJCWVsaWYgWyAidHJ1ZSIgPSAiJChnaXQgcmV2LXBhcnNlIC0taXMtaW5zaWRlLXdvcmstdHJlZSAyPi9kZXYvbnVsbCkiIF07IHRoZW4KCQkJaWYgWyAtbiAiJHtHSVRfUFMxX1NIT1dESVJUWVNUQVRFLX0iIF07IHRoZW4KCQkJCWlmIFsgIiQoZ2l0IGNvbmZpZyAtLWJvb2wgYmFzaC5zaG93RGlydHlTdGF0ZSkiICE9ICJmYWxzZSIgXTsgdGhlbgoJCQkJCWdpdCBkaWZmIC0tbm8tZXh0LWRpZmYgLS1xdWlldCAtLWV4aXQtY29kZSB8fCB3PSIqIgoJCQkJCWlmIGdpdCByZXYtcGFyc2UgLS1xdWlldCAtLXZlcmlmeSBIRUFEID4vZGV2L251bGw7IHRoZW4KCQkJCQkJZ2l0IGRpZmYtaW5kZXggLS1jYWNoZWQgLS1xdWlldCBIRUFEIC0tIHx8IGk9IisiCgkJCQkJZWxzZQoJCQkJCQlpPSIjIgoJCQkJCWZpCgkJCQlmaQoJCQlmaQoJCQlpZiBbIC1uICIke0dJVF9QUzFfU0hPV1NUQVNIU1RBVEUtfSIgXTsgdGhlbgoJCQkJZ2l0IHJldi1wYXJzZSAtLXZlcmlmeSByZWZzL3N0YXNoID4vZGV2L251bGwgMj4mMSAmJiBzPSIkIgoJCQlmaQoKCQkJaWYgWyAtbiAiJHtHSVRfUFMxX1NIT1dVTlRSQUNLRURGSUxFUy19IiBdOyB0aGVuCgkJCQlpZiBbIC1uICIkKGdpdCBscy1maWxlcyAtLW90aGVycyAtLWV4Y2x1ZGUtc3RhbmRhcmQpIiBdOyB0aGVuCgkJCQkJdT0iJSIKCQkJCWZpCgkJCWZpCgoJCQlpZiBbIC1uICIke0dJVF9QUzFfU0hPV1VQU1RSRUFNLX0iIF07IHRoZW4KCQkJCV9fZ2l0X3BzMV9zaG93X3Vwc3RyZWFtCgkJCWZpCgkJZmkKCgkJbG9jYWwgZj0iJHckaSRzJHUiCgkJaWYgWyAkcGNtb2RlID0geWVzIF07IHRoZW4KCQkJbG9jYWwgZ2l0c3RyaW5nPQoJCQlpZiBbIC1uICIke0dJVF9QUzFfU0hPV0NPTE9SSElOVFMtfSIgXTsgdGhlbgoJCQkJbG9jYWwgY19yZWQ9J1xlWzMxbScKCQkJCWxvY2FsIGNfZ3JlZW49J1xlWzMybScKCQkJCWxvY2FsIGNfbGJsdWU9J1xlWzE7MzRtJwoJCQkJbG9jYWwgY19jbGVhcj0nXGVbMG0nCgkJCQlsb2NhbCBiYWRfY29sb3I9JGNfcmVkCgkJCQlsb2NhbCBva19jb2xvcj0kY19ncmVlbgoJCQkJbG9jYWwgYnJhbmNoX2NvbG9yPSIkY19jbGVhciIKCQkJCWxvY2FsIGZsYWdzX2NvbG9yPSIkY19sYmx1ZSIKCQkJCWxvY2FsIGJyYW5jaHN0cmluZz0iJGMke2IjI3JlZnMvaGVhZHMvfSIKCgkJCQlpZiBbICRkZXRhY2hlZCA9IG5vIF07IHRoZW4KCQkJCQlicmFuY2hfY29sb3I9IiRva19jb2xvciIKCQkJCWVsc2UKCQkJCQlicmFuY2hfY29sb3I9IiRiYWRfY29sb3IiCgkJCQlmaQoKCQkJCSMgU2V0dGluZyBnaXRzdHJpbmcgZGlyZWN0bHkgd2l0aCBcWyBhbmQgXF0gYXJvdW5kIGNvbG9ycwoJCQkJIyBpcyBuZWNlc3NhcnkgdG8gcHJldmVudCB3cmFwcGluZyBpc3N1ZXMhCgkJCQlnaXRzdHJpbmc9IlxbJGJyYW5jaF9jb2xvclxdJGJyYW5jaHN0cmluZ1xbJGNfY2xlYXJcXSIKCgkJCQlpZiBbIC1uICIkdyRpJHMkdSRyJHAiIF07IHRoZW4KCQkJCQlnaXRzdHJpbmc9IiRnaXRzdHJpbmcgIgoJCQkJZmkKCQkJCWlmIFsgIiR3IiA9ICIqIiBdOyB0aGVuCgkJCQkJZ2l0c3RyaW5nPSIkZ2l0c3RyaW5nXFskYmFkX2NvbG9yXF0kdyIKCQkJCWZpCgkJCQlpZiBbIC1uICIkaSIgXTsgdGhlbgoJCQkJCWdpdHN0cmluZz0iJGdpdHN0cmluZ1xbJG9rX2NvbG9yXF0kaSIKCQkJCWZpCgkJCQlpZiBbIC1uICIkcyIgXTsgdGhlbgoJCQkJCWdpdHN0cmluZz0iJGdpdHN0cmluZ1xbJGZsYWdzX2NvbG9yXF0kcyIKCQkJCWZpCgkJCQlpZiBbIC1uICIkdSIgXTsgdGhlbgoJCQkJCWdpdHN0cmluZz0iJGdpdHN0cmluZ1xbJGJhZF9jb2xvclxdJHUiCgkJCQlmaQoJCQkJZ2l0c3RyaW5nPSIkZ2l0c3RyaW5nXFskY19jbGVhclxdJHIkcCIKCQkJZWxzZQoJCQkJZ2l0c3RyaW5nPSIkYyR7YiMjcmVmcy9oZWFkcy99JHtmOisgJGZ9JHIkcCIKCQkJZmkKCQkJZ2l0c3RyaW5nPSQocHJpbnRmIC0tICIkcHJpbnRmX2Zvcm1hdCIgIiRnaXRzdHJpbmciKQoJCQlQUzE9IiRwczFwY19zdGFydCRnaXRzdHJpbmckcHMxcGNfZW5kIgoJCWVsc2UKCQkJIyBOTyBjb2xvciBvcHRpb24gdW5sZXNzIGluIFBST01QVF9DT01NQU5EIG1vZGUKCQkJcHJpbnRmIC0tICIkcHJpbnRmX2Zvcm1hdCIgIiRjJHtiIyNyZWZzL2hlYWRzL30ke2Y6KyAkZn0kciRwIgoJCWZpCglmaQp9Cg==",
    "text": "# bash/zsh git prompt support\n#\n# Copyright (C) 2006,2007 Shawn O. Pearce <spearce@spearce.org>\n# Distributed under the GNU General Public License, version 2.0.\n#\n# This script allows you to see the current branch in your prompt.\n#\n# To enable:\n#\n#    1) Copy this file to somewhere (e.g. ~/.git-prompt.sh).\n#    2) Add the following line to your .bashrc/.zshrc:\n#        source ~/.git-prompt.sh\n#    3a) Change your PS1 to call __git_ps1 as\n#        command-substitution:\n#        Bash: PS1='[\\u@\\h \\W$(__git_ps1 \" (%s)\")]\\$ '\n#        ZSH:  PS1='[%n@%m %c$(__git_ps1 \" (%s)\")]\\$ '\n#        the optional argument will be used as format string.\n#    3b) Alternatively, if you are using bash, __git_ps1 can be\n#        used for PROMPT_COMMAND with two parameters, <pre> and\n#        <post>, which are strings you would put in $PS1 before\n#        and after the status string generated by the git-prompt\n#        machinery.  e.g.\n#           PROMPT_COMMAND='__git_ps1 \"\\u@\\h:\\w\" \"\\\\\\$ \"'\n#        will show username, at-sign, host, colon, cwd, then\n#        various status string, followed by dollar and SP, as\n#        your prompt.\n#        Optionally, you can supply a third argument with a printf\n#        format string to finetune the output of the branch status\n#\n# The argument to __git_ps1 will be displayed only if you are currently\n# in a git repository.  The %s token will be the name of the current\n# branch.\n#\n# In addition, if you set GIT_PS1_SHOWDIRTYSTATE to a nonempty value,\n# unstaged (*) and staged (+) changes will be shown next to the branch\n# name.  You can configure this per-repository with the\n# bash.showDirtyState variable, which defaults to true once\n# GIT_PS1_SHOWDIRTYSTATE is enabled.\n#\n# You can also see if currently something is stashed, by setting\n# GIT_PS1_SHOWSTASHSTATE to a nonempty value. If something is stashed,\n# then a '$' will be shown next to the branch name.\n#\n# If you would like to see if there're untracked files, then you can set\n# GIT_PS1_SHOWUNTRACKEDFILES to a nonempty value. If there're untracked\n# files, then a '%' will be shown next to the branch name.\n#\n# If you would like to see the difference between HEAD and its upstream,\n# set GIT_PS1_SHOWUPSTREAM=\"auto\".  A \"<\" indicates you are behind, \">\"\n# indicates you are ahead, \"<>\" indicates you have diverged and \"=\"\n# indicates that there is no difference. You can further control\n# behaviour by setting GIT_PS1_SHOWUPSTREAM to a space-separated list\n# of values:\n#\n#     verbose       show number of commits ahead/behind (+/-) upstream\n#     legacy        don't use the '--count' option available in recent\n#                   versions of git-rev-list\n#     git           always compare HEAD to @{upstream}\n#     svn           always compare HEAD to your SVN upstream\n#\n# By default, __git_ps1 will compare HEAD to your SVN upstream if it can\n# find one, or @{upstream} otherwise.  Once you have set\n# GIT_PS1_SHOWUPSTREAM, you can override it on a per-repository basis by\n# setting the bash.showUpstream config variable.\n#\n# If you would like a colored hint about the current dirty state, set\n# GIT_PS1_SHOWCOLORHINTS to a nonempty value. The colors are based on\n# the colored output of \"git status -sb\".\n#\n# __gitdir accepts 0 or 1 arguments (i.e., location)\n# returns location of .git repo\n__gitdir ()\n{\n\t# Note: this function is duplicated in git-completion.bash\n\t# When updating it, make sure you update the other one to match.\n\tif [ -z \"${1-}\" ]; then\n\t\tif [ -n \"${__git_dir-}\" ]; then\n\t\t\techo \"$__git_dir\"\n\t\telif [ -n \"${GIT_DIR-}\" ]; then\n\t\t\ttest -d \"${GIT_DIR-}\" || return 1\n\t\t\techo \"$GIT_DIR\"\n\t\telif [ -d .git ]; then\n\t\t\techo .git\n\t\telse\n\t\t\tgit rev-parse --git-dir 2>/dev/null\n\t\tfi\n\telif [ -d \"$1/.git\" ]; then\n\t\techo \"$1/.git\"\n\telse\n\t\techo \"$1\"\n\tfi\n}\n\n# stores the divergence from upstream in $p\n# used by GIT_PS1_SHOWUPSTREAM\n__git_ps1_show_upstream ()\n{\n\tlocal key value\n\tlocal svn_remote svn_url_pattern count n\n\tlocal upstream=git legacy=\"\" verbose=\"\"\n\n\tsvn_remote=()\n\t# get some config options from git-config\n\tlocal output=\"$(git config -z --get-regexp '^(svn-remote\\..*\\.url|bash\\.showupstream)$' 2>/dev/null | tr '\\0\\n' '\\n ')\"\n\twhile read -r key value; do\n\t\tcase \"$key\" in\n\t\tbash.showupstream)\n\t\t\tGIT_PS1_SHOWUPSTREAM=\"$value\"\n\t\t\tif [[ -z \"${GIT_PS1_SHOWUPSTREAM}\" ]]; then\n\t\t\t\tp=\"\"\n\t\t\t\treturn\n\t\t\tfi\n\t\t\t;;\n\t\tsvn-remote.*.url)\n\t\t\tsvn_remote[ $((${#svn_remote[@]} + 1)) ]=\"$value\"\n\t\t\tsvn_url_pattern+=\"\\\\|$value\"\n\t\t\tupstream=svn+git # default upstream is SVN if available, else git\n\t\t\t;;\n\t\tesac\n\tdone <<< \"$output\"\n\n\t# parse configuration values\n\tfor option in ${GIT_PS1_SHOWUPSTREAM}; do\n\t\tcase \"$option\" in\n\t\tgit|svn) upstream=\"$option\" ;;\n\t\tverbose) verbose=1 ;;\n\t\tlegacy)  legacy=1  ;;\n\t\tesac\n\tdone\n\n\t# Find our upstream\n\tcase \"$upstream\" in\n\tgit)    upstream=\"@{upstream}\" ;;\n\tsvn*)\n\t\t# get the upstream from the \"git-svn-id: ...\" in a commit message\n\t\t# (git-svn uses essentially the same procedure internally)\n\t\tlocal svn_upstream=($(git log --first-parent -1 \\\n\t\t\t\t\t--grep=\"^git-svn-id: \\(${svn_url_pattern#??}\\)\" 2>/dev/null))\n\t\tif [[ 0 -ne ${#svn_upstream[@]} ]]; then\n\t\t\tsvn_upstream=${svn_upstream[ ${#svn_upstream[@]} - 2 ]}\n\t\t\tsvn_upstream=${svn_upstream%@*}\n\t\t\tlocal n_stop=\"${#svn_remote[@]}\"\n\t\t\tfor ((n=1; n <= n_stop; n++)); do\n\t\t\t\tsvn_upstream=${svn_upstream#${svn_remote[$n]}}\n\t\t\tdone\n\n\t\t\tif [[ -z \"$svn_upstream\" ]]; then\n\t\t\t\t# default branch name for checkouts with no layout:\n\t\t\t\tupstream=${GIT_SVN_ID:-git-svn}\n\t\t\telse\n\t\t\t\tupstream=${svn_upstream#/}\n\t\t\tfi\n\t\telif [[ \"svn+git\" = \"$upstream\" ]]; then\n\t\t\tupstream=\"@{upstream}\"\n\t\tfi\n\t\t;;\n\tesac\n\n\t# Find how many commits we are ahead/behind our upstream\n\tif [[ -z \"$legacy\" ]]; then\n\t\tcount=\"$(git rev-list --count --left-right \\\n\t\t\t\t\"$upstream\"...HEAD 2>/dev/null)\"\n\telse\n\t\t# produce equivalent output to --count for older versions of git\n\t\tlocal commits\n\t\tif commits=\"$(git rev-list --left-right \"$upstream\"...HEAD 2>/dev/null)\"\n\t\tthen\n\t\t\tlocal commit behind=0 ahead=0\n\t\t\tfor commit in $commits\n\t\t\tdo\n\t\t\t\tcase \"$commit\" in\n\t\t\t\t\"<\"*) ((behind++)) ;;\n\t\t\t\t*)    ((ahead++))  ;;\n\t\t\t\tesac\n\t\t\tdone\n\t\t\tcount=\"$behind\t$ahead\"\n\t\telse\n\t\t\tcount=\"\"\n\t\tfi\n\tfi\n\n\t# calculate the result\n\tif [[ -z \"$verbose\" ]]; then\n\t\tcase \"$count\" in\n\t\t\"\") # no upstream\n\t\t\tp=\"\" ;;\n\t\t\"0\t0\") # equal to upstream\n\t\t\tp=\"=\" ;;\n\t\t\"0\t\"*) # ahead of upstream\n\t\t\tp=\">\" ;;\n\t\t*\"\t0\") # behind upstream\n\t\t\tp=\"<\" ;;\n\t\t*)\t    # diverged from upstream\n\t\t\tp=\"<>\" ;;\n\t\tesac\n\telse\n\t\tcase \"$count\" in\n\t\t\"\") # no upstream\n\t\t\tp=\"\" ;;\n\t\t\"0\t0\") # equal to upstream\n\t\t\tp=\" u=\" ;;\n\t\t\"0\t\"*) # ahead of upstream\n\t\t\tp=\" u+${count#0\t}\" ;;\n\t\t*\"\t0\") # behind upstream\n\t\t\tp=\" u-${count%\t0}\" ;;\n\t\t*)\t    # diverged from upstream\n\t\t\tp=\" u+${count#*\t}-${count%\t*}\" ;;\n\t\tesac\n\tfi\n\n}\n\n\n# __git_ps1 accepts 0 or 1 arguments (i.e., format string)\n# when called from PS1 using command substitution\n# in this mode it prints text to add to bash PS1 prompt (includes branch name)\n#\n# __git_ps1 requires 2 or 3 arguments when called from PROMPT_COMMAND (pc)\n# in that case it _sets_ PS1. The arguments are parts of a PS1 string.\n# when two arguments are given, the first is prepended and the second appended\n# to the state string when assigned to PS1.\n# The optional third parameter will be used as printf format string to further\n# customize the output of the git-status string.\n# In this mode you can request colored hints using GIT_PS1_SHOWCOLORHINTS=true\n__git_ps1 ()\n{\n\tlocal pcmode=no\n\tlocal detached=no\n\tlocal ps1pc_start='\\u@\\h:\\w '\n\tlocal ps1pc_end='\\$ '\n\tlocal printf_format=' (%s)'\n\n\tcase \"$#\" in\n\t\t2|3)\tpcmode=yes\n\t\t\tps1pc_start=\"$1\"\n\t\t\tps1pc_end=\"$2\"\n\t\t\tprintf_format=\"${3:-$printf_format}\"\n\t\t;;\n\t\t0|1)\tprintf_format=\"${1:-$printf_format}\"\n\t\t;;\n\t\t*)\treturn\n\t\t;;\n\tesac\n\n\tlocal g=\"$(__gitdir)\"\n\tif [ -z \"$g\" ]; then\n\t\tif [ $pcmode = yes ]; then\n\t\t\t#In PC mode PS1 always needs to be set\n\t\t\tPS1=\"$ps1pc_start$ps1pc_end\"\n\t\tfi\n\telse\n\t\tlocal r=\"\"\n\t\tlocal b=\"\"\n\t\tif [ -f \"$g/rebase-merge/interactive\" ]; then\n\t\t\tr=\"|REBASE-i\"\n\t\t\tb=\"$(cat \"$g/rebase-merge/head-name\")\"\n\t\telif [ -d \"$g/rebase-merge\" ]; then\n\t\t\tr=\"|REBASE-m\"\n\t\t\tb=\"$(cat \"$g/rebase-merge/head-name\")\"\n\t\telse\n\t\t\tif [ -d \"$g/rebase-apply\" ]; then\n\t\t\t\tif [ -f \"$g/rebase-apply/rebasing\" ]; then\n\t\t\t\t\tr=\"|REBASE\"\n\t\t\t\telif [ -f \"$g/rebase-apply/applying\" ]; then\n\t\t\t\t\tr=\"|AM\"\n\t\t\t\telse\n\t\t\t\t\tr=\"|AM/REBASE\"\n\t\t\t\tfi\n\t\t\telif [ -f \"$g/MERGE_HEAD\" ]; then\n\t\t\t\tr=\"|MERGING\"\n\t\t\telif [ -f \"$g/CHERRY_PICK_HEAD\" ]; then\n\t\t\t\tr=\"|CHERRY-PICKING\"\n\t\t\telif [ -f \"$g/BISECT_LOG\" ]; then\n\t\t\t\tr=\"|BISECTING\"\n\t\t\tfi\n\n\t\t\tb=\"$(git symbolic-ref HEAD 2>/dev/null)\" || {\n\t\t\t\tdetached=yes\n\t\t\t\tb=\"$(\n\t\t\t\tcase \"${GIT_PS1_DESCRIBE_STYLE-}\" in\n\t\t\t\t(contains)\n\t\t\t\t\tgit describe --contains HEAD ;;\n\t\t\t\t(branch)\n\t\t\t\t\tgit describe --contains --all HEAD ;;\n\t\t\t\t(describe)\n\t\t\t\t\tgit describe HEAD ;;\n\t\t\t\t(* | default)\n\t\t\t\t\tgit describe --tags --exact-match HEAD ;;\n\t\t\t\tesac 2>/dev/null)\" ||\n\n\t\t\t\tb=\"$(cut -c1-7 \"$g/HEAD\" 2>/dev/null)...\" ||\n\t\t\t\tb=\"unknown\"\n\t\t\t\tb=\"($b)\"\n\t\t\t}\n\t\tfi\n\n\t\tlocal w=\"\"\n\t\tlocal i=\"\"\n\t\tlocal s=\"\"\n\t\tlocal u=\"\"\n\t\tlocal c=\"\"\n\t\tlocal p=\"\"\n\n\t\tif [ \"true\" = \"$(git rev-parse --is-inside-git-dir 2>/dev/null)\" ]; then\n\t\t\tif [ \"true\" = \"$(git rev-parse --is-bare-repository 2>/dev/null)\" ]; then\n\t\t\t\tc=\"BARE:\"\n\t\t\telse\n\t\t\t\tb=\"GIT_DIR!\"\n\t\t\tfi\n\t\telif [ \"true\" = \"$(git rev-parse --is-inside-work-tree 2>/dev/null)\" ]; then\n\t\t\tif [ -n \"${GIT_PS1_SHOWDIRTYSTATE-}\" ]; then\n\t\t\t\tif [ \"$(git config --bool bash.showDirtyState)\" != \"false\" ]; then\n\t\t\t\t\tgit diff --no-ext-diff --quiet --exit-code || w=\"*\"\n\t\t\t\t\tif git rev-parse --quiet --verify HEAD >/dev/null; then\n\t\t\t\t\t\tgit diff-index --cached --quiet HEAD -- || i=\"+\"\n\t\t\t\t\telse\n\t\t\t\t\t\ti=\"#\"\n\t\t\t\t\tfi\n\t\t\t\tfi\n\t\t\tfi\n\t\t\tif [ -n \"${GIT_PS1_SHOWSTASHSTATE-}\" ]; then\n\t\t\t\tgit rev-parse --verify refs/stash >/dev/null 2>&1 && s=\"$\"\n\t\t\tfi\n\n\t\t\tif [ -n \"${GIT_PS1_SHOWUNTRACKEDFILES-}\" ]; then\n\t\t\t\tif [ -n \"$(git ls-files --others --exclude-standard)\" ]; then\n\t\t\t\t\tu=\"%\"\n\t\t\t\tfi\n\t\t\tfi\n\n\t\t\tif [ -n \"${GIT_PS1_SHOWUPSTREAM-}\" ]; then\n\t\t\t\t__git_ps1_show_upstream\n\t\t\tfi\n\t\tfi\n\n\t\tlocal f=\"$w$i$s$u\"\n\t\tif [ $pcmode = yes ]; then\n\t\t\tlocal gitstring=\n\t\t\tif [ -n \"${GIT_PS1_SHOWCOLORHINTS-}\" ]; then\n\t\t\t\tlocal c_red='\\e[31m'\n\t\t\t\tlocal c_green='\\e[32m'\n\t\t\t\tlocal c_lblue='\\e[1;34m'\n\t\t\t\tlocal c_clear='\\e[0m'\n\t\t\t\tlocal bad_color=$c_red\n\t\t\t\tlocal ok_color=$c_green\n\t\t\t\tlocal branch_color=\"$c_clear\"\n\t\t\t\tlocal flags_color=\"$c_lblue\"\n\t\t\t\tlocal branchstring=\"$c${b##refs/heads/}\"\n\n\t\t\t\tif [ $detached = no ]; then\n\t\t\t\t\tbranch_color=\"$ok_color\"\n\t\t\t\telse\n\t\t\t\t\tbranch_color=\"$bad_color\"\n\t\t\t\tfi\n\n\t\t\t\t# Setting gitstring directly with \\[ and \\] around colors\n\t\t\t\t# is necessary to prevent wrapping issues!\n\t\t\t\tgitstring=\"\\[$branch_color\\]$branchstring\\[$c_clear\\]\"\n\n\t\t\t\tif [ -n \"$w$i$s$u$r$p\" ]; then\n\t\t\t\t\tgitstring=\"$gitstring \"\n\t\t\t\tfi\n\t\t\t\tif [ \"$w\" = \"*\" ]; then\n\t\t\t\t\tgitstring=\"$gitstring\\[$bad_color\\]$w\"\n\t\t\t\tfi\n\t\t\t\tif [ -n \"$i\" ]; then\n\t\t\t\t\tgitstring=\"$gitstring\\[$ok_color\\]$i\"\n\t\t\t\tfi\n\t\t\t\tif [ -n \"$s\" ]; then\n\t\t\t\t\tgitstring=\"$gitstring\\[$flags_color\\]$s\"\n\t\t\t\tfi\n\t\t\t\tif [ -n \"$u\" ]; then\n\t\t\t\t\tgitstring=\"$gitstring\\[$bad_color\\]$u\"\n\t\t\t\tfi\n\t\t\t\tgitstring=\"$gitstring\\[$c_clear\\]$r$p\"\n\t\t\telse\n\t\t\t\tgitstring=\"$c${b##refs/heads/}${f:+ $f}$r$p\"\n\t\t\tfi\n\t\t\tgitstring=$(printf -- \"$printf_format\" \"$gitstring\")\n\t\t\tPS1=\"$ps1pc_start$gitstring$ps1pc_end\"\n\t\telse\n\t\t\t# NO color option unless in PROMPT_COMMAND mode\n\t\t\tprintf -- \"$printf_format\" \"$c${b##refs/heads/}${f:+ $f}$r$p\"\n\t\tfi\n\tfi\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0086bf18644d81ddb7b161142cc31a30dad1711e",
  "sha1_ok": true,
  "size": 11359
}
