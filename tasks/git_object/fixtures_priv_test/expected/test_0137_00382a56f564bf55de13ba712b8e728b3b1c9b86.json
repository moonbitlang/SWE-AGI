{
  "content": {
    "base64": "LyoKICogQnVpbHRpbiAiZ2l0IHRhZyIKICoKICogQ29weXJpZ2h0IChjKSAyMDA3IEtyaXN0aWFuIEjDuGdzYmVyZyA8a3JoQHJlZGhhdC5jb20+LAogKiAgICAgICAgICAgICAgICAgICAgQ2FybG9zIFJpY2EgPGphc2FtcGxlckBnbWFpbC5jb20+CiAqIEJhc2VkIG9uIGdpdC10YWcuc2ggYW5kIG1rdGFnLmMgYnkgTGludXMgVG9ydmFsZHMuCiAqLwoKI2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJjb25maWcuaCIKI2luY2x1ZGUgImJ1aWx0aW4uaCIKI2luY2x1ZGUgInJlZnMuaCIKI2luY2x1ZGUgInRhZy5oIgojaW5jbHVkZSAicnVuLWNvbW1hbmQuaCIKI2luY2x1ZGUgInBhcnNlLW9wdGlvbnMuaCIKI2luY2x1ZGUgImRpZmYuaCIKI2luY2x1ZGUgInJldmlzaW9uLmgiCiNpbmNsdWRlICJncGctaW50ZXJmYWNlLmgiCiNpbmNsdWRlICJzaGExLWFycmF5LmgiCiNpbmNsdWRlICJjb2x1bW4uaCIKI2luY2x1ZGUgInJlZi1maWx0ZXIuaCIKCnN0YXRpYyBjb25zdCBjaGFyICogY29uc3QgZ2l0X3RhZ191c2FnZVtdID0gewoJTl8oImdpdCB0YWcgWy1hIHwgLXMgfCAtdSA8a2V5LWlkPl0gWy1mXSBbLW0gPG1zZz4gfCAtRiA8ZmlsZT5dIDx0YWduYW1lPiBbPGhlYWQ+XSIpLAoJTl8oImdpdCB0YWcgLWQgPHRhZ25hbWU+Li4uIiksCglOXygiZ2l0IHRhZyAtbCBbLW5bPG51bT5dXSBbLS1jb250YWlucyA8Y29tbWl0Pl0gWy0tbm8tY29udGFpbnMgPGNvbW1pdD5dIFstLXBvaW50cy1hdCA8b2JqZWN0Pl0iCgkJIlxuXHRcdFstLWZvcm1hdD08Zm9ybWF0Pl0gWy0tW25vLV1tZXJnZWQgWzxjb21taXQ+XV0gWzxwYXR0ZXJuPi4uLl0iKSwKCU5fKCJnaXQgdGFnIC12IFstLWZvcm1hdD08Zm9ybWF0Pl0gPHRhZ25hbWU+Li4uIiksCglOVUxMCn07CgpzdGF0aWMgdW5zaWduZWQgaW50IGNvbG9wdHM7CnN0YXRpYyBpbnQgZm9yY2Vfc2lnbl9hbm5vdGF0ZTsKCnN0YXRpYyBpbnQgbGlzdF90YWdzKHN0cnVjdCByZWZfZmlsdGVyICpmaWx0ZXIsIHN0cnVjdCByZWZfc29ydGluZyAqc29ydGluZywKCQkgICAgIHN0cnVjdCByZWZfZm9ybWF0ICpmb3JtYXQpCnsKCXN0cnVjdCByZWZfYXJyYXkgYXJyYXk7CgljaGFyICp0b19mcmVlID0gTlVMTDsKCWludCBpOwoKCW1lbXNldCgmYXJyYXksIDAsIHNpemVvZihhcnJheSkpOwoKCWlmIChmaWx0ZXItPmxpbmVzID09IC0xKQoJCWZpbHRlci0+bGluZXMgPSAwOwoKCWlmICghZm9ybWF0LT5mb3JtYXQpIHsKCQlpZiAoZmlsdGVyLT5saW5lcykgewoJCQl0b19mcmVlID0geHN0cmZtdCgiJXMgJSUoY29udGVudHM6bGluZXM9JWQpIiwKCQkJCQkgICIlKGFsaWduOjE1KSUocmVmbmFtZTpsc3RyaXA9MiklKGVuZCkiLAoJCQkJCSAgZmlsdGVyLT5saW5lcyk7CgkJCWZvcm1hdC0+Zm9ybWF0ID0gdG9fZnJlZTsKCQl9IGVsc2UKCQkJZm9ybWF0LT5mb3JtYXQgPSAiJShyZWZuYW1lOmxzdHJpcD0yKSI7Cgl9CgoJaWYgKHZlcmlmeV9yZWZfZm9ybWF0KGZvcm1hdCkpCgkJZGllKF8oInVuYWJsZSB0byBwYXJzZSBmb3JtYXQgc3RyaW5nIikpOwoJZmlsdGVyLT53aXRoX2NvbW1pdF90YWdfYWxnbyA9IDE7CglmaWx0ZXJfcmVmcygmYXJyYXksIGZpbHRlciwgRklMVEVSX1JFRlNfVEFHUyk7CglyZWZfYXJyYXlfc29ydChzb3J0aW5nLCAmYXJyYXkpOwoKCWZvciAoaSA9IDA7IGkgPCBhcnJheS5ucjsgaSsrKQoJCXNob3dfcmVmX2FycmF5X2l0ZW0oYXJyYXkuaXRlbXNbaV0sIGZvcm1hdCk7CglyZWZfYXJyYXlfY2xlYXIoJmFycmF5KTsKCWZyZWUodG9fZnJlZSk7CgoJcmV0dXJuIDA7Cn0KCnR5cGVkZWYgaW50ICgqZWFjaF90YWdfbmFtZV9mbikoY29uc3QgY2hhciAqbmFtZSwgY29uc3QgY2hhciAqcmVmLAoJCQkJY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLCBjb25zdCB2b2lkICpjYl9kYXRhKTsKCnN0YXRpYyBpbnQgZm9yX2VhY2hfdGFnX25hbWUoY29uc3QgY2hhciAqKmFyZ3YsIGVhY2hfdGFnX25hbWVfZm4gZm4sCgkJCSAgICAgY29uc3Qgdm9pZCAqY2JfZGF0YSkKewoJY29uc3QgY2hhciAqKnA7CglzdHJ1Y3Qgc3RyYnVmIHJlZiA9IFNUUkJVRl9JTklUOwoJaW50IGhhZF9lcnJvciA9IDA7CglzdHJ1Y3Qgb2JqZWN0X2lkIG9pZDsKCglmb3IgKHAgPSBhcmd2OyAqcDsgcCsrKSB7CgkJc3RyYnVmX3Jlc2V0KCZyZWYpOwoJCXN0cmJ1Zl9hZGRmKCZyZWYsICJyZWZzL3RhZ3MvJXMiLCAqcCk7CgkJaWYgKHJlYWRfcmVmKHJlZi5idWYsIG9pZC5oYXNoKSkgewoJCQllcnJvcihfKCJ0YWcgJyVzJyBub3QgZm91bmQuIiksICpwKTsKCQkJaGFkX2Vycm9yID0gMTsKCQkJY29udGludWU7CgkJfQoJCWlmIChmbigqcCwgcmVmLmJ1ZiwgJm9pZCwgY2JfZGF0YSkpCgkJCWhhZF9lcnJvciA9IDE7Cgl9CglzdHJidWZfcmVsZWFzZSgmcmVmKTsKCXJldHVybiBoYWRfZXJyb3I7Cn0KCnN0YXRpYyBpbnQgZGVsZXRlX3RhZyhjb25zdCBjaGFyICpuYW1lLCBjb25zdCBjaGFyICpyZWYsCgkJICAgICAgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLCBjb25zdCB2b2lkICpjYl9kYXRhKQp7CglpZiAoZGVsZXRlX3JlZihOVUxMLCByZWYsIG9pZC0+aGFzaCwgMCkpCgkJcmV0dXJuIDE7CglwcmludGYoXygiRGVsZXRlZCB0YWcgJyVzJyAod2FzICVzKVxuIiksIG5hbWUsIGZpbmRfdW5pcXVlX2FiYnJldihvaWQtPmhhc2gsIERFRkFVTFRfQUJCUkVWKSk7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCB2ZXJpZnlfdGFnKGNvbnN0IGNoYXIgKm5hbWUsIGNvbnN0IGNoYXIgKnJlZiwKCQkgICAgICBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsIGNvbnN0IHZvaWQgKmNiX2RhdGEpCnsKCWludCBmbGFnczsKCWNvbnN0IHN0cnVjdCByZWZfZm9ybWF0ICpmb3JtYXQgPSBjYl9kYXRhOwoJZmxhZ3MgPSBHUEdfVkVSSUZZX1ZFUkJPU0U7CgoJaWYgKGZvcm1hdC0+Zm9ybWF0KQoJCWZsYWdzID0gR1BHX1ZFUklGWV9PTUlUX1NUQVRVUzsKCglpZiAoZ3BnX3ZlcmlmeV90YWcob2lkLT5oYXNoLCBuYW1lLCBmbGFncykpCgkJcmV0dXJuIC0xOwoKCWlmIChmb3JtYXQtPmZvcm1hdCkKCQlwcmV0dHlfcHJpbnRfcmVmKG5hbWUsIG9pZC0+aGFzaCwgZm9ybWF0KTsKCglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBkb19zaWduKHN0cnVjdCBzdHJidWYgKmJ1ZmZlcikKewoJcmV0dXJuIHNpZ25fYnVmZmVyKGJ1ZmZlciwgYnVmZmVyLCBnZXRfc2lnbmluZ19rZXkoKSk7Cn0KCnN0YXRpYyBjb25zdCBjaGFyIHRhZ190ZW1wbGF0ZVtdID0KCU5fKCJcbldyaXRlIGEgbWVzc2FnZSBmb3IgdGFnOlxuICAlc1xuIgoJIkxpbmVzIHN0YXJ0aW5nIHdpdGggJyVjJyB3aWxsIGJlIGlnbm9yZWQuXG4iKTsKCnN0YXRpYyBjb25zdCBjaGFyIHRhZ190ZW1wbGF0ZV9ub2NsZWFudXBbXSA9CglOXygiXG5Xcml0ZSBhIG1lc3NhZ2UgZm9yIHRhZzpcbiAgJXNcbiIKCSJMaW5lcyBzdGFydGluZyB3aXRoICclYycgd2lsbCBiZSBrZXB0OyB5b3UgbWF5IHJlbW92ZSB0aGVtIgoJIiB5b3Vyc2VsZiBpZiB5b3Ugd2FudCB0by5cbiIpOwoKc3RhdGljIGludCBnaXRfdGFnX2NvbmZpZyhjb25zdCBjaGFyICp2YXIsIGNvbnN0IGNoYXIgKnZhbHVlLCB2b2lkICpjYikKewoJaW50IHN0YXR1czsKCXN0cnVjdCByZWZfc29ydGluZyAqKnNvcnRpbmdfdGFpbCA9IChzdHJ1Y3QgcmVmX3NvcnRpbmcgKiopY2I7CgoJaWYgKCFzdHJjbXAodmFyLCAidGFnLnNvcnQiKSkgewoJCWlmICghdmFsdWUpCgkJCXJldHVybiBjb25maWdfZXJyb3Jfbm9uYm9vbCh2YXIpOwoJCXBhcnNlX3JlZl9zb3J0aW5nKHNvcnRpbmdfdGFpbCwgdmFsdWUpOwoJCXJldHVybiAwOwoJfQoKCXN0YXR1cyA9IGdpdF9ncGdfY29uZmlnKHZhciwgdmFsdWUsIGNiKTsKCWlmIChzdGF0dXMpCgkJcmV0dXJuIHN0YXR1czsKCWlmICghc3RyY21wKHZhciwgInRhZy5mb3JjZXNpZ25hbm5vdGF0ZWQiKSkgewoJCWZvcmNlX3NpZ25fYW5ub3RhdGUgPSBnaXRfY29uZmlnX2Jvb2wodmFyLCB2YWx1ZSk7CgkJcmV0dXJuIDA7Cgl9CgoJaWYgKHN0YXJ0c193aXRoKHZhciwgImNvbHVtbi4iKSkKCQlyZXR1cm4gZ2l0X2NvbHVtbl9jb25maWcodmFyLCB2YWx1ZSwgInRhZyIsICZjb2xvcHRzKTsKCXJldHVybiBnaXRfY29sb3JfZGVmYXVsdF9jb25maWcodmFyLCB2YWx1ZSwgY2IpOwp9CgpzdGF0aWMgdm9pZCB3cml0ZV90YWdfYm9keShpbnQgZmQsIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCkKewoJdW5zaWduZWQgbG9uZyBzaXplOwoJZW51bSBvYmplY3RfdHlwZSB0eXBlOwoJY2hhciAqYnVmLCAqc3A7CgoJYnVmID0gcmVhZF9zaGExX2ZpbGUob2lkLT5oYXNoLCAmdHlwZSwgJnNpemUpOwoJaWYgKCFidWYpCgkJcmV0dXJuOwoJLyogc2tpcCBoZWFkZXIgKi8KCXNwID0gc3Ryc3RyKGJ1ZiwgIlxuXG4iKTsKCglpZiAoIXNwIHx8ICFzaXplIHx8IHR5cGUgIT0gT0JKX1RBRykgewoJCWZyZWUoYnVmKTsKCQlyZXR1cm47Cgl9CglzcCArPSAyOyAvKiBza2lwIHRoZSAyIExGcyAqLwoJd3JpdGVfb3JfZGllKGZkLCBzcCwgcGFyc2Vfc2lnbmF0dXJlKHNwLCBidWYgKyBzaXplIC0gc3ApKTsKCglmcmVlKGJ1Zik7Cn0KCnN0YXRpYyBpbnQgYnVpbGRfdGFnX29iamVjdChzdHJ1Y3Qgc3RyYnVmICpidWYsIGludCBzaWduLCBzdHJ1Y3Qgb2JqZWN0X2lkICpyZXN1bHQpCnsKCWlmIChzaWduICYmIGRvX3NpZ24oYnVmKSA8IDApCgkJcmV0dXJuIGVycm9yKF8oInVuYWJsZSB0byBzaWduIHRoZSB0YWciKSk7CglpZiAod3JpdGVfc2hhMV9maWxlKGJ1Zi0+YnVmLCBidWYtPmxlbiwgdGFnX3R5cGUsIHJlc3VsdC0+aGFzaCkgPCAwKQoJCXJldHVybiBlcnJvcihfKCJ1bmFibGUgdG8gd3JpdGUgdGFnIGZpbGUiKSk7CglyZXR1cm4gMDsKfQoKc3RydWN0IGNyZWF0ZV90YWdfb3B0aW9ucyB7Cgl1bnNpZ25lZCBpbnQgbWVzc2FnZV9naXZlbjoxOwoJdW5zaWduZWQgaW50IHNpZ247CgllbnVtIHsKCQlDTEVBTlVQX05PTkUsCgkJQ0xFQU5VUF9TUEFDRSwKCQlDTEVBTlVQX0FMTAoJfSBjbGVhbnVwX21vZGU7Cn07CgpzdGF0aWMgdm9pZCBjcmVhdGVfdGFnKGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9iamVjdCwgY29uc3QgY2hhciAqdGFnLAoJCSAgICAgICBzdHJ1Y3Qgc3RyYnVmICpidWYsIHN0cnVjdCBjcmVhdGVfdGFnX29wdGlvbnMgKm9wdCwKCQkgICAgICAgc3RydWN0IG9iamVjdF9pZCAqcHJldiwgc3RydWN0IG9iamVjdF9pZCAqcmVzdWx0KQp7CgllbnVtIG9iamVjdF90eXBlIHR5cGU7CglzdHJ1Y3Qgc3RyYnVmIGhlYWRlciA9IFNUUkJVRl9JTklUOwoJY2hhciAqcGF0aCA9IE5VTEw7CgoJdHlwZSA9IHNoYTFfb2JqZWN0X2luZm8ob2JqZWN0LT5oYXNoLCBOVUxMKTsKCWlmICh0eXBlIDw9IE9CSl9OT05FKQoJICAgIGRpZShfKCJiYWQgb2JqZWN0IHR5cGUuIikpOwoKCXN0cmJ1Zl9hZGRmKCZoZWFkZXIsCgkJICAgICJvYmplY3QgJXNcbiIKCQkgICAgInR5cGUgJXNcbiIKCQkgICAgInRhZyAlc1xuIgoJCSAgICAidGFnZ2VyICVzXG5cbiIsCgkJICAgIG9pZF90b19oZXgob2JqZWN0KSwKCQkgICAgdHlwZW5hbWUodHlwZSksCgkJICAgIHRhZywKCQkgICAgZ2l0X2NvbW1pdHRlcl9pbmZvKElERU5UX1NUUklDVCkpOwoKCWlmICghb3B0LT5tZXNzYWdlX2dpdmVuKSB7CgkJaW50IGZkOwoKCQkvKiB3cml0ZSB0aGUgdGVtcGxhdGUgbWVzc2FnZSBiZWZvcmUgZWRpdGluZzogKi8KCQlwYXRoID0gZ2l0X3BhdGhkdXAoIlRBR19FRElUTVNHIik7CgkJZmQgPSBvcGVuKHBhdGgsIE9fQ1JFQVQgfCBPX1RSVU5DIHwgT19XUk9OTFksIDA2MDApOwoJCWlmIChmZCA8IDApCgkJCWRpZV9lcnJubyhfKCJjb3VsZCBub3QgY3JlYXRlIGZpbGUgJyVzJyIpLCBwYXRoKTsKCgkJaWYgKCFpc19udWxsX29pZChwcmV2KSkgewoJCQl3cml0ZV90YWdfYm9keShmZCwgcHJldik7CgkJfSBlbHNlIHsKCQkJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCQkJc3RyYnVmX2FkZGNoKCZidWYsICdcbicpOwoJCQlpZiAob3B0LT5jbGVhbnVwX21vZGUgPT0gQ0xFQU5VUF9BTEwpCgkJCQlzdHJidWZfY29tbWVudGVkX2FkZGYoJmJ1ZiwgXyh0YWdfdGVtcGxhdGUpLCB0YWcsIGNvbW1lbnRfbGluZV9jaGFyKTsKCQkJZWxzZQoJCQkJc3RyYnVmX2NvbW1lbnRlZF9hZGRmKCZidWYsIF8odGFnX3RlbXBsYXRlX25vY2xlYW51cCksIHRhZywgY29tbWVudF9saW5lX2NoYXIpOwoJCQl3cml0ZV9vcl9kaWUoZmQsIGJ1Zi5idWYsIGJ1Zi5sZW4pOwoJCQlzdHJidWZfcmVsZWFzZSgmYnVmKTsKCQl9CgkJY2xvc2UoZmQpOwoKCQlpZiAobGF1bmNoX2VkaXRvcihwYXRoLCBidWYsIE5VTEwpKSB7CgkJCWZwcmludGYoc3RkZXJyLAoJCQlfKCJQbGVhc2Ugc3VwcGx5IHRoZSBtZXNzYWdlIHVzaW5nIGVpdGhlciAtbSBvciAtRiBvcHRpb24uXG4iKSk7CgkJCWV4aXQoMSk7CgkJfQoJfQoKCWlmIChvcHQtPmNsZWFudXBfbW9kZSAhPSBDTEVBTlVQX05PTkUpCgkJc3RyYnVmX3N0cmlwc3BhY2UoYnVmLCBvcHQtPmNsZWFudXBfbW9kZSA9PSBDTEVBTlVQX0FMTCk7CgoJaWYgKCFvcHQtPm1lc3NhZ2VfZ2l2ZW4gJiYgIWJ1Zi0+bGVuKQoJCWRpZShfKCJubyB0YWcgbWVzc2FnZT8iKSk7CgoJc3RyYnVmX2luc2VydChidWYsIDAsIGhlYWRlci5idWYsIGhlYWRlci5sZW4pOwoJc3RyYnVmX3JlbGVhc2UoJmhlYWRlcik7CgoJaWYgKGJ1aWxkX3RhZ19vYmplY3QoYnVmLCBvcHQtPnNpZ24sIHJlc3VsdCkgPCAwKSB7CgkJaWYgKHBhdGgpCgkJCWZwcmludGYoc3RkZXJyLCBfKCJUaGUgdGFnIG1lc3NhZ2UgaGFzIGJlZW4gbGVmdCBpbiAlc1xuIiksCgkJCQlwYXRoKTsKCQlleGl0KDEyOCk7Cgl9CglpZiAocGF0aCkgewoJCXVubGlua19vcl93YXJuKHBhdGgpOwoJCWZyZWUocGF0aCk7Cgl9Cn0KCnN0YXRpYyB2b2lkIGNyZWF0ZV9yZWZsb2dfbXNnKGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwgc3RydWN0IHN0cmJ1ZiAqc2IpCnsKCWVudW0gb2JqZWN0X3R5cGUgdHlwZTsKCXN0cnVjdCBjb21taXQgKmM7CgljaGFyICpidWY7Cgl1bnNpZ25lZCBsb25nIHNpemU7CglpbnQgc3ViamVjdF9sZW4gPSAwOwoJY29uc3QgY2hhciAqc3ViamVjdF9zdGFydDsKCgljaGFyICpybGEgPSBnZXRlbnYoIkdJVF9SRUZMT0dfQUNUSU9OIik7CglpZiAocmxhKSB7CgkJc3RyYnVmX2FkZHN0cihzYiwgcmxhKTsKCX0gZWxzZSB7CgkJc3RyYnVmX2FkZHN0cihzYiwgInRhZzogdGFnZ2luZyAiKTsKCQlzdHJidWZfYWRkX3VuaXF1ZV9hYmJyZXYoc2IsIG9pZC0+aGFzaCwgREVGQVVMVF9BQkJSRVYpOwoJfQoKCXN0cmJ1Zl9hZGRzdHIoc2IsICIgKCIpOwoJdHlwZSA9IHNoYTFfb2JqZWN0X2luZm8ob2lkLT5oYXNoLCBOVUxMKTsKCXN3aXRjaCAodHlwZSkgewoJZGVmYXVsdDoKCQlzdHJidWZfYWRkc3RyKHNiLCAib2JqZWN0IG9mIHVua25vd24gdHlwZSIpOwoJCWJyZWFrOwoJY2FzZSBPQkpfQ09NTUlUOgoJCWlmICgoYnVmID0gcmVhZF9zaGExX2ZpbGUob2lkLT5oYXNoLCAmdHlwZSwgJnNpemUpKSAhPSBOVUxMKSB7CgkJCXN1YmplY3RfbGVuID0gZmluZF9jb21taXRfc3ViamVjdChidWYsICZzdWJqZWN0X3N0YXJ0KTsKCQkJc3RyYnVmX2luc2VydChzYiwgc2ItPmxlbiwgc3ViamVjdF9zdGFydCwgc3ViamVjdF9sZW4pOwoJCX0gZWxzZSB7CgkJCXN0cmJ1Zl9hZGRzdHIoc2IsICJjb21taXQgb2JqZWN0Iik7CgkJfQoJCWZyZWUoYnVmKTsKCgkJaWYgKChjID0gbG9va3VwX2NvbW1pdF9yZWZlcmVuY2Uob2lkKSkgIT0gTlVMTCkKCQkJc3RyYnVmX2FkZGYoc2IsICIsICVzIiwgc2hvd19kYXRlKGMtPmRhdGUsIDAsIERBVEVfTU9ERShTSE9SVCkpKTsKCQlicmVhazsKCWNhc2UgT0JKX1RSRUU6CgkJc3RyYnVmX2FkZHN0cihzYiwgInRyZWUgb2JqZWN0Iik7CgkJYnJlYWs7CgljYXNlIE9CSl9CTE9COgoJCXN0cmJ1Zl9hZGRzdHIoc2IsICJibG9iIG9iamVjdCIpOwoJCWJyZWFrOwoJY2FzZSBPQkpfVEFHOgoJCXN0cmJ1Zl9hZGRzdHIoc2IsICJvdGhlciB0YWcgb2JqZWN0Iik7CgkJYnJlYWs7Cgl9CglzdHJidWZfYWRkY2goc2IsICcpJyk7Cn0KCnN0cnVjdCBtc2dfYXJnIHsKCWludCBnaXZlbjsKCXN0cnVjdCBzdHJidWYgYnVmOwp9OwoKc3RhdGljIGludCBwYXJzZV9tc2dfYXJnKGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdCwgY29uc3QgY2hhciAqYXJnLCBpbnQgdW5zZXQpCnsKCXN0cnVjdCBtc2dfYXJnICptc2cgPSBvcHQtPnZhbHVlOwoKCWlmICghYXJnKQoJCXJldHVybiAtMTsKCWlmIChtc2ctPmJ1Zi5sZW4pCgkJc3RyYnVmX2FkZHN0cigmKG1zZy0+YnVmKSwgIlxuXG4iKTsKCXN0cmJ1Zl9hZGRzdHIoJihtc2ctPmJ1ZiksIGFyZyk7Cgltc2ctPmdpdmVuID0gMTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IHN0cmJ1Zl9jaGVja190YWdfcmVmKHN0cnVjdCBzdHJidWYgKnNiLCBjb25zdCBjaGFyICpuYW1lKQp7CglpZiAobmFtZVswXSA9PSAnLScpCgkJcmV0dXJuIC0xOwoKCXN0cmJ1Zl9yZXNldChzYik7CglzdHJidWZfYWRkZihzYiwgInJlZnMvdGFncy8lcyIsIG5hbWUpOwoKCXJldHVybiBjaGVja19yZWZuYW1lX2Zvcm1hdChzYi0+YnVmLCAwKTsKfQoKaW50IGNtZF90YWcoaW50IGFyZ2MsIGNvbnN0IGNoYXIgKiphcmd2LCBjb25zdCBjaGFyICpwcmVmaXgpCnsKCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3Qgc3RyYnVmIHJlZiA9IFNUUkJVRl9JTklUOwoJc3RydWN0IHN0cmJ1ZiByZWZsb2dfbXNnID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3Qgb2JqZWN0X2lkIG9iamVjdCwgcHJldjsKCWNvbnN0IGNoYXIgKm9iamVjdF9yZWYsICp0YWc7CglzdHJ1Y3QgY3JlYXRlX3RhZ19vcHRpb25zIG9wdDsKCWNoYXIgKmNsZWFudXBfYXJnID0gTlVMTDsKCWludCBjcmVhdGVfcmVmbG9nID0gMDsKCWludCBhbm5vdGF0ZSA9IDAsIGZvcmNlID0gMDsKCWludCBjbWRtb2RlID0gMCwgY3JlYXRlX3RhZ19vYmplY3QgPSAwOwoJY29uc3QgY2hhciAqbXNnZmlsZSA9IE5VTEwsICprZXlpZCA9IE5VTEw7CglzdHJ1Y3QgbXNnX2FyZyBtc2cgPSB7IDAsIFNUUkJVRl9JTklUIH07CglzdHJ1Y3QgcmVmX3RyYW5zYWN0aW9uICp0cmFuc2FjdGlvbjsKCXN0cnVjdCBzdHJidWYgZXJyID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3QgcmVmX2ZpbHRlciBmaWx0ZXI7CglzdGF0aWMgc3RydWN0IHJlZl9zb3J0aW5nICpzb3J0aW5nID0gTlVMTCwgKipzb3J0aW5nX3RhaWwgPSAmc29ydGluZzsKCXN0cnVjdCByZWZfZm9ybWF0IGZvcm1hdCA9IFJFRl9GT1JNQVRfSU5JVDsKCWludCBpY2FzZSA9IDA7CglzdHJ1Y3Qgb3B0aW9uIG9wdGlvbnNbXSA9IHsKCQlPUFRfQ01ETU9ERSgnbCcsICJsaXN0IiwgJmNtZG1vZGUsIE5fKCJsaXN0IHRhZyBuYW1lcyIpLCAnbCcpLAoJCXsgT1BUSU9OX0lOVEVHRVIsICduJywgTlVMTCwgJmZpbHRlci5saW5lcywgTl8oIm4iKSwKCQkJCU5fKCJwcmludCA8bj4gbGluZXMgb2YgZWFjaCB0YWcgbWVzc2FnZSIpLAoJCQkJUEFSU0VfT1BUX09QVEFSRywgTlVMTCwgMSB9LAoJCU9QVF9DTURNT0RFKCdkJywgImRlbGV0ZSIsICZjbWRtb2RlLCBOXygiZGVsZXRlIHRhZ3MiKSwgJ2QnKSwKCQlPUFRfQ01ETU9ERSgndicsICJ2ZXJpZnkiLCAmY21kbW9kZSwgTl8oInZlcmlmeSB0YWdzIiksICd2JyksCgoJCU9QVF9HUk9VUChOXygiVGFnIGNyZWF0aW9uIG9wdGlvbnMiKSksCgkJT1BUX0JPT0woJ2EnLCAiYW5ub3RhdGUiLCAmYW5ub3RhdGUsCgkJCQkJTl8oImFubm90YXRlZCB0YWcsIG5lZWRzIGEgbWVzc2FnZSIpKSwKCQlPUFRfQ0FMTEJBQ0soJ20nLCAibWVzc2FnZSIsICZtc2csIE5fKCJtZXNzYWdlIiksCgkJCSAgICAgTl8oInRhZyBtZXNzYWdlIiksIHBhcnNlX21zZ19hcmcpLAoJCU9QVF9GSUxFTkFNRSgnRicsICJmaWxlIiwgJm1zZ2ZpbGUsIE5fKCJyZWFkIG1lc3NhZ2UgZnJvbSBmaWxlIikpLAoJCU9QVF9CT09MKCdzJywgInNpZ24iLCAmb3B0LnNpZ24sIE5fKCJhbm5vdGF0ZWQgYW5kIEdQRy1zaWduZWQgdGFnIikpLAoJCU9QVF9TVFJJTkcoMCwgImNsZWFudXAiLCAmY2xlYW51cF9hcmcsIE5fKCJtb2RlIiksCgkJCU5fKCJob3cgdG8gc3RyaXAgc3BhY2VzIGFuZCAjY29tbWVudHMgZnJvbSBtZXNzYWdlIikpLAoJCU9QVF9TVFJJTkcoJ3UnLCAibG9jYWwtdXNlciIsICZrZXlpZCwgTl8oImtleS1pZCIpLAoJCQkJCU5fKCJ1c2UgYW5vdGhlciBrZXkgdG8gc2lnbiB0aGUgdGFnIikpLAoJCU9QVF9fRk9SQ0UoJmZvcmNlLCBOXygicmVwbGFjZSB0aGUgdGFnIGlmIGV4aXN0cyIpKSwKCQlPUFRfQk9PTCgwLCAiY3JlYXRlLXJlZmxvZyIsICZjcmVhdGVfcmVmbG9nLCBOXygiY3JlYXRlIGEgcmVmbG9nIikpLAoKCQlPUFRfR1JPVVAoTl8oIlRhZyBsaXN0aW5nIG9wdGlvbnMiKSksCgkJT1BUX0NPTFVNTigwLCAiY29sdW1uIiwgJmNvbG9wdHMsIE5fKCJzaG93IHRhZyBsaXN0IGluIGNvbHVtbnMiKSksCgkJT1BUX0NPTlRBSU5TKCZmaWx0ZXIud2l0aF9jb21taXQsIE5fKCJwcmludCBvbmx5IHRhZ3MgdGhhdCBjb250YWluIHRoZSBjb21taXQiKSksCgkJT1BUX05PX0NPTlRBSU5TKCZmaWx0ZXIubm9fY29tbWl0LCBOXygicHJpbnQgb25seSB0YWdzIHRoYXQgZG9uJ3QgY29udGFpbiB0aGUgY29tbWl0IikpLAoJCU9QVF9XSVRIKCZmaWx0ZXIud2l0aF9jb21taXQsIE5fKCJwcmludCBvbmx5IHRhZ3MgdGhhdCBjb250YWluIHRoZSBjb21taXQiKSksCgkJT1BUX1dJVEhPVVQoJmZpbHRlci5ub19jb21taXQsIE5fKCJwcmludCBvbmx5IHRhZ3MgdGhhdCBkb24ndCBjb250YWluIHRoZSBjb21taXQiKSksCgkJT1BUX01FUkdFRCgmZmlsdGVyLCBOXygicHJpbnQgb25seSB0YWdzIHRoYXQgYXJlIG1lcmdlZCIpKSwKCQlPUFRfTk9fTUVSR0VEKCZmaWx0ZXIsIE5fKCJwcmludCBvbmx5IHRhZ3MgdGhhdCBhcmUgbm90IG1lcmdlZCIpKSwKCQlPUFRfQ0FMTEJBQ0soMCAsICJzb3J0Iiwgc29ydGluZ190YWlsLCBOXygia2V5IiksCgkJCSAgICAgTl8oImZpZWxkIG5hbWUgdG8gc29ydCBvbiIpLCAmcGFyc2Vfb3B0X3JlZl9zb3J0aW5nKSwKCQl7CgkJCU9QVElPTl9DQUxMQkFDSywgMCwgInBvaW50cy1hdCIsICZmaWx0ZXIucG9pbnRzX2F0LCBOXygib2JqZWN0IiksCgkJCU5fKCJwcmludCBvbmx5IHRhZ3Mgb2YgdGhlIG9iamVjdCIpLCBQQVJTRV9PUFRfTEFTVEFSR19ERUZBVUxULAoJCQlwYXJzZV9vcHRfb2JqZWN0X25hbWUsIChpbnRwdHJfdCkgIkhFQUQiCgkJfSwKCQlPUFRfU1RSSU5HKCAgMCAsICJmb3JtYXQiLCAmZm9ybWF0LmZvcm1hdCwgTl8oImZvcm1hdCIpLAoJCQkgICBOXygiZm9ybWF0IHRvIHVzZSBmb3IgdGhlIG91dHB1dCIpKSwKCQlPUFRfX0NPTE9SKCZmb3JtYXQudXNlX2NvbG9yLCBOXygicmVzcGVjdCBmb3JtYXQgY29sb3JzIikpLAoJCU9QVF9CT09MKCdpJywgImlnbm9yZS1jYXNlIiwgJmljYXNlLCBOXygic29ydGluZyBhbmQgZmlsdGVyaW5nIGFyZSBjYXNlIGluc2Vuc2l0aXZlIikpLAoJCU9QVF9FTkQoKQoJfTsKCglzZXR1cF9yZWZfZmlsdGVyX3BvcmNlbGFpbl9tc2coKTsKCglnaXRfY29uZmlnKGdpdF90YWdfY29uZmlnLCBzb3J0aW5nX3RhaWwpOwoKCW1lbXNldCgmb3B0LCAwLCBzaXplb2Yob3B0KSk7CgltZW1zZXQoJmZpbHRlciwgMCwgc2l6ZW9mKGZpbHRlcikpOwoJZmlsdGVyLmxpbmVzID0gLTE7CgoJYXJnYyA9IHBhcnNlX29wdGlvbnMoYXJnYywgYXJndiwgcHJlZml4LCBvcHRpb25zLCBnaXRfdGFnX3VzYWdlLCAwKTsKCglpZiAoa2V5aWQpIHsKCQlvcHQuc2lnbiA9IDE7CgkJc2V0X3NpZ25pbmdfa2V5KGtleWlkKTsKCX0KCWNyZWF0ZV90YWdfb2JqZWN0ID0gKG9wdC5zaWduIHx8IGFubm90YXRlIHx8IG1zZy5naXZlbiB8fCBtc2dmaWxlKTsKCglpZiAoIWNtZG1vZGUpIHsKCQlpZiAoYXJnYyA9PSAwKQoJCQljbWRtb2RlID0gJ2wnOwoJCWVsc2UgaWYgKGZpbHRlci53aXRoX2NvbW1pdCB8fCBmaWx0ZXIubm9fY29tbWl0IHx8CgkJCSBmaWx0ZXIucG9pbnRzX2F0Lm5yIHx8IGZpbHRlci5tZXJnZV9jb21taXQgfHwKCQkJIGZpbHRlci5saW5lcyAhPSAtMSkKCQkJY21kbW9kZSA9ICdsJzsKCX0KCglpZiAoY21kbW9kZSA9PSAnbCcpCgkJc2V0dXBfYXV0b19wYWdlcigidGFnIiwgMSk7CgoJaWYgKChjcmVhdGVfdGFnX29iamVjdCB8fCBmb3JjZSkgJiYgKGNtZG1vZGUgIT0gMCkpCgkJdXNhZ2Vfd2l0aF9vcHRpb25zKGdpdF90YWdfdXNhZ2UsIG9wdGlvbnMpOwoKCWZpbmFsaXplX2NvbG9wdHMoJmNvbG9wdHMsIC0xKTsKCWlmIChjbWRtb2RlID09ICdsJyAmJiBmaWx0ZXIubGluZXMgIT0gLTEpIHsKCQlpZiAoZXhwbGljaXRseV9lbmFibGVfY29sdW1uKGNvbG9wdHMpKQoJCQlkaWUoXygiLS1jb2x1bW4gYW5kIC1uIGFyZSBpbmNvbXBhdGlibGUiKSk7CgkJY29sb3B0cyA9IDA7Cgl9CglpZiAoIXNvcnRpbmcpCgkJc29ydGluZyA9IHJlZl9kZWZhdWx0X3NvcnRpbmcoKTsKCXNvcnRpbmctPmlnbm9yZV9jYXNlID0gaWNhc2U7CglmaWx0ZXIuaWdub3JlX2Nhc2UgPSBpY2FzZTsKCWlmIChjbWRtb2RlID09ICdsJykgewoJCWludCByZXQ7CgkJaWYgKGNvbHVtbl9hY3RpdmUoY29sb3B0cykpIHsKCQkJc3RydWN0IGNvbHVtbl9vcHRpb25zIGNvcHRzOwoJCQltZW1zZXQoJmNvcHRzLCAwLCBzaXplb2YoY29wdHMpKTsKCQkJY29wdHMucGFkZGluZyA9IDI7CgkJCXJ1bl9jb2x1bW5fZmlsdGVyKGNvbG9wdHMsICZjb3B0cyk7CgkJfQoJCWZpbHRlci5uYW1lX3BhdHRlcm5zID0gYXJndjsKCQlyZXQgPSBsaXN0X3RhZ3MoJmZpbHRlciwgc29ydGluZywgJmZvcm1hdCk7CgkJaWYgKGNvbHVtbl9hY3RpdmUoY29sb3B0cykpCgkJCXN0b3BfY29sdW1uX2ZpbHRlcigpOwoJCXJldHVybiByZXQ7Cgl9CglpZiAoZmlsdGVyLmxpbmVzICE9IC0xKQoJCWRpZShfKCItbiBvcHRpb24gaXMgb25seSBhbGxvd2VkIGluIGxpc3QgbW9kZSIpKTsKCWlmIChmaWx0ZXIud2l0aF9jb21taXQpCgkJZGllKF8oIi0tY29udGFpbnMgb3B0aW9uIGlzIG9ubHkgYWxsb3dlZCBpbiBsaXN0IG1vZGUiKSk7CglpZiAoZmlsdGVyLm5vX2NvbW1pdCkKCQlkaWUoXygiLS1uby1jb250YWlucyBvcHRpb24gaXMgb25seSBhbGxvd2VkIGluIGxpc3QgbW9kZSIpKTsKCWlmIChmaWx0ZXIucG9pbnRzX2F0Lm5yKQoJCWRpZShfKCItLXBvaW50cy1hdCBvcHRpb24gaXMgb25seSBhbGxvd2VkIGluIGxpc3QgbW9kZSIpKTsKCWlmIChmaWx0ZXIubWVyZ2VfY29tbWl0KQoJCWRpZShfKCItLW1lcmdlZCBhbmQgLS1uby1tZXJnZWQgb3B0aW9ucyBhcmUgb25seSBhbGxvd2VkIGluIGxpc3QgbW9kZSIpKTsKCWlmIChjbWRtb2RlID09ICdkJykKCQlyZXR1cm4gZm9yX2VhY2hfdGFnX25hbWUoYXJndiwgZGVsZXRlX3RhZywgTlVMTCk7CglpZiAoY21kbW9kZSA9PSAndicpIHsKCQlpZiAoZm9ybWF0LmZvcm1hdCAmJiB2ZXJpZnlfcmVmX2Zvcm1hdCgmZm9ybWF0KSkKCQkJdXNhZ2Vfd2l0aF9vcHRpb25zKGdpdF90YWdfdXNhZ2UsIG9wdGlvbnMpOwoJCXJldHVybiBmb3JfZWFjaF90YWdfbmFtZShhcmd2LCB2ZXJpZnlfdGFnLCAmZm9ybWF0KTsKCX0KCglpZiAobXNnLmdpdmVuIHx8IG1zZ2ZpbGUpIHsKCQlpZiAobXNnLmdpdmVuICYmIG1zZ2ZpbGUpCgkJCWRpZShfKCJvbmx5IG9uZSAtRiBvciAtbSBvcHRpb24gaXMgYWxsb3dlZC4iKSk7CgkJaWYgKG1zZy5naXZlbikKCQkJc3RyYnVmX2FkZGJ1ZigmYnVmLCAmKG1zZy5idWYpKTsKCQllbHNlIHsKCQkJaWYgKCFzdHJjbXAobXNnZmlsZSwgIi0iKSkgewoJCQkJaWYgKHN0cmJ1Zl9yZWFkKCZidWYsIDAsIDEwMjQpIDwgMCkKCQkJCQlkaWVfZXJybm8oXygiY2Fubm90IHJlYWQgJyVzJyIpLCBtc2dmaWxlKTsKCQkJfSBlbHNlIHsKCQkJCWlmIChzdHJidWZfcmVhZF9maWxlKCZidWYsIG1zZ2ZpbGUsIDEwMjQpIDwgMCkKCQkJCQlkaWVfZXJybm8oXygiY291bGQgbm90IG9wZW4gb3IgcmVhZCAnJXMnIiksCgkJCQkJCW1zZ2ZpbGUpOwoJCQl9CgkJfQoJfQoKCXRhZyA9IGFyZ3ZbMF07CgoJb2JqZWN0X3JlZiA9IGFyZ2MgPT0gMiA/IGFyZ3ZbMV0gOiAiSEVBRCI7CglpZiAoYXJnYyA+IDIpCgkJZGllKF8oInRvbyBtYW55IHBhcmFtcyIpKTsKCglpZiAoZ2V0X29pZChvYmplY3RfcmVmLCAmb2JqZWN0KSkKCQlkaWUoXygiRmFpbGVkIHRvIHJlc29sdmUgJyVzJyBhcyBhIHZhbGlkIHJlZi4iKSwgb2JqZWN0X3JlZik7CgoJaWYgKHN0cmJ1Zl9jaGVja190YWdfcmVmKCZyZWYsIHRhZykpCgkJZGllKF8oIiclcycgaXMgbm90IGEgdmFsaWQgdGFnIG5hbWUuIiksIHRhZyk7CgoJaWYgKHJlYWRfcmVmKHJlZi5idWYsIHByZXYuaGFzaCkpCgkJb2lkY2xyKCZwcmV2KTsKCWVsc2UgaWYgKCFmb3JjZSkKCQlkaWUoXygidGFnICclcycgYWxyZWFkeSBleGlzdHMiKSwgdGFnKTsKCglvcHQubWVzc2FnZV9naXZlbiA9IG1zZy5naXZlbiB8fCBtc2dmaWxlOwoKCWlmICghY2xlYW51cF9hcmcgfHwgIXN0cmNtcChjbGVhbnVwX2FyZywgInN0cmlwIikpCgkJb3B0LmNsZWFudXBfbW9kZSA9IENMRUFOVVBfQUxMOwoJZWxzZSBpZiAoIXN0cmNtcChjbGVhbnVwX2FyZywgInZlcmJhdGltIikpCgkJb3B0LmNsZWFudXBfbW9kZSA9IENMRUFOVVBfTk9ORTsKCWVsc2UgaWYgKCFzdHJjbXAoY2xlYW51cF9hcmcsICJ3aGl0ZXNwYWNlIikpCgkJb3B0LmNsZWFudXBfbW9kZSA9IENMRUFOVVBfU1BBQ0U7CgllbHNlCgkJZGllKF8oIkludmFsaWQgY2xlYW51cCBtb2RlICVzIiksIGNsZWFudXBfYXJnKTsKCgljcmVhdGVfcmVmbG9nX21zZygmb2JqZWN0LCAmcmVmbG9nX21zZyk7CgoJaWYgKGNyZWF0ZV90YWdfb2JqZWN0KSB7CgkJaWYgKGZvcmNlX3NpZ25fYW5ub3RhdGUgJiYgIWFubm90YXRlKQoJCQlvcHQuc2lnbiA9IDE7CgkJY3JlYXRlX3RhZygmb2JqZWN0LCB0YWcsICZidWYsICZvcHQsICZwcmV2LCAmb2JqZWN0KTsKCX0KCgl0cmFuc2FjdGlvbiA9IHJlZl90cmFuc2FjdGlvbl9iZWdpbigmZXJyKTsKCWlmICghdHJhbnNhY3Rpb24gfHwKCSAgICByZWZfdHJhbnNhY3Rpb25fdXBkYXRlKHRyYW5zYWN0aW9uLCByZWYuYnVmLCBvYmplY3QuaGFzaCwgcHJldi5oYXNoLAoJCQkJICAgY3JlYXRlX3JlZmxvZyA/IFJFRl9GT1JDRV9DUkVBVEVfUkVGTE9HIDogMCwKCQkJCSAgIHJlZmxvZ19tc2cuYnVmLCAmZXJyKSB8fAoJICAgIHJlZl90cmFuc2FjdGlvbl9jb21taXQodHJhbnNhY3Rpb24sICZlcnIpKQoJCWRpZSgiJXMiLCBlcnIuYnVmKTsKCXJlZl90cmFuc2FjdGlvbl9mcmVlKHRyYW5zYWN0aW9uKTsKCWlmIChmb3JjZSAmJiAhaXNfbnVsbF9vaWQoJnByZXYpICYmIG9pZGNtcCgmcHJldiwgJm9iamVjdCkpCgkJcHJpbnRmKF8oIlVwZGF0ZWQgdGFnICclcycgKHdhcyAlcylcbiIpLCB0YWcsIGZpbmRfdW5pcXVlX2FiYnJldihwcmV2Lmhhc2gsIERFRkFVTFRfQUJCUkVWKSk7CgoJc3RyYnVmX3JlbGVhc2UoJmVycik7CglzdHJidWZfcmVsZWFzZSgmYnVmKTsKCXN0cmJ1Zl9yZWxlYXNlKCZyZWYpOwoJc3RyYnVmX3JlbGVhc2UoJnJlZmxvZ19tc2cpOwoJcmV0dXJuIDA7Cn0K",
    "text": "/*\n * Builtin \"git tag\"\n *\n * Copyright (c) 2007 Kristian H\u00f8gsberg <krh@redhat.com>,\n *                    Carlos Rica <jasampler@gmail.com>\n * Based on git-tag.sh and mktag.c by Linus Torvalds.\n */\n\n#include \"cache.h\"\n#include \"config.h\"\n#include \"builtin.h\"\n#include \"refs.h\"\n#include \"tag.h\"\n#include \"run-command.h\"\n#include \"parse-options.h\"\n#include \"diff.h\"\n#include \"revision.h\"\n#include \"gpg-interface.h\"\n#include \"sha1-array.h\"\n#include \"column.h\"\n#include \"ref-filter.h\"\n\nstatic const char * const git_tag_usage[] = {\n\tN_(\"git tag [-a | -s | -u <key-id>] [-f] [-m <msg> | -F <file>] <tagname> [<head>]\"),\n\tN_(\"git tag -d <tagname>...\"),\n\tN_(\"git tag -l [-n[<num>]] [--contains <commit>] [--no-contains <commit>] [--points-at <object>]\"\n\t\t\"\\n\\t\\t[--format=<format>] [--[no-]merged [<commit>]] [<pattern>...]\"),\n\tN_(\"git tag -v [--format=<format>] <tagname>...\"),\n\tNULL\n};\n\nstatic unsigned int colopts;\nstatic int force_sign_annotate;\n\nstatic int list_tags(struct ref_filter *filter, struct ref_sorting *sorting,\n\t\t     struct ref_format *format)\n{\n\tstruct ref_array array;\n\tchar *to_free = NULL;\n\tint i;\n\n\tmemset(&array, 0, sizeof(array));\n\n\tif (filter->lines == -1)\n\t\tfilter->lines = 0;\n\n\tif (!format->format) {\n\t\tif (filter->lines) {\n\t\t\tto_free = xstrfmt(\"%s %%(contents:lines=%d)\",\n\t\t\t\t\t  \"%(align:15)%(refname:lstrip=2)%(end)\",\n\t\t\t\t\t  filter->lines);\n\t\t\tformat->format = to_free;\n\t\t} else\n\t\t\tformat->format = \"%(refname:lstrip=2)\";\n\t}\n\n\tif (verify_ref_format(format))\n\t\tdie(_(\"unable to parse format string\"));\n\tfilter->with_commit_tag_algo = 1;\n\tfilter_refs(&array, filter, FILTER_REFS_TAGS);\n\tref_array_sort(sorting, &array);\n\n\tfor (i = 0; i < array.nr; i++)\n\t\tshow_ref_array_item(array.items[i], format);\n\tref_array_clear(&array);\n\tfree(to_free);\n\n\treturn 0;\n}\n\ntypedef int (*each_tag_name_fn)(const char *name, const char *ref,\n\t\t\t\tconst struct object_id *oid, const void *cb_data);\n\nstatic int for_each_tag_name(const char **argv, each_tag_name_fn fn,\n\t\t\t     const void *cb_data)\n{\n\tconst char **p;\n\tstruct strbuf ref = STRBUF_INIT;\n\tint had_error = 0;\n\tstruct object_id oid;\n\n\tfor (p = argv; *p; p++) {\n\t\tstrbuf_reset(&ref);\n\t\tstrbuf_addf(&ref, \"refs/tags/%s\", *p);\n\t\tif (read_ref(ref.buf, oid.hash)) {\n\t\t\terror(_(\"tag '%s' not found.\"), *p);\n\t\t\thad_error = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (fn(*p, ref.buf, &oid, cb_data))\n\t\t\thad_error = 1;\n\t}\n\tstrbuf_release(&ref);\n\treturn had_error;\n}\n\nstatic int delete_tag(const char *name, const char *ref,\n\t\t      const struct object_id *oid, const void *cb_data)\n{\n\tif (delete_ref(NULL, ref, oid->hash, 0))\n\t\treturn 1;\n\tprintf(_(\"Deleted tag '%s' (was %s)\\n\"), name, find_unique_abbrev(oid->hash, DEFAULT_ABBREV));\n\treturn 0;\n}\n\nstatic int verify_tag(const char *name, const char *ref,\n\t\t      const struct object_id *oid, const void *cb_data)\n{\n\tint flags;\n\tconst struct ref_format *format = cb_data;\n\tflags = GPG_VERIFY_VERBOSE;\n\n\tif (format->format)\n\t\tflags = GPG_VERIFY_OMIT_STATUS;\n\n\tif (gpg_verify_tag(oid->hash, name, flags))\n\t\treturn -1;\n\n\tif (format->format)\n\t\tpretty_print_ref(name, oid->hash, format);\n\n\treturn 0;\n}\n\nstatic int do_sign(struct strbuf *buffer)\n{\n\treturn sign_buffer(buffer, buffer, get_signing_key());\n}\n\nstatic const char tag_template[] =\n\tN_(\"\\nWrite a message for tag:\\n  %s\\n\"\n\t\"Lines starting with '%c' will be ignored.\\n\");\n\nstatic const char tag_template_nocleanup[] =\n\tN_(\"\\nWrite a message for tag:\\n  %s\\n\"\n\t\"Lines starting with '%c' will be kept; you may remove them\"\n\t\" yourself if you want to.\\n\");\n\nstatic int git_tag_config(const char *var, const char *value, void *cb)\n{\n\tint status;\n\tstruct ref_sorting **sorting_tail = (struct ref_sorting **)cb;\n\n\tif (!strcmp(var, \"tag.sort\")) {\n\t\tif (!value)\n\t\t\treturn config_error_nonbool(var);\n\t\tparse_ref_sorting(sorting_tail, value);\n\t\treturn 0;\n\t}\n\n\tstatus = git_gpg_config(var, value, cb);\n\tif (status)\n\t\treturn status;\n\tif (!strcmp(var, \"tag.forcesignannotated\")) {\n\t\tforce_sign_annotate = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\n\tif (starts_with(var, \"column.\"))\n\t\treturn git_column_config(var, value, \"tag\", &colopts);\n\treturn git_color_default_config(var, value, cb);\n}\n\nstatic void write_tag_body(int fd, const struct object_id *oid)\n{\n\tunsigned long size;\n\tenum object_type type;\n\tchar *buf, *sp;\n\n\tbuf = read_sha1_file(oid->hash, &type, &size);\n\tif (!buf)\n\t\treturn;\n\t/* skip header */\n\tsp = strstr(buf, \"\\n\\n\");\n\n\tif (!sp || !size || type != OBJ_TAG) {\n\t\tfree(buf);\n\t\treturn;\n\t}\n\tsp += 2; /* skip the 2 LFs */\n\twrite_or_die(fd, sp, parse_signature(sp, buf + size - sp));\n\n\tfree(buf);\n}\n\nstatic int build_tag_object(struct strbuf *buf, int sign, struct object_id *result)\n{\n\tif (sign && do_sign(buf) < 0)\n\t\treturn error(_(\"unable to sign the tag\"));\n\tif (write_sha1_file(buf->buf, buf->len, tag_type, result->hash) < 0)\n\t\treturn error(_(\"unable to write tag file\"));\n\treturn 0;\n}\n\nstruct create_tag_options {\n\tunsigned int message_given:1;\n\tunsigned int sign;\n\tenum {\n\t\tCLEANUP_NONE,\n\t\tCLEANUP_SPACE,\n\t\tCLEANUP_ALL\n\t} cleanup_mode;\n};\n\nstatic void create_tag(const struct object_id *object, const char *tag,\n\t\t       struct strbuf *buf, struct create_tag_options *opt,\n\t\t       struct object_id *prev, struct object_id *result)\n{\n\tenum object_type type;\n\tstruct strbuf header = STRBUF_INIT;\n\tchar *path = NULL;\n\n\ttype = sha1_object_info(object->hash, NULL);\n\tif (type <= OBJ_NONE)\n\t    die(_(\"bad object type.\"));\n\n\tstrbuf_addf(&header,\n\t\t    \"object %s\\n\"\n\t\t    \"type %s\\n\"\n\t\t    \"tag %s\\n\"\n\t\t    \"tagger %s\\n\\n\",\n\t\t    oid_to_hex(object),\n\t\t    typename(type),\n\t\t    tag,\n\t\t    git_committer_info(IDENT_STRICT));\n\n\tif (!opt->message_given) {\n\t\tint fd;\n\n\t\t/* write the template message before editing: */\n\t\tpath = git_pathdup(\"TAG_EDITMSG\");\n\t\tfd = open(path, O_CREAT | O_TRUNC | O_WRONLY, 0600);\n\t\tif (fd < 0)\n\t\t\tdie_errno(_(\"could not create file '%s'\"), path);\n\n\t\tif (!is_null_oid(prev)) {\n\t\t\twrite_tag_body(fd, prev);\n\t\t} else {\n\t\t\tstruct strbuf buf = STRBUF_INIT;\n\t\t\tstrbuf_addch(&buf, '\\n');\n\t\t\tif (opt->cleanup_mode == CLEANUP_ALL)\n\t\t\t\tstrbuf_commented_addf(&buf, _(tag_template), tag, comment_line_char);\n\t\t\telse\n\t\t\t\tstrbuf_commented_addf(&buf, _(tag_template_nocleanup), tag, comment_line_char);\n\t\t\twrite_or_die(fd, buf.buf, buf.len);\n\t\t\tstrbuf_release(&buf);\n\t\t}\n\t\tclose(fd);\n\n\t\tif (launch_editor(path, buf, NULL)) {\n\t\t\tfprintf(stderr,\n\t\t\t_(\"Please supply the message using either -m or -F option.\\n\"));\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif (opt->cleanup_mode != CLEANUP_NONE)\n\t\tstrbuf_stripspace(buf, opt->cleanup_mode == CLEANUP_ALL);\n\n\tif (!opt->message_given && !buf->len)\n\t\tdie(_(\"no tag message?\"));\n\n\tstrbuf_insert(buf, 0, header.buf, header.len);\n\tstrbuf_release(&header);\n\n\tif (build_tag_object(buf, opt->sign, result) < 0) {\n\t\tif (path)\n\t\t\tfprintf(stderr, _(\"The tag message has been left in %s\\n\"),\n\t\t\t\tpath);\n\t\texit(128);\n\t}\n\tif (path) {\n\t\tunlink_or_warn(path);\n\t\tfree(path);\n\t}\n}\n\nstatic void create_reflog_msg(const struct object_id *oid, struct strbuf *sb)\n{\n\tenum object_type type;\n\tstruct commit *c;\n\tchar *buf;\n\tunsigned long size;\n\tint subject_len = 0;\n\tconst char *subject_start;\n\n\tchar *rla = getenv(\"GIT_REFLOG_ACTION\");\n\tif (rla) {\n\t\tstrbuf_addstr(sb, rla);\n\t} else {\n\t\tstrbuf_addstr(sb, \"tag: tagging \");\n\t\tstrbuf_add_unique_abbrev(sb, oid->hash, DEFAULT_ABBREV);\n\t}\n\n\tstrbuf_addstr(sb, \" (\");\n\ttype = sha1_object_info(oid->hash, NULL);\n\tswitch (type) {\n\tdefault:\n\t\tstrbuf_addstr(sb, \"object of unknown type\");\n\t\tbreak;\n\tcase OBJ_COMMIT:\n\t\tif ((buf = read_sha1_file(oid->hash, &type, &size)) != NULL) {\n\t\t\tsubject_len = find_commit_subject(buf, &subject_start);\n\t\t\tstrbuf_insert(sb, sb->len, subject_start, subject_len);\n\t\t} else {\n\t\t\tstrbuf_addstr(sb, \"commit object\");\n\t\t}\n\t\tfree(buf);\n\n\t\tif ((c = lookup_commit_reference(oid)) != NULL)\n\t\t\tstrbuf_addf(sb, \", %s\", show_date(c->date, 0, DATE_MODE(SHORT)));\n\t\tbreak;\n\tcase OBJ_TREE:\n\t\tstrbuf_addstr(sb, \"tree object\");\n\t\tbreak;\n\tcase OBJ_BLOB:\n\t\tstrbuf_addstr(sb, \"blob object\");\n\t\tbreak;\n\tcase OBJ_TAG:\n\t\tstrbuf_addstr(sb, \"other tag object\");\n\t\tbreak;\n\t}\n\tstrbuf_addch(sb, ')');\n}\n\nstruct msg_arg {\n\tint given;\n\tstruct strbuf buf;\n};\n\nstatic int parse_msg_arg(const struct option *opt, const char *arg, int unset)\n{\n\tstruct msg_arg *msg = opt->value;\n\n\tif (!arg)\n\t\treturn -1;\n\tif (msg->buf.len)\n\t\tstrbuf_addstr(&(msg->buf), \"\\n\\n\");\n\tstrbuf_addstr(&(msg->buf), arg);\n\tmsg->given = 1;\n\treturn 0;\n}\n\nstatic int strbuf_check_tag_ref(struct strbuf *sb, const char *name)\n{\n\tif (name[0] == '-')\n\t\treturn -1;\n\n\tstrbuf_reset(sb);\n\tstrbuf_addf(sb, \"refs/tags/%s\", name);\n\n\treturn check_refname_format(sb->buf, 0);\n}\n\nint cmd_tag(int argc, const char **argv, const char *prefix)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tstruct strbuf ref = STRBUF_INIT;\n\tstruct strbuf reflog_msg = STRBUF_INIT;\n\tstruct object_id object, prev;\n\tconst char *object_ref, *tag;\n\tstruct create_tag_options opt;\n\tchar *cleanup_arg = NULL;\n\tint create_reflog = 0;\n\tint annotate = 0, force = 0;\n\tint cmdmode = 0, create_tag_object = 0;\n\tconst char *msgfile = NULL, *keyid = NULL;\n\tstruct msg_arg msg = { 0, STRBUF_INIT };\n\tstruct ref_transaction *transaction;\n\tstruct strbuf err = STRBUF_INIT;\n\tstruct ref_filter filter;\n\tstatic struct ref_sorting *sorting = NULL, **sorting_tail = &sorting;\n\tstruct ref_format format = REF_FORMAT_INIT;\n\tint icase = 0;\n\tstruct option options[] = {\n\t\tOPT_CMDMODE('l', \"list\", &cmdmode, N_(\"list tag names\"), 'l'),\n\t\t{ OPTION_INTEGER, 'n', NULL, &filter.lines, N_(\"n\"),\n\t\t\t\tN_(\"print <n> lines of each tag message\"),\n\t\t\t\tPARSE_OPT_OPTARG, NULL, 1 },\n\t\tOPT_CMDMODE('d', \"delete\", &cmdmode, N_(\"delete tags\"), 'd'),\n\t\tOPT_CMDMODE('v', \"verify\", &cmdmode, N_(\"verify tags\"), 'v'),\n\n\t\tOPT_GROUP(N_(\"Tag creation options\")),\n\t\tOPT_BOOL('a', \"annotate\", &annotate,\n\t\t\t\t\tN_(\"annotated tag, needs a message\")),\n\t\tOPT_CALLBACK('m', \"message\", &msg, N_(\"message\"),\n\t\t\t     N_(\"tag message\"), parse_msg_arg),\n\t\tOPT_FILENAME('F', \"file\", &msgfile, N_(\"read message from file\")),\n\t\tOPT_BOOL('s', \"sign\", &opt.sign, N_(\"annotated and GPG-signed tag\")),\n\t\tOPT_STRING(0, \"cleanup\", &cleanup_arg, N_(\"mode\"),\n\t\t\tN_(\"how to strip spaces and #comments from message\")),\n\t\tOPT_STRING('u', \"local-user\", &keyid, N_(\"key-id\"),\n\t\t\t\t\tN_(\"use another key to sign the tag\")),\n\t\tOPT__FORCE(&force, N_(\"replace the tag if exists\")),\n\t\tOPT_BOOL(0, \"create-reflog\", &create_reflog, N_(\"create a reflog\")),\n\n\t\tOPT_GROUP(N_(\"Tag listing options\")),\n\t\tOPT_COLUMN(0, \"column\", &colopts, N_(\"show tag list in columns\")),\n\t\tOPT_CONTAINS(&filter.with_commit, N_(\"print only tags that contain the commit\")),\n\t\tOPT_NO_CONTAINS(&filter.no_commit, N_(\"print only tags that don't contain the commit\")),\n\t\tOPT_WITH(&filter.with_commit, N_(\"print only tags that contain the commit\")),\n\t\tOPT_WITHOUT(&filter.no_commit, N_(\"print only tags that don't contain the commit\")),\n\t\tOPT_MERGED(&filter, N_(\"print only tags that are merged\")),\n\t\tOPT_NO_MERGED(&filter, N_(\"print only tags that are not merged\")),\n\t\tOPT_CALLBACK(0 , \"sort\", sorting_tail, N_(\"key\"),\n\t\t\t     N_(\"field name to sort on\"), &parse_opt_ref_sorting),\n\t\t{\n\t\t\tOPTION_CALLBACK, 0, \"points-at\", &filter.points_at, N_(\"object\"),\n\t\t\tN_(\"print only tags of the object\"), PARSE_OPT_LASTARG_DEFAULT,\n\t\t\tparse_opt_object_name, (intptr_t) \"HEAD\"\n\t\t},\n\t\tOPT_STRING(  0 , \"format\", &format.format, N_(\"format\"),\n\t\t\t   N_(\"format to use for the output\")),\n\t\tOPT__COLOR(&format.use_color, N_(\"respect format colors\")),\n\t\tOPT_BOOL('i', \"ignore-case\", &icase, N_(\"sorting and filtering are case insensitive\")),\n\t\tOPT_END()\n\t};\n\n\tsetup_ref_filter_porcelain_msg();\n\n\tgit_config(git_tag_config, sorting_tail);\n\n\tmemset(&opt, 0, sizeof(opt));\n\tmemset(&filter, 0, sizeof(filter));\n\tfilter.lines = -1;\n\n\targc = parse_options(argc, argv, prefix, options, git_tag_usage, 0);\n\n\tif (keyid) {\n\t\topt.sign = 1;\n\t\tset_signing_key(keyid);\n\t}\n\tcreate_tag_object = (opt.sign || annotate || msg.given || msgfile);\n\n\tif (!cmdmode) {\n\t\tif (argc == 0)\n\t\t\tcmdmode = 'l';\n\t\telse if (filter.with_commit || filter.no_commit ||\n\t\t\t filter.points_at.nr || filter.merge_commit ||\n\t\t\t filter.lines != -1)\n\t\t\tcmdmode = 'l';\n\t}\n\n\tif (cmdmode == 'l')\n\t\tsetup_auto_pager(\"tag\", 1);\n\n\tif ((create_tag_object || force) && (cmdmode != 0))\n\t\tusage_with_options(git_tag_usage, options);\n\n\tfinalize_colopts(&colopts, -1);\n\tif (cmdmode == 'l' && filter.lines != -1) {\n\t\tif (explicitly_enable_column(colopts))\n\t\t\tdie(_(\"--column and -n are incompatible\"));\n\t\tcolopts = 0;\n\t}\n\tif (!sorting)\n\t\tsorting = ref_default_sorting();\n\tsorting->ignore_case = icase;\n\tfilter.ignore_case = icase;\n\tif (cmdmode == 'l') {\n\t\tint ret;\n\t\tif (column_active(colopts)) {\n\t\t\tstruct column_options copts;\n\t\t\tmemset(&copts, 0, sizeof(copts));\n\t\t\tcopts.padding = 2;\n\t\t\trun_column_filter(colopts, &copts);\n\t\t}\n\t\tfilter.name_patterns = argv;\n\t\tret = list_tags(&filter, sorting, &format);\n\t\tif (column_active(colopts))\n\t\t\tstop_column_filter();\n\t\treturn ret;\n\t}\n\tif (filter.lines != -1)\n\t\tdie(_(\"-n option is only allowed in list mode\"));\n\tif (filter.with_commit)\n\t\tdie(_(\"--contains option is only allowed in list mode\"));\n\tif (filter.no_commit)\n\t\tdie(_(\"--no-contains option is only allowed in list mode\"));\n\tif (filter.points_at.nr)\n\t\tdie(_(\"--points-at option is only allowed in list mode\"));\n\tif (filter.merge_commit)\n\t\tdie(_(\"--merged and --no-merged options are only allowed in list mode\"));\n\tif (cmdmode == 'd')\n\t\treturn for_each_tag_name(argv, delete_tag, NULL);\n\tif (cmdmode == 'v') {\n\t\tif (format.format && verify_ref_format(&format))\n\t\t\tusage_with_options(git_tag_usage, options);\n\t\treturn for_each_tag_name(argv, verify_tag, &format);\n\t}\n\n\tif (msg.given || msgfile) {\n\t\tif (msg.given && msgfile)\n\t\t\tdie(_(\"only one -F or -m option is allowed.\"));\n\t\tif (msg.given)\n\t\t\tstrbuf_addbuf(&buf, &(msg.buf));\n\t\telse {\n\t\t\tif (!strcmp(msgfile, \"-\")) {\n\t\t\t\tif (strbuf_read(&buf, 0, 1024) < 0)\n\t\t\t\t\tdie_errno(_(\"cannot read '%s'\"), msgfile);\n\t\t\t} else {\n\t\t\t\tif (strbuf_read_file(&buf, msgfile, 1024) < 0)\n\t\t\t\t\tdie_errno(_(\"could not open or read '%s'\"),\n\t\t\t\t\t\tmsgfile);\n\t\t\t}\n\t\t}\n\t}\n\n\ttag = argv[0];\n\n\tobject_ref = argc == 2 ? argv[1] : \"HEAD\";\n\tif (argc > 2)\n\t\tdie(_(\"too many params\"));\n\n\tif (get_oid(object_ref, &object))\n\t\tdie(_(\"Failed to resolve '%s' as a valid ref.\"), object_ref);\n\n\tif (strbuf_check_tag_ref(&ref, tag))\n\t\tdie(_(\"'%s' is not a valid tag name.\"), tag);\n\n\tif (read_ref(ref.buf, prev.hash))\n\t\toidclr(&prev);\n\telse if (!force)\n\t\tdie(_(\"tag '%s' already exists\"), tag);\n\n\topt.message_given = msg.given || msgfile;\n\n\tif (!cleanup_arg || !strcmp(cleanup_arg, \"strip\"))\n\t\topt.cleanup_mode = CLEANUP_ALL;\n\telse if (!strcmp(cleanup_arg, \"verbatim\"))\n\t\topt.cleanup_mode = CLEANUP_NONE;\n\telse if (!strcmp(cleanup_arg, \"whitespace\"))\n\t\topt.cleanup_mode = CLEANUP_SPACE;\n\telse\n\t\tdie(_(\"Invalid cleanup mode %s\"), cleanup_arg);\n\n\tcreate_reflog_msg(&object, &reflog_msg);\n\n\tif (create_tag_object) {\n\t\tif (force_sign_annotate && !annotate)\n\t\t\topt.sign = 1;\n\t\tcreate_tag(&object, tag, &buf, &opt, &prev, &object);\n\t}\n\n\ttransaction = ref_transaction_begin(&err);\n\tif (!transaction ||\n\t    ref_transaction_update(transaction, ref.buf, object.hash, prev.hash,\n\t\t\t\t   create_reflog ? REF_FORCE_CREATE_REFLOG : 0,\n\t\t\t\t   reflog_msg.buf, &err) ||\n\t    ref_transaction_commit(transaction, &err))\n\t\tdie(\"%s\", err.buf);\n\tref_transaction_free(transaction);\n\tif (force && !is_null_oid(&prev) && oidcmp(&prev, &object))\n\t\tprintf(_(\"Updated tag '%s' (was %s)\\n\"), tag, find_unique_abbrev(prev.hash, DEFAULT_ABBREV));\n\n\tstrbuf_release(&err);\n\tstrbuf_release(&buf);\n\tstrbuf_release(&ref);\n\tstrbuf_release(&reflog_msg);\n\treturn 0;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00382a56f564bf55de13ba712b8e728b3b1c9b86",
  "sha1_ok": true,
  "size": 15477
}
