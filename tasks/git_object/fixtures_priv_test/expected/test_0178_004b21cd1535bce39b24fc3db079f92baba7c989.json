{
  "content": {
    "base64": "IyEvYmluL3NoCiMKIyBnaXQtc3VibW9kdWxlLnNoOiBhZGQsIGluaXQsIHVwZGF0ZSBvciBsaXN0IGdpdCBzdWJtb2R1bGVzCiMKIyBDb3B5cmlnaHQgKGMpIDIwMDcgTGFycyBIamVtbGkKCmRhc2hsZXNzPSQoYmFzZW5hbWUgIiQwIiB8IHNlZCAtZSAncy8tLyAvJykKVVNBR0U9IlstLXF1aWV0XSBhZGQgWy1iIDxicmFuY2g+XSBbLWZ8LS1mb3JjZV0gWy0tbmFtZSA8bmFtZT5dIFstLXJlZmVyZW5jZSA8cmVwb3NpdG9yeT5dIFstLV0gPHJlcG9zaXRvcnk+IFs8cGF0aD5dCiAgIG9yOiAkZGFzaGxlc3MgWy0tcXVpZXRdIHN0YXR1cyBbLS1jYWNoZWRdIFstLXJlY3Vyc2l2ZV0gWy0tXSBbPHBhdGg+Li4uXQogICBvcjogJGRhc2hsZXNzIFstLXF1aWV0XSBpbml0IFstLV0gWzxwYXRoPi4uLl0KICAgb3I6ICRkYXNobGVzcyBbLS1xdWlldF0gZGVpbml0IFstZnwtLWZvcmNlXSBbLS1dIDxwYXRoPi4uLgogICBvcjogJGRhc2hsZXNzIFstLXF1aWV0XSB1cGRhdGUgWy0taW5pdF0gWy0tcmVtb3RlXSBbLU58LS1uby1mZXRjaF0gWy1mfC0tZm9yY2VdIFstLXJlYmFzZV0gWy0tcmVmZXJlbmNlIDxyZXBvc2l0b3J5Pl0gWy0tbWVyZ2VdIFstLXJlY3Vyc2l2ZV0gWy0tXSBbPHBhdGg+Li4uXQogICBvcjogJGRhc2hsZXNzIFstLXF1aWV0XSBzdW1tYXJ5IFstLWNhY2hlZHwtLWZpbGVzXSBbLS1zdW1tYXJ5LWxpbWl0IDxuPl0gW2NvbW1pdF0gWy0tXSBbPHBhdGg+Li4uXQogICBvcjogJGRhc2hsZXNzIFstLXF1aWV0XSBmb3JlYWNoIFstLXJlY3Vyc2l2ZV0gPGNvbW1hbmQ+CiAgIG9yOiAkZGFzaGxlc3MgWy0tcXVpZXRdIHN5bmMgWy0tcmVjdXJzaXZlXSBbLS1dIFs8cGF0aD4uLi5dIgpPUFRJT05TX1NQRUM9ClNVQkRJUkVDVE9SWV9PSz1ZZXMKLiBnaXQtc2gtc2V0dXAKLiBnaXQtc2gtaTE4bgouIGdpdC1wYXJzZS1yZW1vdGUKcmVxdWlyZV93b3JrX3RyZWUKd3RfcHJlZml4PSQoZ2l0IHJldi1wYXJzZSAtLXNob3ctcHJlZml4KQpjZF90b190b3BsZXZlbAoKY29tbWFuZD0KYnJhbmNoPQpmb3JjZT0KcmVmZXJlbmNlPQpjYWNoZWQ9CnJlY3Vyc2l2ZT0KaW5pdD0KZmlsZXM9CnJlbW90ZT0Kbm9mZXRjaD0KdXBkYXRlPQpwcmVmaXg9CmN1c3RvbV9uYW1lPQpkZXB0aD0KCiMgVGhlIGZ1bmN0aW9uIHRha2VzIGF0IG1vc3QgMiBhcmd1bWVudHMuIFRoZSBmaXJzdCBhcmd1bWVudCBpcyB0aGUKIyBVUkwgdGhhdCBuYXZpZ2F0ZXMgdG8gdGhlIHN1Ym1vZHVsZSBvcmlnaW4gcmVwby4gV2hlbiByZWxhdGl2ZSwgdGhpcyBVUkwKIyBpcyByZWxhdGl2ZSB0byB0aGUgc3VwZXJwcm9qZWN0IG9yaWdpbiBVUkwgcmVwby4gVGhlIHNlY29uZCB1cF9wYXRoCiMgYXJndW1lbnQsIGlmIHNwZWNpZmllZCwgaXMgdGhlIHJlbGF0aXZlIHBhdGggdGhhdCBuYXZpZ2F0ZXMKIyBmcm9tIHRoZSBzdWJtb2R1bGUgd29ya2luZyB0cmVlIHRvIHRoZSBzdXBlcnByb2plY3Qgd29ya2luZyB0cmVlLgojCiMgVGhlIG91dHB1dCBvZiB0aGUgZnVuY3Rpb24gaXMgdGhlIG9yaWdpbiBVUkwgb2YgdGhlIHN1Ym1vZHVsZS4KIwojIFRoZSBvdXRwdXQgd2lsbCBlaXRoZXIgYmUgYW4gYWJzb2x1dGUgVVJMIG9yIGZpbGVzeXN0ZW0gcGF0aCAoaWYgdGhlCiMgc3VwZXJwcm9qZWN0IG9yaWdpbiBVUkwgaXMgYW4gYWJzb2x1dGUgVVJMIG9yIGZpbGVzeXN0ZW0gcGF0aCwKIyByZXNwZWN0aXZlbHkpIG9yIGEgcmVsYXRpdmUgZmlsZSBzeXN0ZW0gcGF0aCAoaWYgdGhlIHN1cGVycHJvamVjdAojIG9yaWdpbiBVUkwgaXMgYSByZWxhdGl2ZSBmaWxlIHN5c3RlbSBwYXRoKS4KIwojIFdoZW4gdGhlIG91dHB1dCBpcyBhIHJlbGF0aXZlIGZpbGUgc3lzdGVtIHBhdGgsIHRoZSBwYXRoIGlzIGVpdGhlcgojIHJlbGF0aXZlIHRvIHRoZSBzdWJtb2R1bGUgd29ya2luZyB0cmVlLCBpZiB1cF9wYXRoIGlzIHNwZWNpZmllZCwgb3IgdG8KIyB0aGUgc3VwZXJwcm9qZWN0IHdvcmtpbmcgdHJlZSBvdGhlcndpc2UuCnJlc29sdmVfcmVsYXRpdmVfdXJsICgpCnsKCXJlbW90ZT0kKGdldF9kZWZhdWx0X3JlbW90ZSkKCXJlbW90ZXVybD0kKGdpdCBjb25maWcgInJlbW90ZS4kcmVtb3RlLnVybCIpIHx8CgkJcmVtb3RldXJsPSQocHdkKSAjIHRoZSByZXBvc2l0b3J5IGlzIGl0cyBvd24gYXV0aG9yaXRhdGl2ZSB1cHN0cmVhbQoJdXJsPSIkMSIKCXJlbW90ZXVybD0ke3JlbW90ZXVybCUvfQoJc2VwPS8KCXVwX3BhdGg9IiQyIgoKCWNhc2UgIiRyZW1vdGV1cmwiIGluCgkqOip8LyopCgkJaXNfcmVsYXRpdmU9CgkJOzsKCS4vKnwuLi8qKQoJCWlzX3JlbGF0aXZlPXQKCQk7OwoJKikKCQlpc19yZWxhdGl2ZT10CgkJcmVtb3RldXJsPSIuLyRyZW1vdGV1cmwiCgkJOzsKCWVzYWMKCgl3aGlsZSB0ZXN0IC1uICIkdXJsIgoJZG8KCQljYXNlICIkdXJsIiBpbgoJCS4uLyopCgkJCXVybD0iJHt1cmwjLi4vfSIKCQkJY2FzZSAiJHJlbW90ZXVybCIgaW4KCQkJKi8qKQoJCQkJcmVtb3RldXJsPSIke3JlbW90ZXVybCUvKn0iCgkJCQk7OwoJCQkqOiopCgkJCQlyZW1vdGV1cmw9IiR7cmVtb3RldXJsJToqfSIKCQkJCXNlcD06CgkJCQk7OwoJCQkqKQoJCQkJaWYgdGVzdCAteiAiJGlzX3JlbGF0aXZlIiB8fCB0ZXN0ICIuIiA9ICIkcmVtb3RldXJsIgoJCQkJdGhlbgoJCQkJCWRpZSAiJChldmFsX2dldHRleHQgImNhbm5vdCBzdHJpcCBvbmUgY29tcG9uZW50IG9mZiB1cmwgJ1wkcmVtb3RldXJsJyIpIgoJCQkJZWxzZQoJCQkJCXJlbW90ZXVybD0uCgkJCQlmaQoJCQkJOzsKCQkJZXNhYwoJCQk7OwoJCS4vKikKCQkJdXJsPSIke3VybCMuL30iCgkJCTs7CgkJKikKCQkJYnJlYWs7OwoJCWVzYWMKCWRvbmUKCXJlbW90ZXVybD0iJHJlbW90ZXVybCRzZXAke3VybCUvfSIKCWVjaG8gIiR7aXNfcmVsYXRpdmU6KyR7dXBfcGF0aH19JHtyZW1vdGV1cmwjLi99Igp9CgojIFJlc29sdmUgYSBwYXRoIHRvIGJlIHJlbGF0aXZlIHRvIGFub3RoZXIgcGF0aC4gIFRoaXMgaXMgaW50ZW5kZWQgZm9yCiMgY29udmVydGluZyBzdWJtb2R1bGUgcGF0aHMgd2hlbiBnaXQtc3VibW9kdWxlIGlzIHJ1biBpbiBhIHN1YmRpcmVjdG9yeQojIGFuZCBvbmx5IGhhbmRsZXMgcGF0aHMgd2hlcmUgdGhlIGRpcmVjdG9yeSBzZXBhcmF0b3IgaXMgJy8nLgojCiMgVGhlIG91dHB1dCBpcyB0aGUgZmlyc3QgYXJndW1lbnQgYXMgYSBwYXRoIHJlbGF0aXZlIHRvIHRoZSBzZWNvbmQgYXJndW1lbnQsCiMgd2hpY2ggZGVmYXVsdHMgdG8gJHd0X3ByZWZpeCBpZiBpdCBpcyBvbWl0dGVkLgpyZWxhdGl2ZV9wYXRoICgpCnsKCWxvY2FsIHRhcmdldCBjdXJkaXIgcmVzdWx0Cgl0YXJnZXQ9JDEKCWN1cmRpcj0kezItJHd0X3ByZWZpeH0KCWN1cmRpcj0ke2N1cmRpciUvfQoJcmVzdWx0PQoKCXdoaWxlIHRlc3QgLW4gIiRjdXJkaXIiCglkbwoJCWNhc2UgIiR0YXJnZXQiIGluCgkJIiRjdXJkaXIvIiopCgkJCXRhcmdldD0ke3RhcmdldCMiJGN1cmRpciIvfQoJCQlicmVhawoJCQk7OwoJCWVzYWMKCgkJcmVzdWx0PSIke3Jlc3VsdH0uLi8iCgkJaWYgdGVzdCAiJGN1cmRpciIgPSAiJHtjdXJkaXIlLyp9IgoJCXRoZW4KCQkJY3VyZGlyPQoJCWVsc2UKCQkJY3VyZGlyPSIke2N1cmRpciUvKn0iCgkJZmkKCWRvbmUKCgllY2hvICIkcmVzdWx0JHRhcmdldCIKfQoKIwojIEdldCBzdWJtb2R1bGUgaW5mbyBmb3IgcmVnaXN0ZXJlZCBzdWJtb2R1bGVzCiMgJEAgPSBwYXRoIHRvIGxpbWl0IHN1Ym1vZHVsZSBsaXN0CiMKbW9kdWxlX2xpc3QoKQp7CglldmFsICJzZXQgJChnaXQgcmV2LXBhcnNlIC0tc3EgLS1wcmVmaXggIiR3dF9wcmVmaXgiIC0tICIkQCIpIgoJKAoJCWdpdCBscy1maWxlcyAteiAtLWVycm9yLXVubWF0Y2ggLS1zdGFnZSAtLSAiJEAiIHx8CgkJZWNobyAidW5tYXRjaGVkIHBhdGhzcGVjIGV4aXN0cyIKCSkgfAoJcGVybCAtZSAnCglteSAldW5tZXJnZWQgPSAoKTsKCW15ICgkbnVsbF9zaGExKSA9ICgiMCIgeCA0MCk7CglteSBAb3V0ID0gKCk7CglteSAkdW5tYXRjaGVkID0gMDsKCSQvID0gIlwwIjsKCXdoaWxlICg8U1RESU4+KSB7CgkJaWYgKC9edW5tYXRjaGVkIHBhdGhzcGVjLykgewoJCQkkdW5tYXRjaGVkID0gMTsKCQkJbmV4dDsKCQl9CgkJY2hvbXA7CgkJbXkgKCRtb2RlLCAkc2hhMSwgJHN0YWdlLCAkcGF0aCkgPQoJCQkvXihbMC03XSspIChbMC05YS1mXXs0MH0pIChbMC0zXSlcdCguKikkLzsKCQluZXh0IHVubGVzcyAkbW9kZSBlcSAiMTYwMDAwIjsKCQlpZiAoJHN0YWdlIG5lICIwIikgewoJCQlpZiAoISR1bm1lcmdlZHskcGF0aH0rKykgewoJCQkJcHVzaCBAb3V0LCAiJG1vZGUgJG51bGxfc2hhMSBVXHQkcGF0aFxuIjsKCQkJfQoJCQluZXh0OwoJCX0KCQlwdXNoIEBvdXQsICIkX1xuIjsKCX0KCWlmICgkdW5tYXRjaGVkKSB7CgkJcHJpbnQgIiN1bm1hdGNoZWRcbiI7Cgl9IGVsc2UgewoJCXByaW50IGZvciAoQG91dCk7Cgl9CgknCn0KCmRpZV9pZl91bm1hdGNoZWQgKCkKewoJaWYgdGVzdCAiJDEiID0gIiN1bm1hdGNoZWQiCgl0aGVuCgkJZXhpdCAxCglmaQp9CgojCiMgUHJpbnQgYSBzdWJtb2R1bGUgY29uZmlndXJhdGlvbiBzZXR0aW5nCiMKIyAkMSA9IHN1Ym1vZHVsZSBuYW1lCiMgJDIgPSBvcHRpb24gbmFtZQojICQzID0gZGVmYXVsdCB2YWx1ZQojCiMgQ2hlY2tzIGluIHRoZSB1c3VhbCBnaXQtY29uZmlnIHBsYWNlcyBmaXJzdCAoZm9yIG92ZXJyaWRlcyksCiMgb3RoZXJ3aXNlIGl0IGZhbGxzIGJhY2sgb24gLmdpdG1vZHVsZXMuICBUaGlzIGFsbG93cyB5b3UgdG8KIyBkaXN0cmlidXRlIHByb2plY3Qtd2lkZSBkZWZhdWx0cyBpbiAuZ2l0bW9kdWxlcywgd2hpbGUgc3RpbGwKIyBjdXN0b21pemluZyBpbmRpdmlkdWFsIHJlcG9zaXRvcmllcyBpZiBuZWNlc3NhcnkuICBJZiB0aGUgb3B0aW9uIGlzCiMgbm90IGluIC5naXRtb2R1bGVzIGVpdGhlciwgcHJpbnQgYSBkZWZhdWx0IHZhbHVlLgojCmdldF9zdWJtb2R1bGVfY29uZmlnICgpIHsKCW5hbWU9IiQxIgoJb3B0aW9uPSIkMiIKCWRlZmF1bHQ9IiQzIgoJdmFsdWU9JChnaXQgY29uZmlnIHN1Ym1vZHVsZS4iJG5hbWUiLiIkb3B0aW9uIikKCWlmIHRlc3QgLXogIiR2YWx1ZSIKCXRoZW4KCQl2YWx1ZT0kKGdpdCBjb25maWcgLWYgLmdpdG1vZHVsZXMgc3VibW9kdWxlLiIkbmFtZSIuIiRvcHRpb24iKQoJZmkKCXByaW50ZiAnJXMnICIke3ZhbHVlOi0kZGVmYXVsdH0iCn0KCgojCiMgTWFwIHN1Ym1vZHVsZSBwYXRoIHRvIHN1Ym1vZHVsZSBuYW1lCiMKIyAkMSA9IHBhdGgKIwptb2R1bGVfbmFtZSgpCnsKCSMgRG8gd2UgaGF2ZSAic3VibW9kdWxlLjxzb21ldGhpbmc+LnBhdGggPSAkMSIgZGVmaW5lZCBpbiAuZ2l0bW9kdWxlcyBmaWxlPwoJc21fcGF0aD0iJDEiCglyZT0kKHByaW50ZiAnJXNcbicgIiQxIiB8IHNlZCAtZSAncy9bXS5bXiRcXCpdL1xcJi9nJykKCW5hbWU9JCggZ2l0IGNvbmZpZyAtZiAuZ2l0bW9kdWxlcyAtLWdldC1yZWdleHAgJ15zdWJtb2R1bGVcLi4qXC5wYXRoJCcgfAoJCXNlZCAtbiAtZSAnc3xec3VibW9kdWxlXC5cKC4qXClcLnBhdGggJyIkcmUiJyR8XDF8cCcgKQoJdGVzdCAteiAiJG5hbWUiICYmCglkaWUgIiQoZXZhbF9nZXR0ZXh0ICJObyBzdWJtb2R1bGUgbWFwcGluZyBmb3VuZCBpbiAuZ2l0bW9kdWxlcyBmb3IgcGF0aCAnXCRzbV9wYXRoJyIpIgoJZWNobyAiJG5hbWUiCn0KCiMKIyBDbG9uZSBhIHN1Ym1vZHVsZQojCiMgUHJpb3IgdG8gY2FsbGluZywgY21kX3VwZGF0ZSBjaGVja3MgdGhhdCBhIHBvc3NpYmx5IGV4aXN0aW5nCiMgcGF0aCBpcyBub3QgYSBnaXQgcmVwb3NpdG9yeS4KIyBMaWtld2lzZSwgY21kX2FkZCBjaGVja3MgdGhhdCBwYXRoIGRvZXMgbm90IGV4aXN0IGF0IGFsbCwKIyBzaW5jZSBpdCBpcyB0aGUgbG9jYXRpb24gb2YgYSBuZXcgc3VibW9kdWxlLgojCm1vZHVsZV9jbG9uZSgpCnsKCXNtX3BhdGg9JDEKCW5hbWU9JDIKCXVybD0kMwoJcmVmZXJlbmNlPSIkNCIKCWRlcHRoPSIkNSIKCXF1aWV0PQoJaWYgdGVzdCAtbiAiJEdJVF9RVUlFVCIKCXRoZW4KCQlxdWlldD0tcQoJZmkKCglnaXRkaXI9CglnaXRkaXJfYmFzZT0KCWJhc2VfbmFtZT0kKGRpcm5hbWUgIiRuYW1lIikKCglnaXRkaXI9JChnaXQgcmV2LXBhcnNlIC0tZ2l0LWRpcikKCWdpdGRpcl9iYXNlPSIkZ2l0ZGlyL21vZHVsZXMvJGJhc2VfbmFtZSIKCWdpdGRpcj0iJGdpdGRpci9tb2R1bGVzLyRuYW1lIgoKCWlmIHRlc3QgLWQgIiRnaXRkaXIiCgl0aGVuCgkJbWtkaXIgLXAgIiRzbV9wYXRoIgoJCXJtIC1mICIkZ2l0ZGlyL2luZGV4IgoJZWxzZQoJCW1rZGlyIC1wICIkZ2l0ZGlyX2Jhc2UiCgkJKAoJCQljbGVhcl9sb2NhbF9naXRfZW52CgkJCWdpdCBjbG9uZSAkcXVpZXQgJHtkZXB0aDorIiRkZXB0aCJ9IC1uICR7cmVmZXJlbmNlOisiJHJlZmVyZW5jZSJ9IFwKCQkJCS0tc2VwYXJhdGUtZ2l0LWRpciAiJGdpdGRpciIgIiR1cmwiICIkc21fcGF0aCIKCQkpIHx8CgkJZGllICIkKGV2YWxfZ2V0dGV4dCAiQ2xvbmUgb2YgJ1wkdXJsJyBpbnRvIHN1Ym1vZHVsZSBwYXRoICdcJHNtX3BhdGgnIGZhaWxlZCIpIgoJZmkKCgkjIFdlIGFscmVhZHkgYXJlIGF0IHRoZSByb290IG9mIHRoZSB3b3JrIHRyZWUgYnV0IGNkX3RvX3RvcGxldmVsIHdpbGwKCSMgcmVzb2x2ZSBhbnkgc3ltbGlua3MgdGhhdCBtaWdodCBiZSBwcmVzZW50IGluICRQV0QKCWE9JChjZF90b190b3BsZXZlbCAmJiBjZCAiJGdpdGRpciIgJiYgcHdkKS8KCWI9JChjZF90b190b3BsZXZlbCAmJiBjZCAiJHNtX3BhdGgiICYmIHB3ZCkvCgkjIG5vcm1hbGl6ZSBXaW5kb3dzLXN0eWxlIGFic29sdXRlIHBhdGhzIHRvIFBPU0lYLXN0eWxlIGFic29sdXRlIHBhdGhzCgljYXNlICRhIGluIFthLXpBLVpdOi8qKSBhPS8ke2ElJToqfSR7YSMqOn0gOzsgZXNhYwoJY2FzZSAkYiBpbiBbYS16QS1aXTovKikgYj0vJHtiJSU6Kn0ke2IjKjp9IDs7IGVzYWMKCSMgUmVtb3ZlIGFsbCBjb21tb24gbGVhZGluZyBkaXJlY3RvcmllcyBhZnRlciBhIHNhbml0eSBjaGVjawoJaWYgdGVzdCAiJHthIyRifSIgIT0gIiRhIiB8fCB0ZXN0ICIke2IjJGF9IiAhPSAiJGIiOyB0aGVuCgkJZGllICIkKGV2YWxfZ2V0dGV4dCAiR2l0ZGlyICdcJGEnIGlzIHBhcnQgb2YgdGhlIHN1Ym1vZHVsZSBwYXRoICdcJGInIG9yIHZpY2UgdmVyc2EiKSIKCWZpCgl3aGlsZSB0ZXN0ICIke2ElJS8qfSIgPSAiJHtiJSUvKn0iCglkbwoJCWE9JHthIyovfQoJCWI9JHtiIyovfQoJZG9uZQoJIyBOb3cgY2hvcCBvZmYgdGhlIHRyYWlsaW5nICcvJ3MgdGhhdCB3ZXJlIGFkZGVkIGluIHRoZSBiZWdpbm5pbmcKCWE9JHthJS99CgliPSR7YiUvfQoKCSMgVHVybiBlYWNoIGxlYWRpbmcgIiovIiBjb21wb25lbnQgaW50byAiLi4vIgoJcmVsPSQoZWNobyAkYiB8IHNlZCAtZSAnc3xbXi9dW14vXSp8Li58ZycpCgllY2hvICJnaXRkaXI6ICRyZWwvJGEiID4iJHNtX3BhdGgvLmdpdCIKCglyZWw9JChlY2hvICRhIHwgc2VkIC1lICdzfFteL11bXi9dKnwuLnxnJykKCShjbGVhcl9sb2NhbF9naXRfZW52OyBjZCAiJHNtX3BhdGgiICYmIEdJVF9XT1JLX1RSRUU9LiBnaXQgY29uZmlnIGNvcmUud29ya3RyZWUgIiRyZWwvJGIiKQp9Cgppc251bWJlcigpCnsKCW49JCgoJDEgKyAwKSkgMj4vZGV2L251bGwgJiYgdGVzdCAiJG4iID0gIiQxIgp9CgojCiMgQWRkIGEgbmV3IHN1Ym1vZHVsZSB0byB0aGUgd29ya2luZyB0cmVlLCAuZ2l0bW9kdWxlcyBhbmQgdGhlIGluZGV4CiMKIyAkQCA9IHJlcG8gcGF0aAojCiMgb3B0aW9uYWwgYnJhbmNoIGlzIHN0b3JlZCBpbiBnbG9iYWwgYnJhbmNoIHZhcmlhYmxlCiMKY21kX2FkZCgpCnsKCSMgcGFyc2UgJGFyZ3MgYWZ0ZXIgInN1Ym1vZHVsZSAuLi4gYWRkIi4KCXJlZmVyZW5jZV9wYXRoPQoJd2hpbGUgdGVzdCAkIyAtbmUgMAoJZG8KCQljYXNlICIkMSIgaW4KCQktYiB8IC0tYnJhbmNoKQoJCQljYXNlICIkMiIgaW4gJycpIHVzYWdlIDs7IGVzYWMKCQkJYnJhbmNoPSQyCgkJCXNoaWZ0CgkJCTs7CgkJLWYgfCAtLWZvcmNlKQoJCQlmb3JjZT0kMQoJCQk7OwoJCS1xfC0tcXVpZXQpCgkJCUdJVF9RVUlFVD0xCgkJCTs7CgkJLS1yZWZlcmVuY2UpCgkJCWNhc2UgIiQyIiBpbiAnJykgdXNhZ2UgOzsgZXNhYwoJCQlyZWZlcmVuY2VfcGF0aD0kMgoJCQlzaGlmdAoJCQk7OwoJCS0tcmVmZXJlbmNlPSopCgkJCXJlZmVyZW5jZV9wYXRoPSIkezEjLS1yZWZlcmVuY2U9fSIKCQkJOzsKCQktLW5hbWUpCgkJCWNhc2UgIiQyIiBpbiAnJykgdXNhZ2UgOzsgZXNhYwoJCQljdXN0b21fbmFtZT0kMgoJCQlzaGlmdAoJCQk7OwoJCS0tZGVwdGgpCgkJCWNhc2UgIiQyIiBpbiAnJykgdXNhZ2UgOzsgZXNhYwoJCQlkZXB0aD0iLS1kZXB0aD0kMiIKCQkJc2hpZnQKCQkJOzsKCQktLWRlcHRoPSopCgkJCWRlcHRoPSQxCgkJCTs7CgkJLS0pCgkJCXNoaWZ0CgkJCWJyZWFrCgkJCTs7CgkJLSopCgkJCXVzYWdlCgkJCTs7CgkJKikKCQkJYnJlYWsKCQkJOzsKCQllc2FjCgkJc2hpZnQKCWRvbmUKCglpZiB0ZXN0IC1uICIkcmVmZXJlbmNlX3BhdGgiCgl0aGVuCgkJaXNfYWJzb2x1dGVfcGF0aCAiJHJlZmVyZW5jZV9wYXRoIiB8fAoJCXJlZmVyZW5jZV9wYXRoPSIkd3RfcHJlZml4JHJlZmVyZW5jZV9wYXRoIgoKCQlyZWZlcmVuY2U9Ii0tcmVmZXJlbmNlPSRyZWZlcmVuY2VfcGF0aCIKCWZpCgoJcmVwbz0kMQoJc21fcGF0aD0kMgoKCWlmIHRlc3QgLXogIiRzbV9wYXRoIjsgdGhlbgoJCXNtX3BhdGg9JChlY2hvICIkcmVwbyIgfAoJCQlzZWQgLWUgJ3N8LyR8fCcgLWUgJ3N8OiovKlwuZ2l0JHx8JyAtZSAnc3wuKlsvOl18fGcnKQoJZmkKCglpZiB0ZXN0IC16ICIkcmVwbyIgLW8gLXogIiRzbV9wYXRoIjsgdGhlbgoJCXVzYWdlCglmaQoKCWlzX2Fic29sdXRlX3BhdGggIiRzbV9wYXRoIiB8fCBzbV9wYXRoPSIkd3RfcHJlZml4JHNtX3BhdGgiCgoJIyBhc3N1cmUgcmVwbyBpcyBhYnNvbHV0ZSBvciByZWxhdGl2ZSB0byBwYXJlbnQKCWNhc2UgIiRyZXBvIiBpbgoJLi8qfC4uLyopCgkJdGVzdCAteiAiJHd0X3ByZWZpeCIgfHwKCQlkaWUgIiQoZ2V0dGV4dCAiUmVsYXRpdmUgcGF0aCBjYW4gb25seSBiZSB1c2VkIGZyb20gdGhlIHRvcGxldmVsIG9mIHRoZSB3b3JraW5nIHRyZWUiKSIKCgkJIyBkZXJlZmVyZW5jZSBzb3VyY2UgdXJsIHJlbGF0aXZlIHRvIHBhcmVudCdzIHVybAoJCXJlYWxyZXBvPSQocmVzb2x2ZV9yZWxhdGl2ZV91cmwgIiRyZXBvIikgfHwgZXhpdAoJCTs7CgkqOip8LyopCgkJIyBhYnNvbHV0ZSB1cmwKCQlyZWFscmVwbz0kcmVwbwoJCTs7CgkqKQoJCWRpZSAiJChldmFsX2dldHRleHQgInJlcG8gVVJMOiAnXCRyZXBvJyBtdXN0IGJlIGFic29sdXRlIG9yIGJlZ2luIHdpdGggLi98Li4vIikiCgk7OwoJZXNhYwoKCSMgbm9ybWFsaXplIHBhdGg6CgkjIG11bHRpcGxlIC8vOyBsZWFkaW5nIC4vOyAvLi87IC8uLi87IHRyYWlsaW5nIC8KCXNtX3BhdGg9JChwcmludGYgJyVzL1xuJyAiJHNtX3BhdGgiIHwKCQlzZWQgLWUgJwoJCQlzfC8vKnwvfGcKCQkJc3xeXChcLi9cKSp8fAoJCQlzfC9cLi98L3xnCgkJCTpzdGFydAoJCQlzfFwoW14vXSpcKS9cLlwuL3x8CgkJCXRzdGFydAoJCQlzfC8qJHx8CgkJJykKCWdpdCBscy1maWxlcyAtLWVycm9yLXVubWF0Y2ggIiRzbV9wYXRoIiA+IC9kZXYvbnVsbCAyPiYxICYmCglkaWUgIiQoZXZhbF9nZXR0ZXh0ICInXCRzbV9wYXRoJyBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgaW5kZXgiKSIKCglpZiB0ZXN0IC16ICIkZm9yY2UiICYmICEgZ2l0IGFkZCAtLWRyeS1ydW4gLS1pZ25vcmUtbWlzc2luZyAiJHNtX3BhdGgiID4gL2Rldi9udWxsIDI+JjEKCXRoZW4KCQlldmFsX2dldHRleHRsbiAiVGhlIGZvbGxvd2luZyBwYXRoIGlzIGlnbm9yZWQgYnkgb25lIG9mIHlvdXIgLmdpdGlnbm9yZSBmaWxlczoKXCRzbV9wYXRoClVzZSAtZiBpZiB5b3UgcmVhbGx5IHdhbnQgdG8gYWRkIGl0LiIgPiYyCgkJZXhpdCAxCglmaQoKCWlmIHRlc3QgLW4gIiRjdXN0b21fbmFtZSIKCXRoZW4KCQlzbV9uYW1lPSIkY3VzdG9tX25hbWUiCgllbHNlCgkJc21fbmFtZT0iJHNtX3BhdGgiCglmaQoKCSMgcGVyaGFwcyB0aGUgcGF0aCBleGlzdHMgYW5kIGlzIGFscmVhZHkgYSBnaXQgcmVwbywgZWxzZSBjbG9uZSBpdAoJaWYgdGVzdCAtZSAiJHNtX3BhdGgiCgl0aGVuCgkJaWYgdGVzdCAtZCAiJHNtX3BhdGgiLy5naXQgLW8gLWYgIiRzbV9wYXRoIi8uZ2l0CgkJdGhlbgoJCQlldmFsX2dldHRleHRsbiAiQWRkaW5nIGV4aXN0aW5nIHJlcG8gYXQgJ1wkc21fcGF0aCcgdG8gdGhlIGluZGV4IgoJCWVsc2UKCQkJZGllICIkKGV2YWxfZ2V0dGV4dCAiJ1wkc21fcGF0aCcgYWxyZWFkeSBleGlzdHMgYW5kIGlzIG5vdCBhIHZhbGlkIGdpdCByZXBvIikiCgkJZmkKCgllbHNlCgkJaWYgdGVzdCAtZCAiLmdpdC9tb2R1bGVzLyRzbV9uYW1lIgoJCXRoZW4KCQkJaWYgdGVzdCAteiAiJGZvcmNlIgoJCQl0aGVuCgkJCQllY2hvID4mMiAiJChldmFsX2dldHRleHQgIkEgZ2l0IGRpcmVjdG9yeSBmb3IgJ1wkc21fbmFtZScgaXMgZm91bmQgbG9jYWxseSB3aXRoIHJlbW90ZShzKToiKSIKCQkJCUdJVF9ESVI9Ii5naXQvbW9kdWxlcy8kc21fbmFtZSIgR0lUX1dPUktfVFJFRT0uIGdpdCByZW1vdGUgLXYgfCBncmVwICcoZmV0Y2gpJyB8IHNlZCAtZSBzLF4sIiAgIiwgLWUgcywnIChmZXRjaCknLCwgPiYyCgkJCQllY2hvID4mMiAiJChldmFsX2dldHRleHQgIklmIHlvdSB3YW50IHRvIHJldXNlIHRoaXMgbG9jYWwgZ2l0IGRpcmVjdG9yeSBpbnN0ZWFkIG9mIGNsb25pbmcgYWdhaW4gZnJvbSIpIgoJCQkJZWNobyA+JjIgIiAgJHJlYWxyZXBvIgoJCQkJZWNobyA+JjIgIiQoZXZhbF9nZXR0ZXh0ICJ1c2UgdGhlICctLWZvcmNlJyBvcHRpb24uIElmIHRoZSBsb2NhbCBnaXQgZGlyZWN0b3J5IGlzIG5vdCB0aGUgY29ycmVjdCByZXBvIikiCgkJCQlkaWUgIiQoZXZhbF9nZXR0ZXh0ICJvciB5b3UgYXJlIHVuc3VyZSB3aGF0IHRoaXMgbWVhbnMgY2hvb3NlIGFub3RoZXIgbmFtZSB3aXRoIHRoZSAnLS1uYW1lJyBvcHRpb24uIikiCgkJCWVsc2UKCQkJCWVjaG8gIiQoZXZhbF9nZXR0ZXh0ICJSZWFjdGl2YXRpbmcgbG9jYWwgZ2l0IGRpcmVjdG9yeSBmb3Igc3VibW9kdWxlICdcJHNtX25hbWUnLiIpIgoJCQlmaQoJCWZpCgkJbW9kdWxlX2Nsb25lICIkc21fcGF0aCIgIiRzbV9uYW1lIiAiJHJlYWxyZXBvIiAiJHJlZmVyZW5jZSIgIiRkZXB0aCIgfHwgZXhpdAoJCSgKCQkJY2xlYXJfbG9jYWxfZ2l0X2VudgoJCQljZCAiJHNtX3BhdGgiICYmCgkJCSMgYXNoIGZhaWxzIHRvIHdvcmRzcGxpdCAke2JyYW5jaDorLWIgIiRicmFuY2giLi4ufQoJCQljYXNlICIkYnJhbmNoIiBpbgoJCQknJykgZ2l0IGNoZWNrb3V0IC1mIC1xIDs7CgkJCT8qKSBnaXQgY2hlY2tvdXQgLWYgLXEgLUIgIiRicmFuY2giICJvcmlnaW4vJGJyYW5jaCIgOzsKCQkJZXNhYwoJCSkgfHwgZGllICIkKGV2YWxfZ2V0dGV4dCAiVW5hYmxlIHRvIGNoZWNrb3V0IHN1Ym1vZHVsZSAnXCRzbV9wYXRoJyIpIgoJZmkKCWdpdCBjb25maWcgc3VibW9kdWxlLiIkc21fbmFtZSIudXJsICIkcmVhbHJlcG8iCgoJZ2l0IGFkZCAkZm9yY2UgIiRzbV9wYXRoIiB8fAoJZGllICIkKGV2YWxfZ2V0dGV4dCAiRmFpbGVkIHRvIGFkZCBzdWJtb2R1bGUgJ1wkc21fcGF0aCciKSIKCglnaXQgY29uZmlnIC1mIC5naXRtb2R1bGVzIHN1Ym1vZHVsZS4iJHNtX25hbWUiLnBhdGggIiRzbV9wYXRoIiAmJgoJZ2l0IGNvbmZpZyAtZiAuZ2l0bW9kdWxlcyBzdWJtb2R1bGUuIiRzbV9uYW1lIi51cmwgIiRyZXBvIiAmJgoJaWYgdGVzdCAtbiAiJGJyYW5jaCIKCXRoZW4KCQlnaXQgY29uZmlnIC1mIC5naXRtb2R1bGVzIHN1Ym1vZHVsZS4iJHNtX25hbWUiLmJyYW5jaCAiJGJyYW5jaCIKCWZpICYmCglnaXQgYWRkIC0tZm9yY2UgLmdpdG1vZHVsZXMgfHwKCWRpZSAiJChldmFsX2dldHRleHQgIkZhaWxlZCB0byByZWdpc3RlciBzdWJtb2R1bGUgJ1wkc21fcGF0aCciKSIKfQoKIwojIEV4ZWN1dGUgYW4gYXJiaXRyYXJ5IGNvbW1hbmQgc2VxdWVuY2UgaW4gZWFjaCBjaGVja2VkIG91dAojIHN1Ym1vZHVsZQojCiMgJEAgPSBjb21tYW5kIHRvIGV4ZWN1dGUKIwpjbWRfZm9yZWFjaCgpCnsKCSMgcGFyc2UgJGFyZ3MgYWZ0ZXIgInN1Ym1vZHVsZSAuLi4gZm9yZWFjaCIuCgl3aGlsZSB0ZXN0ICQjIC1uZSAwCglkbwoJCWNhc2UgIiQxIiBpbgoJCS1xfC0tcXVpZXQpCgkJCUdJVF9RVUlFVD0xCgkJCTs7CgkJLS1yZWN1cnNpdmUpCgkJCXJlY3Vyc2l2ZT0xCgkJCTs7CgkJLSopCgkJCXVzYWdlCgkJCTs7CgkJKikKCQkJYnJlYWsKCQkJOzsKCQllc2FjCgkJc2hpZnQKCWRvbmUKCgl0b3BsZXZlbD0kKHB3ZCkKCgkjIGR1cCBzdGRpbiBzbyB0aGF0IGl0IGNhbiBiZSByZXN0b3JlZCB3aGVuIHJ1bm5pbmcgdGhlIGV4dGVybmFsCgkjIGNvbW1hbmQgaW4gdGhlIHN1YnNoZWxsIChhbmQgYSByZWN1cnNpdmUgY2FsbCB0byB0aGlzIGZ1bmN0aW9uKQoJZXhlYyAzPCYwCgoJbW9kdWxlX2xpc3QgfAoJd2hpbGUgcmVhZCBtb2RlIHNoYTEgc3RhZ2Ugc21fcGF0aAoJZG8KCQlkaWVfaWZfdW5tYXRjaGVkICIkbW9kZSIKCQlpZiB0ZXN0IC1lICIkc21fcGF0aCIvLmdpdAoJCXRoZW4KCQkJZGlzcGxheXBhdGg9JChyZWxhdGl2ZV9wYXRoICIkc21fcGF0aCIpCgkJCXNheSAiJChldmFsX2dldHRleHQgIkVudGVyaW5nICdcJHByZWZpeFwkZGlzcGxheXBhdGgnIikiCgkJCW5hbWU9JChtb2R1bGVfbmFtZSAiJHNtX3BhdGgiKQoJCQkoCgkJCQlwcmVmaXg9IiRwcmVmaXgkc21fcGF0aC8iCgkJCQljbGVhcl9sb2NhbF9naXRfZW52CgkJCQljZCAiJHNtX3BhdGgiICYmCgkJCQlzbV9wYXRoPSQocmVsYXRpdmVfcGF0aCAiJHNtX3BhdGgiKSAmJgoJCQkJIyB3ZSBtYWtlICRwYXRoIGF2YWlsYWJsZSB0byBzY3JpcHRzIC4uLgoJCQkJcGF0aD0kc21fcGF0aCAmJgoJCQkJZXZhbCAiJEAiICYmCgkJCQlpZiB0ZXN0IC1uICIkcmVjdXJzaXZlIgoJCQkJdGhlbgoJCQkJCWNtZF9mb3JlYWNoICItLXJlY3Vyc2l2ZSIgIiRAIgoJCQkJZmkKCQkJKSA8JjMgMzwmLSB8fAoJCQlkaWUgIiQoZXZhbF9nZXR0ZXh0ICJTdG9wcGluZyBhdCAnXCRwcmVmaXhcJGRpc3BsYXlwYXRoJzsgc2NyaXB0IHJldHVybmVkIG5vbi16ZXJvIHN0YXR1cy4iKSIKCQlmaQoJZG9uZQp9CgojCiMgUmVnaXN0ZXIgc3VibW9kdWxlcyBpbiAuZ2l0L2NvbmZpZwojCiMgJEAgPSByZXF1ZXN0ZWQgcGF0aHMgKGRlZmF1bHQgdG8gYWxsKQojCmNtZF9pbml0KCkKewoJIyBwYXJzZSAkYXJncyBhZnRlciAic3VibW9kdWxlIC4uLiBpbml0Ii4KCXdoaWxlIHRlc3QgJCMgLW5lIDAKCWRvCgkJY2FzZSAiJDEiIGluCgkJLXF8LS1xdWlldCkKCQkJR0lUX1FVSUVUPTEKCQkJOzsKCQktLSkKCQkJc2hpZnQKCQkJYnJlYWsKCQkJOzsKCQktKikKCQkJdXNhZ2UKCQkJOzsKCQkqKQoJCQlicmVhawoJCQk7OwoJCWVzYWMKCQlzaGlmdAoJZG9uZQoKCW1vZHVsZV9saXN0ICIkQCIgfAoJd2hpbGUgcmVhZCBtb2RlIHNoYTEgc3RhZ2Ugc21fcGF0aAoJZG8KCQlkaWVfaWZfdW5tYXRjaGVkICIkbW9kZSIKCQluYW1lPSQobW9kdWxlX25hbWUgIiRzbV9wYXRoIikgfHwgZXhpdAoKCQlkaXNwbGF5cGF0aD0kKHJlbGF0aXZlX3BhdGggIiRzbV9wYXRoIikKCgkJIyBDb3B5IHVybCBzZXR0aW5nIHdoZW4gaXQgaXMgbm90IHNldCB5ZXQKCQlpZiB0ZXN0IC16ICIkKGdpdCBjb25maWcgInN1Ym1vZHVsZS4kbmFtZS51cmwiKSIKCQl0aGVuCgkJCXVybD0kKGdpdCBjb25maWcgLWYgLmdpdG1vZHVsZXMgc3VibW9kdWxlLiIkbmFtZSIudXJsKQoJCQl0ZXN0IC16ICIkdXJsIiAmJgoJCQlkaWUgIiQoZXZhbF9nZXR0ZXh0ICJObyB1cmwgZm91bmQgZm9yIHN1Ym1vZHVsZSBwYXRoICdcJGRpc3BsYXlwYXRoJyBpbiAuZ2l0bW9kdWxlcyIpIgoKCQkJIyBQb3NzaWJseSBhIHVybCByZWxhdGl2ZSB0byBwYXJlbnQKCQkJY2FzZSAiJHVybCIgaW4KCQkJLi8qfC4uLyopCgkJCQl1cmw9JChyZXNvbHZlX3JlbGF0aXZlX3VybCAiJHVybCIpIHx8IGV4aXQKCQkJCTs7CgkJCWVzYWMKCQkJZ2l0IGNvbmZpZyBzdWJtb2R1bGUuIiRuYW1lIi51cmwgIiR1cmwiIHx8CgkJCWRpZSAiJChldmFsX2dldHRleHQgIkZhaWxlZCB0byByZWdpc3RlciB1cmwgZm9yIHN1Ym1vZHVsZSBwYXRoICdcJGRpc3BsYXlwYXRoJyIpIgoKCQkJc2F5ICIkKGV2YWxfZ2V0dGV4dCAiU3VibW9kdWxlICdcJG5hbWUnIChcJHVybCkgcmVnaXN0ZXJlZCBmb3IgcGF0aCAnXCRkaXNwbGF5cGF0aCciKSIKCQlmaQoKCQkjIENvcHkgInVwZGF0ZSIgc2V0dGluZyB3aGVuIGl0IGlzIG5vdCBzZXQgeWV0CgkJdXBkPSIkKGdpdCBjb25maWcgLWYgLmdpdG1vZHVsZXMgc3VibW9kdWxlLiIkbmFtZSIudXBkYXRlKSIKCQl0ZXN0IC16ICIkdXBkIiB8fAoJCXRlc3QgLW4gIiQoZ2l0IGNvbmZpZyBzdWJtb2R1bGUuIiRuYW1lIi51cGRhdGUpIiB8fAoJCWdpdCBjb25maWcgc3VibW9kdWxlLiIkbmFtZSIudXBkYXRlICIkdXBkIiB8fAoJCWRpZSAiJChldmFsX2dldHRleHQgIkZhaWxlZCB0byByZWdpc3RlciB1cGRhdGUgbW9kZSBmb3Igc3VibW9kdWxlIHBhdGggJ1wkZGlzcGxheXBhdGgnIikiCglkb25lCn0KCiMKIyBVbnJlZ2lzdGVyIHN1Ym1vZHVsZXMgZnJvbSAuZ2l0L2NvbmZpZyBhbmQgcmVtb3ZlIHRoZWlyIHdvcmsgdHJlZQojCiMgJEAgPSByZXF1ZXN0ZWQgcGF0aHMgKHVzZSAnLicgdG8gZGVpbml0IGFsbCBzdWJtb2R1bGVzKQojCmNtZF9kZWluaXQoKQp7CgkjIHBhcnNlICRhcmdzIGFmdGVyICJzdWJtb2R1bGUgLi4uIGRlaW5pdCIuCgl3aGlsZSB0ZXN0ICQjIC1uZSAwCglkbwoJCWNhc2UgIiQxIiBpbgoJCS1mfC0tZm9yY2UpCgkJCWZvcmNlPSQxCgkJCTs7CgkJLXF8LS1xdWlldCkKCQkJR0lUX1FVSUVUPTEKCQkJOzsKCQktLSkKCQkJc2hpZnQKCQkJYnJlYWsKCQkJOzsKCQktKikKCQkJdXNhZ2UKCQkJOzsKCQkqKQoJCQlicmVhawoJCQk7OwoJCWVzYWMKCQlzaGlmdAoJZG9uZQoKCWlmIHRlc3QgJCMgPSAwCgl0aGVuCgkJZGllICIkKGV2YWxfZ2V0dGV4dCAiVXNlICcuJyBpZiB5b3UgcmVhbGx5IHdhbnQgdG8gZGVpbml0aWFsaXplIGFsbCBzdWJtb2R1bGVzIikiCglmaQoKCW1vZHVsZV9saXN0ICIkQCIgfAoJd2hpbGUgcmVhZCBtb2RlIHNoYTEgc3RhZ2Ugc21fcGF0aAoJZG8KCQlkaWVfaWZfdW5tYXRjaGVkICIkbW9kZSIKCQluYW1lPSQobW9kdWxlX25hbWUgIiRzbV9wYXRoIikgfHwgZXhpdAoKCQlkaXNwbGF5cGF0aD0kKHJlbGF0aXZlX3BhdGggIiRzbV9wYXRoIikKCgkJIyBSZW1vdmUgdGhlIHN1Ym1vZHVsZSB3b3JrIHRyZWUgKHVubGVzcyB0aGUgdXNlciBhbHJlYWR5IGRpZCBpdCkKCQlpZiB0ZXN0IC1kICIkc21fcGF0aCIKCQl0aGVuCgkJCSMgUHJvdGVjdCBzdWJtb2R1bGVzIGNvbnRhaW5pbmcgYSAuZ2l0IGRpcmVjdG9yeQoJCQlpZiB0ZXN0IC1kICIkc21fcGF0aC8uZ2l0IgoJCQl0aGVuCgkJCQllY2hvID4mMiAiJChldmFsX2dldHRleHQgIlN1Ym1vZHVsZSB3b3JrIHRyZWUgJ1wkZGlzcGxheXBhdGgnIGNvbnRhaW5zIGEgLmdpdCBkaXJlY3RvcnkiKSIKCQkJCWRpZSAiJChldmFsX2dldHRleHQgIih1c2UgJ3JtIC1yZicgaWYgeW91IHJlYWxseSB3YW50IHRvIHJlbW92ZSBpdCBpbmNsdWRpbmcgYWxsIG9mIGl0cyBoaXN0b3J5KSIpIgoJCQlmaQoKCQkJaWYgdGVzdCAteiAiJGZvcmNlIgoJCQl0aGVuCgkJCQlnaXQgcm0gLXFuICIkc21fcGF0aCIgfHwKCQkJCWRpZSAiJChldmFsX2dldHRleHQgIlN1Ym1vZHVsZSB3b3JrIHRyZWUgJ1wkZGlzcGxheXBhdGgnIGNvbnRhaW5zIGxvY2FsIG1vZGlmaWNhdGlvbnM7IHVzZSAnLWYnIHRvIGRpc2NhcmQgdGhlbSIpIgoJCQlmaQoJCQlybSAtcmYgIiRzbV9wYXRoIiAmJgoJCQlzYXkgIiQoZXZhbF9nZXR0ZXh0ICJDbGVhcmVkIGRpcmVjdG9yeSAnXCRkaXNwbGF5cGF0aCciKSIgfHwKCQkJc2F5ICIkKGV2YWxfZ2V0dGV4dCAiQ291bGQgbm90IHJlbW92ZSBzdWJtb2R1bGUgd29yayB0cmVlICdcJGRpc3BsYXlwYXRoJyIpIgoJCWZpCgoJCW1rZGlyICIkc21fcGF0aCIgfHwgc2F5ICIkKGV2YWxfZ2V0dGV4dCAiQ291bGQgbm90IGNyZWF0ZSBlbXB0eSBzdWJtb2R1bGUgZGlyZWN0b3J5ICdcJGRpc3BsYXlwYXRoJyIpIgoKCQkjIFJlbW92ZSB0aGUgLmdpdC9jb25maWcgZW50cmllcyAodW5sZXNzIHRoZSB1c2VyIGFscmVhZHkgZGlkIGl0KQoJCWlmIHRlc3QgLW4gIiQoZ2l0IGNvbmZpZyAtLWdldC1yZWdleHAgc3VibW9kdWxlLiIkbmFtZVwuIikiCgkJdGhlbgoJCQkjIFJlbW92ZSB0aGUgd2hvbGUgc2VjdGlvbiBzbyB3ZSBoYXZlIGEgY2xlYW4gc3RhdGUgd2hlbgoJCQkjIHRoZSB1c2VyIGxhdGVyIGRlY2lkZXMgdG8gaW5pdCB0aGlzIHN1Ym1vZHVsZSBhZ2FpbgoJCQl1cmw9JChnaXQgY29uZmlnIHN1Ym1vZHVsZS4iJG5hbWUiLnVybCkKCQkJZ2l0IGNvbmZpZyAtLXJlbW92ZS1zZWN0aW9uIHN1Ym1vZHVsZS4iJG5hbWUiIDI+L2Rldi9udWxsICYmCgkJCXNheSAiJChldmFsX2dldHRleHQgIlN1Ym1vZHVsZSAnXCRuYW1lJyAoXCR1cmwpIHVucmVnaXN0ZXJlZCBmb3IgcGF0aCAnXCRkaXNwbGF5cGF0aCciKSIKCQlmaQoJZG9uZQp9CgojCiMgVXBkYXRlIGVhY2ggc3VibW9kdWxlIHBhdGggdG8gY29ycmVjdCByZXZpc2lvbiwgdXNpbmcgY2xvbmUgYW5kIGNoZWNrb3V0IGFzIG5lZWRlZAojCiMgJEAgPSByZXF1ZXN0ZWQgcGF0aHMgKGRlZmF1bHQgdG8gYWxsKQojCmNtZF91cGRhdGUoKQp7CgkjIHBhcnNlICRhcmdzIGFmdGVyICJzdWJtb2R1bGUgLi4uIHVwZGF0ZSIuCglvcmlnX2ZsYWdzPQoJd2hpbGUgdGVzdCAkIyAtbmUgMAoJZG8KCQljYXNlICIkMSIgaW4KCQktcXwtLXF1aWV0KQoJCQlHSVRfUVVJRVQ9MQoJCQk7OwoJCS1pfC0taW5pdCkKCQkJaW5pdD0xCgkJCTs7CgkJLS1yZW1vdGUpCgkJCXJlbW90ZT0xCgkJCTs7CgkJLU58LS1uby1mZXRjaCkKCQkJbm9mZXRjaD0xCgkJCTs7CgkJLWZ8LS1mb3JjZSkKCQkJZm9yY2U9JDEKCQkJOzsKCQktcnwtLXJlYmFzZSkKCQkJdXBkYXRlPSJyZWJhc2UiCgkJCTs7CgkJLS1yZWZlcmVuY2UpCgkJCWNhc2UgIiQyIiBpbiAnJykgdXNhZ2UgOzsgZXNhYwoJCQlyZWZlcmVuY2U9Ii0tcmVmZXJlbmNlPSQyIgoJCQlvcmlnX2ZsYWdzPSIkb3JpZ19mbGFncyAkKGdpdCByZXYtcGFyc2UgLS1zcS1xdW90ZSAiJDEiKSIKCQkJc2hpZnQKCQkJOzsKCQktLXJlZmVyZW5jZT0qKQoJCQlyZWZlcmVuY2U9IiQxIgoJCQk7OwoJCS1tfC0tbWVyZ2UpCgkJCXVwZGF0ZT0ibWVyZ2UiCgkJCTs7CgkJLS1yZWN1cnNpdmUpCgkJCXJlY3Vyc2l2ZT0xCgkJCTs7CgkJLS1jaGVja291dCkKCQkJdXBkYXRlPSJjaGVja291dCIKCQkJOzsKCQktLWRlcHRoKQoJCQljYXNlICIkMiIgaW4gJycpIHVzYWdlIDs7IGVzYWMKCQkJZGVwdGg9Ii0tZGVwdGg9JDIiCgkJCXNoaWZ0CgkJCTs7CgkJLS1kZXB0aD0qKQoJCQlkZXB0aD0kMQoJCQk7OwoJCS0tKQoJCQlzaGlmdAoJCQlicmVhawoJCQk7OwoJCS0qKQoJCQl1c2FnZQoJCQk7OwoJCSopCgkJCWJyZWFrCgkJCTs7CgkJZXNhYwoJCW9yaWdfZmxhZ3M9IiRvcmlnX2ZsYWdzICQoZ2l0IHJldi1wYXJzZSAtLXNxLXF1b3RlICIkMSIpIgoJCXNoaWZ0Cglkb25lCgoJaWYgdGVzdCAtbiAiJGluaXQiCgl0aGVuCgkJY21kX2luaXQgIi0tIiAiJEAiIHx8IHJldHVybgoJZmkKCgljbG9uZWRfbW9kdWxlcz0KCW1vZHVsZV9saXN0ICIkQCIgfCB7CgllcnI9Cgl3aGlsZSByZWFkIG1vZGUgc2hhMSBzdGFnZSBzbV9wYXRoCglkbwoJCWRpZV9pZl91bm1hdGNoZWQgIiRtb2RlIgoJCWlmIHRlc3QgIiRzdGFnZSIgPSBVCgkJdGhlbgoJCQllY2hvID4mMiAiU2tpcHBpbmcgdW5tZXJnZWQgc3VibW9kdWxlICRwcmVmaXgkc21fcGF0aCIKCQkJY29udGludWUKCQlmaQoJCW5hbWU9JChtb2R1bGVfbmFtZSAiJHNtX3BhdGgiKSB8fCBleGl0CgkJdXJsPSQoZ2l0IGNvbmZpZyBzdWJtb2R1bGUuIiRuYW1lIi51cmwpCgkJYnJhbmNoPSQoZ2V0X3N1Ym1vZHVsZV9jb25maWcgIiRuYW1lIiBicmFuY2ggbWFzdGVyKQoJCWlmICEgdGVzdCAteiAiJHVwZGF0ZSIKCQl0aGVuCgkJCXVwZGF0ZV9tb2R1bGU9JHVwZGF0ZQoJCWVsc2UKCQkJdXBkYXRlX21vZHVsZT0kKGdpdCBjb25maWcgc3VibW9kdWxlLiIkbmFtZSIudXBkYXRlKQoJCWZpCgoJCWRpc3BsYXlwYXRoPSQocmVsYXRpdmVfcGF0aCAiJHByZWZpeCRzbV9wYXRoIikKCgkJaWYgdGVzdCAiJHVwZGF0ZV9tb2R1bGUiID0gIm5vbmUiCgkJdGhlbgoJCQllY2hvICJTa2lwcGluZyBzdWJtb2R1bGUgJyRkaXNwbGF5cGF0aCciCgkJCWNvbnRpbnVlCgkJZmkKCgkJaWYgdGVzdCAteiAiJHVybCIKCQl0aGVuCgkJCSMgT25seSBtZW50aW9uIHVuaW5pdGlhbGl6ZWQgc3VibW9kdWxlcyB3aGVuIGl0cwoJCQkjIHBhdGggaGF2ZSBiZWVuIHNwZWNpZmllZAoJCQl0ZXN0ICIkIyIgIT0gIjAiICYmCgkJCXNheSAiJChldmFsX2dldHRleHQgIlN1Ym1vZHVsZSBwYXRoICdcJGRpc3BsYXlwYXRoJyBub3QgaW5pdGlhbGl6ZWQKTWF5YmUgeW91IHdhbnQgdG8gdXNlICd1cGRhdGUgLS1pbml0Jz8iKSIKCQkJY29udGludWUKCQlmaQoKCQlpZiAhIHRlc3QgLWQgIiRzbV9wYXRoIi8uZ2l0IC1vIC1mICIkc21fcGF0aCIvLmdpdAoJCXRoZW4KCQkJbW9kdWxlX2Nsb25lICIkc21fcGF0aCIgIiRuYW1lIiAiJHVybCIgIiRyZWZlcmVuY2UiICIkZGVwdGgiIHx8IGV4aXQKCQkJY2xvbmVkX21vZHVsZXM9IiRjbG9uZWRfbW9kdWxlczskbmFtZSIKCQkJc3Vic2hhMT0KCQllbHNlCgkJCXN1YnNoYTE9JChjbGVhcl9sb2NhbF9naXRfZW52OyBjZCAiJHNtX3BhdGgiICYmCgkJCQlnaXQgcmV2LXBhcnNlIC0tdmVyaWZ5IEhFQUQpIHx8CgkJCWRpZSAiJChldmFsX2dldHRleHQgIlVuYWJsZSB0byBmaW5kIGN1cnJlbnQgcmV2aXNpb24gaW4gc3VibW9kdWxlIHBhdGggJ1wkZGlzcGxheXBhdGgnIikiCgkJZmkKCgkJaWYgdGVzdCAtbiAiJHJlbW90ZSIKCQl0aGVuCgkJCWlmIHRlc3QgLXogIiRub2ZldGNoIgoJCQl0aGVuCgkJCQkjIEZldGNoIHJlbW90ZSBiZWZvcmUgZGV0ZXJtaW5pbmcgdHJhY2tpbmcgJHNoYTEKCQkJCShjbGVhcl9sb2NhbF9naXRfZW52OyBjZCAiJHNtX3BhdGgiICYmIGdpdC1mZXRjaCkgfHwKCQkJCWRpZSAiJChldmFsX2dldHRleHQgIlVuYWJsZSB0byBmZXRjaCBpbiBzdWJtb2R1bGUgcGF0aCAnXCRzbV9wYXRoJyIpIgoJCQlmaQoJCQlyZW1vdGVfbmFtZT0kKGNsZWFyX2xvY2FsX2dpdF9lbnY7IGNkICIkc21fcGF0aCIgJiYgZ2V0X2RlZmF1bHRfcmVtb3RlKQoJCQlzaGExPSQoY2xlYXJfbG9jYWxfZ2l0X2VudjsgY2QgIiRzbV9wYXRoIiAmJgoJCQkJZ2l0IHJldi1wYXJzZSAtLXZlcmlmeSAiJHtyZW1vdGVfbmFtZX0vJHticmFuY2h9IikgfHwKCQkJZGllICIkKGV2YWxfZ2V0dGV4dCAiVW5hYmxlIHRvIGZpbmQgY3VycmVudCAke3JlbW90ZV9uYW1lfS8ke2JyYW5jaH0gcmV2aXNpb24gaW4gc3VibW9kdWxlIHBhdGggJ1wkc21fcGF0aCciKSIKCQlmaQoKCQlpZiB0ZXN0ICIkc3Vic2hhMSIgIT0gIiRzaGExIiAtbyAtbiAiJGZvcmNlIgoJCXRoZW4KCQkJc3ViZm9yY2U9JGZvcmNlCgkJCSMgSWYgd2UgZG9uJ3QgYWxyZWFkeSBoYXZlIGEgLWYgZmxhZyBhbmQgdGhlIHN1Ym1vZHVsZSBoYXMgbmV2ZXIgYmVlbiBjaGVja2VkIG91dAoJCQlpZiB0ZXN0IC16ICIkc3Vic2hhMSIgLWEgLXogIiRmb3JjZSIKCQkJdGhlbgoJCQkJc3ViZm9yY2U9Ii1mIgoJCQlmaQoKCQkJaWYgdGVzdCAteiAiJG5vZmV0Y2giCgkJCXRoZW4KCQkJCSMgUnVuIGZldGNoIG9ubHkgaWYgJHNoYTEgaXNuJ3QgcHJlc2VudCBvciBpdAoJCQkJIyBpcyBub3QgcmVhY2hhYmxlIGZyb20gYSByZWYuCgkJCQkoY2xlYXJfbG9jYWxfZ2l0X2VudjsgY2QgIiRzbV9wYXRoIiAmJgoJCQkJCSggKHJldj0kKGdpdCByZXYtbGlzdCAtbiAxICRzaGExIC0tbm90IC0tYWxsIDI+L2Rldi9udWxsKSAmJgoJCQkJCSB0ZXN0IC16ICIkcmV2IikgfHwgZ2l0LWZldGNoKSkgfHwKCQkJCWRpZSAiJChldmFsX2dldHRleHQgIlVuYWJsZSB0byBmZXRjaCBpbiBzdWJtb2R1bGUgcGF0aCAnXCRkaXNwbGF5cGF0aCciKSIKCQkJZmkKCgkJCSMgSXMgdGhpcyBzb21ldGhpbmcgd2UganVzdCBjbG9uZWQ/CgkJCWNhc2UgIjskY2xvbmVkX21vZHVsZXM7IiBpbgoJCQkqIjskbmFtZTsiKikKCQkJCSMgdGhlbiB0aGVyZSBpcyBubyBsb2NhbCBjaGFuZ2UgdG8gaW50ZWdyYXRlCgkJCQl1cGRhdGVfbW9kdWxlPSA7OwoJCQllc2FjCgoJCQltdXN0X2RpZV9vbl9mYWlsdXJlPQoJCQljYXNlICIkdXBkYXRlX21vZHVsZSIgaW4KCQkJcmViYXNlKQoJCQkJY29tbWFuZD0iZ2l0IHJlYmFzZSIKCQkJCWRpZV9tc2c9IiQoZXZhbF9nZXR0ZXh0ICJVbmFibGUgdG8gcmViYXNlICdcJHNoYTEnIGluIHN1Ym1vZHVsZSBwYXRoICdcJGRpc3BsYXlwYXRoJyIpIgoJCQkJc2F5X21zZz0iJChldmFsX2dldHRleHQgIlN1Ym1vZHVsZSBwYXRoICdcJGRpc3BsYXlwYXRoJzogcmViYXNlZCBpbnRvICdcJHNoYTEnIikiCgkJCQltdXN0X2RpZV9vbl9mYWlsdXJlPXllcwoJCQkJOzsKCQkJbWVyZ2UpCgkJCQljb21tYW5kPSJnaXQgbWVyZ2UiCgkJCQlkaWVfbXNnPSIkKGV2YWxfZ2V0dGV4dCAiVW5hYmxlIHRvIG1lcmdlICdcJHNoYTEnIGluIHN1Ym1vZHVsZSBwYXRoICdcJGRpc3BsYXlwYXRoJyIpIgoJCQkJc2F5X21zZz0iJChldmFsX2dldHRleHQgIlN1Ym1vZHVsZSBwYXRoICdcJGRpc3BsYXlwYXRoJzogbWVyZ2VkIGluICdcJHNoYTEnIikiCgkJCQltdXN0X2RpZV9vbl9mYWlsdXJlPXllcwoJCQkJOzsKCQkJISopCgkJCQljb21tYW5kPSIke3VwZGF0ZV9tb2R1bGUjIX0iCgkJCQlkaWVfbXNnPSIkKGV2YWxfZ2V0dGV4dCAiRXhlY3V0aW9uIG9mICdcJGNvbW1hbmQgXCRzaGExJyBmYWlsZWQgaW4gc3VibW9kdWxlICBwYXRoICdcJHByZWZpeFwkc21fcGF0aCciKSIKCQkJCXNheV9tc2c9IiQoZXZhbF9nZXR0ZXh0ICJTdWJtb2R1bGUgcGF0aCAnXCRwcmVmaXhcJHNtX3BhdGgnOiAnXCRjb21tYW5kIFwkc2hhMSciKSIKCQkJCW11c3RfZGllX29uX2ZhaWx1cmU9eWVzCgkJCQk7OwoJCQkqKQoJCQkJY29tbWFuZD0iZ2l0IGNoZWNrb3V0ICRzdWJmb3JjZSAtcSIKCQkJCWRpZV9tc2c9IiQoZXZhbF9nZXR0ZXh0ICJVbmFibGUgdG8gY2hlY2tvdXQgJ1wkc2hhMScgaW4gc3VibW9kdWxlIHBhdGggJ1wkZGlzcGxheXBhdGgnIikiCgkJCQlzYXlfbXNnPSIkKGV2YWxfZ2V0dGV4dCAiU3VibW9kdWxlIHBhdGggJ1wkZGlzcGxheXBhdGgnOiBjaGVja2VkIG91dCAnXCRzaGExJyIpIgoJCQkJOzsKCQkJZXNhYwoKCQkJaWYgKGNsZWFyX2xvY2FsX2dpdF9lbnY7IGNkICIkc21fcGF0aCIgJiYgJGNvbW1hbmQgIiRzaGExIikKCQkJdGhlbgoJCQkJc2F5ICIkc2F5X21zZyIKCQkJZWxpZiB0ZXN0IC1uICIkbXVzdF9kaWVfb25fZmFpbHVyZSIKCQkJdGhlbgoJCQkJZGllX3dpdGhfc3RhdHVzIDIgIiRkaWVfbXNnIgoJCQllbHNlCgkJCQllcnI9IiR7ZXJyfTskZGllX21zZyIKCQkJCWNvbnRpbnVlCgkJCWZpCgkJZmkKCgkJaWYgdGVzdCAtbiAiJHJlY3Vyc2l2ZSIKCQl0aGVuCgkJCSgKCQkJCXByZWZpeD0iJHByZWZpeCRzbV9wYXRoLyIKCQkJCWNsZWFyX2xvY2FsX2dpdF9lbnYKCQkJCWNkICIkc21fcGF0aCIgJiYKCQkJCWV2YWwgY21kX3VwZGF0ZSAiJG9yaWdfZmxhZ3MiCgkJCSkKCQkJcmVzPSQ/CgkJCWlmIHRlc3QgJHJlcyAtZ3QgMAoJCQl0aGVuCgkJCQlkaWVfbXNnPSIkKGV2YWxfZ2V0dGV4dCAiRmFpbGVkIHRvIHJlY3Vyc2UgaW50byBzdWJtb2R1bGUgcGF0aCAnXCRkaXNwbGF5cGF0aCciKSIKCQkJCWlmIHRlc3QgJHJlcyAtZXEgMQoJCQkJdGhlbgoJCQkJCWVycj0iJHtlcnJ9OyRkaWVfbXNnIgoJCQkJCWNvbnRpbnVlCgkJCQllbHNlCgkJCQkJZGllX3dpdGhfc3RhdHVzICRyZXMgIiRkaWVfbXNnIgoJCQkJZmkKCQkJZmkKCQlmaQoJZG9uZQoKCWlmIHRlc3QgLW4gIiRlcnIiCgl0aGVuCgkJT0lGUz0kSUZTCgkJSUZTPSc7JwoJCWZvciBlIGluICRlcnIKCQlkbwoJCQlpZiB0ZXN0IC1uICIkZSIKCQkJdGhlbgoJCQkJZWNobyA+JjIgIiRlIgoJCQlmaQoJCWRvbmUKCQlJRlM9JE9JRlMKCQlleGl0IDEKCWZpCgl9Cn0KCnNldF9uYW1lX3JldiAoKSB7CglyZXZuYW1lPSQoICgKCQljbGVhcl9sb2NhbF9naXRfZW52CgkJY2QgIiQxIiAmJiB7CgkJCWdpdCBkZXNjcmliZSAiJDIiIDI+L2Rldi9udWxsIHx8CgkJCWdpdCBkZXNjcmliZSAtLXRhZ3MgIiQyIiAyPi9kZXYvbnVsbCB8fAoJCQlnaXQgZGVzY3JpYmUgLS1jb250YWlucyAiJDIiIDI+L2Rldi9udWxsIHx8CgkJCWdpdCBkZXNjcmliZSAtLWFsbCAtLWFsd2F5cyAiJDIiCgkJfQoJKSApCgl0ZXN0IC16ICIkcmV2bmFtZSIgfHwgcmV2bmFtZT0iICgkcmV2bmFtZSkiCn0KIwojIFNob3cgY29tbWl0IHN1bW1hcnkgZm9yIHN1Ym1vZHVsZXMgaW4gaW5kZXggb3Igd29ya2luZyB0cmVlCiMKIyBJZiAnLS1jYWNoZWQnIGlzIGdpdmVuLCBzaG93IHN1bW1hcnkgYmV0d2VlbiBpbmRleCBhbmQgZ2l2ZW4gY29tbWl0LAojIG9yIGJldHdlZW4gd29ya2luZyB0cmVlIGFuZCBnaXZlbiBjb21taXQKIwojICRAID0gW2NvbW1pdCAoZGVmYXVsdCAnSEVBRCcpLF0gcmVxdWVzdGVkIHBhdGhzIChkZWZhdWx0IGFsbCkKIwpjbWRfc3VtbWFyeSgpIHsKCXN1bW1hcnlfbGltaXQ9LTEKCWZvcl9zdGF0dXM9CglkaWZmX2NtZD1kaWZmLWluZGV4CgoJIyBwYXJzZSAkYXJncyBhZnRlciAic3VibW9kdWxlIC4uLiBzdW1tYXJ5Ii4KCXdoaWxlIHRlc3QgJCMgLW5lIDAKCWRvCgkJY2FzZSAiJDEiIGluCgkJLS1jYWNoZWQpCgkJCWNhY2hlZD0iJDEiCgkJCTs7CgkJLS1maWxlcykKCQkJZmlsZXM9IiQxIgoJCQk7OwoJCS0tZm9yLXN0YXR1cykKCQkJZm9yX3N0YXR1cz0iJDEiCgkJCTs7CgkJLW58LS1zdW1tYXJ5LWxpbWl0KQoJCQlzdW1tYXJ5X2xpbWl0PSIkMiIKCQkJaXNudW1iZXIgIiRzdW1tYXJ5X2xpbWl0IiB8fCB1c2FnZQoJCQlzaGlmdAoJCQk7OwoJCS0tc3VtbWFyeS1saW1pdD0qKQoJCQlzdW1tYXJ5X2xpbWl0PSIkezEjLS1zdW1tYXJ5LWxpbWl0PX0iCgkJCWlzbnVtYmVyICIkc3VtbWFyeV9saW1pdCIgfHwgdXNhZ2UKCQkJOzsKCQktLSkKCQkJc2hpZnQKCQkJYnJlYWsKCQkJOzsKCQktKikKCQkJdXNhZ2UKCQkJOzsKCQkqKQoJCQlicmVhawoJCQk7OwoJCWVzYWMKCQlzaGlmdAoJZG9uZQoKCXRlc3QgJHN1bW1hcnlfbGltaXQgPSAwICYmIHJldHVybgoKCWlmIHJldj0kKGdpdCByZXYtcGFyc2UgLXEgLS12ZXJpZnkgLS1kZWZhdWx0IEhFQUQgJHsxKyIkMSJ9KQoJdGhlbgoJCWhlYWQ9JHJldgoJCXRlc3QgJCMgPSAwIHx8IHNoaWZ0CgllbGlmIHRlc3QgLXogIiQxIiAtbyAiJDEiID0gIkhFQUQiCgl0aGVuCgkJIyBiZWZvcmUgdGhlIGZpcnN0IGNvbW1pdDogY29tcGFyZSB3aXRoIGFuIGVtcHR5IHRyZWUKCQloZWFkPSQoZ2l0IGhhc2gtb2JqZWN0IC13IC10IHRyZWUgLS1zdGRpbiA8L2Rldi9udWxsKQoJCXRlc3QgLXogIiQxIiB8fCBzaGlmdAoJZWxzZQoJCWhlYWQ9IkhFQUQiCglmaQoKCWlmIFsgLW4gIiRmaWxlcyIgXQoJdGhlbgoJCXRlc3QgLW4gIiRjYWNoZWQiICYmCgkJZGllICIkKGdldHRleHQgIlRoZSAtLWNhY2hlZCBvcHRpb24gY2Fubm90IGJlIHVzZWQgd2l0aCB0aGUgLS1maWxlcyBvcHRpb24iKSIKCQlkaWZmX2NtZD1kaWZmLWZpbGVzCgkJaGVhZD0KCWZpCgoJY2RfdG9fdG9wbGV2ZWwKCWV2YWwgInNldCAkKGdpdCByZXYtcGFyc2UgLS1zcSAtLXByZWZpeCAiJHd0X3ByZWZpeCIgLS0gIiRAIikiCgkjIEdldCBtb2RpZmllZCBtb2R1bGVzIGNhcmVkIGJ5IHVzZXIKCW1vZHVsZXM9JChnaXQgJGRpZmZfY21kICRjYWNoZWQgLS1pZ25vcmUtc3VibW9kdWxlcz1kaXJ0eSAtLXJhdyAkaGVhZCAtLSAiJEAiIHwKCQlzYW5lX2VncmVwICdeOihbMC03XSogKT8xNjAwMDAnIHwKCQl3aGlsZSByZWFkIG1vZF9zcmMgbW9kX2RzdCBzaGExX3NyYyBzaGExX2RzdCBzdGF0dXMgc21fcGF0aAoJCWRvCgkJCSMgQWx3YXlzIHNob3cgbW9kdWxlcyBkZWxldGVkIG9yIHR5cGUtY2hhbmdlZCAoYmxvYjwtPm1vZHVsZSkKCQkJdGVzdCAkc3RhdHVzID0gRCAtbyAkc3RhdHVzID0gVCAmJiBlY2hvICIkc21fcGF0aCIgJiYgY29udGludWUKCQkJIyBSZXNwZWN0IHRoZSBpZ25vcmUgc2V0dGluZyBmb3IgLS1mb3Itc3RhdHVzLgoJCQlpZiB0ZXN0IC1uICIkZm9yX3N0YXR1cyIKCQkJdGhlbgoJCQkJbmFtZT0kKG1vZHVsZV9uYW1lICIkc21fcGF0aCIpCgkJCQlpZ25vcmVfY29uZmlnPSQoZ2V0X3N1Ym1vZHVsZV9jb25maWcgIiRuYW1lIiBpZ25vcmUgbm9uZSkKCQkJCXRlc3QgJHN0YXR1cyAhPSBBIC1hICRpZ25vcmVfY29uZmlnID0gYWxsICYmIGNvbnRpbnVlCgkJCWZpCgkJCSMgQWxzbyBzaG93IGFkZGVkIG9yIG1vZGlmaWVkIG1vZHVsZXMgd2hpY2ggYXJlIGNoZWNrZWQgb3V0CgkJCUdJVF9ESVI9IiRzbV9wYXRoLy5naXQiIGdpdC1yZXYtcGFyc2UgLS1naXQtZGlyID4vZGV2L251bGwgMj4mMSAmJgoJCQllY2hvICIkc21fcGF0aCIKCQlkb25lCgkpCgoJdGVzdCAteiAiJG1vZHVsZXMiICYmIHJldHVybgoKCWdpdCAkZGlmZl9jbWQgJGNhY2hlZCAtLWlnbm9yZS1zdWJtb2R1bGVzPWRpcnR5IC0tcmF3ICRoZWFkIC0tICRtb2R1bGVzIHwKCXNhbmVfZWdyZXAgJ146KFswLTddKiApPzE2MDAwMCcgfAoJY3V0IC1jMi0gfAoJd2hpbGUgcmVhZCBtb2Rfc3JjIG1vZF9kc3Qgc2hhMV9zcmMgc2hhMV9kc3Qgc3RhdHVzIG5hbWUKCWRvCgkJaWYgdGVzdCAteiAiJGNhY2hlZCIgJiYKCQkJdGVzdCAkc2hhMV9kc3QgPSAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwCgkJdGhlbgoJCQljYXNlICIkbW9kX2RzdCIgaW4KCQkJMTYwMDAwKQoJCQkJc2hhMV9kc3Q9JChHSVRfRElSPSIkbmFtZS8uZ2l0IiBnaXQgcmV2LXBhcnNlIEhFQUQpCgkJCQk7OwoJCQkxMDA2NDQgfCAxMDA3NTUgfCAxMjAwMDApCgkJCQlzaGExX2RzdD0kKGdpdCBoYXNoLW9iamVjdCAkbmFtZSkKCQkJCTs7CgkJCTAwMDAwMCkKCQkJCTs7ICMgcmVtb3ZlZAoJCQkqKQoJCQkJIyB1bmV4cGVjdGVkIHR5cGUKCQkJCWV2YWxfZ2V0dGV4dGxuICJ1bmV4cGVjdGVkIG1vZGUgXCRtb2RfZHN0IiA+JjIKCQkJCWNvbnRpbnVlIDs7CgkJCWVzYWMKCQlmaQoJCW1pc3Npbmdfc3JjPQoJCW1pc3NpbmdfZHN0PQoKCQl0ZXN0ICRtb2Rfc3JjID0gMTYwMDAwICYmCgkJISBHSVRfRElSPSIkbmFtZS8uZ2l0IiBnaXQtcmV2LXBhcnNlIC1xIC0tdmVyaWZ5ICRzaGExX3NyY14wID4vZGV2L251bGwgJiYKCQltaXNzaW5nX3NyYz10CgoJCXRlc3QgJG1vZF9kc3QgPSAxNjAwMDAgJiYKCQkhIEdJVF9ESVI9IiRuYW1lLy5naXQiIGdpdC1yZXYtcGFyc2UgLXEgLS12ZXJpZnkgJHNoYTFfZHN0XjAgPi9kZXYvbnVsbCAmJgoJCW1pc3NpbmdfZHN0PXQKCgkJZGlzcGxheV9uYW1lPSQocmVsYXRpdmVfcGF0aCAiJG5hbWUiKQoKCQl0b3RhbF9jb21taXRzPQoJCWNhc2UgIiRtaXNzaW5nX3NyYywkbWlzc2luZ19kc3QiIGluCgkJdCwpCgkJCWVycm1zZz0iJChldmFsX2dldHRleHQgIiAgV2FybjogXCRkaXNwbGF5X25hbWUgZG9lc24ndCBjb250YWluIGNvbW1pdCBcJHNoYTFfc3JjIikiCgkJCTs7CgkJLHQpCgkJCWVycm1zZz0iJChldmFsX2dldHRleHQgIiAgV2FybjogXCRkaXNwbGF5X25hbWUgZG9lc24ndCBjb250YWluIGNvbW1pdCBcJHNoYTFfZHN0IikiCgkJCTs7CgkJdCx0KQoJCQllcnJtc2c9IiQoZXZhbF9nZXR0ZXh0ICIgIFdhcm46IFwkZGlzcGxheV9uYW1lIGRvZXNuJ3QgY29udGFpbiBjb21taXRzIFwkc2hhMV9zcmMgYW5kIFwkc2hhMV9kc3QiKSIKCQkJOzsKCQkqKQoJCQllcnJtc2c9CgkJCXRvdGFsX2NvbW1pdHM9JCgKCQkJaWYgdGVzdCAkbW9kX3NyYyA9IDE2MDAwMCAtYSAkbW9kX2RzdCA9IDE2MDAwMAoJCQl0aGVuCgkJCQlyYW5nZT0iJHNoYTFfc3JjLi4uJHNoYTFfZHN0IgoJCQllbGlmIHRlc3QgJG1vZF9zcmMgPSAxNjAwMDAKCQkJdGhlbgoJCQkJcmFuZ2U9JHNoYTFfc3JjCgkJCWVsc2UKCQkJCXJhbmdlPSRzaGExX2RzdAoJCQlmaQoJCQlHSVRfRElSPSIkbmFtZS8uZ2l0IiBcCgkJCWdpdCByZXYtbGlzdCAtLWZpcnN0LXBhcmVudCAkcmFuZ2UgLS0gfCB3YyAtbAoJCQkpCgkJCXRvdGFsX2NvbW1pdHM9IiAoJCgoJHRvdGFsX2NvbW1pdHMgKyAwKSkpIgoJCQk7OwoJCWVzYWMKCgkJc2hhMV9hYmJyX3NyYz0kKGVjaG8gJHNoYTFfc3JjIHwgY3V0IC1jMS03KQoJCXNoYTFfYWJicl9kc3Q9JChlY2hvICRzaGExX2RzdCB8IGN1dCAtYzEtNykKCQlpZiB0ZXN0ICRzdGF0dXMgPSBUCgkJdGhlbgoJCQlibG9iPSIkKGdldHRleHQgImJsb2IiKSIKCQkJc3VibW9kdWxlPSIkKGdldHRleHQgInN1Ym1vZHVsZSIpIgoJCQlpZiB0ZXN0ICRtb2RfZHN0ID0gMTYwMDAwCgkJCXRoZW4KCQkJCWVjaG8gIiogJGRpc3BsYXlfbmFtZSAkc2hhMV9hYmJyX3NyYygkYmxvYiktPiRzaGExX2FiYnJfZHN0KCRzdWJtb2R1bGUpJHRvdGFsX2NvbW1pdHM6IgoJCQllbHNlCgkJCQllY2hvICIqICRkaXNwbGF5X25hbWUgJHNoYTFfYWJicl9zcmMoJHN1Ym1vZHVsZSktPiRzaGExX2FiYnJfZHN0KCRibG9iKSR0b3RhbF9jb21taXRzOiIKCQkJZmkKCQllbHNlCgkJCWVjaG8gIiogJGRpc3BsYXlfbmFtZSAkc2hhMV9hYmJyX3NyYy4uLiRzaGExX2FiYnJfZHN0JHRvdGFsX2NvbW1pdHM6IgoJCWZpCgkJaWYgdGVzdCAtbiAiJGVycm1zZyIKCQl0aGVuCgkJCSMgRG9uJ3QgZ2l2ZSBlcnJvciBtc2cgZm9yIG1vZGlmaWNhdGlvbiB3aG9zZSBkc3QgaXMgbm90IHN1Ym1vZHVsZQoJCQkjIGkuZS4gZGVsZXRlZCBvciBjaGFuZ2VkIHRvIGJsb2IKCQkJdGVzdCAkbW9kX2RzdCA9IDE2MDAwMCAmJiBlY2hvICIkZXJybXNnIgoJCWVsc2UKCQkJaWYgdGVzdCAkbW9kX3NyYyA9IDE2MDAwMCAtYSAkbW9kX2RzdCA9IDE2MDAwMAoJCQl0aGVuCgkJCQlsaW1pdD0KCQkJCXRlc3QgJHN1bW1hcnlfbGltaXQgLWd0IDAgJiYgbGltaXQ9Ii0kc3VtbWFyeV9saW1pdCIKCQkJCUdJVF9ESVI9IiRuYW1lLy5naXQiIFwKCQkJCWdpdCBsb2cgJGxpbWl0IC0tcHJldHR5PSdmb3JtYXQ6ICAlbSAlcycgXAoJCQkJLS1maXJzdC1wYXJlbnQgJHNoYTFfc3JjLi4uJHNoYTFfZHN0CgkJCWVsaWYgdGVzdCAkbW9kX2RzdCA9IDE2MDAwMAoJCQl0aGVuCgkJCQlHSVRfRElSPSIkbmFtZS8uZ2l0IiBcCgkJCQlnaXQgbG9nIC0tcHJldHR5PSdmb3JtYXQ6ICA+ICVzJyAtMSAkc2hhMV9kc3QKCQkJZWxzZQoJCQkJR0lUX0RJUj0iJG5hbWUvLmdpdCIgXAoJCQkJZ2l0IGxvZyAtLXByZXR0eT0nZm9ybWF0OiAgPCAlcycgLTEgJHNoYTFfc3JjCgkJCWZpCgkJCWVjaG8KCQlmaQoJCWVjaG8KCWRvbmUgfAoJaWYgdGVzdCAtbiAiJGZvcl9zdGF0dXMiOyB0aGVuCgkJaWYgWyAtbiAiJGZpbGVzIiBdOyB0aGVuCgkJCWdldHRleHRsbiAiU3VibW9kdWxlcyBjaGFuZ2VkIGJ1dCBub3QgdXBkYXRlZDoiIHwgZ2l0IHN0cmlwc3BhY2UgLWMKCQllbHNlCgkJCWdldHRleHRsbiAiU3VibW9kdWxlIGNoYW5nZXMgdG8gYmUgY29tbWl0dGVkOiIgfCBnaXQgc3RyaXBzcGFjZSAtYwoJCWZpCgkJcHJpbnRmICJcbiIgfCBnaXQgc3RyaXBzcGFjZSAtYwoJCWdpdCBzdHJpcHNwYWNlIC1jCgllbHNlCgkJY2F0CglmaQp9CiMKIyBMaXN0IGFsbCBzdWJtb2R1bGVzLCBwcmVmaXhlZCB3aXRoOgojICAtIHN1Ym1vZHVsZSBub3QgaW5pdGlhbGl6ZWQKIyAgKyBkaWZmZXJlbnQgcmV2aXNpb24gY2hlY2tlZCBvdXQKIwojIElmIC0tY2FjaGVkIHdhcyBzcGVjaWZpZWQgdGhlIHJldmlzaW9uIGluIHRoZSBpbmRleCB3aWxsIGJlIHByaW50ZWQKIyBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50bHkgY2hlY2tlZCBvdXQgcmV2aXNpb24uCiMKIyAkQCA9IHJlcXVlc3RlZCBwYXRocyAoZGVmYXVsdCB0byBhbGwpCiMKY21kX3N0YXR1cygpCnsKCSMgcGFyc2UgJGFyZ3MgYWZ0ZXIgInN1Ym1vZHVsZSAuLi4gc3RhdHVzIi4KCXdoaWxlIHRlc3QgJCMgLW5lIDAKCWRvCgkJY2FzZSAiJDEiIGluCgkJLXF8LS1xdWlldCkKCQkJR0lUX1FVSUVUPTEKCQkJOzsKCQktLWNhY2hlZCkKCQkJY2FjaGVkPTEKCQkJOzsKCQktLXJlY3Vyc2l2ZSkKCQkJcmVjdXJzaXZlPTEKCQkJOzsKCQktLSkKCQkJc2hpZnQKCQkJYnJlYWsKCQkJOzsKCQktKikKCQkJdXNhZ2UKCQkJOzsKCQkqKQoJCQlicmVhawoJCQk7OwoJCWVzYWMKCQlzaGlmdAoJZG9uZQoKCW1vZHVsZV9saXN0ICIkQCIgfAoJd2hpbGUgcmVhZCBtb2RlIHNoYTEgc3RhZ2Ugc21fcGF0aAoJZG8KCQlkaWVfaWZfdW5tYXRjaGVkICIkbW9kZSIKCQluYW1lPSQobW9kdWxlX25hbWUgIiRzbV9wYXRoIikgfHwgZXhpdAoJCXVybD0kKGdpdCBjb25maWcgc3VibW9kdWxlLiIkbmFtZSIudXJsKQoJCWRpc3BsYXlwYXRoPSQocmVsYXRpdmVfcGF0aCAiJHByZWZpeCRzbV9wYXRoIikKCQlpZiB0ZXN0ICIkc3RhZ2UiID0gVQoJCXRoZW4KCQkJc2F5ICJVJHNoYTEgJGRpc3BsYXlwYXRoIgoJCQljb250aW51ZQoJCWZpCgkJaWYgdGVzdCAteiAiJHVybCIgfHwgISB0ZXN0IC1kICIkc21fcGF0aCIvLmdpdCAtbyAtZiAiJHNtX3BhdGgiLy5naXQKCQl0aGVuCgkJCXNheSAiLSRzaGExICRkaXNwbGF5cGF0aCIKCQkJY29udGludWU7CgkJZmkKCQlpZiBnaXQgZGlmZi1maWxlcyAtLWlnbm9yZS1zdWJtb2R1bGVzPWRpcnR5IC0tcXVpZXQgLS0gIiRzbV9wYXRoIgoJCXRoZW4KCQkJc2V0X25hbWVfcmV2ICIkc21fcGF0aCIgIiRzaGExIgoJCQlzYXkgIiAkc2hhMSAkZGlzcGxheXBhdGgkcmV2bmFtZSIKCQllbHNlCgkJCWlmIHRlc3QgLXogIiRjYWNoZWQiCgkJCXRoZW4KCQkJCXNoYTE9JChjbGVhcl9sb2NhbF9naXRfZW52OyBjZCAiJHNtX3BhdGgiICYmIGdpdCByZXYtcGFyc2UgLS12ZXJpZnkgSEVBRCkKCQkJZmkKCQkJc2V0X25hbWVfcmV2ICIkc21fcGF0aCIgIiRzaGExIgoJCQlzYXkgIiskc2hhMSAkZGlzcGxheXBhdGgkcmV2bmFtZSIKCQlmaQoKCQlpZiB0ZXN0IC1uICIkcmVjdXJzaXZlIgoJCXRoZW4KCQkJKAoJCQkJcHJlZml4PSIkZGlzcGxheXBhdGgvIgoJCQkJY2xlYXJfbG9jYWxfZ2l0X2VudgoJCQkJY2QgIiRzbV9wYXRoIiAmJgoJCQkJZXZhbCBjbWRfc3RhdHVzCgkJCSkgfHwKCQkJZGllICIkKGV2YWxfZ2V0dGV4dCAiRmFpbGVkIHRvIHJlY3Vyc2UgaW50byBzdWJtb2R1bGUgcGF0aCAnXCRzbV9wYXRoJyIpIgoJCWZpCglkb25lCn0KIwojIFN5bmMgcmVtb3RlIHVybHMgZm9yIHN1Ym1vZHVsZXMKIyBUaGlzIG1ha2VzIHRoZSB2YWx1ZSBmb3IgcmVtb3RlLiRyZW1vdGUudXJsIG1hdGNoIHRoZSB2YWx1ZQojIHNwZWNpZmllZCBpbiAuZ2l0bW9kdWxlcy4KIwpjbWRfc3luYygpCnsKCXdoaWxlIHRlc3QgJCMgLW5lIDAKCWRvCgkJY2FzZSAiJDEiIGluCgkJLXF8LS1xdWlldCkKCQkJR0lUX1FVSUVUPTEKCQkJc2hpZnQKCQkJOzsKCQktLXJlY3Vyc2l2ZSkKCQkJcmVjdXJzaXZlPTEKCQkJc2hpZnQKCQkJOzsKCQktLSkKCQkJc2hpZnQKCQkJYnJlYWsKCQkJOzsKCQktKikKCQkJdXNhZ2UKCQkJOzsKCQkqKQoJCQlicmVhawoJCQk7OwoJCWVzYWMKCWRvbmUKCWNkX3RvX3RvcGxldmVsCgltb2R1bGVfbGlzdCAiJEAiIHwKCXdoaWxlIHJlYWQgbW9kZSBzaGExIHN0YWdlIHNtX3BhdGgKCWRvCgkJZGllX2lmX3VubWF0Y2hlZCAiJG1vZGUiCgkJbmFtZT0kKG1vZHVsZV9uYW1lICIkc21fcGF0aCIpCgkJdXJsPSQoZ2l0IGNvbmZpZyAtZiAuZ2l0bW9kdWxlcyAtLWdldCBzdWJtb2R1bGUuIiRuYW1lIi51cmwpCgoJCSMgUG9zc2libHkgYSB1cmwgcmVsYXRpdmUgdG8gcGFyZW50CgkJY2FzZSAiJHVybCIgaW4KCQkuLyp8Li4vKikKCQkJIyByZXdyaXRlIGZvby9iYXIgYXMgLi4vLi4gdG8gZmluZCBwYXRoIGZyb20KCQkJIyBzdWJtb2R1bGUgd29yayB0cmVlIHRvIHN1cGVycHJvamVjdCB3b3JrIHRyZWUKCQkJdXBfcGF0aD0iJChlY2hvICIkc21fcGF0aCIgfCBzZWQgInMvW14vXVteL10qLy4uL2ciKSIgJiYKCQkJIyBndWFyYW50ZWUgYSB0cmFpbGluZyAvCgkJCXVwX3BhdGg9JHt1cF9wYXRoJS99LyAmJgoJCQkjIHBhdGggZnJvbSBzdWJtb2R1bGUgd29yayB0cmVlIHRvIHN1Ym1vZHVsZSBvcmlnaW4gcmVwbwoJCQlzdWJfb3JpZ2luX3VybD0kKHJlc29sdmVfcmVsYXRpdmVfdXJsICIkdXJsIiAiJHVwX3BhdGgiKSAmJgoJCQkjIHBhdGggZnJvbSBzdXBlcnByb2plY3Qgd29yayB0cmVlIHRvIHN1Ym1vZHVsZSBvcmlnaW4gcmVwbwoJCQlzdXBlcl9jb25maWdfdXJsPSQocmVzb2x2ZV9yZWxhdGl2ZV91cmwgIiR1cmwiKSB8fCBleGl0CgkJCTs7CgkJKikKCQkJc3ViX29yaWdpbl91cmw9IiR1cmwiCgkJCXN1cGVyX2NvbmZpZ191cmw9IiR1cmwiCgkJCTs7CgkJZXNhYwoKCQlpZiBnaXQgY29uZmlnICJzdWJtb2R1bGUuJG5hbWUudXJsIiA+L2Rldi9udWxsIDI+L2Rldi9udWxsCgkJdGhlbgoJCQlkaXNwbGF5cGF0aD0kKHJlbGF0aXZlX3BhdGggIiRwcmVmaXgkc21fcGF0aCIpCgkJCXNheSAiJChldmFsX2dldHRleHQgIlN5bmNocm9uaXppbmcgc3VibW9kdWxlIHVybCBmb3IgJ1wkZGlzcGxheXBhdGgnIikiCgkJCWdpdCBjb25maWcgc3VibW9kdWxlLiIkbmFtZSIudXJsICIkc3VwZXJfY29uZmlnX3VybCIKCgkJCWlmIHRlc3QgLWUgIiRzbV9wYXRoIi8uZ2l0CgkJCXRoZW4KCQkJKAoJCQkJY2xlYXJfbG9jYWxfZ2l0X2VudgoJCQkJY2QgIiRzbV9wYXRoIgoJCQkJcmVtb3RlPSQoZ2V0X2RlZmF1bHRfcmVtb3RlKQoJCQkJZ2l0IGNvbmZpZyByZW1vdGUuIiRyZW1vdGUiLnVybCAiJHN1Yl9vcmlnaW5fdXJsIgoKCQkJCWlmIHRlc3QgLW4gIiRyZWN1cnNpdmUiCgkJCQl0aGVuCgkJCQkJcHJlZml4PSIkcHJlZml4JHNtX3BhdGgvIgoJCQkJCWV2YWwgY21kX3N5bmMKCQkJCWZpCgkJCSkKCQkJZmkKCQlmaQoJZG9uZQp9CgojIFRoaXMgbG9vcCBwYXJzZXMgdGhlIGNvbW1hbmQgbGluZSBhcmd1bWVudHMgdG8gZmluZCB0aGUKIyBzdWJjb21tYW5kIG5hbWUgdG8gZGlzcGF0Y2guICBQYXJzaW5nIG9mIHRoZSBzdWJjb21tYW5kIHNwZWNpZmljCiMgb3B0aW9ucyBhcmUgcHJpbWFyaWx5IGRvbmUgYnkgdGhlIHN1YmNvbW1hbmQgaW1wbGVtZW50YXRpb25zLgojIFN1YmNvbW1hbmQgc3BlY2lmaWMgb3B0aW9ucyBzdWNoIGFzIC0tYnJhbmNoIGFuZCAtLWNhY2hlZCBhcmUKIyBwYXJzZWQgaGVyZSBhcyB3ZWxsLCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS4KCndoaWxlIHRlc3QgJCMgIT0gMCAmJiB0ZXN0IC16ICIkY29tbWFuZCIKZG8KCWNhc2UgIiQxIiBpbgoJYWRkIHwgZm9yZWFjaCB8IGluaXQgfCBkZWluaXQgfCB1cGRhdGUgfCBzdGF0dXMgfCBzdW1tYXJ5IHwgc3luYykKCQljb21tYW5kPSQxCgkJOzsKCS1xfC0tcXVpZXQpCgkJR0lUX1FVSUVUPTEKCQk7OwoJLWJ8LS1icmFuY2gpCgkJY2FzZSAiJDIiIGluCgkJJycpCgkJCXVzYWdlCgkJCTs7CgkJZXNhYwoJCWJyYW5jaD0iJDIiOyBzaGlmdAoJCTs7CgktLWNhY2hlZCkKCQljYWNoZWQ9IiQxIgoJCTs7CgktLSkKCQlicmVhawoJCTs7CgktKikKCQl1c2FnZQoJCTs7CgkqKQoJCWJyZWFrCgkJOzsKCWVzYWMKCXNoaWZ0CmRvbmUKCiMgTm8gY29tbWFuZCB3b3JkIGRlZmF1bHRzIHRvICJzdGF0dXMiCmlmIHRlc3QgLXogIiRjb21tYW5kIgp0aGVuCiAgICBpZiB0ZXN0ICQjID0gMAogICAgdGhlbgoJY29tbWFuZD1zdGF0dXMKICAgIGVsc2UKCXVzYWdlCiAgICBmaQpmaQoKIyAiLWIgYnJhbmNoIiBpcyBhY2NlcHRlZCBvbmx5IGJ5ICJhZGQiCmlmIHRlc3QgLW4gIiRicmFuY2giICYmIHRlc3QgIiRjb21tYW5kIiAhPSBhZGQKdGhlbgoJdXNhZ2UKZmkKCiMgIi0tY2FjaGVkIiBpcyBhY2NlcHRlZCBvbmx5IGJ5ICJzdGF0dXMiIGFuZCAic3VtbWFyeSIKaWYgdGVzdCAtbiAiJGNhY2hlZCIgJiYgdGVzdCAiJGNvbW1hbmQiICE9IHN0YXR1cyAtYSAiJGNvbW1hbmQiICE9IHN1bW1hcnkKdGhlbgoJdXNhZ2UKZmkKCiJjbWRfJGNvbW1hbmQiICIkQCIK",
    "text": "#!/bin/sh\n#\n# git-submodule.sh: add, init, update or list git submodules\n#\n# Copyright (c) 2007 Lars Hjemli\n\ndashless=$(basename \"$0\" | sed -e 's/-/ /')\nUSAGE=\"[--quiet] add [-b <branch>] [-f|--force] [--name <name>] [--reference <repository>] [--] <repository> [<path>]\n   or: $dashless [--quiet] status [--cached] [--recursive] [--] [<path>...]\n   or: $dashless [--quiet] init [--] [<path>...]\n   or: $dashless [--quiet] deinit [-f|--force] [--] <path>...\n   or: $dashless [--quiet] update [--init] [--remote] [-N|--no-fetch] [-f|--force] [--rebase] [--reference <repository>] [--merge] [--recursive] [--] [<path>...]\n   or: $dashless [--quiet] summary [--cached|--files] [--summary-limit <n>] [commit] [--] [<path>...]\n   or: $dashless [--quiet] foreach [--recursive] <command>\n   or: $dashless [--quiet] sync [--recursive] [--] [<path>...]\"\nOPTIONS_SPEC=\nSUBDIRECTORY_OK=Yes\n. git-sh-setup\n. git-sh-i18n\n. git-parse-remote\nrequire_work_tree\nwt_prefix=$(git rev-parse --show-prefix)\ncd_to_toplevel\n\ncommand=\nbranch=\nforce=\nreference=\ncached=\nrecursive=\ninit=\nfiles=\nremote=\nnofetch=\nupdate=\nprefix=\ncustom_name=\ndepth=\n\n# The function takes at most 2 arguments. The first argument is the\n# URL that navigates to the submodule origin repo. When relative, this URL\n# is relative to the superproject origin URL repo. The second up_path\n# argument, if specified, is the relative path that navigates\n# from the submodule working tree to the superproject working tree.\n#\n# The output of the function is the origin URL of the submodule.\n#\n# The output will either be an absolute URL or filesystem path (if the\n# superproject origin URL is an absolute URL or filesystem path,\n# respectively) or a relative file system path (if the superproject\n# origin URL is a relative file system path).\n#\n# When the output is a relative file system path, the path is either\n# relative to the submodule working tree, if up_path is specified, or to\n# the superproject working tree otherwise.\nresolve_relative_url ()\n{\n\tremote=$(get_default_remote)\n\tremoteurl=$(git config \"remote.$remote.url\") ||\n\t\tremoteurl=$(pwd) # the repository is its own authoritative upstream\n\turl=\"$1\"\n\tremoteurl=${remoteurl%/}\n\tsep=/\n\tup_path=\"$2\"\n\n\tcase \"$remoteurl\" in\n\t*:*|/*)\n\t\tis_relative=\n\t\t;;\n\t./*|../*)\n\t\tis_relative=t\n\t\t;;\n\t*)\n\t\tis_relative=t\n\t\tremoteurl=\"./$remoteurl\"\n\t\t;;\n\tesac\n\n\twhile test -n \"$url\"\n\tdo\n\t\tcase \"$url\" in\n\t\t../*)\n\t\t\turl=\"${url#../}\"\n\t\t\tcase \"$remoteurl\" in\n\t\t\t*/*)\n\t\t\t\tremoteurl=\"${remoteurl%/*}\"\n\t\t\t\t;;\n\t\t\t*:*)\n\t\t\t\tremoteurl=\"${remoteurl%:*}\"\n\t\t\t\tsep=:\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\tif test -z \"$is_relative\" || test \".\" = \"$remoteurl\"\n\t\t\t\tthen\n\t\t\t\t\tdie \"$(eval_gettext \"cannot strip one component off url '\\$remoteurl'\")\"\n\t\t\t\telse\n\t\t\t\t\tremoteurl=.\n\t\t\t\tfi\n\t\t\t\t;;\n\t\t\tesac\n\t\t\t;;\n\t\t./*)\n\t\t\turl=\"${url#./}\"\n\t\t\t;;\n\t\t*)\n\t\t\tbreak;;\n\t\tesac\n\tdone\n\tremoteurl=\"$remoteurl$sep${url%/}\"\n\techo \"${is_relative:+${up_path}}${remoteurl#./}\"\n}\n\n# Resolve a path to be relative to another path.  This is intended for\n# converting submodule paths when git-submodule is run in a subdirectory\n# and only handles paths where the directory separator is '/'.\n#\n# The output is the first argument as a path relative to the second argument,\n# which defaults to $wt_prefix if it is omitted.\nrelative_path ()\n{\n\tlocal target curdir result\n\ttarget=$1\n\tcurdir=${2-$wt_prefix}\n\tcurdir=${curdir%/}\n\tresult=\n\n\twhile test -n \"$curdir\"\n\tdo\n\t\tcase \"$target\" in\n\t\t\"$curdir/\"*)\n\t\t\ttarget=${target#\"$curdir\"/}\n\t\t\tbreak\n\t\t\t;;\n\t\tesac\n\n\t\tresult=\"${result}../\"\n\t\tif test \"$curdir\" = \"${curdir%/*}\"\n\t\tthen\n\t\t\tcurdir=\n\t\telse\n\t\t\tcurdir=\"${curdir%/*}\"\n\t\tfi\n\tdone\n\n\techo \"$result$target\"\n}\n\n#\n# Get submodule info for registered submodules\n# $@ = path to limit submodule list\n#\nmodule_list()\n{\n\teval \"set $(git rev-parse --sq --prefix \"$wt_prefix\" -- \"$@\")\"\n\t(\n\t\tgit ls-files -z --error-unmatch --stage -- \"$@\" ||\n\t\techo \"unmatched pathspec exists\"\n\t) |\n\tperl -e '\n\tmy %unmerged = ();\n\tmy ($null_sha1) = (\"0\" x 40);\n\tmy @out = ();\n\tmy $unmatched = 0;\n\t$/ = \"\\0\";\n\twhile (<STDIN>) {\n\t\tif (/^unmatched pathspec/) {\n\t\t\t$unmatched = 1;\n\t\t\tnext;\n\t\t}\n\t\tchomp;\n\t\tmy ($mode, $sha1, $stage, $path) =\n\t\t\t/^([0-7]+) ([0-9a-f]{40}) ([0-3])\\t(.*)$/;\n\t\tnext unless $mode eq \"160000\";\n\t\tif ($stage ne \"0\") {\n\t\t\tif (!$unmerged{$path}++) {\n\t\t\t\tpush @out, \"$mode $null_sha1 U\\t$path\\n\";\n\t\t\t}\n\t\t\tnext;\n\t\t}\n\t\tpush @out, \"$_\\n\";\n\t}\n\tif ($unmatched) {\n\t\tprint \"#unmatched\\n\";\n\t} else {\n\t\tprint for (@out);\n\t}\n\t'\n}\n\ndie_if_unmatched ()\n{\n\tif test \"$1\" = \"#unmatched\"\n\tthen\n\t\texit 1\n\tfi\n}\n\n#\n# Print a submodule configuration setting\n#\n# $1 = submodule name\n# $2 = option name\n# $3 = default value\n#\n# Checks in the usual git-config places first (for overrides),\n# otherwise it falls back on .gitmodules.  This allows you to\n# distribute project-wide defaults in .gitmodules, while still\n# customizing individual repositories if necessary.  If the option is\n# not in .gitmodules either, print a default value.\n#\nget_submodule_config () {\n\tname=\"$1\"\n\toption=\"$2\"\n\tdefault=\"$3\"\n\tvalue=$(git config submodule.\"$name\".\"$option\")\n\tif test -z \"$value\"\n\tthen\n\t\tvalue=$(git config -f .gitmodules submodule.\"$name\".\"$option\")\n\tfi\n\tprintf '%s' \"${value:-$default}\"\n}\n\n\n#\n# Map submodule path to submodule name\n#\n# $1 = path\n#\nmodule_name()\n{\n\t# Do we have \"submodule.<something>.path = $1\" defined in .gitmodules file?\n\tsm_path=\"$1\"\n\tre=$(printf '%s\\n' \"$1\" | sed -e 's/[].[^$\\\\*]/\\\\&/g')\n\tname=$( git config -f .gitmodules --get-regexp '^submodule\\..*\\.path$' |\n\t\tsed -n -e 's|^submodule\\.\\(.*\\)\\.path '\"$re\"'$|\\1|p' )\n\ttest -z \"$name\" &&\n\tdie \"$(eval_gettext \"No submodule mapping found in .gitmodules for path '\\$sm_path'\")\"\n\techo \"$name\"\n}\n\n#\n# Clone a submodule\n#\n# Prior to calling, cmd_update checks that a possibly existing\n# path is not a git repository.\n# Likewise, cmd_add checks that path does not exist at all,\n# since it is the location of a new submodule.\n#\nmodule_clone()\n{\n\tsm_path=$1\n\tname=$2\n\turl=$3\n\treference=\"$4\"\n\tdepth=\"$5\"\n\tquiet=\n\tif test -n \"$GIT_QUIET\"\n\tthen\n\t\tquiet=-q\n\tfi\n\n\tgitdir=\n\tgitdir_base=\n\tbase_name=$(dirname \"$name\")\n\n\tgitdir=$(git rev-parse --git-dir)\n\tgitdir_base=\"$gitdir/modules/$base_name\"\n\tgitdir=\"$gitdir/modules/$name\"\n\n\tif test -d \"$gitdir\"\n\tthen\n\t\tmkdir -p \"$sm_path\"\n\t\trm -f \"$gitdir/index\"\n\telse\n\t\tmkdir -p \"$gitdir_base\"\n\t\t(\n\t\t\tclear_local_git_env\n\t\t\tgit clone $quiet ${depth:+\"$depth\"} -n ${reference:+\"$reference\"} \\\n\t\t\t\t--separate-git-dir \"$gitdir\" \"$url\" \"$sm_path\"\n\t\t) ||\n\t\tdie \"$(eval_gettext \"Clone of '\\$url' into submodule path '\\$sm_path' failed\")\"\n\tfi\n\n\t# We already are at the root of the work tree but cd_to_toplevel will\n\t# resolve any symlinks that might be present in $PWD\n\ta=$(cd_to_toplevel && cd \"$gitdir\" && pwd)/\n\tb=$(cd_to_toplevel && cd \"$sm_path\" && pwd)/\n\t# normalize Windows-style absolute paths to POSIX-style absolute paths\n\tcase $a in [a-zA-Z]:/*) a=/${a%%:*}${a#*:} ;; esac\n\tcase $b in [a-zA-Z]:/*) b=/${b%%:*}${b#*:} ;; esac\n\t# Remove all common leading directories after a sanity check\n\tif test \"${a#$b}\" != \"$a\" || test \"${b#$a}\" != \"$b\"; then\n\t\tdie \"$(eval_gettext \"Gitdir '\\$a' is part of the submodule path '\\$b' or vice versa\")\"\n\tfi\n\twhile test \"${a%%/*}\" = \"${b%%/*}\"\n\tdo\n\t\ta=${a#*/}\n\t\tb=${b#*/}\n\tdone\n\t# Now chop off the trailing '/'s that were added in the beginning\n\ta=${a%/}\n\tb=${b%/}\n\n\t# Turn each leading \"*/\" component into \"../\"\n\trel=$(echo $b | sed -e 's|[^/][^/]*|..|g')\n\techo \"gitdir: $rel/$a\" >\"$sm_path/.git\"\n\n\trel=$(echo $a | sed -e 's|[^/][^/]*|..|g')\n\t(clear_local_git_env; cd \"$sm_path\" && GIT_WORK_TREE=. git config core.worktree \"$rel/$b\")\n}\n\nisnumber()\n{\n\tn=$(($1 + 0)) 2>/dev/null && test \"$n\" = \"$1\"\n}\n\n#\n# Add a new submodule to the working tree, .gitmodules and the index\n#\n# $@ = repo path\n#\n# optional branch is stored in global branch variable\n#\ncmd_add()\n{\n\t# parse $args after \"submodule ... add\".\n\treference_path=\n\twhile test $# -ne 0\n\tdo\n\t\tcase \"$1\" in\n\t\t-b | --branch)\n\t\t\tcase \"$2\" in '') usage ;; esac\n\t\t\tbranch=$2\n\t\t\tshift\n\t\t\t;;\n\t\t-f | --force)\n\t\t\tforce=$1\n\t\t\t;;\n\t\t-q|--quiet)\n\t\t\tGIT_QUIET=1\n\t\t\t;;\n\t\t--reference)\n\t\t\tcase \"$2\" in '') usage ;; esac\n\t\t\treference_path=$2\n\t\t\tshift\n\t\t\t;;\n\t\t--reference=*)\n\t\t\treference_path=\"${1#--reference=}\"\n\t\t\t;;\n\t\t--name)\n\t\t\tcase \"$2\" in '') usage ;; esac\n\t\t\tcustom_name=$2\n\t\t\tshift\n\t\t\t;;\n\t\t--depth)\n\t\t\tcase \"$2\" in '') usage ;; esac\n\t\t\tdepth=\"--depth=$2\"\n\t\t\tshift\n\t\t\t;;\n\t\t--depth=*)\n\t\t\tdepth=$1\n\t\t\t;;\n\t\t--)\n\t\t\tshift\n\t\t\tbreak\n\t\t\t;;\n\t\t-*)\n\t\t\tusage\n\t\t\t;;\n\t\t*)\n\t\t\tbreak\n\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n\n\tif test -n \"$reference_path\"\n\tthen\n\t\tis_absolute_path \"$reference_path\" ||\n\t\treference_path=\"$wt_prefix$reference_path\"\n\n\t\treference=\"--reference=$reference_path\"\n\tfi\n\n\trepo=$1\n\tsm_path=$2\n\n\tif test -z \"$sm_path\"; then\n\t\tsm_path=$(echo \"$repo\" |\n\t\t\tsed -e 's|/$||' -e 's|:*/*\\.git$||' -e 's|.*[/:]||g')\n\tfi\n\n\tif test -z \"$repo\" -o -z \"$sm_path\"; then\n\t\tusage\n\tfi\n\n\tis_absolute_path \"$sm_path\" || sm_path=\"$wt_prefix$sm_path\"\n\n\t# assure repo is absolute or relative to parent\n\tcase \"$repo\" in\n\t./*|../*)\n\t\ttest -z \"$wt_prefix\" ||\n\t\tdie \"$(gettext \"Relative path can only be used from the toplevel of the working tree\")\"\n\n\t\t# dereference source url relative to parent's url\n\t\trealrepo=$(resolve_relative_url \"$repo\") || exit\n\t\t;;\n\t*:*|/*)\n\t\t# absolute url\n\t\trealrepo=$repo\n\t\t;;\n\t*)\n\t\tdie \"$(eval_gettext \"repo URL: '\\$repo' must be absolute or begin with ./|../\")\"\n\t;;\n\tesac\n\n\t# normalize path:\n\t# multiple //; leading ./; /./; /../; trailing /\n\tsm_path=$(printf '%s/\\n' \"$sm_path\" |\n\t\tsed -e '\n\t\t\ts|//*|/|g\n\t\t\ts|^\\(\\./\\)*||\n\t\t\ts|/\\./|/|g\n\t\t\t:start\n\t\t\ts|\\([^/]*\\)/\\.\\./||\n\t\t\ttstart\n\t\t\ts|/*$||\n\t\t')\n\tgit ls-files --error-unmatch \"$sm_path\" > /dev/null 2>&1 &&\n\tdie \"$(eval_gettext \"'\\$sm_path' already exists in the index\")\"\n\n\tif test -z \"$force\" && ! git add --dry-run --ignore-missing \"$sm_path\" > /dev/null 2>&1\n\tthen\n\t\teval_gettextln \"The following path is ignored by one of your .gitignore files:\n\\$sm_path\nUse -f if you really want to add it.\" >&2\n\t\texit 1\n\tfi\n\n\tif test -n \"$custom_name\"\n\tthen\n\t\tsm_name=\"$custom_name\"\n\telse\n\t\tsm_name=\"$sm_path\"\n\tfi\n\n\t# perhaps the path exists and is already a git repo, else clone it\n\tif test -e \"$sm_path\"\n\tthen\n\t\tif test -d \"$sm_path\"/.git -o -f \"$sm_path\"/.git\n\t\tthen\n\t\t\teval_gettextln \"Adding existing repo at '\\$sm_path' to the index\"\n\t\telse\n\t\t\tdie \"$(eval_gettext \"'\\$sm_path' already exists and is not a valid git repo\")\"\n\t\tfi\n\n\telse\n\t\tif test -d \".git/modules/$sm_name\"\n\t\tthen\n\t\t\tif test -z \"$force\"\n\t\t\tthen\n\t\t\t\techo >&2 \"$(eval_gettext \"A git directory for '\\$sm_name' is found locally with remote(s):\")\"\n\t\t\t\tGIT_DIR=\".git/modules/$sm_name\" GIT_WORK_TREE=. git remote -v | grep '(fetch)' | sed -e s,^,\"  \", -e s,' (fetch)',, >&2\n\t\t\t\techo >&2 \"$(eval_gettext \"If you want to reuse this local git directory instead of cloning again from\")\"\n\t\t\t\techo >&2 \"  $realrepo\"\n\t\t\t\techo >&2 \"$(eval_gettext \"use the '--force' option. If the local git directory is not the correct repo\")\"\n\t\t\t\tdie \"$(eval_gettext \"or you are unsure what this means choose another name with the '--name' option.\")\"\n\t\t\telse\n\t\t\t\techo \"$(eval_gettext \"Reactivating local git directory for submodule '\\$sm_name'.\")\"\n\t\t\tfi\n\t\tfi\n\t\tmodule_clone \"$sm_path\" \"$sm_name\" \"$realrepo\" \"$reference\" \"$depth\" || exit\n\t\t(\n\t\t\tclear_local_git_env\n\t\t\tcd \"$sm_path\" &&\n\t\t\t# ash fails to wordsplit ${branch:+-b \"$branch\"...}\n\t\t\tcase \"$branch\" in\n\t\t\t'') git checkout -f -q ;;\n\t\t\t?*) git checkout -f -q -B \"$branch\" \"origin/$branch\" ;;\n\t\t\tesac\n\t\t) || die \"$(eval_gettext \"Unable to checkout submodule '\\$sm_path'\")\"\n\tfi\n\tgit config submodule.\"$sm_name\".url \"$realrepo\"\n\n\tgit add $force \"$sm_path\" ||\n\tdie \"$(eval_gettext \"Failed to add submodule '\\$sm_path'\")\"\n\n\tgit config -f .gitmodules submodule.\"$sm_name\".path \"$sm_path\" &&\n\tgit config -f .gitmodules submodule.\"$sm_name\".url \"$repo\" &&\n\tif test -n \"$branch\"\n\tthen\n\t\tgit config -f .gitmodules submodule.\"$sm_name\".branch \"$branch\"\n\tfi &&\n\tgit add --force .gitmodules ||\n\tdie \"$(eval_gettext \"Failed to register submodule '\\$sm_path'\")\"\n}\n\n#\n# Execute an arbitrary command sequence in each checked out\n# submodule\n#\n# $@ = command to execute\n#\ncmd_foreach()\n{\n\t# parse $args after \"submodule ... foreach\".\n\twhile test $# -ne 0\n\tdo\n\t\tcase \"$1\" in\n\t\t-q|--quiet)\n\t\t\tGIT_QUIET=1\n\t\t\t;;\n\t\t--recursive)\n\t\t\trecursive=1\n\t\t\t;;\n\t\t-*)\n\t\t\tusage\n\t\t\t;;\n\t\t*)\n\t\t\tbreak\n\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n\n\ttoplevel=$(pwd)\n\n\t# dup stdin so that it can be restored when running the external\n\t# command in the subshell (and a recursive call to this function)\n\texec 3<&0\n\n\tmodule_list |\n\twhile read mode sha1 stage sm_path\n\tdo\n\t\tdie_if_unmatched \"$mode\"\n\t\tif test -e \"$sm_path\"/.git\n\t\tthen\n\t\t\tdisplaypath=$(relative_path \"$sm_path\")\n\t\t\tsay \"$(eval_gettext \"Entering '\\$prefix\\$displaypath'\")\"\n\t\t\tname=$(module_name \"$sm_path\")\n\t\t\t(\n\t\t\t\tprefix=\"$prefix$sm_path/\"\n\t\t\t\tclear_local_git_env\n\t\t\t\tcd \"$sm_path\" &&\n\t\t\t\tsm_path=$(relative_path \"$sm_path\") &&\n\t\t\t\t# we make $path available to scripts ...\n\t\t\t\tpath=$sm_path &&\n\t\t\t\teval \"$@\" &&\n\t\t\t\tif test -n \"$recursive\"\n\t\t\t\tthen\n\t\t\t\t\tcmd_foreach \"--recursive\" \"$@\"\n\t\t\t\tfi\n\t\t\t) <&3 3<&- ||\n\t\t\tdie \"$(eval_gettext \"Stopping at '\\$prefix\\$displaypath'; script returned non-zero status.\")\"\n\t\tfi\n\tdone\n}\n\n#\n# Register submodules in .git/config\n#\n# $@ = requested paths (default to all)\n#\ncmd_init()\n{\n\t# parse $args after \"submodule ... init\".\n\twhile test $# -ne 0\n\tdo\n\t\tcase \"$1\" in\n\t\t-q|--quiet)\n\t\t\tGIT_QUIET=1\n\t\t\t;;\n\t\t--)\n\t\t\tshift\n\t\t\tbreak\n\t\t\t;;\n\t\t-*)\n\t\t\tusage\n\t\t\t;;\n\t\t*)\n\t\t\tbreak\n\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n\n\tmodule_list \"$@\" |\n\twhile read mode sha1 stage sm_path\n\tdo\n\t\tdie_if_unmatched \"$mode\"\n\t\tname=$(module_name \"$sm_path\") || exit\n\n\t\tdisplaypath=$(relative_path \"$sm_path\")\n\n\t\t# Copy url setting when it is not set yet\n\t\tif test -z \"$(git config \"submodule.$name.url\")\"\n\t\tthen\n\t\t\turl=$(git config -f .gitmodules submodule.\"$name\".url)\n\t\t\ttest -z \"$url\" &&\n\t\t\tdie \"$(eval_gettext \"No url found for submodule path '\\$displaypath' in .gitmodules\")\"\n\n\t\t\t# Possibly a url relative to parent\n\t\t\tcase \"$url\" in\n\t\t\t./*|../*)\n\t\t\t\turl=$(resolve_relative_url \"$url\") || exit\n\t\t\t\t;;\n\t\t\tesac\n\t\t\tgit config submodule.\"$name\".url \"$url\" ||\n\t\t\tdie \"$(eval_gettext \"Failed to register url for submodule path '\\$displaypath'\")\"\n\n\t\t\tsay \"$(eval_gettext \"Submodule '\\$name' (\\$url) registered for path '\\$displaypath'\")\"\n\t\tfi\n\n\t\t# Copy \"update\" setting when it is not set yet\n\t\tupd=\"$(git config -f .gitmodules submodule.\"$name\".update)\"\n\t\ttest -z \"$upd\" ||\n\t\ttest -n \"$(git config submodule.\"$name\".update)\" ||\n\t\tgit config submodule.\"$name\".update \"$upd\" ||\n\t\tdie \"$(eval_gettext \"Failed to register update mode for submodule path '\\$displaypath'\")\"\n\tdone\n}\n\n#\n# Unregister submodules from .git/config and remove their work tree\n#\n# $@ = requested paths (use '.' to deinit all submodules)\n#\ncmd_deinit()\n{\n\t# parse $args after \"submodule ... deinit\".\n\twhile test $# -ne 0\n\tdo\n\t\tcase \"$1\" in\n\t\t-f|--force)\n\t\t\tforce=$1\n\t\t\t;;\n\t\t-q|--quiet)\n\t\t\tGIT_QUIET=1\n\t\t\t;;\n\t\t--)\n\t\t\tshift\n\t\t\tbreak\n\t\t\t;;\n\t\t-*)\n\t\t\tusage\n\t\t\t;;\n\t\t*)\n\t\t\tbreak\n\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n\n\tif test $# = 0\n\tthen\n\t\tdie \"$(eval_gettext \"Use '.' if you really want to deinitialize all submodules\")\"\n\tfi\n\n\tmodule_list \"$@\" |\n\twhile read mode sha1 stage sm_path\n\tdo\n\t\tdie_if_unmatched \"$mode\"\n\t\tname=$(module_name \"$sm_path\") || exit\n\n\t\tdisplaypath=$(relative_path \"$sm_path\")\n\n\t\t# Remove the submodule work tree (unless the user already did it)\n\t\tif test -d \"$sm_path\"\n\t\tthen\n\t\t\t# Protect submodules containing a .git directory\n\t\t\tif test -d \"$sm_path/.git\"\n\t\t\tthen\n\t\t\t\techo >&2 \"$(eval_gettext \"Submodule work tree '\\$displaypath' contains a .git directory\")\"\n\t\t\t\tdie \"$(eval_gettext \"(use 'rm -rf' if you really want to remove it including all of its history)\")\"\n\t\t\tfi\n\n\t\t\tif test -z \"$force\"\n\t\t\tthen\n\t\t\t\tgit rm -qn \"$sm_path\" ||\n\t\t\t\tdie \"$(eval_gettext \"Submodule work tree '\\$displaypath' contains local modifications; use '-f' to discard them\")\"\n\t\t\tfi\n\t\t\trm -rf \"$sm_path\" &&\n\t\t\tsay \"$(eval_gettext \"Cleared directory '\\$displaypath'\")\" ||\n\t\t\tsay \"$(eval_gettext \"Could not remove submodule work tree '\\$displaypath'\")\"\n\t\tfi\n\n\t\tmkdir \"$sm_path\" || say \"$(eval_gettext \"Could not create empty submodule directory '\\$displaypath'\")\"\n\n\t\t# Remove the .git/config entries (unless the user already did it)\n\t\tif test -n \"$(git config --get-regexp submodule.\"$name\\.\")\"\n\t\tthen\n\t\t\t# Remove the whole section so we have a clean state when\n\t\t\t# the user later decides to init this submodule again\n\t\t\turl=$(git config submodule.\"$name\".url)\n\t\t\tgit config --remove-section submodule.\"$name\" 2>/dev/null &&\n\t\t\tsay \"$(eval_gettext \"Submodule '\\$name' (\\$url) unregistered for path '\\$displaypath'\")\"\n\t\tfi\n\tdone\n}\n\n#\n# Update each submodule path to correct revision, using clone and checkout as needed\n#\n# $@ = requested paths (default to all)\n#\ncmd_update()\n{\n\t# parse $args after \"submodule ... update\".\n\torig_flags=\n\twhile test $# -ne 0\n\tdo\n\t\tcase \"$1\" in\n\t\t-q|--quiet)\n\t\t\tGIT_QUIET=1\n\t\t\t;;\n\t\t-i|--init)\n\t\t\tinit=1\n\t\t\t;;\n\t\t--remote)\n\t\t\tremote=1\n\t\t\t;;\n\t\t-N|--no-fetch)\n\t\t\tnofetch=1\n\t\t\t;;\n\t\t-f|--force)\n\t\t\tforce=$1\n\t\t\t;;\n\t\t-r|--rebase)\n\t\t\tupdate=\"rebase\"\n\t\t\t;;\n\t\t--reference)\n\t\t\tcase \"$2\" in '') usage ;; esac\n\t\t\treference=\"--reference=$2\"\n\t\t\torig_flags=\"$orig_flags $(git rev-parse --sq-quote \"$1\")\"\n\t\t\tshift\n\t\t\t;;\n\t\t--reference=*)\n\t\t\treference=\"$1\"\n\t\t\t;;\n\t\t-m|--merge)\n\t\t\tupdate=\"merge\"\n\t\t\t;;\n\t\t--recursive)\n\t\t\trecursive=1\n\t\t\t;;\n\t\t--checkout)\n\t\t\tupdate=\"checkout\"\n\t\t\t;;\n\t\t--depth)\n\t\t\tcase \"$2\" in '') usage ;; esac\n\t\t\tdepth=\"--depth=$2\"\n\t\t\tshift\n\t\t\t;;\n\t\t--depth=*)\n\t\t\tdepth=$1\n\t\t\t;;\n\t\t--)\n\t\t\tshift\n\t\t\tbreak\n\t\t\t;;\n\t\t-*)\n\t\t\tusage\n\t\t\t;;\n\t\t*)\n\t\t\tbreak\n\t\t\t;;\n\t\tesac\n\t\torig_flags=\"$orig_flags $(git rev-parse --sq-quote \"$1\")\"\n\t\tshift\n\tdone\n\n\tif test -n \"$init\"\n\tthen\n\t\tcmd_init \"--\" \"$@\" || return\n\tfi\n\n\tcloned_modules=\n\tmodule_list \"$@\" | {\n\terr=\n\twhile read mode sha1 stage sm_path\n\tdo\n\t\tdie_if_unmatched \"$mode\"\n\t\tif test \"$stage\" = U\n\t\tthen\n\t\t\techo >&2 \"Skipping unmerged submodule $prefix$sm_path\"\n\t\t\tcontinue\n\t\tfi\n\t\tname=$(module_name \"$sm_path\") || exit\n\t\turl=$(git config submodule.\"$name\".url)\n\t\tbranch=$(get_submodule_config \"$name\" branch master)\n\t\tif ! test -z \"$update\"\n\t\tthen\n\t\t\tupdate_module=$update\n\t\telse\n\t\t\tupdate_module=$(git config submodule.\"$name\".update)\n\t\tfi\n\n\t\tdisplaypath=$(relative_path \"$prefix$sm_path\")\n\n\t\tif test \"$update_module\" = \"none\"\n\t\tthen\n\t\t\techo \"Skipping submodule '$displaypath'\"\n\t\t\tcontinue\n\t\tfi\n\n\t\tif test -z \"$url\"\n\t\tthen\n\t\t\t# Only mention uninitialized submodules when its\n\t\t\t# path have been specified\n\t\t\ttest \"$#\" != \"0\" &&\n\t\t\tsay \"$(eval_gettext \"Submodule path '\\$displaypath' not initialized\nMaybe you want to use 'update --init'?\")\"\n\t\t\tcontinue\n\t\tfi\n\n\t\tif ! test -d \"$sm_path\"/.git -o -f \"$sm_path\"/.git\n\t\tthen\n\t\t\tmodule_clone \"$sm_path\" \"$name\" \"$url\" \"$reference\" \"$depth\" || exit\n\t\t\tcloned_modules=\"$cloned_modules;$name\"\n\t\t\tsubsha1=\n\t\telse\n\t\t\tsubsha1=$(clear_local_git_env; cd \"$sm_path\" &&\n\t\t\t\tgit rev-parse --verify HEAD) ||\n\t\t\tdie \"$(eval_gettext \"Unable to find current revision in submodule path '\\$displaypath'\")\"\n\t\tfi\n\n\t\tif test -n \"$remote\"\n\t\tthen\n\t\t\tif test -z \"$nofetch\"\n\t\t\tthen\n\t\t\t\t# Fetch remote before determining tracking $sha1\n\t\t\t\t(clear_local_git_env; cd \"$sm_path\" && git-fetch) ||\n\t\t\t\tdie \"$(eval_gettext \"Unable to fetch in submodule path '\\$sm_path'\")\"\n\t\t\tfi\n\t\t\tremote_name=$(clear_local_git_env; cd \"$sm_path\" && get_default_remote)\n\t\t\tsha1=$(clear_local_git_env; cd \"$sm_path\" &&\n\t\t\t\tgit rev-parse --verify \"${remote_name}/${branch}\") ||\n\t\t\tdie \"$(eval_gettext \"Unable to find current ${remote_name}/${branch} revision in submodule path '\\$sm_path'\")\"\n\t\tfi\n\n\t\tif test \"$subsha1\" != \"$sha1\" -o -n \"$force\"\n\t\tthen\n\t\t\tsubforce=$force\n\t\t\t# If we don't already have a -f flag and the submodule has never been checked out\n\t\t\tif test -z \"$subsha1\" -a -z \"$force\"\n\t\t\tthen\n\t\t\t\tsubforce=\"-f\"\n\t\t\tfi\n\n\t\t\tif test -z \"$nofetch\"\n\t\t\tthen\n\t\t\t\t# Run fetch only if $sha1 isn't present or it\n\t\t\t\t# is not reachable from a ref.\n\t\t\t\t(clear_local_git_env; cd \"$sm_path\" &&\n\t\t\t\t\t( (rev=$(git rev-list -n 1 $sha1 --not --all 2>/dev/null) &&\n\t\t\t\t\t test -z \"$rev\") || git-fetch)) ||\n\t\t\t\tdie \"$(eval_gettext \"Unable to fetch in submodule path '\\$displaypath'\")\"\n\t\t\tfi\n\n\t\t\t# Is this something we just cloned?\n\t\t\tcase \";$cloned_modules;\" in\n\t\t\t*\";$name;\"*)\n\t\t\t\t# then there is no local change to integrate\n\t\t\t\tupdate_module= ;;\n\t\t\tesac\n\n\t\t\tmust_die_on_failure=\n\t\t\tcase \"$update_module\" in\n\t\t\trebase)\n\t\t\t\tcommand=\"git rebase\"\n\t\t\t\tdie_msg=\"$(eval_gettext \"Unable to rebase '\\$sha1' in submodule path '\\$displaypath'\")\"\n\t\t\t\tsay_msg=\"$(eval_gettext \"Submodule path '\\$displaypath': rebased into '\\$sha1'\")\"\n\t\t\t\tmust_die_on_failure=yes\n\t\t\t\t;;\n\t\t\tmerge)\n\t\t\t\tcommand=\"git merge\"\n\t\t\t\tdie_msg=\"$(eval_gettext \"Unable to merge '\\$sha1' in submodule path '\\$displaypath'\")\"\n\t\t\t\tsay_msg=\"$(eval_gettext \"Submodule path '\\$displaypath': merged in '\\$sha1'\")\"\n\t\t\t\tmust_die_on_failure=yes\n\t\t\t\t;;\n\t\t\t!*)\n\t\t\t\tcommand=\"${update_module#!}\"\n\t\t\t\tdie_msg=\"$(eval_gettext \"Execution of '\\$command \\$sha1' failed in submodule  path '\\$prefix\\$sm_path'\")\"\n\t\t\t\tsay_msg=\"$(eval_gettext \"Submodule path '\\$prefix\\$sm_path': '\\$command \\$sha1'\")\"\n\t\t\t\tmust_die_on_failure=yes\n\t\t\t\t;;\n\t\t\t*)\n\t\t\t\tcommand=\"git checkout $subforce -q\"\n\t\t\t\tdie_msg=\"$(eval_gettext \"Unable to checkout '\\$sha1' in submodule path '\\$displaypath'\")\"\n\t\t\t\tsay_msg=\"$(eval_gettext \"Submodule path '\\$displaypath': checked out '\\$sha1'\")\"\n\t\t\t\t;;\n\t\t\tesac\n\n\t\t\tif (clear_local_git_env; cd \"$sm_path\" && $command \"$sha1\")\n\t\t\tthen\n\t\t\t\tsay \"$say_msg\"\n\t\t\telif test -n \"$must_die_on_failure\"\n\t\t\tthen\n\t\t\t\tdie_with_status 2 \"$die_msg\"\n\t\t\telse\n\t\t\t\terr=\"${err};$die_msg\"\n\t\t\t\tcontinue\n\t\t\tfi\n\t\tfi\n\n\t\tif test -n \"$recursive\"\n\t\tthen\n\t\t\t(\n\t\t\t\tprefix=\"$prefix$sm_path/\"\n\t\t\t\tclear_local_git_env\n\t\t\t\tcd \"$sm_path\" &&\n\t\t\t\teval cmd_update \"$orig_flags\"\n\t\t\t)\n\t\t\tres=$?\n\t\t\tif test $res -gt 0\n\t\t\tthen\n\t\t\t\tdie_msg=\"$(eval_gettext \"Failed to recurse into submodule path '\\$displaypath'\")\"\n\t\t\t\tif test $res -eq 1\n\t\t\t\tthen\n\t\t\t\t\terr=\"${err};$die_msg\"\n\t\t\t\t\tcontinue\n\t\t\t\telse\n\t\t\t\t\tdie_with_status $res \"$die_msg\"\n\t\t\t\tfi\n\t\t\tfi\n\t\tfi\n\tdone\n\n\tif test -n \"$err\"\n\tthen\n\t\tOIFS=$IFS\n\t\tIFS=';'\n\t\tfor e in $err\n\t\tdo\n\t\t\tif test -n \"$e\"\n\t\t\tthen\n\t\t\t\techo >&2 \"$e\"\n\t\t\tfi\n\t\tdone\n\t\tIFS=$OIFS\n\t\texit 1\n\tfi\n\t}\n}\n\nset_name_rev () {\n\trevname=$( (\n\t\tclear_local_git_env\n\t\tcd \"$1\" && {\n\t\t\tgit describe \"$2\" 2>/dev/null ||\n\t\t\tgit describe --tags \"$2\" 2>/dev/null ||\n\t\t\tgit describe --contains \"$2\" 2>/dev/null ||\n\t\t\tgit describe --all --always \"$2\"\n\t\t}\n\t) )\n\ttest -z \"$revname\" || revname=\" ($revname)\"\n}\n#\n# Show commit summary for submodules in index or working tree\n#\n# If '--cached' is given, show summary between index and given commit,\n# or between working tree and given commit\n#\n# $@ = [commit (default 'HEAD'),] requested paths (default all)\n#\ncmd_summary() {\n\tsummary_limit=-1\n\tfor_status=\n\tdiff_cmd=diff-index\n\n\t# parse $args after \"submodule ... summary\".\n\twhile test $# -ne 0\n\tdo\n\t\tcase \"$1\" in\n\t\t--cached)\n\t\t\tcached=\"$1\"\n\t\t\t;;\n\t\t--files)\n\t\t\tfiles=\"$1\"\n\t\t\t;;\n\t\t--for-status)\n\t\t\tfor_status=\"$1\"\n\t\t\t;;\n\t\t-n|--summary-limit)\n\t\t\tsummary_limit=\"$2\"\n\t\t\tisnumber \"$summary_limit\" || usage\n\t\t\tshift\n\t\t\t;;\n\t\t--summary-limit=*)\n\t\t\tsummary_limit=\"${1#--summary-limit=}\"\n\t\t\tisnumber \"$summary_limit\" || usage\n\t\t\t;;\n\t\t--)\n\t\t\tshift\n\t\t\tbreak\n\t\t\t;;\n\t\t-*)\n\t\t\tusage\n\t\t\t;;\n\t\t*)\n\t\t\tbreak\n\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n\n\ttest $summary_limit = 0 && return\n\n\tif rev=$(git rev-parse -q --verify --default HEAD ${1+\"$1\"})\n\tthen\n\t\thead=$rev\n\t\ttest $# = 0 || shift\n\telif test -z \"$1\" -o \"$1\" = \"HEAD\"\n\tthen\n\t\t# before the first commit: compare with an empty tree\n\t\thead=$(git hash-object -w -t tree --stdin </dev/null)\n\t\ttest -z \"$1\" || shift\n\telse\n\t\thead=\"HEAD\"\n\tfi\n\n\tif [ -n \"$files\" ]\n\tthen\n\t\ttest -n \"$cached\" &&\n\t\tdie \"$(gettext \"The --cached option cannot be used with the --files option\")\"\n\t\tdiff_cmd=diff-files\n\t\thead=\n\tfi\n\n\tcd_to_toplevel\n\teval \"set $(git rev-parse --sq --prefix \"$wt_prefix\" -- \"$@\")\"\n\t# Get modified modules cared by user\n\tmodules=$(git $diff_cmd $cached --ignore-submodules=dirty --raw $head -- \"$@\" |\n\t\tsane_egrep '^:([0-7]* )?160000' |\n\t\twhile read mod_src mod_dst sha1_src sha1_dst status sm_path\n\t\tdo\n\t\t\t# Always show modules deleted or type-changed (blob<->module)\n\t\t\ttest $status = D -o $status = T && echo \"$sm_path\" && continue\n\t\t\t# Respect the ignore setting for --for-status.\n\t\t\tif test -n \"$for_status\"\n\t\t\tthen\n\t\t\t\tname=$(module_name \"$sm_path\")\n\t\t\t\tignore_config=$(get_submodule_config \"$name\" ignore none)\n\t\t\t\ttest $status != A -a $ignore_config = all && continue\n\t\t\tfi\n\t\t\t# Also show added or modified modules which are checked out\n\t\t\tGIT_DIR=\"$sm_path/.git\" git-rev-parse --git-dir >/dev/null 2>&1 &&\n\t\t\techo \"$sm_path\"\n\t\tdone\n\t)\n\n\ttest -z \"$modules\" && return\n\n\tgit $diff_cmd $cached --ignore-submodules=dirty --raw $head -- $modules |\n\tsane_egrep '^:([0-7]* )?160000' |\n\tcut -c2- |\n\twhile read mod_src mod_dst sha1_src sha1_dst status name\n\tdo\n\t\tif test -z \"$cached\" &&\n\t\t\ttest $sha1_dst = 0000000000000000000000000000000000000000\n\t\tthen\n\t\t\tcase \"$mod_dst\" in\n\t\t\t160000)\n\t\t\t\tsha1_dst=$(GIT_DIR=\"$name/.git\" git rev-parse HEAD)\n\t\t\t\t;;\n\t\t\t100644 | 100755 | 120000)\n\t\t\t\tsha1_dst=$(git hash-object $name)\n\t\t\t\t;;\n\t\t\t000000)\n\t\t\t\t;; # removed\n\t\t\t*)\n\t\t\t\t# unexpected type\n\t\t\t\teval_gettextln \"unexpected mode \\$mod_dst\" >&2\n\t\t\t\tcontinue ;;\n\t\t\tesac\n\t\tfi\n\t\tmissing_src=\n\t\tmissing_dst=\n\n\t\ttest $mod_src = 160000 &&\n\t\t! GIT_DIR=\"$name/.git\" git-rev-parse -q --verify $sha1_src^0 >/dev/null &&\n\t\tmissing_src=t\n\n\t\ttest $mod_dst = 160000 &&\n\t\t! GIT_DIR=\"$name/.git\" git-rev-parse -q --verify $sha1_dst^0 >/dev/null &&\n\t\tmissing_dst=t\n\n\t\tdisplay_name=$(relative_path \"$name\")\n\n\t\ttotal_commits=\n\t\tcase \"$missing_src,$missing_dst\" in\n\t\tt,)\n\t\t\terrmsg=\"$(eval_gettext \"  Warn: \\$display_name doesn't contain commit \\$sha1_src\")\"\n\t\t\t;;\n\t\t,t)\n\t\t\terrmsg=\"$(eval_gettext \"  Warn: \\$display_name doesn't contain commit \\$sha1_dst\")\"\n\t\t\t;;\n\t\tt,t)\n\t\t\terrmsg=\"$(eval_gettext \"  Warn: \\$display_name doesn't contain commits \\$sha1_src and \\$sha1_dst\")\"\n\t\t\t;;\n\t\t*)\n\t\t\terrmsg=\n\t\t\ttotal_commits=$(\n\t\t\tif test $mod_src = 160000 -a $mod_dst = 160000\n\t\t\tthen\n\t\t\t\trange=\"$sha1_src...$sha1_dst\"\n\t\t\telif test $mod_src = 160000\n\t\t\tthen\n\t\t\t\trange=$sha1_src\n\t\t\telse\n\t\t\t\trange=$sha1_dst\n\t\t\tfi\n\t\t\tGIT_DIR=\"$name/.git\" \\\n\t\t\tgit rev-list --first-parent $range -- | wc -l\n\t\t\t)\n\t\t\ttotal_commits=\" ($(($total_commits + 0)))\"\n\t\t\t;;\n\t\tesac\n\n\t\tsha1_abbr_src=$(echo $sha1_src | cut -c1-7)\n\t\tsha1_abbr_dst=$(echo $sha1_dst | cut -c1-7)\n\t\tif test $status = T\n\t\tthen\n\t\t\tblob=\"$(gettext \"blob\")\"\n\t\t\tsubmodule=\"$(gettext \"submodule\")\"\n\t\t\tif test $mod_dst = 160000\n\t\t\tthen\n\t\t\t\techo \"* $display_name $sha1_abbr_src($blob)->$sha1_abbr_dst($submodule)$total_commits:\"\n\t\t\telse\n\t\t\t\techo \"* $display_name $sha1_abbr_src($submodule)->$sha1_abbr_dst($blob)$total_commits:\"\n\t\t\tfi\n\t\telse\n\t\t\techo \"* $display_name $sha1_abbr_src...$sha1_abbr_dst$total_commits:\"\n\t\tfi\n\t\tif test -n \"$errmsg\"\n\t\tthen\n\t\t\t# Don't give error msg for modification whose dst is not submodule\n\t\t\t# i.e. deleted or changed to blob\n\t\t\ttest $mod_dst = 160000 && echo \"$errmsg\"\n\t\telse\n\t\t\tif test $mod_src = 160000 -a $mod_dst = 160000\n\t\t\tthen\n\t\t\t\tlimit=\n\t\t\t\ttest $summary_limit -gt 0 && limit=\"-$summary_limit\"\n\t\t\t\tGIT_DIR=\"$name/.git\" \\\n\t\t\t\tgit log $limit --pretty='format:  %m %s' \\\n\t\t\t\t--first-parent $sha1_src...$sha1_dst\n\t\t\telif test $mod_dst = 160000\n\t\t\tthen\n\t\t\t\tGIT_DIR=\"$name/.git\" \\\n\t\t\t\tgit log --pretty='format:  > %s' -1 $sha1_dst\n\t\t\telse\n\t\t\t\tGIT_DIR=\"$name/.git\" \\\n\t\t\t\tgit log --pretty='format:  < %s' -1 $sha1_src\n\t\t\tfi\n\t\t\techo\n\t\tfi\n\t\techo\n\tdone |\n\tif test -n \"$for_status\"; then\n\t\tif [ -n \"$files\" ]; then\n\t\t\tgettextln \"Submodules changed but not updated:\" | git stripspace -c\n\t\telse\n\t\t\tgettextln \"Submodule changes to be committed:\" | git stripspace -c\n\t\tfi\n\t\tprintf \"\\n\" | git stripspace -c\n\t\tgit stripspace -c\n\telse\n\t\tcat\n\tfi\n}\n#\n# List all submodules, prefixed with:\n#  - submodule not initialized\n#  + different revision checked out\n#\n# If --cached was specified the revision in the index will be printed\n# instead of the currently checked out revision.\n#\n# $@ = requested paths (default to all)\n#\ncmd_status()\n{\n\t# parse $args after \"submodule ... status\".\n\twhile test $# -ne 0\n\tdo\n\t\tcase \"$1\" in\n\t\t-q|--quiet)\n\t\t\tGIT_QUIET=1\n\t\t\t;;\n\t\t--cached)\n\t\t\tcached=1\n\t\t\t;;\n\t\t--recursive)\n\t\t\trecursive=1\n\t\t\t;;\n\t\t--)\n\t\t\tshift\n\t\t\tbreak\n\t\t\t;;\n\t\t-*)\n\t\t\tusage\n\t\t\t;;\n\t\t*)\n\t\t\tbreak\n\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n\n\tmodule_list \"$@\" |\n\twhile read mode sha1 stage sm_path\n\tdo\n\t\tdie_if_unmatched \"$mode\"\n\t\tname=$(module_name \"$sm_path\") || exit\n\t\turl=$(git config submodule.\"$name\".url)\n\t\tdisplaypath=$(relative_path \"$prefix$sm_path\")\n\t\tif test \"$stage\" = U\n\t\tthen\n\t\t\tsay \"U$sha1 $displaypath\"\n\t\t\tcontinue\n\t\tfi\n\t\tif test -z \"$url\" || ! test -d \"$sm_path\"/.git -o -f \"$sm_path\"/.git\n\t\tthen\n\t\t\tsay \"-$sha1 $displaypath\"\n\t\t\tcontinue;\n\t\tfi\n\t\tif git diff-files --ignore-submodules=dirty --quiet -- \"$sm_path\"\n\t\tthen\n\t\t\tset_name_rev \"$sm_path\" \"$sha1\"\n\t\t\tsay \" $sha1 $displaypath$revname\"\n\t\telse\n\t\t\tif test -z \"$cached\"\n\t\t\tthen\n\t\t\t\tsha1=$(clear_local_git_env; cd \"$sm_path\" && git rev-parse --verify HEAD)\n\t\t\tfi\n\t\t\tset_name_rev \"$sm_path\" \"$sha1\"\n\t\t\tsay \"+$sha1 $displaypath$revname\"\n\t\tfi\n\n\t\tif test -n \"$recursive\"\n\t\tthen\n\t\t\t(\n\t\t\t\tprefix=\"$displaypath/\"\n\t\t\t\tclear_local_git_env\n\t\t\t\tcd \"$sm_path\" &&\n\t\t\t\teval cmd_status\n\t\t\t) ||\n\t\t\tdie \"$(eval_gettext \"Failed to recurse into submodule path '\\$sm_path'\")\"\n\t\tfi\n\tdone\n}\n#\n# Sync remote urls for submodules\n# This makes the value for remote.$remote.url match the value\n# specified in .gitmodules.\n#\ncmd_sync()\n{\n\twhile test $# -ne 0\n\tdo\n\t\tcase \"$1\" in\n\t\t-q|--quiet)\n\t\t\tGIT_QUIET=1\n\t\t\tshift\n\t\t\t;;\n\t\t--recursive)\n\t\t\trecursive=1\n\t\t\tshift\n\t\t\t;;\n\t\t--)\n\t\t\tshift\n\t\t\tbreak\n\t\t\t;;\n\t\t-*)\n\t\t\tusage\n\t\t\t;;\n\t\t*)\n\t\t\tbreak\n\t\t\t;;\n\t\tesac\n\tdone\n\tcd_to_toplevel\n\tmodule_list \"$@\" |\n\twhile read mode sha1 stage sm_path\n\tdo\n\t\tdie_if_unmatched \"$mode\"\n\t\tname=$(module_name \"$sm_path\")\n\t\turl=$(git config -f .gitmodules --get submodule.\"$name\".url)\n\n\t\t# Possibly a url relative to parent\n\t\tcase \"$url\" in\n\t\t./*|../*)\n\t\t\t# rewrite foo/bar as ../.. to find path from\n\t\t\t# submodule work tree to superproject work tree\n\t\t\tup_path=\"$(echo \"$sm_path\" | sed \"s/[^/][^/]*/../g\")\" &&\n\t\t\t# guarantee a trailing /\n\t\t\tup_path=${up_path%/}/ &&\n\t\t\t# path from submodule work tree to submodule origin repo\n\t\t\tsub_origin_url=$(resolve_relative_url \"$url\" \"$up_path\") &&\n\t\t\t# path from superproject work tree to submodule origin repo\n\t\t\tsuper_config_url=$(resolve_relative_url \"$url\") || exit\n\t\t\t;;\n\t\t*)\n\t\t\tsub_origin_url=\"$url\"\n\t\t\tsuper_config_url=\"$url\"\n\t\t\t;;\n\t\tesac\n\n\t\tif git config \"submodule.$name.url\" >/dev/null 2>/dev/null\n\t\tthen\n\t\t\tdisplaypath=$(relative_path \"$prefix$sm_path\")\n\t\t\tsay \"$(eval_gettext \"Synchronizing submodule url for '\\$displaypath'\")\"\n\t\t\tgit config submodule.\"$name\".url \"$super_config_url\"\n\n\t\t\tif test -e \"$sm_path\"/.git\n\t\t\tthen\n\t\t\t(\n\t\t\t\tclear_local_git_env\n\t\t\t\tcd \"$sm_path\"\n\t\t\t\tremote=$(get_default_remote)\n\t\t\t\tgit config remote.\"$remote\".url \"$sub_origin_url\"\n\n\t\t\t\tif test -n \"$recursive\"\n\t\t\t\tthen\n\t\t\t\t\tprefix=\"$prefix$sm_path/\"\n\t\t\t\t\teval cmd_sync\n\t\t\t\tfi\n\t\t\t)\n\t\t\tfi\n\t\tfi\n\tdone\n}\n\n# This loop parses the command line arguments to find the\n# subcommand name to dispatch.  Parsing of the subcommand specific\n# options are primarily done by the subcommand implementations.\n# Subcommand specific options such as --branch and --cached are\n# parsed here as well, for backward compatibility.\n\nwhile test $# != 0 && test -z \"$command\"\ndo\n\tcase \"$1\" in\n\tadd | foreach | init | deinit | update | status | summary | sync)\n\t\tcommand=$1\n\t\t;;\n\t-q|--quiet)\n\t\tGIT_QUIET=1\n\t\t;;\n\t-b|--branch)\n\t\tcase \"$2\" in\n\t\t'')\n\t\t\tusage\n\t\t\t;;\n\t\tesac\n\t\tbranch=\"$2\"; shift\n\t\t;;\n\t--cached)\n\t\tcached=\"$1\"\n\t\t;;\n\t--)\n\t\tbreak\n\t\t;;\n\t-*)\n\t\tusage\n\t\t;;\n\t*)\n\t\tbreak\n\t\t;;\n\tesac\n\tshift\ndone\n\n# No command word defaults to \"status\"\nif test -z \"$command\"\nthen\n    if test $# = 0\n    then\n\tcommand=status\n    else\n\tusage\n    fi\nfi\n\n# \"-b branch\" is accepted only by \"add\"\nif test -n \"$branch\" && test \"$command\" != add\nthen\n\tusage\nfi\n\n# \"--cached\" is accepted only by \"status\" and \"summary\"\nif test -n \"$cached\" && test \"$command\" != status -a \"$command\" != summary\nthen\n\tusage\nfi\n\n\"cmd_$command\" \"$@\"\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "004b21cd1535bce39b24fc3db079f92baba7c989",
  "sha1_ok": true,
  "size": 31968
}
