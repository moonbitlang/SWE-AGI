{
  "content": {
    "base64": "I2luY2x1ZGUgImdpdC1jb21wYXQtdXRpbC5oIgojaW5jbHVkZSAiY29uZmlnLmgiCiNpbmNsdWRlICJlbnZpcm9ubWVudC5oIgojaW5jbHVkZSAiZ2V0dGV4dC5oIgojaW5jbHVkZSAic3RyaW5nLWxpc3QuaCIKI2luY2x1ZGUgInJ1bi1jb21tYW5kLmgiCiNpbmNsdWRlICJjb21taXQuaCIKI2luY2x1ZGUgInRlbXBmaWxlLmgiCiNpbmNsdWRlICJ0cmFpbGVyLmgiCiNpbmNsdWRlICJsaXN0LmgiCi8qCiAqIENvcHlyaWdodCAoYykgMjAxMywgMjAxNCBDaHJpc3RpYW4gQ291ZGVyIDxjaHJpc2Nvb2xAdHV4ZmFtaWx5Lm9yZz4KICovCgpzdHJ1Y3QgY29uZl9pbmZvIHsKCWNoYXIgKm5hbWU7CgljaGFyICprZXk7CgljaGFyICpjb21tYW5kOwoJY2hhciAqY21kOwoJZW51bSB0cmFpbGVyX3doZXJlIHdoZXJlOwoJZW51bSB0cmFpbGVyX2lmX2V4aXN0cyBpZl9leGlzdHM7CgllbnVtIHRyYWlsZXJfaWZfbWlzc2luZyBpZl9taXNzaW5nOwp9OwoKc3RhdGljIHN0cnVjdCBjb25mX2luZm8gZGVmYXVsdF9jb25mX2luZm87CgpzdHJ1Y3QgdHJhaWxlcl9pdGVtIHsKCXN0cnVjdCBsaXN0X2hlYWQgbGlzdDsKCS8qCgkgKiBJZiB0aGlzIGlzIG5vdCBhIHRyYWlsZXIgbGluZSwgdGhlIGxpbmUgaXMgc3RvcmVkIGluIHZhbHVlCgkgKiAoZXhjbHVkaW5nIHRoZSB0ZXJtaW5hdGluZyBuZXdsaW5lKSBhbmQgdG9rZW4gaXMgTlVMTC4KCSAqLwoJY2hhciAqdG9rZW47CgljaGFyICp2YWx1ZTsKfTsKCnN0cnVjdCBhcmdfaXRlbSB7CglzdHJ1Y3QgbGlzdF9oZWFkIGxpc3Q7CgljaGFyICp0b2tlbjsKCWNoYXIgKnZhbHVlOwoJc3RydWN0IGNvbmZfaW5mbyBjb25mOwp9OwoKc3RhdGljIExJU1RfSEVBRChjb25mX2hlYWQpOwoKc3RhdGljIGNoYXIgKnNlcGFyYXRvcnMgPSAiOiI7CgpzdGF0aWMgaW50IGNvbmZpZ3VyZWQ7CgojZGVmaW5lIFRSQUlMRVJfQVJHX1NUUklORyAiJEFSRyIKCnN0YXRpYyBjb25zdCBjaGFyICpnaXRfZ2VuZXJhdGVkX3ByZWZpeGVzW10gPSB7CgkiU2lnbmVkLW9mZi1ieTogIiwKCSIoY2hlcnJ5IHBpY2tlZCBmcm9tIGNvbW1pdCAiLAoJTlVMTAp9OwoKLyogSXRlcmF0ZSBvdmVyIHRoZSBlbGVtZW50cyBvZiB0aGUgbGlzdC4gKi8KI2RlZmluZSBsaXN0X2Zvcl9lYWNoX2Rpcihwb3MsIGhlYWQsIGlzX3JldmVyc2UpIFwKCWZvciAocG9zID0gaXNfcmV2ZXJzZSA/IChoZWFkKS0+cHJldiA6IChoZWFkKS0+bmV4dDsgXAoJCXBvcyAhPSAoaGVhZCk7IFwKCQlwb3MgPSBpc19yZXZlcnNlID8gcG9zLT5wcmV2IDogcG9zLT5uZXh0KQoKc3RhdGljIGludCBhZnRlcl9vcl9lbmQoZW51bSB0cmFpbGVyX3doZXJlIHdoZXJlKQp7CglyZXR1cm4gKHdoZXJlID09IFdIRVJFX0FGVEVSKSB8fCAod2hlcmUgPT0gV0hFUkVfRU5EKTsKfQoKLyoKICogUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIHN0cmluZyBub3QgaW5jbHVkaW5nIGFueSBmaW5hbAogKiBwdW5jdHVhdGlvbi4gRS5nLiwgdGhlIGlucHV0ICJTaWduZWQtb2ZmLWJ5OiIgd291bGQgcmV0dXJuCiAqIDEzLCBzdHJpcHBpbmcgdGhlIHRyYWlsaW5nIHB1bmN0dWF0aW9uIGJ1dCByZXRhaW5pbmcKICogaW50ZXJuYWwgcHVuY3R1YXRpb24uCiAqLwpzdGF0aWMgc2l6ZV90IHRva2VuX2xlbl93aXRob3V0X3NlcGFyYXRvcihjb25zdCBjaGFyICp0b2tlbiwgc2l6ZV90IGxlbikKewoJd2hpbGUgKGxlbiA+IDAgJiYgIWlzYWxudW0odG9rZW5bbGVuIC0gMV0pKQoJCWxlbi0tOwoJcmV0dXJuIGxlbjsKfQoKc3RhdGljIGludCBzYW1lX3Rva2VuKHN0cnVjdCB0cmFpbGVyX2l0ZW0gKmEsIHN0cnVjdCBhcmdfaXRlbSAqYikKewoJc2l6ZV90IGFfbGVuLCBiX2xlbiwgbWluX2xlbjsKCglpZiAoIWEtPnRva2VuKQoJCXJldHVybiAwOwoKCWFfbGVuID0gdG9rZW5fbGVuX3dpdGhvdXRfc2VwYXJhdG9yKGEtPnRva2VuLCBzdHJsZW4oYS0+dG9rZW4pKTsKCWJfbGVuID0gdG9rZW5fbGVuX3dpdGhvdXRfc2VwYXJhdG9yKGItPnRva2VuLCBzdHJsZW4oYi0+dG9rZW4pKTsKCW1pbl9sZW4gPSAoYV9sZW4gPiBiX2xlbikgPyBiX2xlbiA6IGFfbGVuOwoKCXJldHVybiAhc3RybmNhc2VjbXAoYS0+dG9rZW4sIGItPnRva2VuLCBtaW5fbGVuKTsKfQoKc3RhdGljIGludCBzYW1lX3ZhbHVlKHN0cnVjdCB0cmFpbGVyX2l0ZW0gKmEsIHN0cnVjdCBhcmdfaXRlbSAqYikKewoJcmV0dXJuICFzdHJjYXNlY21wKGEtPnZhbHVlLCBiLT52YWx1ZSk7Cn0KCnN0YXRpYyBpbnQgc2FtZV90cmFpbGVyKHN0cnVjdCB0cmFpbGVyX2l0ZW0gKmEsIHN0cnVjdCBhcmdfaXRlbSAqYikKewoJcmV0dXJuIHNhbWVfdG9rZW4oYSwgYikgJiYgc2FtZV92YWx1ZShhLCBiKTsKfQoKc3RhdGljIGlubGluZSBpbnQgaXNfYmxhbmtfbGluZShjb25zdCBjaGFyICpzdHIpCnsKCWNvbnN0IGNoYXIgKnMgPSBzdHI7Cgl3aGlsZSAoKnMgJiYgKnMgIT0gJ1xuJyAmJiBpc3NwYWNlKCpzKSkKCQlzKys7CglyZXR1cm4gISpzIHx8ICpzID09ICdcbic7Cn0KCnN0YXRpYyBpbmxpbmUgdm9pZCBzdHJidWZfcmVwbGFjZShzdHJ1Y3Qgc3RyYnVmICpzYiwgY29uc3QgY2hhciAqYSwgY29uc3QgY2hhciAqYikKewoJY29uc3QgY2hhciAqcHRyID0gc3Ryc3RyKHNiLT5idWYsIGEpOwoJaWYgKHB0cikKCQlzdHJidWZfc3BsaWNlKHNiLCBwdHIgLSBzYi0+YnVmLCBzdHJsZW4oYSksIGIsIHN0cmxlbihiKSk7Cn0KCnN0YXRpYyB2b2lkIGZyZWVfdHJhaWxlcl9pdGVtKHN0cnVjdCB0cmFpbGVyX2l0ZW0gKml0ZW0pCnsKCWZyZWUoaXRlbS0+dG9rZW4pOwoJZnJlZShpdGVtLT52YWx1ZSk7CglmcmVlKGl0ZW0pOwp9CgpzdGF0aWMgdm9pZCBmcmVlX2FyZ19pdGVtKHN0cnVjdCBhcmdfaXRlbSAqaXRlbSkKewoJZnJlZShpdGVtLT5jb25mLm5hbWUpOwoJZnJlZShpdGVtLT5jb25mLmtleSk7CglmcmVlKGl0ZW0tPmNvbmYuY29tbWFuZCk7CglmcmVlKGl0ZW0tPmNvbmYuY21kKTsKCWZyZWUoaXRlbS0+dG9rZW4pOwoJZnJlZShpdGVtLT52YWx1ZSk7CglmcmVlKGl0ZW0pOwp9CgpzdGF0aWMgY2hhciBsYXN0X25vbl9zcGFjZV9jaGFyKGNvbnN0IGNoYXIgKnMpCnsKCWludCBpOwoJZm9yIChpID0gc3RybGVuKHMpIC0gMTsgaSA+PSAwOyBpLS0pCgkJaWYgKCFpc3NwYWNlKHNbaV0pKQoJCQlyZXR1cm4gc1tpXTsKCXJldHVybiAnXDAnOwp9CgpzdGF0aWMgdm9pZCBwcmludF90b2tfdmFsKEZJTEUgKm91dGZpbGUsIGNvbnN0IGNoYXIgKnRvaywgY29uc3QgY2hhciAqdmFsKQp7CgljaGFyIGM7CgoJaWYgKCF0b2spIHsKCQlmcHJpbnRmKG91dGZpbGUsICIlc1xuIiwgdmFsKTsKCQlyZXR1cm47Cgl9CgoJYyA9IGxhc3Rfbm9uX3NwYWNlX2NoYXIodG9rKTsKCWlmICghYykKCQlyZXR1cm47CglpZiAoc3RyY2hyKHNlcGFyYXRvcnMsIGMpKQoJCWZwcmludGYob3V0ZmlsZSwgIiVzJXNcbiIsIHRvaywgdmFsKTsKCWVsc2UKCQlmcHJpbnRmKG91dGZpbGUsICIlcyVjICVzXG4iLCB0b2ssIHNlcGFyYXRvcnNbMF0sIHZhbCk7Cn0KCnN0YXRpYyB2b2lkIHByaW50X2FsbChGSUxFICpvdXRmaWxlLCBzdHJ1Y3QgbGlzdF9oZWFkICpoZWFkLAoJCSAgICAgIGNvbnN0IHN0cnVjdCBwcm9jZXNzX3RyYWlsZXJfb3B0aW9ucyAqb3B0cykKewoJc3RydWN0IGxpc3RfaGVhZCAqcG9zOwoJc3RydWN0IHRyYWlsZXJfaXRlbSAqaXRlbTsKCWxpc3RfZm9yX2VhY2gocG9zLCBoZWFkKSB7CgkJaXRlbSA9IGxpc3RfZW50cnkocG9zLCBzdHJ1Y3QgdHJhaWxlcl9pdGVtLCBsaXN0KTsKCQlpZiAoKCFvcHRzLT50cmltX2VtcHR5IHx8IHN0cmxlbihpdGVtLT52YWx1ZSkgPiAwKSAmJgoJCSAgICAoIW9wdHMtPm9ubHlfdHJhaWxlcnMgfHwgaXRlbS0+dG9rZW4pKQoJCQlwcmludF90b2tfdmFsKG91dGZpbGUsIGl0ZW0tPnRva2VuLCBpdGVtLT52YWx1ZSk7Cgl9Cn0KCnN0YXRpYyBzdHJ1Y3QgdHJhaWxlcl9pdGVtICp0cmFpbGVyX2Zyb21fYXJnKHN0cnVjdCBhcmdfaXRlbSAqYXJnX3RvaykKewoJc3RydWN0IHRyYWlsZXJfaXRlbSAqbmV3X2l0ZW0gPSB4Y2FsbG9jKDEsIHNpemVvZigqbmV3X2l0ZW0pKTsKCW5ld19pdGVtLT50b2tlbiA9IGFyZ190b2stPnRva2VuOwoJbmV3X2l0ZW0tPnZhbHVlID0gYXJnX3Rvay0+dmFsdWU7CglhcmdfdG9rLT50b2tlbiA9IGFyZ190b2stPnZhbHVlID0gTlVMTDsKCWZyZWVfYXJnX2l0ZW0oYXJnX3Rvayk7CglyZXR1cm4gbmV3X2l0ZW07Cn0KCnN0YXRpYyB2b2lkIGFkZF9hcmdfdG9faW5wdXRfbGlzdChzdHJ1Y3QgdHJhaWxlcl9pdGVtICpvbl90b2ssCgkJCQkgIHN0cnVjdCBhcmdfaXRlbSAqYXJnX3RvaykKewoJaW50IGFvZSA9IGFmdGVyX29yX2VuZChhcmdfdG9rLT5jb25mLndoZXJlKTsKCXN0cnVjdCB0cmFpbGVyX2l0ZW0gKnRvX2FkZCA9IHRyYWlsZXJfZnJvbV9hcmcoYXJnX3Rvayk7CglpZiAoYW9lKQoJCWxpc3RfYWRkKCZ0b19hZGQtPmxpc3QsICZvbl90b2stPmxpc3QpOwoJZWxzZQoJCWxpc3RfYWRkX3RhaWwoJnRvX2FkZC0+bGlzdCwgJm9uX3Rvay0+bGlzdCk7Cn0KCnN0YXRpYyBpbnQgY2hlY2tfaWZfZGlmZmVyZW50KHN0cnVjdCB0cmFpbGVyX2l0ZW0gKmluX3RvaywKCQkJICAgICAgc3RydWN0IGFyZ19pdGVtICphcmdfdG9rLAoJCQkgICAgICBpbnQgY2hlY2tfYWxsLAoJCQkgICAgICBzdHJ1Y3QgbGlzdF9oZWFkICpoZWFkKQp7CgllbnVtIHRyYWlsZXJfd2hlcmUgd2hlcmUgPSBhcmdfdG9rLT5jb25mLndoZXJlOwoJc3RydWN0IGxpc3RfaGVhZCAqbmV4dF9oZWFkOwoJZG8gewoJCWlmIChzYW1lX3RyYWlsZXIoaW5fdG9rLCBhcmdfdG9rKSkKCQkJcmV0dXJuIDA7CgkJLyoKCQkgKiBpZiB3ZSB3YW50IHRvIGFkZCBhIHRyYWlsZXIgYWZ0ZXIgYW5vdGhlciBvbmUsCgkJICogd2UgaGF2ZSB0byBjaGVjayB0aG9zZSBiZWZvcmUgdGhpcyBvbmUKCQkgKi8KCQluZXh0X2hlYWQgPSBhZnRlcl9vcl9lbmQod2hlcmUpID8gaW5fdG9rLT5saXN0LnByZXYKCQkJCQkJOiBpbl90b2stPmxpc3QubmV4dDsKCQlpZiAobmV4dF9oZWFkID09IGhlYWQpCgkJCWJyZWFrOwoJCWluX3RvayA9IGxpc3RfZW50cnkobmV4dF9oZWFkLCBzdHJ1Y3QgdHJhaWxlcl9pdGVtLCBsaXN0KTsKCX0gd2hpbGUgKGNoZWNrX2FsbCk7CglyZXR1cm4gMTsKfQoKc3RhdGljIGNoYXIgKmFwcGx5X2NvbW1hbmQoc3RydWN0IGNvbmZfaW5mbyAqY29uZiwgY29uc3QgY2hhciAqYXJnKQp7CglzdHJ1Y3Qgc3RyYnVmIGNtZCA9IFNUUkJVRl9JTklUOwoJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCXN0cnVjdCBjaGlsZF9wcm9jZXNzIGNwID0gQ0hJTERfUFJPQ0VTU19JTklUOwoJY2hhciAqcmVzdWx0OwoKCWlmIChjb25mLT5jbWQpIHsKCQlzdHJidWZfYWRkc3RyKCZjbWQsIGNvbmYtPmNtZCk7CgkJc3RydmVjX3B1c2goJmNwLmFyZ3MsIGNtZC5idWYpOwoJCWlmIChhcmcpCgkJCXN0cnZlY19wdXNoKCZjcC5hcmdzLCBhcmcpOwoJfSBlbHNlIGlmIChjb25mLT5jb21tYW5kKSB7CgkJc3RyYnVmX2FkZHN0cigmY21kLCBjb25mLT5jb21tYW5kKTsKCQlpZiAoYXJnKQoJCQlzdHJidWZfcmVwbGFjZSgmY21kLCBUUkFJTEVSX0FSR19TVFJJTkcsIGFyZyk7CgkJc3RydmVjX3B1c2goJmNwLmFyZ3MsIGNtZC5idWYpOwoJfQoJc3RydmVjX3B1c2h2KCZjcC5lbnYsIChjb25zdCBjaGFyICoqKWxvY2FsX3JlcG9fZW52KTsKCWNwLm5vX3N0ZGluID0gMTsKCWNwLnVzZV9zaGVsbCA9IDE7CgoJaWYgKGNhcHR1cmVfY29tbWFuZCgmY3AsICZidWYsIDEwMjQpKSB7CgkJZXJyb3IoXygicnVubmluZyB0cmFpbGVyIGNvbW1hbmQgJyVzJyBmYWlsZWQiKSwgY21kLmJ1Zik7CgkJc3RyYnVmX3JlbGVhc2UoJmJ1Zik7CgkJcmVzdWx0ID0geHN0cmR1cCgiIik7Cgl9IGVsc2UgewoJCXN0cmJ1Zl90cmltKCZidWYpOwoJCXJlc3VsdCA9IHN0cmJ1Zl9kZXRhY2goJmJ1ZiwgTlVMTCk7Cgl9CgoJc3RyYnVmX3JlbGVhc2UoJmNtZCk7CglyZXR1cm4gcmVzdWx0Owp9CgpzdGF0aWMgdm9pZCBhcHBseV9pdGVtX2NvbW1hbmQoc3RydWN0IHRyYWlsZXJfaXRlbSAqaW5fdG9rLCBzdHJ1Y3QgYXJnX2l0ZW0gKmFyZ190b2spCnsKCWlmIChhcmdfdG9rLT5jb25mLmNvbW1hbmQgfHwgYXJnX3Rvay0+Y29uZi5jbWQpIHsKCQljb25zdCBjaGFyICphcmc7CgkJaWYgKGFyZ190b2stPnZhbHVlICYmIGFyZ190b2stPnZhbHVlWzBdKSB7CgkJCWFyZyA9IGFyZ190b2stPnZhbHVlOwoJCX0gZWxzZSB7CgkJCWlmIChpbl90b2sgJiYgaW5fdG9rLT52YWx1ZSkKCQkJCWFyZyA9IHhzdHJkdXAoaW5fdG9rLT52YWx1ZSk7CgkJCWVsc2UKCQkJCWFyZyA9IHhzdHJkdXAoIiIpOwoJCX0KCQlhcmdfdG9rLT52YWx1ZSA9IGFwcGx5X2NvbW1hbmQoJmFyZ190b2stPmNvbmYsIGFyZyk7CgkJZnJlZSgoY2hhciAqKWFyZyk7Cgl9Cn0KCnN0YXRpYyB2b2lkIGFwcGx5X2FyZ19pZl9leGlzdHMoc3RydWN0IHRyYWlsZXJfaXRlbSAqaW5fdG9rLAoJCQkJc3RydWN0IGFyZ19pdGVtICphcmdfdG9rLAoJCQkJc3RydWN0IHRyYWlsZXJfaXRlbSAqb25fdG9rLAoJCQkJc3RydWN0IGxpc3RfaGVhZCAqaGVhZCkKewoJc3dpdGNoIChhcmdfdG9rLT5jb25mLmlmX2V4aXN0cykgewoJY2FzZSBFWElTVFNfRE9fTk9USElORzoKCQlmcmVlX2FyZ19pdGVtKGFyZ190b2spOwoJCWJyZWFrOwoJY2FzZSBFWElTVFNfUkVQTEFDRToKCQlhcHBseV9pdGVtX2NvbW1hbmQoaW5fdG9rLCBhcmdfdG9rKTsKCQlhZGRfYXJnX3RvX2lucHV0X2xpc3Qob25fdG9rLCBhcmdfdG9rKTsKCQlsaXN0X2RlbCgmaW5fdG9rLT5saXN0KTsKCQlmcmVlX3RyYWlsZXJfaXRlbShpbl90b2spOwoJCWJyZWFrOwoJY2FzZSBFWElTVFNfQUREOgoJCWFwcGx5X2l0ZW1fY29tbWFuZChpbl90b2ssIGFyZ190b2spOwoJCWFkZF9hcmdfdG9faW5wdXRfbGlzdChvbl90b2ssIGFyZ190b2spOwoJCWJyZWFrOwoJY2FzZSBFWElTVFNfQUREX0lGX0RJRkZFUkVOVDoKCQlhcHBseV9pdGVtX2NvbW1hbmQoaW5fdG9rLCBhcmdfdG9rKTsKCQlpZiAoY2hlY2tfaWZfZGlmZmVyZW50KGluX3RvaywgYXJnX3RvaywgMSwgaGVhZCkpCgkJCWFkZF9hcmdfdG9faW5wdXRfbGlzdChvbl90b2ssIGFyZ190b2spOwoJCWVsc2UKCQkJZnJlZV9hcmdfaXRlbShhcmdfdG9rKTsKCQlicmVhazsKCWNhc2UgRVhJU1RTX0FERF9JRl9ESUZGRVJFTlRfTkVJR0hCT1I6CgkJYXBwbHlfaXRlbV9jb21tYW5kKGluX3RvaywgYXJnX3Rvayk7CgkJaWYgKGNoZWNrX2lmX2RpZmZlcmVudChvbl90b2ssIGFyZ190b2ssIDAsIGhlYWQpKQoJCQlhZGRfYXJnX3RvX2lucHV0X2xpc3Qob25fdG9rLCBhcmdfdG9rKTsKCQllbHNlCgkJCWZyZWVfYXJnX2l0ZW0oYXJnX3Rvayk7CgkJYnJlYWs7CglkZWZhdWx0OgoJCUJVRygidHJhaWxlci5jOiB1bmhhbmRsZWQgdmFsdWUgJWQiLAoJCSAgICBhcmdfdG9rLT5jb25mLmlmX2V4aXN0cyk7Cgl9Cn0KCnN0YXRpYyB2b2lkIGFwcGx5X2FyZ19pZl9taXNzaW5nKHN0cnVjdCBsaXN0X2hlYWQgKmhlYWQsCgkJCQkgc3RydWN0IGFyZ19pdGVtICphcmdfdG9rKQp7CgllbnVtIHRyYWlsZXJfd2hlcmUgd2hlcmU7CglzdHJ1Y3QgdHJhaWxlcl9pdGVtICp0b19hZGQ7CgoJc3dpdGNoIChhcmdfdG9rLT5jb25mLmlmX21pc3NpbmcpIHsKCWNhc2UgTUlTU0lOR19ET19OT1RISU5HOgoJCWZyZWVfYXJnX2l0ZW0oYXJnX3Rvayk7CgkJYnJlYWs7CgljYXNlIE1JU1NJTkdfQUREOgoJCXdoZXJlID0gYXJnX3Rvay0+Y29uZi53aGVyZTsKCQlhcHBseV9pdGVtX2NvbW1hbmQoTlVMTCwgYXJnX3Rvayk7CgkJdG9fYWRkID0gdHJhaWxlcl9mcm9tX2FyZyhhcmdfdG9rKTsKCQlpZiAoYWZ0ZXJfb3JfZW5kKHdoZXJlKSkKCQkJbGlzdF9hZGRfdGFpbCgmdG9fYWRkLT5saXN0LCBoZWFkKTsKCQllbHNlCgkJCWxpc3RfYWRkKCZ0b19hZGQtPmxpc3QsIGhlYWQpOwoJCWJyZWFrOwoJZGVmYXVsdDoKCQlCVUcoInRyYWlsZXIuYzogdW5oYW5kbGVkIHZhbHVlICVkIiwKCQkgICAgYXJnX3Rvay0+Y29uZi5pZl9taXNzaW5nKTsKCX0KfQoKc3RhdGljIGludCBmaW5kX3NhbWVfYW5kX2FwcGx5X2FyZyhzdHJ1Y3QgbGlzdF9oZWFkICpoZWFkLAoJCQkJICAgc3RydWN0IGFyZ19pdGVtICphcmdfdG9rKQp7CglzdHJ1Y3QgbGlzdF9oZWFkICpwb3M7CglzdHJ1Y3QgdHJhaWxlcl9pdGVtICppbl90b2s7CglzdHJ1Y3QgdHJhaWxlcl9pdGVtICpvbl90b2s7CgoJZW51bSB0cmFpbGVyX3doZXJlIHdoZXJlID0gYXJnX3Rvay0+Y29uZi53aGVyZTsKCWludCBtaWRkbGUgPSAod2hlcmUgPT0gV0hFUkVfQUZURVIpIHx8ICh3aGVyZSA9PSBXSEVSRV9CRUZPUkUpOwoJaW50IGJhY2t3YXJkcyA9IGFmdGVyX29yX2VuZCh3aGVyZSk7CglzdHJ1Y3QgdHJhaWxlcl9pdGVtICpzdGFydF90b2s7CgoJaWYgKGxpc3RfZW1wdHkoaGVhZCkpCgkJcmV0dXJuIDA7CgoJc3RhcnRfdG9rID0gbGlzdF9lbnRyeShiYWNrd2FyZHMgPyBoZWFkLT5wcmV2IDogaGVhZC0+bmV4dCwKCQkJICAgICAgIHN0cnVjdCB0cmFpbGVyX2l0ZW0sCgkJCSAgICAgICBsaXN0KTsKCglsaXN0X2Zvcl9lYWNoX2Rpcihwb3MsIGhlYWQsIGJhY2t3YXJkcykgewoJCWluX3RvayA9IGxpc3RfZW50cnkocG9zLCBzdHJ1Y3QgdHJhaWxlcl9pdGVtLCBsaXN0KTsKCQlpZiAoIXNhbWVfdG9rZW4oaW5fdG9rLCBhcmdfdG9rKSkKCQkJY29udGludWU7CgkJb25fdG9rID0gbWlkZGxlID8gaW5fdG9rIDogc3RhcnRfdG9rOwoJCWFwcGx5X2FyZ19pZl9leGlzdHMoaW5fdG9rLCBhcmdfdG9rLCBvbl90b2ssIGhlYWQpOwoJCXJldHVybiAxOwoJfQoJcmV0dXJuIDA7Cn0KCnN0YXRpYyB2b2lkIHByb2Nlc3NfdHJhaWxlcnNfbGlzdHMoc3RydWN0IGxpc3RfaGVhZCAqaGVhZCwKCQkJCSAgIHN0cnVjdCBsaXN0X2hlYWQgKmFyZ19oZWFkKQp7CglzdHJ1Y3QgbGlzdF9oZWFkICpwb3MsICpwOwoJc3RydWN0IGFyZ19pdGVtICphcmdfdG9rOwoKCWxpc3RfZm9yX2VhY2hfc2FmZShwb3MsIHAsIGFyZ19oZWFkKSB7CgkJaW50IGFwcGxpZWQgPSAwOwoJCWFyZ190b2sgPSBsaXN0X2VudHJ5KHBvcywgc3RydWN0IGFyZ19pdGVtLCBsaXN0KTsKCgkJbGlzdF9kZWwocG9zKTsKCgkJYXBwbGllZCA9IGZpbmRfc2FtZV9hbmRfYXBwbHlfYXJnKGhlYWQsIGFyZ190b2spOwoKCQlpZiAoIWFwcGxpZWQpCgkJCWFwcGx5X2FyZ19pZl9taXNzaW5nKGhlYWQsIGFyZ190b2spOwoJfQp9CgppbnQgdHJhaWxlcl9zZXRfd2hlcmUoZW51bSB0cmFpbGVyX3doZXJlICppdGVtLCBjb25zdCBjaGFyICp2YWx1ZSkKewoJaWYgKCF2YWx1ZSkKCQkqaXRlbSA9IFdIRVJFX0RFRkFVTFQ7CgllbHNlIGlmICghc3RyY2FzZWNtcCgiYWZ0ZXIiLCB2YWx1ZSkpCgkJKml0ZW0gPSBXSEVSRV9BRlRFUjsKCWVsc2UgaWYgKCFzdHJjYXNlY21wKCJiZWZvcmUiLCB2YWx1ZSkpCgkJKml0ZW0gPSBXSEVSRV9CRUZPUkU7CgllbHNlIGlmICghc3RyY2FzZWNtcCgiZW5kIiwgdmFsdWUpKQoJCSppdGVtID0gV0hFUkVfRU5EOwoJZWxzZSBpZiAoIXN0cmNhc2VjbXAoInN0YXJ0IiwgdmFsdWUpKQoJCSppdGVtID0gV0hFUkVfU1RBUlQ7CgllbHNlCgkJcmV0dXJuIC0xOwoJcmV0dXJuIDA7Cn0KCmludCB0cmFpbGVyX3NldF9pZl9leGlzdHMoZW51bSB0cmFpbGVyX2lmX2V4aXN0cyAqaXRlbSwgY29uc3QgY2hhciAqdmFsdWUpCnsKCWlmICghdmFsdWUpCgkJKml0ZW0gPSBFWElTVFNfREVGQVVMVDsKCWVsc2UgaWYgKCFzdHJjYXNlY21wKCJhZGRJZkRpZmZlcmVudCIsIHZhbHVlKSkKCQkqaXRlbSA9IEVYSVNUU19BRERfSUZfRElGRkVSRU5UOwoJZWxzZSBpZiAoIXN0cmNhc2VjbXAoImFkZElmRGlmZmVyZW50TmVpZ2hib3IiLCB2YWx1ZSkpCgkJKml0ZW0gPSBFWElTVFNfQUREX0lGX0RJRkZFUkVOVF9ORUlHSEJPUjsKCWVsc2UgaWYgKCFzdHJjYXNlY21wKCJhZGQiLCB2YWx1ZSkpCgkJKml0ZW0gPSBFWElTVFNfQUREOwoJZWxzZSBpZiAoIXN0cmNhc2VjbXAoInJlcGxhY2UiLCB2YWx1ZSkpCgkJKml0ZW0gPSBFWElTVFNfUkVQTEFDRTsKCWVsc2UgaWYgKCFzdHJjYXNlY21wKCJkb05vdGhpbmciLCB2YWx1ZSkpCgkJKml0ZW0gPSBFWElTVFNfRE9fTk9USElORzsKCWVsc2UKCQlyZXR1cm4gLTE7CglyZXR1cm4gMDsKfQoKaW50IHRyYWlsZXJfc2V0X2lmX21pc3NpbmcoZW51bSB0cmFpbGVyX2lmX21pc3NpbmcgKml0ZW0sIGNvbnN0IGNoYXIgKnZhbHVlKQp7CglpZiAoIXZhbHVlKQoJCSppdGVtID0gTUlTU0lOR19ERUZBVUxUOwoJZWxzZSBpZiAoIXN0cmNhc2VjbXAoImRvTm90aGluZyIsIHZhbHVlKSkKCQkqaXRlbSA9IE1JU1NJTkdfRE9fTk9USElORzsKCWVsc2UgaWYgKCFzdHJjYXNlY21wKCJhZGQiLCB2YWx1ZSkpCgkJKml0ZW0gPSBNSVNTSU5HX0FERDsKCWVsc2UKCQlyZXR1cm4gLTE7CglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgZHVwbGljYXRlX2NvbmYoc3RydWN0IGNvbmZfaW5mbyAqZHN0LCBjb25zdCBzdHJ1Y3QgY29uZl9pbmZvICpzcmMpCnsKCSpkc3QgPSAqc3JjOwoJZHN0LT5uYW1lID0geHN0cmR1cF9vcl9udWxsKHNyYy0+bmFtZSk7Cglkc3QtPmtleSA9IHhzdHJkdXBfb3JfbnVsbChzcmMtPmtleSk7Cglkc3QtPmNvbW1hbmQgPSB4c3RyZHVwX29yX251bGwoc3JjLT5jb21tYW5kKTsKCWRzdC0+Y21kID0geHN0cmR1cF9vcl9udWxsKHNyYy0+Y21kKTsKfQoKc3RhdGljIHN0cnVjdCBhcmdfaXRlbSAqZ2V0X2NvbmZfaXRlbShjb25zdCBjaGFyICpuYW1lKQp7CglzdHJ1Y3QgbGlzdF9oZWFkICpwb3M7CglzdHJ1Y3QgYXJnX2l0ZW0gKml0ZW07CgoJLyogTG9vayB1cCBpdGVtIHdpdGggc2FtZSBuYW1lICovCglsaXN0X2Zvcl9lYWNoKHBvcywgJmNvbmZfaGVhZCkgewoJCWl0ZW0gPSBsaXN0X2VudHJ5KHBvcywgc3RydWN0IGFyZ19pdGVtLCBsaXN0KTsKCQlpZiAoIXN0cmNhc2VjbXAoaXRlbS0+Y29uZi5uYW1lLCBuYW1lKSkKCQkJcmV0dXJuIGl0ZW07Cgl9CgoJLyogSXRlbSBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0cywgY3JlYXRlIGl0ICovCglDQUxMT0NfQVJSQVkoaXRlbSwgMSk7CglkdXBsaWNhdGVfY29uZigmaXRlbS0+Y29uZiwgJmRlZmF1bHRfY29uZl9pbmZvKTsKCWl0ZW0tPmNvbmYubmFtZSA9IHhzdHJkdXAobmFtZSk7CgoJbGlzdF9hZGRfdGFpbCgmaXRlbS0+bGlzdCwgJmNvbmZfaGVhZCk7CgoJcmV0dXJuIGl0ZW07Cn0KCmVudW0gdHJhaWxlcl9pbmZvX3R5cGUgeyBUUkFJTEVSX0tFWSwgVFJBSUxFUl9DT01NQU5ELCBUUkFJTEVSX0NNRCwKCQkJVFJBSUxFUl9XSEVSRSwgVFJBSUxFUl9JRl9FWElTVFMsIFRSQUlMRVJfSUZfTUlTU0lORyB9OwoKc3RhdGljIHN0cnVjdCB7Cgljb25zdCBjaGFyICpuYW1lOwoJZW51bSB0cmFpbGVyX2luZm9fdHlwZSB0eXBlOwp9IHRyYWlsZXJfY29uZmlnX2l0ZW1zW10gPSB7Cgl7ICJrZXkiLCBUUkFJTEVSX0tFWSB9LAoJeyAiY29tbWFuZCIsIFRSQUlMRVJfQ09NTUFORCB9LAoJeyAiY21kIiwgVFJBSUxFUl9DTUQgfSwKCXsgIndoZXJlIiwgVFJBSUxFUl9XSEVSRSB9LAoJeyAiaWZleGlzdHMiLCBUUkFJTEVSX0lGX0VYSVNUUyB9LAoJeyAiaWZtaXNzaW5nIiwgVFJBSUxFUl9JRl9NSVNTSU5HIH0KfTsKCnN0YXRpYyBpbnQgZ2l0X3RyYWlsZXJfZGVmYXVsdF9jb25maWcoY29uc3QgY2hhciAqY29uZl9rZXksIGNvbnN0IGNoYXIgKnZhbHVlLAoJCQkJICAgICAgY29uc3Qgc3RydWN0IGNvbmZpZ19jb250ZXh0ICpjdHggVU5VU0VELAoJCQkJICAgICAgdm9pZCAqY2IgVU5VU0VEKQp7Cgljb25zdCBjaGFyICp0cmFpbGVyX2l0ZW0sICp2YXJpYWJsZV9uYW1lOwoKCWlmICghc2tpcF9wcmVmaXgoY29uZl9rZXksICJ0cmFpbGVyLiIsICZ0cmFpbGVyX2l0ZW0pKQoJCXJldHVybiAwOwoKCXZhcmlhYmxlX25hbWUgPSBzdHJyY2hyKHRyYWlsZXJfaXRlbSwgJy4nKTsKCWlmICghdmFyaWFibGVfbmFtZSkgewoJCWlmICghc3RyY21wKHRyYWlsZXJfaXRlbSwgIndoZXJlIikpIHsKCQkJaWYgKHRyYWlsZXJfc2V0X3doZXJlKCZkZWZhdWx0X2NvbmZfaW5mby53aGVyZSwKCQkJCQkgICAgICB2YWx1ZSkgPCAwKQoJCQkJd2FybmluZyhfKCJ1bmtub3duIHZhbHVlICclcycgZm9yIGtleSAnJXMnIiksCgkJCQkJdmFsdWUsIGNvbmZfa2V5KTsKCQl9IGVsc2UgaWYgKCFzdHJjbXAodHJhaWxlcl9pdGVtLCAiaWZleGlzdHMiKSkgewoJCQlpZiAodHJhaWxlcl9zZXRfaWZfZXhpc3RzKCZkZWZhdWx0X2NvbmZfaW5mby5pZl9leGlzdHMsCgkJCQkJCSAgdmFsdWUpIDwgMCkKCQkJCXdhcm5pbmcoXygidW5rbm93biB2YWx1ZSAnJXMnIGZvciBrZXkgJyVzJyIpLAoJCQkJCXZhbHVlLCBjb25mX2tleSk7CgkJfSBlbHNlIGlmICghc3RyY21wKHRyYWlsZXJfaXRlbSwgImlmbWlzc2luZyIpKSB7CgkJCWlmICh0cmFpbGVyX3NldF9pZl9taXNzaW5nKCZkZWZhdWx0X2NvbmZfaW5mby5pZl9taXNzaW5nLAoJCQkJCQkgICB2YWx1ZSkgPCAwKQoJCQkJd2FybmluZyhfKCJ1bmtub3duIHZhbHVlICclcycgZm9yIGtleSAnJXMnIiksCgkJCQkJdmFsdWUsIGNvbmZfa2V5KTsKCQl9IGVsc2UgaWYgKCFzdHJjbXAodHJhaWxlcl9pdGVtLCAic2VwYXJhdG9ycyIpKSB7CgkJCXNlcGFyYXRvcnMgPSB4c3RyZHVwKHZhbHVlKTsKCQl9Cgl9CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBnaXRfdHJhaWxlcl9jb25maWcoY29uc3QgY2hhciAqY29uZl9rZXksIGNvbnN0IGNoYXIgKnZhbHVlLAoJCQkgICAgICBjb25zdCBzdHJ1Y3QgY29uZmlnX2NvbnRleHQgKmN0eCBVTlVTRUQsCgkJCSAgICAgIHZvaWQgKmNiIFVOVVNFRCkKewoJY29uc3QgY2hhciAqdHJhaWxlcl9pdGVtLCAqdmFyaWFibGVfbmFtZTsKCXN0cnVjdCBhcmdfaXRlbSAqaXRlbTsKCXN0cnVjdCBjb25mX2luZm8gKmNvbmY7CgljaGFyICpuYW1lID0gTlVMTDsKCWVudW0gdHJhaWxlcl9pbmZvX3R5cGUgdHlwZTsKCWludCBpOwoKCWlmICghc2tpcF9wcmVmaXgoY29uZl9rZXksICJ0cmFpbGVyLiIsICZ0cmFpbGVyX2l0ZW0pKQoJCXJldHVybiAwOwoKCXZhcmlhYmxlX25hbWUgPSBzdHJyY2hyKHRyYWlsZXJfaXRlbSwgJy4nKTsKCWlmICghdmFyaWFibGVfbmFtZSkKCQlyZXR1cm4gMDsKCgl2YXJpYWJsZV9uYW1lKys7Cglmb3IgKGkgPSAwOyBpIDwgQVJSQVlfU0laRSh0cmFpbGVyX2NvbmZpZ19pdGVtcyk7IGkrKykgewoJCWlmIChzdHJjbXAodHJhaWxlcl9jb25maWdfaXRlbXNbaV0ubmFtZSwgdmFyaWFibGVfbmFtZSkpCgkJCWNvbnRpbnVlOwoJCW5hbWUgPSB4c3RybmR1cCh0cmFpbGVyX2l0ZW0sICB2YXJpYWJsZV9uYW1lIC0gdHJhaWxlcl9pdGVtIC0gMSk7CgkJdHlwZSA9IHRyYWlsZXJfY29uZmlnX2l0ZW1zW2ldLnR5cGU7CgkJYnJlYWs7Cgl9CgoJaWYgKCFuYW1lKQoJCXJldHVybiAwOwoKCWl0ZW0gPSBnZXRfY29uZl9pdGVtKG5hbWUpOwoJY29uZiA9ICZpdGVtLT5jb25mOwoJZnJlZShuYW1lKTsKCglzd2l0Y2ggKHR5cGUpIHsKCWNhc2UgVFJBSUxFUl9LRVk6CgkJaWYgKGNvbmYtPmtleSkKCQkJd2FybmluZyhfKCJtb3JlIHRoYW4gb25lICVzIiksIGNvbmZfa2V5KTsKCQljb25mLT5rZXkgPSB4c3RyZHVwKHZhbHVlKTsKCQlicmVhazsKCWNhc2UgVFJBSUxFUl9DT01NQU5EOgoJCWlmIChjb25mLT5jb21tYW5kKQoJCQl3YXJuaW5nKF8oIm1vcmUgdGhhbiBvbmUgJXMiKSwgY29uZl9rZXkpOwoJCWNvbmYtPmNvbW1hbmQgPSB4c3RyZHVwKHZhbHVlKTsKCQlicmVhazsKCWNhc2UgVFJBSUxFUl9DTUQ6CgkJaWYgKGNvbmYtPmNtZCkKCQkJd2FybmluZyhfKCJtb3JlIHRoYW4gb25lICVzIiksIGNvbmZfa2V5KTsKCQljb25mLT5jbWQgPSB4c3RyZHVwKHZhbHVlKTsKCQlicmVhazsKCWNhc2UgVFJBSUxFUl9XSEVSRToKCQlpZiAodHJhaWxlcl9zZXRfd2hlcmUoJmNvbmYtPndoZXJlLCB2YWx1ZSkpCgkJCXdhcm5pbmcoXygidW5rbm93biB2YWx1ZSAnJXMnIGZvciBrZXkgJyVzJyIpLCB2YWx1ZSwgY29uZl9rZXkpOwoJCWJyZWFrOwoJY2FzZSBUUkFJTEVSX0lGX0VYSVNUUzoKCQlpZiAodHJhaWxlcl9zZXRfaWZfZXhpc3RzKCZjb25mLT5pZl9leGlzdHMsIHZhbHVlKSkKCQkJd2FybmluZyhfKCJ1bmtub3duIHZhbHVlICclcycgZm9yIGtleSAnJXMnIiksIHZhbHVlLCBjb25mX2tleSk7CgkJYnJlYWs7CgljYXNlIFRSQUlMRVJfSUZfTUlTU0lORzoKCQlpZiAodHJhaWxlcl9zZXRfaWZfbWlzc2luZygmY29uZi0+aWZfbWlzc2luZywgdmFsdWUpKQoJCQl3YXJuaW5nKF8oInVua25vd24gdmFsdWUgJyVzJyBmb3Iga2V5ICclcyciKSwgdmFsdWUsIGNvbmZfa2V5KTsKCQlicmVhazsKCWRlZmF1bHQ6CgkJQlVHKCJ0cmFpbGVyLmM6IHVuaGFuZGxlZCB0eXBlICVkIiwgdHlwZSk7Cgl9CglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgZW5zdXJlX2NvbmZpZ3VyZWQodm9pZCkKewoJaWYgKGNvbmZpZ3VyZWQpCgkJcmV0dXJuOwoKCS8qIERlZmF1bHQgY29uZmlnIG11c3QgYmUgc2V0dXAgZmlyc3QgKi8KCWRlZmF1bHRfY29uZl9pbmZvLndoZXJlID0gV0hFUkVfRU5EOwoJZGVmYXVsdF9jb25mX2luZm8uaWZfZXhpc3RzID0gRVhJU1RTX0FERF9JRl9ESUZGRVJFTlRfTkVJR0hCT1I7CglkZWZhdWx0X2NvbmZfaW5mby5pZl9taXNzaW5nID0gTUlTU0lOR19BREQ7CglnaXRfY29uZmlnKGdpdF90cmFpbGVyX2RlZmF1bHRfY29uZmlnLCBOVUxMKTsKCWdpdF9jb25maWcoZ2l0X3RyYWlsZXJfY29uZmlnLCBOVUxMKTsKCWNvbmZpZ3VyZWQgPSAxOwp9CgpzdGF0aWMgY29uc3QgY2hhciAqdG9rZW5fZnJvbV9pdGVtKHN0cnVjdCBhcmdfaXRlbSAqaXRlbSwgY2hhciAqdG9rKQp7CglpZiAoaXRlbS0+Y29uZi5rZXkpCgkJcmV0dXJuIGl0ZW0tPmNvbmYua2V5OwoJaWYgKHRvaykKCQlyZXR1cm4gdG9rOwoJcmV0dXJuIGl0ZW0tPmNvbmYubmFtZTsKfQoKc3RhdGljIGludCB0b2tlbl9tYXRjaGVzX2l0ZW0oY29uc3QgY2hhciAqdG9rLCBzdHJ1Y3QgYXJnX2l0ZW0gKml0ZW0sIHNpemVfdCB0b2tfbGVuKQp7CglpZiAoIXN0cm5jYXNlY21wKHRvaywgaXRlbS0+Y29uZi5uYW1lLCB0b2tfbGVuKSkKCQlyZXR1cm4gMTsKCXJldHVybiBpdGVtLT5jb25mLmtleSA/ICFzdHJuY2FzZWNtcCh0b2ssIGl0ZW0tPmNvbmYua2V5LCB0b2tfbGVuKSA6IDA7Cn0KCi8qCiAqIElmIHRoZSBnaXZlbiBsaW5lIGlzIG9mIHRoZSBmb3JtCiAqICI8dG9rZW4+PG9wdGlvbmFsIHdoaXRlc3BhY2U+PHNlcGFyYXRvcj4uLi4iIG9yICI8c2VwYXJhdG9yPi4uLiIsIHJldHVybiB0aGUKICogbG9jYXRpb24gb2YgdGhlIHNlcGFyYXRvci4gT3RoZXJ3aXNlLCByZXR1cm4gLTEuICBUaGUgb3B0aW9uYWwgd2hpdGVzcGFjZQogKiBpcyBhbGxvd2VkIHRoZXJlIHByaW1hcmlseSB0byBhbGxvdyB0aGluZ3MgbGlrZSAiQnVnICM0MyIgd2hlcmUgPHRva2VuPiBpcwogKiAiQnVnIiBhbmQgPHNlcGFyYXRvcj4gaXMgIiMiLgogKgogKiBUaGUgc2VwYXJhdG9yLXN0YXJ0cy1saW5lIGNhc2UgKGluIHdoaWNoIHRoaXMgZnVuY3Rpb24gcmV0dXJucyAwKSBpcwogKiBkaXN0aW5ndWlzaGVkIGZyb20gdGhlIG5vbi13ZWxsLWZvcm1lZC1saW5lIGNhc2UgKGluIHdoaWNoIHRoaXMgZnVuY3Rpb24KICogcmV0dXJucyAtMSkgYmVjYXVzZSBzb21lIGNhbGxlcnMgb2YgdGhpcyBmdW5jdGlvbiBuZWVkIHN1Y2ggYSBkaXN0aW5jdGlvbi4KICovCnN0YXRpYyBzc2l6ZV90IGZpbmRfc2VwYXJhdG9yKGNvbnN0IGNoYXIgKmxpbmUsIGNvbnN0IGNoYXIgKnNlcGFyYXRvcnMpCnsKCWludCB3aGl0ZXNwYWNlX2ZvdW5kID0gMDsKCWNvbnN0IGNoYXIgKmM7Cglmb3IgKGMgPSBsaW5lOyAqYzsgYysrKSB7CgkJaWYgKHN0cmNocihzZXBhcmF0b3JzLCAqYykpCgkJCXJldHVybiBjIC0gbGluZTsKCQlpZiAoIXdoaXRlc3BhY2VfZm91bmQgJiYgKGlzYWxudW0oKmMpIHx8ICpjID09ICctJykpCgkJCWNvbnRpbnVlOwoJCWlmIChjICE9IGxpbmUgJiYgKCpjID09ICcgJyB8fCAqYyA9PSAnXHQnKSkgewoJCQl3aGl0ZXNwYWNlX2ZvdW5kID0gMTsKCQkJY29udGludWU7CgkJfQoJCWJyZWFrOwoJfQoJcmV0dXJuIC0xOwp9CgovKgogKiBPYnRhaW4gdGhlIHRva2VuLCB2YWx1ZSwgYW5kIGNvbmYgZnJvbSB0aGUgZ2l2ZW4gdHJhaWxlci4KICoKICogc2VwYXJhdG9yX3BvcyBtdXN0IG5vdCBiZSAwLCBzaW5jZSB0aGUgdG9rZW4gY2Fubm90IGJlIGFuIGVtcHR5IHN0cmluZy4KICoKICogSWYgc2VwYXJhdG9yX3BvcyBpcyAtMSwgaW50ZXJwcmV0IHRoZSB3aG9sZSB0cmFpbGVyIGFzIGEgdG9rZW4uCiAqLwpzdGF0aWMgdm9pZCBwYXJzZV90cmFpbGVyKHN0cnVjdCBzdHJidWYgKnRvaywgc3RydWN0IHN0cmJ1ZiAqdmFsLAoJCQkgY29uc3Qgc3RydWN0IGNvbmZfaW5mbyAqKmNvbmYsIGNvbnN0IGNoYXIgKnRyYWlsZXIsCgkJCSBzc2l6ZV90IHNlcGFyYXRvcl9wb3MpCnsKCXN0cnVjdCBhcmdfaXRlbSAqaXRlbTsKCXNpemVfdCB0b2tfbGVuOwoJc3RydWN0IGxpc3RfaGVhZCAqcG9zOwoKCWlmIChzZXBhcmF0b3JfcG9zICE9IC0xKSB7CgkJc3RyYnVmX2FkZCh0b2ssIHRyYWlsZXIsIHNlcGFyYXRvcl9wb3MpOwoJCXN0cmJ1Zl90cmltKHRvayk7CgkJc3RyYnVmX2FkZHN0cih2YWwsIHRyYWlsZXIgKyBzZXBhcmF0b3JfcG9zICsgMSk7CgkJc3RyYnVmX3RyaW0odmFsKTsKCX0gZWxzZSB7CgkJc3RyYnVmX2FkZHN0cih0b2ssIHRyYWlsZXIpOwoJCXN0cmJ1Zl90cmltKHRvayk7Cgl9CgoJLyogTG9va3VwIGlmIHRoZSB0b2tlbiBtYXRjaGVzIHNvbWV0aGluZyBpbiB0aGUgY29uZmlnICovCgl0b2tfbGVuID0gdG9rZW5fbGVuX3dpdGhvdXRfc2VwYXJhdG9yKHRvay0+YnVmLCB0b2stPmxlbik7CglpZiAoY29uZikKCQkqY29uZiA9ICZkZWZhdWx0X2NvbmZfaW5mbzsKCWxpc3RfZm9yX2VhY2gocG9zLCAmY29uZl9oZWFkKSB7CgkJaXRlbSA9IGxpc3RfZW50cnkocG9zLCBzdHJ1Y3QgYXJnX2l0ZW0sIGxpc3QpOwoJCWlmICh0b2tlbl9tYXRjaGVzX2l0ZW0odG9rLT5idWYsIGl0ZW0sIHRva19sZW4pKSB7CgkJCWNoYXIgKnRva19idWYgPSBzdHJidWZfZGV0YWNoKHRvaywgTlVMTCk7CgkJCWlmIChjb25mKQoJCQkJKmNvbmYgPSAmaXRlbS0+Y29uZjsKCQkJc3RyYnVmX2FkZHN0cih0b2ssIHRva2VuX2Zyb21faXRlbShpdGVtLCB0b2tfYnVmKSk7CgkJCWZyZWUodG9rX2J1Zik7CgkJCWJyZWFrOwoJCX0KCX0KfQoKc3RhdGljIHN0cnVjdCB0cmFpbGVyX2l0ZW0gKmFkZF90cmFpbGVyX2l0ZW0oc3RydWN0IGxpc3RfaGVhZCAqaGVhZCwgY2hhciAqdG9rLAoJCQkJCSAgICAgY2hhciAqdmFsKQp7CglzdHJ1Y3QgdHJhaWxlcl9pdGVtICpuZXdfaXRlbSA9IHhjYWxsb2MoMSwgc2l6ZW9mKCpuZXdfaXRlbSkpOwoJbmV3X2l0ZW0tPnRva2VuID0gdG9rOwoJbmV3X2l0ZW0tPnZhbHVlID0gdmFsOwoJbGlzdF9hZGRfdGFpbCgmbmV3X2l0ZW0tPmxpc3QsIGhlYWQpOwoJcmV0dXJuIG5ld19pdGVtOwp9CgpzdGF0aWMgdm9pZCBhZGRfYXJnX2l0ZW0oc3RydWN0IGxpc3RfaGVhZCAqYXJnX2hlYWQsIGNoYXIgKnRvaywgY2hhciAqdmFsLAoJCQkgY29uc3Qgc3RydWN0IGNvbmZfaW5mbyAqY29uZiwKCQkJIGNvbnN0IHN0cnVjdCBuZXdfdHJhaWxlcl9pdGVtICpuZXdfdHJhaWxlcl9pdGVtKQp7CglzdHJ1Y3QgYXJnX2l0ZW0gKm5ld19pdGVtID0geGNhbGxvYygxLCBzaXplb2YoKm5ld19pdGVtKSk7CgluZXdfaXRlbS0+dG9rZW4gPSB0b2s7CgluZXdfaXRlbS0+dmFsdWUgPSB2YWw7CglkdXBsaWNhdGVfY29uZigmbmV3X2l0ZW0tPmNvbmYsIGNvbmYpOwoJaWYgKG5ld190cmFpbGVyX2l0ZW0pIHsKCQlpZiAobmV3X3RyYWlsZXJfaXRlbS0+d2hlcmUgIT0gV0hFUkVfREVGQVVMVCkKCQkJbmV3X2l0ZW0tPmNvbmYud2hlcmUgPSBuZXdfdHJhaWxlcl9pdGVtLT53aGVyZTsKCQlpZiAobmV3X3RyYWlsZXJfaXRlbS0+aWZfZXhpc3RzICE9IEVYSVNUU19ERUZBVUxUKQoJCQluZXdfaXRlbS0+Y29uZi5pZl9leGlzdHMgPSBuZXdfdHJhaWxlcl9pdGVtLT5pZl9leGlzdHM7CgkJaWYgKG5ld190cmFpbGVyX2l0ZW0tPmlmX21pc3NpbmcgIT0gTUlTU0lOR19ERUZBVUxUKQoJCQluZXdfaXRlbS0+Y29uZi5pZl9taXNzaW5nID0gbmV3X3RyYWlsZXJfaXRlbS0+aWZfbWlzc2luZzsKCX0KCWxpc3RfYWRkX3RhaWwoJm5ld19pdGVtLT5saXN0LCBhcmdfaGVhZCk7Cn0KCnN0YXRpYyB2b2lkIHBhcnNlX3RyYWlsZXJzX2Zyb21fY29uZmlnKHN0cnVjdCBsaXN0X2hlYWQgKmNvbmZpZ19oZWFkKQp7CglzdHJ1Y3QgYXJnX2l0ZW0gKml0ZW07CglzdHJ1Y3QgbGlzdF9oZWFkICpwb3M7CgoJLyogQWRkIGFuIGFyZyBpdGVtIGZvciBlYWNoIGNvbmZpZ3VyZWQgdHJhaWxlciB3aXRoIGEgY29tbWFuZCAqLwoJbGlzdF9mb3JfZWFjaChwb3MsICZjb25mX2hlYWQpIHsKCQlpdGVtID0gbGlzdF9lbnRyeShwb3MsIHN0cnVjdCBhcmdfaXRlbSwgbGlzdCk7CgkJaWYgKGl0ZW0tPmNvbmYuY29tbWFuZCkKCQkJYWRkX2FyZ19pdGVtKGNvbmZpZ19oZWFkLAoJCQkJICAgICB4c3RyZHVwKHRva2VuX2Zyb21faXRlbShpdGVtLCBOVUxMKSksCgkJCQkgICAgIHhzdHJkdXAoIiIpLAoJCQkJICAgICAmaXRlbS0+Y29uZiwgTlVMTCk7Cgl9Cn0KCnN0YXRpYyB2b2lkIHBhcnNlX3RyYWlsZXJzX2Zyb21fY29tbWFuZF9saW5lX2FyZ3Moc3RydWN0IGxpc3RfaGVhZCAqYXJnX2hlYWQsCgkJCQkJCSAgc3RydWN0IGxpc3RfaGVhZCAqbmV3X3RyYWlsZXJfaGVhZCkKewoJc3RydWN0IHN0cmJ1ZiB0b2sgPSBTVFJCVUZfSU5JVDsKCXN0cnVjdCBzdHJidWYgdmFsID0gU1RSQlVGX0lOSVQ7Cgljb25zdCBzdHJ1Y3QgY29uZl9pbmZvICpjb25mOwoJc3RydWN0IGxpc3RfaGVhZCAqcG9zOwoKCS8qCgkgKiBJbiBjb21tYW5kLWxpbmUgYXJndW1lbnRzLCAnPScgaXMgYWNjZXB0ZWQgKGluIGFkZGl0aW9uIHRvIHRoZQoJICogc2VwYXJhdG9ycyB0aGF0IGFyZSBkZWZpbmVkKS4KCSAqLwoJY2hhciAqY2xfc2VwYXJhdG9ycyA9IHhzdHJmbXQoIj0lcyIsIHNlcGFyYXRvcnMpOwoKCS8qIEFkZCBhbiBhcmcgaXRlbSBmb3IgZWFjaCB0cmFpbGVyIG9uIHRoZSBjb21tYW5kIGxpbmUgKi8KCWxpc3RfZm9yX2VhY2gocG9zLCBuZXdfdHJhaWxlcl9oZWFkKSB7CgkJc3RydWN0IG5ld190cmFpbGVyX2l0ZW0gKnRyID0KCQkJbGlzdF9lbnRyeShwb3MsIHN0cnVjdCBuZXdfdHJhaWxlcl9pdGVtLCBsaXN0KTsKCQlzc2l6ZV90IHNlcGFyYXRvcl9wb3MgPSBmaW5kX3NlcGFyYXRvcih0ci0+dGV4dCwgY2xfc2VwYXJhdG9ycyk7CgoJCWlmIChzZXBhcmF0b3JfcG9zID09IDApIHsKCQkJc3RydWN0IHN0cmJ1ZiBzYiA9IFNUUkJVRl9JTklUOwoJCQlzdHJidWZfYWRkc3RyKCZzYiwgdHItPnRleHQpOwoJCQlzdHJidWZfdHJpbSgmc2IpOwoJCQllcnJvcihfKCJlbXB0eSB0cmFpbGVyIHRva2VuIGluIHRyYWlsZXIgJyUuKnMnIiksCgkJCSAgICAgIChpbnQpIHNiLmxlbiwgc2IuYnVmKTsKCQkJc3RyYnVmX3JlbGVhc2UoJnNiKTsKCQl9IGVsc2UgewoJCQlwYXJzZV90cmFpbGVyKCZ0b2ssICZ2YWwsICZjb25mLCB0ci0+dGV4dCwKCQkJCSAgICAgIHNlcGFyYXRvcl9wb3MpOwoJCQlhZGRfYXJnX2l0ZW0oYXJnX2hlYWQsCgkJCQkgICAgIHN0cmJ1Zl9kZXRhY2goJnRvaywgTlVMTCksCgkJCQkgICAgIHN0cmJ1Zl9kZXRhY2goJnZhbCwgTlVMTCksCgkJCQkgICAgIGNvbmYsIHRyKTsKCQl9Cgl9CgoJZnJlZShjbF9zZXBhcmF0b3JzKTsKfQoKc3RhdGljIHZvaWQgcmVhZF9pbnB1dF9maWxlKHN0cnVjdCBzdHJidWYgKnNiLCBjb25zdCBjaGFyICpmaWxlKQp7CglpZiAoZmlsZSkgewoJCWlmIChzdHJidWZfcmVhZF9maWxlKHNiLCBmaWxlLCAwKSA8IDApCgkJCWRpZV9lcnJubyhfKCJjb3VsZCBub3QgcmVhZCBpbnB1dCBmaWxlICclcyciKSwgZmlsZSk7Cgl9IGVsc2UgewoJCWlmIChzdHJidWZfcmVhZChzYiwgZmlsZW5vKHN0ZGluKSwgMCkgPCAwKQoJCQlkaWVfZXJybm8oXygiY291bGQgbm90IHJlYWQgZnJvbSBzdGRpbiIpKTsKCX0KfQoKc3RhdGljIGNvbnN0IGNoYXIgKm5leHRfbGluZShjb25zdCBjaGFyICpzdHIpCnsKCWNvbnN0IGNoYXIgKm5sID0gc3RyY2hybnVsKHN0ciwgJ1xuJyk7CglyZXR1cm4gbmwgKyAhISpubDsKfQoKLyoKICogUmV0dXJuIHRoZSBwb3NpdGlvbiBvZiB0aGUgc3RhcnQgb2YgdGhlIGxhc3QgbGluZS4gSWYgbGVuIGlzIDAsIHJldHVybiAtMS4KICovCnN0YXRpYyBzc2l6ZV90IGxhc3RfbGluZShjb25zdCBjaGFyICpidWYsIHNpemVfdCBsZW4pCnsKCXNzaXplX3QgaTsKCWlmIChsZW4gPT0gMCkKCQlyZXR1cm4gLTE7CglpZiAobGVuID09IDEpCgkJcmV0dXJuIDA7CgkvKgoJICogU2tpcCB0aGUgbGFzdCBjaGFyYWN0ZXIgKGluIGFkZGl0aW9uIHRvIHRoZSBudWxsIHRlcm1pbmF0b3IpLAoJICogYmVjYXVzZSBpZiB0aGUgbGFzdCBjaGFyYWN0ZXIgaXMgYSBuZXdsaW5lLCBpdCBpcyBjb25zaWRlcmVkIGFzIHBhcnQKCSAqIG9mIHRoZSBsYXN0IGxpbmUgYW55d2F5LgoJICovCglpID0gbGVuIC0gMjsKCglmb3IgKDsgaSA+PSAwOyBpLS0pIHsKCQlpZiAoYnVmW2ldID09ICdcbicpCgkJCXJldHVybiBpICsgMTsKCX0KCXJldHVybiAwOwp9CgovKgogKiBGaW5kIHRoZSBlbmQgb2YgdGhlIGxvZyBtZXNzYWdlIGFzIGFuIG9mZnNldCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgaW5wdXQKICogKHdoZXJlIGNhbGxlcnMgb2YgdGhpcyBmdW5jdGlvbiBhcmUgaW50ZXJlc3RlZCBpbiBsb29raW5nIGZvciBhIHRyYWlsZXJzCiAqIGJsb2NrIGluIHRoZSBzYW1lIGlucHV0KS4gV2UgaGF2ZSB0byBjb25zaWRlciB0d28gY2F0ZWdvcmllcyBvZiBjb250ZW50IHRoYXQKICogY2FuIGNvbWUgYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgd2hpY2ggd2Ugd2FudCB0byBpZ25vcmUgKGJlY2F1c2UgdGhleSBkb24ndAogKiBiZWxvbmcgaW4gdGhlIGxvZyBtZXNzYWdlKToKICoKICogKDEpIHRoZSAicGF0Y2ggcGFydCIgd2hpY2ggYmVnaW5zIHdpdGggYSAiLS0tIiBkaXZpZGVyIGFuZCBoYXMgcGF0Y2gKICogaW5mb3JtYXRpb24gKGxpa2UgdGhlIG91dHB1dCBvZiBnaXQtZm9ybWF0LXBhdGNoKSwgYW5kCiAqCiAqICgyKSBhbnkgdHJhaWxpbmcgY29tbWVudCBsaW5lcywgYmxhbmsgbGluZXMgbGlrZSBpbiB0aGUgb3V0cHV0IG9mICJnaXQKICogY29tbWl0IC12Iiwgb3Igc3R1ZmYgYmVsb3cgdGhlICJjdXQiIChzY2lzc29yKSBsaW5lLgogKgogKiBBcyBhIGZvcm11bGEsIHRoZSBzaXR1YXRpb24gbG9va3MgbGlrZSB0aGlzOgogKgogKiAgICAgSU5QVVQgPSBMT0cgTUVTU0FHRSArIElHTk9SRUQKICoKICogd2hlcmUgSUdOT1JFRCBjYW4gYmUgZWl0aGVyIG9mIHRoZSB0d28gY2F0ZWdvcmllcyBkZXNjcmliZWQgYWJvdmUuIEl0IG1heSBiZQogKiB0aGF0IHRoZXJlIGlzIG5vdGhpbmcgdG8gaWdub3JlLiBOb3cgaXQgbWF5IGJlIHRoZSBjYXNlIHRoYXQgdGhlIExPRyBNRVNTQUdFCiAqIGNvbnRhaW5zIGEgdHJhaWxlciBibG9jaywgYnV0IHRoYXQncyBub3QgdGhlIGNvbmNlcm4gb2YgdGhpcyBmdW5jdGlvbi4KICovCnN0YXRpYyBzaXplX3QgZmluZF9lbmRfb2ZfbG9nX21lc3NhZ2UoY29uc3QgY2hhciAqaW5wdXQsIGludCBub19kaXZpZGVyKQp7CglzaXplX3QgZW5kOwoJY29uc3QgY2hhciAqczsKCgkvKiBBc3N1bWUgdGhlIG5haXZlIGVuZCBvZiB0aGUgaW5wdXQgaXMgYWxyZWFkeSB3aGF0IHdlIHdhbnQuICovCgllbmQgPSBzdHJsZW4oaW5wdXQpOwoKCS8qIE9wdGlvbmFsbHkgc2tpcCBvdmVyIGFueSBwYXRjaCBwYXJ0ICgiLS0tIiBsaW5lIGFuZCBiZWxvdykuICovCglpZiAoIW5vX2RpdmlkZXIpIHsKCQlmb3IgKHMgPSBpbnB1dDsgKnM7IHMgPSBuZXh0X2xpbmUocykpIHsKCQkJY29uc3QgY2hhciAqdjsKCgkJCWlmIChza2lwX3ByZWZpeChzLCAiLS0tIiwgJnYpICYmIGlzc3BhY2UoKnYpKSB7CgkJCQllbmQgPSBzIC0gaW5wdXQ7CgkJCQlicmVhazsKCQkJfQoJCX0KCX0KCgkvKiBTa2lwIG92ZXIgb3RoZXIgaWdub3JhYmxlIGJpdHMuICovCglyZXR1cm4gZW5kIC0gaWdub3JlZF9sb2dfbWVzc2FnZV9ieXRlcyhpbnB1dCwgZW5kKTsKfQoKLyoKICogUmV0dXJuIHRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3QgdHJhaWxlciBsaW5lIG9yIGxlbiBpZiB0aGVyZSBhcmUgbm8KICogdHJhaWxlcnMuCiAqLwpzdGF0aWMgc2l6ZV90IGZpbmRfdHJhaWxlcl9ibG9ja19zdGFydChjb25zdCBjaGFyICpidWYsIHNpemVfdCBsZW4pCnsKCWNvbnN0IGNoYXIgKnM7Cglzc2l6ZV90IGVuZF9vZl90aXRsZSwgbDsKCWludCBvbmx5X3NwYWNlcyA9IDE7CglpbnQgcmVjb2duaXplZF9wcmVmaXggPSAwLCB0cmFpbGVyX2xpbmVzID0gMCwgbm9uX3RyYWlsZXJfbGluZXMgPSAwOwoJLyoKCSAqIE51bWJlciBvZiBwb3NzaWJsZSBjb250aW51YXRpb24gbGluZXMgZW5jb3VudGVyZWQuIFRoaXMgd2lsbCBiZQoJICogcmVzZXQgdG8gMCBpZiB3ZSBlbmNvdW50ZXIgYSB0cmFpbGVyIChzaW5jZSB0aG9zZSBsaW5lcyBhcmUgdG8gYmUKCSAqIGNvbnNpZGVyZWQgY29udGludWF0aW9ucyBvZiB0aGF0IHRyYWlsZXIpLCBhbmQgYWRkZWQgdG8KCSAqIG5vbl90cmFpbGVyX2xpbmVzIGlmIHdlIGVuY291bnRlciBhIG5vbi10cmFpbGVyIChzaW5jZSB0aG9zZSBsaW5lcwoJICogYXJlIHRvIGJlIGNvbnNpZGVyZWQgbm9uLXRyYWlsZXJzKS4KCSAqLwoJaW50IHBvc3NpYmxlX2NvbnRpbnVhdGlvbl9saW5lcyA9IDA7CgoJLyogVGhlIGZpcnN0IHBhcmFncmFwaCBpcyB0aGUgdGl0bGUgYW5kIGNhbm5vdCBiZSB0cmFpbGVycyAqLwoJZm9yIChzID0gYnVmOyBzIDwgYnVmICsgbGVuOyBzID0gbmV4dF9saW5lKHMpKSB7CgkJaWYgKHNbMF0gPT0gY29tbWVudF9saW5lX2NoYXIpCgkJCWNvbnRpbnVlOwoJCWlmIChpc19ibGFua19saW5lKHMpKQoJCQlicmVhazsKCX0KCWVuZF9vZl90aXRsZSA9IHMgLSBidWY7CgoJLyoKCSAqIEdldCB0aGUgc3RhcnQgb2YgdGhlIHRyYWlsZXJzIGJ5IGxvb2tpbmcgc3RhcnRpbmcgZnJvbSB0aGUgZW5kIGZvciBhCgkgKiBibGFuayBsaW5lIGJlZm9yZSBhIHNldCBvZiBub24tYmxhbmsgbGluZXMgdGhhdCAoaSkgYXJlIGFsbAoJICogdHJhaWxlcnMsIG9yIChpaSkgY29udGFpbnMgYXQgbGVhc3Qgb25lIEdpdC1nZW5lcmF0ZWQgdHJhaWxlciBhbmQKCSAqIGNvbnNpc3RzIG9mIGF0IGxlYXN0IDI1JSB0cmFpbGVycy4KCSAqLwoJZm9yIChsID0gbGFzdF9saW5lKGJ1ZiwgbGVuKTsKCSAgICAgbCA+PSBlbmRfb2ZfdGl0bGU7CgkgICAgIGwgPSBsYXN0X2xpbmUoYnVmLCBsKSkgewoJCWNvbnN0IGNoYXIgKmJvbCA9IGJ1ZiArIGw7CgkJY29uc3QgY2hhciAqKnA7CgkJc3NpemVfdCBzZXBhcmF0b3JfcG9zOwoKCQlpZiAoYm9sWzBdID09IGNvbW1lbnRfbGluZV9jaGFyKSB7CgkJCW5vbl90cmFpbGVyX2xpbmVzICs9IHBvc3NpYmxlX2NvbnRpbnVhdGlvbl9saW5lczsKCQkJcG9zc2libGVfY29udGludWF0aW9uX2xpbmVzID0gMDsKCQkJY29udGludWU7CgkJfQoJCWlmIChpc19ibGFua19saW5lKGJvbCkpIHsKCQkJaWYgKG9ubHlfc3BhY2VzKQoJCQkJY29udGludWU7CgkJCW5vbl90cmFpbGVyX2xpbmVzICs9IHBvc3NpYmxlX2NvbnRpbnVhdGlvbl9saW5lczsKCQkJaWYgKHJlY29nbml6ZWRfcHJlZml4ICYmCgkJCSAgICB0cmFpbGVyX2xpbmVzICogMyA+PSBub25fdHJhaWxlcl9saW5lcykKCQkJCXJldHVybiBuZXh0X2xpbmUoYm9sKSAtIGJ1ZjsKCQkJZWxzZSBpZiAodHJhaWxlcl9saW5lcyAmJiAhbm9uX3RyYWlsZXJfbGluZXMpCgkJCQlyZXR1cm4gbmV4dF9saW5lKGJvbCkgLSBidWY7CgkJCXJldHVybiBsZW47CgkJfQoJCW9ubHlfc3BhY2VzID0gMDsKCgkJZm9yIChwID0gZ2l0X2dlbmVyYXRlZF9wcmVmaXhlczsgKnA7IHArKykgewoJCQlpZiAoc3RhcnRzX3dpdGgoYm9sLCAqcCkpIHsKCQkJCXRyYWlsZXJfbGluZXMrKzsKCQkJCXBvc3NpYmxlX2NvbnRpbnVhdGlvbl9saW5lcyA9IDA7CgkJCQlyZWNvZ25pemVkX3ByZWZpeCA9IDE7CgkJCQlnb3RvIGNvbnRpbnVlX291dGVyX2xvb3A7CgkJCX0KCQl9CgoJCXNlcGFyYXRvcl9wb3MgPSBmaW5kX3NlcGFyYXRvcihib2wsIHNlcGFyYXRvcnMpOwoJCWlmIChzZXBhcmF0b3JfcG9zID49IDEgJiYgIWlzc3BhY2UoYm9sWzBdKSkgewoJCQlzdHJ1Y3QgbGlzdF9oZWFkICpwb3M7CgoJCQl0cmFpbGVyX2xpbmVzKys7CgkJCXBvc3NpYmxlX2NvbnRpbnVhdGlvbl9saW5lcyA9IDA7CgkJCWlmIChyZWNvZ25pemVkX3ByZWZpeCkKCQkJCWNvbnRpbnVlOwoJCQlsaXN0X2Zvcl9lYWNoKHBvcywgJmNvbmZfaGVhZCkgewoJCQkJc3RydWN0IGFyZ19pdGVtICppdGVtOwoJCQkJaXRlbSA9IGxpc3RfZW50cnkocG9zLCBzdHJ1Y3QgYXJnX2l0ZW0sIGxpc3QpOwoJCQkJaWYgKHRva2VuX21hdGNoZXNfaXRlbShib2wsIGl0ZW0sCgkJCQkJCSAgICAgICBzZXBhcmF0b3JfcG9zKSkgewoJCQkJCXJlY29nbml6ZWRfcHJlZml4ID0gMTsKCQkJCQlicmVhazsKCQkJCX0KCQkJfQoJCX0gZWxzZSBpZiAoaXNzcGFjZShib2xbMF0pKQoJCQlwb3NzaWJsZV9jb250aW51YXRpb25fbGluZXMrKzsKCQllbHNlIHsKCQkJbm9uX3RyYWlsZXJfbGluZXMrKzsKCQkJbm9uX3RyYWlsZXJfbGluZXMgKz0gcG9zc2libGVfY29udGludWF0aW9uX2xpbmVzOwoJCQlwb3NzaWJsZV9jb250aW51YXRpb25fbGluZXMgPSAwOwoJCX0KY29udGludWVfb3V0ZXJfbG9vcDoKCQk7Cgl9CgoJcmV0dXJuIGxlbjsKfQoKc3RhdGljIGludCBlbmRzX3dpdGhfYmxhbmtfbGluZShjb25zdCBjaGFyICpidWYsIHNpemVfdCBsZW4pCnsKCXNzaXplX3QgbGwgPSBsYXN0X2xpbmUoYnVmLCBsZW4pOwoJaWYgKGxsIDwgMCkKCQlyZXR1cm4gMDsKCXJldHVybiBpc19ibGFua19saW5lKGJ1ZiArIGxsKTsKfQoKc3RhdGljIHZvaWQgdW5mb2xkX3ZhbHVlKHN0cnVjdCBzdHJidWYgKnZhbCkKewoJc3RydWN0IHN0cmJ1ZiBvdXQgPSBTVFJCVUZfSU5JVDsKCXNpemVfdCBpOwoKCXN0cmJ1Zl9ncm93KCZvdXQsIHZhbC0+bGVuKTsKCWkgPSAwOwoJd2hpbGUgKGkgPCB2YWwtPmxlbikgewoJCWNoYXIgYyA9IHZhbC0+YnVmW2krK107CgkJaWYgKGMgPT0gJ1xuJykgewoJCQkvKiBDb2xsYXBzZSBjb250aW51YXRpb24gZG93biB0byBhIHNpbmdsZSBzcGFjZS4gKi8KCQkJd2hpbGUgKGkgPCB2YWwtPmxlbiAmJiBpc3NwYWNlKHZhbC0+YnVmW2ldKSkKCQkJCWkrKzsKCQkJc3RyYnVmX2FkZGNoKCZvdXQsICcgJyk7CgkJfSBlbHNlIHsKCQkJc3RyYnVmX2FkZGNoKCZvdXQsIGMpOwoJCX0KCX0KCgkvKiBFbXB0eSBsaW5lcyBtYXkgaGF2ZSBsZWZ0IHVzIHdpdGggd2hpdGVzcGFjZSBjcnVmdCBhdCB0aGUgZWRnZXMgKi8KCXN0cmJ1Zl90cmltKCZvdXQpOwoKCS8qIG91dHB1dCBnb2VzIGJhY2sgdG8gdmFsIGFzIGlmIHdlIG1vZGlmaWVkIGl0IGluLXBsYWNlICovCglzdHJidWZfc3dhcCgmb3V0LCB2YWwpOwoJc3RyYnVmX3JlbGVhc2UoJm91dCk7Cn0KCi8qCiAqIFBhcnNlIHRyYWlsZXJzIGluICJzdHIiLCBwb3B1bGF0aW5nIHRoZSB0cmFpbGVyIGluZm8gYW5kICJoZWFkIgogKiBsaW5rZWQgbGlzdCBzdHJ1Y3R1cmUuCiAqLwpzdGF0aWMgdm9pZCBwYXJzZV90cmFpbGVycyhzdHJ1Y3QgdHJhaWxlcl9pbmZvICppbmZvLAoJCQkgICAgIGNvbnN0IGNoYXIgKnN0ciwKCQkJICAgICBzdHJ1Y3QgbGlzdF9oZWFkICpoZWFkLAoJCQkgICAgIGNvbnN0IHN0cnVjdCBwcm9jZXNzX3RyYWlsZXJfb3B0aW9ucyAqb3B0cykKewoJc3RydWN0IHN0cmJ1ZiB0b2sgPSBTVFJCVUZfSU5JVDsKCXN0cnVjdCBzdHJidWYgdmFsID0gU1RSQlVGX0lOSVQ7CglzaXplX3QgaTsKCgl0cmFpbGVyX2luZm9fZ2V0KGluZm8sIHN0ciwgb3B0cyk7CgoJZm9yIChpID0gMDsgaSA8IGluZm8tPnRyYWlsZXJfbnI7IGkrKykgewoJCWludCBzZXBhcmF0b3JfcG9zOwoJCWNoYXIgKnRyYWlsZXIgPSBpbmZvLT50cmFpbGVyc1tpXTsKCQlpZiAodHJhaWxlclswXSA9PSBjb21tZW50X2xpbmVfY2hhcikKCQkJY29udGludWU7CgkJc2VwYXJhdG9yX3BvcyA9IGZpbmRfc2VwYXJhdG9yKHRyYWlsZXIsIHNlcGFyYXRvcnMpOwoJCWlmIChzZXBhcmF0b3JfcG9zID49IDEpIHsKCQkJcGFyc2VfdHJhaWxlcigmdG9rLCAmdmFsLCBOVUxMLCB0cmFpbGVyLAoJCQkJICAgICAgc2VwYXJhdG9yX3Bvcyk7CgkJCWlmIChvcHRzLT51bmZvbGQpCgkJCQl1bmZvbGRfdmFsdWUoJnZhbCk7CgkJCWFkZF90cmFpbGVyX2l0ZW0oaGVhZCwKCQkJCQkgc3RyYnVmX2RldGFjaCgmdG9rLCBOVUxMKSwKCQkJCQkgc3RyYnVmX2RldGFjaCgmdmFsLCBOVUxMKSk7CgkJfSBlbHNlIGlmICghb3B0cy0+b25seV90cmFpbGVycykgewoJCQlzdHJidWZfYWRkc3RyKCZ2YWwsIHRyYWlsZXIpOwoJCQlzdHJidWZfc3RyaXBfc3VmZml4KCZ2YWwsICJcbiIpOwoJCQlhZGRfdHJhaWxlcl9pdGVtKGhlYWQsCgkJCQkJIE5VTEwsCgkJCQkJIHN0cmJ1Zl9kZXRhY2goJnZhbCwgTlVMTCkpOwoJCX0KCX0KfQoKc3RhdGljIHZvaWQgZnJlZV9hbGwoc3RydWN0IGxpc3RfaGVhZCAqaGVhZCkKewoJc3RydWN0IGxpc3RfaGVhZCAqcG9zLCAqcDsKCWxpc3RfZm9yX2VhY2hfc2FmZShwb3MsIHAsIGhlYWQpIHsKCQlsaXN0X2RlbChwb3MpOwoJCWZyZWVfdHJhaWxlcl9pdGVtKGxpc3RfZW50cnkocG9zLCBzdHJ1Y3QgdHJhaWxlcl9pdGVtLCBsaXN0KSk7Cgl9Cn0KCnN0YXRpYyBzdHJ1Y3QgdGVtcGZpbGUgKnRyYWlsZXJzX3RlbXBmaWxlOwoKc3RhdGljIEZJTEUgKmNyZWF0ZV9pbl9wbGFjZV90ZW1wZmlsZShjb25zdCBjaGFyICpmaWxlKQp7CglzdHJ1Y3Qgc3RhdCBzdDsKCXN0cnVjdCBzdHJidWYgZmlsZW5hbWVfdGVtcGxhdGUgPSBTVFJCVUZfSU5JVDsKCWNvbnN0IGNoYXIgKnRhaWw7CglGSUxFICpvdXRmaWxlOwoKCWlmIChzdGF0KGZpbGUsICZzdCkpCgkJZGllX2Vycm5vKF8oImNvdWxkIG5vdCBzdGF0ICVzIiksIGZpbGUpOwoJaWYgKCFTX0lTUkVHKHN0LnN0X21vZGUpKQoJCWRpZShfKCJmaWxlICVzIGlzIG5vdCBhIHJlZ3VsYXIgZmlsZSIpLCBmaWxlKTsKCWlmICghKHN0LnN0X21vZGUgJiBTX0lXVVNSKSkKCQlkaWUoXygiZmlsZSAlcyBpcyBub3Qgd3JpdGFibGUgYnkgdXNlciIpLCBmaWxlKTsKCgkvKiBDcmVhdGUgdGVtcG9yYXJ5IGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5IGFzIHRoZSBvcmlnaW5hbCAqLwoJdGFpbCA9IHN0cnJjaHIoZmlsZSwgJy8nKTsKCWlmICh0YWlsKQoJCXN0cmJ1Zl9hZGQoJmZpbGVuYW1lX3RlbXBsYXRlLCBmaWxlLCB0YWlsIC0gZmlsZSArIDEpOwoJc3RyYnVmX2FkZHN0cigmZmlsZW5hbWVfdGVtcGxhdGUsICJnaXQtaW50ZXJwcmV0LXRyYWlsZXJzLVhYWFhYWCIpOwoKCXRyYWlsZXJzX3RlbXBmaWxlID0geG1rc190ZW1wZmlsZV9tKGZpbGVuYW1lX3RlbXBsYXRlLmJ1Ziwgc3Quc3RfbW9kZSk7CglzdHJidWZfcmVsZWFzZSgmZmlsZW5hbWVfdGVtcGxhdGUpOwoJb3V0ZmlsZSA9IGZkb3Blbl90ZW1wZmlsZSh0cmFpbGVyc190ZW1wZmlsZSwgInciKTsKCWlmICghb3V0ZmlsZSkKCQlkaWVfZXJybm8oXygiY291bGQgbm90IG9wZW4gdGVtcG9yYXJ5IGZpbGUiKSk7CgoJcmV0dXJuIG91dGZpbGU7Cn0KCnZvaWQgcHJvY2Vzc190cmFpbGVycyhjb25zdCBjaGFyICpmaWxlLAoJCSAgICAgIGNvbnN0IHN0cnVjdCBwcm9jZXNzX3RyYWlsZXJfb3B0aW9ucyAqb3B0cywKCQkgICAgICBzdHJ1Y3QgbGlzdF9oZWFkICpuZXdfdHJhaWxlcl9oZWFkKQp7CglMSVNUX0hFQUQoaGVhZCk7CglzdHJ1Y3Qgc3RyYnVmIHNiID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3QgdHJhaWxlcl9pbmZvIGluZm87CglGSUxFICpvdXRmaWxlID0gc3Rkb3V0OwoKCWVuc3VyZV9jb25maWd1cmVkKCk7CgoJcmVhZF9pbnB1dF9maWxlKCZzYiwgZmlsZSk7CgoJaWYgKG9wdHMtPmluX3BsYWNlKQoJCW91dGZpbGUgPSBjcmVhdGVfaW5fcGxhY2VfdGVtcGZpbGUoZmlsZSk7CgoJcGFyc2VfdHJhaWxlcnMoJmluZm8sIHNiLmJ1ZiwgJmhlYWQsIG9wdHMpOwoKCS8qIFByaW50IHRoZSBsaW5lcyBiZWZvcmUgdGhlIHRyYWlsZXJzICovCglpZiAoIW9wdHMtPm9ubHlfdHJhaWxlcnMpCgkJZndyaXRlKHNiLmJ1ZiwgMSwgaW5mby50cmFpbGVyX2Jsb2NrX3N0YXJ0LCBvdXRmaWxlKTsKCglpZiAoIW9wdHMtPm9ubHlfdHJhaWxlcnMgJiYgIWluZm8uYmxhbmtfbGluZV9iZWZvcmVfdHJhaWxlcikKCQlmcHJpbnRmKG91dGZpbGUsICJcbiIpOwoKCglpZiAoIW9wdHMtPm9ubHlfaW5wdXQpIHsKCQlMSVNUX0hFQUQoY29uZmlnX2hlYWQpOwoJCUxJU1RfSEVBRChhcmdfaGVhZCk7CgkJcGFyc2VfdHJhaWxlcnNfZnJvbV9jb25maWcoJmNvbmZpZ19oZWFkKTsKCQlwYXJzZV90cmFpbGVyc19mcm9tX2NvbW1hbmRfbGluZV9hcmdzKCZhcmdfaGVhZCwgbmV3X3RyYWlsZXJfaGVhZCk7CgkJbGlzdF9zcGxpY2UoJmNvbmZpZ19oZWFkLCAmYXJnX2hlYWQpOwoJCXByb2Nlc3NfdHJhaWxlcnNfbGlzdHMoJmhlYWQsICZhcmdfaGVhZCk7Cgl9CgoJcHJpbnRfYWxsKG91dGZpbGUsICZoZWFkLCBvcHRzKTsKCglmcmVlX2FsbCgmaGVhZCk7Cgl0cmFpbGVyX2luZm9fcmVsZWFzZSgmaW5mbyk7CgoJLyogUHJpbnQgdGhlIGxpbmVzIGFmdGVyIHRoZSB0cmFpbGVycyBhcyBpcyAqLwoJaWYgKCFvcHRzLT5vbmx5X3RyYWlsZXJzKQoJCWZ3cml0ZShzYi5idWYgKyBpbmZvLnRyYWlsZXJfYmxvY2tfZW5kLCAxLCBzYi5sZW4gLSBpbmZvLnRyYWlsZXJfYmxvY2tfZW5kLCBvdXRmaWxlKTsKCglpZiAob3B0cy0+aW5fcGxhY2UpCgkJaWYgKHJlbmFtZV90ZW1wZmlsZSgmdHJhaWxlcnNfdGVtcGZpbGUsIGZpbGUpKQoJCQlkaWVfZXJybm8oXygiY291bGQgbm90IHJlbmFtZSB0ZW1wb3JhcnkgZmlsZSB0byAlcyIpLCBmaWxlKTsKCglzdHJidWZfcmVsZWFzZSgmc2IpOwp9Cgp2b2lkIHRyYWlsZXJfaW5mb19nZXQoc3RydWN0IHRyYWlsZXJfaW5mbyAqaW5mbywgY29uc3QgY2hhciAqc3RyLAoJCSAgICAgIGNvbnN0IHN0cnVjdCBwcm9jZXNzX3RyYWlsZXJfb3B0aW9ucyAqb3B0cykKewoJc2l6ZV90IGVuZF9vZl9sb2dfbWVzc2FnZSA9IDAsIHRyYWlsZXJfYmxvY2tfc3RhcnQgPSAwOwoJc3RydWN0IHN0cmJ1ZiAqKnRyYWlsZXJfbGluZXMsICoqcHRyOwoJY2hhciAqKnRyYWlsZXJfc3RyaW5ncyA9IE5VTEw7CglzaXplX3QgbnIgPSAwLCBhbGxvYyA9IDA7CgljaGFyICoqbGFzdCA9IE5VTEw7CgoJZW5zdXJlX2NvbmZpZ3VyZWQoKTsKCgllbmRfb2ZfbG9nX21lc3NhZ2UgPSBmaW5kX2VuZF9vZl9sb2dfbWVzc2FnZShzdHIsIG9wdHMtPm5vX2RpdmlkZXIpOwoJdHJhaWxlcl9ibG9ja19zdGFydCA9IGZpbmRfdHJhaWxlcl9ibG9ja19zdGFydChzdHIsIGVuZF9vZl9sb2dfbWVzc2FnZSk7CgoJdHJhaWxlcl9saW5lcyA9IHN0cmJ1Zl9zcGxpdF9idWYoc3RyICsgdHJhaWxlcl9ibG9ja19zdGFydCwKCQkJCQkgZW5kX29mX2xvZ19tZXNzYWdlIC0gdHJhaWxlcl9ibG9ja19zdGFydCwKCQkJCQkgJ1xuJywKCQkJCQkgMCk7Cglmb3IgKHB0ciA9IHRyYWlsZXJfbGluZXM7ICpwdHI7IHB0cisrKSB7CgkJaWYgKGxhc3QgJiYgaXNzcGFjZSgoKnB0ciktPmJ1ZlswXSkpIHsKCQkJc3RydWN0IHN0cmJ1ZiBzYiA9IFNUUkJVRl9JTklUOwoJCQlzdHJidWZfYXR0YWNoKCZzYiwgKmxhc3QsIHN0cmxlbigqbGFzdCksIHN0cmxlbigqbGFzdCkpOwoJCQlzdHJidWZfYWRkYnVmKCZzYiwgKnB0cik7CgkJCSpsYXN0ID0gc3RyYnVmX2RldGFjaCgmc2IsIE5VTEwpOwoJCQljb250aW51ZTsKCQl9CgkJQUxMT0NfR1JPVyh0cmFpbGVyX3N0cmluZ3MsIG5yICsgMSwgYWxsb2MpOwoJCXRyYWlsZXJfc3RyaW5nc1tucl0gPSBzdHJidWZfZGV0YWNoKCpwdHIsIE5VTEwpOwoJCWxhc3QgPSBmaW5kX3NlcGFyYXRvcih0cmFpbGVyX3N0cmluZ3NbbnJdLCBzZXBhcmF0b3JzKSA+PSAxCgkJCT8gJnRyYWlsZXJfc3RyaW5nc1tucl0KCQkJOiBOVUxMOwoJCW5yKys7Cgl9CglzdHJidWZfbGlzdF9mcmVlKHRyYWlsZXJfbGluZXMpOwoKCWluZm8tPmJsYW5rX2xpbmVfYmVmb3JlX3RyYWlsZXIgPSBlbmRzX3dpdGhfYmxhbmtfbGluZShzdHIsCgkJCQkJCQkgICAgICAgdHJhaWxlcl9ibG9ja19zdGFydCk7CglpbmZvLT50cmFpbGVyX2Jsb2NrX3N0YXJ0ID0gdHJhaWxlcl9ibG9ja19zdGFydDsKCWluZm8tPnRyYWlsZXJfYmxvY2tfZW5kID0gZW5kX29mX2xvZ19tZXNzYWdlOwoJaW5mby0+dHJhaWxlcnMgPSB0cmFpbGVyX3N0cmluZ3M7CglpbmZvLT50cmFpbGVyX25yID0gbnI7Cn0KCnZvaWQgdHJhaWxlcl9pbmZvX3JlbGVhc2Uoc3RydWN0IHRyYWlsZXJfaW5mbyAqaW5mbykKewoJc2l6ZV90IGk7Cglmb3IgKGkgPSAwOyBpIDwgaW5mby0+dHJhaWxlcl9ucjsgaSsrKQoJCWZyZWUoaW5mby0+dHJhaWxlcnNbaV0pOwoJZnJlZShpbmZvLT50cmFpbGVycyk7Cn0KCnN0YXRpYyB2b2lkIGZvcm1hdF90cmFpbGVyX2luZm8oc3RydWN0IHN0cmJ1ZiAqb3V0LAoJCQkJY29uc3Qgc3RydWN0IHRyYWlsZXJfaW5mbyAqaW5mbywKCQkJCWNvbnN0IGNoYXIgKm1zZywKCQkJCWNvbnN0IHN0cnVjdCBwcm9jZXNzX3RyYWlsZXJfb3B0aW9ucyAqb3B0cykKewoJc2l6ZV90IG9yaWdsZW4gPSBvdXQtPmxlbjsKCXNpemVfdCBpOwoKCS8qIElmIHdlIHdhbnQgdGhlIHdob2xlIGJsb2NrIHVudG91Y2hlZCwgd2UgY2FuIHRha2UgdGhlIGZhc3QgcGF0aC4gKi8KCWlmICghb3B0cy0+b25seV90cmFpbGVycyAmJiAhb3B0cy0+dW5mb2xkICYmICFvcHRzLT5maWx0ZXIgJiYKCSAgICAhb3B0cy0+c2VwYXJhdG9yICYmICFvcHRzLT5rZXlfb25seSAmJiAhb3B0cy0+dmFsdWVfb25seSAmJgoJICAgICFvcHRzLT5rZXlfdmFsdWVfc2VwYXJhdG9yKSB7CgkJc3RyYnVmX2FkZChvdXQsIG1zZyArIGluZm8tPnRyYWlsZXJfYmxvY2tfc3RhcnQsCgkJCSAgIGluZm8tPnRyYWlsZXJfYmxvY2tfZW5kIC0gaW5mby0+dHJhaWxlcl9ibG9ja19zdGFydCk7CgkJcmV0dXJuOwoJfQoKCWZvciAoaSA9IDA7IGkgPCBpbmZvLT50cmFpbGVyX25yOyBpKyspIHsKCQljaGFyICp0cmFpbGVyID0gaW5mby0+dHJhaWxlcnNbaV07CgkJc3NpemVfdCBzZXBhcmF0b3JfcG9zID0gZmluZF9zZXBhcmF0b3IodHJhaWxlciwgc2VwYXJhdG9ycyk7CgoJCWlmIChzZXBhcmF0b3JfcG9zID49IDEpIHsKCQkJc3RydWN0IHN0cmJ1ZiB0b2sgPSBTVFJCVUZfSU5JVDsKCQkJc3RydWN0IHN0cmJ1ZiB2YWwgPSBTVFJCVUZfSU5JVDsKCgkJCXBhcnNlX3RyYWlsZXIoJnRvaywgJnZhbCwgTlVMTCwgdHJhaWxlciwgc2VwYXJhdG9yX3Bvcyk7CgkJCWlmICghb3B0cy0+ZmlsdGVyIHx8IG9wdHMtPmZpbHRlcigmdG9rLCBvcHRzLT5maWx0ZXJfZGF0YSkpIHsKCQkJCWlmIChvcHRzLT51bmZvbGQpCgkJCQkJdW5mb2xkX3ZhbHVlKCZ2YWwpOwoKCQkJCWlmIChvcHRzLT5zZXBhcmF0b3IgJiYgb3V0LT5sZW4gIT0gb3JpZ2xlbikKCQkJCQlzdHJidWZfYWRkYnVmKG91dCwgb3B0cy0+c2VwYXJhdG9yKTsKCQkJCWlmICghb3B0cy0+dmFsdWVfb25seSkKCQkJCQlzdHJidWZfYWRkYnVmKG91dCwgJnRvayk7CgkJCQlpZiAoIW9wdHMtPmtleV9vbmx5ICYmICFvcHRzLT52YWx1ZV9vbmx5KSB7CgkJCQkJaWYgKG9wdHMtPmtleV92YWx1ZV9zZXBhcmF0b3IpCgkJCQkJCXN0cmJ1Zl9hZGRidWYob3V0LCBvcHRzLT5rZXlfdmFsdWVfc2VwYXJhdG9yKTsKCQkJCQllbHNlCgkJCQkJCXN0cmJ1Zl9hZGRzdHIob3V0LCAiOiAiKTsKCQkJCX0KCQkJCWlmICghb3B0cy0+a2V5X29ubHkpCgkJCQkJc3RyYnVmX2FkZGJ1ZihvdXQsICZ2YWwpOwoJCQkJaWYgKCFvcHRzLT5zZXBhcmF0b3IpCgkJCQkJc3RyYnVmX2FkZGNoKG91dCwgJ1xuJyk7CgkJCX0KCQkJc3RyYnVmX3JlbGVhc2UoJnRvayk7CgkJCXN0cmJ1Zl9yZWxlYXNlKCZ2YWwpOwoKCQl9IGVsc2UgaWYgKCFvcHRzLT5vbmx5X3RyYWlsZXJzKSB7CgkJCWlmIChvcHRzLT5zZXBhcmF0b3IgJiYgb3V0LT5sZW4gIT0gb3JpZ2xlbikgewoJCQkJc3RyYnVmX2FkZGJ1ZihvdXQsIG9wdHMtPnNlcGFyYXRvcik7CgkJCX0KCQkJc3RyYnVmX2FkZHN0cihvdXQsIHRyYWlsZXIpOwoJCQlpZiAob3B0cy0+c2VwYXJhdG9yKSB7CgkJCQlzdHJidWZfcnRyaW0ob3V0KTsKCQkJfQoJCX0KCX0KCn0KCnZvaWQgZm9ybWF0X3RyYWlsZXJzX2Zyb21fY29tbWl0KHN0cnVjdCBzdHJidWYgKm91dCwgY29uc3QgY2hhciAqbXNnLAoJCQkJIGNvbnN0IHN0cnVjdCBwcm9jZXNzX3RyYWlsZXJfb3B0aW9ucyAqb3B0cykKewoJc3RydWN0IHRyYWlsZXJfaW5mbyBpbmZvOwoKCXRyYWlsZXJfaW5mb19nZXQoJmluZm8sIG1zZywgb3B0cyk7Cglmb3JtYXRfdHJhaWxlcl9pbmZvKG91dCwgJmluZm8sIG1zZywgb3B0cyk7Cgl0cmFpbGVyX2luZm9fcmVsZWFzZSgmaW5mbyk7Cn0KCnZvaWQgdHJhaWxlcl9pdGVyYXRvcl9pbml0KHN0cnVjdCB0cmFpbGVyX2l0ZXJhdG9yICppdGVyLCBjb25zdCBjaGFyICptc2cpCnsKCXN0cnVjdCBwcm9jZXNzX3RyYWlsZXJfb3B0aW9ucyBvcHRzID0gUFJPQ0VTU19UUkFJTEVSX09QVElPTlNfSU5JVDsKCXN0cmJ1Zl9pbml0KCZpdGVyLT5rZXksIDApOwoJc3RyYnVmX2luaXQoJml0ZXItPnZhbCwgMCk7CglvcHRzLm5vX2RpdmlkZXIgPSAxOwoJdHJhaWxlcl9pbmZvX2dldCgmaXRlci0+aW50ZXJuYWwuaW5mbywgbXNnLCAmb3B0cyk7CglpdGVyLT5pbnRlcm5hbC5jdXIgPSAwOwp9CgppbnQgdHJhaWxlcl9pdGVyYXRvcl9hZHZhbmNlKHN0cnVjdCB0cmFpbGVyX2l0ZXJhdG9yICppdGVyKQp7Cgl3aGlsZSAoaXRlci0+aW50ZXJuYWwuY3VyIDwgaXRlci0+aW50ZXJuYWwuaW5mby50cmFpbGVyX25yKSB7CgkJY2hhciAqdHJhaWxlciA9IGl0ZXItPmludGVybmFsLmluZm8udHJhaWxlcnNbaXRlci0+aW50ZXJuYWwuY3VyKytdOwoJCWludCBzZXBhcmF0b3JfcG9zID0gZmluZF9zZXBhcmF0b3IodHJhaWxlciwgc2VwYXJhdG9ycyk7CgoJCWlmIChzZXBhcmF0b3JfcG9zIDwgMSkKCQkJY29udGludWU7IC8qIG5vdCBhIHJlYWwgdHJhaWxlciAqLwoKCQlzdHJidWZfcmVzZXQoJml0ZXItPmtleSk7CgkJc3RyYnVmX3Jlc2V0KCZpdGVyLT52YWwpOwoJCXBhcnNlX3RyYWlsZXIoJml0ZXItPmtleSwgJml0ZXItPnZhbCwgTlVMTCwKCQkJICAgICAgdHJhaWxlciwgc2VwYXJhdG9yX3Bvcyk7CgkJdW5mb2xkX3ZhbHVlKCZpdGVyLT52YWwpOwoJCXJldHVybiAxOwoJfQoJcmV0dXJuIDA7Cn0KCnZvaWQgdHJhaWxlcl9pdGVyYXRvcl9yZWxlYXNlKHN0cnVjdCB0cmFpbGVyX2l0ZXJhdG9yICppdGVyKQp7Cgl0cmFpbGVyX2luZm9fcmVsZWFzZSgmaXRlci0+aW50ZXJuYWwuaW5mbyk7CglzdHJidWZfcmVsZWFzZSgmaXRlci0+dmFsKTsKCXN0cmJ1Zl9yZWxlYXNlKCZpdGVyLT5rZXkpOwp9Cg==",
    "text": "#include \"git-compat-util.h\"\n#include \"config.h\"\n#include \"environment.h\"\n#include \"gettext.h\"\n#include \"string-list.h\"\n#include \"run-command.h\"\n#include \"commit.h\"\n#include \"tempfile.h\"\n#include \"trailer.h\"\n#include \"list.h\"\n/*\n * Copyright (c) 2013, 2014 Christian Couder <chriscool@tuxfamily.org>\n */\n\nstruct conf_info {\n\tchar *name;\n\tchar *key;\n\tchar *command;\n\tchar *cmd;\n\tenum trailer_where where;\n\tenum trailer_if_exists if_exists;\n\tenum trailer_if_missing if_missing;\n};\n\nstatic struct conf_info default_conf_info;\n\nstruct trailer_item {\n\tstruct list_head list;\n\t/*\n\t * If this is not a trailer line, the line is stored in value\n\t * (excluding the terminating newline) and token is NULL.\n\t */\n\tchar *token;\n\tchar *value;\n};\n\nstruct arg_item {\n\tstruct list_head list;\n\tchar *token;\n\tchar *value;\n\tstruct conf_info conf;\n};\n\nstatic LIST_HEAD(conf_head);\n\nstatic char *separators = \":\";\n\nstatic int configured;\n\n#define TRAILER_ARG_STRING \"$ARG\"\n\nstatic const char *git_generated_prefixes[] = {\n\t\"Signed-off-by: \",\n\t\"(cherry picked from commit \",\n\tNULL\n};\n\n/* Iterate over the elements of the list. */\n#define list_for_each_dir(pos, head, is_reverse) \\\n\tfor (pos = is_reverse ? (head)->prev : (head)->next; \\\n\t\tpos != (head); \\\n\t\tpos = is_reverse ? pos->prev : pos->next)\n\nstatic int after_or_end(enum trailer_where where)\n{\n\treturn (where == WHERE_AFTER) || (where == WHERE_END);\n}\n\n/*\n * Return the length of the string not including any final\n * punctuation. E.g., the input \"Signed-off-by:\" would return\n * 13, stripping the trailing punctuation but retaining\n * internal punctuation.\n */\nstatic size_t token_len_without_separator(const char *token, size_t len)\n{\n\twhile (len > 0 && !isalnum(token[len - 1]))\n\t\tlen--;\n\treturn len;\n}\n\nstatic int same_token(struct trailer_item *a, struct arg_item *b)\n{\n\tsize_t a_len, b_len, min_len;\n\n\tif (!a->token)\n\t\treturn 0;\n\n\ta_len = token_len_without_separator(a->token, strlen(a->token));\n\tb_len = token_len_without_separator(b->token, strlen(b->token));\n\tmin_len = (a_len > b_len) ? b_len : a_len;\n\n\treturn !strncasecmp(a->token, b->token, min_len);\n}\n\nstatic int same_value(struct trailer_item *a, struct arg_item *b)\n{\n\treturn !strcasecmp(a->value, b->value);\n}\n\nstatic int same_trailer(struct trailer_item *a, struct arg_item *b)\n{\n\treturn same_token(a, b) && same_value(a, b);\n}\n\nstatic inline int is_blank_line(const char *str)\n{\n\tconst char *s = str;\n\twhile (*s && *s != '\\n' && isspace(*s))\n\t\ts++;\n\treturn !*s || *s == '\\n';\n}\n\nstatic inline void strbuf_replace(struct strbuf *sb, const char *a, const char *b)\n{\n\tconst char *ptr = strstr(sb->buf, a);\n\tif (ptr)\n\t\tstrbuf_splice(sb, ptr - sb->buf, strlen(a), b, strlen(b));\n}\n\nstatic void free_trailer_item(struct trailer_item *item)\n{\n\tfree(item->token);\n\tfree(item->value);\n\tfree(item);\n}\n\nstatic void free_arg_item(struct arg_item *item)\n{\n\tfree(item->conf.name);\n\tfree(item->conf.key);\n\tfree(item->conf.command);\n\tfree(item->conf.cmd);\n\tfree(item->token);\n\tfree(item->value);\n\tfree(item);\n}\n\nstatic char last_non_space_char(const char *s)\n{\n\tint i;\n\tfor (i = strlen(s) - 1; i >= 0; i--)\n\t\tif (!isspace(s[i]))\n\t\t\treturn s[i];\n\treturn '\\0';\n}\n\nstatic void print_tok_val(FILE *outfile, const char *tok, const char *val)\n{\n\tchar c;\n\n\tif (!tok) {\n\t\tfprintf(outfile, \"%s\\n\", val);\n\t\treturn;\n\t}\n\n\tc = last_non_space_char(tok);\n\tif (!c)\n\t\treturn;\n\tif (strchr(separators, c))\n\t\tfprintf(outfile, \"%s%s\\n\", tok, val);\n\telse\n\t\tfprintf(outfile, \"%s%c %s\\n\", tok, separators[0], val);\n}\n\nstatic void print_all(FILE *outfile, struct list_head *head,\n\t\t      const struct process_trailer_options *opts)\n{\n\tstruct list_head *pos;\n\tstruct trailer_item *item;\n\tlist_for_each(pos, head) {\n\t\titem = list_entry(pos, struct trailer_item, list);\n\t\tif ((!opts->trim_empty || strlen(item->value) > 0) &&\n\t\t    (!opts->only_trailers || item->token))\n\t\t\tprint_tok_val(outfile, item->token, item->value);\n\t}\n}\n\nstatic struct trailer_item *trailer_from_arg(struct arg_item *arg_tok)\n{\n\tstruct trailer_item *new_item = xcalloc(1, sizeof(*new_item));\n\tnew_item->token = arg_tok->token;\n\tnew_item->value = arg_tok->value;\n\targ_tok->token = arg_tok->value = NULL;\n\tfree_arg_item(arg_tok);\n\treturn new_item;\n}\n\nstatic void add_arg_to_input_list(struct trailer_item *on_tok,\n\t\t\t\t  struct arg_item *arg_tok)\n{\n\tint aoe = after_or_end(arg_tok->conf.where);\n\tstruct trailer_item *to_add = trailer_from_arg(arg_tok);\n\tif (aoe)\n\t\tlist_add(&to_add->list, &on_tok->list);\n\telse\n\t\tlist_add_tail(&to_add->list, &on_tok->list);\n}\n\nstatic int check_if_different(struct trailer_item *in_tok,\n\t\t\t      struct arg_item *arg_tok,\n\t\t\t      int check_all,\n\t\t\t      struct list_head *head)\n{\n\tenum trailer_where where = arg_tok->conf.where;\n\tstruct list_head *next_head;\n\tdo {\n\t\tif (same_trailer(in_tok, arg_tok))\n\t\t\treturn 0;\n\t\t/*\n\t\t * if we want to add a trailer after another one,\n\t\t * we have to check those before this one\n\t\t */\n\t\tnext_head = after_or_end(where) ? in_tok->list.prev\n\t\t\t\t\t\t: in_tok->list.next;\n\t\tif (next_head == head)\n\t\t\tbreak;\n\t\tin_tok = list_entry(next_head, struct trailer_item, list);\n\t} while (check_all);\n\treturn 1;\n}\n\nstatic char *apply_command(struct conf_info *conf, const char *arg)\n{\n\tstruct strbuf cmd = STRBUF_INIT;\n\tstruct strbuf buf = STRBUF_INIT;\n\tstruct child_process cp = CHILD_PROCESS_INIT;\n\tchar *result;\n\n\tif (conf->cmd) {\n\t\tstrbuf_addstr(&cmd, conf->cmd);\n\t\tstrvec_push(&cp.args, cmd.buf);\n\t\tif (arg)\n\t\t\tstrvec_push(&cp.args, arg);\n\t} else if (conf->command) {\n\t\tstrbuf_addstr(&cmd, conf->command);\n\t\tif (arg)\n\t\t\tstrbuf_replace(&cmd, TRAILER_ARG_STRING, arg);\n\t\tstrvec_push(&cp.args, cmd.buf);\n\t}\n\tstrvec_pushv(&cp.env, (const char **)local_repo_env);\n\tcp.no_stdin = 1;\n\tcp.use_shell = 1;\n\n\tif (capture_command(&cp, &buf, 1024)) {\n\t\terror(_(\"running trailer command '%s' failed\"), cmd.buf);\n\t\tstrbuf_release(&buf);\n\t\tresult = xstrdup(\"\");\n\t} else {\n\t\tstrbuf_trim(&buf);\n\t\tresult = strbuf_detach(&buf, NULL);\n\t}\n\n\tstrbuf_release(&cmd);\n\treturn result;\n}\n\nstatic void apply_item_command(struct trailer_item *in_tok, struct arg_item *arg_tok)\n{\n\tif (arg_tok->conf.command || arg_tok->conf.cmd) {\n\t\tconst char *arg;\n\t\tif (arg_tok->value && arg_tok->value[0]) {\n\t\t\targ = arg_tok->value;\n\t\t} else {\n\t\t\tif (in_tok && in_tok->value)\n\t\t\t\targ = xstrdup(in_tok->value);\n\t\t\telse\n\t\t\t\targ = xstrdup(\"\");\n\t\t}\n\t\targ_tok->value = apply_command(&arg_tok->conf, arg);\n\t\tfree((char *)arg);\n\t}\n}\n\nstatic void apply_arg_if_exists(struct trailer_item *in_tok,\n\t\t\t\tstruct arg_item *arg_tok,\n\t\t\t\tstruct trailer_item *on_tok,\n\t\t\t\tstruct list_head *head)\n{\n\tswitch (arg_tok->conf.if_exists) {\n\tcase EXISTS_DO_NOTHING:\n\t\tfree_arg_item(arg_tok);\n\t\tbreak;\n\tcase EXISTS_REPLACE:\n\t\tapply_item_command(in_tok, arg_tok);\n\t\tadd_arg_to_input_list(on_tok, arg_tok);\n\t\tlist_del(&in_tok->list);\n\t\tfree_trailer_item(in_tok);\n\t\tbreak;\n\tcase EXISTS_ADD:\n\t\tapply_item_command(in_tok, arg_tok);\n\t\tadd_arg_to_input_list(on_tok, arg_tok);\n\t\tbreak;\n\tcase EXISTS_ADD_IF_DIFFERENT:\n\t\tapply_item_command(in_tok, arg_tok);\n\t\tif (check_if_different(in_tok, arg_tok, 1, head))\n\t\t\tadd_arg_to_input_list(on_tok, arg_tok);\n\t\telse\n\t\t\tfree_arg_item(arg_tok);\n\t\tbreak;\n\tcase EXISTS_ADD_IF_DIFFERENT_NEIGHBOR:\n\t\tapply_item_command(in_tok, arg_tok);\n\t\tif (check_if_different(on_tok, arg_tok, 0, head))\n\t\t\tadd_arg_to_input_list(on_tok, arg_tok);\n\t\telse\n\t\t\tfree_arg_item(arg_tok);\n\t\tbreak;\n\tdefault:\n\t\tBUG(\"trailer.c: unhandled value %d\",\n\t\t    arg_tok->conf.if_exists);\n\t}\n}\n\nstatic void apply_arg_if_missing(struct list_head *head,\n\t\t\t\t struct arg_item *arg_tok)\n{\n\tenum trailer_where where;\n\tstruct trailer_item *to_add;\n\n\tswitch (arg_tok->conf.if_missing) {\n\tcase MISSING_DO_NOTHING:\n\t\tfree_arg_item(arg_tok);\n\t\tbreak;\n\tcase MISSING_ADD:\n\t\twhere = arg_tok->conf.where;\n\t\tapply_item_command(NULL, arg_tok);\n\t\tto_add = trailer_from_arg(arg_tok);\n\t\tif (after_or_end(where))\n\t\t\tlist_add_tail(&to_add->list, head);\n\t\telse\n\t\t\tlist_add(&to_add->list, head);\n\t\tbreak;\n\tdefault:\n\t\tBUG(\"trailer.c: unhandled value %d\",\n\t\t    arg_tok->conf.if_missing);\n\t}\n}\n\nstatic int find_same_and_apply_arg(struct list_head *head,\n\t\t\t\t   struct arg_item *arg_tok)\n{\n\tstruct list_head *pos;\n\tstruct trailer_item *in_tok;\n\tstruct trailer_item *on_tok;\n\n\tenum trailer_where where = arg_tok->conf.where;\n\tint middle = (where == WHERE_AFTER) || (where == WHERE_BEFORE);\n\tint backwards = after_or_end(where);\n\tstruct trailer_item *start_tok;\n\n\tif (list_empty(head))\n\t\treturn 0;\n\n\tstart_tok = list_entry(backwards ? head->prev : head->next,\n\t\t\t       struct trailer_item,\n\t\t\t       list);\n\n\tlist_for_each_dir(pos, head, backwards) {\n\t\tin_tok = list_entry(pos, struct trailer_item, list);\n\t\tif (!same_token(in_tok, arg_tok))\n\t\t\tcontinue;\n\t\ton_tok = middle ? in_tok : start_tok;\n\t\tapply_arg_if_exists(in_tok, arg_tok, on_tok, head);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic void process_trailers_lists(struct list_head *head,\n\t\t\t\t   struct list_head *arg_head)\n{\n\tstruct list_head *pos, *p;\n\tstruct arg_item *arg_tok;\n\n\tlist_for_each_safe(pos, p, arg_head) {\n\t\tint applied = 0;\n\t\targ_tok = list_entry(pos, struct arg_item, list);\n\n\t\tlist_del(pos);\n\n\t\tapplied = find_same_and_apply_arg(head, arg_tok);\n\n\t\tif (!applied)\n\t\t\tapply_arg_if_missing(head, arg_tok);\n\t}\n}\n\nint trailer_set_where(enum trailer_where *item, const char *value)\n{\n\tif (!value)\n\t\t*item = WHERE_DEFAULT;\n\telse if (!strcasecmp(\"after\", value))\n\t\t*item = WHERE_AFTER;\n\telse if (!strcasecmp(\"before\", value))\n\t\t*item = WHERE_BEFORE;\n\telse if (!strcasecmp(\"end\", value))\n\t\t*item = WHERE_END;\n\telse if (!strcasecmp(\"start\", value))\n\t\t*item = WHERE_START;\n\telse\n\t\treturn -1;\n\treturn 0;\n}\n\nint trailer_set_if_exists(enum trailer_if_exists *item, const char *value)\n{\n\tif (!value)\n\t\t*item = EXISTS_DEFAULT;\n\telse if (!strcasecmp(\"addIfDifferent\", value))\n\t\t*item = EXISTS_ADD_IF_DIFFERENT;\n\telse if (!strcasecmp(\"addIfDifferentNeighbor\", value))\n\t\t*item = EXISTS_ADD_IF_DIFFERENT_NEIGHBOR;\n\telse if (!strcasecmp(\"add\", value))\n\t\t*item = EXISTS_ADD;\n\telse if (!strcasecmp(\"replace\", value))\n\t\t*item = EXISTS_REPLACE;\n\telse if (!strcasecmp(\"doNothing\", value))\n\t\t*item = EXISTS_DO_NOTHING;\n\telse\n\t\treturn -1;\n\treturn 0;\n}\n\nint trailer_set_if_missing(enum trailer_if_missing *item, const char *value)\n{\n\tif (!value)\n\t\t*item = MISSING_DEFAULT;\n\telse if (!strcasecmp(\"doNothing\", value))\n\t\t*item = MISSING_DO_NOTHING;\n\telse if (!strcasecmp(\"add\", value))\n\t\t*item = MISSING_ADD;\n\telse\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic void duplicate_conf(struct conf_info *dst, const struct conf_info *src)\n{\n\t*dst = *src;\n\tdst->name = xstrdup_or_null(src->name);\n\tdst->key = xstrdup_or_null(src->key);\n\tdst->command = xstrdup_or_null(src->command);\n\tdst->cmd = xstrdup_or_null(src->cmd);\n}\n\nstatic struct arg_item *get_conf_item(const char *name)\n{\n\tstruct list_head *pos;\n\tstruct arg_item *item;\n\n\t/* Look up item with same name */\n\tlist_for_each(pos, &conf_head) {\n\t\titem = list_entry(pos, struct arg_item, list);\n\t\tif (!strcasecmp(item->conf.name, name))\n\t\t\treturn item;\n\t}\n\n\t/* Item does not already exists, create it */\n\tCALLOC_ARRAY(item, 1);\n\tduplicate_conf(&item->conf, &default_conf_info);\n\titem->conf.name = xstrdup(name);\n\n\tlist_add_tail(&item->list, &conf_head);\n\n\treturn item;\n}\n\nenum trailer_info_type { TRAILER_KEY, TRAILER_COMMAND, TRAILER_CMD,\n\t\t\tTRAILER_WHERE, TRAILER_IF_EXISTS, TRAILER_IF_MISSING };\n\nstatic struct {\n\tconst char *name;\n\tenum trailer_info_type type;\n} trailer_config_items[] = {\n\t{ \"key\", TRAILER_KEY },\n\t{ \"command\", TRAILER_COMMAND },\n\t{ \"cmd\", TRAILER_CMD },\n\t{ \"where\", TRAILER_WHERE },\n\t{ \"ifexists\", TRAILER_IF_EXISTS },\n\t{ \"ifmissing\", TRAILER_IF_MISSING }\n};\n\nstatic int git_trailer_default_config(const char *conf_key, const char *value,\n\t\t\t\t      const struct config_context *ctx UNUSED,\n\t\t\t\t      void *cb UNUSED)\n{\n\tconst char *trailer_item, *variable_name;\n\n\tif (!skip_prefix(conf_key, \"trailer.\", &trailer_item))\n\t\treturn 0;\n\n\tvariable_name = strrchr(trailer_item, '.');\n\tif (!variable_name) {\n\t\tif (!strcmp(trailer_item, \"where\")) {\n\t\t\tif (trailer_set_where(&default_conf_info.where,\n\t\t\t\t\t      value) < 0)\n\t\t\t\twarning(_(\"unknown value '%s' for key '%s'\"),\n\t\t\t\t\tvalue, conf_key);\n\t\t} else if (!strcmp(trailer_item, \"ifexists\")) {\n\t\t\tif (trailer_set_if_exists(&default_conf_info.if_exists,\n\t\t\t\t\t\t  value) < 0)\n\t\t\t\twarning(_(\"unknown value '%s' for key '%s'\"),\n\t\t\t\t\tvalue, conf_key);\n\t\t} else if (!strcmp(trailer_item, \"ifmissing\")) {\n\t\t\tif (trailer_set_if_missing(&default_conf_info.if_missing,\n\t\t\t\t\t\t   value) < 0)\n\t\t\t\twarning(_(\"unknown value '%s' for key '%s'\"),\n\t\t\t\t\tvalue, conf_key);\n\t\t} else if (!strcmp(trailer_item, \"separators\")) {\n\t\t\tseparators = xstrdup(value);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int git_trailer_config(const char *conf_key, const char *value,\n\t\t\t      const struct config_context *ctx UNUSED,\n\t\t\t      void *cb UNUSED)\n{\n\tconst char *trailer_item, *variable_name;\n\tstruct arg_item *item;\n\tstruct conf_info *conf;\n\tchar *name = NULL;\n\tenum trailer_info_type type;\n\tint i;\n\n\tif (!skip_prefix(conf_key, \"trailer.\", &trailer_item))\n\t\treturn 0;\n\n\tvariable_name = strrchr(trailer_item, '.');\n\tif (!variable_name)\n\t\treturn 0;\n\n\tvariable_name++;\n\tfor (i = 0; i < ARRAY_SIZE(trailer_config_items); i++) {\n\t\tif (strcmp(trailer_config_items[i].name, variable_name))\n\t\t\tcontinue;\n\t\tname = xstrndup(trailer_item,  variable_name - trailer_item - 1);\n\t\ttype = trailer_config_items[i].type;\n\t\tbreak;\n\t}\n\n\tif (!name)\n\t\treturn 0;\n\n\titem = get_conf_item(name);\n\tconf = &item->conf;\n\tfree(name);\n\n\tswitch (type) {\n\tcase TRAILER_KEY:\n\t\tif (conf->key)\n\t\t\twarning(_(\"more than one %s\"), conf_key);\n\t\tconf->key = xstrdup(value);\n\t\tbreak;\n\tcase TRAILER_COMMAND:\n\t\tif (conf->command)\n\t\t\twarning(_(\"more than one %s\"), conf_key);\n\t\tconf->command = xstrdup(value);\n\t\tbreak;\n\tcase TRAILER_CMD:\n\t\tif (conf->cmd)\n\t\t\twarning(_(\"more than one %s\"), conf_key);\n\t\tconf->cmd = xstrdup(value);\n\t\tbreak;\n\tcase TRAILER_WHERE:\n\t\tif (trailer_set_where(&conf->where, value))\n\t\t\twarning(_(\"unknown value '%s' for key '%s'\"), value, conf_key);\n\t\tbreak;\n\tcase TRAILER_IF_EXISTS:\n\t\tif (trailer_set_if_exists(&conf->if_exists, value))\n\t\t\twarning(_(\"unknown value '%s' for key '%s'\"), value, conf_key);\n\t\tbreak;\n\tcase TRAILER_IF_MISSING:\n\t\tif (trailer_set_if_missing(&conf->if_missing, value))\n\t\t\twarning(_(\"unknown value '%s' for key '%s'\"), value, conf_key);\n\t\tbreak;\n\tdefault:\n\t\tBUG(\"trailer.c: unhandled type %d\", type);\n\t}\n\treturn 0;\n}\n\nstatic void ensure_configured(void)\n{\n\tif (configured)\n\t\treturn;\n\n\t/* Default config must be setup first */\n\tdefault_conf_info.where = WHERE_END;\n\tdefault_conf_info.if_exists = EXISTS_ADD_IF_DIFFERENT_NEIGHBOR;\n\tdefault_conf_info.if_missing = MISSING_ADD;\n\tgit_config(git_trailer_default_config, NULL);\n\tgit_config(git_trailer_config, NULL);\n\tconfigured = 1;\n}\n\nstatic const char *token_from_item(struct arg_item *item, char *tok)\n{\n\tif (item->conf.key)\n\t\treturn item->conf.key;\n\tif (tok)\n\t\treturn tok;\n\treturn item->conf.name;\n}\n\nstatic int token_matches_item(const char *tok, struct arg_item *item, size_t tok_len)\n{\n\tif (!strncasecmp(tok, item->conf.name, tok_len))\n\t\treturn 1;\n\treturn item->conf.key ? !strncasecmp(tok, item->conf.key, tok_len) : 0;\n}\n\n/*\n * If the given line is of the form\n * \"<token><optional whitespace><separator>...\" or \"<separator>...\", return the\n * location of the separator. Otherwise, return -1.  The optional whitespace\n * is allowed there primarily to allow things like \"Bug #43\" where <token> is\n * \"Bug\" and <separator> is \"#\".\n *\n * The separator-starts-line case (in which this function returns 0) is\n * distinguished from the non-well-formed-line case (in which this function\n * returns -1) because some callers of this function need such a distinction.\n */\nstatic ssize_t find_separator(const char *line, const char *separators)\n{\n\tint whitespace_found = 0;\n\tconst char *c;\n\tfor (c = line; *c; c++) {\n\t\tif (strchr(separators, *c))\n\t\t\treturn c - line;\n\t\tif (!whitespace_found && (isalnum(*c) || *c == '-'))\n\t\t\tcontinue;\n\t\tif (c != line && (*c == ' ' || *c == '\\t')) {\n\t\t\twhitespace_found = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\treturn -1;\n}\n\n/*\n * Obtain the token, value, and conf from the given trailer.\n *\n * separator_pos must not be 0, since the token cannot be an empty string.\n *\n * If separator_pos is -1, interpret the whole trailer as a token.\n */\nstatic void parse_trailer(struct strbuf *tok, struct strbuf *val,\n\t\t\t const struct conf_info **conf, const char *trailer,\n\t\t\t ssize_t separator_pos)\n{\n\tstruct arg_item *item;\n\tsize_t tok_len;\n\tstruct list_head *pos;\n\n\tif (separator_pos != -1) {\n\t\tstrbuf_add(tok, trailer, separator_pos);\n\t\tstrbuf_trim(tok);\n\t\tstrbuf_addstr(val, trailer + separator_pos + 1);\n\t\tstrbuf_trim(val);\n\t} else {\n\t\tstrbuf_addstr(tok, trailer);\n\t\tstrbuf_trim(tok);\n\t}\n\n\t/* Lookup if the token matches something in the config */\n\ttok_len = token_len_without_separator(tok->buf, tok->len);\n\tif (conf)\n\t\t*conf = &default_conf_info;\n\tlist_for_each(pos, &conf_head) {\n\t\titem = list_entry(pos, struct arg_item, list);\n\t\tif (token_matches_item(tok->buf, item, tok_len)) {\n\t\t\tchar *tok_buf = strbuf_detach(tok, NULL);\n\t\t\tif (conf)\n\t\t\t\t*conf = &item->conf;\n\t\t\tstrbuf_addstr(tok, token_from_item(item, tok_buf));\n\t\t\tfree(tok_buf);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic struct trailer_item *add_trailer_item(struct list_head *head, char *tok,\n\t\t\t\t\t     char *val)\n{\n\tstruct trailer_item *new_item = xcalloc(1, sizeof(*new_item));\n\tnew_item->token = tok;\n\tnew_item->value = val;\n\tlist_add_tail(&new_item->list, head);\n\treturn new_item;\n}\n\nstatic void add_arg_item(struct list_head *arg_head, char *tok, char *val,\n\t\t\t const struct conf_info *conf,\n\t\t\t const struct new_trailer_item *new_trailer_item)\n{\n\tstruct arg_item *new_item = xcalloc(1, sizeof(*new_item));\n\tnew_item->token = tok;\n\tnew_item->value = val;\n\tduplicate_conf(&new_item->conf, conf);\n\tif (new_trailer_item) {\n\t\tif (new_trailer_item->where != WHERE_DEFAULT)\n\t\t\tnew_item->conf.where = new_trailer_item->where;\n\t\tif (new_trailer_item->if_exists != EXISTS_DEFAULT)\n\t\t\tnew_item->conf.if_exists = new_trailer_item->if_exists;\n\t\tif (new_trailer_item->if_missing != MISSING_DEFAULT)\n\t\t\tnew_item->conf.if_missing = new_trailer_item->if_missing;\n\t}\n\tlist_add_tail(&new_item->list, arg_head);\n}\n\nstatic void parse_trailers_from_config(struct list_head *config_head)\n{\n\tstruct arg_item *item;\n\tstruct list_head *pos;\n\n\t/* Add an arg item for each configured trailer with a command */\n\tlist_for_each(pos, &conf_head) {\n\t\titem = list_entry(pos, struct arg_item, list);\n\t\tif (item->conf.command)\n\t\t\tadd_arg_item(config_head,\n\t\t\t\t     xstrdup(token_from_item(item, NULL)),\n\t\t\t\t     xstrdup(\"\"),\n\t\t\t\t     &item->conf, NULL);\n\t}\n}\n\nstatic void parse_trailers_from_command_line_args(struct list_head *arg_head,\n\t\t\t\t\t\t  struct list_head *new_trailer_head)\n{\n\tstruct strbuf tok = STRBUF_INIT;\n\tstruct strbuf val = STRBUF_INIT;\n\tconst struct conf_info *conf;\n\tstruct list_head *pos;\n\n\t/*\n\t * In command-line arguments, '=' is accepted (in addition to the\n\t * separators that are defined).\n\t */\n\tchar *cl_separators = xstrfmt(\"=%s\", separators);\n\n\t/* Add an arg item for each trailer on the command line */\n\tlist_for_each(pos, new_trailer_head) {\n\t\tstruct new_trailer_item *tr =\n\t\t\tlist_entry(pos, struct new_trailer_item, list);\n\t\tssize_t separator_pos = find_separator(tr->text, cl_separators);\n\n\t\tif (separator_pos == 0) {\n\t\t\tstruct strbuf sb = STRBUF_INIT;\n\t\t\tstrbuf_addstr(&sb, tr->text);\n\t\t\tstrbuf_trim(&sb);\n\t\t\terror(_(\"empty trailer token in trailer '%.*s'\"),\n\t\t\t      (int) sb.len, sb.buf);\n\t\t\tstrbuf_release(&sb);\n\t\t} else {\n\t\t\tparse_trailer(&tok, &val, &conf, tr->text,\n\t\t\t\t      separator_pos);\n\t\t\tadd_arg_item(arg_head,\n\t\t\t\t     strbuf_detach(&tok, NULL),\n\t\t\t\t     strbuf_detach(&val, NULL),\n\t\t\t\t     conf, tr);\n\t\t}\n\t}\n\n\tfree(cl_separators);\n}\n\nstatic void read_input_file(struct strbuf *sb, const char *file)\n{\n\tif (file) {\n\t\tif (strbuf_read_file(sb, file, 0) < 0)\n\t\t\tdie_errno(_(\"could not read input file '%s'\"), file);\n\t} else {\n\t\tif (strbuf_read(sb, fileno(stdin), 0) < 0)\n\t\t\tdie_errno(_(\"could not read from stdin\"));\n\t}\n}\n\nstatic const char *next_line(const char *str)\n{\n\tconst char *nl = strchrnul(str, '\\n');\n\treturn nl + !!*nl;\n}\n\n/*\n * Return the position of the start of the last line. If len is 0, return -1.\n */\nstatic ssize_t last_line(const char *buf, size_t len)\n{\n\tssize_t i;\n\tif (len == 0)\n\t\treturn -1;\n\tif (len == 1)\n\t\treturn 0;\n\t/*\n\t * Skip the last character (in addition to the null terminator),\n\t * because if the last character is a newline, it is considered as part\n\t * of the last line anyway.\n\t */\n\ti = len - 2;\n\n\tfor (; i >= 0; i--) {\n\t\tif (buf[i] == '\\n')\n\t\t\treturn i + 1;\n\t}\n\treturn 0;\n}\n\n/*\n * Find the end of the log message as an offset from the start of the input\n * (where callers of this function are interested in looking for a trailers\n * block in the same input). We have to consider two categories of content that\n * can come at the end of the input which we want to ignore (because they don't\n * belong in the log message):\n *\n * (1) the \"patch part\" which begins with a \"---\" divider and has patch\n * information (like the output of git-format-patch), and\n *\n * (2) any trailing comment lines, blank lines like in the output of \"git\n * commit -v\", or stuff below the \"cut\" (scissor) line.\n *\n * As a formula, the situation looks like this:\n *\n *     INPUT = LOG MESSAGE + IGNORED\n *\n * where IGNORED can be either of the two categories described above. It may be\n * that there is nothing to ignore. Now it may be the case that the LOG MESSAGE\n * contains a trailer block, but that's not the concern of this function.\n */\nstatic size_t find_end_of_log_message(const char *input, int no_divider)\n{\n\tsize_t end;\n\tconst char *s;\n\n\t/* Assume the naive end of the input is already what we want. */\n\tend = strlen(input);\n\n\t/* Optionally skip over any patch part (\"---\" line and below). */\n\tif (!no_divider) {\n\t\tfor (s = input; *s; s = next_line(s)) {\n\t\t\tconst char *v;\n\n\t\t\tif (skip_prefix(s, \"---\", &v) && isspace(*v)) {\n\t\t\t\tend = s - input;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Skip over other ignorable bits. */\n\treturn end - ignored_log_message_bytes(input, end);\n}\n\n/*\n * Return the position of the first trailer line or len if there are no\n * trailers.\n */\nstatic size_t find_trailer_block_start(const char *buf, size_t len)\n{\n\tconst char *s;\n\tssize_t end_of_title, l;\n\tint only_spaces = 1;\n\tint recognized_prefix = 0, trailer_lines = 0, non_trailer_lines = 0;\n\t/*\n\t * Number of possible continuation lines encountered. This will be\n\t * reset to 0 if we encounter a trailer (since those lines are to be\n\t * considered continuations of that trailer), and added to\n\t * non_trailer_lines if we encounter a non-trailer (since those lines\n\t * are to be considered non-trailers).\n\t */\n\tint possible_continuation_lines = 0;\n\n\t/* The first paragraph is the title and cannot be trailers */\n\tfor (s = buf; s < buf + len; s = next_line(s)) {\n\t\tif (s[0] == comment_line_char)\n\t\t\tcontinue;\n\t\tif (is_blank_line(s))\n\t\t\tbreak;\n\t}\n\tend_of_title = s - buf;\n\n\t/*\n\t * Get the start of the trailers by looking starting from the end for a\n\t * blank line before a set of non-blank lines that (i) are all\n\t * trailers, or (ii) contains at least one Git-generated trailer and\n\t * consists of at least 25% trailers.\n\t */\n\tfor (l = last_line(buf, len);\n\t     l >= end_of_title;\n\t     l = last_line(buf, l)) {\n\t\tconst char *bol = buf + l;\n\t\tconst char **p;\n\t\tssize_t separator_pos;\n\n\t\tif (bol[0] == comment_line_char) {\n\t\t\tnon_trailer_lines += possible_continuation_lines;\n\t\t\tpossible_continuation_lines = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (is_blank_line(bol)) {\n\t\t\tif (only_spaces)\n\t\t\t\tcontinue;\n\t\t\tnon_trailer_lines += possible_continuation_lines;\n\t\t\tif (recognized_prefix &&\n\t\t\t    trailer_lines * 3 >= non_trailer_lines)\n\t\t\t\treturn next_line(bol) - buf;\n\t\t\telse if (trailer_lines && !non_trailer_lines)\n\t\t\t\treturn next_line(bol) - buf;\n\t\t\treturn len;\n\t\t}\n\t\tonly_spaces = 0;\n\n\t\tfor (p = git_generated_prefixes; *p; p++) {\n\t\t\tif (starts_with(bol, *p)) {\n\t\t\t\ttrailer_lines++;\n\t\t\t\tpossible_continuation_lines = 0;\n\t\t\t\trecognized_prefix = 1;\n\t\t\t\tgoto continue_outer_loop;\n\t\t\t}\n\t\t}\n\n\t\tseparator_pos = find_separator(bol, separators);\n\t\tif (separator_pos >= 1 && !isspace(bol[0])) {\n\t\t\tstruct list_head *pos;\n\n\t\t\ttrailer_lines++;\n\t\t\tpossible_continuation_lines = 0;\n\t\t\tif (recognized_prefix)\n\t\t\t\tcontinue;\n\t\t\tlist_for_each(pos, &conf_head) {\n\t\t\t\tstruct arg_item *item;\n\t\t\t\titem = list_entry(pos, struct arg_item, list);\n\t\t\t\tif (token_matches_item(bol, item,\n\t\t\t\t\t\t       separator_pos)) {\n\t\t\t\t\trecognized_prefix = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isspace(bol[0]))\n\t\t\tpossible_continuation_lines++;\n\t\telse {\n\t\t\tnon_trailer_lines++;\n\t\t\tnon_trailer_lines += possible_continuation_lines;\n\t\t\tpossible_continuation_lines = 0;\n\t\t}\ncontinue_outer_loop:\n\t\t;\n\t}\n\n\treturn len;\n}\n\nstatic int ends_with_blank_line(const char *buf, size_t len)\n{\n\tssize_t ll = last_line(buf, len);\n\tif (ll < 0)\n\t\treturn 0;\n\treturn is_blank_line(buf + ll);\n}\n\nstatic void unfold_value(struct strbuf *val)\n{\n\tstruct strbuf out = STRBUF_INIT;\n\tsize_t i;\n\n\tstrbuf_grow(&out, val->len);\n\ti = 0;\n\twhile (i < val->len) {\n\t\tchar c = val->buf[i++];\n\t\tif (c == '\\n') {\n\t\t\t/* Collapse continuation down to a single space. */\n\t\t\twhile (i < val->len && isspace(val->buf[i]))\n\t\t\t\ti++;\n\t\t\tstrbuf_addch(&out, ' ');\n\t\t} else {\n\t\t\tstrbuf_addch(&out, c);\n\t\t}\n\t}\n\n\t/* Empty lines may have left us with whitespace cruft at the edges */\n\tstrbuf_trim(&out);\n\n\t/* output goes back to val as if we modified it in-place */\n\tstrbuf_swap(&out, val);\n\tstrbuf_release(&out);\n}\n\n/*\n * Parse trailers in \"str\", populating the trailer info and \"head\"\n * linked list structure.\n */\nstatic void parse_trailers(struct trailer_info *info,\n\t\t\t     const char *str,\n\t\t\t     struct list_head *head,\n\t\t\t     const struct process_trailer_options *opts)\n{\n\tstruct strbuf tok = STRBUF_INIT;\n\tstruct strbuf val = STRBUF_INIT;\n\tsize_t i;\n\n\ttrailer_info_get(info, str, opts);\n\n\tfor (i = 0; i < info->trailer_nr; i++) {\n\t\tint separator_pos;\n\t\tchar *trailer = info->trailers[i];\n\t\tif (trailer[0] == comment_line_char)\n\t\t\tcontinue;\n\t\tseparator_pos = find_separator(trailer, separators);\n\t\tif (separator_pos >= 1) {\n\t\t\tparse_trailer(&tok, &val, NULL, trailer,\n\t\t\t\t      separator_pos);\n\t\t\tif (opts->unfold)\n\t\t\t\tunfold_value(&val);\n\t\t\tadd_trailer_item(head,\n\t\t\t\t\t strbuf_detach(&tok, NULL),\n\t\t\t\t\t strbuf_detach(&val, NULL));\n\t\t} else if (!opts->only_trailers) {\n\t\t\tstrbuf_addstr(&val, trailer);\n\t\t\tstrbuf_strip_suffix(&val, \"\\n\");\n\t\t\tadd_trailer_item(head,\n\t\t\t\t\t NULL,\n\t\t\t\t\t strbuf_detach(&val, NULL));\n\t\t}\n\t}\n}\n\nstatic void free_all(struct list_head *head)\n{\n\tstruct list_head *pos, *p;\n\tlist_for_each_safe(pos, p, head) {\n\t\tlist_del(pos);\n\t\tfree_trailer_item(list_entry(pos, struct trailer_item, list));\n\t}\n}\n\nstatic struct tempfile *trailers_tempfile;\n\nstatic FILE *create_in_place_tempfile(const char *file)\n{\n\tstruct stat st;\n\tstruct strbuf filename_template = STRBUF_INIT;\n\tconst char *tail;\n\tFILE *outfile;\n\n\tif (stat(file, &st))\n\t\tdie_errno(_(\"could not stat %s\"), file);\n\tif (!S_ISREG(st.st_mode))\n\t\tdie(_(\"file %s is not a regular file\"), file);\n\tif (!(st.st_mode & S_IWUSR))\n\t\tdie(_(\"file %s is not writable by user\"), file);\n\n\t/* Create temporary file in the same directory as the original */\n\ttail = strrchr(file, '/');\n\tif (tail)\n\t\tstrbuf_add(&filename_template, file, tail - file + 1);\n\tstrbuf_addstr(&filename_template, \"git-interpret-trailers-XXXXXX\");\n\n\ttrailers_tempfile = xmks_tempfile_m(filename_template.buf, st.st_mode);\n\tstrbuf_release(&filename_template);\n\toutfile = fdopen_tempfile(trailers_tempfile, \"w\");\n\tif (!outfile)\n\t\tdie_errno(_(\"could not open temporary file\"));\n\n\treturn outfile;\n}\n\nvoid process_trailers(const char *file,\n\t\t      const struct process_trailer_options *opts,\n\t\t      struct list_head *new_trailer_head)\n{\n\tLIST_HEAD(head);\n\tstruct strbuf sb = STRBUF_INIT;\n\tstruct trailer_info info;\n\tFILE *outfile = stdout;\n\n\tensure_configured();\n\n\tread_input_file(&sb, file);\n\n\tif (opts->in_place)\n\t\toutfile = create_in_place_tempfile(file);\n\n\tparse_trailers(&info, sb.buf, &head, opts);\n\n\t/* Print the lines before the trailers */\n\tif (!opts->only_trailers)\n\t\tfwrite(sb.buf, 1, info.trailer_block_start, outfile);\n\n\tif (!opts->only_trailers && !info.blank_line_before_trailer)\n\t\tfprintf(outfile, \"\\n\");\n\n\n\tif (!opts->only_input) {\n\t\tLIST_HEAD(config_head);\n\t\tLIST_HEAD(arg_head);\n\t\tparse_trailers_from_config(&config_head);\n\t\tparse_trailers_from_command_line_args(&arg_head, new_trailer_head);\n\t\tlist_splice(&config_head, &arg_head);\n\t\tprocess_trailers_lists(&head, &arg_head);\n\t}\n\n\tprint_all(outfile, &head, opts);\n\n\tfree_all(&head);\n\ttrailer_info_release(&info);\n\n\t/* Print the lines after the trailers as is */\n\tif (!opts->only_trailers)\n\t\tfwrite(sb.buf + info.trailer_block_end, 1, sb.len - info.trailer_block_end, outfile);\n\n\tif (opts->in_place)\n\t\tif (rename_tempfile(&trailers_tempfile, file))\n\t\t\tdie_errno(_(\"could not rename temporary file to %s\"), file);\n\n\tstrbuf_release(&sb);\n}\n\nvoid trailer_info_get(struct trailer_info *info, const char *str,\n\t\t      const struct process_trailer_options *opts)\n{\n\tsize_t end_of_log_message = 0, trailer_block_start = 0;\n\tstruct strbuf **trailer_lines, **ptr;\n\tchar **trailer_strings = NULL;\n\tsize_t nr = 0, alloc = 0;\n\tchar **last = NULL;\n\n\tensure_configured();\n\n\tend_of_log_message = find_end_of_log_message(str, opts->no_divider);\n\ttrailer_block_start = find_trailer_block_start(str, end_of_log_message);\n\n\ttrailer_lines = strbuf_split_buf(str + trailer_block_start,\n\t\t\t\t\t end_of_log_message - trailer_block_start,\n\t\t\t\t\t '\\n',\n\t\t\t\t\t 0);\n\tfor (ptr = trailer_lines; *ptr; ptr++) {\n\t\tif (last && isspace((*ptr)->buf[0])) {\n\t\t\tstruct strbuf sb = STRBUF_INIT;\n\t\t\tstrbuf_attach(&sb, *last, strlen(*last), strlen(*last));\n\t\t\tstrbuf_addbuf(&sb, *ptr);\n\t\t\t*last = strbuf_detach(&sb, NULL);\n\t\t\tcontinue;\n\t\t}\n\t\tALLOC_GROW(trailer_strings, nr + 1, alloc);\n\t\ttrailer_strings[nr] = strbuf_detach(*ptr, NULL);\n\t\tlast = find_separator(trailer_strings[nr], separators) >= 1\n\t\t\t? &trailer_strings[nr]\n\t\t\t: NULL;\n\t\tnr++;\n\t}\n\tstrbuf_list_free(trailer_lines);\n\n\tinfo->blank_line_before_trailer = ends_with_blank_line(str,\n\t\t\t\t\t\t\t       trailer_block_start);\n\tinfo->trailer_block_start = trailer_block_start;\n\tinfo->trailer_block_end = end_of_log_message;\n\tinfo->trailers = trailer_strings;\n\tinfo->trailer_nr = nr;\n}\n\nvoid trailer_info_release(struct trailer_info *info)\n{\n\tsize_t i;\n\tfor (i = 0; i < info->trailer_nr; i++)\n\t\tfree(info->trailers[i]);\n\tfree(info->trailers);\n}\n\nstatic void format_trailer_info(struct strbuf *out,\n\t\t\t\tconst struct trailer_info *info,\n\t\t\t\tconst char *msg,\n\t\t\t\tconst struct process_trailer_options *opts)\n{\n\tsize_t origlen = out->len;\n\tsize_t i;\n\n\t/* If we want the whole block untouched, we can take the fast path. */\n\tif (!opts->only_trailers && !opts->unfold && !opts->filter &&\n\t    !opts->separator && !opts->key_only && !opts->value_only &&\n\t    !opts->key_value_separator) {\n\t\tstrbuf_add(out, msg + info->trailer_block_start,\n\t\t\t   info->trailer_block_end - info->trailer_block_start);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < info->trailer_nr; i++) {\n\t\tchar *trailer = info->trailers[i];\n\t\tssize_t separator_pos = find_separator(trailer, separators);\n\n\t\tif (separator_pos >= 1) {\n\t\t\tstruct strbuf tok = STRBUF_INIT;\n\t\t\tstruct strbuf val = STRBUF_INIT;\n\n\t\t\tparse_trailer(&tok, &val, NULL, trailer, separator_pos);\n\t\t\tif (!opts->filter || opts->filter(&tok, opts->filter_data)) {\n\t\t\t\tif (opts->unfold)\n\t\t\t\t\tunfold_value(&val);\n\n\t\t\t\tif (opts->separator && out->len != origlen)\n\t\t\t\t\tstrbuf_addbuf(out, opts->separator);\n\t\t\t\tif (!opts->value_only)\n\t\t\t\t\tstrbuf_addbuf(out, &tok);\n\t\t\t\tif (!opts->key_only && !opts->value_only) {\n\t\t\t\t\tif (opts->key_value_separator)\n\t\t\t\t\t\tstrbuf_addbuf(out, opts->key_value_separator);\n\t\t\t\t\telse\n\t\t\t\t\t\tstrbuf_addstr(out, \": \");\n\t\t\t\t}\n\t\t\t\tif (!opts->key_only)\n\t\t\t\t\tstrbuf_addbuf(out, &val);\n\t\t\t\tif (!opts->separator)\n\t\t\t\t\tstrbuf_addch(out, '\\n');\n\t\t\t}\n\t\t\tstrbuf_release(&tok);\n\t\t\tstrbuf_release(&val);\n\n\t\t} else if (!opts->only_trailers) {\n\t\t\tif (opts->separator && out->len != origlen) {\n\t\t\t\tstrbuf_addbuf(out, opts->separator);\n\t\t\t}\n\t\t\tstrbuf_addstr(out, trailer);\n\t\t\tif (opts->separator) {\n\t\t\t\tstrbuf_rtrim(out);\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nvoid format_trailers_from_commit(struct strbuf *out, const char *msg,\n\t\t\t\t const struct process_trailer_options *opts)\n{\n\tstruct trailer_info info;\n\n\ttrailer_info_get(&info, msg, opts);\n\tformat_trailer_info(out, &info, msg, opts);\n\ttrailer_info_release(&info);\n}\n\nvoid trailer_iterator_init(struct trailer_iterator *iter, const char *msg)\n{\n\tstruct process_trailer_options opts = PROCESS_TRAILER_OPTIONS_INIT;\n\tstrbuf_init(&iter->key, 0);\n\tstrbuf_init(&iter->val, 0);\n\topts.no_divider = 1;\n\ttrailer_info_get(&iter->internal.info, msg, &opts);\n\titer->internal.cur = 0;\n}\n\nint trailer_iterator_advance(struct trailer_iterator *iter)\n{\n\twhile (iter->internal.cur < iter->internal.info.trailer_nr) {\n\t\tchar *trailer = iter->internal.info.trailers[iter->internal.cur++];\n\t\tint separator_pos = find_separator(trailer, separators);\n\n\t\tif (separator_pos < 1)\n\t\t\tcontinue; /* not a real trailer */\n\n\t\tstrbuf_reset(&iter->key);\n\t\tstrbuf_reset(&iter->val);\n\t\tparse_trailer(&iter->key, &iter->val, NULL,\n\t\t\t      trailer, separator_pos);\n\t\tunfold_value(&iter->val);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nvoid trailer_iterator_release(struct trailer_iterator *iter)\n{\n\ttrailer_info_release(&iter->internal.info);\n\tstrbuf_release(&iter->val);\n\tstrbuf_release(&iter->key);\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "009ee80deec8c16d5336dd52c751f3b6cd7cfa3e",
  "sha1_ok": true,
  "size": 33322
}
