{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJwYXRoLWxpc3QuaCIKI2luY2x1ZGUgInhkaWZmL3hkaWZmLmgiCiNpbmNsdWRlICJ4ZGlmZi1pbnRlcmZhY2UuaCIKCiNpbmNsdWRlIDx0aW1lLmg+CgpzdGF0aWMgY29uc3QgY2hhciBnaXRfcmVyZXJlX3VzYWdlW10gPQoiZ2l0LXJlcmVyZSBbY2xlYXIgfCBzdGF0dXMgfCBkaWZmIHwgZ2NdIjsKCi8qIHRoZXNlIHZhbHVlcyBhcmUgZGF5cyAqLwpzdGF0aWMgaW50IGN1dG9mZl9ub3Jlc29sdmUgPSAxNTsKc3RhdGljIGludCBjdXRvZmZfcmVzb2x2ZSA9IDYwOwoKc3RhdGljIGNoYXIgKm1lcmdlX3JyX3BhdGg7CgpzdGF0aWMgY29uc3QgY2hhciAqcnJfcGF0aChjb25zdCBjaGFyICpuYW1lLCBjb25zdCBjaGFyICpmaWxlKQp7CglyZXR1cm4gZ2l0X3BhdGgoInJyLWNhY2hlLyVzLyVzIiwgbmFtZSwgZmlsZSk7Cn0KCnN0YXRpYyB2b2lkIHJlYWRfcnIoc3RydWN0IHBhdGhfbGlzdCAqcnIpCnsKCXVuc2lnbmVkIGNoYXIgc2hhMVsyMF07CgljaGFyIGJ1ZltQQVRIX01BWF07CglGSUxFICppbiA9IGZvcGVuKG1lcmdlX3JyX3BhdGgsICJyIik7CglpZiAoIWluKQoJCXJldHVybjsKCXdoaWxlIChmcmVhZChidWYsIDQwLCAxLCBpbikgPT0gMSkgewoJCWludCBpOwoJCWNoYXIgKm5hbWU7CgkJaWYgKGdldF9zaGExX2hleChidWYsIHNoYTEpKQoJCQlkaWUoImNvcnJ1cHQgTUVSR0VfUlIiKTsKCQlidWZbNDBdID0gJ1wwJzsKCQluYW1lID0geHN0cmR1cChidWYpOwoJCWlmIChmZ2V0YyhpbikgIT0gJ1x0JykKCQkJZGllKCJjb3JydXB0IE1FUkdFX1JSIik7CgkJZm9yIChpID0gMDsgaSA8IHNpemVvZihidWYpICYmIChidWZbaV0gPSBmZ2V0YyhpbikpOyBpKyspCgkJCTsgLyogZG8gbm90aGluZyAqLwoJCWlmIChpID09IHNpemVvZihidWYpKQoJCQlkaWUoImZpbGVuYW1lIHRvbyBsb25nIik7CgkJcGF0aF9saXN0X2luc2VydChidWYsIHJyKS0+dXRpbCA9IHhzdHJkdXAobmFtZSk7Cgl9CglmY2xvc2UoaW4pOwp9CgpzdGF0aWMgc3RydWN0IGxvY2tfZmlsZSB3cml0ZV9sb2NrOwoKc3RhdGljIGludCB3cml0ZV9ycihzdHJ1Y3QgcGF0aF9saXN0ICpyciwgaW50IG91dF9mZCkKewoJaW50IGk7Cglmb3IgKGkgPSAwOyBpIDwgcnItPm5yOyBpKyspIHsKCQljb25zdCBjaGFyICpwYXRoID0gcnItPml0ZW1zW2ldLnBhdGg7CgkJaW50IGxlbmd0aCA9IHN0cmxlbihwYXRoKSArIDE7CgkJaWYgKHdyaXRlX2luX2Z1bGwob3V0X2ZkLCByci0+aXRlbXNbaV0udXRpbCwgNDApICE9IDQwIHx8CgkJICAgIHdyaXRlX2luX2Z1bGwob3V0X2ZkLCAiXHQiLCAxKSAhPSAxIHx8CgkJICAgIHdyaXRlX2luX2Z1bGwob3V0X2ZkLCBwYXRoLCBsZW5ndGgpICE9IGxlbmd0aCkKCQkJZGllKCJ1bmFibGUgdG8gd3JpdGUgcmVyZXJlIHJlY29yZCIpOwoJfQoJY2xvc2Uob3V0X2ZkKTsKCXJldHVybiBjb21taXRfbG9ja19maWxlKCZ3cml0ZV9sb2NrKTsKfQoKc3RydWN0IGJ1ZmZlciB7CgljaGFyICpwdHI7CglpbnQgbnIsIGFsbG9jOwp9OwoKc3RhdGljIHZvaWQgYXBwZW5kX2xpbmUoc3RydWN0IGJ1ZmZlciAqYnVmZmVyLCBjb25zdCBjaGFyICpsaW5lKQp7CglpbnQgbGVuID0gc3RybGVuKGxpbmUpOwoKCWlmIChidWZmZXItPm5yICsgbGVuID4gYnVmZmVyLT5hbGxvYykgewoJCWJ1ZmZlci0+YWxsb2MgPSBhbGxvY19ucihidWZmZXItPm5yICsgbGVuKTsKCQlidWZmZXItPnB0ciA9IHhyZWFsbG9jKGJ1ZmZlci0+cHRyLCBidWZmZXItPmFsbG9jKTsKCX0KCW1lbWNweShidWZmZXItPnB0ciArIGJ1ZmZlci0+bnIsIGxpbmUsIGxlbik7CglidWZmZXItPm5yICs9IGxlbjsKfQoKc3RhdGljIHZvaWQgY2xlYXJfYnVmZmVyKHN0cnVjdCBidWZmZXIgKmJ1ZmZlcikKewoJZnJlZShidWZmZXItPnB0cik7CglidWZmZXItPnB0ciA9IE5VTEw7CglidWZmZXItPm5yID0gYnVmZmVyLT5hbGxvYyA9IDA7Cn0KCnN0YXRpYyBpbnQgaGFuZGxlX2ZpbGUoY29uc3QgY2hhciAqcGF0aCwKCSB1bnNpZ25lZCBjaGFyICpzaGExLCBjb25zdCBjaGFyICpvdXRwdXQpCnsKCVNIQV9DVFggY3R4OwoJY2hhciBidWZbMTAyNF07CglpbnQgaHVuayA9IDAsIGh1bmtfbm8gPSAwOwoJc3RydWN0IGJ1ZmZlciBtaW51cyA9IHsgTlVMTCwgMCwgMCB9LCBwbHVzID0geyBOVUxMLCAwLCAwIH07CglzdHJ1Y3QgYnVmZmVyICpvbmUgPSAmbWludXMsICp0d28gPSAmcGx1czsKCUZJTEUgKmYgPSBmb3BlbihwYXRoLCAiciIpOwoJRklMRSAqb3V0OwoKCWlmICghZikKCQlyZXR1cm4gZXJyb3IoIkNvdWxkIG5vdCBvcGVuICVzIiwgcGF0aCk7CgoJaWYgKG91dHB1dCkgewoJCW91dCA9IGZvcGVuKG91dHB1dCwgInciKTsKCQlpZiAoIW91dCkgewoJCQlmY2xvc2UoZik7CgkJCXJldHVybiBlcnJvcigiQ291bGQgbm90IHdyaXRlICVzIiwgb3V0cHV0KTsKCQl9Cgl9IGVsc2UKCQlvdXQgPSBOVUxMOwoKCWlmIChzaGExKQoJCVNIQTFfSW5pdCgmY3R4KTsKCgl3aGlsZSAoZmdldHMoYnVmLCBzaXplb2YoYnVmKSwgZikpIHsKCQlpZiAoIXN0cm5jbXAoIjw8PDw8PDwgIiwgYnVmLCA4KSkKCQkJaHVuayA9IDE7CgkJZWxzZSBpZiAoIXN0cm5jbXAoIj09PT09PT0iLCBidWYsIDcpKQoJCQlodW5rID0gMjsKCQllbHNlIGlmICghc3RybmNtcCgiPj4+Pj4+PiAiLCBidWYsIDgpKSB7CgkJCWh1bmtfbm8rKzsKCQkJaHVuayA9IDA7CgkJCWlmIChtZW1jbXAob25lLT5wdHIsIHR3by0+cHRyLCBvbmUtPm5yIDwgdHdvLT5uciA/CgkJCQkJCW9uZS0+bnIgOiB0d28tPm5yKSA+IDApIHsKCQkJCXN0cnVjdCBidWZmZXIgKnN3YXAgPSBvbmU7CgkJCQlvbmUgPSB0d287CgkJCQl0d28gPSBzd2FwOwoJCQl9CgkJCWlmIChvdXQpIHsKCQkJCWZwdXRzKCI8PDw8PDw8XG4iLCBvdXQpOwoJCQkJZndyaXRlKG9uZS0+cHRyLCBvbmUtPm5yLCAxLCBvdXQpOwoJCQkJZnB1dHMoIj09PT09PT1cbiIsIG91dCk7CgkJCQlmd3JpdGUodHdvLT5wdHIsIHR3by0+bnIsIDEsIG91dCk7CgkJCQlmcHV0cygiPj4+Pj4+PlxuIiwgb3V0KTsKCQkJfQoJCQlpZiAoc2hhMSkgewoJCQkJU0hBMV9VcGRhdGUoJmN0eCwgb25lLT5wdHIsIG9uZS0+bnIpOwoJCQkJU0hBMV9VcGRhdGUoJmN0eCwgIlwwIiwgMSk7CgkJCQlTSEExX1VwZGF0ZSgmY3R4LCB0d28tPnB0ciwgdHdvLT5ucik7CgkJCQlTSEExX1VwZGF0ZSgmY3R4LCAiXDAiLCAxKTsKCQkJfQoJCQljbGVhcl9idWZmZXIob25lKTsKCQkJY2xlYXJfYnVmZmVyKHR3byk7CgkJfSBlbHNlIGlmIChodW5rID09IDEpCgkJCWFwcGVuZF9saW5lKG9uZSwgYnVmKTsKCQllbHNlIGlmIChodW5rID09IDIpCgkJCWFwcGVuZF9saW5lKHR3bywgYnVmKTsKCQllbHNlIGlmIChvdXQpCgkJCWZwdXRzKGJ1Ziwgb3V0KTsKCX0KCglmY2xvc2UoZik7CglpZiAob3V0KQoJCWZjbG9zZShvdXQpOwoJaWYgKHNoYTEpCgkJU0hBMV9GaW5hbChzaGExLCAmY3R4KTsKCXJldHVybiBodW5rX25vOwp9CgpzdGF0aWMgaW50IGZpbmRfY29uZmxpY3Qoc3RydWN0IHBhdGhfbGlzdCAqY29uZmxpY3QpCnsKCWludCBpOwoJaWYgKHJlYWRfY2FjaGUoKSA8IDApCgkJcmV0dXJuIGVycm9yKCJDb3VsZCBub3QgcmVhZCBpbmRleCIpOwoJZm9yIChpID0gMDsgaSArIDIgPCBhY3RpdmVfbnI7IGkrKykgewoJCXN0cnVjdCBjYWNoZV9lbnRyeSAqZTEgPSBhY3RpdmVfY2FjaGVbaV07CgkJc3RydWN0IGNhY2hlX2VudHJ5ICplMiA9IGFjdGl2ZV9jYWNoZVtpKzFdOwoJCXN0cnVjdCBjYWNoZV9lbnRyeSAqZTMgPSBhY3RpdmVfY2FjaGVbaSsyXTsKCQlpZiAoY2Vfc3RhZ2UoZTEpID09IDEgJiYKCQkgICAgY2Vfc3RhZ2UoZTIpID09IDIgJiYKCQkgICAgY2Vfc3RhZ2UoZTMpID09IDMgJiYKCQkgICAgY2Vfc2FtZV9uYW1lKGUxLCBlMikgJiYgY2Vfc2FtZV9uYW1lKGUxLCBlMykgJiYKCQkgICAgU19JU1JFRyhudG9obChlMS0+Y2VfbW9kZSkpICYmCgkJICAgIFNfSVNSRUcobnRvaGwoZTItPmNlX21vZGUpKSAmJgoJCSAgICBTX0lTUkVHKG50b2hsKGUzLT5jZV9tb2RlKSkpIHsKCQkJcGF0aF9saXN0X2luc2VydCgoY29uc3QgY2hhciAqKWUxLT5uYW1lLCBjb25mbGljdCk7CgkJCWkgKz0gMjsKCQl9Cgl9CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBtZXJnZShjb25zdCBjaGFyICpuYW1lLCBjb25zdCBjaGFyICpwYXRoKQp7CglpbnQgcmV0OwoJbW1maWxlX3QgY3VyLCBiYXNlLCBvdGhlcjsKCW1tYnVmZmVyX3QgcmVzdWx0ID0ge05VTEwsIDB9OwoJeHBwYXJhbV90IHhwcCA9IHtYREZfTkVFRF9NSU5JTUFMfTsKCglpZiAoaGFuZGxlX2ZpbGUocGF0aCwgTlVMTCwgcnJfcGF0aChuYW1lLCAidGhpc2ltYWdlIikpIDwgMCkKCQlyZXR1cm4gMTsKCglpZiAocmVhZF9tbWZpbGUoJmN1ciwgcnJfcGF0aChuYW1lLCAidGhpc2ltYWdlIikpIHx8CgkJCXJlYWRfbW1maWxlKCZiYXNlLCBycl9wYXRoKG5hbWUsICJwcmVpbWFnZSIpKSB8fAoJCQlyZWFkX21tZmlsZSgmb3RoZXIsIHJyX3BhdGgobmFtZSwgInBvc3RpbWFnZSIpKSkKCQlyZXR1cm4gMTsKCXJldCA9IHhkbF9tZXJnZSgmYmFzZSwgJmN1ciwgIiIsICZvdGhlciwgIiIsCgkJCSZ4cHAsIFhETF9NRVJHRV9aRUFMT1VTLCAmcmVzdWx0KTsKCWlmICghcmV0KSB7CgkJRklMRSAqZiA9IGZvcGVuKHBhdGgsICJ3Iik7CgkJaWYgKCFmKQoJCQlyZXR1cm4gZXJyb3IoIkNvdWxkIG5vdCB3cml0ZSB0byAlcyIsIHBhdGgpOwoJCWZ3cml0ZShyZXN1bHQucHRyLCByZXN1bHQuc2l6ZSwgMSwgZik7CgkJZmNsb3NlKGYpOwoJfQoKCWZyZWUoY3VyLnB0cik7CglmcmVlKGJhc2UucHRyKTsKCWZyZWUob3RoZXIucHRyKTsKCWZyZWUocmVzdWx0LnB0cik7CgoJcmV0dXJuIHJldDsKfQoKc3RhdGljIHZvaWQgdW5saW5rX3JyX2l0ZW0oY29uc3QgY2hhciAqbmFtZSkKewoJdW5saW5rKHJyX3BhdGgobmFtZSwgInRoaXNpbWFnZSIpKTsKCXVubGluayhycl9wYXRoKG5hbWUsICJwcmVpbWFnZSIpKTsKCXVubGluayhycl9wYXRoKG5hbWUsICJwb3N0aW1hZ2UiKSk7CglybWRpcihnaXRfcGF0aCgicnItY2FjaGUvJXMiLCBuYW1lKSk7Cn0KCnN0YXRpYyB2b2lkIGdhcmJhZ2VfY29sbGVjdChzdHJ1Y3QgcGF0aF9saXN0ICpycikKewoJc3RydWN0IHBhdGhfbGlzdCB0b19yZW1vdmUgPSB7IE5VTEwsIDAsIDAsIDEgfTsKCWNoYXIgYnVmWzEwMjRdOwoJRElSICpkaXI7CglzdHJ1Y3QgZGlyZW50ICplOwoJaW50IGxlbiwgaSwgY3V0b2ZmOwoJdGltZV90IG5vdyA9IHRpbWUoTlVMTCksIHRoZW47CgoJc3RybGNweShidWYsIGdpdF9wYXRoKCJyci1jYWNoZSIpLCBzaXplb2YoYnVmKSk7CglsZW4gPSBzdHJsZW4oYnVmKTsKCWRpciA9IG9wZW5kaXIoYnVmKTsKCXN0cmNweShidWYgKyBsZW4rKywgIi8iKTsKCXdoaWxlICgoZSA9IHJlYWRkaXIoZGlyKSkpIHsKCQljb25zdCBjaGFyICpuYW1lID0gZS0+ZF9uYW1lOwoJCXN0cnVjdCBzdGF0IHN0OwoJCWlmIChuYW1lWzBdID09ICcuJyAmJiAobmFtZVsxXSA9PSAnXDAnIHx8CgkJCQkJKG5hbWVbMV0gPT0gJy4nICYmIG5hbWVbMl0gPT0gJ1wwJykpKQoJCQljb250aW51ZTsKCQlpID0gc25wcmludGYoYnVmICsgbGVuLCBzaXplb2YoYnVmKSAtIGxlbiwgIiVzIiwgbmFtZSk7CgkJc3RybGNweShidWYgKyBsZW4gKyBpLCAiL3ByZWltYWdlIiwgc2l6ZW9mKGJ1ZikgLSBsZW4gLSBpKTsKCQlpZiAoc3RhdChidWYsICZzdCkpCgkJCWNvbnRpbnVlOwoJCXRoZW4gPSBzdC5zdF9tdGltZTsKCQlzdHJsY3B5KGJ1ZiArIGxlbiArIGksICIvcG9zdGltYWdlIiwgc2l6ZW9mKGJ1ZikgLSBsZW4gLSBpKTsKCQljdXRvZmYgPSBzdGF0KGJ1ZiwgJnN0KSA/IGN1dG9mZl9ub3Jlc29sdmUgOiBjdXRvZmZfcmVzb2x2ZTsKCQlpZiAodGhlbiA8IG5vdyAtIGN1dG9mZiAqIDg2NDAwKSB7CgkJCWJ1ZltsZW4gKyBpXSA9ICdcMCc7CgkJCXBhdGhfbGlzdF9pbnNlcnQoeHN0cmR1cChuYW1lKSwgJnRvX3JlbW92ZSk7CgkJfQoJfQoJZm9yIChpID0gMDsgaSA8IHRvX3JlbW92ZS5ucjsgaSsrKQoJCXVubGlua19ycl9pdGVtKHRvX3JlbW92ZS5pdGVtc1tpXS5wYXRoKTsKCXBhdGhfbGlzdF9jbGVhcigmdG9fcmVtb3ZlLCAwKTsKfQoKc3RhdGljIGludCBvdXRmKHZvaWQgKmR1bW15LCBtbWJ1ZmZlcl90ICpwdHIsIGludCBuYnVmKQp7CglpbnQgaTsKCWZvciAoaSA9IDA7IGkgPCBuYnVmOyBpKyspCgkJaWYgKHdyaXRlX2luX2Z1bGwoMSwgcHRyW2ldLnB0ciwgcHRyW2ldLnNpemUpICE9IHB0cltpXS5zaXplKQoJCQlyZXR1cm4gLTE7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBkaWZmX3R3byhjb25zdCBjaGFyICpmaWxlMSwgY29uc3QgY2hhciAqbGFiZWwxLAoJCWNvbnN0IGNoYXIgKmZpbGUyLCBjb25zdCBjaGFyICpsYWJlbDIpCnsKCXhwcGFyYW1fdCB4cHA7Cgl4ZGVtaXRjb25mX3QgeGVjZmc7Cgl4ZGVtaXRjYl90IGVjYjsKCW1tZmlsZV90IG1pbnVzLCBwbHVzOwoKCWlmIChyZWFkX21tZmlsZSgmbWludXMsIGZpbGUxKSB8fCByZWFkX21tZmlsZSgmcGx1cywgZmlsZTIpKQoJCXJldHVybiAxOwoKCXByaW50ZigiLS0tIGEvJXNcbisrKyBiLyVzXG4iLCBsYWJlbDEsIGxhYmVsMik7CglmZmx1c2goc3Rkb3V0KTsKCXhwcC5mbGFncyA9IFhERl9ORUVEX01JTklNQUw7Cgl4ZWNmZy5jdHhsZW4gPSAzOwoJeGVjZmcuZmxhZ3MgPSAwOwoJZWNiLm91dGYgPSBvdXRmOwoJeGRsX2RpZmYoJm1pbnVzLCAmcGx1cywgJnhwcCwgJnhlY2ZnLCAmZWNiKTsKCglmcmVlKG1pbnVzLnB0cik7CglmcmVlKHBsdXMucHRyKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGNvcHlfZmlsZShjb25zdCBjaGFyICpzcmMsIGNvbnN0IGNoYXIgKmRlc3QpCnsKCUZJTEUgKmluLCAqb3V0OwoJY2hhciBidWZmZXJbMzI3NjhdOwoJaW50IGNvdW50OwoKCWlmICghKGluID0gZm9wZW4oc3JjLCAiciIpKSkKCQlyZXR1cm4gZXJyb3IoIkNvdWxkIG5vdCBvcGVuICVzIiwgc3JjKTsKCWlmICghKG91dCA9IGZvcGVuKGRlc3QsICJ3IikpKQoJCXJldHVybiBlcnJvcigiQ291bGQgbm90IG9wZW4gJXMiLCBkZXN0KTsKCXdoaWxlICgoY291bnQgPSBmcmVhZChidWZmZXIsIDEsIHNpemVvZihidWZmZXIpLCBpbikpKQoJCWZ3cml0ZShidWZmZXIsIDEsIGNvdW50LCBvdXQpOwoJZmNsb3NlKGluKTsKCWZjbG9zZShvdXQpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgZG9fcGxhaW5fcmVyZXJlKHN0cnVjdCBwYXRoX2xpc3QgKnJyLCBpbnQgZmQpCnsKCXN0cnVjdCBwYXRoX2xpc3QgY29uZmxpY3QgPSB7IE5VTEwsIDAsIDAsIDEgfTsKCWludCBpOwoKCWZpbmRfY29uZmxpY3QoJmNvbmZsaWN0KTsKCgkvKgoJICogTUVSR0VfUlIgcmVjb3JkcyBwYXRocyB3aXRoIGNvbmZsaWN0cyBpbW1lZGlhdGVseSBhZnRlciBtZXJnZQoJICogZmFpbGVkLiAgU29tZSBvZiB0aGUgY29uZmxpY3RlZCBwYXRocyBtaWdodCBoYXZlIGJlZW4gaGFuZCByZXNvbHZlZAoJICogaW4gdGhlIHdvcmtpbmcgdHJlZSBzaW5jZSB0aGVuLCBidXQgdGhlIGluaXRpYWwgcnVuIHdvdWxkIGNhdGNoIGFsbAoJICogYW5kIHJlZ2lzdGVyIHRoZWlyIHByZWltYWdlcy4KCSAqLwoKCWZvciAoaSA9IDA7IGkgPCBjb25mbGljdC5ucjsgaSsrKSB7CgkJY29uc3QgY2hhciAqcGF0aCA9IGNvbmZsaWN0Lml0ZW1zW2ldLnBhdGg7CgkJaWYgKCFwYXRoX2xpc3RfaGFzX3BhdGgocnIsIHBhdGgpKSB7CgkJCXVuc2lnbmVkIGNoYXIgc2hhMVsyMF07CgkJCWNoYXIgKmhleDsKCQkJaW50IHJldDsKCQkJcmV0ID0gaGFuZGxlX2ZpbGUocGF0aCwgc2hhMSwgTlVMTCk7CgkJCWlmIChyZXQgPCAxKQoJCQkJY29udGludWU7CgkJCWhleCA9IHhzdHJkdXAoc2hhMV90b19oZXgoc2hhMSkpOwoJCQlwYXRoX2xpc3RfaW5zZXJ0KHBhdGgsIHJyKS0+dXRpbCA9IGhleDsKCQkJaWYgKG1rZGlyKGdpdF9wYXRoKCJyci1jYWNoZS8lcyIsIGhleCksIDA3NTUpKQoJCQkJY29udGludWU7OwoJCQloYW5kbGVfZmlsZShwYXRoLCBOVUxMLCBycl9wYXRoKGhleCwgInByZWltYWdlIikpOwoJCQlmcHJpbnRmKHN0ZGVyciwgIlJlY29yZGVkIHByZWltYWdlIGZvciAnJXMnXG4iLCBwYXRoKTsKCQl9Cgl9CgoJLyoKCSAqIE5vdyBzb21lIG9mIHRoZSBwYXRocyB0aGF0IGhhZCBjb25mbGljdHMgZWFybGllciBtaWdodCBoYXZlIGJlZW4KCSAqIGhhbmQgcmVzb2x2ZWQuICBPdGhlcnMgbWF5IGJlIHNpbWlsYXIgdG8gYSBjb25mbGljdCBhbHJlYWR5IHRoYXQKCSAqIHdhcyByZXNvbHZlZCBiZWZvcmUuCgkgKi8KCglmb3IgKGkgPSAwOyBpIDwgcnItPm5yOyBpKyspIHsKCQlzdHJ1Y3Qgc3RhdCBzdDsKCQlpbnQgcmV0OwoJCWNvbnN0IGNoYXIgKnBhdGggPSByci0+aXRlbXNbaV0ucGF0aDsKCQljb25zdCBjaGFyICpuYW1lID0gKGNvbnN0IGNoYXIgKilyci0+aXRlbXNbaV0udXRpbDsKCgkJaWYgKCFzdGF0KHJyX3BhdGgobmFtZSwgInByZWltYWdlIiksICZzdCkgJiYKCQkJCSFzdGF0KHJyX3BhdGgobmFtZSwgInBvc3RpbWFnZSIpLCAmc3QpKSB7CgkJCWlmICghbWVyZ2UobmFtZSwgcGF0aCkpIHsKCQkJCWZwcmludGYoc3RkZXJyLCAiUmVzb2x2ZWQgJyVzJyB1c2luZyAiCgkJCQkJCSJwcmV2aW91cyByZXNvbHV0aW9uLlxuIiwgcGF0aCk7CgkJCQlnb3RvIHRhaWxfb3B0aW1pemF0aW9uOwoJCQl9CgkJfQoKCQkvKiBMZXQncyBzZWUgaWYgd2UgaGF2ZSByZXNvbHZlZCBpdC4gKi8KCQlyZXQgPSBoYW5kbGVfZmlsZShwYXRoLCBOVUxMLCBOVUxMKTsKCQlpZiAocmV0KQoJCQljb250aW51ZTsKCgkJZnByaW50ZihzdGRlcnIsICJSZWNvcmRlZCByZXNvbHV0aW9uIGZvciAnJXMnLlxuIiwgcGF0aCk7CgkJY29weV9maWxlKHBhdGgsIHJyX3BhdGgobmFtZSwgInBvc3RpbWFnZSIpKTsKdGFpbF9vcHRpbWl6YXRpb246CgkJaWYgKGkgPCByci0+bnIgLSAxKQoJCQltZW1tb3ZlKHJyLT5pdGVtcyArIGksCgkJCQlyci0+aXRlbXMgKyBpICsgMSwKCQkJCXNpemVvZihyci0+aXRlbXNbMF0pICogKHJyLT5uciAtIGkgLSAxKSk7CgkJcnItPm5yLS07CgkJaS0tOwoJfQoKCXJldHVybiB3cml0ZV9ycihyciwgZmQpOwp9CgpzdGF0aWMgaW50IGdpdF9yZXJlcmVfY29uZmlnKGNvbnN0IGNoYXIgKnZhciwgY29uc3QgY2hhciAqdmFsdWUpCnsKCWlmICghc3RyY21wKHZhciwgImdjLnJlcmVyZXJlc29sdmVkIikpCgkJY3V0b2ZmX3Jlc29sdmUgPSBnaXRfY29uZmlnX2ludCh2YXIsIHZhbHVlKTsKCWVsc2UgaWYgKCFzdHJjbXAodmFyLCAiZ2MucmVyZXJldW5yZXNvbHZlZCIpKQoJCWN1dG9mZl9ub3Jlc29sdmUgPSBnaXRfY29uZmlnX2ludCh2YXIsIHZhbHVlKTsKCWVsc2UKCQlyZXR1cm4gZ2l0X2RlZmF1bHRfY29uZmlnKHZhciwgdmFsdWUpOwoJcmV0dXJuIDA7Cn0KCmludCBjbWRfcmVyZXJlKGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndiwgY29uc3QgY2hhciAqcHJlZml4KQp7CglzdHJ1Y3QgcGF0aF9saXN0IG1lcmdlX3JyID0geyBOVUxMLCAwLCAwLCAxIH07CglpbnQgaSwgZmQgPSAtMTsKCXN0cnVjdCBzdGF0IHN0OwoKCWlmIChzdGF0KGdpdF9wYXRoKCJyci1jYWNoZSIpLCAmc3QpIHx8ICFTX0lTRElSKHN0LnN0X21vZGUpKQoJCXJldHVybiAwOwoKCWdpdF9jb25maWcoZ2l0X3JlcmVyZV9jb25maWcpOwoKCW1lcmdlX3JyX3BhdGggPSB4c3RyZHVwKGdpdF9wYXRoKCJyci1jYWNoZS9NRVJHRV9SUiIpKTsKCWZkID0gaG9sZF9sb2NrX2ZpbGVfZm9yX3VwZGF0ZSgmd3JpdGVfbG9jaywgbWVyZ2VfcnJfcGF0aCwgMSk7CglyZWFkX3JyKCZtZXJnZV9ycik7CgoJaWYgKGFyZ2MgPCAyKQoJCXJldHVybiBkb19wbGFpbl9yZXJlcmUoJm1lcmdlX3JyLCBmZCk7CgllbHNlIGlmICghc3RyY21wKGFyZ3ZbMV0sICJjbGVhciIpKSB7CgkJZm9yIChpID0gMDsgaSA8IG1lcmdlX3JyLm5yOyBpKyspIHsKCQkJY29uc3QgY2hhciAqbmFtZSA9IChjb25zdCBjaGFyICopbWVyZ2VfcnIuaXRlbXNbaV0udXRpbDsKCQkJaWYgKCFzdGF0KGdpdF9wYXRoKCJyci1jYWNoZS8lcyIsIG5hbWUpLCAmc3QpICYmCgkJCQkJU19JU0RJUihzdC5zdF9tb2RlKSAmJgoJCQkJCXN0YXQocnJfcGF0aChuYW1lLCAicG9zdGltYWdlIiksICZzdCkpCgkJCQl1bmxpbmtfcnJfaXRlbShuYW1lKTsKCQl9CgkJdW5saW5rKG1lcmdlX3JyX3BhdGgpOwoJfSBlbHNlIGlmICghc3RyY21wKGFyZ3ZbMV0sICJnYyIpKQoJCWdhcmJhZ2VfY29sbGVjdCgmbWVyZ2VfcnIpOwoJZWxzZSBpZiAoIXN0cmNtcChhcmd2WzFdLCAic3RhdHVzIikpCgkJZm9yIChpID0gMDsgaSA8IG1lcmdlX3JyLm5yOyBpKyspCgkJCXByaW50ZigiJXNcbiIsIG1lcmdlX3JyLml0ZW1zW2ldLnBhdGgpOwoJZWxzZSBpZiAoIXN0cmNtcChhcmd2WzFdLCAiZGlmZiIpKQoJCWZvciAoaSA9IDA7IGkgPCBtZXJnZV9yci5ucjsgaSsrKSB7CgkJCWNvbnN0IGNoYXIgKnBhdGggPSBtZXJnZV9yci5pdGVtc1tpXS5wYXRoOwoJCQljb25zdCBjaGFyICpuYW1lID0gKGNvbnN0IGNoYXIgKiltZXJnZV9yci5pdGVtc1tpXS51dGlsOwoJCQlkaWZmX3R3byhycl9wYXRoKG5hbWUsICJwcmVpbWFnZSIpLCBwYXRoLCBwYXRoLCBwYXRoKTsKCQl9CgllbHNlCgkJdXNhZ2UoZ2l0X3JlcmVyZV91c2FnZSk7CgoJcGF0aF9saXN0X2NsZWFyKCZtZXJnZV9yciwgMSk7CglyZXR1cm4gMDsKfQoK",
    "text": "#include \"cache.h\"\n#include \"path-list.h\"\n#include \"xdiff/xdiff.h\"\n#include \"xdiff-interface.h\"\n\n#include <time.h>\n\nstatic const char git_rerere_usage[] =\n\"git-rerere [clear | status | diff | gc]\";\n\n/* these values are days */\nstatic int cutoff_noresolve = 15;\nstatic int cutoff_resolve = 60;\n\nstatic char *merge_rr_path;\n\nstatic const char *rr_path(const char *name, const char *file)\n{\n\treturn git_path(\"rr-cache/%s/%s\", name, file);\n}\n\nstatic void read_rr(struct path_list *rr)\n{\n\tunsigned char sha1[20];\n\tchar buf[PATH_MAX];\n\tFILE *in = fopen(merge_rr_path, \"r\");\n\tif (!in)\n\t\treturn;\n\twhile (fread(buf, 40, 1, in) == 1) {\n\t\tint i;\n\t\tchar *name;\n\t\tif (get_sha1_hex(buf, sha1))\n\t\t\tdie(\"corrupt MERGE_RR\");\n\t\tbuf[40] = '\\0';\n\t\tname = xstrdup(buf);\n\t\tif (fgetc(in) != '\\t')\n\t\t\tdie(\"corrupt MERGE_RR\");\n\t\tfor (i = 0; i < sizeof(buf) && (buf[i] = fgetc(in)); i++)\n\t\t\t; /* do nothing */\n\t\tif (i == sizeof(buf))\n\t\t\tdie(\"filename too long\");\n\t\tpath_list_insert(buf, rr)->util = xstrdup(name);\n\t}\n\tfclose(in);\n}\n\nstatic struct lock_file write_lock;\n\nstatic int write_rr(struct path_list *rr, int out_fd)\n{\n\tint i;\n\tfor (i = 0; i < rr->nr; i++) {\n\t\tconst char *path = rr->items[i].path;\n\t\tint length = strlen(path) + 1;\n\t\tif (write_in_full(out_fd, rr->items[i].util, 40) != 40 ||\n\t\t    write_in_full(out_fd, \"\\t\", 1) != 1 ||\n\t\t    write_in_full(out_fd, path, length) != length)\n\t\t\tdie(\"unable to write rerere record\");\n\t}\n\tclose(out_fd);\n\treturn commit_lock_file(&write_lock);\n}\n\nstruct buffer {\n\tchar *ptr;\n\tint nr, alloc;\n};\n\nstatic void append_line(struct buffer *buffer, const char *line)\n{\n\tint len = strlen(line);\n\n\tif (buffer->nr + len > buffer->alloc) {\n\t\tbuffer->alloc = alloc_nr(buffer->nr + len);\n\t\tbuffer->ptr = xrealloc(buffer->ptr, buffer->alloc);\n\t}\n\tmemcpy(buffer->ptr + buffer->nr, line, len);\n\tbuffer->nr += len;\n}\n\nstatic void clear_buffer(struct buffer *buffer)\n{\n\tfree(buffer->ptr);\n\tbuffer->ptr = NULL;\n\tbuffer->nr = buffer->alloc = 0;\n}\n\nstatic int handle_file(const char *path,\n\t unsigned char *sha1, const char *output)\n{\n\tSHA_CTX ctx;\n\tchar buf[1024];\n\tint hunk = 0, hunk_no = 0;\n\tstruct buffer minus = { NULL, 0, 0 }, plus = { NULL, 0, 0 };\n\tstruct buffer *one = &minus, *two = &plus;\n\tFILE *f = fopen(path, \"r\");\n\tFILE *out;\n\n\tif (!f)\n\t\treturn error(\"Could not open %s\", path);\n\n\tif (output) {\n\t\tout = fopen(output, \"w\");\n\t\tif (!out) {\n\t\t\tfclose(f);\n\t\t\treturn error(\"Could not write %s\", output);\n\t\t}\n\t} else\n\t\tout = NULL;\n\n\tif (sha1)\n\t\tSHA1_Init(&ctx);\n\n\twhile (fgets(buf, sizeof(buf), f)) {\n\t\tif (!strncmp(\"<<<<<<< \", buf, 8))\n\t\t\thunk = 1;\n\t\telse if (!strncmp(\"=======\", buf, 7))\n\t\t\thunk = 2;\n\t\telse if (!strncmp(\">>>>>>> \", buf, 8)) {\n\t\t\thunk_no++;\n\t\t\thunk = 0;\n\t\t\tif (memcmp(one->ptr, two->ptr, one->nr < two->nr ?\n\t\t\t\t\t\tone->nr : two->nr) > 0) {\n\t\t\t\tstruct buffer *swap = one;\n\t\t\t\tone = two;\n\t\t\t\ttwo = swap;\n\t\t\t}\n\t\t\tif (out) {\n\t\t\t\tfputs(\"<<<<<<<\\n\", out);\n\t\t\t\tfwrite(one->ptr, one->nr, 1, out);\n\t\t\t\tfputs(\"=======\\n\", out);\n\t\t\t\tfwrite(two->ptr, two->nr, 1, out);\n\t\t\t\tfputs(\">>>>>>>\\n\", out);\n\t\t\t}\n\t\t\tif (sha1) {\n\t\t\t\tSHA1_Update(&ctx, one->ptr, one->nr);\n\t\t\t\tSHA1_Update(&ctx, \"\\0\", 1);\n\t\t\t\tSHA1_Update(&ctx, two->ptr, two->nr);\n\t\t\t\tSHA1_Update(&ctx, \"\\0\", 1);\n\t\t\t}\n\t\t\tclear_buffer(one);\n\t\t\tclear_buffer(two);\n\t\t} else if (hunk == 1)\n\t\t\tappend_line(one, buf);\n\t\telse if (hunk == 2)\n\t\t\tappend_line(two, buf);\n\t\telse if (out)\n\t\t\tfputs(buf, out);\n\t}\n\n\tfclose(f);\n\tif (out)\n\t\tfclose(out);\n\tif (sha1)\n\t\tSHA1_Final(sha1, &ctx);\n\treturn hunk_no;\n}\n\nstatic int find_conflict(struct path_list *conflict)\n{\n\tint i;\n\tif (read_cache() < 0)\n\t\treturn error(\"Could not read index\");\n\tfor (i = 0; i + 2 < active_nr; i++) {\n\t\tstruct cache_entry *e1 = active_cache[i];\n\t\tstruct cache_entry *e2 = active_cache[i+1];\n\t\tstruct cache_entry *e3 = active_cache[i+2];\n\t\tif (ce_stage(e1) == 1 &&\n\t\t    ce_stage(e2) == 2 &&\n\t\t    ce_stage(e3) == 3 &&\n\t\t    ce_same_name(e1, e2) && ce_same_name(e1, e3) &&\n\t\t    S_ISREG(ntohl(e1->ce_mode)) &&\n\t\t    S_ISREG(ntohl(e2->ce_mode)) &&\n\t\t    S_ISREG(ntohl(e3->ce_mode))) {\n\t\t\tpath_list_insert((const char *)e1->name, conflict);\n\t\t\ti += 2;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int merge(const char *name, const char *path)\n{\n\tint ret;\n\tmmfile_t cur, base, other;\n\tmmbuffer_t result = {NULL, 0};\n\txpparam_t xpp = {XDF_NEED_MINIMAL};\n\n\tif (handle_file(path, NULL, rr_path(name, \"thisimage\")) < 0)\n\t\treturn 1;\n\n\tif (read_mmfile(&cur, rr_path(name, \"thisimage\")) ||\n\t\t\tread_mmfile(&base, rr_path(name, \"preimage\")) ||\n\t\t\tread_mmfile(&other, rr_path(name, \"postimage\")))\n\t\treturn 1;\n\tret = xdl_merge(&base, &cur, \"\", &other, \"\",\n\t\t\t&xpp, XDL_MERGE_ZEALOUS, &result);\n\tif (!ret) {\n\t\tFILE *f = fopen(path, \"w\");\n\t\tif (!f)\n\t\t\treturn error(\"Could not write to %s\", path);\n\t\tfwrite(result.ptr, result.size, 1, f);\n\t\tfclose(f);\n\t}\n\n\tfree(cur.ptr);\n\tfree(base.ptr);\n\tfree(other.ptr);\n\tfree(result.ptr);\n\n\treturn ret;\n}\n\nstatic void unlink_rr_item(const char *name)\n{\n\tunlink(rr_path(name, \"thisimage\"));\n\tunlink(rr_path(name, \"preimage\"));\n\tunlink(rr_path(name, \"postimage\"));\n\trmdir(git_path(\"rr-cache/%s\", name));\n}\n\nstatic void garbage_collect(struct path_list *rr)\n{\n\tstruct path_list to_remove = { NULL, 0, 0, 1 };\n\tchar buf[1024];\n\tDIR *dir;\n\tstruct dirent *e;\n\tint len, i, cutoff;\n\ttime_t now = time(NULL), then;\n\n\tstrlcpy(buf, git_path(\"rr-cache\"), sizeof(buf));\n\tlen = strlen(buf);\n\tdir = opendir(buf);\n\tstrcpy(buf + len++, \"/\");\n\twhile ((e = readdir(dir))) {\n\t\tconst char *name = e->d_name;\n\t\tstruct stat st;\n\t\tif (name[0] == '.' && (name[1] == '\\0' ||\n\t\t\t\t\t(name[1] == '.' && name[2] == '\\0')))\n\t\t\tcontinue;\n\t\ti = snprintf(buf + len, sizeof(buf) - len, \"%s\", name);\n\t\tstrlcpy(buf + len + i, \"/preimage\", sizeof(buf) - len - i);\n\t\tif (stat(buf, &st))\n\t\t\tcontinue;\n\t\tthen = st.st_mtime;\n\t\tstrlcpy(buf + len + i, \"/postimage\", sizeof(buf) - len - i);\n\t\tcutoff = stat(buf, &st) ? cutoff_noresolve : cutoff_resolve;\n\t\tif (then < now - cutoff * 86400) {\n\t\t\tbuf[len + i] = '\\0';\n\t\t\tpath_list_insert(xstrdup(name), &to_remove);\n\t\t}\n\t}\n\tfor (i = 0; i < to_remove.nr; i++)\n\t\tunlink_rr_item(to_remove.items[i].path);\n\tpath_list_clear(&to_remove, 0);\n}\n\nstatic int outf(void *dummy, mmbuffer_t *ptr, int nbuf)\n{\n\tint i;\n\tfor (i = 0; i < nbuf; i++)\n\t\tif (write_in_full(1, ptr[i].ptr, ptr[i].size) != ptr[i].size)\n\t\t\treturn -1;\n\treturn 0;\n}\n\nstatic int diff_two(const char *file1, const char *label1,\n\t\tconst char *file2, const char *label2)\n{\n\txpparam_t xpp;\n\txdemitconf_t xecfg;\n\txdemitcb_t ecb;\n\tmmfile_t minus, plus;\n\n\tif (read_mmfile(&minus, file1) || read_mmfile(&plus, file2))\n\t\treturn 1;\n\n\tprintf(\"--- a/%s\\n+++ b/%s\\n\", label1, label2);\n\tfflush(stdout);\n\txpp.flags = XDF_NEED_MINIMAL;\n\txecfg.ctxlen = 3;\n\txecfg.flags = 0;\n\tecb.outf = outf;\n\txdl_diff(&minus, &plus, &xpp, &xecfg, &ecb);\n\n\tfree(minus.ptr);\n\tfree(plus.ptr);\n\treturn 0;\n}\n\nstatic int copy_file(const char *src, const char *dest)\n{\n\tFILE *in, *out;\n\tchar buffer[32768];\n\tint count;\n\n\tif (!(in = fopen(src, \"r\")))\n\t\treturn error(\"Could not open %s\", src);\n\tif (!(out = fopen(dest, \"w\")))\n\t\treturn error(\"Could not open %s\", dest);\n\twhile ((count = fread(buffer, 1, sizeof(buffer), in)))\n\t\tfwrite(buffer, 1, count, out);\n\tfclose(in);\n\tfclose(out);\n\treturn 0;\n}\n\nstatic int do_plain_rerere(struct path_list *rr, int fd)\n{\n\tstruct path_list conflict = { NULL, 0, 0, 1 };\n\tint i;\n\n\tfind_conflict(&conflict);\n\n\t/*\n\t * MERGE_RR records paths with conflicts immediately after merge\n\t * failed.  Some of the conflicted paths might have been hand resolved\n\t * in the working tree since then, but the initial run would catch all\n\t * and register their preimages.\n\t */\n\n\tfor (i = 0; i < conflict.nr; i++) {\n\t\tconst char *path = conflict.items[i].path;\n\t\tif (!path_list_has_path(rr, path)) {\n\t\t\tunsigned char sha1[20];\n\t\t\tchar *hex;\n\t\t\tint ret;\n\t\t\tret = handle_file(path, sha1, NULL);\n\t\t\tif (ret < 1)\n\t\t\t\tcontinue;\n\t\t\thex = xstrdup(sha1_to_hex(sha1));\n\t\t\tpath_list_insert(path, rr)->util = hex;\n\t\t\tif (mkdir(git_path(\"rr-cache/%s\", hex), 0755))\n\t\t\t\tcontinue;;\n\t\t\thandle_file(path, NULL, rr_path(hex, \"preimage\"));\n\t\t\tfprintf(stderr, \"Recorded preimage for '%s'\\n\", path);\n\t\t}\n\t}\n\n\t/*\n\t * Now some of the paths that had conflicts earlier might have been\n\t * hand resolved.  Others may be similar to a conflict already that\n\t * was resolved before.\n\t */\n\n\tfor (i = 0; i < rr->nr; i++) {\n\t\tstruct stat st;\n\t\tint ret;\n\t\tconst char *path = rr->items[i].path;\n\t\tconst char *name = (const char *)rr->items[i].util;\n\n\t\tif (!stat(rr_path(name, \"preimage\"), &st) &&\n\t\t\t\t!stat(rr_path(name, \"postimage\"), &st)) {\n\t\t\tif (!merge(name, path)) {\n\t\t\t\tfprintf(stderr, \"Resolved '%s' using \"\n\t\t\t\t\t\t\"previous resolution.\\n\", path);\n\t\t\t\tgoto tail_optimization;\n\t\t\t}\n\t\t}\n\n\t\t/* Let's see if we have resolved it. */\n\t\tret = handle_file(path, NULL, NULL);\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\tfprintf(stderr, \"Recorded resolution for '%s'.\\n\", path);\n\t\tcopy_file(path, rr_path(name, \"postimage\"));\ntail_optimization:\n\t\tif (i < rr->nr - 1)\n\t\t\tmemmove(rr->items + i,\n\t\t\t\trr->items + i + 1,\n\t\t\t\tsizeof(rr->items[0]) * (rr->nr - i - 1));\n\t\trr->nr--;\n\t\ti--;\n\t}\n\n\treturn write_rr(rr, fd);\n}\n\nstatic int git_rerere_config(const char *var, const char *value)\n{\n\tif (!strcmp(var, \"gc.rerereresolved\"))\n\t\tcutoff_resolve = git_config_int(var, value);\n\telse if (!strcmp(var, \"gc.rerereunresolved\"))\n\t\tcutoff_noresolve = git_config_int(var, value);\n\telse\n\t\treturn git_default_config(var, value);\n\treturn 0;\n}\n\nint cmd_rerere(int argc, const char **argv, const char *prefix)\n{\n\tstruct path_list merge_rr = { NULL, 0, 0, 1 };\n\tint i, fd = -1;\n\tstruct stat st;\n\n\tif (stat(git_path(\"rr-cache\"), &st) || !S_ISDIR(st.st_mode))\n\t\treturn 0;\n\n\tgit_config(git_rerere_config);\n\n\tmerge_rr_path = xstrdup(git_path(\"rr-cache/MERGE_RR\"));\n\tfd = hold_lock_file_for_update(&write_lock, merge_rr_path, 1);\n\tread_rr(&merge_rr);\n\n\tif (argc < 2)\n\t\treturn do_plain_rerere(&merge_rr, fd);\n\telse if (!strcmp(argv[1], \"clear\")) {\n\t\tfor (i = 0; i < merge_rr.nr; i++) {\n\t\t\tconst char *name = (const char *)merge_rr.items[i].util;\n\t\t\tif (!stat(git_path(\"rr-cache/%s\", name), &st) &&\n\t\t\t\t\tS_ISDIR(st.st_mode) &&\n\t\t\t\t\tstat(rr_path(name, \"postimage\"), &st))\n\t\t\t\tunlink_rr_item(name);\n\t\t}\n\t\tunlink(merge_rr_path);\n\t} else if (!strcmp(argv[1], \"gc\"))\n\t\tgarbage_collect(&merge_rr);\n\telse if (!strcmp(argv[1], \"status\"))\n\t\tfor (i = 0; i < merge_rr.nr; i++)\n\t\t\tprintf(\"%s\\n\", merge_rr.items[i].path);\n\telse if (!strcmp(argv[1], \"diff\"))\n\t\tfor (i = 0; i < merge_rr.nr; i++) {\n\t\t\tconst char *path = merge_rr.items[i].path;\n\t\t\tconst char *name = (const char *)merge_rr.items[i].util;\n\t\t\tdiff_two(rr_path(name, \"preimage\"), path, path, path);\n\t\t}\n\telse\n\t\tusage(git_rerere_usage);\n\n\tpath_list_clear(&merge_rr, 1);\n\treturn 0;\n}\n\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "004eda2acdf9b8ac5a66f9717d2244613b23768e",
  "sha1_ok": true,
  "size": 10614
}
