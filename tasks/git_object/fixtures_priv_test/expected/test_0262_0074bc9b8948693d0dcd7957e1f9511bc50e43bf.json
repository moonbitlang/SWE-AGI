{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJjb25maWcuaCIKI2luY2x1ZGUgIm5vdGVzLmgiCiNpbmNsdWRlICJibG9iLmgiCiNpbmNsdWRlICJ0cmVlLmgiCiNpbmNsdWRlICJ1dGY4LmgiCiNpbmNsdWRlICJzdHJidWYuaCIKI2luY2x1ZGUgInRyZWUtd2Fsay5oIgojaW5jbHVkZSAic3RyaW5nLWxpc3QuaCIKI2luY2x1ZGUgInJlZnMuaCIKCi8qCiAqIFVzZSBhIG5vbi1iYWxhbmNpbmcgc2ltcGxlIDE2LXRyZWUgc3RydWN0dXJlIHdpdGggc3RydWN0IGludF9ub2RlIGFzCiAqIGludGVybmFsIG5vZGVzLCBhbmQgc3RydWN0IGxlYWZfbm9kZSBhcyBsZWFmIG5vZGVzLiBFYWNoIGludF9ub2RlIGhhcyBhCiAqIDE2LWFycmF5IG9mIHBvaW50ZXJzIHRvIGl0cyBjaGlsZHJlbi4KICogVGhlIGJvdHRvbSAyIGJpdHMgb2YgZWFjaCBwb2ludGVyIGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIHBvaW50ZXIgdHlwZQogKiAtIHB0ciAmIDMgPT0gMCAtIE5VTEwgcG9pbnRlciwgYXNzZXJ0KHB0ciA9PSBOVUxMKQogKiAtIHB0ciAmIDMgPT0gMSAtIHBvaW50ZXIgdG8gbmV4dCBpbnRlcm5hbCBub2RlIC0gY2FzdCB0byBzdHJ1Y3QgaW50X25vZGUgKgogKiAtIHB0ciAmIDMgPT0gMiAtIHBvaW50ZXIgdG8gbm90ZSBlbnRyeSAtIGNhc3QgdG8gc3RydWN0IGxlYWZfbm9kZSAqCiAqIC0gcHRyICYgMyA9PSAzIC0gcG9pbnRlciB0byBzdWJ0cmVlIGVudHJ5IC0gY2FzdCB0byBzdHJ1Y3QgbGVhZl9ub2RlICoKICoKICogVGhlIHJvb3Qgbm9kZSBpcyBhIHN0YXRpY2FsbHkgYWxsb2NhdGVkIHN0cnVjdCBpbnRfbm9kZS4KICovCnN0cnVjdCBpbnRfbm9kZSB7Cgl2b2lkICphWzE2XTsKfTsKCi8qCiAqIExlYWYgbm9kZXMgY29tZSBpbiB0d28gdmFyaWFudHMsIG5vdGUgZW50cmllcyBhbmQgc3VidHJlZSBlbnRyaWVzLAogKiBkaXN0aW5ndWlzaGVkIGJ5IHRoZSBMU2Igb2YgdGhlIGxlYWYgbm9kZSBwb2ludGVyIChzZWUgYWJvdmUpLgogKiBBcyBhIG5vdGUgZW50cnksIHRoZSBrZXkgaXMgdGhlIFNIQTEgb2YgdGhlIHJlZmVyZW5jZWQgb2JqZWN0LCBhbmQgdGhlCiAqIHZhbHVlIGlzIHRoZSBTSEExIG9mIHRoZSBub3RlIG9iamVjdC4KICogQXMgYSBzdWJ0cmVlIGVudHJ5LCB0aGUga2V5IGlzIHRoZSBwcmVmaXggU0hBMSAody90cmFpbGluZyBOVUxzKSBvZiB0aGUKICogcmVmZXJlbmNlZCBvYmplY3QsIHVzaW5nIHRoZSBsYXN0IGJ5dGUgb2YgdGhlIGtleSB0byBzdG9yZSB0aGUgbGVuZ3RoIG9mCiAqIHRoZSBwcmVmaXguIFRoZSB2YWx1ZSBpcyB0aGUgU0hBMSBvZiB0aGUgdHJlZSBvYmplY3QgY29udGFpbmluZyB0aGUgbm90ZXMKICogc3VidHJlZS4KICovCnN0cnVjdCBsZWFmX25vZGUgewoJc3RydWN0IG9iamVjdF9pZCBrZXlfb2lkOwoJc3RydWN0IG9iamVjdF9pZCB2YWxfb2lkOwp9OwoKLyoKICogQSBub3RlcyB0cmVlIG1heSBjb250YWluIGVudHJpZXMgdGhhdCBhcmUgbm90IG5vdGVzLCBhbmQgdGhhdCBkbyBub3QgZm9sbG93CiAqIHRoZSBuYW1pbmcgY29udmVudGlvbnMgb2Ygbm90ZXMuIFRoZXJlIGFyZSB0eXBpY2FsbHkgbm9uZS9mZXcgb2YgdGhlc2UsIGJ1dAogKiB3ZSBzdGlsbCBuZWVkIHRvIGtlZXAgdHJhY2sgb2YgdGhlbS4gS2VlcCBhIHNpbXBsZSBsaW5rZWQgbGlzdCBzb3J0ZWQgYWxwaGEtCiAqIGJldGljYWxseSBvbiB0aGUgbm9uLW5vdGUgcGF0aC4gVGhlIGxpc3QgaXMgcG9wdWxhdGVkIHdoZW4gcGFyc2luZyB0cmVlCiAqIG9iamVjdHMgaW4gbG9hZF9zdWJ0cmVlKCksIGFuZCB0aGUgbm9uLW5vdGVzIGFyZSBjb3JyZWN0bHkgd3JpdHRlbiBiYWNrIGludG8KICogdGhlIHRyZWUgb2JqZWN0cyBwcm9kdWNlZCBieSB3cml0ZV9ub3Rlc190cmVlKCkuCiAqLwpzdHJ1Y3Qgbm9uX25vdGUgewoJc3RydWN0IG5vbl9ub3RlICpuZXh0OyAvKiBncm91bmRlZCAobGFzdC0+bmV4dCA9PSBOVUxMKSAqLwoJY2hhciAqcGF0aDsKCXVuc2lnbmVkIGludCBtb2RlOwoJc3RydWN0IG9iamVjdF9pZCBvaWQ7Cn07CgojZGVmaW5lIFBUUl9UWVBFX05VTEwgICAgIDAKI2RlZmluZSBQVFJfVFlQRV9JTlRFUk5BTCAxCiNkZWZpbmUgUFRSX1RZUEVfTk9URSAgICAgMgojZGVmaW5lIFBUUl9UWVBFX1NVQlRSRUUgIDMKCiNkZWZpbmUgR0VUX1BUUl9UWVBFKHB0cikgICAgICAgKCh1aW50cHRyX3QpIChwdHIpICYgMykKI2RlZmluZSBDTFJfUFRSX1RZUEUocHRyKSAgICAgICAoKHZvaWQgKikgKCh1aW50cHRyX3QpIChwdHIpICYgfjMpKQojZGVmaW5lIFNFVF9QVFJfVFlQRShwdHIsIHR5cGUpICgodm9pZCAqKSAoKHVpbnRwdHJfdCkgKHB0cikgfCAodHlwZSkpKQoKI2RlZmluZSBHRVRfTklCQkxFKG4sIHNoYTEpICgoKChzaGExKVsobikgPj4gMV0pID4+ICgofihuKSAmIDB4MDEpIDw8IDIpKSAmIDB4MGYpCgojZGVmaW5lIEtFWV9JTkRFWCAoR0lUX1NIQTFfUkFXU1ogLSAxKQojZGVmaW5lIEZBTk9VVF9QQVRIX1NFUEFSQVRPUlMgKChHSVRfU0hBMV9IRVhTWiAvIDIpIC0gMSkKI2RlZmluZSBTVUJUUkVFX1NIQTFfUFJFRklYQ01QKGtleV9zaGExLCBzdWJ0cmVlX3NoYTEpIFwKCShtZW1jbXAoa2V5X3NoYTEsIHN1YnRyZWVfc2hhMSwgc3VidHJlZV9zaGExW0tFWV9JTkRFWF0pKQoKc3RydWN0IG5vdGVzX3RyZWUgZGVmYXVsdF9ub3Rlc190cmVlOwoKc3RhdGljIHN0cnVjdCBzdHJpbmdfbGlzdCBkaXNwbGF5X25vdGVzX3JlZnMgPSBTVFJJTkdfTElTVF9JTklUX05PRFVQOwpzdGF0aWMgc3RydWN0IG5vdGVzX3RyZWUgKipkaXNwbGF5X25vdGVzX3RyZWVzOwoKc3RhdGljIHZvaWQgbG9hZF9zdWJ0cmVlKHN0cnVjdCBub3Rlc190cmVlICp0LCBzdHJ1Y3QgbGVhZl9ub2RlICpzdWJ0cmVlLAoJCXN0cnVjdCBpbnRfbm9kZSAqbm9kZSwgdW5zaWduZWQgaW50IG4pOwoKLyoKICogU2VhcmNoIHRoZSB0cmVlIHVudGlsIHRoZSBhcHByb3ByaWF0ZSBsb2NhdGlvbiBmb3IgdGhlIGdpdmVuIGtleSBpcyBmb3VuZDoKICogMS4gU3RhcnQgYXQgdGhlIHJvb3Qgbm9kZSwgd2l0aCBuID0gMAogKiAyLiBJZiBhWzBdIGF0IHRoZSBjdXJyZW50IGxldmVsIGlzIGEgbWF0Y2hpbmcgc3VidHJlZSBlbnRyeSwgdW5wYWNrIHRoYXQKICogICAgc3VidHJlZSBlbnRyeSBhbmQgcmVtb3ZlIGl0OyByZXN0YXJ0IHNlYXJjaCBhdCB0aGUgY3VycmVudCBsZXZlbC4KICogMy4gVXNlIHRoZSBudGggbmliYmxlIG9mIHRoZSBrZXkgYXMgYW4gaW5kZXggaW50byBhOgogKiAgICAtIElmIGFbbl0gaXMgYW4gaW50X25vZGUsIHJlY3Vyc2UgZnJvbSAjMiBpbnRvIHRoYXQgbm9kZSBhbmQgaW5jcmVtZW50IG4KICogICAgLSBJZiBhIG1hdGNoaW5nIHN1YnRyZWUgZW50cnksIHVucGFjayB0aGF0IHN1YnRyZWUgZW50cnkgKGFuZCByZW1vdmUgaXQpOwogKiAgICAgIHJlc3RhcnQgc2VhcmNoIGF0IHRoZSBjdXJyZW50IGxldmVsLgogKiAgICAtIE90aGVyd2lzZSwgd2UgaGF2ZSBmb3VuZCBvbmUgb2YgdGhlIGZvbGxvd2luZzoKICogICAgICAtIGEgc3VidHJlZSBlbnRyeSB3aGljaCBkb2VzIG5vdCBtYXRjaCB0aGUga2V5CiAqICAgICAgLSBhIG5vdGUgZW50cnkgd2hpY2ggbWF5IG9yIG1heSBub3QgbWF0Y2ggdGhlIGtleQogKiAgICAgIC0gYW4gdW51c2VkIGxlYWYgbm9kZSAoTlVMTCkKICogICAgICBJbiBhbnkgY2FzZSwgc2V0ICp0cmVlIGFuZCAqbiwgYW5kIHJldHVybiBwb2ludGVyIHRvIHRoZSB0cmVlIGxvY2F0aW9uLgogKi8Kc3RhdGljIHZvaWQgKipub3RlX3RyZWVfc2VhcmNoKHN0cnVjdCBub3Rlc190cmVlICp0LCBzdHJ1Y3QgaW50X25vZGUgKip0cmVlLAoJCXVuc2lnbmVkIGNoYXIgKm4sIGNvbnN0IHVuc2lnbmVkIGNoYXIgKmtleV9zaGExKQp7CglzdHJ1Y3QgbGVhZl9ub2RlICpsOwoJdW5zaWduZWQgY2hhciBpOwoJdm9pZCAqcCA9ICgqdHJlZSktPmFbMF07CgoJaWYgKEdFVF9QVFJfVFlQRShwKSA9PSBQVFJfVFlQRV9TVUJUUkVFKSB7CgkJbCA9IChzdHJ1Y3QgbGVhZl9ub2RlICopIENMUl9QVFJfVFlQRShwKTsKCQlpZiAoIVNVQlRSRUVfU0hBMV9QUkVGSVhDTVAoa2V5X3NoYTEsIGwtPmtleV9vaWQuaGFzaCkpIHsKCQkJLyogdW5wYWNrIHRyZWUgYW5kIHJlc3VtZSBzZWFyY2ggKi8KCQkJKCp0cmVlKS0+YVswXSA9IE5VTEw7CgkJCWxvYWRfc3VidHJlZSh0LCBsLCAqdHJlZSwgKm4pOwoJCQlmcmVlKGwpOwoJCQlyZXR1cm4gbm90ZV90cmVlX3NlYXJjaCh0LCB0cmVlLCBuLCBrZXlfc2hhMSk7CgkJfQoJfQoKCWkgPSBHRVRfTklCQkxFKCpuLCBrZXlfc2hhMSk7CglwID0gKCp0cmVlKS0+YVtpXTsKCXN3aXRjaCAoR0VUX1BUUl9UWVBFKHApKSB7CgljYXNlIFBUUl9UWVBFX0lOVEVSTkFMOgoJCSp0cmVlID0gQ0xSX1BUUl9UWVBFKHApOwoJCSgqbikrKzsKCQlyZXR1cm4gbm90ZV90cmVlX3NlYXJjaCh0LCB0cmVlLCBuLCBrZXlfc2hhMSk7CgljYXNlIFBUUl9UWVBFX1NVQlRSRUU6CgkJbCA9IChzdHJ1Y3QgbGVhZl9ub2RlICopIENMUl9QVFJfVFlQRShwKTsKCQlpZiAoIVNVQlRSRUVfU0hBMV9QUkVGSVhDTVAoa2V5X3NoYTEsIGwtPmtleV9vaWQuaGFzaCkpIHsKCQkJLyogdW5wYWNrIHRyZWUgYW5kIHJlc3VtZSBzZWFyY2ggKi8KCQkJKCp0cmVlKS0+YVtpXSA9IE5VTEw7CgkJCWxvYWRfc3VidHJlZSh0LCBsLCAqdHJlZSwgKm4pOwoJCQlmcmVlKGwpOwoJCQlyZXR1cm4gbm90ZV90cmVlX3NlYXJjaCh0LCB0cmVlLCBuLCBrZXlfc2hhMSk7CgkJfQoJCS8qIGZhbGwgdGhyb3VnaCAqLwoJZGVmYXVsdDoKCQlyZXR1cm4gJigoKnRyZWUpLT5hW2ldKTsKCX0KfQoKLyoKICogVG8gZmluZCBhIGxlYWZfbm9kZToKICogU2VhcmNoIHRvIHRoZSB0cmVlIGxvY2F0aW9uIGFwcHJvcHJpYXRlIGZvciB0aGUgZ2l2ZW4ga2V5OgogKiBJZiBhIG5vdGUgZW50cnkgd2l0aCBtYXRjaGluZyBrZXksIHJldHVybiB0aGUgbm90ZSBlbnRyeSwgZWxzZSByZXR1cm4gTlVMTC4KICovCnN0YXRpYyBzdHJ1Y3QgbGVhZl9ub2RlICpub3RlX3RyZWVfZmluZChzdHJ1Y3Qgbm90ZXNfdHJlZSAqdCwKCQlzdHJ1Y3QgaW50X25vZGUgKnRyZWUsIHVuc2lnbmVkIGNoYXIgbiwKCQljb25zdCB1bnNpZ25lZCBjaGFyICprZXlfc2hhMSkKewoJdm9pZCAqKnAgPSBub3RlX3RyZWVfc2VhcmNoKHQsICZ0cmVlLCAmbiwga2V5X3NoYTEpOwoJaWYgKEdFVF9QVFJfVFlQRSgqcCkgPT0gUFRSX1RZUEVfTk9URSkgewoJCXN0cnVjdCBsZWFmX25vZGUgKmwgPSAoc3RydWN0IGxlYWZfbm9kZSAqKSBDTFJfUFRSX1RZUEUoKnApOwoJCWlmICghaGFzaGNtcChrZXlfc2hhMSwgbC0+a2V5X29pZC5oYXNoKSkKCQkJcmV0dXJuIGw7Cgl9CglyZXR1cm4gTlVMTDsKfQoKLyoKICogSG93IHRvIGNvbnNvbGlkYXRlIGFuIGludF9ub2RlOgogKiBJZiB0aGVyZSBhcmUgPiAxIG5vbi1OVUxMIGVudHJpZXMsIGdpdmUgdXAgYW5kIHJldHVybiBub24temVyby4KICogT3RoZXJ3aXNlIHJlcGxhY2UgdGhlIGludF9ub2RlIGF0IHRoZSBnaXZlbiBpbmRleCBpbiB0aGUgZ2l2ZW4gcGFyZW50IG5vZGUKICogd2l0aCB0aGUgb25seSBOT1RFIGVudHJ5IChvciBhIE5VTEwgZW50cnkgaWYgbm8gZW50cmllcykgZnJvbSB0aGUgZ2l2ZW4KICogdHJlZSwgYW5kIHJldHVybiAwLgogKi8Kc3RhdGljIGludCBub3RlX3RyZWVfY29uc29saWRhdGUoc3RydWN0IGludF9ub2RlICp0cmVlLAoJc3RydWN0IGludF9ub2RlICpwYXJlbnQsIHVuc2lnbmVkIGNoYXIgaW5kZXgpCnsKCXVuc2lnbmVkIGludCBpOwoJdm9pZCAqcCA9IE5VTEw7CgoJYXNzZXJ0KHRyZWUgJiYgcGFyZW50KTsKCWFzc2VydChDTFJfUFRSX1RZUEUocGFyZW50LT5hW2luZGV4XSkgPT0gdHJlZSk7CgoJZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHsKCQlpZiAoR0VUX1BUUl9UWVBFKHRyZWUtPmFbaV0pICE9IFBUUl9UWVBFX05VTEwpIHsKCQkJaWYgKHApIC8qIG1vcmUgdGhhbiBvbmUgZW50cnkgKi8KCQkJCXJldHVybiAtMjsKCQkJcCA9IHRyZWUtPmFbaV07CgkJfQoJfQoKCWlmIChwICYmIChHRVRfUFRSX1RZUEUocCkgIT0gUFRSX1RZUEVfTk9URSkpCgkJcmV0dXJuIC0yOwoJLyogcmVwbGFjZSB0cmVlIHdpdGggcCBpbiBwYXJlbnRbaW5kZXhdICovCglwYXJlbnQtPmFbaW5kZXhdID0gcDsKCWZyZWUodHJlZSk7CglyZXR1cm4gMDsKfQoKLyoKICogVG8gcmVtb3ZlIGEgbGVhZl9ub2RlOgogKiBTZWFyY2ggdG8gdGhlIHRyZWUgbG9jYXRpb24gYXBwcm9wcmlhdGUgZm9yIHRoZSBnaXZlbiBsZWFmX25vZGUncyBrZXk6CiAqIC0gSWYgbG9jYXRpb24gZG9lcyBub3QgaG9sZCBhIG1hdGNoaW5nIGVudHJ5LCBhYm9ydCBhbmQgZG8gbm90aGluZy4KICogLSBDb3B5IHRoZSBtYXRjaGluZyBlbnRyeSdzIHZhbHVlIGludG8gdGhlIGdpdmVuIGVudHJ5LgogKiAtIFJlcGxhY2UgdGhlIG1hdGNoaW5nIGxlYWZfbm9kZSB3aXRoIGEgTlVMTCBlbnRyeSAoYW5kIGZyZWUgdGhlIGxlYWZfbm9kZSkuCiAqIC0gQ29uc29saWRhdGUgaW50X25vZGVzIHJlcGVhdGVkbHksIHdoaWxlIHdhbGtpbmcgdXAgdGhlIHRyZWUgdG93YXJkcyByb290LgogKi8Kc3RhdGljIHZvaWQgbm90ZV90cmVlX3JlbW92ZShzdHJ1Y3Qgbm90ZXNfdHJlZSAqdCwKCQlzdHJ1Y3QgaW50X25vZGUgKnRyZWUsIHVuc2lnbmVkIGNoYXIgbiwKCQlzdHJ1Y3QgbGVhZl9ub2RlICplbnRyeSkKewoJc3RydWN0IGxlYWZfbm9kZSAqbDsKCXN0cnVjdCBpbnRfbm9kZSAqcGFyZW50X3N0YWNrW0dJVF9TSEExX1JBV1NaXTsKCXVuc2lnbmVkIGNoYXIgaSwgajsKCXZvaWQgKipwID0gbm90ZV90cmVlX3NlYXJjaCh0LCAmdHJlZSwgJm4sIGVudHJ5LT5rZXlfb2lkLmhhc2gpOwoKCWFzc2VydChHRVRfUFRSX1RZUEUoZW50cnkpID09IDApOyAvKiBubyB0eXBlIGJpdHMgc2V0ICovCglpZiAoR0VUX1BUUl9UWVBFKCpwKSAhPSBQVFJfVFlQRV9OT1RFKQoJCXJldHVybjsgLyogdHlwZSBtaXNtYXRjaCwgbm90aGluZyB0byByZW1vdmUgKi8KCWwgPSAoc3RydWN0IGxlYWZfbm9kZSAqKSBDTFJfUFRSX1RZUEUoKnApOwoJaWYgKG9pZGNtcCgmbC0+a2V5X29pZCwgJmVudHJ5LT5rZXlfb2lkKSkKCQlyZXR1cm47IC8qIGtleSBtaXNtYXRjaCwgbm90aGluZyB0byByZW1vdmUgKi8KCgkvKiB3ZSBoYXZlIGZvdW5kIGEgbWF0Y2hpbmcgZW50cnkgKi8KCW9pZGNweSgmZW50cnktPnZhbF9vaWQsICZsLT52YWxfb2lkKTsKCWZyZWUobCk7CgkqcCA9IFNFVF9QVFJfVFlQRShOVUxMLCBQVFJfVFlQRV9OVUxMKTsKCgkvKiBjb25zb2xpZGF0ZSB0aGlzIHRyZWUgbGV2ZWwsIGFuZCBwYXJlbnQgbGV2ZWxzLCBpZiBwb3NzaWJsZSAqLwoJaWYgKCFuKQoJCXJldHVybjsgLyogY2Fubm90IGNvbnNvbGlkYXRlIHRvcCBsZXZlbCAqLwoJLyogZmlyc3QsIGJ1aWxkIHN0YWNrIG9mIGFuY2VzdG9ycyBiZXR3ZWVuIHJvb3QgYW5kIGN1cnJlbnQgbm9kZSAqLwoJcGFyZW50X3N0YWNrWzBdID0gdC0+cm9vdDsKCWZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHsKCQlqID0gR0VUX05JQkJMRShpLCBlbnRyeS0+a2V5X29pZC5oYXNoKTsKCQlwYXJlbnRfc3RhY2tbaSArIDFdID0gQ0xSX1BUUl9UWVBFKHBhcmVudF9zdGFja1tpXS0+YVtqXSk7Cgl9Cglhc3NlcnQoaSA9PSBuICYmIHBhcmVudF9zdGFja1tpXSA9PSB0cmVlKTsKCS8qIG5leHQsIHVud2luZCBzdGFjayB1bnRpbCBub3RlX3RyZWVfY29uc29saWRhdGUoKSBpcyBkb25lICovCgl3aGlsZSAoaSA+IDAgJiYKCSAgICAgICAhbm90ZV90cmVlX2NvbnNvbGlkYXRlKHBhcmVudF9zdGFja1tpXSwgcGFyZW50X3N0YWNrW2kgLSAxXSwKCQkJCSAgICAgIEdFVF9OSUJCTEUoaSAtIDEsIGVudHJ5LT5rZXlfb2lkLmhhc2gpKSkKCQlpLS07Cn0KCi8qCiAqIFRvIGluc2VydCBhIGxlYWZfbm9kZToKICogU2VhcmNoIHRvIHRoZSB0cmVlIGxvY2F0aW9uIGFwcHJvcHJpYXRlIGZvciB0aGUgZ2l2ZW4gbGVhZl9ub2RlJ3Mga2V5OgogKiAtIElmIGxvY2F0aW9uIGlzIHVudXNlZCAoTlVMTCksIHN0b3JlIHRoZSB0d2Vha2VkIHBvaW50ZXIgZGlyZWN0bHkgdGhlcmUKICogLSBJZiBsb2NhdGlvbiBob2xkcyBhIG5vdGUgZW50cnkgdGhhdCBtYXRjaGVzIHRoZSBub3RlLXRvLWJlLWluc2VydGVkLCB0aGVuCiAqICAgY29tYmluZSB0aGUgdHdvIG5vdGVzIChieSBjYWxsaW5nIHRoZSBnaXZlbiBjb21iaW5lX25vdGVzIGZ1bmN0aW9uKS4KICogLSBJZiBsb2NhdGlvbiBob2xkcyBhIG5vdGUgZW50cnkgdGhhdCBtYXRjaGVzIHRoZSBzdWJ0cmVlLXRvLWJlLWluc2VydGVkLAogKiAgIHRoZW4gdW5wYWNrIHRoZSBzdWJ0cmVlLXRvLWJlLWluc2VydGVkIGludG8gdGhlIGxvY2F0aW9uLgogKiAtIElmIGxvY2F0aW9uIGhvbGRzIGEgbWF0Y2hpbmcgc3VidHJlZSBlbnRyeSwgdW5wYWNrIHRoZSBzdWJ0cmVlIGF0IHRoYXQKICogICBsb2NhdGlvbiwgYW5kIHJlc3RhcnQgdGhlIGluc2VydCBvcGVyYXRpb24gZnJvbSB0aGF0IGxldmVsLgogKiAtIEVsc2UsIGNyZWF0ZSBhIG5ldyBpbnRfbm9kZSwgaG9sZGluZyBib3RoIHRoZSBub2RlLWF0LWxvY2F0aW9uIGFuZCB0aGUKICogICBub2RlLXRvLWJlLWluc2VydGVkLCBhbmQgc3RvcmUgdGhlIG5ldyBpbnRfbm9kZSBpbnRvIHRoZSBsb2NhdGlvbi4KICovCnN0YXRpYyBpbnQgbm90ZV90cmVlX2luc2VydChzdHJ1Y3Qgbm90ZXNfdHJlZSAqdCwgc3RydWN0IGludF9ub2RlICp0cmVlLAoJCXVuc2lnbmVkIGNoYXIgbiwgc3RydWN0IGxlYWZfbm9kZSAqZW50cnksIHVuc2lnbmVkIGNoYXIgdHlwZSwKCQljb21iaW5lX25vdGVzX2ZuIGNvbWJpbmVfbm90ZXMpCnsKCXN0cnVjdCBpbnRfbm9kZSAqbmV3X25vZGU7CglzdHJ1Y3QgbGVhZl9ub2RlICpsOwoJdm9pZCAqKnAgPSBub3RlX3RyZWVfc2VhcmNoKHQsICZ0cmVlLCAmbiwgZW50cnktPmtleV9vaWQuaGFzaCk7CglpbnQgcmV0ID0gMDsKCglhc3NlcnQoR0VUX1BUUl9UWVBFKGVudHJ5KSA9PSAwKTsgLyogbm8gdHlwZSBiaXRzIHNldCAqLwoJbCA9IChzdHJ1Y3QgbGVhZl9ub2RlICopIENMUl9QVFJfVFlQRSgqcCk7Cglzd2l0Y2ggKEdFVF9QVFJfVFlQRSgqcCkpIHsKCWNhc2UgUFRSX1RZUEVfTlVMTDoKCQlhc3NlcnQoISpwKTsKCQlpZiAoaXNfbnVsbF9vaWQoJmVudHJ5LT52YWxfb2lkKSkKCQkJZnJlZShlbnRyeSk7CgkJZWxzZQoJCQkqcCA9IFNFVF9QVFJfVFlQRShlbnRyeSwgdHlwZSk7CgkJcmV0dXJuIDA7CgljYXNlIFBUUl9UWVBFX05PVEU6CgkJc3dpdGNoICh0eXBlKSB7CgkJY2FzZSBQVFJfVFlQRV9OT1RFOgoJCQlpZiAoIW9pZGNtcCgmbC0+a2V5X29pZCwgJmVudHJ5LT5rZXlfb2lkKSkgewoJCQkJLyogc2tpcCBjb25jYXRlbmF0aW9uIGlmIGwgPT0gZW50cnkgKi8KCQkJCWlmICghb2lkY21wKCZsLT52YWxfb2lkLCAmZW50cnktPnZhbF9vaWQpKQoJCQkJCXJldHVybiAwOwoKCQkJCXJldCA9IGNvbWJpbmVfbm90ZXMobC0+dmFsX29pZC5oYXNoLAoJCQkJCQkgICAgZW50cnktPnZhbF9vaWQuaGFzaCk7CgkJCQlpZiAoIXJldCAmJiBpc19udWxsX29pZCgmbC0+dmFsX29pZCkpCgkJCQkJbm90ZV90cmVlX3JlbW92ZSh0LCB0cmVlLCBuLCBlbnRyeSk7CgkJCQlmcmVlKGVudHJ5KTsKCQkJCXJldHVybiByZXQ7CgkJCX0KCQkJYnJlYWs7CgkJY2FzZSBQVFJfVFlQRV9TVUJUUkVFOgoJCQlpZiAoIVNVQlRSRUVfU0hBMV9QUkVGSVhDTVAobC0+a2V5X29pZC5oYXNoLAoJCQkJCQkgICAgZW50cnktPmtleV9vaWQuaGFzaCkpIHsKCQkJCS8qIHVucGFjayAnZW50cnknICovCgkJCQlsb2FkX3N1YnRyZWUodCwgZW50cnksIHRyZWUsIG4pOwoJCQkJZnJlZShlbnRyeSk7CgkJCQlyZXR1cm4gMDsKCQkJfQoJCQlicmVhazsKCQl9CgkJYnJlYWs7CgljYXNlIFBUUl9UWVBFX1NVQlRSRUU6CgkJaWYgKCFTVUJUUkVFX1NIQTFfUFJFRklYQ01QKGVudHJ5LT5rZXlfb2lkLmhhc2gsIGwtPmtleV9vaWQuaGFzaCkpIHsKCQkJLyogdW5wYWNrICdsJyBhbmQgcmVzdGFydCBpbnNlcnQgKi8KCQkJKnAgPSBOVUxMOwoJCQlsb2FkX3N1YnRyZWUodCwgbCwgdHJlZSwgbik7CgkJCWZyZWUobCk7CgkJCXJldHVybiBub3RlX3RyZWVfaW5zZXJ0KHQsIHRyZWUsIG4sIGVudHJ5LCB0eXBlLAoJCQkJCQljb21iaW5lX25vdGVzKTsKCQl9CgkJYnJlYWs7Cgl9CgoJLyogbm9uLW1hdGNoaW5nIGxlYWZfbm9kZSAqLwoJYXNzZXJ0KEdFVF9QVFJfVFlQRSgqcCkgPT0gUFRSX1RZUEVfTk9URSB8fAoJICAgICAgIEdFVF9QVFJfVFlQRSgqcCkgPT0gUFRSX1RZUEVfU1VCVFJFRSk7CglpZiAoaXNfbnVsbF9vaWQoJmVudHJ5LT52YWxfb2lkKSkgeyAvKiBza2lwIGluc2VydGlvbiBvZiBlbXB0eSBub3RlICovCgkJZnJlZShlbnRyeSk7CgkJcmV0dXJuIDA7Cgl9CgluZXdfbm9kZSA9IChzdHJ1Y3QgaW50X25vZGUgKikgeGNhbGxvYygxLCBzaXplb2Yoc3RydWN0IGludF9ub2RlKSk7CglyZXQgPSBub3RlX3RyZWVfaW5zZXJ0KHQsIG5ld19ub2RlLCBuICsgMSwgbCwgR0VUX1BUUl9UWVBFKCpwKSwKCQkJICAgICAgIGNvbWJpbmVfbm90ZXMpOwoJaWYgKHJldCkKCQlyZXR1cm4gcmV0OwoJKnAgPSBTRVRfUFRSX1RZUEUobmV3X25vZGUsIFBUUl9UWVBFX0lOVEVSTkFMKTsKCXJldHVybiBub3RlX3RyZWVfaW5zZXJ0KHQsIG5ld19ub2RlLCBuICsgMSwgZW50cnksIHR5cGUsIGNvbWJpbmVfbm90ZXMpOwp9CgovKiBGcmVlIHRoZSBlbnRpcmUgbm90ZXMgZGF0YSBjb250YWluZWQgaW4gdGhlIGdpdmVuIHRyZWUgKi8Kc3RhdGljIHZvaWQgbm90ZV90cmVlX2ZyZWUoc3RydWN0IGludF9ub2RlICp0cmVlKQp7Cgl1bnNpZ25lZCBpbnQgaTsKCWZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7CgkJdm9pZCAqcCA9IHRyZWUtPmFbaV07CgkJc3dpdGNoIChHRVRfUFRSX1RZUEUocCkpIHsKCQljYXNlIFBUUl9UWVBFX0lOVEVSTkFMOgoJCQlub3RlX3RyZWVfZnJlZShDTFJfUFRSX1RZUEUocCkpOwoJCQkvKiBmYWxsIHRocm91Z2ggKi8KCQljYXNlIFBUUl9UWVBFX05PVEU6CgkJY2FzZSBQVFJfVFlQRV9TVUJUUkVFOgoJCQlmcmVlKENMUl9QVFJfVFlQRShwKSk7CgkJfQoJfQp9CgovKgogKiBDb252ZXJ0IGEgcGFydGlhbCBTSEExIGhleCBzdHJpbmcgdG8gdGhlIGNvcnJlc3BvbmRpbmcgcGFydGlhbCBTSEExIHZhbHVlLgogKiAtIGhleCAgICAgIC0gUGFydGlhbCBTSEExIHNlZ21lbnQgaW4gQVNDSUkgaGV4IGZvcm1hdAogKiAtIGhleF9sZW4gIC0gTGVuZ3RoIG9mIGFib3ZlIHNlZ21lbnQuIE11c3QgYmUgbXVsdGlwbGUgb2YgMiBiZXR3ZWVuIDAgYW5kIDQwCiAqIC0gb2lkICAgICAgLSBQYXJ0aWFsIFNIQTEgdmFsdWUgaXMgd3JpdHRlbiBoZXJlCiAqIC0gb2lkX2xlbiAgLSBNYXggI2J5dGVzIHRvIHN0b3JlIGluIHNoYTEsIE11c3QgYmUgPj0gaGV4X2xlbiAvIDIsIGFuZCA8IDIwCiAqIFJldHVybiAwIG9uIHN1Y2Nlc3Mgb3IgLTEgb24gZXJyb3IgKGludmFsaWQgYXJndW1lbnRzIG9yIGlucHV0IG5vdAogKiBpbiBoZXggZm9ybWF0KS4gUGFkIG9pZCB3aXRoIE5VTHMgdXAgdG8gb2lkX2xlbi4KICovCnN0YXRpYyBpbnQgZ2V0X29pZF9oZXhfc2VnbWVudChjb25zdCBjaGFyICpoZXgsIHVuc2lnbmVkIGludCBoZXhfbGVuLAoJCXVuc2lnbmVkIGNoYXIgKm9pZCwgdW5zaWduZWQgaW50IG9pZF9sZW4pCnsKCXVuc2lnbmVkIGludCBpLCBsZW4gPSBoZXhfbGVuID4+IDE7CglpZiAoaGV4X2xlbiAlIDIgIT0gMCB8fCBsZW4gPiBvaWRfbGVuKQoJCXJldHVybiAtMTsKCWZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykgewoJCXVuc2lnbmVkIGludCB2YWwgPSAoaGV4dmFsKGhleFswXSkgPDwgNCkgfCBoZXh2YWwoaGV4WzFdKTsKCQlpZiAodmFsICYgfjB4ZmYpCgkJCXJldHVybiAtMTsKCQkqb2lkKysgPSB2YWw7CgkJaGV4ICs9IDI7Cgl9Cglmb3IgKDsgaSA8IG9pZF9sZW47IGkrKykKCQkqb2lkKysgPSAwOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgbm9uX25vdGVfY21wKGNvbnN0IHN0cnVjdCBub25fbm90ZSAqYSwgY29uc3Qgc3RydWN0IG5vbl9ub3RlICpiKQp7CglyZXR1cm4gc3RyY21wKGEtPnBhdGgsIGItPnBhdGgpOwp9CgovKiBub3RlOiB0YWtlcyBvd25lcnNoaXAgb2YgcGF0aCBzdHJpbmcgKi8Kc3RhdGljIHZvaWQgYWRkX25vbl9ub3RlKHN0cnVjdCBub3Rlc190cmVlICp0LCBjaGFyICpwYXRoLAoJCXVuc2lnbmVkIGludCBtb2RlLCBjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExKQp7CglzdHJ1Y3Qgbm9uX25vdGUgKnAgPSB0LT5wcmV2X25vbl9ub3RlLCAqbjsKCW4gPSAoc3RydWN0IG5vbl9ub3RlICopIHhtYWxsb2Moc2l6ZW9mKHN0cnVjdCBub25fbm90ZSkpOwoJbi0+bmV4dCA9IE5VTEw7CgluLT5wYXRoID0gcGF0aDsKCW4tPm1vZGUgPSBtb2RlOwoJaGFzaGNweShuLT5vaWQuaGFzaCwgc2hhMSk7Cgl0LT5wcmV2X25vbl9ub3RlID0gbjsKCglpZiAoIXQtPmZpcnN0X25vbl9ub3RlKSB7CgkJdC0+Zmlyc3Rfbm9uX25vdGUgPSBuOwoJCXJldHVybjsKCX0KCglpZiAobm9uX25vdGVfY21wKHAsIG4pIDwgMCkKCQk7IC8qIGRvIG5vdGhpbmcgICovCgllbHNlIGlmIChub25fbm90ZV9jbXAodC0+Zmlyc3Rfbm9uX25vdGUsIG4pIDw9IDApCgkJcCA9IHQtPmZpcnN0X25vbl9ub3RlOwoJZWxzZSB7CgkJLyogbiBzb3J0cyBiZWZvcmUgdC0+Zmlyc3Rfbm9uX25vdGUgKi8KCQluLT5uZXh0ID0gdC0+Zmlyc3Rfbm9uX25vdGU7CgkJdC0+Zmlyc3Rfbm9uX25vdGUgPSBuOwoJCXJldHVybjsKCX0KCgkvKiBuIHNvcnRzIGVxdWFsIG9yIGFmdGVyIHAgKi8KCXdoaWxlIChwLT5uZXh0ICYmIG5vbl9ub3RlX2NtcChwLT5uZXh0LCBuKSA8PSAwKQoJCXAgPSBwLT5uZXh0OwoKCWlmIChub25fbm90ZV9jbXAocCwgbikgPT0gMCkgeyAvKiBuIH49IHA7IG92ZXJ3cml0ZSBwIHdpdGggbiAqLwoJCWFzc2VydChzdHJjbXAocC0+cGF0aCwgbi0+cGF0aCkgPT0gMCk7CgkJcC0+bW9kZSA9IG4tPm1vZGU7CgkJb2lkY3B5KCZwLT5vaWQsICZuLT5vaWQpOwoJCWZyZWUobik7CgkJdC0+cHJldl9ub25fbm90ZSA9IHA7CgkJcmV0dXJuOwoJfQoKCS8qIG4gc29ydHMgYmV0d2VlbiBwIGFuZCBwLT5uZXh0ICovCgluLT5uZXh0ID0gcC0+bmV4dDsKCXAtPm5leHQgPSBuOwp9CgpzdGF0aWMgdm9pZCBsb2FkX3N1YnRyZWUoc3RydWN0IG5vdGVzX3RyZWUgKnQsIHN0cnVjdCBsZWFmX25vZGUgKnN1YnRyZWUsCgkJc3RydWN0IGludF9ub2RlICpub2RlLCB1bnNpZ25lZCBpbnQgbikKewoJc3RydWN0IG9iamVjdF9pZCBvYmplY3Rfb2lkOwoJdW5zaWduZWQgaW50IHByZWZpeF9sZW47Cgl2b2lkICpidWY7CglzdHJ1Y3QgdHJlZV9kZXNjIGRlc2M7CglzdHJ1Y3QgbmFtZV9lbnRyeSBlbnRyeTsKCglidWYgPSBmaWxsX3RyZWVfZGVzY3JpcHRvcigmZGVzYywgc3VidHJlZS0+dmFsX29pZC5oYXNoKTsKCWlmICghYnVmKQoJCWRpZSgiQ291bGQgbm90IHJlYWQgJXMgZm9yIG5vdGVzLWluZGV4IiwKCQkgICAgIG9pZF90b19oZXgoJnN1YnRyZWUtPnZhbF9vaWQpKTsKCglwcmVmaXhfbGVuID0gc3VidHJlZS0+a2V5X29pZC5oYXNoW0tFWV9JTkRFWF07Cglhc3NlcnQocHJlZml4X2xlbiAqIDIgPj0gbik7CgltZW1jcHkob2JqZWN0X29pZC5oYXNoLCBzdWJ0cmVlLT5rZXlfb2lkLmhhc2gsIHByZWZpeF9sZW4pOwoJd2hpbGUgKHRyZWVfZW50cnkoJmRlc2MsICZlbnRyeSkpIHsKCQl1bnNpZ25lZCBjaGFyIHR5cGU7CgkJc3RydWN0IGxlYWZfbm9kZSAqbDsKCQlpbnQgcGF0aF9sZW4gPSBzdHJsZW4oZW50cnkucGF0aCk7CgoJCWlmIChwYXRoX2xlbiA9PSAyICogKEdJVF9TSEExX1JBV1NaIC0gcHJlZml4X2xlbikpIHsKCQkJLyogVGhpcyBpcyBwb3RlbnRpYWxseSB0aGUgcmVtYWluZGVyIG9mIHRoZSBTSEEtMSAqLwoKCQkJaWYgKCFTX0lTUkVHKGVudHJ5Lm1vZGUpKQoJCQkJLyogbm90ZXMgbXVzdCBiZSBibG9icyAqLwoJCQkJZ290byBoYW5kbGVfbm9uX25vdGU7CgoJCQlpZiAoZ2V0X29pZF9oZXhfc2VnbWVudChlbnRyeS5wYXRoLCBwYXRoX2xlbiwKCQkJCQkJb2JqZWN0X29pZC5oYXNoICsgcHJlZml4X2xlbiwKCQkJCQkJR0lUX1NIQTFfUkFXU1ogLSBwcmVmaXhfbGVuKSkKCQkJCWdvdG8gaGFuZGxlX25vbl9ub3RlOyAvKiBlbnRyeS5wYXRoIGlzIG5vdCBhIFNIQTEgKi8KCgkJCXR5cGUgPSBQVFJfVFlQRV9OT1RFOwoJCX0gZWxzZSBpZiAocGF0aF9sZW4gPT0gMikgewoJCQkvKiBUaGlzIGlzIHBvdGVudGlhbGx5IGFuIGludGVybmFsIG5vZGUgKi8KCgkJCWlmICghU19JU0RJUihlbnRyeS5tb2RlKSkKCQkJCS8qIGludGVybmFsIG5vZGVzIG11c3QgYmUgdHJlZXMgKi8KCQkJCWdvdG8gaGFuZGxlX25vbl9ub3RlOwoKCQkJaWYgKGdldF9vaWRfaGV4X3NlZ21lbnQoZW50cnkucGF0aCwgMiwKCQkJCQkJb2JqZWN0X29pZC5oYXNoICsgcHJlZml4X2xlbiwKCQkJCQkJR0lUX1NIQTFfUkFXU1ogLSBwcmVmaXhfbGVuKSkKCQkJCWdvdG8gaGFuZGxlX25vbl9ub3RlOyAvKiBlbnRyeS5wYXRoIGlzIG5vdCBhIFNIQTEgKi8KCgkJCW9iamVjdF9vaWQuaGFzaFtLRVlfSU5ERVhdID0gKHVuc2lnbmVkIGNoYXIpIChwcmVmaXhfbGVuICsgMSk7CgoJCQl0eXBlID0gUFRSX1RZUEVfU1VCVFJFRTsKCQl9IGVsc2UgewoJCQkvKiBUaGlzIGNhbid0IGJlIHBhcnQgb2YgYSBub3RlICovCgkJCWdvdG8gaGFuZGxlX25vbl9ub3RlOwoJCX0KCgkJbCA9IHhjYWxsb2MoMSwgc2l6ZW9mKCpsKSk7CgkJb2lkY3B5KCZsLT5rZXlfb2lkLCAmb2JqZWN0X29pZCk7CgkJb2lkY3B5KCZsLT52YWxfb2lkLCBlbnRyeS5vaWQpOwoJCWlmIChub3RlX3RyZWVfaW5zZXJ0KHQsIG5vZGUsIG4sIGwsIHR5cGUsCgkJCQkgICAgIGNvbWJpbmVfbm90ZXNfY29uY2F0ZW5hdGUpKQoJCQlkaWUoIkZhaWxlZCB0byBsb2FkICVzICVzIGludG8gbm90ZXMgdHJlZSAiCgkJCSAgICAiZnJvbSAlcyIsCgkJCSAgICB0eXBlID09IFBUUl9UWVBFX05PVEUgPyAibm90ZSIgOiAic3VidHJlZSIsCgkJCSAgICBvaWRfdG9faGV4KCZsLT5rZXlfb2lkKSwgdC0+cmVmKTsKCgkJY29udGludWU7CgpoYW5kbGVfbm9uX25vdGU6CgkJLyoKCQkgKiBEZXRlcm1pbmUgZnVsbCBwYXRoIGZvciB0aGlzIG5vbi1ub3RlIGVudHJ5LiBUaGUKCQkgKiBmaWxlbmFtZSBpcyBhbHJlYWR5IGZvdW5kIGluIGVudHJ5LnBhdGgsIGJ1dCB0aGUKCQkgKiBkaXJlY3RvcnkgcGFydCBvZiB0aGUgcGF0aCBtdXN0IGJlIGRlZHVjZWQgZnJvbSB0aGUKCQkgKiBzdWJ0cmVlIGNvbnRhaW5pbmcgdGhpcyBlbnRyeSBiYXNlZCBvbiBvdXIKCQkgKiBrbm93bGVkZ2UgdGhhdCB0aGUgb3ZlcmFsbCBub3RlcyB0cmVlIGZvbGxvd3MgYQoJCSAqIHN0cmljdCBieXRlLWJhc2VkIHByb2dyZXNzaXZlIGZhbm91dCBzdHJ1Y3R1cmUKCQkgKiAoaS5lLiB1c2luZyAyLzM4LCAyLzIvMzYsIGV0Yy4gZmFub3V0cykuCgkJICovCgkJewoJCQlzdHJ1Y3Qgc3RyYnVmIG5vbl9ub3RlX3BhdGggPSBTVFJCVUZfSU5JVDsKCQkJY29uc3QgY2hhciAqcSA9IG9pZF90b19oZXgoJnN1YnRyZWUtPmtleV9vaWQpOwoJCQlpbnQgaTsKCQkJZm9yIChpID0gMDsgaSA8IHByZWZpeF9sZW47IGkrKykgewoJCQkJc3RyYnVmX2FkZGNoKCZub25fbm90ZV9wYXRoLCAqcSsrKTsKCQkJCXN0cmJ1Zl9hZGRjaCgmbm9uX25vdGVfcGF0aCwgKnErKyk7CgkJCQlzdHJidWZfYWRkY2goJm5vbl9ub3RlX3BhdGgsICcvJyk7CgkJCX0KCQkJc3RyYnVmX2FkZHN0cigmbm9uX25vdGVfcGF0aCwgZW50cnkucGF0aCk7CgkJCWFkZF9ub25fbm90ZSh0LCBzdHJidWZfZGV0YWNoKCZub25fbm90ZV9wYXRoLCBOVUxMKSwKCQkJCSAgICAgZW50cnkubW9kZSwgZW50cnkub2lkLT5oYXNoKTsKCQl9Cgl9CglmcmVlKGJ1Zik7Cn0KCi8qCiAqIERldGVybWluZSBvcHRpbWFsIG9uLWRpc2sgZmFub3V0IGZvciB0aGlzIHBhcnQgb2YgdGhlIG5vdGVzIHRyZWUKICoKICogR2l2ZW4gYSAoc3ViKXRyZWUgYW5kIHRoZSBsZXZlbCBpbiB0aGUgaW50ZXJuYWwgdHJlZSBzdHJ1Y3R1cmUsIGRldGVybWluZQogKiB3aGV0aGVyIG9yIG5vdCB0aGUgZ2l2ZW4gZXhpc3RpbmcgZmFub3V0IHNob3VsZCBiZSBleHBhbmRlZCBmb3IgdGhpcwogKiAoc3ViKXRyZWUuCiAqCiAqIFZhbHVlcyBvZiB0aGUgJ2Zhbm91dCcgdmFyaWFibGU6CiAqIC0gMDogTm8gZmFub3V0IChhbGwgbm90ZXMgYXJlIHN0b3JlZCBkaXJlY3RseSBpbiB0aGUgcm9vdCBub3RlcyB0cmVlKQogKiAtIDE6IDIvMzggZmFub3V0CiAqIC0gMjogMi8yLzM2IGZhbm91dAogKiAtIDM6IDIvMi8yLzM0IGZhbm91dAogKiBldGMuCiAqLwpzdGF0aWMgdW5zaWduZWQgY2hhciBkZXRlcm1pbmVfZmFub3V0KHN0cnVjdCBpbnRfbm9kZSAqdHJlZSwgdW5zaWduZWQgY2hhciBuLAoJCXVuc2lnbmVkIGNoYXIgZmFub3V0KQp7CgkvKgoJICogVGhlIGZvbGxvd2luZyBpcyBhIHNpbXBsZSBoZXVyaXN0aWMgdGhhdCB3b3JrcyB3ZWxsIGluIHByYWN0aWNlOgoJICogRm9yIGVhY2ggZXZlbi1udW1iZXJlZCAxNi10cmVlIGxldmVsIChyZW1lbWJlciB0aGF0IGVhY2ggb24tZGlzawoJICogZmFub3V0IGxldmVsIGNvcnJlc3BvbmRzIHRvIF90d29fIDE2LXRyZWUgbGV2ZWxzKSwgcGVlayBhdCBhbGwgMTYKCSAqIGVudHJpZXMgYXQgdGhhdCB0cmVlIGxldmVsLiBJZiBhbGwgb2YgdGhlbSBhcmUgZWl0aGVyIGludF9ub2RlcyBvcgoJICogc3VidHJlZSBlbnRyaWVzLCB0aGVuIHRoZXJlIGFyZSBsaWtlbHkgcGxlbnR5IG9mIG5vdGVzIGJlbG93IHRoaXMKCSAqIGxldmVsLCBzbyB3ZSByZXR1cm4gYW4gaW5jcmVtZW50ZWQgZmFub3V0LgoJICovCgl1bnNpZ25lZCBpbnQgaTsKCWlmICgobiAlIDIpIHx8IChuID4gMiAqIGZhbm91dCkpCgkJcmV0dXJuIGZhbm91dDsKCWZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7CgkJc3dpdGNoIChHRVRfUFRSX1RZUEUodHJlZS0+YVtpXSkpIHsKCQljYXNlIFBUUl9UWVBFX1NVQlRSRUU6CgkJY2FzZSBQVFJfVFlQRV9JTlRFUk5BTDoKCQkJY29udGludWU7CgkJZGVmYXVsdDoKCQkJcmV0dXJuIGZhbm91dDsKCQl9Cgl9CglyZXR1cm4gZmFub3V0ICsgMTsKfQoKLyogaGV4IFNIQTEgKyAxOSAqICcvJyArIE5VTCAqLwojZGVmaW5lIEZBTk9VVF9QQVRIX01BWCBHSVRfU0hBMV9IRVhTWiArIEZBTk9VVF9QQVRIX1NFUEFSQVRPUlMgKyAxCgpzdGF0aWMgdm9pZCBjb25zdHJ1Y3RfcGF0aF93aXRoX2Zhbm91dChjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExLAoJCXVuc2lnbmVkIGNoYXIgZmFub3V0LCBjaGFyICpwYXRoKQp7Cgl1bnNpZ25lZCBpbnQgaSA9IDAsIGogPSAwOwoJY29uc3QgY2hhciAqaGV4X3NoYTEgPSBzaGExX3RvX2hleChzaGExKTsKCWFzc2VydChmYW5vdXQgPCBHSVRfU0hBMV9SQVdTWik7Cgl3aGlsZSAoZmFub3V0KSB7CgkJcGF0aFtpKytdID0gaGV4X3NoYTFbaisrXTsKCQlwYXRoW2krK10gPSBoZXhfc2hhMVtqKytdOwoJCXBhdGhbaSsrXSA9ICcvJzsKCQlmYW5vdXQtLTsKCX0KCXhzbnByaW50ZihwYXRoICsgaSwgRkFOT1VUX1BBVEhfTUFYIC0gaSwgIiVzIiwgaGV4X3NoYTEgKyBqKTsKfQoKc3RhdGljIGludCBmb3JfZWFjaF9ub3RlX2hlbHBlcihzdHJ1Y3Qgbm90ZXNfdHJlZSAqdCwgc3RydWN0IGludF9ub2RlICp0cmVlLAoJCXVuc2lnbmVkIGNoYXIgbiwgdW5zaWduZWQgY2hhciBmYW5vdXQsIGludCBmbGFncywKCQllYWNoX25vdGVfZm4gZm4sIHZvaWQgKmNiX2RhdGEpCnsKCXVuc2lnbmVkIGludCBpOwoJdm9pZCAqcDsKCWludCByZXQgPSAwOwoJc3RydWN0IGxlYWZfbm9kZSAqbDsKCXN0YXRpYyBjaGFyIHBhdGhbRkFOT1VUX1BBVEhfTUFYXTsKCglmYW5vdXQgPSBkZXRlcm1pbmVfZmFub3V0KHRyZWUsIG4sIGZhbm91dCk7Cglmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykgewpyZWRvOgoJCXAgPSB0cmVlLT5hW2ldOwoJCXN3aXRjaCAoR0VUX1BUUl9UWVBFKHApKSB7CgkJY2FzZSBQVFJfVFlQRV9JTlRFUk5BTDoKCQkJLyogcmVjdXJzZSBpbnRvIGludF9ub2RlICovCgkJCXJldCA9IGZvcl9lYWNoX25vdGVfaGVscGVyKHQsIENMUl9QVFJfVFlQRShwKSwgbiArIDEsCgkJCQlmYW5vdXQsIGZsYWdzLCBmbiwgY2JfZGF0YSk7CgkJCWJyZWFrOwoJCWNhc2UgUFRSX1RZUEVfU1VCVFJFRToKCQkJbCA9IChzdHJ1Y3QgbGVhZl9ub2RlICopIENMUl9QVFJfVFlQRShwKTsKCQkJLyoKCQkJICogU3VidHJlZSBlbnRyaWVzIGluIHRoZSBub3RlIHRyZWUgcmVwcmVzZW50IHBhcnRzIG9mCgkJCSAqIHRoZSBub3RlIHRyZWUgdGhhdCBoYXZlIG5vdCB5ZXQgYmVlbiBleHBsb3JlZC4gVGhlcmUKCQkJICogaXMgYSBkaXJlY3QgcmVsYXRpb25zaGlwIGJldHdlZW4gc3VidHJlZSBlbnRyaWVzIGF0CgkJCSAqIGxldmVsICduJyBpbiB0aGUgdHJlZSwgYW5kIHRoZSAnZmFub3V0JyB2YXJpYWJsZToKCQkJICogU3VidHJlZSBlbnRyaWVzIGF0IGxldmVsICduIDw9IDIgKiBmYW5vdXQnIHNob3VsZCBiZQoJCQkgKiBwcmVzZXJ2ZWQsIHNpbmNlIHRoZXkgY29ycmVzcG9uZCBleGFjdGx5IHRvIGEgZmFub3V0CgkJCSAqIGRpcmVjdG9yeSBpbiB0aGUgb24tZGlzayBzdHJ1Y3R1cmUuIEhvd2V2ZXIsIHN1YnRyZWUKCQkJICogZW50cmllcyBhdCBsZXZlbCAnbiA+IDIgKiBmYW5vdXQnIHNob3VsZCBOT1QgYmUKCQkJICogcHJlc2VydmVkLCBidXQgcmF0aGVyIGNvbnNvbGlkYXRlZCBpbnRvIHRoZSBhYm92ZQoJCQkgKiBub3RlcyB0cmVlIGxldmVsLiBXZSBhY2hpZXZlIHRoaXMgYnkgdW5jb25kaXRpb25hbGx5CgkJCSAqIHVucGFja2luZyBzdWJ0cmVlIGVudHJpZXMgdGhhdCBleGlzdCBiZWxvdyB0aGUKCQkJICogdGhyZXNob2xkIGxldmVsIGF0ICduID0gMiAqIGZhbm91dCcuCgkJCSAqLwoJCQlpZiAobiA8PSAyICogZmFub3V0ICYmCgkJCSAgICBmbGFncyAmIEZPUl9FQUNIX05PVEVfWUlFTERfU1VCVFJFRVMpIHsKCQkJCS8qIGludm9rZSBjYWxsYmFjayB3aXRoIHN1YnRyZWUgKi8KCQkJCXVuc2lnbmVkIGludCBwYXRoX2xlbiA9CgkJCQkJbC0+a2V5X29pZC5oYXNoW0tFWV9JTkRFWF0gKiAyICsgZmFub3V0OwoJCQkJYXNzZXJ0KHBhdGhfbGVuIDwgRkFOT1VUX1BBVEhfTUFYIC0gMSk7CgkJCQljb25zdHJ1Y3RfcGF0aF93aXRoX2Zhbm91dChsLT5rZXlfb2lkLmhhc2gsCgkJCQkJCQkgICBmYW5vdXQsCgkJCQkJCQkgICBwYXRoKTsKCQkJCS8qIENyZWF0ZSB0cmFpbGluZyBzbGFzaCwgaWYgbmVlZGVkICovCgkJCQlpZiAocGF0aFtwYXRoX2xlbiAtIDFdICE9ICcvJykKCQkJCQlwYXRoW3BhdGhfbGVuKytdID0gJy8nOwoJCQkJcGF0aFtwYXRoX2xlbl0gPSAnXDAnOwoJCQkJcmV0ID0gZm4oJmwtPmtleV9vaWQsICZsLT52YWxfb2lkLAoJCQkJCSBwYXRoLAoJCQkJCSBjYl9kYXRhKTsKCQkJfQoJCQlpZiAobiA+IGZhbm91dCAqIDIgfHwKCQkJICAgICEoZmxhZ3MgJiBGT1JfRUFDSF9OT1RFX0RPTlRfVU5QQUNLX1NVQlRSRUVTKSkgewoJCQkJLyogdW5wYWNrIHN1YnRyZWUgYW5kIHJlc3VtZSB0cmF2ZXJzYWwgKi8KCQkJCXRyZWUtPmFbaV0gPSBOVUxMOwoJCQkJbG9hZF9zdWJ0cmVlKHQsIGwsIHRyZWUsIG4pOwoJCQkJZnJlZShsKTsKCQkJCWdvdG8gcmVkbzsKCQkJfQoJCQlicmVhazsKCQljYXNlIFBUUl9UWVBFX05PVEU6CgkJCWwgPSAoc3RydWN0IGxlYWZfbm9kZSAqKSBDTFJfUFRSX1RZUEUocCk7CgkJCWNvbnN0cnVjdF9wYXRoX3dpdGhfZmFub3V0KGwtPmtleV9vaWQuaGFzaCwgZmFub3V0LAoJCQkJCQkgICBwYXRoKTsKCQkJcmV0ID0gZm4oJmwtPmtleV9vaWQsICZsLT52YWxfb2lkLCBwYXRoLAoJCQkJIGNiX2RhdGEpOwoJCQlicmVhazsKCQl9CgkJaWYgKHJldCkKCQkJcmV0dXJuIHJldDsKCX0KCXJldHVybiAwOwp9CgpzdHJ1Y3QgdHJlZV93cml0ZV9zdGFjayB7CglzdHJ1Y3QgdHJlZV93cml0ZV9zdGFjayAqbmV4dDsKCXN0cnVjdCBzdHJidWYgYnVmOwoJY2hhciBwYXRoWzJdOyAvKiBwYXRoIHRvIHN1YnRyZWUgaW4gbmV4dCwgaWYgYW55ICovCn07CgpzdGF0aWMgaW5saW5lIGludCBtYXRjaGVzX3RyZWVfd3JpdGVfc3RhY2soc3RydWN0IHRyZWVfd3JpdGVfc3RhY2sgKnR3cywKCQljb25zdCBjaGFyICpmdWxsX3BhdGgpCnsKCXJldHVybiAgZnVsbF9wYXRoWzBdID09IHR3cy0+cGF0aFswXSAmJgoJCWZ1bGxfcGF0aFsxXSA9PSB0d3MtPnBhdGhbMV0gJiYKCQlmdWxsX3BhdGhbMl0gPT0gJy8nOwp9CgpzdGF0aWMgdm9pZCB3cml0ZV90cmVlX2VudHJ5KHN0cnVjdCBzdHJidWYgKmJ1ZiwgdW5zaWduZWQgaW50IG1vZGUsCgkJY29uc3QgY2hhciAqcGF0aCwgdW5zaWduZWQgaW50IHBhdGhfbGVuLCBjb25zdAoJCXVuc2lnbmVkIGNoYXIgKnNoYTEpCnsKCXN0cmJ1Zl9hZGRmKGJ1ZiwgIiVvICUuKnMlYyIsIG1vZGUsIHBhdGhfbGVuLCBwYXRoLCAnXDAnKTsKCXN0cmJ1Zl9hZGQoYnVmLCBzaGExLCBHSVRfU0hBMV9SQVdTWik7Cn0KCnN0YXRpYyB2b2lkIHRyZWVfd3JpdGVfc3RhY2tfaW5pdF9zdWJ0cmVlKHN0cnVjdCB0cmVlX3dyaXRlX3N0YWNrICp0d3MsCgkJY29uc3QgY2hhciAqcGF0aCkKewoJc3RydWN0IHRyZWVfd3JpdGVfc3RhY2sgKm47Cglhc3NlcnQoIXR3cy0+bmV4dCk7Cglhc3NlcnQodHdzLT5wYXRoWzBdID09ICdcMCcgJiYgdHdzLT5wYXRoWzFdID09ICdcMCcpOwoJbiA9IChzdHJ1Y3QgdHJlZV93cml0ZV9zdGFjayAqKQoJCXhtYWxsb2Moc2l6ZW9mKHN0cnVjdCB0cmVlX3dyaXRlX3N0YWNrKSk7CgluLT5uZXh0ID0gTlVMTDsKCXN0cmJ1Zl9pbml0KCZuLT5idWYsIDI1NiAqICgzMiArIEdJVF9TSEExX0hFWFNaKSk7IC8qIGFzc3VtZSAyNTYgZW50cmllcyBwZXIgdHJlZSAqLwoJbi0+cGF0aFswXSA9IG4tPnBhdGhbMV0gPSAnXDAnOwoJdHdzLT5uZXh0ID0gbjsKCXR3cy0+cGF0aFswXSA9IHBhdGhbMF07Cgl0d3MtPnBhdGhbMV0gPSBwYXRoWzFdOwp9CgpzdGF0aWMgaW50IHRyZWVfd3JpdGVfc3RhY2tfZmluaXNoX3N1YnRyZWUoc3RydWN0IHRyZWVfd3JpdGVfc3RhY2sgKnR3cykKewoJaW50IHJldDsKCXN0cnVjdCB0cmVlX3dyaXRlX3N0YWNrICpuID0gdHdzLT5uZXh0OwoJc3RydWN0IG9iamVjdF9pZCBzOwoJaWYgKG4pIHsKCQlyZXQgPSB0cmVlX3dyaXRlX3N0YWNrX2ZpbmlzaF9zdWJ0cmVlKG4pOwoJCWlmIChyZXQpCgkJCXJldHVybiByZXQ7CgkJcmV0ID0gd3JpdGVfc2hhMV9maWxlKG4tPmJ1Zi5idWYsIG4tPmJ1Zi5sZW4sIHRyZWVfdHlwZSwgcy5oYXNoKTsKCQlpZiAocmV0KQoJCQlyZXR1cm4gcmV0OwoJCXN0cmJ1Zl9yZWxlYXNlKCZuLT5idWYpOwoJCWZyZWUobik7CgkJdHdzLT5uZXh0ID0gTlVMTDsKCQl3cml0ZV90cmVlX2VudHJ5KCZ0d3MtPmJ1ZiwgMDQwMDAwLCB0d3MtPnBhdGgsIDIsIHMuaGFzaCk7CgkJdHdzLT5wYXRoWzBdID0gdHdzLT5wYXRoWzFdID0gJ1wwJzsKCX0KCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IHdyaXRlX2VhY2hfbm90ZV9oZWxwZXIoc3RydWN0IHRyZWVfd3JpdGVfc3RhY2sgKnR3cywKCQljb25zdCBjaGFyICpwYXRoLCB1bnNpZ25lZCBpbnQgbW9kZSwKCQljb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQpCnsKCXNpemVfdCBwYXRoX2xlbiA9IHN0cmxlbihwYXRoKTsKCXVuc2lnbmVkIGludCBuID0gMDsKCWludCByZXQ7CgoJLyogRGV0ZXJtaW5lIGNvbW1vbiBwYXJ0IG9mIHRyZWUgd3JpdGUgc3RhY2sgKi8KCXdoaWxlICh0d3MgJiYgMyAqIG4gPCBwYXRoX2xlbiAmJgoJICAgICAgIG1hdGNoZXNfdHJlZV93cml0ZV9zdGFjayh0d3MsIHBhdGggKyAzICogbikpIHsKCQluKys7CgkJdHdzID0gdHdzLT5uZXh0OwoJfQoKCS8qIHR3cyBwb2ludCB0byBsYXN0IG1hdGNoaW5nIHRyZWVfd3JpdGVfc3RhY2sgZW50cnkgKi8KCXJldCA9IHRyZWVfd3JpdGVfc3RhY2tfZmluaXNoX3N1YnRyZWUodHdzKTsKCWlmIChyZXQpCgkJcmV0dXJuIHJldDsKCgkvKiBTdGFydCBzdWJ0cmVlcyBuZWVkZWQgdG8gc2F0aXNmeSBwYXRoICovCgl3aGlsZSAoMyAqIG4gKyAyIDwgcGF0aF9sZW4gJiYgcGF0aFszICogbiArIDJdID09ICcvJykgewoJCXRyZWVfd3JpdGVfc3RhY2tfaW5pdF9zdWJ0cmVlKHR3cywgcGF0aCArIDMgKiBuKTsKCQluKys7CgkJdHdzID0gdHdzLT5uZXh0OwoJfQoKCS8qIFRoZXJlIHNob3VsZCBiZSBubyBtb3JlIGRpcmVjdG9yeSBjb21wb25lbnRzIGluIHRoZSBnaXZlbiBwYXRoICovCglhc3NlcnQobWVtY2hyKHBhdGggKyAzICogbiwgJy8nLCBwYXRoX2xlbiAtICgzICogbikpID09IE5VTEwpOwoKCS8qIEZpbmFsbHkgYWRkIGdpdmVuIGVudHJ5IHRvIHRoZSBjdXJyZW50IHRyZWUgb2JqZWN0ICovCgl3cml0ZV90cmVlX2VudHJ5KCZ0d3MtPmJ1ZiwgbW9kZSwgcGF0aCArIDMgKiBuLCBwYXRoX2xlbiAtICgzICogbiksCgkJCSBvaWQtPmhhc2gpOwoKCXJldHVybiAwOwp9CgpzdHJ1Y3Qgd3JpdGVfZWFjaF9ub3RlX2RhdGEgewoJc3RydWN0IHRyZWVfd3JpdGVfc3RhY2sgKnJvb3Q7CglzdHJ1Y3Qgbm9uX25vdGUgKm5leHRfbm9uX25vdGU7Cn07CgpzdGF0aWMgaW50IHdyaXRlX2VhY2hfbm9uX25vdGVfdW50aWwoY29uc3QgY2hhciAqbm90ZV9wYXRoLAoJCXN0cnVjdCB3cml0ZV9lYWNoX25vdGVfZGF0YSAqZCkKewoJc3RydWN0IG5vbl9ub3RlICpuID0gZC0+bmV4dF9ub25fbm90ZTsKCWludCBjbXAgPSAwLCByZXQ7Cgl3aGlsZSAobiAmJiAoIW5vdGVfcGF0aCB8fCAoY21wID0gc3RyY21wKG4tPnBhdGgsIG5vdGVfcGF0aCkpIDw9IDApKSB7CgkJaWYgKG5vdGVfcGF0aCAmJiBjbXAgPT0gMCkKCQkJOyAvKiBkbyBub3RoaW5nLCBwcmVmZXIgbm90ZSB0byBub24tbm90ZSAqLwoJCWVsc2UgewoJCQlyZXQgPSB3cml0ZV9lYWNoX25vdGVfaGVscGVyKGQtPnJvb3QsIG4tPnBhdGgsIG4tPm1vZGUsCgkJCQkJCSAgICAgJm4tPm9pZCk7CgkJCWlmIChyZXQpCgkJCQlyZXR1cm4gcmV0OwoJCX0KCQluID0gbi0+bmV4dDsKCX0KCWQtPm5leHRfbm9uX25vdGUgPSBuOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgd3JpdGVfZWFjaF9ub3RlKGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9iamVjdF9vaWQsCgkJY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqbm90ZV9vaWQsIGNoYXIgKm5vdGVfcGF0aCwKCQl2b2lkICpjYl9kYXRhKQp7CglzdHJ1Y3Qgd3JpdGVfZWFjaF9ub3RlX2RhdGEgKmQgPQoJCShzdHJ1Y3Qgd3JpdGVfZWFjaF9ub3RlX2RhdGEgKikgY2JfZGF0YTsKCXNpemVfdCBub3RlX3BhdGhfbGVuID0gc3RybGVuKG5vdGVfcGF0aCk7Cgl1bnNpZ25lZCBpbnQgbW9kZSA9IDAxMDA2NDQ7CgoJaWYgKG5vdGVfcGF0aFtub3RlX3BhdGhfbGVuIC0gMV0gPT0gJy8nKSB7CgkJLyogc3VidHJlZSBlbnRyeSAqLwoJCW5vdGVfcGF0aF9sZW4tLTsKCQlub3RlX3BhdGhbbm90ZV9wYXRoX2xlbl0gPSAnXDAnOwoJCW1vZGUgPSAwNDAwMDA7Cgl9Cglhc3NlcnQobm90ZV9wYXRoX2xlbiA8PSBHSVRfU0hBMV9IRVhTWiArIEZBTk9VVF9QQVRIX1NFUEFSQVRPUlMpOwoKCS8qIFdlYXZlIG5vbi1ub3RlIGVudHJpZXMgaW50byBub3RlIGVudHJpZXMgKi8KCXJldHVybiAgd3JpdGVfZWFjaF9ub25fbm90ZV91bnRpbChub3RlX3BhdGgsIGQpIHx8CgkJd3JpdGVfZWFjaF9ub3RlX2hlbHBlcihkLT5yb290LCBub3RlX3BhdGgsIG1vZGUsIG5vdGVfb2lkKTsKfQoKc3RydWN0IG5vdGVfZGVsZXRlX2xpc3QgewoJc3RydWN0IG5vdGVfZGVsZXRlX2xpc3QgKm5leHQ7Cgljb25zdCB1bnNpZ25lZCBjaGFyICpzaGExOwp9OwoKc3RhdGljIGludCBwcnVuZV9ub3Rlc19oZWxwZXIoY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2JqZWN0X29pZCwKCQljb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpub3RlX29pZCwgY2hhciAqbm90ZV9wYXRoLAoJCXZvaWQgKmNiX2RhdGEpCnsKCXN0cnVjdCBub3RlX2RlbGV0ZV9saXN0ICoqbCA9IChzdHJ1Y3Qgbm90ZV9kZWxldGVfbGlzdCAqKikgY2JfZGF0YTsKCXN0cnVjdCBub3RlX2RlbGV0ZV9saXN0ICpuOwoKCWlmIChoYXNfb2JqZWN0X2ZpbGUob2JqZWN0X29pZCkpCgkJcmV0dXJuIDA7IC8qIG5vdGhpbmcgdG8gZG8gZm9yIHRoaXMgbm90ZSAqLwoKCS8qIGZhaWxlZCB0byBmaW5kIG9iamVjdCA9PiBwcnVuZSB0aGlzIG5vdGUgKi8KCW4gPSAoc3RydWN0IG5vdGVfZGVsZXRlX2xpc3QgKikgeG1hbGxvYyhzaXplb2YoKm4pKTsKCW4tPm5leHQgPSAqbDsKCW4tPnNoYTEgPSBvYmplY3Rfb2lkLT5oYXNoOwoJKmwgPSBuOwoJcmV0dXJuIDA7Cn0KCmludCBjb21iaW5lX25vdGVzX2NvbmNhdGVuYXRlKHVuc2lnbmVkIGNoYXIgKmN1cl9zaGExLAoJCWNvbnN0IHVuc2lnbmVkIGNoYXIgKm5ld19zaGExKQp7CgljaGFyICpjdXJfbXNnID0gTlVMTCwgKm5ld19tc2cgPSBOVUxMLCAqYnVmOwoJdW5zaWduZWQgbG9uZyBjdXJfbGVuLCBuZXdfbGVuLCBidWZfbGVuOwoJZW51bSBvYmplY3RfdHlwZSBjdXJfdHlwZSwgbmV3X3R5cGU7CglpbnQgcmV0OwoKCS8qIHJlYWQgaW4gYm90aCBub3RlIGJsb2Igb2JqZWN0cyAqLwoJaWYgKCFpc19udWxsX3NoYTEobmV3X3NoYTEpKQoJCW5ld19tc2cgPSByZWFkX3NoYTFfZmlsZShuZXdfc2hhMSwgJm5ld190eXBlLCAmbmV3X2xlbik7CglpZiAoIW5ld19tc2cgfHwgIW5ld19sZW4gfHwgbmV3X3R5cGUgIT0gT0JKX0JMT0IpIHsKCQlmcmVlKG5ld19tc2cpOwoJCXJldHVybiAwOwoJfQoJaWYgKCFpc19udWxsX3NoYTEoY3VyX3NoYTEpKQoJCWN1cl9tc2cgPSByZWFkX3NoYTFfZmlsZShjdXJfc2hhMSwgJmN1cl90eXBlLCAmY3VyX2xlbik7CglpZiAoIWN1cl9tc2cgfHwgIWN1cl9sZW4gfHwgY3VyX3R5cGUgIT0gT0JKX0JMT0IpIHsKCQlmcmVlKGN1cl9tc2cpOwoJCWZyZWUobmV3X21zZyk7CgkJaGFzaGNweShjdXJfc2hhMSwgbmV3X3NoYTEpOwoJCXJldHVybiAwOwoJfQoKCS8qIHdlIHdpbGwgc2VwYXJhdGUgdGhlIG5vdGVzIGJ5IHR3byBuZXdsaW5lcyBhbnl3YXkgKi8KCWlmIChjdXJfbXNnW2N1cl9sZW4gLSAxXSA9PSAnXG4nKQoJCWN1cl9sZW4tLTsKCgkvKiBjb25jYXRlbmF0ZSBjdXJfbXNnIGFuZCBuZXdfbXNnIGludG8gYnVmICovCglidWZfbGVuID0gY3VyX2xlbiArIDIgKyBuZXdfbGVuOwoJYnVmID0gKGNoYXIgKikgeG1hbGxvYyhidWZfbGVuKTsKCW1lbWNweShidWYsIGN1cl9tc2csIGN1cl9sZW4pOwoJYnVmW2N1cl9sZW5dID0gJ1xuJzsKCWJ1ZltjdXJfbGVuICsgMV0gPSAnXG4nOwoJbWVtY3B5KGJ1ZiArIGN1cl9sZW4gKyAyLCBuZXdfbXNnLCBuZXdfbGVuKTsKCWZyZWUoY3VyX21zZyk7CglmcmVlKG5ld19tc2cpOwoKCS8qIGNyZWF0ZSBhIG5ldyBibG9iIG9iamVjdCBmcm9tIGJ1ZiAqLwoJcmV0ID0gd3JpdGVfc2hhMV9maWxlKGJ1ZiwgYnVmX2xlbiwgYmxvYl90eXBlLCBjdXJfc2hhMSk7CglmcmVlKGJ1Zik7CglyZXR1cm4gcmV0Owp9CgppbnQgY29tYmluZV9ub3Rlc19vdmVyd3JpdGUodW5zaWduZWQgY2hhciAqY3VyX3NoYTEsCgkJY29uc3QgdW5zaWduZWQgY2hhciAqbmV3X3NoYTEpCnsKCWhhc2hjcHkoY3VyX3NoYTEsIG5ld19zaGExKTsKCXJldHVybiAwOwp9CgppbnQgY29tYmluZV9ub3Rlc19pZ25vcmUodW5zaWduZWQgY2hhciAqY3VyX3NoYTEsCgkJY29uc3QgdW5zaWduZWQgY2hhciAqbmV3X3NoYTEpCnsKCXJldHVybiAwOwp9CgovKgogKiBBZGQgdGhlIGxpbmVzIGZyb20gdGhlIG5hbWVkIG9iamVjdCB0byBsaXN0LCB3aXRoIHRyYWlsaW5nCiAqIG5ld2xpbmVzIHJlbW92ZWQuCiAqLwpzdGF0aWMgaW50IHN0cmluZ19saXN0X2FkZF9ub3RlX2xpbmVzKHN0cnVjdCBzdHJpbmdfbGlzdCAqbGlzdCwKCQkJCSAgICAgIGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEpCnsKCWNoYXIgKmRhdGE7Cgl1bnNpZ25lZCBsb25nIGxlbjsKCWVudW0gb2JqZWN0X3R5cGUgdDsKCglpZiAoaXNfbnVsbF9zaGExKHNoYTEpKQoJCXJldHVybiAwOwoKCS8qIHJlYWRfc2hhMV9maWxlIE5VTC10ZXJtaW5hdGVzICovCglkYXRhID0gcmVhZF9zaGExX2ZpbGUoc2hhMSwgJnQsICZsZW4pOwoJaWYgKHQgIT0gT0JKX0JMT0IgfHwgIWRhdGEgfHwgIWxlbikgewoJCWZyZWUoZGF0YSk7CgkJcmV0dXJuIHQgIT0gT0JKX0JMT0IgfHwgIWRhdGE7Cgl9CgoJLyoKCSAqIElmIHRoZSBsYXN0IGxpbmUgb2YgdGhlIGZpbGUgaXMgRU9MLXRlcm1pbmF0ZWQsIHRoaXMgd2lsbAoJICogYWRkIGFuIGVtcHR5IHN0cmluZyB0byB0aGUgbGlzdC4gIEJ1dCBpdCB3aWxsIGJlIHJlbW92ZWQKCSAqIGxhdGVyLCBhbG9uZyB3aXRoIGFueSBlbXB0eSBzdHJpbmdzIHRoYXQgY2FtZSBmcm9tIGVtcHR5CgkgKiBsaW5lcyB3aXRoaW4gdGhlIGZpbGUuCgkgKi8KCXN0cmluZ19saXN0X3NwbGl0KGxpc3QsIGRhdGEsICdcbicsIC0xKTsKCWZyZWUoZGF0YSk7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBzdHJpbmdfbGlzdF9qb2luX2xpbmVzX2hlbHBlcihzdHJ1Y3Qgc3RyaW5nX2xpc3RfaXRlbSAqaXRlbSwKCQkJCQkgdm9pZCAqY2JfZGF0YSkKewoJc3RydWN0IHN0cmJ1ZiAqYnVmID0gY2JfZGF0YTsKCXN0cmJ1Zl9hZGRzdHIoYnVmLCBpdGVtLT5zdHJpbmcpOwoJc3RyYnVmX2FkZGNoKGJ1ZiwgJ1xuJyk7CglyZXR1cm4gMDsKfQoKaW50IGNvbWJpbmVfbm90ZXNfY2F0X3NvcnRfdW5pcSh1bnNpZ25lZCBjaGFyICpjdXJfc2hhMSwKCQljb25zdCB1bnNpZ25lZCBjaGFyICpuZXdfc2hhMSkKewoJc3RydWN0IHN0cmluZ19saXN0IHNvcnRfdW5pcV9saXN0ID0gU1RSSU5HX0xJU1RfSU5JVF9EVVA7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoJaW50IHJldCA9IDE7CgoJLyogcmVhZCBib3RoIG5vdGUgYmxvYiBvYmplY3RzIGludG8gdW5pcXVlX2xpbmVzICovCglpZiAoc3RyaW5nX2xpc3RfYWRkX25vdGVfbGluZXMoJnNvcnRfdW5pcV9saXN0LCBjdXJfc2hhMSkpCgkJZ290byBvdXQ7CglpZiAoc3RyaW5nX2xpc3RfYWRkX25vdGVfbGluZXMoJnNvcnRfdW5pcV9saXN0LCBuZXdfc2hhMSkpCgkJZ290byBvdXQ7CglzdHJpbmdfbGlzdF9yZW1vdmVfZW1wdHlfaXRlbXMoJnNvcnRfdW5pcV9saXN0LCAwKTsKCXN0cmluZ19saXN0X3NvcnQoJnNvcnRfdW5pcV9saXN0KTsKCXN0cmluZ19saXN0X3JlbW92ZV9kdXBsaWNhdGVzKCZzb3J0X3VuaXFfbGlzdCwgMCk7CgoJLyogY3JlYXRlIGEgbmV3IGJsb2Igb2JqZWN0IGZyb20gc29ydF91bmlxX2xpc3QgKi8KCWlmIChmb3JfZWFjaF9zdHJpbmdfbGlzdCgmc29ydF91bmlxX2xpc3QsCgkJCQkgc3RyaW5nX2xpc3Rfam9pbl9saW5lc19oZWxwZXIsICZidWYpKQoJCWdvdG8gb3V0OwoKCXJldCA9IHdyaXRlX3NoYTFfZmlsZShidWYuYnVmLCBidWYubGVuLCBibG9iX3R5cGUsIGN1cl9zaGExKTsKCm91dDoKCXN0cmJ1Zl9yZWxlYXNlKCZidWYpOwoJc3RyaW5nX2xpc3RfY2xlYXIoJnNvcnRfdW5pcV9saXN0LCAwKTsKCXJldHVybiByZXQ7Cn0KCnN0YXRpYyBpbnQgc3RyaW5nX2xpc3RfYWRkX29uZV9yZWYoY29uc3QgY2hhciAqcmVmbmFtZSwgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLAoJCQkJICAgaW50IGZsYWcsIHZvaWQgKmNiKQp7CglzdHJ1Y3Qgc3RyaW5nX2xpc3QgKnJlZnMgPSBjYjsKCWlmICghdW5zb3J0ZWRfc3RyaW5nX2xpc3RfaGFzX3N0cmluZyhyZWZzLCByZWZuYW1lKSkKCQlzdHJpbmdfbGlzdF9hcHBlbmQocmVmcywgcmVmbmFtZSk7CglyZXR1cm4gMDsKfQoKLyoKICogVGhlIGxpc3QgYXJndW1lbnQgbXVzdCBoYXZlIHN0cmR1cF9zdHJpbmdzIHNldCBvbiBpdC4KICovCnZvaWQgc3RyaW5nX2xpc3RfYWRkX3JlZnNfYnlfZ2xvYihzdHJ1Y3Qgc3RyaW5nX2xpc3QgKmxpc3QsIGNvbnN0IGNoYXIgKmdsb2IpCnsKCWFzc2VydChsaXN0LT5zdHJkdXBfc3RyaW5ncyk7CglpZiAoaGFzX2dsb2Jfc3BlY2lhbHMoZ2xvYikpIHsKCQlmb3JfZWFjaF9nbG9iX3JlZihzdHJpbmdfbGlzdF9hZGRfb25lX3JlZiwgZ2xvYiwgbGlzdCk7Cgl9IGVsc2UgewoJCXN0cnVjdCBvYmplY3RfaWQgb2lkOwoJCWlmIChnZXRfb2lkKGdsb2IsICZvaWQpKQoJCQl3YXJuaW5nKCJub3RlcyByZWYgJXMgaXMgaW52YWxpZCIsIGdsb2IpOwoJCWlmICghdW5zb3J0ZWRfc3RyaW5nX2xpc3RfaGFzX3N0cmluZyhsaXN0LCBnbG9iKSkKCQkJc3RyaW5nX2xpc3RfYXBwZW5kKGxpc3QsIGdsb2IpOwoJfQp9Cgp2b2lkIHN0cmluZ19saXN0X2FkZF9yZWZzX2Zyb21fY29sb25fc2VwKHN0cnVjdCBzdHJpbmdfbGlzdCAqbGlzdCwKCQkJCQkgY29uc3QgY2hhciAqZ2xvYnMpCnsKCXN0cnVjdCBzdHJpbmdfbGlzdCBzcGxpdCA9IFNUUklOR19MSVNUX0lOSVRfTk9EVVA7CgljaGFyICpnbG9ic19jb3B5ID0geHN0cmR1cChnbG9icyk7CglpbnQgaTsKCglzdHJpbmdfbGlzdF9zcGxpdF9pbl9wbGFjZSgmc3BsaXQsIGdsb2JzX2NvcHksICc6JywgLTEpOwoJc3RyaW5nX2xpc3RfcmVtb3ZlX2VtcHR5X2l0ZW1zKCZzcGxpdCwgMCk7CgoJZm9yIChpID0gMDsgaSA8IHNwbGl0Lm5yOyBpKyspCgkJc3RyaW5nX2xpc3RfYWRkX3JlZnNfYnlfZ2xvYihsaXN0LCBzcGxpdC5pdGVtc1tpXS5zdHJpbmcpOwoKCXN0cmluZ19saXN0X2NsZWFyKCZzcGxpdCwgMCk7CglmcmVlKGdsb2JzX2NvcHkpOwp9CgpzdGF0aWMgaW50IG5vdGVzX2Rpc3BsYXlfY29uZmlnKGNvbnN0IGNoYXIgKmssIGNvbnN0IGNoYXIgKnYsIHZvaWQgKmNiKQp7CglpbnQgKmxvYWRfcmVmcyA9IGNiOwoKCWlmICgqbG9hZF9yZWZzICYmICFzdHJjbXAoaywgIm5vdGVzLmRpc3BsYXlyZWYiKSkgewoJCWlmICghdikKCQkJY29uZmlnX2Vycm9yX25vbmJvb2woayk7CgkJc3RyaW5nX2xpc3RfYWRkX3JlZnNfYnlfZ2xvYigmZGlzcGxheV9ub3Rlc19yZWZzLCB2KTsKCX0KCglyZXR1cm4gMDsKfQoKY29uc3QgY2hhciAqZGVmYXVsdF9ub3Rlc19yZWYodm9pZCkKewoJY29uc3QgY2hhciAqbm90ZXNfcmVmID0gTlVMTDsKCWlmICghbm90ZXNfcmVmKQoJCW5vdGVzX3JlZiA9IGdldGVudihHSVRfTk9URVNfUkVGX0VOVklST05NRU5UKTsKCWlmICghbm90ZXNfcmVmKQoJCW5vdGVzX3JlZiA9IG5vdGVzX3JlZl9uYW1lOyAvKiB2YWx1ZSBvZiBjb3JlLm5vdGVzUmVmIGNvbmZpZyAqLwoJaWYgKCFub3Rlc19yZWYpCgkJbm90ZXNfcmVmID0gR0lUX05PVEVTX0RFRkFVTFRfUkVGOwoJcmV0dXJuIG5vdGVzX3JlZjsKfQoKdm9pZCBpbml0X25vdGVzKHN0cnVjdCBub3Rlc190cmVlICp0LCBjb25zdCBjaGFyICpub3Rlc19yZWYsCgkJY29tYmluZV9ub3Rlc19mbiBjb21iaW5lX25vdGVzLCBpbnQgZmxhZ3MpCnsKCXN0cnVjdCBvYmplY3RfaWQgb2lkLCBvYmplY3Rfb2lkOwoJdW5zaWduZWQgbW9kZTsKCXN0cnVjdCBsZWFmX25vZGUgcm9vdF90cmVlOwoKCWlmICghdCkKCQl0ID0gJmRlZmF1bHRfbm90ZXNfdHJlZTsKCWFzc2VydCghdC0+aW5pdGlhbGl6ZWQpOwoKCWlmICghbm90ZXNfcmVmKQoJCW5vdGVzX3JlZiA9IGRlZmF1bHRfbm90ZXNfcmVmKCk7CgoJaWYgKCFjb21iaW5lX25vdGVzKQoJCWNvbWJpbmVfbm90ZXMgPSBjb21iaW5lX25vdGVzX2NvbmNhdGVuYXRlOwoKCXQtPnJvb3QgPSAoc3RydWN0IGludF9ub2RlICopIHhjYWxsb2MoMSwgc2l6ZW9mKHN0cnVjdCBpbnRfbm9kZSkpOwoJdC0+Zmlyc3Rfbm9uX25vdGUgPSBOVUxMOwoJdC0+cHJldl9ub25fbm90ZSA9IE5VTEw7Cgl0LT5yZWYgPSB4c3RyZHVwX29yX251bGwobm90ZXNfcmVmKTsKCXQtPnVwZGF0ZV9yZWYgPSAoZmxhZ3MgJiBOT1RFU19JTklUX1dSSVRBQkxFKSA/IHQtPnJlZiA6IE5VTEw7Cgl0LT5jb21iaW5lX25vdGVzID0gY29tYmluZV9ub3RlczsKCXQtPmluaXRpYWxpemVkID0gMTsKCXQtPmRpcnR5ID0gMDsKCglpZiAoZmxhZ3MgJiBOT1RFU19JTklUX0VNUFRZIHx8ICFub3Rlc19yZWYgfHwKCSAgICBnZXRfc2hhMV90cmVlaXNoKG5vdGVzX3JlZiwgb2JqZWN0X29pZC5oYXNoKSkKCQlyZXR1cm47CglpZiAoZmxhZ3MgJiBOT1RFU19JTklUX1dSSVRBQkxFICYmIHJlYWRfcmVmKG5vdGVzX3JlZiwgb2JqZWN0X29pZC5oYXNoKSkKCQlkaWUoIkNhbm5vdCB1c2Ugbm90ZXMgcmVmICVzIiwgbm90ZXNfcmVmKTsKCWlmIChnZXRfdHJlZV9lbnRyeShvYmplY3Rfb2lkLmhhc2gsICIiLCBvaWQuaGFzaCwgJm1vZGUpKQoJCWRpZSgiRmFpbGVkIHRvIHJlYWQgbm90ZXMgdHJlZSByZWZlcmVuY2VkIGJ5ICVzICglcykiLAoJCSAgICBub3Rlc19yZWYsIG9pZF90b19oZXgoJm9iamVjdF9vaWQpKTsKCglvaWRjbHIoJnJvb3RfdHJlZS5rZXlfb2lkKTsKCW9pZGNweSgmcm9vdF90cmVlLnZhbF9vaWQsICZvaWQpOwoJbG9hZF9zdWJ0cmVlKHQsICZyb290X3RyZWUsIHQtPnJvb3QsIDApOwp9CgpzdHJ1Y3Qgbm90ZXNfdHJlZSAqKmxvYWRfbm90ZXNfdHJlZXMoc3RydWN0IHN0cmluZ19saXN0ICpyZWZzLCBpbnQgZmxhZ3MpCnsKCXN0cnVjdCBzdHJpbmdfbGlzdF9pdGVtICppdGVtOwoJaW50IGNvdW50ZXIgPSAwOwoJc3RydWN0IG5vdGVzX3RyZWUgKip0cmVlczsKCUFMTE9DX0FSUkFZKHRyZWVzLCByZWZzLT5uciArIDEpOwoJZm9yX2VhY2hfc3RyaW5nX2xpc3RfaXRlbShpdGVtLCByZWZzKSB7CgkJc3RydWN0IG5vdGVzX3RyZWUgKnQgPSB4Y2FsbG9jKDEsIHNpemVvZihzdHJ1Y3Qgbm90ZXNfdHJlZSkpOwoJCWluaXRfbm90ZXModCwgaXRlbS0+c3RyaW5nLCBjb21iaW5lX25vdGVzX2lnbm9yZSwgZmxhZ3MpOwoJCXRyZWVzW2NvdW50ZXIrK10gPSB0OwoJfQoJdHJlZXNbY291bnRlcl0gPSBOVUxMOwoJcmV0dXJuIHRyZWVzOwp9Cgp2b2lkIGluaXRfZGlzcGxheV9ub3RlcyhzdHJ1Y3QgZGlzcGxheV9ub3Rlc19vcHQgKm9wdCkKewoJY2hhciAqZGlzcGxheV9yZWZfZW52OwoJaW50IGxvYWRfY29uZmlnX3JlZnMgPSAwOwoJZGlzcGxheV9ub3Rlc19yZWZzLnN0cmR1cF9zdHJpbmdzID0gMTsKCglhc3NlcnQoIWRpc3BsYXlfbm90ZXNfdHJlZXMpOwoKCWlmICghb3B0IHx8IG9wdC0+dXNlX2RlZmF1bHRfbm90ZXMgPiAwIHx8CgkgICAgKG9wdC0+dXNlX2RlZmF1bHRfbm90ZXMgPT0gLTEgJiYgIW9wdC0+ZXh0cmFfbm90ZXNfcmVmcy5ucikpIHsKCQlzdHJpbmdfbGlzdF9hcHBlbmQoJmRpc3BsYXlfbm90ZXNfcmVmcywgZGVmYXVsdF9ub3Rlc19yZWYoKSk7CgkJZGlzcGxheV9yZWZfZW52ID0gZ2V0ZW52KEdJVF9OT1RFU19ESVNQTEFZX1JFRl9FTlZJUk9OTUVOVCk7CgkJaWYgKGRpc3BsYXlfcmVmX2VudikgewoJCQlzdHJpbmdfbGlzdF9hZGRfcmVmc19mcm9tX2NvbG9uX3NlcCgmZGlzcGxheV9ub3Rlc19yZWZzLAoJCQkJCQkJICAgIGRpc3BsYXlfcmVmX2Vudik7CgkJCWxvYWRfY29uZmlnX3JlZnMgPSAwOwoJCX0gZWxzZQoJCQlsb2FkX2NvbmZpZ19yZWZzID0gMTsKCX0KCglnaXRfY29uZmlnKG5vdGVzX2Rpc3BsYXlfY29uZmlnLCAmbG9hZF9jb25maWdfcmVmcyk7CgoJaWYgKG9wdCkgewoJCXN0cnVjdCBzdHJpbmdfbGlzdF9pdGVtICppdGVtOwoJCWZvcl9lYWNoX3N0cmluZ19saXN0X2l0ZW0oaXRlbSwgJm9wdC0+ZXh0cmFfbm90ZXNfcmVmcykKCQkJc3RyaW5nX2xpc3RfYWRkX3JlZnNfYnlfZ2xvYigmZGlzcGxheV9ub3Rlc19yZWZzLAoJCQkJCQkgICAgIGl0ZW0tPnN0cmluZyk7Cgl9CgoJZGlzcGxheV9ub3Rlc190cmVlcyA9IGxvYWRfbm90ZXNfdHJlZXMoJmRpc3BsYXlfbm90ZXNfcmVmcywgMCk7CglzdHJpbmdfbGlzdF9jbGVhcigmZGlzcGxheV9ub3Rlc19yZWZzLCAwKTsKfQoKaW50IGFkZF9ub3RlKHN0cnVjdCBub3Rlc190cmVlICp0LCBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvYmplY3Rfb2lkLAoJCWNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm5vdGVfb2lkLCBjb21iaW5lX25vdGVzX2ZuIGNvbWJpbmVfbm90ZXMpCnsKCXN0cnVjdCBsZWFmX25vZGUgKmw7CgoJaWYgKCF0KQoJCXQgPSAmZGVmYXVsdF9ub3Rlc190cmVlOwoJYXNzZXJ0KHQtPmluaXRpYWxpemVkKTsKCXQtPmRpcnR5ID0gMTsKCWlmICghY29tYmluZV9ub3RlcykKCQljb21iaW5lX25vdGVzID0gdC0+Y29tYmluZV9ub3RlczsKCWwgPSAoc3RydWN0IGxlYWZfbm9kZSAqKSB4bWFsbG9jKHNpemVvZihzdHJ1Y3QgbGVhZl9ub2RlKSk7CglvaWRjcHkoJmwtPmtleV9vaWQsIG9iamVjdF9vaWQpOwoJb2lkY3B5KCZsLT52YWxfb2lkLCBub3RlX29pZCk7CglyZXR1cm4gbm90ZV90cmVlX2luc2VydCh0LCB0LT5yb290LCAwLCBsLCBQVFJfVFlQRV9OT1RFLCBjb21iaW5lX25vdGVzKTsKfQoKaW50IHJlbW92ZV9ub3RlKHN0cnVjdCBub3Rlc190cmVlICp0LCBjb25zdCB1bnNpZ25lZCBjaGFyICpvYmplY3Rfc2hhMSkKewoJc3RydWN0IGxlYWZfbm9kZSBsOwoKCWlmICghdCkKCQl0ID0gJmRlZmF1bHRfbm90ZXNfdHJlZTsKCWFzc2VydCh0LT5pbml0aWFsaXplZCk7CgloYXNoY3B5KGwua2V5X29pZC5oYXNoLCBvYmplY3Rfc2hhMSk7CglvaWRjbHIoJmwudmFsX29pZCk7Cglub3RlX3RyZWVfcmVtb3ZlKHQsIHQtPnJvb3QsIDAsICZsKTsKCWlmIChpc19udWxsX29pZCgmbC52YWxfb2lkKSkgLyogbm8gbm90ZSB3YXMgcmVtb3ZlZCAqLwoJCXJldHVybiAxOwoJdC0+ZGlydHkgPSAxOwoJcmV0dXJuIDA7Cn0KCmNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKmdldF9ub3RlKHN0cnVjdCBub3Rlc190cmVlICp0LAoJCWNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCkKewoJc3RydWN0IGxlYWZfbm9kZSAqZm91bmQ7CgoJaWYgKCF0KQoJCXQgPSAmZGVmYXVsdF9ub3Rlc190cmVlOwoJYXNzZXJ0KHQtPmluaXRpYWxpemVkKTsKCWZvdW5kID0gbm90ZV90cmVlX2ZpbmQodCwgdC0+cm9vdCwgMCwgb2lkLT5oYXNoKTsKCXJldHVybiBmb3VuZCA/ICZmb3VuZC0+dmFsX29pZCA6IE5VTEw7Cn0KCmludCBmb3JfZWFjaF9ub3RlKHN0cnVjdCBub3Rlc190cmVlICp0LCBpbnQgZmxhZ3MsIGVhY2hfbm90ZV9mbiBmbiwKCQl2b2lkICpjYl9kYXRhKQp7CglpZiAoIXQpCgkJdCA9ICZkZWZhdWx0X25vdGVzX3RyZWU7Cglhc3NlcnQodC0+aW5pdGlhbGl6ZWQpOwoJcmV0dXJuIGZvcl9lYWNoX25vdGVfaGVscGVyKHQsIHQtPnJvb3QsIDAsIDAsIGZsYWdzLCBmbiwgY2JfZGF0YSk7Cn0KCmludCB3cml0ZV9ub3Rlc190cmVlKHN0cnVjdCBub3Rlc190cmVlICp0LCB1bnNpZ25lZCBjaGFyICpyZXN1bHQpCnsKCXN0cnVjdCB0cmVlX3dyaXRlX3N0YWNrIHJvb3Q7CglzdHJ1Y3Qgd3JpdGVfZWFjaF9ub3RlX2RhdGEgY2JfZGF0YTsKCWludCByZXQ7CgoJaWYgKCF0KQoJCXQgPSAmZGVmYXVsdF9ub3Rlc190cmVlOwoJYXNzZXJ0KHQtPmluaXRpYWxpemVkKTsKCgkvKiBQcmVwYXJlIGZvciB0cmF2ZXJzYWwgb2YgY3VycmVudCBub3RlcyB0cmVlICovCglyb290Lm5leHQgPSBOVUxMOyAvKiBsYXN0IGZvcndhcmQgZW50cnkgaW4gbGlzdCBpcyBncm91bmRlZCAqLwoJc3RyYnVmX2luaXQoJnJvb3QuYnVmLCAyNTYgKiAoMzIgKyBHSVRfU0hBMV9IRVhTWikpOyAvKiBhc3N1bWUgMjU2IGVudHJpZXMgKi8KCXJvb3QucGF0aFswXSA9IHJvb3QucGF0aFsxXSA9ICdcMCc7CgljYl9kYXRhLnJvb3QgPSAmcm9vdDsKCWNiX2RhdGEubmV4dF9ub25fbm90ZSA9IHQtPmZpcnN0X25vbl9ub3RlOwoKCS8qIFdyaXRlIHRyZWUgb2JqZWN0cyByZXByZXNlbnRpbmcgY3VycmVudCBub3RlcyB0cmVlICovCglyZXQgPSBmb3JfZWFjaF9ub3RlKHQsIEZPUl9FQUNIX05PVEVfRE9OVF9VTlBBQ0tfU1VCVFJFRVMgfAoJCQkJRk9SX0VBQ0hfTk9URV9ZSUVMRF9TVUJUUkVFUywKCQkJd3JpdGVfZWFjaF9ub3RlLCAmY2JfZGF0YSkgfHwKCQl3cml0ZV9lYWNoX25vbl9ub3RlX3VudGlsKE5VTEwsICZjYl9kYXRhKSB8fAoJCXRyZWVfd3JpdGVfc3RhY2tfZmluaXNoX3N1YnRyZWUoJnJvb3QpIHx8CgkJd3JpdGVfc2hhMV9maWxlKHJvb3QuYnVmLmJ1Ziwgcm9vdC5idWYubGVuLCB0cmVlX3R5cGUsIHJlc3VsdCk7CglzdHJidWZfcmVsZWFzZSgmcm9vdC5idWYpOwoJcmV0dXJuIHJldDsKfQoKdm9pZCBwcnVuZV9ub3RlcyhzdHJ1Y3Qgbm90ZXNfdHJlZSAqdCwgaW50IGZsYWdzKQp7CglzdHJ1Y3Qgbm90ZV9kZWxldGVfbGlzdCAqbCA9IE5VTEw7CgoJaWYgKCF0KQoJCXQgPSAmZGVmYXVsdF9ub3Rlc190cmVlOwoJYXNzZXJ0KHQtPmluaXRpYWxpemVkKTsKCglmb3JfZWFjaF9ub3RlKHQsIDAsIHBydW5lX25vdGVzX2hlbHBlciwgJmwpOwoKCXdoaWxlIChsKSB7CgkJaWYgKGZsYWdzICYgTk9URVNfUFJVTkVfVkVSQk9TRSkKCQkJcHJpbnRmKCIlc1xuIiwgc2hhMV90b19oZXgobC0+c2hhMSkpOwoJCWlmICghKGZsYWdzICYgTk9URVNfUFJVTkVfRFJZUlVOKSkKCQkJcmVtb3ZlX25vdGUodCwgbC0+c2hhMSk7CgkJbCA9IGwtPm5leHQ7Cgl9Cn0KCnZvaWQgZnJlZV9ub3RlcyhzdHJ1Y3Qgbm90ZXNfdHJlZSAqdCkKewoJaWYgKCF0KQoJCXQgPSAmZGVmYXVsdF9ub3Rlc190cmVlOwoJaWYgKHQtPnJvb3QpCgkJbm90ZV90cmVlX2ZyZWUodC0+cm9vdCk7CglmcmVlKHQtPnJvb3QpOwoJd2hpbGUgKHQtPmZpcnN0X25vbl9ub3RlKSB7CgkJdC0+cHJldl9ub25fbm90ZSA9IHQtPmZpcnN0X25vbl9ub3RlLT5uZXh0OwoJCWZyZWUodC0+Zmlyc3Rfbm9uX25vdGUtPnBhdGgpOwoJCWZyZWUodC0+Zmlyc3Rfbm9uX25vdGUpOwoJCXQtPmZpcnN0X25vbl9ub3RlID0gdC0+cHJldl9ub25fbm90ZTsKCX0KCWZyZWUodC0+cmVmKTsKCW1lbXNldCh0LCAwLCBzaXplb2Yoc3RydWN0IG5vdGVzX3RyZWUpKTsKfQoKLyoKICogRmlsbCB0aGUgZ2l2ZW4gc3RyYnVmIHdpdGggdGhlIG5vdGVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gb2JqZWN0LgogKgogKiBJZiB0aGUgZ2l2ZW4gbm90ZXNfdHJlZSBzdHJ1Y3R1cmUgaXMgbm90IGluaXRpYWxpemVkLCBpdCB3aWxsIGJlIGF1dG8tCiAqIGluaXRpYWxpemVkIHRvIHRoZSBkZWZhdWx0IHZhbHVlIChzZWUgZG9jdW1lbnRhdGlvbiBmb3IgaW5pdF9ub3RlcygpIGFib3ZlKS4KICogSWYgdGhlIGdpdmVuIG5vdGVzX3RyZWUgaXMgTlVMTCwgdGhlIGludGVybmFsL2RlZmF1bHQgbm90ZXNfdHJlZSB3aWxsIGJlCiAqIHVzZWQgaW5zdGVhZC4KICoKICogKHJhdyAhPSAwKSBnaXZlcyB0aGUgJU4gdXNlcmZvcm1hdDsgb3RoZXJ3aXNlLCB0aGUgbm90ZSBtZXNzYWdlIGlzIGdpdmVuCiAqIGZvciBodW1hbiBjb25zdW1wdGlvbi4KICovCnN0YXRpYyB2b2lkIGZvcm1hdF9ub3RlKHN0cnVjdCBub3Rlc190cmVlICp0LCBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvYmplY3Rfb2lkLAoJCQlzdHJ1Y3Qgc3RyYnVmICpzYiwgY29uc3QgY2hhciAqb3V0cHV0X2VuY29kaW5nLCBpbnQgcmF3KQp7CglzdGF0aWMgY29uc3QgY2hhciB1dGY4W10gPSAidXRmLTgiOwoJY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkOwoJY2hhciAqbXNnLCAqbXNnX3A7Cgl1bnNpZ25lZCBsb25nIGxpbmVsZW4sIG1zZ2xlbjsKCWVudW0gb2JqZWN0X3R5cGUgdHlwZTsKCglpZiAoIXQpCgkJdCA9ICZkZWZhdWx0X25vdGVzX3RyZWU7CglpZiAoIXQtPmluaXRpYWxpemVkKQoJCWluaXRfbm90ZXModCwgTlVMTCwgTlVMTCwgMCk7CgoJb2lkID0gZ2V0X25vdGUodCwgb2JqZWN0X29pZCk7CglpZiAoIW9pZCkKCQlyZXR1cm47CgoJaWYgKCEobXNnID0gcmVhZF9zaGExX2ZpbGUob2lkLT5oYXNoLCAmdHlwZSwgJm1zZ2xlbikpIHx8IHR5cGUgIT0gT0JKX0JMT0IpIHsKCQlmcmVlKG1zZyk7CgkJcmV0dXJuOwoJfQoKCWlmIChvdXRwdXRfZW5jb2RpbmcgJiYgKm91dHB1dF9lbmNvZGluZyAmJgoJICAgICFpc19lbmNvZGluZ191dGY4KG91dHB1dF9lbmNvZGluZykpIHsKCQljaGFyICpyZWVuY29kZWQgPSByZWVuY29kZV9zdHJpbmcobXNnLCBvdXRwdXRfZW5jb2RpbmcsIHV0ZjgpOwoJCWlmIChyZWVuY29kZWQpIHsKCQkJZnJlZShtc2cpOwoJCQltc2cgPSByZWVuY29kZWQ7CgkJCW1zZ2xlbiA9IHN0cmxlbihtc2cpOwoJCX0KCX0KCgkvKiB3ZSB3aWxsIGVuZCB0aGUgYW5ub3RhdGlvbiBieSBhIG5ld2xpbmUgYW55d2F5ICovCglpZiAobXNnbGVuICYmIG1zZ1ttc2dsZW4gLSAxXSA9PSAnXG4nKQoJCW1zZ2xlbi0tOwoKCWlmICghcmF3KSB7CgkJY29uc3QgY2hhciAqcmVmID0gdC0+cmVmOwoJCWlmICghcmVmIHx8ICFzdHJjbXAocmVmLCBHSVRfTk9URVNfREVGQVVMVF9SRUYpKSB7CgkJCXN0cmJ1Zl9hZGRzdHIoc2IsICJcbk5vdGVzOlxuIik7CgkJfSBlbHNlIHsKCQkJaWYgKHN0YXJ0c193aXRoKHJlZiwgInJlZnMvIikpCgkJCQlyZWYgKz0gNTsKCQkJaWYgKHN0YXJ0c193aXRoKHJlZiwgIm5vdGVzLyIpKQoJCQkJcmVmICs9IDY7CgkJCXN0cmJ1Zl9hZGRmKHNiLCAiXG5Ob3RlcyAoJXMpOlxuIiwgcmVmKTsKCQl9Cgl9CgoJZm9yIChtc2dfcCA9IG1zZzsgbXNnX3AgPCBtc2cgKyBtc2dsZW47IG1zZ19wICs9IGxpbmVsZW4gKyAxKSB7CgkJbGluZWxlbiA9IHN0cmNocm51bChtc2dfcCwgJ1xuJykgLSBtc2dfcDsKCgkJaWYgKCFyYXcpCgkJCXN0cmJ1Zl9hZGRzdHIoc2IsICIgICAgIik7CgkJc3RyYnVmX2FkZChzYiwgbXNnX3AsIGxpbmVsZW4pOwoJCXN0cmJ1Zl9hZGRjaChzYiwgJ1xuJyk7Cgl9CgoJZnJlZShtc2cpOwp9Cgp2b2lkIGZvcm1hdF9kaXNwbGF5X25vdGVzKGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9iamVjdF9vaWQsCgkJCSAgc3RydWN0IHN0cmJ1ZiAqc2IsIGNvbnN0IGNoYXIgKm91dHB1dF9lbmNvZGluZywgaW50IHJhdykKewoJaW50IGk7Cglhc3NlcnQoZGlzcGxheV9ub3Rlc190cmVlcyk7Cglmb3IgKGkgPSAwOyBkaXNwbGF5X25vdGVzX3RyZWVzW2ldOyBpKyspCgkJZm9ybWF0X25vdGUoZGlzcGxheV9ub3Rlc190cmVlc1tpXSwgb2JqZWN0X29pZCwgc2IsCgkJCSAgICBvdXRwdXRfZW5jb2RpbmcsIHJhdyk7Cn0KCmludCBjb3B5X25vdGUoc3RydWN0IG5vdGVzX3RyZWUgKnQsCgkgICAgICBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpmcm9tX29iaiwgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqdG9fb2JqLAoJICAgICAgaW50IGZvcmNlLCBjb21iaW5lX25vdGVzX2ZuIGNvbWJpbmVfbm90ZXMpCnsKCWNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm5vdGUgPSBnZXRfbm90ZSh0LCBmcm9tX29iaik7Cgljb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpleGlzdGluZ19ub3RlID0gZ2V0X25vdGUodCwgdG9fb2JqKTsKCglpZiAoIWZvcmNlICYmIGV4aXN0aW5nX25vdGUpCgkJcmV0dXJuIDE7CgoJaWYgKG5vdGUpCgkJcmV0dXJuIGFkZF9ub3RlKHQsIHRvX29iaiwgbm90ZSwgY29tYmluZV9ub3Rlcyk7CgllbHNlIGlmIChleGlzdGluZ19ub3RlKQoJCXJldHVybiBhZGRfbm90ZSh0LCB0b19vYmosICZudWxsX29pZCwgY29tYmluZV9ub3Rlcyk7CgoJcmV0dXJuIDA7Cn0KCnZvaWQgZXhwYW5kX25vdGVzX3JlZihzdHJ1Y3Qgc3RyYnVmICpzYikKewoJaWYgKHN0YXJ0c193aXRoKHNiLT5idWYsICJyZWZzL25vdGVzLyIpKQoJCXJldHVybjsgLyogd2UncmUgaGFwcHkgKi8KCWVsc2UgaWYgKHN0YXJ0c193aXRoKHNiLT5idWYsICJub3Rlcy8iKSkKCQlzdHJidWZfaW5zZXJ0KHNiLCAwLCAicmVmcy8iLCA1KTsKCWVsc2UKCQlzdHJidWZfaW5zZXJ0KHNiLCAwLCAicmVmcy9ub3Rlcy8iLCAxMSk7Cn0KCnZvaWQgZXhwYW5kX2xvb3NlX25vdGVzX3JlZihzdHJ1Y3Qgc3RyYnVmICpzYikKewoJc3RydWN0IG9iamVjdF9pZCBvYmplY3Q7CgoJaWYgKGdldF9vaWQoc2ItPmJ1ZiwgJm9iamVjdCkpIHsKCQkvKiBmYWxsYmFjayB0byBleHBhbmRfbm90ZXNfcmVmICovCgkJZXhwYW5kX25vdGVzX3JlZihzYik7Cgl9Cn0K",
    "text": "#include \"cache.h\"\n#include \"config.h\"\n#include \"notes.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"utf8.h\"\n#include \"strbuf.h\"\n#include \"tree-walk.h\"\n#include \"string-list.h\"\n#include \"refs.h\"\n\n/*\n * Use a non-balancing simple 16-tree structure with struct int_node as\n * internal nodes, and struct leaf_node as leaf nodes. Each int_node has a\n * 16-array of pointers to its children.\n * The bottom 2 bits of each pointer is used to identify the pointer type\n * - ptr & 3 == 0 - NULL pointer, assert(ptr == NULL)\n * - ptr & 3 == 1 - pointer to next internal node - cast to struct int_node *\n * - ptr & 3 == 2 - pointer to note entry - cast to struct leaf_node *\n * - ptr & 3 == 3 - pointer to subtree entry - cast to struct leaf_node *\n *\n * The root node is a statically allocated struct int_node.\n */\nstruct int_node {\n\tvoid *a[16];\n};\n\n/*\n * Leaf nodes come in two variants, note entries and subtree entries,\n * distinguished by the LSb of the leaf node pointer (see above).\n * As a note entry, the key is the SHA1 of the referenced object, and the\n * value is the SHA1 of the note object.\n * As a subtree entry, the key is the prefix SHA1 (w/trailing NULs) of the\n * referenced object, using the last byte of the key to store the length of\n * the prefix. The value is the SHA1 of the tree object containing the notes\n * subtree.\n */\nstruct leaf_node {\n\tstruct object_id key_oid;\n\tstruct object_id val_oid;\n};\n\n/*\n * A notes tree may contain entries that are not notes, and that do not follow\n * the naming conventions of notes. There are typically none/few of these, but\n * we still need to keep track of them. Keep a simple linked list sorted alpha-\n * betically on the non-note path. The list is populated when parsing tree\n * objects in load_subtree(), and the non-notes are correctly written back into\n * the tree objects produced by write_notes_tree().\n */\nstruct non_note {\n\tstruct non_note *next; /* grounded (last->next == NULL) */\n\tchar *path;\n\tunsigned int mode;\n\tstruct object_id oid;\n};\n\n#define PTR_TYPE_NULL     0\n#define PTR_TYPE_INTERNAL 1\n#define PTR_TYPE_NOTE     2\n#define PTR_TYPE_SUBTREE  3\n\n#define GET_PTR_TYPE(ptr)       ((uintptr_t) (ptr) & 3)\n#define CLR_PTR_TYPE(ptr)       ((void *) ((uintptr_t) (ptr) & ~3))\n#define SET_PTR_TYPE(ptr, type) ((void *) ((uintptr_t) (ptr) | (type)))\n\n#define GET_NIBBLE(n, sha1) ((((sha1)[(n) >> 1]) >> ((~(n) & 0x01) << 2)) & 0x0f)\n\n#define KEY_INDEX (GIT_SHA1_RAWSZ - 1)\n#define FANOUT_PATH_SEPARATORS ((GIT_SHA1_HEXSZ / 2) - 1)\n#define SUBTREE_SHA1_PREFIXCMP(key_sha1, subtree_sha1) \\\n\t(memcmp(key_sha1, subtree_sha1, subtree_sha1[KEY_INDEX]))\n\nstruct notes_tree default_notes_tree;\n\nstatic struct string_list display_notes_refs = STRING_LIST_INIT_NODUP;\nstatic struct notes_tree **display_notes_trees;\n\nstatic void load_subtree(struct notes_tree *t, struct leaf_node *subtree,\n\t\tstruct int_node *node, unsigned int n);\n\n/*\n * Search the tree until the appropriate location for the given key is found:\n * 1. Start at the root node, with n = 0\n * 2. If a[0] at the current level is a matching subtree entry, unpack that\n *    subtree entry and remove it; restart search at the current level.\n * 3. Use the nth nibble of the key as an index into a:\n *    - If a[n] is an int_node, recurse from #2 into that node and increment n\n *    - If a matching subtree entry, unpack that subtree entry (and remove it);\n *      restart search at the current level.\n *    - Otherwise, we have found one of the following:\n *      - a subtree entry which does not match the key\n *      - a note entry which may or may not match the key\n *      - an unused leaf node (NULL)\n *      In any case, set *tree and *n, and return pointer to the tree location.\n */\nstatic void **note_tree_search(struct notes_tree *t, struct int_node **tree,\n\t\tunsigned char *n, const unsigned char *key_sha1)\n{\n\tstruct leaf_node *l;\n\tunsigned char i;\n\tvoid *p = (*tree)->a[0];\n\n\tif (GET_PTR_TYPE(p) == PTR_TYPE_SUBTREE) {\n\t\tl = (struct leaf_node *) CLR_PTR_TYPE(p);\n\t\tif (!SUBTREE_SHA1_PREFIXCMP(key_sha1, l->key_oid.hash)) {\n\t\t\t/* unpack tree and resume search */\n\t\t\t(*tree)->a[0] = NULL;\n\t\t\tload_subtree(t, l, *tree, *n);\n\t\t\tfree(l);\n\t\t\treturn note_tree_search(t, tree, n, key_sha1);\n\t\t}\n\t}\n\n\ti = GET_NIBBLE(*n, key_sha1);\n\tp = (*tree)->a[i];\n\tswitch (GET_PTR_TYPE(p)) {\n\tcase PTR_TYPE_INTERNAL:\n\t\t*tree = CLR_PTR_TYPE(p);\n\t\t(*n)++;\n\t\treturn note_tree_search(t, tree, n, key_sha1);\n\tcase PTR_TYPE_SUBTREE:\n\t\tl = (struct leaf_node *) CLR_PTR_TYPE(p);\n\t\tif (!SUBTREE_SHA1_PREFIXCMP(key_sha1, l->key_oid.hash)) {\n\t\t\t/* unpack tree and resume search */\n\t\t\t(*tree)->a[i] = NULL;\n\t\t\tload_subtree(t, l, *tree, *n);\n\t\t\tfree(l);\n\t\t\treturn note_tree_search(t, tree, n, key_sha1);\n\t\t}\n\t\t/* fall through */\n\tdefault:\n\t\treturn &((*tree)->a[i]);\n\t}\n}\n\n/*\n * To find a leaf_node:\n * Search to the tree location appropriate for the given key:\n * If a note entry with matching key, return the note entry, else return NULL.\n */\nstatic struct leaf_node *note_tree_find(struct notes_tree *t,\n\t\tstruct int_node *tree, unsigned char n,\n\t\tconst unsigned char *key_sha1)\n{\n\tvoid **p = note_tree_search(t, &tree, &n, key_sha1);\n\tif (GET_PTR_TYPE(*p) == PTR_TYPE_NOTE) {\n\t\tstruct leaf_node *l = (struct leaf_node *) CLR_PTR_TYPE(*p);\n\t\tif (!hashcmp(key_sha1, l->key_oid.hash))\n\t\t\treturn l;\n\t}\n\treturn NULL;\n}\n\n/*\n * How to consolidate an int_node:\n * If there are > 1 non-NULL entries, give up and return non-zero.\n * Otherwise replace the int_node at the given index in the given parent node\n * with the only NOTE entry (or a NULL entry if no entries) from the given\n * tree, and return 0.\n */\nstatic int note_tree_consolidate(struct int_node *tree,\n\tstruct int_node *parent, unsigned char index)\n{\n\tunsigned int i;\n\tvoid *p = NULL;\n\n\tassert(tree && parent);\n\tassert(CLR_PTR_TYPE(parent->a[index]) == tree);\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (GET_PTR_TYPE(tree->a[i]) != PTR_TYPE_NULL) {\n\t\t\tif (p) /* more than one entry */\n\t\t\t\treturn -2;\n\t\t\tp = tree->a[i];\n\t\t}\n\t}\n\n\tif (p && (GET_PTR_TYPE(p) != PTR_TYPE_NOTE))\n\t\treturn -2;\n\t/* replace tree with p in parent[index] */\n\tparent->a[index] = p;\n\tfree(tree);\n\treturn 0;\n}\n\n/*\n * To remove a leaf_node:\n * Search to the tree location appropriate for the given leaf_node's key:\n * - If location does not hold a matching entry, abort and do nothing.\n * - Copy the matching entry's value into the given entry.\n * - Replace the matching leaf_node with a NULL entry (and free the leaf_node).\n * - Consolidate int_nodes repeatedly, while walking up the tree towards root.\n */\nstatic void note_tree_remove(struct notes_tree *t,\n\t\tstruct int_node *tree, unsigned char n,\n\t\tstruct leaf_node *entry)\n{\n\tstruct leaf_node *l;\n\tstruct int_node *parent_stack[GIT_SHA1_RAWSZ];\n\tunsigned char i, j;\n\tvoid **p = note_tree_search(t, &tree, &n, entry->key_oid.hash);\n\n\tassert(GET_PTR_TYPE(entry) == 0); /* no type bits set */\n\tif (GET_PTR_TYPE(*p) != PTR_TYPE_NOTE)\n\t\treturn; /* type mismatch, nothing to remove */\n\tl = (struct leaf_node *) CLR_PTR_TYPE(*p);\n\tif (oidcmp(&l->key_oid, &entry->key_oid))\n\t\treturn; /* key mismatch, nothing to remove */\n\n\t/* we have found a matching entry */\n\toidcpy(&entry->val_oid, &l->val_oid);\n\tfree(l);\n\t*p = SET_PTR_TYPE(NULL, PTR_TYPE_NULL);\n\n\t/* consolidate this tree level, and parent levels, if possible */\n\tif (!n)\n\t\treturn; /* cannot consolidate top level */\n\t/* first, build stack of ancestors between root and current node */\n\tparent_stack[0] = t->root;\n\tfor (i = 0; i < n; i++) {\n\t\tj = GET_NIBBLE(i, entry->key_oid.hash);\n\t\tparent_stack[i + 1] = CLR_PTR_TYPE(parent_stack[i]->a[j]);\n\t}\n\tassert(i == n && parent_stack[i] == tree);\n\t/* next, unwind stack until note_tree_consolidate() is done */\n\twhile (i > 0 &&\n\t       !note_tree_consolidate(parent_stack[i], parent_stack[i - 1],\n\t\t\t\t      GET_NIBBLE(i - 1, entry->key_oid.hash)))\n\t\ti--;\n}\n\n/*\n * To insert a leaf_node:\n * Search to the tree location appropriate for the given leaf_node's key:\n * - If location is unused (NULL), store the tweaked pointer directly there\n * - If location holds a note entry that matches the note-to-be-inserted, then\n *   combine the two notes (by calling the given combine_notes function).\n * - If location holds a note entry that matches the subtree-to-be-inserted,\n *   then unpack the subtree-to-be-inserted into the location.\n * - If location holds a matching subtree entry, unpack the subtree at that\n *   location, and restart the insert operation from that level.\n * - Else, create a new int_node, holding both the node-at-location and the\n *   node-to-be-inserted, and store the new int_node into the location.\n */\nstatic int note_tree_insert(struct notes_tree *t, struct int_node *tree,\n\t\tunsigned char n, struct leaf_node *entry, unsigned char type,\n\t\tcombine_notes_fn combine_notes)\n{\n\tstruct int_node *new_node;\n\tstruct leaf_node *l;\n\tvoid **p = note_tree_search(t, &tree, &n, entry->key_oid.hash);\n\tint ret = 0;\n\n\tassert(GET_PTR_TYPE(entry) == 0); /* no type bits set */\n\tl = (struct leaf_node *) CLR_PTR_TYPE(*p);\n\tswitch (GET_PTR_TYPE(*p)) {\n\tcase PTR_TYPE_NULL:\n\t\tassert(!*p);\n\t\tif (is_null_oid(&entry->val_oid))\n\t\t\tfree(entry);\n\t\telse\n\t\t\t*p = SET_PTR_TYPE(entry, type);\n\t\treturn 0;\n\tcase PTR_TYPE_NOTE:\n\t\tswitch (type) {\n\t\tcase PTR_TYPE_NOTE:\n\t\t\tif (!oidcmp(&l->key_oid, &entry->key_oid)) {\n\t\t\t\t/* skip concatenation if l == entry */\n\t\t\t\tif (!oidcmp(&l->val_oid, &entry->val_oid))\n\t\t\t\t\treturn 0;\n\n\t\t\t\tret = combine_notes(l->val_oid.hash,\n\t\t\t\t\t\t    entry->val_oid.hash);\n\t\t\t\tif (!ret && is_null_oid(&l->val_oid))\n\t\t\t\t\tnote_tree_remove(t, tree, n, entry);\n\t\t\t\tfree(entry);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PTR_TYPE_SUBTREE:\n\t\t\tif (!SUBTREE_SHA1_PREFIXCMP(l->key_oid.hash,\n\t\t\t\t\t\t    entry->key_oid.hash)) {\n\t\t\t\t/* unpack 'entry' */\n\t\t\t\tload_subtree(t, entry, tree, n);\n\t\t\t\tfree(entry);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase PTR_TYPE_SUBTREE:\n\t\tif (!SUBTREE_SHA1_PREFIXCMP(entry->key_oid.hash, l->key_oid.hash)) {\n\t\t\t/* unpack 'l' and restart insert */\n\t\t\t*p = NULL;\n\t\t\tload_subtree(t, l, tree, n);\n\t\t\tfree(l);\n\t\t\treturn note_tree_insert(t, tree, n, entry, type,\n\t\t\t\t\t\tcombine_notes);\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* non-matching leaf_node */\n\tassert(GET_PTR_TYPE(*p) == PTR_TYPE_NOTE ||\n\t       GET_PTR_TYPE(*p) == PTR_TYPE_SUBTREE);\n\tif (is_null_oid(&entry->val_oid)) { /* skip insertion of empty note */\n\t\tfree(entry);\n\t\treturn 0;\n\t}\n\tnew_node = (struct int_node *) xcalloc(1, sizeof(struct int_node));\n\tret = note_tree_insert(t, new_node, n + 1, l, GET_PTR_TYPE(*p),\n\t\t\t       combine_notes);\n\tif (ret)\n\t\treturn ret;\n\t*p = SET_PTR_TYPE(new_node, PTR_TYPE_INTERNAL);\n\treturn note_tree_insert(t, new_node, n + 1, entry, type, combine_notes);\n}\n\n/* Free the entire notes data contained in the given tree */\nstatic void note_tree_free(struct int_node *tree)\n{\n\tunsigned int i;\n\tfor (i = 0; i < 16; i++) {\n\t\tvoid *p = tree->a[i];\n\t\tswitch (GET_PTR_TYPE(p)) {\n\t\tcase PTR_TYPE_INTERNAL:\n\t\t\tnote_tree_free(CLR_PTR_TYPE(p));\n\t\t\t/* fall through */\n\t\tcase PTR_TYPE_NOTE:\n\t\tcase PTR_TYPE_SUBTREE:\n\t\t\tfree(CLR_PTR_TYPE(p));\n\t\t}\n\t}\n}\n\n/*\n * Convert a partial SHA1 hex string to the corresponding partial SHA1 value.\n * - hex      - Partial SHA1 segment in ASCII hex format\n * - hex_len  - Length of above segment. Must be multiple of 2 between 0 and 40\n * - oid      - Partial SHA1 value is written here\n * - oid_len  - Max #bytes to store in sha1, Must be >= hex_len / 2, and < 20\n * Return 0 on success or -1 on error (invalid arguments or input not\n * in hex format). Pad oid with NULs up to oid_len.\n */\nstatic int get_oid_hex_segment(const char *hex, unsigned int hex_len,\n\t\tunsigned char *oid, unsigned int oid_len)\n{\n\tunsigned int i, len = hex_len >> 1;\n\tif (hex_len % 2 != 0 || len > oid_len)\n\t\treturn -1;\n\tfor (i = 0; i < len; i++) {\n\t\tunsigned int val = (hexval(hex[0]) << 4) | hexval(hex[1]);\n\t\tif (val & ~0xff)\n\t\t\treturn -1;\n\t\t*oid++ = val;\n\t\thex += 2;\n\t}\n\tfor (; i < oid_len; i++)\n\t\t*oid++ = 0;\n\treturn 0;\n}\n\nstatic int non_note_cmp(const struct non_note *a, const struct non_note *b)\n{\n\treturn strcmp(a->path, b->path);\n}\n\n/* note: takes ownership of path string */\nstatic void add_non_note(struct notes_tree *t, char *path,\n\t\tunsigned int mode, const unsigned char *sha1)\n{\n\tstruct non_note *p = t->prev_non_note, *n;\n\tn = (struct non_note *) xmalloc(sizeof(struct non_note));\n\tn->next = NULL;\n\tn->path = path;\n\tn->mode = mode;\n\thashcpy(n->oid.hash, sha1);\n\tt->prev_non_note = n;\n\n\tif (!t->first_non_note) {\n\t\tt->first_non_note = n;\n\t\treturn;\n\t}\n\n\tif (non_note_cmp(p, n) < 0)\n\t\t; /* do nothing  */\n\telse if (non_note_cmp(t->first_non_note, n) <= 0)\n\t\tp = t->first_non_note;\n\telse {\n\t\t/* n sorts before t->first_non_note */\n\t\tn->next = t->first_non_note;\n\t\tt->first_non_note = n;\n\t\treturn;\n\t}\n\n\t/* n sorts equal or after p */\n\twhile (p->next && non_note_cmp(p->next, n) <= 0)\n\t\tp = p->next;\n\n\tif (non_note_cmp(p, n) == 0) { /* n ~= p; overwrite p with n */\n\t\tassert(strcmp(p->path, n->path) == 0);\n\t\tp->mode = n->mode;\n\t\toidcpy(&p->oid, &n->oid);\n\t\tfree(n);\n\t\tt->prev_non_note = p;\n\t\treturn;\n\t}\n\n\t/* n sorts between p and p->next */\n\tn->next = p->next;\n\tp->next = n;\n}\n\nstatic void load_subtree(struct notes_tree *t, struct leaf_node *subtree,\n\t\tstruct int_node *node, unsigned int n)\n{\n\tstruct object_id object_oid;\n\tunsigned int prefix_len;\n\tvoid *buf;\n\tstruct tree_desc desc;\n\tstruct name_entry entry;\n\n\tbuf = fill_tree_descriptor(&desc, subtree->val_oid.hash);\n\tif (!buf)\n\t\tdie(\"Could not read %s for notes-index\",\n\t\t     oid_to_hex(&subtree->val_oid));\n\n\tprefix_len = subtree->key_oid.hash[KEY_INDEX];\n\tassert(prefix_len * 2 >= n);\n\tmemcpy(object_oid.hash, subtree->key_oid.hash, prefix_len);\n\twhile (tree_entry(&desc, &entry)) {\n\t\tunsigned char type;\n\t\tstruct leaf_node *l;\n\t\tint path_len = strlen(entry.path);\n\n\t\tif (path_len == 2 * (GIT_SHA1_RAWSZ - prefix_len)) {\n\t\t\t/* This is potentially the remainder of the SHA-1 */\n\n\t\t\tif (!S_ISREG(entry.mode))\n\t\t\t\t/* notes must be blobs */\n\t\t\t\tgoto handle_non_note;\n\n\t\t\tif (get_oid_hex_segment(entry.path, path_len,\n\t\t\t\t\t\tobject_oid.hash + prefix_len,\n\t\t\t\t\t\tGIT_SHA1_RAWSZ - prefix_len))\n\t\t\t\tgoto handle_non_note; /* entry.path is not a SHA1 */\n\n\t\t\ttype = PTR_TYPE_NOTE;\n\t\t} else if (path_len == 2) {\n\t\t\t/* This is potentially an internal node */\n\n\t\t\tif (!S_ISDIR(entry.mode))\n\t\t\t\t/* internal nodes must be trees */\n\t\t\t\tgoto handle_non_note;\n\n\t\t\tif (get_oid_hex_segment(entry.path, 2,\n\t\t\t\t\t\tobject_oid.hash + prefix_len,\n\t\t\t\t\t\tGIT_SHA1_RAWSZ - prefix_len))\n\t\t\t\tgoto handle_non_note; /* entry.path is not a SHA1 */\n\n\t\t\tobject_oid.hash[KEY_INDEX] = (unsigned char) (prefix_len + 1);\n\n\t\t\ttype = PTR_TYPE_SUBTREE;\n\t\t} else {\n\t\t\t/* This can't be part of a note */\n\t\t\tgoto handle_non_note;\n\t\t}\n\n\t\tl = xcalloc(1, sizeof(*l));\n\t\toidcpy(&l->key_oid, &object_oid);\n\t\toidcpy(&l->val_oid, entry.oid);\n\t\tif (note_tree_insert(t, node, n, l, type,\n\t\t\t\t     combine_notes_concatenate))\n\t\t\tdie(\"Failed to load %s %s into notes tree \"\n\t\t\t    \"from %s\",\n\t\t\t    type == PTR_TYPE_NOTE ? \"note\" : \"subtree\",\n\t\t\t    oid_to_hex(&l->key_oid), t->ref);\n\n\t\tcontinue;\n\nhandle_non_note:\n\t\t/*\n\t\t * Determine full path for this non-note entry. The\n\t\t * filename is already found in entry.path, but the\n\t\t * directory part of the path must be deduced from the\n\t\t * subtree containing this entry based on our\n\t\t * knowledge that the overall notes tree follows a\n\t\t * strict byte-based progressive fanout structure\n\t\t * (i.e. using 2/38, 2/2/36, etc. fanouts).\n\t\t */\n\t\t{\n\t\t\tstruct strbuf non_note_path = STRBUF_INIT;\n\t\t\tconst char *q = oid_to_hex(&subtree->key_oid);\n\t\t\tint i;\n\t\t\tfor (i = 0; i < prefix_len; i++) {\n\t\t\t\tstrbuf_addch(&non_note_path, *q++);\n\t\t\t\tstrbuf_addch(&non_note_path, *q++);\n\t\t\t\tstrbuf_addch(&non_note_path, '/');\n\t\t\t}\n\t\t\tstrbuf_addstr(&non_note_path, entry.path);\n\t\t\tadd_non_note(t, strbuf_detach(&non_note_path, NULL),\n\t\t\t\t     entry.mode, entry.oid->hash);\n\t\t}\n\t}\n\tfree(buf);\n}\n\n/*\n * Determine optimal on-disk fanout for this part of the notes tree\n *\n * Given a (sub)tree and the level in the internal tree structure, determine\n * whether or not the given existing fanout should be expanded for this\n * (sub)tree.\n *\n * Values of the 'fanout' variable:\n * - 0: No fanout (all notes are stored directly in the root notes tree)\n * - 1: 2/38 fanout\n * - 2: 2/2/36 fanout\n * - 3: 2/2/2/34 fanout\n * etc.\n */\nstatic unsigned char determine_fanout(struct int_node *tree, unsigned char n,\n\t\tunsigned char fanout)\n{\n\t/*\n\t * The following is a simple heuristic that works well in practice:\n\t * For each even-numbered 16-tree level (remember that each on-disk\n\t * fanout level corresponds to _two_ 16-tree levels), peek at all 16\n\t * entries at that tree level. If all of them are either int_nodes or\n\t * subtree entries, then there are likely plenty of notes below this\n\t * level, so we return an incremented fanout.\n\t */\n\tunsigned int i;\n\tif ((n % 2) || (n > 2 * fanout))\n\t\treturn fanout;\n\tfor (i = 0; i < 16; i++) {\n\t\tswitch (GET_PTR_TYPE(tree->a[i])) {\n\t\tcase PTR_TYPE_SUBTREE:\n\t\tcase PTR_TYPE_INTERNAL:\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\treturn fanout;\n\t\t}\n\t}\n\treturn fanout + 1;\n}\n\n/* hex SHA1 + 19 * '/' + NUL */\n#define FANOUT_PATH_MAX GIT_SHA1_HEXSZ + FANOUT_PATH_SEPARATORS + 1\n\nstatic void construct_path_with_fanout(const unsigned char *sha1,\n\t\tunsigned char fanout, char *path)\n{\n\tunsigned int i = 0, j = 0;\n\tconst char *hex_sha1 = sha1_to_hex(sha1);\n\tassert(fanout < GIT_SHA1_RAWSZ);\n\twhile (fanout) {\n\t\tpath[i++] = hex_sha1[j++];\n\t\tpath[i++] = hex_sha1[j++];\n\t\tpath[i++] = '/';\n\t\tfanout--;\n\t}\n\txsnprintf(path + i, FANOUT_PATH_MAX - i, \"%s\", hex_sha1 + j);\n}\n\nstatic int for_each_note_helper(struct notes_tree *t, struct int_node *tree,\n\t\tunsigned char n, unsigned char fanout, int flags,\n\t\teach_note_fn fn, void *cb_data)\n{\n\tunsigned int i;\n\tvoid *p;\n\tint ret = 0;\n\tstruct leaf_node *l;\n\tstatic char path[FANOUT_PATH_MAX];\n\n\tfanout = determine_fanout(tree, n, fanout);\n\tfor (i = 0; i < 16; i++) {\nredo:\n\t\tp = tree->a[i];\n\t\tswitch (GET_PTR_TYPE(p)) {\n\t\tcase PTR_TYPE_INTERNAL:\n\t\t\t/* recurse into int_node */\n\t\t\tret = for_each_note_helper(t, CLR_PTR_TYPE(p), n + 1,\n\t\t\t\tfanout, flags, fn, cb_data);\n\t\t\tbreak;\n\t\tcase PTR_TYPE_SUBTREE:\n\t\t\tl = (struct leaf_node *) CLR_PTR_TYPE(p);\n\t\t\t/*\n\t\t\t * Subtree entries in the note tree represent parts of\n\t\t\t * the note tree that have not yet been explored. There\n\t\t\t * is a direct relationship between subtree entries at\n\t\t\t * level 'n' in the tree, and the 'fanout' variable:\n\t\t\t * Subtree entries at level 'n <= 2 * fanout' should be\n\t\t\t * preserved, since they correspond exactly to a fanout\n\t\t\t * directory in the on-disk structure. However, subtree\n\t\t\t * entries at level 'n > 2 * fanout' should NOT be\n\t\t\t * preserved, but rather consolidated into the above\n\t\t\t * notes tree level. We achieve this by unconditionally\n\t\t\t * unpacking subtree entries that exist below the\n\t\t\t * threshold level at 'n = 2 * fanout'.\n\t\t\t */\n\t\t\tif (n <= 2 * fanout &&\n\t\t\t    flags & FOR_EACH_NOTE_YIELD_SUBTREES) {\n\t\t\t\t/* invoke callback with subtree */\n\t\t\t\tunsigned int path_len =\n\t\t\t\t\tl->key_oid.hash[KEY_INDEX] * 2 + fanout;\n\t\t\t\tassert(path_len < FANOUT_PATH_MAX - 1);\n\t\t\t\tconstruct_path_with_fanout(l->key_oid.hash,\n\t\t\t\t\t\t\t   fanout,\n\t\t\t\t\t\t\t   path);\n\t\t\t\t/* Create trailing slash, if needed */\n\t\t\t\tif (path[path_len - 1] != '/')\n\t\t\t\t\tpath[path_len++] = '/';\n\t\t\t\tpath[path_len] = '\\0';\n\t\t\t\tret = fn(&l->key_oid, &l->val_oid,\n\t\t\t\t\t path,\n\t\t\t\t\t cb_data);\n\t\t\t}\n\t\t\tif (n > fanout * 2 ||\n\t\t\t    !(flags & FOR_EACH_NOTE_DONT_UNPACK_SUBTREES)) {\n\t\t\t\t/* unpack subtree and resume traversal */\n\t\t\t\ttree->a[i] = NULL;\n\t\t\t\tload_subtree(t, l, tree, n);\n\t\t\t\tfree(l);\n\t\t\t\tgoto redo;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PTR_TYPE_NOTE:\n\t\t\tl = (struct leaf_node *) CLR_PTR_TYPE(p);\n\t\t\tconstruct_path_with_fanout(l->key_oid.hash, fanout,\n\t\t\t\t\t\t   path);\n\t\t\tret = fn(&l->key_oid, &l->val_oid, path,\n\t\t\t\t cb_data);\n\t\t\tbreak;\n\t\t}\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstruct tree_write_stack {\n\tstruct tree_write_stack *next;\n\tstruct strbuf buf;\n\tchar path[2]; /* path to subtree in next, if any */\n};\n\nstatic inline int matches_tree_write_stack(struct tree_write_stack *tws,\n\t\tconst char *full_path)\n{\n\treturn  full_path[0] == tws->path[0] &&\n\t\tfull_path[1] == tws->path[1] &&\n\t\tfull_path[2] == '/';\n}\n\nstatic void write_tree_entry(struct strbuf *buf, unsigned int mode,\n\t\tconst char *path, unsigned int path_len, const\n\t\tunsigned char *sha1)\n{\n\tstrbuf_addf(buf, \"%o %.*s%c\", mode, path_len, path, '\\0');\n\tstrbuf_add(buf, sha1, GIT_SHA1_RAWSZ);\n}\n\nstatic void tree_write_stack_init_subtree(struct tree_write_stack *tws,\n\t\tconst char *path)\n{\n\tstruct tree_write_stack *n;\n\tassert(!tws->next);\n\tassert(tws->path[0] == '\\0' && tws->path[1] == '\\0');\n\tn = (struct tree_write_stack *)\n\t\txmalloc(sizeof(struct tree_write_stack));\n\tn->next = NULL;\n\tstrbuf_init(&n->buf, 256 * (32 + GIT_SHA1_HEXSZ)); /* assume 256 entries per tree */\n\tn->path[0] = n->path[1] = '\\0';\n\ttws->next = n;\n\ttws->path[0] = path[0];\n\ttws->path[1] = path[1];\n}\n\nstatic int tree_write_stack_finish_subtree(struct tree_write_stack *tws)\n{\n\tint ret;\n\tstruct tree_write_stack *n = tws->next;\n\tstruct object_id s;\n\tif (n) {\n\t\tret = tree_write_stack_finish_subtree(n);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = write_sha1_file(n->buf.buf, n->buf.len, tree_type, s.hash);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tstrbuf_release(&n->buf);\n\t\tfree(n);\n\t\ttws->next = NULL;\n\t\twrite_tree_entry(&tws->buf, 040000, tws->path, 2, s.hash);\n\t\ttws->path[0] = tws->path[1] = '\\0';\n\t}\n\treturn 0;\n}\n\nstatic int write_each_note_helper(struct tree_write_stack *tws,\n\t\tconst char *path, unsigned int mode,\n\t\tconst struct object_id *oid)\n{\n\tsize_t path_len = strlen(path);\n\tunsigned int n = 0;\n\tint ret;\n\n\t/* Determine common part of tree write stack */\n\twhile (tws && 3 * n < path_len &&\n\t       matches_tree_write_stack(tws, path + 3 * n)) {\n\t\tn++;\n\t\ttws = tws->next;\n\t}\n\n\t/* tws point to last matching tree_write_stack entry */\n\tret = tree_write_stack_finish_subtree(tws);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Start subtrees needed to satisfy path */\n\twhile (3 * n + 2 < path_len && path[3 * n + 2] == '/') {\n\t\ttree_write_stack_init_subtree(tws, path + 3 * n);\n\t\tn++;\n\t\ttws = tws->next;\n\t}\n\n\t/* There should be no more directory components in the given path */\n\tassert(memchr(path + 3 * n, '/', path_len - (3 * n)) == NULL);\n\n\t/* Finally add given entry to the current tree object */\n\twrite_tree_entry(&tws->buf, mode, path + 3 * n, path_len - (3 * n),\n\t\t\t oid->hash);\n\n\treturn 0;\n}\n\nstruct write_each_note_data {\n\tstruct tree_write_stack *root;\n\tstruct non_note *next_non_note;\n};\n\nstatic int write_each_non_note_until(const char *note_path,\n\t\tstruct write_each_note_data *d)\n{\n\tstruct non_note *n = d->next_non_note;\n\tint cmp = 0, ret;\n\twhile (n && (!note_path || (cmp = strcmp(n->path, note_path)) <= 0)) {\n\t\tif (note_path && cmp == 0)\n\t\t\t; /* do nothing, prefer note to non-note */\n\t\telse {\n\t\t\tret = write_each_note_helper(d->root, n->path, n->mode,\n\t\t\t\t\t\t     &n->oid);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tn = n->next;\n\t}\n\td->next_non_note = n;\n\treturn 0;\n}\n\nstatic int write_each_note(const struct object_id *object_oid,\n\t\tconst struct object_id *note_oid, char *note_path,\n\t\tvoid *cb_data)\n{\n\tstruct write_each_note_data *d =\n\t\t(struct write_each_note_data *) cb_data;\n\tsize_t note_path_len = strlen(note_path);\n\tunsigned int mode = 0100644;\n\n\tif (note_path[note_path_len - 1] == '/') {\n\t\t/* subtree entry */\n\t\tnote_path_len--;\n\t\tnote_path[note_path_len] = '\\0';\n\t\tmode = 040000;\n\t}\n\tassert(note_path_len <= GIT_SHA1_HEXSZ + FANOUT_PATH_SEPARATORS);\n\n\t/* Weave non-note entries into note entries */\n\treturn  write_each_non_note_until(note_path, d) ||\n\t\twrite_each_note_helper(d->root, note_path, mode, note_oid);\n}\n\nstruct note_delete_list {\n\tstruct note_delete_list *next;\n\tconst unsigned char *sha1;\n};\n\nstatic int prune_notes_helper(const struct object_id *object_oid,\n\t\tconst struct object_id *note_oid, char *note_path,\n\t\tvoid *cb_data)\n{\n\tstruct note_delete_list **l = (struct note_delete_list **) cb_data;\n\tstruct note_delete_list *n;\n\n\tif (has_object_file(object_oid))\n\t\treturn 0; /* nothing to do for this note */\n\n\t/* failed to find object => prune this note */\n\tn = (struct note_delete_list *) xmalloc(sizeof(*n));\n\tn->next = *l;\n\tn->sha1 = object_oid->hash;\n\t*l = n;\n\treturn 0;\n}\n\nint combine_notes_concatenate(unsigned char *cur_sha1,\n\t\tconst unsigned char *new_sha1)\n{\n\tchar *cur_msg = NULL, *new_msg = NULL, *buf;\n\tunsigned long cur_len, new_len, buf_len;\n\tenum object_type cur_type, new_type;\n\tint ret;\n\n\t/* read in both note blob objects */\n\tif (!is_null_sha1(new_sha1))\n\t\tnew_msg = read_sha1_file(new_sha1, &new_type, &new_len);\n\tif (!new_msg || !new_len || new_type != OBJ_BLOB) {\n\t\tfree(new_msg);\n\t\treturn 0;\n\t}\n\tif (!is_null_sha1(cur_sha1))\n\t\tcur_msg = read_sha1_file(cur_sha1, &cur_type, &cur_len);\n\tif (!cur_msg || !cur_len || cur_type != OBJ_BLOB) {\n\t\tfree(cur_msg);\n\t\tfree(new_msg);\n\t\thashcpy(cur_sha1, new_sha1);\n\t\treturn 0;\n\t}\n\n\t/* we will separate the notes by two newlines anyway */\n\tif (cur_msg[cur_len - 1] == '\\n')\n\t\tcur_len--;\n\n\t/* concatenate cur_msg and new_msg into buf */\n\tbuf_len = cur_len + 2 + new_len;\n\tbuf = (char *) xmalloc(buf_len);\n\tmemcpy(buf, cur_msg, cur_len);\n\tbuf[cur_len] = '\\n';\n\tbuf[cur_len + 1] = '\\n';\n\tmemcpy(buf + cur_len + 2, new_msg, new_len);\n\tfree(cur_msg);\n\tfree(new_msg);\n\n\t/* create a new blob object from buf */\n\tret = write_sha1_file(buf, buf_len, blob_type, cur_sha1);\n\tfree(buf);\n\treturn ret;\n}\n\nint combine_notes_overwrite(unsigned char *cur_sha1,\n\t\tconst unsigned char *new_sha1)\n{\n\thashcpy(cur_sha1, new_sha1);\n\treturn 0;\n}\n\nint combine_notes_ignore(unsigned char *cur_sha1,\n\t\tconst unsigned char *new_sha1)\n{\n\treturn 0;\n}\n\n/*\n * Add the lines from the named object to list, with trailing\n * newlines removed.\n */\nstatic int string_list_add_note_lines(struct string_list *list,\n\t\t\t\t      const unsigned char *sha1)\n{\n\tchar *data;\n\tunsigned long len;\n\tenum object_type t;\n\n\tif (is_null_sha1(sha1))\n\t\treturn 0;\n\n\t/* read_sha1_file NUL-terminates */\n\tdata = read_sha1_file(sha1, &t, &len);\n\tif (t != OBJ_BLOB || !data || !len) {\n\t\tfree(data);\n\t\treturn t != OBJ_BLOB || !data;\n\t}\n\n\t/*\n\t * If the last line of the file is EOL-terminated, this will\n\t * add an empty string to the list.  But it will be removed\n\t * later, along with any empty strings that came from empty\n\t * lines within the file.\n\t */\n\tstring_list_split(list, data, '\\n', -1);\n\tfree(data);\n\treturn 0;\n}\n\nstatic int string_list_join_lines_helper(struct string_list_item *item,\n\t\t\t\t\t void *cb_data)\n{\n\tstruct strbuf *buf = cb_data;\n\tstrbuf_addstr(buf, item->string);\n\tstrbuf_addch(buf, '\\n');\n\treturn 0;\n}\n\nint combine_notes_cat_sort_uniq(unsigned char *cur_sha1,\n\t\tconst unsigned char *new_sha1)\n{\n\tstruct string_list sort_uniq_list = STRING_LIST_INIT_DUP;\n\tstruct strbuf buf = STRBUF_INIT;\n\tint ret = 1;\n\n\t/* read both note blob objects into unique_lines */\n\tif (string_list_add_note_lines(&sort_uniq_list, cur_sha1))\n\t\tgoto out;\n\tif (string_list_add_note_lines(&sort_uniq_list, new_sha1))\n\t\tgoto out;\n\tstring_list_remove_empty_items(&sort_uniq_list, 0);\n\tstring_list_sort(&sort_uniq_list);\n\tstring_list_remove_duplicates(&sort_uniq_list, 0);\n\n\t/* create a new blob object from sort_uniq_list */\n\tif (for_each_string_list(&sort_uniq_list,\n\t\t\t\t string_list_join_lines_helper, &buf))\n\t\tgoto out;\n\n\tret = write_sha1_file(buf.buf, buf.len, blob_type, cur_sha1);\n\nout:\n\tstrbuf_release(&buf);\n\tstring_list_clear(&sort_uniq_list, 0);\n\treturn ret;\n}\n\nstatic int string_list_add_one_ref(const char *refname, const struct object_id *oid,\n\t\t\t\t   int flag, void *cb)\n{\n\tstruct string_list *refs = cb;\n\tif (!unsorted_string_list_has_string(refs, refname))\n\t\tstring_list_append(refs, refname);\n\treturn 0;\n}\n\n/*\n * The list argument must have strdup_strings set on it.\n */\nvoid string_list_add_refs_by_glob(struct string_list *list, const char *glob)\n{\n\tassert(list->strdup_strings);\n\tif (has_glob_specials(glob)) {\n\t\tfor_each_glob_ref(string_list_add_one_ref, glob, list);\n\t} else {\n\t\tstruct object_id oid;\n\t\tif (get_oid(glob, &oid))\n\t\t\twarning(\"notes ref %s is invalid\", glob);\n\t\tif (!unsorted_string_list_has_string(list, glob))\n\t\t\tstring_list_append(list, glob);\n\t}\n}\n\nvoid string_list_add_refs_from_colon_sep(struct string_list *list,\n\t\t\t\t\t const char *globs)\n{\n\tstruct string_list split = STRING_LIST_INIT_NODUP;\n\tchar *globs_copy = xstrdup(globs);\n\tint i;\n\n\tstring_list_split_in_place(&split, globs_copy, ':', -1);\n\tstring_list_remove_empty_items(&split, 0);\n\n\tfor (i = 0; i < split.nr; i++)\n\t\tstring_list_add_refs_by_glob(list, split.items[i].string);\n\n\tstring_list_clear(&split, 0);\n\tfree(globs_copy);\n}\n\nstatic int notes_display_config(const char *k, const char *v, void *cb)\n{\n\tint *load_refs = cb;\n\n\tif (*load_refs && !strcmp(k, \"notes.displayref\")) {\n\t\tif (!v)\n\t\t\tconfig_error_nonbool(k);\n\t\tstring_list_add_refs_by_glob(&display_notes_refs, v);\n\t}\n\n\treturn 0;\n}\n\nconst char *default_notes_ref(void)\n{\n\tconst char *notes_ref = NULL;\n\tif (!notes_ref)\n\t\tnotes_ref = getenv(GIT_NOTES_REF_ENVIRONMENT);\n\tif (!notes_ref)\n\t\tnotes_ref = notes_ref_name; /* value of core.notesRef config */\n\tif (!notes_ref)\n\t\tnotes_ref = GIT_NOTES_DEFAULT_REF;\n\treturn notes_ref;\n}\n\nvoid init_notes(struct notes_tree *t, const char *notes_ref,\n\t\tcombine_notes_fn combine_notes, int flags)\n{\n\tstruct object_id oid, object_oid;\n\tunsigned mode;\n\tstruct leaf_node root_tree;\n\n\tif (!t)\n\t\tt = &default_notes_tree;\n\tassert(!t->initialized);\n\n\tif (!notes_ref)\n\t\tnotes_ref = default_notes_ref();\n\n\tif (!combine_notes)\n\t\tcombine_notes = combine_notes_concatenate;\n\n\tt->root = (struct int_node *) xcalloc(1, sizeof(struct int_node));\n\tt->first_non_note = NULL;\n\tt->prev_non_note = NULL;\n\tt->ref = xstrdup_or_null(notes_ref);\n\tt->update_ref = (flags & NOTES_INIT_WRITABLE) ? t->ref : NULL;\n\tt->combine_notes = combine_notes;\n\tt->initialized = 1;\n\tt->dirty = 0;\n\n\tif (flags & NOTES_INIT_EMPTY || !notes_ref ||\n\t    get_sha1_treeish(notes_ref, object_oid.hash))\n\t\treturn;\n\tif (flags & NOTES_INIT_WRITABLE && read_ref(notes_ref, object_oid.hash))\n\t\tdie(\"Cannot use notes ref %s\", notes_ref);\n\tif (get_tree_entry(object_oid.hash, \"\", oid.hash, &mode))\n\t\tdie(\"Failed to read notes tree referenced by %s (%s)\",\n\t\t    notes_ref, oid_to_hex(&object_oid));\n\n\toidclr(&root_tree.key_oid);\n\toidcpy(&root_tree.val_oid, &oid);\n\tload_subtree(t, &root_tree, t->root, 0);\n}\n\nstruct notes_tree **load_notes_trees(struct string_list *refs, int flags)\n{\n\tstruct string_list_item *item;\n\tint counter = 0;\n\tstruct notes_tree **trees;\n\tALLOC_ARRAY(trees, refs->nr + 1);\n\tfor_each_string_list_item(item, refs) {\n\t\tstruct notes_tree *t = xcalloc(1, sizeof(struct notes_tree));\n\t\tinit_notes(t, item->string, combine_notes_ignore, flags);\n\t\ttrees[counter++] = t;\n\t}\n\ttrees[counter] = NULL;\n\treturn trees;\n}\n\nvoid init_display_notes(struct display_notes_opt *opt)\n{\n\tchar *display_ref_env;\n\tint load_config_refs = 0;\n\tdisplay_notes_refs.strdup_strings = 1;\n\n\tassert(!display_notes_trees);\n\n\tif (!opt || opt->use_default_notes > 0 ||\n\t    (opt->use_default_notes == -1 && !opt->extra_notes_refs.nr)) {\n\t\tstring_list_append(&display_notes_refs, default_notes_ref());\n\t\tdisplay_ref_env = getenv(GIT_NOTES_DISPLAY_REF_ENVIRONMENT);\n\t\tif (display_ref_env) {\n\t\t\tstring_list_add_refs_from_colon_sep(&display_notes_refs,\n\t\t\t\t\t\t\t    display_ref_env);\n\t\t\tload_config_refs = 0;\n\t\t} else\n\t\t\tload_config_refs = 1;\n\t}\n\n\tgit_config(notes_display_config, &load_config_refs);\n\n\tif (opt) {\n\t\tstruct string_list_item *item;\n\t\tfor_each_string_list_item(item, &opt->extra_notes_refs)\n\t\t\tstring_list_add_refs_by_glob(&display_notes_refs,\n\t\t\t\t\t\t     item->string);\n\t}\n\n\tdisplay_notes_trees = load_notes_trees(&display_notes_refs, 0);\n\tstring_list_clear(&display_notes_refs, 0);\n}\n\nint add_note(struct notes_tree *t, const struct object_id *object_oid,\n\t\tconst struct object_id *note_oid, combine_notes_fn combine_notes)\n{\n\tstruct leaf_node *l;\n\n\tif (!t)\n\t\tt = &default_notes_tree;\n\tassert(t->initialized);\n\tt->dirty = 1;\n\tif (!combine_notes)\n\t\tcombine_notes = t->combine_notes;\n\tl = (struct leaf_node *) xmalloc(sizeof(struct leaf_node));\n\toidcpy(&l->key_oid, object_oid);\n\toidcpy(&l->val_oid, note_oid);\n\treturn note_tree_insert(t, t->root, 0, l, PTR_TYPE_NOTE, combine_notes);\n}\n\nint remove_note(struct notes_tree *t, const unsigned char *object_sha1)\n{\n\tstruct leaf_node l;\n\n\tif (!t)\n\t\tt = &default_notes_tree;\n\tassert(t->initialized);\n\thashcpy(l.key_oid.hash, object_sha1);\n\toidclr(&l.val_oid);\n\tnote_tree_remove(t, t->root, 0, &l);\n\tif (is_null_oid(&l.val_oid)) /* no note was removed */\n\t\treturn 1;\n\tt->dirty = 1;\n\treturn 0;\n}\n\nconst struct object_id *get_note(struct notes_tree *t,\n\t\tconst struct object_id *oid)\n{\n\tstruct leaf_node *found;\n\n\tif (!t)\n\t\tt = &default_notes_tree;\n\tassert(t->initialized);\n\tfound = note_tree_find(t, t->root, 0, oid->hash);\n\treturn found ? &found->val_oid : NULL;\n}\n\nint for_each_note(struct notes_tree *t, int flags, each_note_fn fn,\n\t\tvoid *cb_data)\n{\n\tif (!t)\n\t\tt = &default_notes_tree;\n\tassert(t->initialized);\n\treturn for_each_note_helper(t, t->root, 0, 0, flags, fn, cb_data);\n}\n\nint write_notes_tree(struct notes_tree *t, unsigned char *result)\n{\n\tstruct tree_write_stack root;\n\tstruct write_each_note_data cb_data;\n\tint ret;\n\n\tif (!t)\n\t\tt = &default_notes_tree;\n\tassert(t->initialized);\n\n\t/* Prepare for traversal of current notes tree */\n\troot.next = NULL; /* last forward entry in list is grounded */\n\tstrbuf_init(&root.buf, 256 * (32 + GIT_SHA1_HEXSZ)); /* assume 256 entries */\n\troot.path[0] = root.path[1] = '\\0';\n\tcb_data.root = &root;\n\tcb_data.next_non_note = t->first_non_note;\n\n\t/* Write tree objects representing current notes tree */\n\tret = for_each_note(t, FOR_EACH_NOTE_DONT_UNPACK_SUBTREES |\n\t\t\t\tFOR_EACH_NOTE_YIELD_SUBTREES,\n\t\t\twrite_each_note, &cb_data) ||\n\t\twrite_each_non_note_until(NULL, &cb_data) ||\n\t\ttree_write_stack_finish_subtree(&root) ||\n\t\twrite_sha1_file(root.buf.buf, root.buf.len, tree_type, result);\n\tstrbuf_release(&root.buf);\n\treturn ret;\n}\n\nvoid prune_notes(struct notes_tree *t, int flags)\n{\n\tstruct note_delete_list *l = NULL;\n\n\tif (!t)\n\t\tt = &default_notes_tree;\n\tassert(t->initialized);\n\n\tfor_each_note(t, 0, prune_notes_helper, &l);\n\n\twhile (l) {\n\t\tif (flags & NOTES_PRUNE_VERBOSE)\n\t\t\tprintf(\"%s\\n\", sha1_to_hex(l->sha1));\n\t\tif (!(flags & NOTES_PRUNE_DRYRUN))\n\t\t\tremove_note(t, l->sha1);\n\t\tl = l->next;\n\t}\n}\n\nvoid free_notes(struct notes_tree *t)\n{\n\tif (!t)\n\t\tt = &default_notes_tree;\n\tif (t->root)\n\t\tnote_tree_free(t->root);\n\tfree(t->root);\n\twhile (t->first_non_note) {\n\t\tt->prev_non_note = t->first_non_note->next;\n\t\tfree(t->first_non_note->path);\n\t\tfree(t->first_non_note);\n\t\tt->first_non_note = t->prev_non_note;\n\t}\n\tfree(t->ref);\n\tmemset(t, 0, sizeof(struct notes_tree));\n}\n\n/*\n * Fill the given strbuf with the notes associated with the given object.\n *\n * If the given notes_tree structure is not initialized, it will be auto-\n * initialized to the default value (see documentation for init_notes() above).\n * If the given notes_tree is NULL, the internal/default notes_tree will be\n * used instead.\n *\n * (raw != 0) gives the %N userformat; otherwise, the note message is given\n * for human consumption.\n */\nstatic void format_note(struct notes_tree *t, const struct object_id *object_oid,\n\t\t\tstruct strbuf *sb, const char *output_encoding, int raw)\n{\n\tstatic const char utf8[] = \"utf-8\";\n\tconst struct object_id *oid;\n\tchar *msg, *msg_p;\n\tunsigned long linelen, msglen;\n\tenum object_type type;\n\n\tif (!t)\n\t\tt = &default_notes_tree;\n\tif (!t->initialized)\n\t\tinit_notes(t, NULL, NULL, 0);\n\n\toid = get_note(t, object_oid);\n\tif (!oid)\n\t\treturn;\n\n\tif (!(msg = read_sha1_file(oid->hash, &type, &msglen)) || type != OBJ_BLOB) {\n\t\tfree(msg);\n\t\treturn;\n\t}\n\n\tif (output_encoding && *output_encoding &&\n\t    !is_encoding_utf8(output_encoding)) {\n\t\tchar *reencoded = reencode_string(msg, output_encoding, utf8);\n\t\tif (reencoded) {\n\t\t\tfree(msg);\n\t\t\tmsg = reencoded;\n\t\t\tmsglen = strlen(msg);\n\t\t}\n\t}\n\n\t/* we will end the annotation by a newline anyway */\n\tif (msglen && msg[msglen - 1] == '\\n')\n\t\tmsglen--;\n\n\tif (!raw) {\n\t\tconst char *ref = t->ref;\n\t\tif (!ref || !strcmp(ref, GIT_NOTES_DEFAULT_REF)) {\n\t\t\tstrbuf_addstr(sb, \"\\nNotes:\\n\");\n\t\t} else {\n\t\t\tif (starts_with(ref, \"refs/\"))\n\t\t\t\tref += 5;\n\t\t\tif (starts_with(ref, \"notes/\"))\n\t\t\t\tref += 6;\n\t\t\tstrbuf_addf(sb, \"\\nNotes (%s):\\n\", ref);\n\t\t}\n\t}\n\n\tfor (msg_p = msg; msg_p < msg + msglen; msg_p += linelen + 1) {\n\t\tlinelen = strchrnul(msg_p, '\\n') - msg_p;\n\n\t\tif (!raw)\n\t\t\tstrbuf_addstr(sb, \"    \");\n\t\tstrbuf_add(sb, msg_p, linelen);\n\t\tstrbuf_addch(sb, '\\n');\n\t}\n\n\tfree(msg);\n}\n\nvoid format_display_notes(const struct object_id *object_oid,\n\t\t\t  struct strbuf *sb, const char *output_encoding, int raw)\n{\n\tint i;\n\tassert(display_notes_trees);\n\tfor (i = 0; display_notes_trees[i]; i++)\n\t\tformat_note(display_notes_trees[i], object_oid, sb,\n\t\t\t    output_encoding, raw);\n}\n\nint copy_note(struct notes_tree *t,\n\t      const struct object_id *from_obj, const struct object_id *to_obj,\n\t      int force, combine_notes_fn combine_notes)\n{\n\tconst struct object_id *note = get_note(t, from_obj);\n\tconst struct object_id *existing_note = get_note(t, to_obj);\n\n\tif (!force && existing_note)\n\t\treturn 1;\n\n\tif (note)\n\t\treturn add_note(t, to_obj, note, combine_notes);\n\telse if (existing_note)\n\t\treturn add_note(t, to_obj, &null_oid, combine_notes);\n\n\treturn 0;\n}\n\nvoid expand_notes_ref(struct strbuf *sb)\n{\n\tif (starts_with(sb->buf, \"refs/notes/\"))\n\t\treturn; /* we're happy */\n\telse if (starts_with(sb->buf, \"notes/\"))\n\t\tstrbuf_insert(sb, 0, \"refs/\", 5);\n\telse\n\t\tstrbuf_insert(sb, 0, \"refs/notes/\", 11);\n}\n\nvoid expand_loose_notes_ref(struct strbuf *sb)\n{\n\tstruct object_id object;\n\n\tif (get_oid(sb->buf, &object)) {\n\t\t/* fallback to expand_notes_ref */\n\t\texpand_notes_ref(sb);\n\t}\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0074bc9b8948693d0dcd7957e1f9511bc50e43bf",
  "sha1_ok": true,
  "size": 37572
}
