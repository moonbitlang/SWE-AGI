{
  "content": {
    "base64": "I2luY2x1ZGUgImJ1aWx0aW4uaCIKI2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJjb25maWcuaCIKI2luY2x1ZGUgImNvbW1pdC5oIgojaW5jbHVkZSAidHJlZS5oIgojaW5jbHVkZSAiYmxvYi5oIgojaW5jbHVkZSAidGFnLmgiCiNpbmNsdWRlICJyZWZzLmgiCiNpbmNsdWRlICJwYWNrLmgiCiNpbmNsdWRlICJjYWNoZS10cmVlLmgiCiNpbmNsdWRlICJ0cmVlLXdhbGsuaCIKI2luY2x1ZGUgImZzY2suaCIKI2luY2x1ZGUgInBhcnNlLW9wdGlvbnMuaCIKI2luY2x1ZGUgImRpci5oIgojaW5jbHVkZSAicHJvZ3Jlc3MuaCIKI2luY2x1ZGUgInN0cmVhbWluZy5oIgojaW5jbHVkZSAiZGVjb3JhdGUuaCIKCiNkZWZpbmUgUkVBQ0hBQkxFIDB4MDAwMQojZGVmaW5lIFNFRU4gICAgICAweDAwMDIKI2RlZmluZSBIQVNfT0JKICAgMHgwMDA0CgpzdGF0aWMgaW50IHNob3dfcm9vdDsKc3RhdGljIGludCBzaG93X3RhZ3M7CnN0YXRpYyBpbnQgc2hvd191bnJlYWNoYWJsZTsKc3RhdGljIGludCBpbmNsdWRlX3JlZmxvZ3MgPSAxOwpzdGF0aWMgaW50IGNoZWNrX2Z1bGwgPSAxOwpzdGF0aWMgaW50IGNvbm5lY3Rpdml0eV9vbmx5OwpzdGF0aWMgaW50IGNoZWNrX3N0cmljdDsKc3RhdGljIGludCBrZWVwX2NhY2hlX29iamVjdHM7CnN0YXRpYyBzdHJ1Y3QgZnNja19vcHRpb25zIGZzY2tfd2Fsa19vcHRpb25zID0gRlNDS19PUFRJT05TX0RFRkFVTFQ7CnN0YXRpYyBzdHJ1Y3QgZnNja19vcHRpb25zIGZzY2tfb2JqX29wdGlvbnMgPSBGU0NLX09QVElPTlNfREVGQVVMVDsKc3RhdGljIHN0cnVjdCBvYmplY3RfaWQgaGVhZF9vaWQ7CnN0YXRpYyBjb25zdCBjaGFyICpoZWFkX3BvaW50c19hdDsKc3RhdGljIGludCBlcnJvcnNfZm91bmQ7CnN0YXRpYyBpbnQgd3JpdGVfbG9zdF9hbmRfZm91bmQ7CnN0YXRpYyBpbnQgdmVyYm9zZTsKc3RhdGljIGludCBzaG93X3Byb2dyZXNzID0gLTE7CnN0YXRpYyBpbnQgc2hvd19kYW5nbGluZyA9IDE7CnN0YXRpYyBpbnQgbmFtZV9vYmplY3RzOwojZGVmaW5lIEVSUk9SX09CSkVDVCAwMQojZGVmaW5lIEVSUk9SX1JFQUNIQUJMRSAwMgojZGVmaW5lIEVSUk9SX1BBQ0sgMDQKI2RlZmluZSBFUlJPUl9SRUZTIDAxMAoKc3RhdGljIGNvbnN0IGNoYXIgKmRlc2NyaWJlX29iamVjdChzdHJ1Y3Qgb2JqZWN0ICpvYmopCnsKCXN0YXRpYyBzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoJY2hhciAqbmFtZSA9IG5hbWVfb2JqZWN0cyA/CgkJbG9va3VwX2RlY29yYXRpb24oZnNja193YWxrX29wdGlvbnMub2JqZWN0X25hbWVzLCBvYmopIDogTlVMTDsKCglzdHJidWZfcmVzZXQoJmJ1Zik7CglzdHJidWZfYWRkc3RyKCZidWYsIG9pZF90b19oZXgoJm9iai0+b2lkKSk7CglpZiAobmFtZSkKCQlzdHJidWZfYWRkZigmYnVmLCAiICglcykiLCBuYW1lKTsKCglyZXR1cm4gYnVmLmJ1ZjsKfQoKc3RhdGljIGNvbnN0IGNoYXIgKnByaW50YWJsZV90eXBlKHN0cnVjdCBvYmplY3QgKm9iaikKewoJY29uc3QgY2hhciAqcmV0OwoKCWlmIChvYmotPnR5cGUgPT0gT0JKX05PTkUpIHsKCQllbnVtIG9iamVjdF90eXBlIHR5cGUgPSBzaGExX29iamVjdF9pbmZvKG9iai0+b2lkLmhhc2gsIE5VTEwpOwoJCWlmICh0eXBlID4gMCkKCQkJb2JqZWN0X2FzX3R5cGUob2JqLCB0eXBlLCAwKTsKCX0KCglyZXQgPSB0eXBlbmFtZShvYmotPnR5cGUpOwoJaWYgKCFyZXQpCgkJcmV0ID0gInVua25vd24iOwoKCXJldHVybiByZXQ7Cn0KCnN0YXRpYyBpbnQgZnNja19jb25maWcoY29uc3QgY2hhciAqdmFyLCBjb25zdCBjaGFyICp2YWx1ZSwgdm9pZCAqY2IpCnsKCWlmIChzdHJjbXAodmFyLCAiZnNjay5za2lwbGlzdCIpID09IDApIHsKCQljb25zdCBjaGFyICpwYXRoOwoJCXN0cnVjdCBzdHJidWYgc2IgPSBTVFJCVUZfSU5JVDsKCgkJaWYgKGdpdF9jb25maWdfcGF0aG5hbWUoJnBhdGgsIHZhciwgdmFsdWUpKQoJCQlyZXR1cm4gMTsKCQlzdHJidWZfYWRkZigmc2IsICJza2lwbGlzdD0lcyIsIHBhdGgpOwoJCWZyZWUoKGNoYXIgKilwYXRoKTsKCQlmc2NrX3NldF9tc2dfdHlwZXMoJmZzY2tfb2JqX29wdGlvbnMsIHNiLmJ1Zik7CgkJc3RyYnVmX3JlbGVhc2UoJnNiKTsKCQlyZXR1cm4gMDsKCX0KCglpZiAoc2tpcF9wcmVmaXgodmFyLCAiZnNjay4iLCAmdmFyKSkgewoJCWZzY2tfc2V0X21zZ190eXBlKCZmc2NrX29ial9vcHRpb25zLCB2YXIsIHZhbHVlKTsKCQlyZXR1cm4gMDsKCX0KCglyZXR1cm4gZ2l0X2RlZmF1bHRfY29uZmlnKHZhciwgdmFsdWUsIGNiKTsKfQoKc3RhdGljIHZvaWQgb2JqcmVwb3J0KHN0cnVjdCBvYmplY3QgKm9iaiwgY29uc3QgY2hhciAqbXNnX3R5cGUsCgkJCWNvbnN0IGNoYXIgKmVycikKewoJZnByaW50ZihzdGRlcnIsICIlcyBpbiAlcyAlczogJXNcbiIsCgkJbXNnX3R5cGUsIHByaW50YWJsZV90eXBlKG9iaiksIGRlc2NyaWJlX29iamVjdChvYmopLCBlcnIpOwp9CgpzdGF0aWMgaW50IG9iamVycm9yKHN0cnVjdCBvYmplY3QgKm9iaiwgY29uc3QgY2hhciAqZXJyKQp7CgllcnJvcnNfZm91bmQgfD0gRVJST1JfT0JKRUNUOwoJb2JqcmVwb3J0KG9iaiwgImVycm9yIiwgZXJyKTsKCXJldHVybiAtMTsKfQoKc3RhdGljIGludCBmc2NrX2Vycm9yX2Z1bmMoc3RydWN0IGZzY2tfb3B0aW9ucyAqbywKCXN0cnVjdCBvYmplY3QgKm9iaiwgaW50IHR5cGUsIGNvbnN0IGNoYXIgKm1lc3NhZ2UpCnsKCW9ianJlcG9ydChvYmosICh0eXBlID09IEZTQ0tfV0FSTikgPyAid2FybmluZyIgOiAiZXJyb3IiLCBtZXNzYWdlKTsKCXJldHVybiAodHlwZSA9PSBGU0NLX1dBUk4pID8gMCA6IDE7Cn0KCnN0YXRpYyBzdHJ1Y3Qgb2JqZWN0X2FycmF5IHBlbmRpbmc7CgpzdGF0aWMgaW50IG1hcmtfb2JqZWN0KHN0cnVjdCBvYmplY3QgKm9iaiwgaW50IHR5cGUsIHZvaWQgKmRhdGEsIHN0cnVjdCBmc2NrX29wdGlvbnMgKm9wdGlvbnMpCnsKCXN0cnVjdCBvYmplY3QgKnBhcmVudCA9IGRhdGE7CgoJLyoKCSAqIFRoZSBvbmx5IGNhc2UgZGF0YSBpcyBOVUxMIG9yIHR5cGUgaXMgT0JKX0FOWSBpcyB3aGVuCgkgKiBtYXJrX29iamVjdF9yZWFjaGFibGUoKSBjYWxscyB1cy4gIEFsbCB0aGUgY2FsbGVycyBvZgoJICogdGhhdCBmdW5jdGlvbiBoYXMgbm9uLU5VTEwgb2JqIGhlbmNlIC4uLgoJICovCglpZiAoIW9iaikgewoJCS8qIC4uLiB0aGVzZSByZWZlcmVuY2VzIHRvIHBhcmVudC0+ZmxkIGFyZSBzYWZlIGhlcmUgKi8KCQlwcmludGYoImJyb2tlbiBsaW5rIGZyb20gJTdzICVzXG4iLAoJCQkgICBwcmludGFibGVfdHlwZShwYXJlbnQpLCBkZXNjcmliZV9vYmplY3QocGFyZW50KSk7CgkJcHJpbnRmKCJicm9rZW4gbGluayBmcm9tICU3cyAlc1xuIiwKCQkJICAgKHR5cGUgPT0gT0JKX0FOWSA/ICJ1bmtub3duIiA6IHR5cGVuYW1lKHR5cGUpKSwgInVua25vd24iKTsKCQllcnJvcnNfZm91bmQgfD0gRVJST1JfUkVBQ0hBQkxFOwoJCXJldHVybiAxOwoJfQoKCWlmICh0eXBlICE9IE9CSl9BTlkgJiYgb2JqLT50eXBlICE9IHR5cGUpCgkJLyogLi4uIGFuZCB0aGUgcmVmZXJlbmNlIHRvIHBhcmVudCBpcyBzYWZlIGhlcmUgKi8KCQlvYmplcnJvcihwYXJlbnQsICJ3cm9uZyBvYmplY3QgdHlwZSBpbiBsaW5rIik7CgoJaWYgKG9iai0+ZmxhZ3MgJiBSRUFDSEFCTEUpCgkJcmV0dXJuIDA7CglvYmotPmZsYWdzIHw9IFJFQUNIQUJMRTsKCWlmICghKG9iai0+ZmxhZ3MgJiBIQVNfT0JKKSkgewoJCWlmIChwYXJlbnQgJiYgIWhhc19vYmplY3RfZmlsZSgmb2JqLT5vaWQpKSB7CgkJCXByaW50ZigiYnJva2VuIGxpbmsgZnJvbSAlN3MgJXNcbiIsCgkJCQkgcHJpbnRhYmxlX3R5cGUocGFyZW50KSwgZGVzY3JpYmVfb2JqZWN0KHBhcmVudCkpOwoJCQlwcmludGYoIiAgICAgICAgICAgICAgdG8gJTdzICVzXG4iLAoJCQkJIHByaW50YWJsZV90eXBlKG9iaiksIGRlc2NyaWJlX29iamVjdChvYmopKTsKCQkJZXJyb3JzX2ZvdW5kIHw9IEVSUk9SX1JFQUNIQUJMRTsKCQl9CgkJcmV0dXJuIDE7Cgl9CgoJYWRkX29iamVjdF9hcnJheShvYmosIE5VTEwsICZwZW5kaW5nKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgdm9pZCBtYXJrX29iamVjdF9yZWFjaGFibGUoc3RydWN0IG9iamVjdCAqb2JqKQp7CgltYXJrX29iamVjdChvYmosIE9CSl9BTlksIE5VTEwsIE5VTEwpOwp9CgpzdGF0aWMgaW50IHRyYXZlcnNlX29uZV9vYmplY3Qoc3RydWN0IG9iamVjdCAqb2JqKQp7CglpbnQgcmVzdWx0OwoJc3RydWN0IHRyZWUgKnRyZWUgPSBOVUxMOwoKCWlmIChvYmotPnR5cGUgPT0gT0JKX1RSRUUpIHsKCQl0cmVlID0gKHN0cnVjdCB0cmVlICopb2JqOwoJCWlmIChwYXJzZV90cmVlKHRyZWUpIDwgMCkKCQkJcmV0dXJuIDE7IC8qIGVycm9yIGFscmVhZHkgZGlzcGxheWVkICovCgl9CglyZXN1bHQgPSBmc2NrX3dhbGsob2JqLCBvYmosICZmc2NrX3dhbGtfb3B0aW9ucyk7CglpZiAodHJlZSkKCQlmcmVlX3RyZWVfYnVmZmVyKHRyZWUpOwoJcmV0dXJuIHJlc3VsdDsKfQoKc3RhdGljIGludCB0cmF2ZXJzZV9yZWFjaGFibGUodm9pZCkKewoJc3RydWN0IHByb2dyZXNzICpwcm9ncmVzcyA9IE5VTEw7Cgl1bnNpZ25lZCBpbnQgbnIgPSAwOwoJaW50IHJlc3VsdCA9IDA7CglpZiAoc2hvd19wcm9ncmVzcykKCQlwcm9ncmVzcyA9IHN0YXJ0X2RlbGF5ZWRfcHJvZ3Jlc3MoXygiQ2hlY2tpbmcgY29ubmVjdGl2aXR5IiksIDApOwoJd2hpbGUgKHBlbmRpbmcubnIpIHsKCQlzdHJ1Y3Qgb2JqZWN0X2FycmF5X2VudHJ5ICplbnRyeTsKCQlzdHJ1Y3Qgb2JqZWN0ICpvYmo7CgoJCWVudHJ5ID0gcGVuZGluZy5vYmplY3RzICsgLS1wZW5kaW5nLm5yOwoJCW9iaiA9IGVudHJ5LT5pdGVtOwoJCXJlc3VsdCB8PSB0cmF2ZXJzZV9vbmVfb2JqZWN0KG9iaik7CgkJZGlzcGxheV9wcm9ncmVzcyhwcm9ncmVzcywgKytucik7Cgl9CglzdG9wX3Byb2dyZXNzKCZwcm9ncmVzcyk7CglyZXR1cm4gISFyZXN1bHQ7Cn0KCnN0YXRpYyBpbnQgbWFya191c2VkKHN0cnVjdCBvYmplY3QgKm9iaiwgaW50IHR5cGUsIHZvaWQgKmRhdGEsIHN0cnVjdCBmc2NrX29wdGlvbnMgKm9wdGlvbnMpCnsKCWlmICghb2JqKQoJCXJldHVybiAxOwoJb2JqLT51c2VkID0gMTsKCXJldHVybiAwOwp9CgovKgogKiBDaGVjayBhIHNpbmdsZSByZWFjaGFibGUgb2JqZWN0CiAqLwpzdGF0aWMgdm9pZCBjaGVja19yZWFjaGFibGVfb2JqZWN0KHN0cnVjdCBvYmplY3QgKm9iaikKewoJLyoKCSAqIFdlIG9idmlvdXNseSB3YW50IHRoZSBvYmplY3QgdG8gYmUgcGFyc2VkLAoJICogZXhjZXB0IGlmIGl0IHdhcyBpbiBhIHBhY2stZmlsZSBhbmQgd2UgZGlkbid0CgkgKiBkbyBhIGZ1bGwgZnNjawoJICovCglpZiAoIShvYmotPmZsYWdzICYgSEFTX09CSikpIHsKCQlpZiAoaGFzX3NoYTFfcGFjayhvYmotPm9pZC5oYXNoKSkKCQkJcmV0dXJuOyAvKiBpdCBpcyBpbiBwYWNrIC0gZm9yZ2V0IGFib3V0IGl0ICovCgkJcHJpbnRmKCJtaXNzaW5nICVzICVzXG4iLCBwcmludGFibGVfdHlwZShvYmopLAoJCQlkZXNjcmliZV9vYmplY3Qob2JqKSk7CgkJZXJyb3JzX2ZvdW5kIHw9IEVSUk9SX1JFQUNIQUJMRTsKCQlyZXR1cm47Cgl9Cn0KCi8qCiAqIENoZWNrIGEgc2luZ2xlIHVucmVhY2hhYmxlIG9iamVjdAogKi8Kc3RhdGljIHZvaWQgY2hlY2tfdW5yZWFjaGFibGVfb2JqZWN0KHN0cnVjdCBvYmplY3QgKm9iaikKewoJLyoKCSAqIE1pc3NpbmcgdW5yZWFjaGFibGUgb2JqZWN0PyBJZ25vcmUgaXQuIEl0J3Mgbm90IGxpa2UKCSAqIHdlIG1pc3MgaXQgKHNpbmNlIGl0IGNhbid0IGJlIHJlYWNoZWQpLCBub3IgZG8gd2Ugd2FudAoJICogdG8gY29tcGxhaW4gYWJvdXQgaXQgYmVpbmcgdW5yZWFjaGFibGUgKHNpbmNlIGl0IGRvZXMKCSAqIG5vdCBleGlzdCkuCgkgKi8KCWlmICghKG9iai0+ZmxhZ3MgJiBIQVNfT0JKKSkKCQlyZXR1cm47CgoJLyoKCSAqIFVucmVhY2hhYmxlIG9iamVjdCB0aGF0IGV4aXN0cz8gU2hvdyBpdCBpZiBhc2tlZCB0bywKCSAqIHNpbmNlIHRoaXMgaXMgc29tZXRoaW5nIHRoYXQgaXMgcHJ1bmFibGUuCgkgKi8KCWlmIChzaG93X3VucmVhY2hhYmxlKSB7CgkJcHJpbnRmKCJ1bnJlYWNoYWJsZSAlcyAlc1xuIiwgcHJpbnRhYmxlX3R5cGUob2JqKSwKCQkJZGVzY3JpYmVfb2JqZWN0KG9iaikpOwoJCXJldHVybjsKCX0KCgkvKgoJICogIiF1c2VkIiBtZWFucyB0aGF0IG5vdGhpbmcgYXQgYWxsIHBvaW50cyB0byBpdCwgaW5jbHVkaW5nCgkgKiBvdGhlciB1bnJlYWNoYWJsZSBvYmplY3RzLiBJbiBvdGhlciB3b3JkcywgaXQncyB0aGUgInRpcCIKCSAqIG9mIHNvbWUgc2V0IG9mIHVucmVhY2hhYmxlIG9iamVjdHMsIHVzdWFsbHkgYSBjb21taXQgdGhhdAoJICogZ290IGRyb3BwZWQuCgkgKgoJICogU3VjaCBzdGFydGluZyBwb2ludHMgYXJlIG1vcmUgaW50ZXJlc3RpbmcgdGhhbiBzb21lIHJhbmRvbQoJICogc2V0IG9mIHVucmVhY2hhYmxlIG9iamVjdHMsIHNvIHdlIHNob3cgdGhlbSBldmVuIGlmIHRoZSB1c2VyCgkgKiBoYXNuJ3QgYXNrZWQgZm9yIF9hbGxfIHVucmVhY2hhYmxlIG9iamVjdHMuIElmIHlvdSBoYXZlCgkgKiBkZWxldGVkIGEgYnJhbmNoIGJ5IG1pc3Rha2UsIHRoaXMgaXMgYSBwcmltZSBjYW5kaWRhdGUgdG8KCSAqIHN0YXJ0IGxvb2tpbmcgYXQsIGZvciBleGFtcGxlLgoJICovCglpZiAoIW9iai0+dXNlZCkgewoJCWlmIChzaG93X2RhbmdsaW5nKQoJCQlwcmludGYoImRhbmdsaW5nICVzICVzXG4iLCBwcmludGFibGVfdHlwZShvYmopLAoJCQkgICAgICAgZGVzY3JpYmVfb2JqZWN0KG9iaikpOwoJCWlmICh3cml0ZV9sb3N0X2FuZF9mb3VuZCkgewoJCQljaGFyICpmaWxlbmFtZSA9IGdpdF9wYXRoZHVwKCJsb3N0LWZvdW5kLyVzLyVzIiwKCQkJCW9iai0+dHlwZSA9PSBPQkpfQ09NTUlUID8gImNvbW1pdCIgOiAib3RoZXIiLAoJCQkJZGVzY3JpYmVfb2JqZWN0KG9iaikpOwoJCQlGSUxFICpmOwoKCQkJaWYgKHNhZmVfY3JlYXRlX2xlYWRpbmdfZGlyZWN0b3JpZXNfY29uc3QoZmlsZW5hbWUpKSB7CgkJCQllcnJvcigiQ291bGQgbm90IGNyZWF0ZSBsb3N0LWZvdW5kIik7CgkJCQlmcmVlKGZpbGVuYW1lKTsKCQkJCXJldHVybjsKCQkJfQoJCQlmID0geGZvcGVuKGZpbGVuYW1lLCAidyIpOwoJCQlpZiAob2JqLT50eXBlID09IE9CSl9CTE9CKSB7CgkJCQlpZiAoc3RyZWFtX2Jsb2JfdG9fZmQoZmlsZW5vKGYpLCAmb2JqLT5vaWQsIE5VTEwsIDEpKQoJCQkJCWRpZV9lcnJubygiQ291bGQgbm90IHdyaXRlICclcyciLCBmaWxlbmFtZSk7CgkJCX0gZWxzZQoJCQkJZnByaW50ZihmLCAiJXNcbiIsIGRlc2NyaWJlX29iamVjdChvYmopKTsKCQkJaWYgKGZjbG9zZShmKSkKCQkJCWRpZV9lcnJubygiQ291bGQgbm90IGZpbmlzaCAnJXMnIiwKCQkJCQkgIGZpbGVuYW1lKTsKCQkJZnJlZShmaWxlbmFtZSk7CgkJfQoJCXJldHVybjsKCX0KCgkvKgoJICogT3RoZXJ3aXNlPyBJdCdzIHRoZXJlLCBpdCdzIHVucmVhY2hhYmxlLCBhbmQgc29tZSBvdGhlciB1bnJlYWNoYWJsZQoJICogb2JqZWN0IHBvaW50cyB0byBpdC4gSWdub3JlIGl0IC0gaXQncyBub3QgaW50ZXJlc3RpbmcsIGFuZCB3ZSBzaG93ZWQKCSAqIGFsbCB0aGUgaW50ZXJlc3RpbmcgY2FzZXMgYWJvdmUuCgkgKi8KfQoKc3RhdGljIHZvaWQgY2hlY2tfb2JqZWN0KHN0cnVjdCBvYmplY3QgKm9iaikKewoJaWYgKHZlcmJvc2UpCgkJZnByaW50ZihzdGRlcnIsICJDaGVja2luZyAlc1xuIiwgZGVzY3JpYmVfb2JqZWN0KG9iaikpOwoKCWlmIChvYmotPmZsYWdzICYgUkVBQ0hBQkxFKQoJCWNoZWNrX3JlYWNoYWJsZV9vYmplY3Qob2JqKTsKCWVsc2UKCQljaGVja191bnJlYWNoYWJsZV9vYmplY3Qob2JqKTsKfQoKc3RhdGljIHZvaWQgY2hlY2tfY29ubmVjdGl2aXR5KHZvaWQpCnsKCWludCBpLCBtYXg7CgoJLyogVHJhdmVyc2UgdGhlIHBlbmRpbmcgcmVhY2hhYmxlIG9iamVjdHMgKi8KCXRyYXZlcnNlX3JlYWNoYWJsZSgpOwoKCS8qIExvb2sgdXAgYWxsIHRoZSByZXF1aXJlbWVudHMsIHdhcm4gYWJvdXQgbWlzc2luZyBvYmplY3RzLi4gKi8KCW1heCA9IGdldF9tYXhfb2JqZWN0X2luZGV4KCk7CglpZiAodmVyYm9zZSkKCQlmcHJpbnRmKHN0ZGVyciwgIkNoZWNraW5nIGNvbm5lY3Rpdml0eSAoJWQgb2JqZWN0cylcbiIsIG1heCk7CgoJZm9yIChpID0gMDsgaSA8IG1heDsgaSsrKSB7CgkJc3RydWN0IG9iamVjdCAqb2JqID0gZ2V0X2luZGV4ZWRfb2JqZWN0KGkpOwoKCQlpZiAob2JqKQoJCQljaGVja19vYmplY3Qob2JqKTsKCX0KfQoKc3RhdGljIGludCBmc2NrX29iaihzdHJ1Y3Qgb2JqZWN0ICpvYmopCnsKCWlmIChvYmotPmZsYWdzICYgU0VFTikKCQlyZXR1cm4gMDsKCW9iai0+ZmxhZ3MgfD0gU0VFTjsKCglpZiAodmVyYm9zZSkKCQlmcHJpbnRmKHN0ZGVyciwgIkNoZWNraW5nICVzICVzXG4iLAoJCQlwcmludGFibGVfdHlwZShvYmopLCBkZXNjcmliZV9vYmplY3Qob2JqKSk7CgoJaWYgKGZzY2tfd2FsayhvYmosIE5VTEwsICZmc2NrX29ial9vcHRpb25zKSkKCQlvYmplcnJvcihvYmosICJicm9rZW4gbGlua3MiKTsKCWlmIChmc2NrX29iamVjdChvYmosIE5VTEwsIDAsICZmc2NrX29ial9vcHRpb25zKSkKCQlyZXR1cm4gLTE7CgoJaWYgKG9iai0+dHlwZSA9PSBPQkpfVFJFRSkgewoJCXN0cnVjdCB0cmVlICppdGVtID0gKHN0cnVjdCB0cmVlICopIG9iajsKCgkJZnJlZV90cmVlX2J1ZmZlcihpdGVtKTsKCX0KCglpZiAob2JqLT50eXBlID09IE9CSl9DT01NSVQpIHsKCQlzdHJ1Y3QgY29tbWl0ICpjb21taXQgPSAoc3RydWN0IGNvbW1pdCAqKSBvYmo7CgoJCWZyZWVfY29tbWl0X2J1ZmZlcihjb21taXQpOwoKCQlpZiAoIWNvbW1pdC0+cGFyZW50cyAmJiBzaG93X3Jvb3QpCgkJCXByaW50Zigicm9vdCAlc1xuIiwgZGVzY3JpYmVfb2JqZWN0KCZjb21taXQtPm9iamVjdCkpOwoJfQoKCWlmIChvYmotPnR5cGUgPT0gT0JKX1RBRykgewoJCXN0cnVjdCB0YWcgKnRhZyA9IChzdHJ1Y3QgdGFnICopIG9iajsKCgkJaWYgKHNob3dfdGFncyAmJiB0YWctPnRhZ2dlZCkgewoJCQlwcmludGYoInRhZ2dlZCAlcyAlcyIsIHByaW50YWJsZV90eXBlKHRhZy0+dGFnZ2VkKSwKCQkJCWRlc2NyaWJlX29iamVjdCh0YWctPnRhZ2dlZCkpOwoJCQlwcmludGYoIiAoJXMpIGluICVzXG4iLCB0YWctPnRhZywKCQkJCWRlc2NyaWJlX29iamVjdCgmdGFnLT5vYmplY3QpKTsKCQl9Cgl9CgoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgZnNja19vYmpfYnVmZmVyKGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwgZW51bSBvYmplY3RfdHlwZSB0eXBlLAoJCQkgICB1bnNpZ25lZCBsb25nIHNpemUsIHZvaWQgKmJ1ZmZlciwgaW50ICplYXRlbikKewoJLyoKCSAqIE5vdGUsIGJ1ZmZlciBtYXkgYmUgTlVMTCBpZiB0eXBlIGlzIE9CSl9CTE9CLiBTZWUKCSAqIHZlcmlmeV9wYWNrZmlsZSgpLCBkYXRhX3ZhbGlkIHZhcmlhYmxlIGZvciBkZXRhaWxzLgoJICovCglzdHJ1Y3Qgb2JqZWN0ICpvYmo7CglvYmogPSBwYXJzZV9vYmplY3RfYnVmZmVyKG9pZCwgdHlwZSwgc2l6ZSwgYnVmZmVyLCBlYXRlbik7CglpZiAoIW9iaikgewoJCWVycm9yc19mb3VuZCB8PSBFUlJPUl9PQkpFQ1Q7CgkJcmV0dXJuIGVycm9yKCIlczogb2JqZWN0IGNvcnJ1cHQgb3IgbWlzc2luZyIsIG9pZF90b19oZXgob2lkKSk7Cgl9CglvYmotPmZsYWdzID0gSEFTX09CSjsKCXJldHVybiBmc2NrX29iaihvYmopOwp9CgpzdGF0aWMgaW50IGRlZmF1bHRfcmVmczsKCnN0YXRpYyB2b2lkIGZzY2tfaGFuZGxlX3JlZmxvZ19vaWQoY29uc3QgY2hhciAqcmVmbmFtZSwgc3RydWN0IG9iamVjdF9pZCAqb2lkLAoJdGltZXN0YW1wX3QgdGltZXN0YW1wKQp7CglzdHJ1Y3Qgb2JqZWN0ICpvYmo7CgoJaWYgKCFpc19udWxsX29pZChvaWQpKSB7CgkJb2JqID0gbG9va3VwX29iamVjdChvaWQtPmhhc2gpOwoJCWlmIChvYmogJiYgKG9iai0+ZmxhZ3MgJiBIQVNfT0JKKSkgewoJCQlpZiAodGltZXN0YW1wICYmIG5hbWVfb2JqZWN0cykKCQkJCWFkZF9kZWNvcmF0aW9uKGZzY2tfd2Fsa19vcHRpb25zLm9iamVjdF9uYW1lcywKCQkJCQlvYmosCgkJCQkJeHN0cmZtdCgiJXNAeyUiUFJJdGltZSJ9IiwgcmVmbmFtZSwgdGltZXN0YW1wKSk7CgkJCW9iai0+dXNlZCA9IDE7CgkJCW1hcmtfb2JqZWN0X3JlYWNoYWJsZShvYmopOwoJCX0gZWxzZSB7CgkJCWVycm9yKCIlczogaW52YWxpZCByZWZsb2cgZW50cnkgJXMiLCByZWZuYW1lLCBvaWRfdG9faGV4KG9pZCkpOwoJCQllcnJvcnNfZm91bmQgfD0gRVJST1JfUkVBQ0hBQkxFOwoJCX0KCX0KfQoKc3RhdGljIGludCBmc2NrX2hhbmRsZV9yZWZsb2dfZW50KHN0cnVjdCBvYmplY3RfaWQgKm9vaWQsIHN0cnVjdCBvYmplY3RfaWQgKm5vaWQsCgkJY29uc3QgY2hhciAqZW1haWwsIHRpbWVzdGFtcF90IHRpbWVzdGFtcCwgaW50IHR6LAoJCWNvbnN0IGNoYXIgKm1lc3NhZ2UsIHZvaWQgKmNiX2RhdGEpCnsKCWNvbnN0IGNoYXIgKnJlZm5hbWUgPSBjYl9kYXRhOwoKCWlmICh2ZXJib3NlKQoJCWZwcmludGYoc3RkZXJyLCAiQ2hlY2tpbmcgcmVmbG9nICVzLT4lc1xuIiwKCQkJb2lkX3RvX2hleChvb2lkKSwgb2lkX3RvX2hleChub2lkKSk7CgoJZnNja19oYW5kbGVfcmVmbG9nX29pZChyZWZuYW1lLCBvb2lkLCAwKTsKCWZzY2tfaGFuZGxlX3JlZmxvZ19vaWQocmVmbmFtZSwgbm9pZCwgdGltZXN0YW1wKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGZzY2tfaGFuZGxlX3JlZmxvZyhjb25zdCBjaGFyICpsb2duYW1lLCBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsCgkJCSAgICAgIGludCBmbGFnLCB2b2lkICpjYl9kYXRhKQp7Cglmb3JfZWFjaF9yZWZsb2dfZW50KGxvZ25hbWUsIGZzY2tfaGFuZGxlX3JlZmxvZ19lbnQsICh2b2lkICopbG9nbmFtZSk7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBmc2NrX2hhbmRsZV9yZWYoY29uc3QgY2hhciAqcmVmbmFtZSwgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLAoJCQkgICBpbnQgZmxhZywgdm9pZCAqY2JfZGF0YSkKewoJc3RydWN0IG9iamVjdCAqb2JqOwoKCW9iaiA9IHBhcnNlX29iamVjdChvaWQpOwoJaWYgKCFvYmopIHsKCQllcnJvcigiJXM6IGludmFsaWQgc2hhMSBwb2ludGVyICVzIiwgcmVmbmFtZSwgb2lkX3RvX2hleChvaWQpKTsKCQllcnJvcnNfZm91bmQgfD0gRVJST1JfUkVBQ0hBQkxFOwoJCS8qIFdlJ2xsIGNvbnRpbnVlIHdpdGggdGhlIHJlc3QgZGVzcGl0ZSB0aGUgZXJyb3IuLiAqLwoJCXJldHVybiAwOwoJfQoJaWYgKG9iai0+dHlwZSAhPSBPQkpfQ09NTUlUICYmIGlzX2JyYW5jaChyZWZuYW1lKSkgewoJCWVycm9yKCIlczogbm90IGEgY29tbWl0IiwgcmVmbmFtZSk7CgkJZXJyb3JzX2ZvdW5kIHw9IEVSUk9SX1JFRlM7Cgl9CglkZWZhdWx0X3JlZnMrKzsKCW9iai0+dXNlZCA9IDE7CglpZiAobmFtZV9vYmplY3RzKQoJCWFkZF9kZWNvcmF0aW9uKGZzY2tfd2Fsa19vcHRpb25zLm9iamVjdF9uYW1lcywKCQkJb2JqLCB4c3RyZHVwKHJlZm5hbWUpKTsKCW1hcmtfb2JqZWN0X3JlYWNoYWJsZShvYmopOwoKCXJldHVybiAwOwp9CgpzdGF0aWMgdm9pZCBnZXRfZGVmYXVsdF9oZWFkcyh2b2lkKQp7CglpZiAoaGVhZF9wb2ludHNfYXQgJiYgIWlzX251bGxfb2lkKCZoZWFkX29pZCkpCgkJZnNja19oYW5kbGVfcmVmKCJIRUFEIiwgJmhlYWRfb2lkLCAwLCBOVUxMKTsKCWZvcl9lYWNoX3Jhd3JlZihmc2NrX2hhbmRsZV9yZWYsIE5VTEwpOwoJaWYgKGluY2x1ZGVfcmVmbG9ncykKCQlmb3JfZWFjaF9yZWZsb2coZnNja19oYW5kbGVfcmVmbG9nLCBOVUxMKTsKCgkvKgoJICogTm90IGhhdmluZyBhbnkgZGVmYXVsdCBoZWFkcyBpc24ndCByZWFsbHkgZmF0YWwsIGJ1dAoJICogaXQgZG9lcyBtZWFuIHRoYXQgIi0tdW5yZWFjaGFibGUiIG5vIGxvbmdlciBtYWtlcyBhbnkKCSAqIHNlbnNlIChzaW5jZSBpbiB0aGlzIGNhc2UgZXZlcnl0aGluZyB3aWxsIG9idmlvdXNseQoJICogYmUgdW5yZWFjaGFibGUgYnkgZGVmaW5pdGlvbi4KCSAqCgkgKiBTaG93aW5nIGRhbmdsaW5nIG9iamVjdHMgaXMgdmFsaWQsIHRob3VnaCAoYXMgdGhvc2UKCSAqIGRhbmdsaW5nIG9iamVjdHMgYXJlIGxpa2VseSBsb3N0IGhlYWRzKS4KCSAqCgkgKiBTbyB3ZSBqdXN0IHByaW50IGEgd2FybmluZyBhYm91dCBpdCwgYW5kIGNsZWFyIHRoZQoJICogInNob3dfdW5yZWFjaGFibGUiIGZsYWcuCgkgKi8KCWlmICghZGVmYXVsdF9yZWZzKSB7CgkJZnByaW50ZihzdGRlcnIsICJub3RpY2U6IE5vIGRlZmF1bHQgcmVmZXJlbmNlc1xuIik7CgkJc2hvd191bnJlYWNoYWJsZSA9IDA7Cgl9Cn0KCnN0YXRpYyBzdHJ1Y3Qgb2JqZWN0ICpwYXJzZV9sb29zZV9vYmplY3QoY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLAoJCQkJCSBjb25zdCBjaGFyICpwYXRoKQp7CglzdHJ1Y3Qgb2JqZWN0ICpvYmo7Cgl2b2lkICpjb250ZW50czsKCWVudW0gb2JqZWN0X3R5cGUgdHlwZTsKCXVuc2lnbmVkIGxvbmcgc2l6ZTsKCWludCBlYXRlbjsKCglpZiAocmVhZF9sb29zZV9vYmplY3QocGF0aCwgb2lkLT5oYXNoLCAmdHlwZSwgJnNpemUsICZjb250ZW50cykgPCAwKQoJCXJldHVybiBOVUxMOwoKCWlmICghY29udGVudHMgJiYgdHlwZSAhPSBPQkpfQkxPQikKCQlkaWUoIkJVRzogcmVhZF9sb29zZV9vYmplY3Qgc3RyZWFtZWQgYSBub24tYmxvYiIpOwoKCW9iaiA9IHBhcnNlX29iamVjdF9idWZmZXIob2lkLCB0eXBlLCBzaXplLCBjb250ZW50cywgJmVhdGVuKTsKCglpZiAoIWVhdGVuKQoJCWZyZWUoY29udGVudHMpOwoJcmV0dXJuIG9iajsKfQoKc3RhdGljIGludCBmc2NrX2xvb3NlKGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwgY29uc3QgY2hhciAqcGF0aCwgdm9pZCAqZGF0YSkKewoJc3RydWN0IG9iamVjdCAqb2JqID0gcGFyc2VfbG9vc2Vfb2JqZWN0KG9pZCwgcGF0aCk7CgoJaWYgKCFvYmopIHsKCQllcnJvcnNfZm91bmQgfD0gRVJST1JfT0JKRUNUOwoJCWVycm9yKCIlczogb2JqZWN0IGNvcnJ1cHQgb3IgbWlzc2luZzogJXMiLAoJCSAgICAgIG9pZF90b19oZXgob2lkKSwgcGF0aCk7CgkJcmV0dXJuIDA7IC8qIGtlZXAgY2hlY2tpbmcgb3RoZXIgb2JqZWN0cyAqLwoJfQoKCW9iai0+ZmxhZ3MgPSBIQVNfT0JKOwoJaWYgKGZzY2tfb2JqKG9iaikpCgkJZXJyb3JzX2ZvdW5kIHw9IEVSUk9SX09CSkVDVDsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGZzY2tfY3J1ZnQoY29uc3QgY2hhciAqYmFzZW5hbWUsIGNvbnN0IGNoYXIgKnBhdGgsIHZvaWQgKmRhdGEpCnsKCWlmICghc3RhcnRzX3dpdGgoYmFzZW5hbWUsICJ0bXBfb2JqXyIpKQoJCWZwcmludGYoc3RkZXJyLCAiYmFkIHNoYTEgZmlsZTogJXNcbiIsIHBhdGgpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgZnNja19zdWJkaXIodW5zaWduZWQgaW50IG5yLCBjb25zdCBjaGFyICpwYXRoLCB2b2lkICpwcm9ncmVzcykKewoJZGlzcGxheV9wcm9ncmVzcyhwcm9ncmVzcywgbnIgKyAxKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgdm9pZCBmc2NrX29iamVjdF9kaXIoY29uc3QgY2hhciAqcGF0aCkKewoJc3RydWN0IHByb2dyZXNzICpwcm9ncmVzcyA9IE5VTEw7CgoJaWYgKHZlcmJvc2UpCgkJZnByaW50ZihzdGRlcnIsICJDaGVja2luZyBvYmplY3QgZGlyZWN0b3J5XG4iKTsKCglpZiAoc2hvd19wcm9ncmVzcykKCQlwcm9ncmVzcyA9IHN0YXJ0X3Byb2dyZXNzKF8oIkNoZWNraW5nIG9iamVjdCBkaXJlY3RvcmllcyIpLCAyNTYpOwoKCWZvcl9lYWNoX2xvb3NlX2ZpbGVfaW5fb2JqZGlyKHBhdGgsIGZzY2tfbG9vc2UsIGZzY2tfY3J1ZnQsIGZzY2tfc3ViZGlyLAoJCQkJICAgICAgcHJvZ3Jlc3MpOwoJZGlzcGxheV9wcm9ncmVzcyhwcm9ncmVzcywgMjU2KTsKCXN0b3BfcHJvZ3Jlc3MoJnByb2dyZXNzKTsKfQoKc3RhdGljIGludCBmc2NrX2hlYWRfbGluayh2b2lkKQp7CglpbnQgbnVsbF9pc19lcnJvciA9IDA7CgoJaWYgKHZlcmJvc2UpCgkJZnByaW50ZihzdGRlcnIsICJDaGVja2luZyBIRUFEIGxpbmtcbiIpOwoKCWhlYWRfcG9pbnRzX2F0ID0gcmVzb2x2ZV9yZWZfdW5zYWZlKCJIRUFEIiwgMCwgaGVhZF9vaWQuaGFzaCwgTlVMTCk7CglpZiAoIWhlYWRfcG9pbnRzX2F0KSB7CgkJZXJyb3JzX2ZvdW5kIHw9IEVSUk9SX1JFRlM7CgkJcmV0dXJuIGVycm9yKCJJbnZhbGlkIEhFQUQiKTsKCX0KCWlmICghc3RyY21wKGhlYWRfcG9pbnRzX2F0LCAiSEVBRCIpKQoJCS8qIGRldGFjaGVkIEhFQUQgKi8KCQludWxsX2lzX2Vycm9yID0gMTsKCWVsc2UgaWYgKCFzdGFydHNfd2l0aChoZWFkX3BvaW50c19hdCwgInJlZnMvaGVhZHMvIikpIHsKCQllcnJvcnNfZm91bmQgfD0gRVJST1JfUkVGUzsKCQlyZXR1cm4gZXJyb3IoIkhFQUQgcG9pbnRzIHRvIHNvbWV0aGluZyBzdHJhbmdlICglcykiLAoJCQkgICAgIGhlYWRfcG9pbnRzX2F0KTsKCX0KCWlmIChpc19udWxsX29pZCgmaGVhZF9vaWQpKSB7CgkJaWYgKG51bGxfaXNfZXJyb3IpIHsKCQkJZXJyb3JzX2ZvdW5kIHw9IEVSUk9SX1JFRlM7CgkJCXJldHVybiBlcnJvcigiSEVBRDogZGV0YWNoZWQgSEVBRCBwb2ludHMgYXQgbm90aGluZyIpOwoJCX0KCQlmcHJpbnRmKHN0ZGVyciwgIm5vdGljZTogSEVBRCBwb2ludHMgdG8gYW4gdW5ib3JuIGJyYW5jaCAoJXMpXG4iLAoJCQloZWFkX3BvaW50c19hdCArIDExKTsKCX0KCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGZzY2tfY2FjaGVfdHJlZShzdHJ1Y3QgY2FjaGVfdHJlZSAqaXQpCnsKCWludCBpOwoJaW50IGVyciA9IDA7CgoJaWYgKHZlcmJvc2UpCgkJZnByaW50ZihzdGRlcnIsICJDaGVja2luZyBjYWNoZSB0cmVlXG4iKTsKCglpZiAoMCA8PSBpdC0+ZW50cnlfY291bnQpIHsKCQlzdHJ1Y3Qgb2JqZWN0ICpvYmogPSBwYXJzZV9vYmplY3QoJml0LT5vaWQpOwoJCWlmICghb2JqKSB7CgkJCWVycm9yKCIlczogaW52YWxpZCBzaGExIHBvaW50ZXIgaW4gY2FjaGUtdHJlZSIsCgkJCSAgICAgIG9pZF90b19oZXgoJml0LT5vaWQpKTsKCQkJZXJyb3JzX2ZvdW5kIHw9IEVSUk9SX1JFRlM7CgkJCXJldHVybiAxOwoJCX0KCQlvYmotPnVzZWQgPSAxOwoJCWlmIChuYW1lX29iamVjdHMpCgkJCWFkZF9kZWNvcmF0aW9uKGZzY2tfd2Fsa19vcHRpb25zLm9iamVjdF9uYW1lcywKCQkJCW9iaiwgeHN0cmR1cCgiOiIpKTsKCQltYXJrX29iamVjdF9yZWFjaGFibGUob2JqKTsKCQlpZiAob2JqLT50eXBlICE9IE9CSl9UUkVFKQoJCQllcnIgfD0gb2JqZXJyb3Iob2JqLCAibm9uLXRyZWUgaW4gY2FjaGUtdHJlZSIpOwoJfQoJZm9yIChpID0gMDsgaSA8IGl0LT5zdWJ0cmVlX25yOyBpKyspCgkJZXJyIHw9IGZzY2tfY2FjaGVfdHJlZShpdC0+ZG93bltpXS0+Y2FjaGVfdHJlZSk7CglyZXR1cm4gZXJyOwp9CgpzdGF0aWMgdm9pZCBtYXJrX29iamVjdF9mb3JfY29ubmVjdGl2aXR5KGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCkKewoJc3RydWN0IG9iamVjdCAqb2JqID0gbG9va3VwX3Vua25vd25fb2JqZWN0KG9pZC0+aGFzaCk7CglvYmotPmZsYWdzIHw9IEhBU19PQko7Cn0KCnN0YXRpYyBpbnQgbWFya19sb29zZV9mb3JfY29ubmVjdGl2aXR5KGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwKCQkJCSAgICAgICBjb25zdCBjaGFyICpwYXRoLAoJCQkJICAgICAgIHZvaWQgKmRhdGEpCnsKCW1hcmtfb2JqZWN0X2Zvcl9jb25uZWN0aXZpdHkob2lkKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IG1hcmtfcGFja2VkX2Zvcl9jb25uZWN0aXZpdHkoY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLAoJCQkJCXN0cnVjdCBwYWNrZWRfZ2l0ICpwYWNrLAoJCQkJCXVpbnQzMl90IHBvcywKCQkJCQl2b2lkICpkYXRhKQp7CgltYXJrX29iamVjdF9mb3JfY29ubmVjdGl2aXR5KG9pZCk7CglyZXR1cm4gMDsKfQoKc3RhdGljIGNoYXIgY29uc3QgKiBjb25zdCBmc2NrX3VzYWdlW10gPSB7CglOXygiZ2l0IGZzY2sgWzxvcHRpb25zPl0gWzxvYmplY3Q+Li4uXSIpLAoJTlVMTAp9OwoKc3RhdGljIHN0cnVjdCBvcHRpb24gZnNja19vcHRzW10gPSB7CglPUFRfX1ZFUkJPU0UoJnZlcmJvc2UsIE5fKCJiZSB2ZXJib3NlIikpLAoJT1BUX0JPT0woMCwgInVucmVhY2hhYmxlIiwgJnNob3dfdW5yZWFjaGFibGUsIE5fKCJzaG93IHVucmVhY2hhYmxlIG9iamVjdHMiKSksCglPUFRfQk9PTCgwLCAiZGFuZ2xpbmciLCAmc2hvd19kYW5nbGluZywgTl8oInNob3cgZGFuZ2xpbmcgb2JqZWN0cyIpKSwKCU9QVF9CT09MKDAsICJ0YWdzIiwgJnNob3dfdGFncywgTl8oInJlcG9ydCB0YWdzIikpLAoJT1BUX0JPT0woMCwgInJvb3QiLCAmc2hvd19yb290LCBOXygicmVwb3J0IHJvb3Qgbm9kZXMiKSksCglPUFRfQk9PTCgwLCAiY2FjaGUiLCAma2VlcF9jYWNoZV9vYmplY3RzLCBOXygibWFrZSBpbmRleCBvYmplY3RzIGhlYWQgbm9kZXMiKSksCglPUFRfQk9PTCgwLCAicmVmbG9ncyIsICZpbmNsdWRlX3JlZmxvZ3MsIE5fKCJtYWtlIHJlZmxvZ3MgaGVhZCBub2RlcyAoZGVmYXVsdCkiKSksCglPUFRfQk9PTCgwLCAiZnVsbCIsICZjaGVja19mdWxsLCBOXygiYWxzbyBjb25zaWRlciBwYWNrcyBhbmQgYWx0ZXJuYXRlIG9iamVjdHMiKSksCglPUFRfQk9PTCgwLCAiY29ubmVjdGl2aXR5LW9ubHkiLCAmY29ubmVjdGl2aXR5X29ubHksIE5fKCJjaGVjayBvbmx5IGNvbm5lY3Rpdml0eSIpKSwKCU9QVF9CT09MKDAsICJzdHJpY3QiLCAmY2hlY2tfc3RyaWN0LCBOXygiZW5hYmxlIG1vcmUgc3RyaWN0IGNoZWNraW5nIikpLAoJT1BUX0JPT0woMCwgImxvc3QtZm91bmQiLCAmd3JpdGVfbG9zdF9hbmRfZm91bmQsCgkJCQlOXygid3JpdGUgZGFuZ2xpbmcgb2JqZWN0cyBpbiAuZ2l0L2xvc3QtZm91bmQiKSksCglPUFRfQk9PTCgwLCAicHJvZ3Jlc3MiLCAmc2hvd19wcm9ncmVzcywgTl8oInNob3cgcHJvZ3Jlc3MiKSksCglPUFRfQk9PTCgwLCAibmFtZS1vYmplY3RzIiwgJm5hbWVfb2JqZWN0cywgTl8oInNob3cgdmVyYm9zZSBuYW1lcyBmb3IgcmVhY2hhYmxlIG9iamVjdHMiKSksCglPUFRfRU5EKCksCn07CgppbnQgY21kX2ZzY2soaW50IGFyZ2MsIGNvbnN0IGNoYXIgKiphcmd2LCBjb25zdCBjaGFyICpwcmVmaXgpCnsKCWludCBpLCBoZWFkczsKCXN0cnVjdCBhbHRlcm5hdGVfb2JqZWN0X2RhdGFiYXNlICphbHQ7CgoJZXJyb3JzX2ZvdW5kID0gMDsKCWNoZWNrX3JlcGxhY2VfcmVmcyA9IDA7CgoJYXJnYyA9IHBhcnNlX29wdGlvbnMoYXJnYywgYXJndiwgcHJlZml4LCBmc2NrX29wdHMsIGZzY2tfdXNhZ2UsIDApOwoKCWZzY2tfd2Fsa19vcHRpb25zLndhbGsgPSBtYXJrX29iamVjdDsKCWZzY2tfb2JqX29wdGlvbnMud2FsayA9IG1hcmtfdXNlZDsKCWZzY2tfb2JqX29wdGlvbnMuZXJyb3JfZnVuYyA9IGZzY2tfZXJyb3JfZnVuYzsKCWlmIChjaGVja19zdHJpY3QpCgkJZnNja19vYmpfb3B0aW9ucy5zdHJpY3QgPSAxOwoKCWlmIChzaG93X3Byb2dyZXNzID09IC0xKQoJCXNob3dfcHJvZ3Jlc3MgPSBpc2F0dHkoMik7CglpZiAodmVyYm9zZSkKCQlzaG93X3Byb2dyZXNzID0gMDsKCglpZiAod3JpdGVfbG9zdF9hbmRfZm91bmQpIHsKCQljaGVja19mdWxsID0gMTsKCQlpbmNsdWRlX3JlZmxvZ3MgPSAwOwoJfQoKCWlmIChuYW1lX29iamVjdHMpCgkJZnNja193YWxrX29wdGlvbnMub2JqZWN0X25hbWVzID0KCQkJeGNhbGxvYygxLCBzaXplb2Yoc3RydWN0IGRlY29yYXRpb24pKTsKCglnaXRfY29uZmlnKGZzY2tfY29uZmlnLCBOVUxMKTsKCglmc2NrX2hlYWRfbGluaygpOwoJaWYgKGNvbm5lY3Rpdml0eV9vbmx5KSB7CgkJZm9yX2VhY2hfbG9vc2Vfb2JqZWN0KG1hcmtfbG9vc2VfZm9yX2Nvbm5lY3Rpdml0eSwgTlVMTCwgMCk7CgkJZm9yX2VhY2hfcGFja2VkX29iamVjdChtYXJrX3BhY2tlZF9mb3JfY29ubmVjdGl2aXR5LCBOVUxMLCAwKTsKCX0gZWxzZSB7CgkJZnNja19vYmplY3RfZGlyKGdldF9vYmplY3RfZGlyZWN0b3J5KCkpOwoKCQlwcmVwYXJlX2FsdF9vZGIoKTsKCQlmb3IgKGFsdCA9IGFsdF9vZGJfbGlzdDsgYWx0OyBhbHQgPSBhbHQtPm5leHQpCgkJCWZzY2tfb2JqZWN0X2RpcihhbHQtPnBhdGgpOwoKCQlpZiAoY2hlY2tfZnVsbCkgewoJCQlzdHJ1Y3QgcGFja2VkX2dpdCAqcDsKCQkJdWludDMyX3QgdG90YWwgPSAwLCBjb3VudCA9IDA7CgkJCXN0cnVjdCBwcm9ncmVzcyAqcHJvZ3Jlc3MgPSBOVUxMOwoKCQkJcHJlcGFyZV9wYWNrZWRfZ2l0KCk7CgoJCQlpZiAoc2hvd19wcm9ncmVzcykgewoJCQkJZm9yIChwID0gcGFja2VkX2dpdDsgcDsgcCA9IHAtPm5leHQpIHsKCQkJCQlpZiAob3Blbl9wYWNrX2luZGV4KHApKQoJCQkJCQljb250aW51ZTsKCQkJCQl0b3RhbCArPSBwLT5udW1fb2JqZWN0czsKCQkJCX0KCgkJCQlwcm9ncmVzcyA9IHN0YXJ0X3Byb2dyZXNzKF8oIkNoZWNraW5nIG9iamVjdHMiKSwgdG90YWwpOwoJCQl9CgkJCWZvciAocCA9IHBhY2tlZF9naXQ7IHA7IHAgPSBwLT5uZXh0KSB7CgkJCQkvKiB2ZXJpZnkgZ2l2ZXMgZXJyb3IgbWVzc2FnZXMgaXRzZWxmICovCgkJCQlpZiAodmVyaWZ5X3BhY2socCwgZnNja19vYmpfYnVmZmVyLAoJCQkJCQlwcm9ncmVzcywgY291bnQpKQoJCQkJCWVycm9yc19mb3VuZCB8PSBFUlJPUl9QQUNLOwoJCQkJY291bnQgKz0gcC0+bnVtX29iamVjdHM7CgkJCX0KCQkJc3RvcF9wcm9ncmVzcygmcHJvZ3Jlc3MpOwoJCX0KCX0KCgloZWFkcyA9IDA7Cglmb3IgKGkgPSAwOyBpIDwgYXJnYzsgaSsrKSB7CgkJY29uc3QgY2hhciAqYXJnID0gYXJndltpXTsKCQl1bnNpZ25lZCBjaGFyIHNoYTFbMjBdOwoJCWlmICghZ2V0X3NoYTEoYXJnLCBzaGExKSkgewoJCQlzdHJ1Y3Qgb2JqZWN0ICpvYmogPSBsb29rdXBfb2JqZWN0KHNoYTEpOwoKCQkJaWYgKCFvYmogfHwgIShvYmotPmZsYWdzICYgSEFTX09CSikpIHsKCQkJCWVycm9yKCIlczogb2JqZWN0IG1pc3NpbmciLCBzaGExX3RvX2hleChzaGExKSk7CgkJCQllcnJvcnNfZm91bmQgfD0gRVJST1JfT0JKRUNUOwoJCQkJY29udGludWU7CgkJCX0KCgkJCW9iai0+dXNlZCA9IDE7CgkJCWlmIChuYW1lX29iamVjdHMpCgkJCQlhZGRfZGVjb3JhdGlvbihmc2NrX3dhbGtfb3B0aW9ucy5vYmplY3RfbmFtZXMsCgkJCQkJb2JqLCB4c3RyZHVwKGFyZykpOwoJCQltYXJrX29iamVjdF9yZWFjaGFibGUob2JqKTsKCQkJaGVhZHMrKzsKCQkJY29udGludWU7CgkJfQoJCWVycm9yKCJpbnZhbGlkIHBhcmFtZXRlcjogZXhwZWN0ZWQgc2hhMSwgZ290ICclcyciLCBhcmcpOwoJCWVycm9yc19mb3VuZCB8PSBFUlJPUl9PQkpFQ1Q7Cgl9CgoJLyoKCSAqIElmIHdlJ3ZlIG5vdCBiZWVuIGdpdmVuIGFueSBleHBsaWNpdCBoZWFkIGluZm9ybWF0aW9uLCBkbyB0aGUKCSAqIGRlZmF1bHQgb25lcyBmcm9tIC5naXQvcmVmcy4gV2UgYWxzbyBjb25zaWRlciB0aGUgaW5kZXggZmlsZQoJICogaW4gdGhpcyBjYXNlIChpZSB0aGlzIGltcGxpZXMgLS1jYWNoZSkuCgkgKi8KCWlmICghYXJnYykgewoJCWdldF9kZWZhdWx0X2hlYWRzKCk7CgkJa2VlcF9jYWNoZV9vYmplY3RzID0gMTsKCX0KCglpZiAoa2VlcF9jYWNoZV9vYmplY3RzKSB7CgkJdmVyaWZ5X2luZGV4X2NoZWNrc3VtID0gMTsKCQlyZWFkX2NhY2hlKCk7CgkJZm9yIChpID0gMDsgaSA8IGFjdGl2ZV9ucjsgaSsrKSB7CgkJCXVuc2lnbmVkIGludCBtb2RlOwoJCQlzdHJ1Y3QgYmxvYiAqYmxvYjsKCQkJc3RydWN0IG9iamVjdCAqb2JqOwoKCQkJbW9kZSA9IGFjdGl2ZV9jYWNoZVtpXS0+Y2VfbW9kZTsKCQkJaWYgKFNfSVNHSVRMSU5LKG1vZGUpKQoJCQkJY29udGludWU7CgkJCWJsb2IgPSBsb29rdXBfYmxvYigmYWN0aXZlX2NhY2hlW2ldLT5vaWQpOwoJCQlpZiAoIWJsb2IpCgkJCQljb250aW51ZTsKCQkJb2JqID0gJmJsb2ItPm9iamVjdDsKCQkJb2JqLT51c2VkID0gMTsKCQkJaWYgKG5hbWVfb2JqZWN0cykKCQkJCWFkZF9kZWNvcmF0aW9uKGZzY2tfd2Fsa19vcHRpb25zLm9iamVjdF9uYW1lcywKCQkJCQlvYmosCgkJCQkJeHN0cmZtdCgiOiVzIiwgYWN0aXZlX2NhY2hlW2ldLT5uYW1lKSk7CgkJCW1hcmtfb2JqZWN0X3JlYWNoYWJsZShvYmopOwoJCX0KCQlpZiAoYWN0aXZlX2NhY2hlX3RyZWUpCgkJCWZzY2tfY2FjaGVfdHJlZShhY3RpdmVfY2FjaGVfdHJlZSk7Cgl9CgoJY2hlY2tfY29ubmVjdGl2aXR5KCk7CglyZXR1cm4gZXJyb3JzX2ZvdW5kOwp9Cg==",
    "text": "#include \"builtin.h\"\n#include \"cache.h\"\n#include \"config.h\"\n#include \"commit.h\"\n#include \"tree.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"refs.h\"\n#include \"pack.h\"\n#include \"cache-tree.h\"\n#include \"tree-walk.h\"\n#include \"fsck.h\"\n#include \"parse-options.h\"\n#include \"dir.h\"\n#include \"progress.h\"\n#include \"streaming.h\"\n#include \"decorate.h\"\n\n#define REACHABLE 0x0001\n#define SEEN      0x0002\n#define HAS_OBJ   0x0004\n\nstatic int show_root;\nstatic int show_tags;\nstatic int show_unreachable;\nstatic int include_reflogs = 1;\nstatic int check_full = 1;\nstatic int connectivity_only;\nstatic int check_strict;\nstatic int keep_cache_objects;\nstatic struct fsck_options fsck_walk_options = FSCK_OPTIONS_DEFAULT;\nstatic struct fsck_options fsck_obj_options = FSCK_OPTIONS_DEFAULT;\nstatic struct object_id head_oid;\nstatic const char *head_points_at;\nstatic int errors_found;\nstatic int write_lost_and_found;\nstatic int verbose;\nstatic int show_progress = -1;\nstatic int show_dangling = 1;\nstatic int name_objects;\n#define ERROR_OBJECT 01\n#define ERROR_REACHABLE 02\n#define ERROR_PACK 04\n#define ERROR_REFS 010\n\nstatic const char *describe_object(struct object *obj)\n{\n\tstatic struct strbuf buf = STRBUF_INIT;\n\tchar *name = name_objects ?\n\t\tlookup_decoration(fsck_walk_options.object_names, obj) : NULL;\n\n\tstrbuf_reset(&buf);\n\tstrbuf_addstr(&buf, oid_to_hex(&obj->oid));\n\tif (name)\n\t\tstrbuf_addf(&buf, \" (%s)\", name);\n\n\treturn buf.buf;\n}\n\nstatic const char *printable_type(struct object *obj)\n{\n\tconst char *ret;\n\n\tif (obj->type == OBJ_NONE) {\n\t\tenum object_type type = sha1_object_info(obj->oid.hash, NULL);\n\t\tif (type > 0)\n\t\t\tobject_as_type(obj, type, 0);\n\t}\n\n\tret = typename(obj->type);\n\tif (!ret)\n\t\tret = \"unknown\";\n\n\treturn ret;\n}\n\nstatic int fsck_config(const char *var, const char *value, void *cb)\n{\n\tif (strcmp(var, \"fsck.skiplist\") == 0) {\n\t\tconst char *path;\n\t\tstruct strbuf sb = STRBUF_INIT;\n\n\t\tif (git_config_pathname(&path, var, value))\n\t\t\treturn 1;\n\t\tstrbuf_addf(&sb, \"skiplist=%s\", path);\n\t\tfree((char *)path);\n\t\tfsck_set_msg_types(&fsck_obj_options, sb.buf);\n\t\tstrbuf_release(&sb);\n\t\treturn 0;\n\t}\n\n\tif (skip_prefix(var, \"fsck.\", &var)) {\n\t\tfsck_set_msg_type(&fsck_obj_options, var, value);\n\t\treturn 0;\n\t}\n\n\treturn git_default_config(var, value, cb);\n}\n\nstatic void objreport(struct object *obj, const char *msg_type,\n\t\t\tconst char *err)\n{\n\tfprintf(stderr, \"%s in %s %s: %s\\n\",\n\t\tmsg_type, printable_type(obj), describe_object(obj), err);\n}\n\nstatic int objerror(struct object *obj, const char *err)\n{\n\terrors_found |= ERROR_OBJECT;\n\tobjreport(obj, \"error\", err);\n\treturn -1;\n}\n\nstatic int fsck_error_func(struct fsck_options *o,\n\tstruct object *obj, int type, const char *message)\n{\n\tobjreport(obj, (type == FSCK_WARN) ? \"warning\" : \"error\", message);\n\treturn (type == FSCK_WARN) ? 0 : 1;\n}\n\nstatic struct object_array pending;\n\nstatic int mark_object(struct object *obj, int type, void *data, struct fsck_options *options)\n{\n\tstruct object *parent = data;\n\n\t/*\n\t * The only case data is NULL or type is OBJ_ANY is when\n\t * mark_object_reachable() calls us.  All the callers of\n\t * that function has non-NULL obj hence ...\n\t */\n\tif (!obj) {\n\t\t/* ... these references to parent->fld are safe here */\n\t\tprintf(\"broken link from %7s %s\\n\",\n\t\t\t   printable_type(parent), describe_object(parent));\n\t\tprintf(\"broken link from %7s %s\\n\",\n\t\t\t   (type == OBJ_ANY ? \"unknown\" : typename(type)), \"unknown\");\n\t\terrors_found |= ERROR_REACHABLE;\n\t\treturn 1;\n\t}\n\n\tif (type != OBJ_ANY && obj->type != type)\n\t\t/* ... and the reference to parent is safe here */\n\t\tobjerror(parent, \"wrong object type in link\");\n\n\tif (obj->flags & REACHABLE)\n\t\treturn 0;\n\tobj->flags |= REACHABLE;\n\tif (!(obj->flags & HAS_OBJ)) {\n\t\tif (parent && !has_object_file(&obj->oid)) {\n\t\t\tprintf(\"broken link from %7s %s\\n\",\n\t\t\t\t printable_type(parent), describe_object(parent));\n\t\t\tprintf(\"              to %7s %s\\n\",\n\t\t\t\t printable_type(obj), describe_object(obj));\n\t\t\terrors_found |= ERROR_REACHABLE;\n\t\t}\n\t\treturn 1;\n\t}\n\n\tadd_object_array(obj, NULL, &pending);\n\treturn 0;\n}\n\nstatic void mark_object_reachable(struct object *obj)\n{\n\tmark_object(obj, OBJ_ANY, NULL, NULL);\n}\n\nstatic int traverse_one_object(struct object *obj)\n{\n\tint result;\n\tstruct tree *tree = NULL;\n\n\tif (obj->type == OBJ_TREE) {\n\t\ttree = (struct tree *)obj;\n\t\tif (parse_tree(tree) < 0)\n\t\t\treturn 1; /* error already displayed */\n\t}\n\tresult = fsck_walk(obj, obj, &fsck_walk_options);\n\tif (tree)\n\t\tfree_tree_buffer(tree);\n\treturn result;\n}\n\nstatic int traverse_reachable(void)\n{\n\tstruct progress *progress = NULL;\n\tunsigned int nr = 0;\n\tint result = 0;\n\tif (show_progress)\n\t\tprogress = start_delayed_progress(_(\"Checking connectivity\"), 0);\n\twhile (pending.nr) {\n\t\tstruct object_array_entry *entry;\n\t\tstruct object *obj;\n\n\t\tentry = pending.objects + --pending.nr;\n\t\tobj = entry->item;\n\t\tresult |= traverse_one_object(obj);\n\t\tdisplay_progress(progress, ++nr);\n\t}\n\tstop_progress(&progress);\n\treturn !!result;\n}\n\nstatic int mark_used(struct object *obj, int type, void *data, struct fsck_options *options)\n{\n\tif (!obj)\n\t\treturn 1;\n\tobj->used = 1;\n\treturn 0;\n}\n\n/*\n * Check a single reachable object\n */\nstatic void check_reachable_object(struct object *obj)\n{\n\t/*\n\t * We obviously want the object to be parsed,\n\t * except if it was in a pack-file and we didn't\n\t * do a full fsck\n\t */\n\tif (!(obj->flags & HAS_OBJ)) {\n\t\tif (has_sha1_pack(obj->oid.hash))\n\t\t\treturn; /* it is in pack - forget about it */\n\t\tprintf(\"missing %s %s\\n\", printable_type(obj),\n\t\t\tdescribe_object(obj));\n\t\terrors_found |= ERROR_REACHABLE;\n\t\treturn;\n\t}\n}\n\n/*\n * Check a single unreachable object\n */\nstatic void check_unreachable_object(struct object *obj)\n{\n\t/*\n\t * Missing unreachable object? Ignore it. It's not like\n\t * we miss it (since it can't be reached), nor do we want\n\t * to complain about it being unreachable (since it does\n\t * not exist).\n\t */\n\tif (!(obj->flags & HAS_OBJ))\n\t\treturn;\n\n\t/*\n\t * Unreachable object that exists? Show it if asked to,\n\t * since this is something that is prunable.\n\t */\n\tif (show_unreachable) {\n\t\tprintf(\"unreachable %s %s\\n\", printable_type(obj),\n\t\t\tdescribe_object(obj));\n\t\treturn;\n\t}\n\n\t/*\n\t * \"!used\" means that nothing at all points to it, including\n\t * other unreachable objects. In other words, it's the \"tip\"\n\t * of some set of unreachable objects, usually a commit that\n\t * got dropped.\n\t *\n\t * Such starting points are more interesting than some random\n\t * set of unreachable objects, so we show them even if the user\n\t * hasn't asked for _all_ unreachable objects. If you have\n\t * deleted a branch by mistake, this is a prime candidate to\n\t * start looking at, for example.\n\t */\n\tif (!obj->used) {\n\t\tif (show_dangling)\n\t\t\tprintf(\"dangling %s %s\\n\", printable_type(obj),\n\t\t\t       describe_object(obj));\n\t\tif (write_lost_and_found) {\n\t\t\tchar *filename = git_pathdup(\"lost-found/%s/%s\",\n\t\t\t\tobj->type == OBJ_COMMIT ? \"commit\" : \"other\",\n\t\t\t\tdescribe_object(obj));\n\t\t\tFILE *f;\n\n\t\t\tif (safe_create_leading_directories_const(filename)) {\n\t\t\t\terror(\"Could not create lost-found\");\n\t\t\t\tfree(filename);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tf = xfopen(filename, \"w\");\n\t\t\tif (obj->type == OBJ_BLOB) {\n\t\t\t\tif (stream_blob_to_fd(fileno(f), &obj->oid, NULL, 1))\n\t\t\t\t\tdie_errno(\"Could not write '%s'\", filename);\n\t\t\t} else\n\t\t\t\tfprintf(f, \"%s\\n\", describe_object(obj));\n\t\t\tif (fclose(f))\n\t\t\t\tdie_errno(\"Could not finish '%s'\",\n\t\t\t\t\t  filename);\n\t\t\tfree(filename);\n\t\t}\n\t\treturn;\n\t}\n\n\t/*\n\t * Otherwise? It's there, it's unreachable, and some other unreachable\n\t * object points to it. Ignore it - it's not interesting, and we showed\n\t * all the interesting cases above.\n\t */\n}\n\nstatic void check_object(struct object *obj)\n{\n\tif (verbose)\n\t\tfprintf(stderr, \"Checking %s\\n\", describe_object(obj));\n\n\tif (obj->flags & REACHABLE)\n\t\tcheck_reachable_object(obj);\n\telse\n\t\tcheck_unreachable_object(obj);\n}\n\nstatic void check_connectivity(void)\n{\n\tint i, max;\n\n\t/* Traverse the pending reachable objects */\n\ttraverse_reachable();\n\n\t/* Look up all the requirements, warn about missing objects.. */\n\tmax = get_max_object_index();\n\tif (verbose)\n\t\tfprintf(stderr, \"Checking connectivity (%d objects)\\n\", max);\n\n\tfor (i = 0; i < max; i++) {\n\t\tstruct object *obj = get_indexed_object(i);\n\n\t\tif (obj)\n\t\t\tcheck_object(obj);\n\t}\n}\n\nstatic int fsck_obj(struct object *obj)\n{\n\tif (obj->flags & SEEN)\n\t\treturn 0;\n\tobj->flags |= SEEN;\n\n\tif (verbose)\n\t\tfprintf(stderr, \"Checking %s %s\\n\",\n\t\t\tprintable_type(obj), describe_object(obj));\n\n\tif (fsck_walk(obj, NULL, &fsck_obj_options))\n\t\tobjerror(obj, \"broken links\");\n\tif (fsck_object(obj, NULL, 0, &fsck_obj_options))\n\t\treturn -1;\n\n\tif (obj->type == OBJ_TREE) {\n\t\tstruct tree *item = (struct tree *) obj;\n\n\t\tfree_tree_buffer(item);\n\t}\n\n\tif (obj->type == OBJ_COMMIT) {\n\t\tstruct commit *commit = (struct commit *) obj;\n\n\t\tfree_commit_buffer(commit);\n\n\t\tif (!commit->parents && show_root)\n\t\t\tprintf(\"root %s\\n\", describe_object(&commit->object));\n\t}\n\n\tif (obj->type == OBJ_TAG) {\n\t\tstruct tag *tag = (struct tag *) obj;\n\n\t\tif (show_tags && tag->tagged) {\n\t\t\tprintf(\"tagged %s %s\", printable_type(tag->tagged),\n\t\t\t\tdescribe_object(tag->tagged));\n\t\t\tprintf(\" (%s) in %s\\n\", tag->tag,\n\t\t\t\tdescribe_object(&tag->object));\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int fsck_obj_buffer(const struct object_id *oid, enum object_type type,\n\t\t\t   unsigned long size, void *buffer, int *eaten)\n{\n\t/*\n\t * Note, buffer may be NULL if type is OBJ_BLOB. See\n\t * verify_packfile(), data_valid variable for details.\n\t */\n\tstruct object *obj;\n\tobj = parse_object_buffer(oid, type, size, buffer, eaten);\n\tif (!obj) {\n\t\terrors_found |= ERROR_OBJECT;\n\t\treturn error(\"%s: object corrupt or missing\", oid_to_hex(oid));\n\t}\n\tobj->flags = HAS_OBJ;\n\treturn fsck_obj(obj);\n}\n\nstatic int default_refs;\n\nstatic void fsck_handle_reflog_oid(const char *refname, struct object_id *oid,\n\ttimestamp_t timestamp)\n{\n\tstruct object *obj;\n\n\tif (!is_null_oid(oid)) {\n\t\tobj = lookup_object(oid->hash);\n\t\tif (obj && (obj->flags & HAS_OBJ)) {\n\t\t\tif (timestamp && name_objects)\n\t\t\t\tadd_decoration(fsck_walk_options.object_names,\n\t\t\t\t\tobj,\n\t\t\t\t\txstrfmt(\"%s@{%\"PRItime\"}\", refname, timestamp));\n\t\t\tobj->used = 1;\n\t\t\tmark_object_reachable(obj);\n\t\t} else {\n\t\t\terror(\"%s: invalid reflog entry %s\", refname, oid_to_hex(oid));\n\t\t\terrors_found |= ERROR_REACHABLE;\n\t\t}\n\t}\n}\n\nstatic int fsck_handle_reflog_ent(struct object_id *ooid, struct object_id *noid,\n\t\tconst char *email, timestamp_t timestamp, int tz,\n\t\tconst char *message, void *cb_data)\n{\n\tconst char *refname = cb_data;\n\n\tif (verbose)\n\t\tfprintf(stderr, \"Checking reflog %s->%s\\n\",\n\t\t\toid_to_hex(ooid), oid_to_hex(noid));\n\n\tfsck_handle_reflog_oid(refname, ooid, 0);\n\tfsck_handle_reflog_oid(refname, noid, timestamp);\n\treturn 0;\n}\n\nstatic int fsck_handle_reflog(const char *logname, const struct object_id *oid,\n\t\t\t      int flag, void *cb_data)\n{\n\tfor_each_reflog_ent(logname, fsck_handle_reflog_ent, (void *)logname);\n\treturn 0;\n}\n\nstatic int fsck_handle_ref(const char *refname, const struct object_id *oid,\n\t\t\t   int flag, void *cb_data)\n{\n\tstruct object *obj;\n\n\tobj = parse_object(oid);\n\tif (!obj) {\n\t\terror(\"%s: invalid sha1 pointer %s\", refname, oid_to_hex(oid));\n\t\terrors_found |= ERROR_REACHABLE;\n\t\t/* We'll continue with the rest despite the error.. */\n\t\treturn 0;\n\t}\n\tif (obj->type != OBJ_COMMIT && is_branch(refname)) {\n\t\terror(\"%s: not a commit\", refname);\n\t\terrors_found |= ERROR_REFS;\n\t}\n\tdefault_refs++;\n\tobj->used = 1;\n\tif (name_objects)\n\t\tadd_decoration(fsck_walk_options.object_names,\n\t\t\tobj, xstrdup(refname));\n\tmark_object_reachable(obj);\n\n\treturn 0;\n}\n\nstatic void get_default_heads(void)\n{\n\tif (head_points_at && !is_null_oid(&head_oid))\n\t\tfsck_handle_ref(\"HEAD\", &head_oid, 0, NULL);\n\tfor_each_rawref(fsck_handle_ref, NULL);\n\tif (include_reflogs)\n\t\tfor_each_reflog(fsck_handle_reflog, NULL);\n\n\t/*\n\t * Not having any default heads isn't really fatal, but\n\t * it does mean that \"--unreachable\" no longer makes any\n\t * sense (since in this case everything will obviously\n\t * be unreachable by definition.\n\t *\n\t * Showing dangling objects is valid, though (as those\n\t * dangling objects are likely lost heads).\n\t *\n\t * So we just print a warning about it, and clear the\n\t * \"show_unreachable\" flag.\n\t */\n\tif (!default_refs) {\n\t\tfprintf(stderr, \"notice: No default references\\n\");\n\t\tshow_unreachable = 0;\n\t}\n}\n\nstatic struct object *parse_loose_object(const struct object_id *oid,\n\t\t\t\t\t const char *path)\n{\n\tstruct object *obj;\n\tvoid *contents;\n\tenum object_type type;\n\tunsigned long size;\n\tint eaten;\n\n\tif (read_loose_object(path, oid->hash, &type, &size, &contents) < 0)\n\t\treturn NULL;\n\n\tif (!contents && type != OBJ_BLOB)\n\t\tdie(\"BUG: read_loose_object streamed a non-blob\");\n\n\tobj = parse_object_buffer(oid, type, size, contents, &eaten);\n\n\tif (!eaten)\n\t\tfree(contents);\n\treturn obj;\n}\n\nstatic int fsck_loose(const struct object_id *oid, const char *path, void *data)\n{\n\tstruct object *obj = parse_loose_object(oid, path);\n\n\tif (!obj) {\n\t\terrors_found |= ERROR_OBJECT;\n\t\terror(\"%s: object corrupt or missing: %s\",\n\t\t      oid_to_hex(oid), path);\n\t\treturn 0; /* keep checking other objects */\n\t}\n\n\tobj->flags = HAS_OBJ;\n\tif (fsck_obj(obj))\n\t\terrors_found |= ERROR_OBJECT;\n\treturn 0;\n}\n\nstatic int fsck_cruft(const char *basename, const char *path, void *data)\n{\n\tif (!starts_with(basename, \"tmp_obj_\"))\n\t\tfprintf(stderr, \"bad sha1 file: %s\\n\", path);\n\treturn 0;\n}\n\nstatic int fsck_subdir(unsigned int nr, const char *path, void *progress)\n{\n\tdisplay_progress(progress, nr + 1);\n\treturn 0;\n}\n\nstatic void fsck_object_dir(const char *path)\n{\n\tstruct progress *progress = NULL;\n\n\tif (verbose)\n\t\tfprintf(stderr, \"Checking object directory\\n\");\n\n\tif (show_progress)\n\t\tprogress = start_progress(_(\"Checking object directories\"), 256);\n\n\tfor_each_loose_file_in_objdir(path, fsck_loose, fsck_cruft, fsck_subdir,\n\t\t\t\t      progress);\n\tdisplay_progress(progress, 256);\n\tstop_progress(&progress);\n}\n\nstatic int fsck_head_link(void)\n{\n\tint null_is_error = 0;\n\n\tif (verbose)\n\t\tfprintf(stderr, \"Checking HEAD link\\n\");\n\n\thead_points_at = resolve_ref_unsafe(\"HEAD\", 0, head_oid.hash, NULL);\n\tif (!head_points_at) {\n\t\terrors_found |= ERROR_REFS;\n\t\treturn error(\"Invalid HEAD\");\n\t}\n\tif (!strcmp(head_points_at, \"HEAD\"))\n\t\t/* detached HEAD */\n\t\tnull_is_error = 1;\n\telse if (!starts_with(head_points_at, \"refs/heads/\")) {\n\t\terrors_found |= ERROR_REFS;\n\t\treturn error(\"HEAD points to something strange (%s)\",\n\t\t\t     head_points_at);\n\t}\n\tif (is_null_oid(&head_oid)) {\n\t\tif (null_is_error) {\n\t\t\terrors_found |= ERROR_REFS;\n\t\t\treturn error(\"HEAD: detached HEAD points at nothing\");\n\t\t}\n\t\tfprintf(stderr, \"notice: HEAD points to an unborn branch (%s)\\n\",\n\t\t\thead_points_at + 11);\n\t}\n\treturn 0;\n}\n\nstatic int fsck_cache_tree(struct cache_tree *it)\n{\n\tint i;\n\tint err = 0;\n\n\tif (verbose)\n\t\tfprintf(stderr, \"Checking cache tree\\n\");\n\n\tif (0 <= it->entry_count) {\n\t\tstruct object *obj = parse_object(&it->oid);\n\t\tif (!obj) {\n\t\t\terror(\"%s: invalid sha1 pointer in cache-tree\",\n\t\t\t      oid_to_hex(&it->oid));\n\t\t\terrors_found |= ERROR_REFS;\n\t\t\treturn 1;\n\t\t}\n\t\tobj->used = 1;\n\t\tif (name_objects)\n\t\t\tadd_decoration(fsck_walk_options.object_names,\n\t\t\t\tobj, xstrdup(\":\"));\n\t\tmark_object_reachable(obj);\n\t\tif (obj->type != OBJ_TREE)\n\t\t\terr |= objerror(obj, \"non-tree in cache-tree\");\n\t}\n\tfor (i = 0; i < it->subtree_nr; i++)\n\t\terr |= fsck_cache_tree(it->down[i]->cache_tree);\n\treturn err;\n}\n\nstatic void mark_object_for_connectivity(const struct object_id *oid)\n{\n\tstruct object *obj = lookup_unknown_object(oid->hash);\n\tobj->flags |= HAS_OBJ;\n}\n\nstatic int mark_loose_for_connectivity(const struct object_id *oid,\n\t\t\t\t       const char *path,\n\t\t\t\t       void *data)\n{\n\tmark_object_for_connectivity(oid);\n\treturn 0;\n}\n\nstatic int mark_packed_for_connectivity(const struct object_id *oid,\n\t\t\t\t\tstruct packed_git *pack,\n\t\t\t\t\tuint32_t pos,\n\t\t\t\t\tvoid *data)\n{\n\tmark_object_for_connectivity(oid);\n\treturn 0;\n}\n\nstatic char const * const fsck_usage[] = {\n\tN_(\"git fsck [<options>] [<object>...]\"),\n\tNULL\n};\n\nstatic struct option fsck_opts[] = {\n\tOPT__VERBOSE(&verbose, N_(\"be verbose\")),\n\tOPT_BOOL(0, \"unreachable\", &show_unreachable, N_(\"show unreachable objects\")),\n\tOPT_BOOL(0, \"dangling\", &show_dangling, N_(\"show dangling objects\")),\n\tOPT_BOOL(0, \"tags\", &show_tags, N_(\"report tags\")),\n\tOPT_BOOL(0, \"root\", &show_root, N_(\"report root nodes\")),\n\tOPT_BOOL(0, \"cache\", &keep_cache_objects, N_(\"make index objects head nodes\")),\n\tOPT_BOOL(0, \"reflogs\", &include_reflogs, N_(\"make reflogs head nodes (default)\")),\n\tOPT_BOOL(0, \"full\", &check_full, N_(\"also consider packs and alternate objects\")),\n\tOPT_BOOL(0, \"connectivity-only\", &connectivity_only, N_(\"check only connectivity\")),\n\tOPT_BOOL(0, \"strict\", &check_strict, N_(\"enable more strict checking\")),\n\tOPT_BOOL(0, \"lost-found\", &write_lost_and_found,\n\t\t\t\tN_(\"write dangling objects in .git/lost-found\")),\n\tOPT_BOOL(0, \"progress\", &show_progress, N_(\"show progress\")),\n\tOPT_BOOL(0, \"name-objects\", &name_objects, N_(\"show verbose names for reachable objects\")),\n\tOPT_END(),\n};\n\nint cmd_fsck(int argc, const char **argv, const char *prefix)\n{\n\tint i, heads;\n\tstruct alternate_object_database *alt;\n\n\terrors_found = 0;\n\tcheck_replace_refs = 0;\n\n\targc = parse_options(argc, argv, prefix, fsck_opts, fsck_usage, 0);\n\n\tfsck_walk_options.walk = mark_object;\n\tfsck_obj_options.walk = mark_used;\n\tfsck_obj_options.error_func = fsck_error_func;\n\tif (check_strict)\n\t\tfsck_obj_options.strict = 1;\n\n\tif (show_progress == -1)\n\t\tshow_progress = isatty(2);\n\tif (verbose)\n\t\tshow_progress = 0;\n\n\tif (write_lost_and_found) {\n\t\tcheck_full = 1;\n\t\tinclude_reflogs = 0;\n\t}\n\n\tif (name_objects)\n\t\tfsck_walk_options.object_names =\n\t\t\txcalloc(1, sizeof(struct decoration));\n\n\tgit_config(fsck_config, NULL);\n\n\tfsck_head_link();\n\tif (connectivity_only) {\n\t\tfor_each_loose_object(mark_loose_for_connectivity, NULL, 0);\n\t\tfor_each_packed_object(mark_packed_for_connectivity, NULL, 0);\n\t} else {\n\t\tfsck_object_dir(get_object_directory());\n\n\t\tprepare_alt_odb();\n\t\tfor (alt = alt_odb_list; alt; alt = alt->next)\n\t\t\tfsck_object_dir(alt->path);\n\n\t\tif (check_full) {\n\t\t\tstruct packed_git *p;\n\t\t\tuint32_t total = 0, count = 0;\n\t\t\tstruct progress *progress = NULL;\n\n\t\t\tprepare_packed_git();\n\n\t\t\tif (show_progress) {\n\t\t\t\tfor (p = packed_git; p; p = p->next) {\n\t\t\t\t\tif (open_pack_index(p))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\ttotal += p->num_objects;\n\t\t\t\t}\n\n\t\t\t\tprogress = start_progress(_(\"Checking objects\"), total);\n\t\t\t}\n\t\t\tfor (p = packed_git; p; p = p->next) {\n\t\t\t\t/* verify gives error messages itself */\n\t\t\t\tif (verify_pack(p, fsck_obj_buffer,\n\t\t\t\t\t\tprogress, count))\n\t\t\t\t\terrors_found |= ERROR_PACK;\n\t\t\t\tcount += p->num_objects;\n\t\t\t}\n\t\t\tstop_progress(&progress);\n\t\t}\n\t}\n\n\theads = 0;\n\tfor (i = 0; i < argc; i++) {\n\t\tconst char *arg = argv[i];\n\t\tunsigned char sha1[20];\n\t\tif (!get_sha1(arg, sha1)) {\n\t\t\tstruct object *obj = lookup_object(sha1);\n\n\t\t\tif (!obj || !(obj->flags & HAS_OBJ)) {\n\t\t\t\terror(\"%s: object missing\", sha1_to_hex(sha1));\n\t\t\t\terrors_found |= ERROR_OBJECT;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tobj->used = 1;\n\t\t\tif (name_objects)\n\t\t\t\tadd_decoration(fsck_walk_options.object_names,\n\t\t\t\t\tobj, xstrdup(arg));\n\t\t\tmark_object_reachable(obj);\n\t\t\theads++;\n\t\t\tcontinue;\n\t\t}\n\t\terror(\"invalid parameter: expected sha1, got '%s'\", arg);\n\t\terrors_found |= ERROR_OBJECT;\n\t}\n\n\t/*\n\t * If we've not been given any explicit head information, do the\n\t * default ones from .git/refs. We also consider the index file\n\t * in this case (ie this implies --cache).\n\t */\n\tif (!argc) {\n\t\tget_default_heads();\n\t\tkeep_cache_objects = 1;\n\t}\n\n\tif (keep_cache_objects) {\n\t\tverify_index_checksum = 1;\n\t\tread_cache();\n\t\tfor (i = 0; i < active_nr; i++) {\n\t\t\tunsigned int mode;\n\t\t\tstruct blob *blob;\n\t\t\tstruct object *obj;\n\n\t\t\tmode = active_cache[i]->ce_mode;\n\t\t\tif (S_ISGITLINK(mode))\n\t\t\t\tcontinue;\n\t\t\tblob = lookup_blob(&active_cache[i]->oid);\n\t\t\tif (!blob)\n\t\t\t\tcontinue;\n\t\t\tobj = &blob->object;\n\t\t\tobj->used = 1;\n\t\t\tif (name_objects)\n\t\t\t\tadd_decoration(fsck_walk_options.object_names,\n\t\t\t\t\tobj,\n\t\t\t\t\txstrfmt(\":%s\", active_cache[i]->name));\n\t\t\tmark_object_reachable(obj);\n\t\t}\n\t\tif (active_cache_tree)\n\t\t\tfsck_cache_tree(active_cache_tree);\n\t}\n\n\tcheck_connectivity();\n\treturn errors_found;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0031439fc4a0e9b0cefad9ff70de976054c86d44",
  "sha1_ok": true,
  "size": 20089
}
