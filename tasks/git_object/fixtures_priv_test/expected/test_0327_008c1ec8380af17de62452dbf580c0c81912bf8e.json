{
  "content": {
    "base64": "LyoKICogQnVpbHRpbiAiZ2l0IGNvbW1pdCIKICoKICogQ29weXJpZ2h0IChjKSAyMDA3IEtyaXN0aWFuIEjDuGdzYmVyZyA8a3JoQHJlZGhhdC5jb20+CiAqIEJhc2VkIG9uIGdpdC1jb21taXQuc2ggYnkgSnVuaW8gQyBIYW1hbm8gYW5kIExpbnVzIFRvcnZhbGRzCiAqLwoKI2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJjYWNoZS10cmVlLmgiCiNpbmNsdWRlICJjb2xvci5oIgojaW5jbHVkZSAiZGlyLmgiCiNpbmNsdWRlICJidWlsdGluLmgiCiNpbmNsdWRlICJkaWZmLmgiCiNpbmNsdWRlICJkaWZmY29yZS5oIgojaW5jbHVkZSAiY29tbWl0LmgiCiNpbmNsdWRlICJyZXZpc2lvbi5oIgojaW5jbHVkZSAid3Qtc3RhdHVzLmgiCiNpbmNsdWRlICJydW4tY29tbWFuZC5oIgojaW5jbHVkZSAicmVmcy5oIgojaW5jbHVkZSAibG9nLXRyZWUuaCIKI2luY2x1ZGUgInN0cmJ1Zi5oIgojaW5jbHVkZSAidXRmOC5oIgojaW5jbHVkZSAicGFyc2Utb3B0aW9ucy5oIgojaW5jbHVkZSAic3RyaW5nLWxpc3QuaCIKI2luY2x1ZGUgInJlcmVyZS5oIgojaW5jbHVkZSAidW5wYWNrLXRyZWVzLmgiCiNpbmNsdWRlICJxdW90ZS5oIgojaW5jbHVkZSAic3VibW9kdWxlLmgiCgpzdGF0aWMgY29uc3QgY2hhciAqIGNvbnN0IGJ1aWx0aW5fY29tbWl0X3VzYWdlW10gPSB7CgkiZ2l0IGNvbW1pdCBbb3B0aW9uc10gWy0tXSA8ZmlsZXBhdHRlcm4+Li4uIiwKCU5VTEwKfTsKCnN0YXRpYyBjb25zdCBjaGFyICogY29uc3QgYnVpbHRpbl9zdGF0dXNfdXNhZ2VbXSA9IHsKCSJnaXQgc3RhdHVzIFtvcHRpb25zXSBbLS1dIDxmaWxlcGF0dGVybj4uLi4iLAoJTlVMTAp9OwoKc3RhdGljIGNvbnN0IGNoYXIgaW1wbGljaXRfaWRlbnRfYWR2aWNlW10gPQpOXygiWW91ciBuYW1lIGFuZCBlbWFpbCBhZGRyZXNzIHdlcmUgY29uZmlndXJlZCBhdXRvbWF0aWNhbGx5IGJhc2VkXG4iCiJvbiB5b3VyIHVzZXJuYW1lIGFuZCBob3N0bmFtZS4gUGxlYXNlIGNoZWNrIHRoYXQgdGhleSBhcmUgYWNjdXJhdGUuXG4iCiJZb3UgY2FuIHN1cHByZXNzIHRoaXMgbWVzc2FnZSBieSBzZXR0aW5nIHRoZW0gZXhwbGljaXRseTpcbiIKIlxuIgoiICAgIGdpdCBjb25maWcgLS1nbG9iYWwgdXNlci5uYW1lIFwiWW91ciBOYW1lXCJcbiIKIiAgICBnaXQgY29uZmlnIC0tZ2xvYmFsIHVzZXIuZW1haWwgeW91QGV4YW1wbGUuY29tXG4iCiJcbiIKIkFmdGVyIGRvaW5nIHRoaXMsIHlvdSBtYXkgZml4IHRoZSBpZGVudGl0eSB1c2VkIGZvciB0aGlzIGNvbW1pdCB3aXRoOlxuIgoiXG4iCiIgICAgZ2l0IGNvbW1pdCAtLWFtZW5kIC0tcmVzZXQtYXV0aG9yXG4iKTsKCnN0YXRpYyBjb25zdCBjaGFyIGVtcHR5X2FtZW5kX2FkdmljZVtdID0KTl8oIllvdSBhc2tlZCB0byBhbWVuZCB0aGUgbW9zdCByZWNlbnQgY29tbWl0LCBidXQgZG9pbmcgc28gd291bGQgbWFrZVxuIgoiaXQgZW1wdHkuIFlvdSBjYW4gcmVwZWF0IHlvdXIgY29tbWFuZCB3aXRoIC0tYWxsb3ctZW1wdHksIG9yIHlvdSBjYW5cbiIKInJlbW92ZSB0aGUgY29tbWl0IGVudGlyZWx5IHdpdGggXCJnaXQgcmVzZXQgSEVBRF5cIi5cbiIpOwoKc3RhdGljIGNvbnN0IGNoYXIgZW1wdHlfY2hlcnJ5X3BpY2tfYWR2aWNlW10gPQpOXygiVGhlIHByZXZpb3VzIGNoZXJyeS1waWNrIGlzIG5vdyBlbXB0eSwgcG9zc2libHkgZHVlIHRvIGNvbmZsaWN0IHJlc29sdXRpb24uXG4iCiJJZiB5b3Ugd2lzaCB0byBjb21taXQgaXQgYW55d2F5LCB1c2U6XG4iCiJcbiIKIiAgICBnaXQgY29tbWl0IC0tYWxsb3ctZW1wdHlcbiIKIlxuIgoiT3RoZXJ3aXNlLCBwbGVhc2UgdXNlICdnaXQgcmVzZXQnXG4iKTsKCnN0YXRpYyB1bnNpZ25lZCBjaGFyIGhlYWRfc2hhMVsyMF07CgpzdGF0aWMgY29uc3QgY2hhciAqdXNlX21lc3NhZ2VfYnVmZmVyOwpzdGF0aWMgY29uc3QgY2hhciBjb21taXRfZWRpdG1zZ1tdID0gIkNPTU1JVF9FRElUTVNHIjsKc3RhdGljIHN0cnVjdCBsb2NrX2ZpbGUgaW5kZXhfbG9jazsgLyogcmVhbCBpbmRleCAqLwpzdGF0aWMgc3RydWN0IGxvY2tfZmlsZSBmYWxzZV9sb2NrOyAvKiB1c2VkIG9ubHkgZm9yIHBhcnRpYWwgY29tbWl0cyAqLwpzdGF0aWMgZW51bSB7CglDT01NSVRfQVNfSVMgPSAxLAoJQ09NTUlUX05PUk1BTCwKCUNPTU1JVF9QQVJUSUFMCn0gY29tbWl0X3N0eWxlOwoKc3RhdGljIGNvbnN0IGNoYXIgKmxvZ2ZpbGUsICpmb3JjZV9hdXRob3I7CnN0YXRpYyBjb25zdCBjaGFyICp0ZW1wbGF0ZV9maWxlOwovKgogKiBUaGUgX21lc3NhZ2UgdmFyaWFibGVzIGFyZSBjb21taXQgbmFtZXMgZnJvbSB3aGljaCB0byB0YWtlCiAqIHRoZSBjb21taXQgbWVzc2FnZSBhbmQvb3IgYXV0aG9yc2hpcC4KICovCnN0YXRpYyBjb25zdCBjaGFyICphdXRob3JfbWVzc2FnZSwgKmF1dGhvcl9tZXNzYWdlX2J1ZmZlcjsKc3RhdGljIGNoYXIgKmVkaXRfbWVzc2FnZSwgKnVzZV9tZXNzYWdlOwpzdGF0aWMgY2hhciAqZml4dXBfbWVzc2FnZSwgKnNxdWFzaF9tZXNzYWdlOwpzdGF0aWMgaW50IGFsbCwgZWRpdF9mbGFnLCBhbHNvLCBpbnRlcmFjdGl2ZSwgcGF0Y2hfaW50ZXJhY3RpdmUsIG9ubHksIGFtZW5kLCBzaWdub2ZmOwpzdGF0aWMgaW50IHF1aWV0LCB2ZXJib3NlLCBub192ZXJpZnksIGFsbG93X2VtcHR5LCBkcnlfcnVuLCByZW5ld19hdXRob3JzaGlwOwpzdGF0aWMgaW50IG5vX3Bvc3RfcmV3cml0ZSwgYWxsb3dfZW1wdHlfbWVzc2FnZTsKc3RhdGljIGNoYXIgKnVudHJhY2tlZF9maWxlc19hcmcsICpmb3JjZV9kYXRlLCAqaWdub3JlX3N1Ym1vZHVsZV9hcmc7Ci8qCiAqIFRoZSBkZWZhdWx0IGNvbW1pdCBtZXNzYWdlIGNsZWFudXAgbW9kZSB3aWxsIHJlbW92ZSB0aGUgbGluZXMKICogYmVnaW5uaW5nIHdpdGggIyAoc2hlbGwgY29tbWVudHMpIGFuZCBsZWFkaW5nIGFuZCB0cmFpbGluZwogKiB3aGl0ZXNwYWNlcyAoZW1wdHkgbGluZXMgb3IgY29udGFpbmluZyBvbmx5IHdoaXRlc3BhY2VzKQogKiBpZiBlZGl0b3IgaXMgdXNlZCwgYW5kIG9ubHkgdGhlIHdoaXRlc3BhY2VzIGlmIHRoZSBtZXNzYWdlCiAqIGlzIHNwZWNpZmllZCBleHBsaWNpdGx5LgogKi8Kc3RhdGljIGVudW0gewoJQ0xFQU5VUF9TUEFDRSwKCUNMRUFOVVBfTk9ORSwKCUNMRUFOVVBfQUxMCn0gY2xlYW51cF9tb2RlOwpzdGF0aWMgY2hhciAqY2xlYW51cF9hcmc7CgpzdGF0aWMgZW51bSBjb21taXRfd2hlbmNlIHdoZW5jZTsKc3RhdGljIGludCB1c2VfZWRpdG9yID0gMSwgaW5pdGlhbF9jb21taXQsIGluY2x1ZGVfc3RhdHVzID0gMTsKc3RhdGljIGludCBzaG93X2lnbm9yZWRfaW5fc3RhdHVzOwpzdGF0aWMgY29uc3QgY2hhciAqb25seV9pbmNsdWRlX2Fzc3VtZWQ7CnN0YXRpYyBzdHJ1Y3Qgc3RyYnVmIG1lc3NhZ2U7CgpzdGF0aWMgaW50IG51bGxfdGVybWluYXRpb247CnN0YXRpYyBlbnVtIHsKCVNUQVRVU19GT1JNQVRfTE9ORywKCVNUQVRVU19GT1JNQVRfU0hPUlQsCglTVEFUVVNfRk9STUFUX1BPUkNFTEFJTgp9IHN0YXR1c19mb3JtYXQgPSBTVEFUVVNfRk9STUFUX0xPTkc7CnN0YXRpYyBpbnQgc3RhdHVzX3Nob3dfYnJhbmNoOwoKc3RhdGljIGludCBvcHRfcGFyc2VfbShjb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHQsIGNvbnN0IGNoYXIgKmFyZywgaW50IHVuc2V0KQp7CglzdHJ1Y3Qgc3RyYnVmICpidWYgPSBvcHQtPnZhbHVlOwoJaWYgKHVuc2V0KQoJCXN0cmJ1Zl9zZXRsZW4oYnVmLCAwKTsKCWVsc2UgewoJCXN0cmJ1Zl9hZGRzdHIoYnVmLCBhcmcpOwoJCXN0cmJ1Zl9hZGRzdHIoYnVmLCAiXG5cbiIpOwoJfQoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBzdHJ1Y3Qgb3B0aW9uIGJ1aWx0aW5fY29tbWl0X29wdGlvbnNbXSA9IHsKCU9QVF9fUVVJRVQoJnF1aWV0LCAic3VwcHJlc3Mgc3VtbWFyeSBhZnRlciBzdWNjZXNzZnVsIGNvbW1pdCIpLAoJT1BUX19WRVJCT1NFKCZ2ZXJib3NlLCAic2hvdyBkaWZmIGluIGNvbW1pdCBtZXNzYWdlIHRlbXBsYXRlIiksCgoJT1BUX0dST1VQKCJDb21taXQgbWVzc2FnZSBvcHRpb25zIiksCglPUFRfRklMRU5BTUUoJ0YnLCAiZmlsZSIsICZsb2dmaWxlLCAicmVhZCBtZXNzYWdlIGZyb20gZmlsZSIpLAoJT1BUX1NUUklORygwLCAiYXV0aG9yIiwgJmZvcmNlX2F1dGhvciwgImF1dGhvciIsICJvdmVycmlkZSBhdXRob3IgZm9yIGNvbW1pdCIpLAoJT1BUX1NUUklORygwLCAiZGF0ZSIsICZmb3JjZV9kYXRlLCAiZGF0ZSIsICJvdmVycmlkZSBkYXRlIGZvciBjb21taXQiKSwKCU9QVF9DQUxMQkFDSygnbScsICJtZXNzYWdlIiwgJm1lc3NhZ2UsICJtZXNzYWdlIiwgImNvbW1pdCBtZXNzYWdlIiwgb3B0X3BhcnNlX20pLAoJT1BUX1NUUklORygnYycsICJyZWVkaXQtbWVzc2FnZSIsICZlZGl0X21lc3NhZ2UsICJjb21taXQiLCAicmV1c2UgYW5kIGVkaXQgbWVzc2FnZSBmcm9tIHNwZWNpZmllZCBjb21taXQiKSwKCU9QVF9TVFJJTkcoJ0MnLCAicmV1c2UtbWVzc2FnZSIsICZ1c2VfbWVzc2FnZSwgImNvbW1pdCIsICJyZXVzZSBtZXNzYWdlIGZyb20gc3BlY2lmaWVkIGNvbW1pdCIpLAoJT1BUX1NUUklORygwLCAiZml4dXAiLCAmZml4dXBfbWVzc2FnZSwgImNvbW1pdCIsICJ1c2UgYXV0b3NxdWFzaCBmb3JtYXR0ZWQgbWVzc2FnZSB0byBmaXh1cCBzcGVjaWZpZWQgY29tbWl0IiksCglPUFRfU1RSSU5HKDAsICJzcXVhc2giLCAmc3F1YXNoX21lc3NhZ2UsICJjb21taXQiLCAidXNlIGF1dG9zcXVhc2ggZm9ybWF0dGVkIG1lc3NhZ2UgdG8gc3F1YXNoIHNwZWNpZmllZCBjb21taXQiKSwKCU9QVF9CT09MRUFOKDAsICJyZXNldC1hdXRob3IiLCAmcmVuZXdfYXV0aG9yc2hpcCwgInRoZSBjb21taXQgaXMgYXV0aG9yZWQgYnkgbWUgbm93ICh1c2VkIHdpdGggLUMtYy8tLWFtZW5kKSIpLAoJT1BUX0JPT0xFQU4oJ3MnLCAic2lnbm9mZiIsICZzaWdub2ZmLCAiYWRkIFNpZ25lZC1vZmYtYnk6IiksCglPUFRfRklMRU5BTUUoJ3QnLCAidGVtcGxhdGUiLCAmdGVtcGxhdGVfZmlsZSwgInVzZSBzcGVjaWZpZWQgdGVtcGxhdGUgZmlsZSIpLAoJT1BUX0JPT0xFQU4oJ2UnLCAiZWRpdCIsICZlZGl0X2ZsYWcsICJmb3JjZSBlZGl0IG9mIGNvbW1pdCIpLAoJT1BUX1NUUklORygwLCAiY2xlYW51cCIsICZjbGVhbnVwX2FyZywgImRlZmF1bHQiLCAiaG93IHRvIHN0cmlwIHNwYWNlcyBhbmQgI2NvbW1lbnRzIGZyb20gbWVzc2FnZSIpLAoJT1BUX0JPT0xFQU4oMCwgInN0YXR1cyIsICZpbmNsdWRlX3N0YXR1cywgImluY2x1ZGUgc3RhdHVzIGluIGNvbW1pdCBtZXNzYWdlIHRlbXBsYXRlIiksCgkvKiBlbmQgY29tbWl0IG1lc3NhZ2Ugb3B0aW9ucyAqLwoKCU9QVF9HUk9VUCgiQ29tbWl0IGNvbnRlbnRzIG9wdGlvbnMiKSwKCU9QVF9CT09MRUFOKCdhJywgImFsbCIsICZhbGwsICJjb21taXQgYWxsIGNoYW5nZWQgZmlsZXMiKSwKCU9QVF9CT09MRUFOKCdpJywgImluY2x1ZGUiLCAmYWxzbywgImFkZCBzcGVjaWZpZWQgZmlsZXMgdG8gaW5kZXggZm9yIGNvbW1pdCIpLAoJT1BUX0JPT0xFQU4oMCwgImludGVyYWN0aXZlIiwgJmludGVyYWN0aXZlLCAiaW50ZXJhY3RpdmVseSBhZGQgZmlsZXMiKSwKCU9QVF9CT09MRUFOKCdwJywgInBhdGNoIiwgJnBhdGNoX2ludGVyYWN0aXZlLCAiaW50ZXJhY3RpdmVseSBhZGQgY2hhbmdlcyIpLAoJT1BUX0JPT0xFQU4oJ28nLCAib25seSIsICZvbmx5LCAiY29tbWl0IG9ubHkgc3BlY2lmaWVkIGZpbGVzIiksCglPUFRfQk9PTEVBTignbicsICJuby12ZXJpZnkiLCAmbm9fdmVyaWZ5LCAiYnlwYXNzIHByZS1jb21taXQgaG9vayIpLAoJT1BUX0JPT0xFQU4oMCwgImRyeS1ydW4iLCAmZHJ5X3J1biwgInNob3cgd2hhdCB3b3VsZCBiZSBjb21taXR0ZWQiKSwKCU9QVF9TRVRfSU5UKDAsICJzaG9ydCIsICZzdGF0dXNfZm9ybWF0LCAic2hvdyBzdGF0dXMgY29uY2lzZWx5IiwKCQkgICAgU1RBVFVTX0ZPUk1BVF9TSE9SVCksCglPUFRfQk9PTEVBTigwLCAiYnJhbmNoIiwgJnN0YXR1c19zaG93X2JyYW5jaCwgInNob3cgYnJhbmNoIGluZm9ybWF0aW9uIiksCglPUFRfU0VUX0lOVCgwLCAicG9yY2VsYWluIiwgJnN0YXR1c19mb3JtYXQsCgkJICAgICJtYWNoaW5lLXJlYWRhYmxlIG91dHB1dCIsIFNUQVRVU19GT1JNQVRfUE9SQ0VMQUlOKSwKCU9QVF9CT09MRUFOKCd6JywgIm51bGwiLCAmbnVsbF90ZXJtaW5hdGlvbiwKCQkgICAgInRlcm1pbmF0ZSBlbnRyaWVzIHdpdGggTlVMIiksCglPUFRfQk9PTEVBTigwLCAiYW1lbmQiLCAmYW1lbmQsICJhbWVuZCBwcmV2aW91cyBjb21taXQiKSwKCU9QVF9CT09MRUFOKDAsICJuby1wb3N0LXJld3JpdGUiLCAmbm9fcG9zdF9yZXdyaXRlLCAiYnlwYXNzIHBvc3QtcmV3cml0ZSBob29rIiksCgl7IE9QVElPTl9TVFJJTkcsICd1JywgInVudHJhY2tlZC1maWxlcyIsICZ1bnRyYWNrZWRfZmlsZXNfYXJnLCAibW9kZSIsICJzaG93IHVudHJhY2tlZCBmaWxlcywgb3B0aW9uYWwgbW9kZXM6IGFsbCwgbm9ybWFsLCBuby4gKERlZmF1bHQ6IGFsbCkiLCBQQVJTRV9PUFRfT1BUQVJHLCBOVUxMLCAoaW50cHRyX3QpImFsbCIgfSwKCS8qIGVuZCBjb21taXQgY29udGVudHMgb3B0aW9ucyAqLwoKCXsgT1BUSU9OX0JPT0xFQU4sIDAsICJhbGxvdy1lbXB0eSIsICZhbGxvd19lbXB0eSwgTlVMTCwKCSAgIm9rIHRvIHJlY29yZCBhbiBlbXB0eSBjaGFuZ2UiLAoJICBQQVJTRV9PUFRfTk9BUkcgfCBQQVJTRV9PUFRfSElEREVOIH0sCgl7IE9QVElPTl9CT09MRUFOLCAwLCAiYWxsb3ctZW1wdHktbWVzc2FnZSIsICZhbGxvd19lbXB0eV9tZXNzYWdlLCBOVUxMLAoJICAib2sgdG8gcmVjb3JkIGEgY2hhbmdlIHdpdGggYW4gZW1wdHkgbWVzc2FnZSIsCgkgIFBBUlNFX09QVF9OT0FSRyB8IFBBUlNFX09QVF9ISURERU4gfSwKCglPUFRfRU5EKCkKfTsKCnN0YXRpYyB2b2lkIGRldGVybWluZV93aGVuY2Uoc3RydWN0IHd0X3N0YXR1cyAqcykKewoJaWYgKGZpbGVfZXhpc3RzKGdpdF9wYXRoKCJNRVJHRV9IRUFEIikpKQoJCXdoZW5jZSA9IEZST01fTUVSR0U7CgllbHNlIGlmIChmaWxlX2V4aXN0cyhnaXRfcGF0aCgiQ0hFUlJZX1BJQ0tfSEVBRCIpKSkKCQl3aGVuY2UgPSBGUk9NX0NIRVJSWV9QSUNLOwoJZWxzZQoJCXdoZW5jZSA9IEZST01fQ09NTUlUOwoJaWYgKHMpCgkJcy0+d2hlbmNlID0gd2hlbmNlOwp9CgpzdGF0aWMgY29uc3QgY2hhciAqd2hlbmNlX3Modm9pZCkKewoJY2hhciAqcyA9ICIiOwoKCXN3aXRjaCAod2hlbmNlKSB7CgljYXNlIEZST01fQ09NTUlUOgoJCWJyZWFrOwoJY2FzZSBGUk9NX01FUkdFOgoJCXMgPSAibWVyZ2UiOwoJCWJyZWFrOwoJY2FzZSBGUk9NX0NIRVJSWV9QSUNLOgoJCXMgPSAiY2hlcnJ5LXBpY2siOwoJCWJyZWFrOwoJfQoKCXJldHVybiBzOwp9CgpzdGF0aWMgdm9pZCByb2xsYmFja19pbmRleF9maWxlcyh2b2lkKQp7Cglzd2l0Y2ggKGNvbW1pdF9zdHlsZSkgewoJY2FzZSBDT01NSVRfQVNfSVM6CgkJYnJlYWs7IC8qIG5vdGhpbmcgdG8gZG8gKi8KCWNhc2UgQ09NTUlUX05PUk1BTDoKCQlyb2xsYmFja19sb2NrX2ZpbGUoJmluZGV4X2xvY2spOwoJCWJyZWFrOwoJY2FzZSBDT01NSVRfUEFSVElBTDoKCQlyb2xsYmFja19sb2NrX2ZpbGUoJmluZGV4X2xvY2spOwoJCXJvbGxiYWNrX2xvY2tfZmlsZSgmZmFsc2VfbG9jayk7CgkJYnJlYWs7Cgl9Cn0KCnN0YXRpYyBpbnQgY29tbWl0X2luZGV4X2ZpbGVzKHZvaWQpCnsKCWludCBlcnIgPSAwOwoKCXN3aXRjaCAoY29tbWl0X3N0eWxlKSB7CgljYXNlIENPTU1JVF9BU19JUzoKCQlicmVhazsgLyogbm90aGluZyB0byBkbyAqLwoJY2FzZSBDT01NSVRfTk9STUFMOgoJCWVyciA9IGNvbW1pdF9sb2NrX2ZpbGUoJmluZGV4X2xvY2spOwoJCWJyZWFrOwoJY2FzZSBDT01NSVRfUEFSVElBTDoKCQllcnIgPSBjb21taXRfbG9ja19maWxlKCZpbmRleF9sb2NrKTsKCQlyb2xsYmFja19sb2NrX2ZpbGUoJmZhbHNlX2xvY2spOwoJCWJyZWFrOwoJfQoKCXJldHVybiBlcnI7Cn0KCi8qCiAqIFRha2UgYSB1bmlvbiBvZiBwYXRocyBpbiB0aGUgaW5kZXggYW5kIHRoZSBuYW1lZCB0cmVlICh0eXBpY2FsbHksICJIRUFEIiksCiAqIGFuZCByZXR1cm4gdGhlIHBhdGhzIHRoYXQgbWF0Y2ggdGhlIGdpdmVuIHBhdHRlcm4gaW4gbGlzdC4KICovCnN0YXRpYyBpbnQgbGlzdF9wYXRocyhzdHJ1Y3Qgc3RyaW5nX2xpc3QgKmxpc3QsIGNvbnN0IGNoYXIgKndpdGhfdHJlZSwKCQkgICAgICBjb25zdCBjaGFyICpwcmVmaXgsIGNvbnN0IGNoYXIgKipwYXR0ZXJuKQp7CglpbnQgaTsKCWNoYXIgKm07CgoJZm9yIChpID0gMDsgcGF0dGVybltpXTsgaSsrKQoJCTsKCW0gPSB4Y2FsbG9jKDEsIGkpOwoKCWlmICh3aXRoX3RyZWUpCgkJb3ZlcmxheV90cmVlX29uX2NhY2hlKHdpdGhfdHJlZSwgcHJlZml4KTsKCglmb3IgKGkgPSAwOyBpIDwgYWN0aXZlX25yOyBpKyspIHsKCQlzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlID0gYWN0aXZlX2NhY2hlW2ldOwoJCXN0cnVjdCBzdHJpbmdfbGlzdF9pdGVtICppdGVtOwoKCQlpZiAoY2UtPmNlX2ZsYWdzICYgQ0VfVVBEQVRFKQoJCQljb250aW51ZTsKCQlpZiAoIW1hdGNoX3BhdGhzcGVjKHBhdHRlcm4sIGNlLT5uYW1lLCBjZV9uYW1lbGVuKGNlKSwgMCwgbSkpCgkJCWNvbnRpbnVlOwoJCWl0ZW0gPSBzdHJpbmdfbGlzdF9pbnNlcnQobGlzdCwgY2UtPm5hbWUpOwoJCWlmIChjZV9za2lwX3dvcmt0cmVlKGNlKSkKCQkJaXRlbS0+dXRpbCA9IGl0ZW07IC8qIGJldHRlciBhIHZhbGlkIHBvaW50ZXIgdGhhbiBhIGZha2Ugb25lICovCgl9CgoJcmV0dXJuIHJlcG9ydF9wYXRoX2Vycm9yKG0sIHBhdHRlcm4sIHByZWZpeCA/IHN0cmxlbihwcmVmaXgpIDogMCk7Cn0KCnN0YXRpYyB2b2lkIGFkZF9yZW1vdmVfZmlsZXMoc3RydWN0IHN0cmluZ19saXN0ICpsaXN0KQp7CglpbnQgaTsKCWZvciAoaSA9IDA7IGkgPCBsaXN0LT5ucjsgaSsrKSB7CgkJc3RydWN0IHN0YXQgc3Q7CgkJc3RydWN0IHN0cmluZ19saXN0X2l0ZW0gKnAgPSAmKGxpc3QtPml0ZW1zW2ldKTsKCgkJLyogcC0+dXRpbCBpcyBza2lwLXdvcmt0cmVlICovCgkJaWYgKHAtPnV0aWwpCgkJCWNvbnRpbnVlOwoKCQlpZiAoIWxzdGF0KHAtPnN0cmluZywgJnN0KSkgewoJCQlpZiAoYWRkX3RvX2NhY2hlKHAtPnN0cmluZywgJnN0LCAwKSkKCQkJCWRpZShfKCJ1cGRhdGluZyBmaWxlcyBmYWlsZWQiKSk7CgkJfSBlbHNlCgkJCXJlbW92ZV9maWxlX2Zyb21fY2FjaGUocC0+c3RyaW5nKTsKCX0KfQoKc3RhdGljIHZvaWQgY3JlYXRlX2Jhc2VfaW5kZXgodm9pZCkKewoJc3RydWN0IHRyZWUgKnRyZWU7CglzdHJ1Y3QgdW5wYWNrX3RyZWVzX29wdGlvbnMgb3B0czsKCXN0cnVjdCB0cmVlX2Rlc2MgdDsKCglpZiAoaW5pdGlhbF9jb21taXQpIHsKCQlkaXNjYXJkX2NhY2hlKCk7CgkJcmV0dXJuOwoJfQoKCW1lbXNldCgmb3B0cywgMCwgc2l6ZW9mKG9wdHMpKTsKCW9wdHMuaGVhZF9pZHggPSAxOwoJb3B0cy5pbmRleF9vbmx5ID0gMTsKCW9wdHMubWVyZ2UgPSAxOwoJb3B0cy5zcmNfaW5kZXggPSAmdGhlX2luZGV4OwoJb3B0cy5kc3RfaW5kZXggPSAmdGhlX2luZGV4OwoKCW9wdHMuZm4gPSBvbmV3YXlfbWVyZ2U7Cgl0cmVlID0gcGFyc2VfdHJlZV9pbmRpcmVjdChoZWFkX3NoYTEpOwoJaWYgKCF0cmVlKQoJCWRpZShfKCJmYWlsZWQgdG8gdW5wYWNrIEhFQUQgdHJlZSBvYmplY3QiKSk7CglwYXJzZV90cmVlKHRyZWUpOwoJaW5pdF90cmVlX2Rlc2MoJnQsIHRyZWUtPmJ1ZmZlciwgdHJlZS0+c2l6ZSk7CglpZiAodW5wYWNrX3RyZWVzKDEsICZ0LCAmb3B0cykpCgkJZXhpdCgxMjgpOyAvKiBXZSd2ZSBhbHJlYWR5IHJlcG9ydGVkIHRoZSBlcnJvciwgZmluaXNoIGR5aW5nICovCn0KCnN0YXRpYyB2b2lkIHJlZnJlc2hfY2FjaGVfb3JfZGllKGludCByZWZyZXNoX2ZsYWdzKQp7CgkvKgoJICogcmVmcmVzaF9mbGFncyBjb250YWlucyBSRUZSRVNIX1FVSUVULCBzbyB0aGUgb25seSBlcnJvcnMKCSAqIGFyZSBmb3IgdW5tZXJnZWQgZW50cmllcy4KCSAqLwoJaWYgKHJlZnJlc2hfY2FjaGUocmVmcmVzaF9mbGFncyB8IFJFRlJFU0hfSU5fUE9SQ0VMQUlOKSkKCQlkaWVfcmVzb2x2ZV9jb25mbGljdCgiY29tbWl0Iik7Cn0KCnN0YXRpYyBjaGFyICpwcmVwYXJlX2luZGV4KGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndiwgY29uc3QgY2hhciAqcHJlZml4LCBpbnQgaXNfc3RhdHVzKQp7CglpbnQgZmQ7CglzdHJ1Y3Qgc3RyaW5nX2xpc3QgcGFydGlhbDsKCWNvbnN0IGNoYXIgKipwYXRoc3BlYyA9IE5VTEw7CgljaGFyICpvbGRfaW5kZXhfZW52ID0gTlVMTDsKCWludCByZWZyZXNoX2ZsYWdzID0gUkVGUkVTSF9RVUlFVDsKCglpZiAoaXNfc3RhdHVzKQoJCXJlZnJlc2hfZmxhZ3MgfD0gUkVGUkVTSF9VTk1FUkdFRDsKCglpZiAoKmFyZ3YpCgkJcGF0aHNwZWMgPSBnZXRfcGF0aHNwZWMocHJlZml4LCBhcmd2KTsKCglpZiAocmVhZF9jYWNoZV9wcmVsb2FkKHBhdGhzcGVjKSA8IDApCgkJZGllKF8oImluZGV4IGZpbGUgY29ycnVwdCIpKTsKCglpZiAoaW50ZXJhY3RpdmUpIHsKCQlmZCA9IGhvbGRfbG9ja2VkX2luZGV4KCZpbmRleF9sb2NrLCAxKTsKCgkJcmVmcmVzaF9jYWNoZV9vcl9kaWUocmVmcmVzaF9mbGFncyk7CgoJCWlmICh3cml0ZV9jYWNoZShmZCwgYWN0aXZlX2NhY2hlLCBhY3RpdmVfbnIpIHx8CgkJICAgIGNsb3NlX2xvY2tfZmlsZSgmaW5kZXhfbG9jaykpCgkJCWRpZShfKCJ1bmFibGUgdG8gY3JlYXRlIHRlbXBvcmFyeSBpbmRleCIpKTsKCgkJb2xkX2luZGV4X2VudiA9IGdldGVudihJTkRFWF9FTlZJUk9OTUVOVCk7CgkJc2V0ZW52KElOREVYX0VOVklST05NRU5ULCBpbmRleF9sb2NrLmZpbGVuYW1lLCAxKTsKCgkJaWYgKGludGVyYWN0aXZlX2FkZChhcmdjLCBhcmd2LCBwcmVmaXgsIHBhdGNoX2ludGVyYWN0aXZlKSAhPSAwKQoJCQlkaWUoXygiaW50ZXJhY3RpdmUgYWRkIGZhaWxlZCIpKTsKCgkJaWYgKG9sZF9pbmRleF9lbnYgJiYgKm9sZF9pbmRleF9lbnYpCgkJCXNldGVudihJTkRFWF9FTlZJUk9OTUVOVCwgb2xkX2luZGV4X2VudiwgMSk7CgkJZWxzZQoJCQl1bnNldGVudihJTkRFWF9FTlZJUk9OTUVOVCk7CgoJCWRpc2NhcmRfY2FjaGUoKTsKCQlyZWFkX2NhY2hlX2Zyb20oaW5kZXhfbG9jay5maWxlbmFtZSk7CgoJCWNvbW1pdF9zdHlsZSA9IENPTU1JVF9OT1JNQUw7CgkJcmV0dXJuIGluZGV4X2xvY2suZmlsZW5hbWU7Cgl9CgoJLyoKCSAqIE5vbiBwYXJ0aWFsLCBub24gYXMtaXMgY29tbWl0LgoJICoKCSAqICgxKSBnZXQgdGhlIHJlYWwgaW5kZXg7CgkgKiAoMikgdXBkYXRlIHRoZV9pbmRleCBhcyBuZWNlc3Nhcnk7CgkgKiAoMykgd3JpdGUgdGhlX2luZGV4IG91dCB0byB0aGUgcmVhbCBpbmRleCAoc3RpbGwgbG9ja2VkKTsKCSAqICg0KSByZXR1cm4gdGhlIG5hbWUgb2YgdGhlIGxvY2tlZCBpbmRleCBmaWxlLgoJICoKCSAqIFRoZSBjYWxsZXIgc2hvdWxkIHJ1biBob29rcyBvbiB0aGUgbG9ja2VkIHJlYWwgaW5kZXgsIGFuZAoJICogKEEpIGlmIGFsbCBnb2VzIHdlbGwsIGNvbW1pdCB0aGUgcmVhbCBpbmRleDsKCSAqIChCKSBvbiBmYWlsdXJlLCByb2xsYmFjayB0aGUgcmVhbCBpbmRleC4KCSAqLwoJaWYgKGFsbCB8fCAoYWxzbyAmJiBwYXRoc3BlYyAmJiAqcGF0aHNwZWMpKSB7CgkJZmQgPSBob2xkX2xvY2tlZF9pbmRleCgmaW5kZXhfbG9jaywgMSk7CgkJYWRkX2ZpbGVzX3RvX2NhY2hlKGFsc28gPyBwcmVmaXggOiBOVUxMLCBwYXRoc3BlYywgMCk7CgkJcmVmcmVzaF9jYWNoZV9vcl9kaWUocmVmcmVzaF9mbGFncyk7CgkJaWYgKHdyaXRlX2NhY2hlKGZkLCBhY3RpdmVfY2FjaGUsIGFjdGl2ZV9ucikgfHwKCQkgICAgY2xvc2VfbG9ja19maWxlKCZpbmRleF9sb2NrKSkKCQkJZGllKF8oInVuYWJsZSB0byB3cml0ZSBuZXdfaW5kZXggZmlsZSIpKTsKCQljb21taXRfc3R5bGUgPSBDT01NSVRfTk9STUFMOwoJCXJldHVybiBpbmRleF9sb2NrLmZpbGVuYW1lOwoJfQoKCS8qCgkgKiBBcy1pcyBjb21taXQuCgkgKgoJICogKDEpIHJldHVybiB0aGUgbmFtZSBvZiB0aGUgcmVhbCBpbmRleCBmaWxlLgoJICoKCSAqIFRoZSBjYWxsZXIgc2hvdWxkIHJ1biBob29rcyBvbiB0aGUgcmVhbCBpbmRleCwKCSAqIGFuZCBjcmVhdGUgY29tbWl0IGZyb20gdGhlX2luZGV4LgoJICogV2Ugc3RpbGwgbmVlZCB0byByZWZyZXNoIHRoZSBpbmRleCBoZXJlLgoJICovCglpZiAoIXBhdGhzcGVjIHx8ICEqcGF0aHNwZWMpIHsKCQlmZCA9IGhvbGRfbG9ja2VkX2luZGV4KCZpbmRleF9sb2NrLCAxKTsKCQlyZWZyZXNoX2NhY2hlX29yX2RpZShyZWZyZXNoX2ZsYWdzKTsKCQlpZiAoYWN0aXZlX2NhY2hlX2NoYW5nZWQpIHsKCQkJaWYgKHdyaXRlX2NhY2hlKGZkLCBhY3RpdmVfY2FjaGUsIGFjdGl2ZV9ucikgfHwKCQkJICAgIGNvbW1pdF9sb2NrZWRfaW5kZXgoJmluZGV4X2xvY2spKQoJCQkJZGllKF8oInVuYWJsZSB0byB3cml0ZSBuZXdfaW5kZXggZmlsZSIpKTsKCQl9IGVsc2UgewoJCQlyb2xsYmFja19sb2NrX2ZpbGUoJmluZGV4X2xvY2spOwoJCX0KCQljb21taXRfc3R5bGUgPSBDT01NSVRfQVNfSVM7CgkJcmV0dXJuIGdldF9pbmRleF9maWxlKCk7Cgl9CgoJLyoKCSAqIEEgcGFydGlhbCBjb21taXQuCgkgKgoJICogKDApIGZpbmQgdGhlIHNldCBvZiBhZmZlY3RlZCBwYXRoczsKCSAqICgxKSBnZXQgbG9jayBvbiB0aGUgcmVhbCBpbmRleCBmaWxlOwoJICogKDIpIHVwZGF0ZSB0aGVfaW5kZXggd2l0aCB0aGUgZ2l2ZW4gcGF0aHM7CgkgKiAoMykgd3JpdGUgdGhlX2luZGV4IG91dCB0byB0aGUgcmVhbCBpbmRleCAoc3RpbGwgbG9ja2VkKTsKCSAqICg0KSBnZXQgbG9jayBvbiB0aGUgZmFsc2UgaW5kZXggZmlsZTsKCSAqICg1KSByZXNldCB0aGVfaW5kZXggZnJvbSBIRUFEOwoJICogKDYpIHVwZGF0ZSB0aGVfaW5kZXggdGhlIHNhbWUgd2F5IGFzICgyKTsKCSAqICg3KSB3cml0ZSB0aGVfaW5kZXggb3V0IHRvIHRoZSBmYWxzZSBpbmRleCBmaWxlOwoJICogKDgpIHJldHVybiB0aGUgbmFtZSBvZiB0aGUgZmFsc2UgaW5kZXggZmlsZSAoc3RpbGwgbG9ja2VkKTsKCSAqCgkgKiBUaGUgY2FsbGVyIHNob3VsZCBydW4gaG9va3Mgb24gdGhlIGxvY2tlZCBmYWxzZSBpbmRleCwgYW5kCgkgKiBjcmVhdGUgY29tbWl0IGZyb20gaXQuICBUaGVuCgkgKiAoQSkgaWYgYWxsIGdvZXMgd2VsbCwgY29tbWl0IHRoZSByZWFsIGluZGV4OwoJICogKEIpIG9uIGZhaWx1cmUsIHJvbGxiYWNrIHRoZSByZWFsIGluZGV4OwoJICogSW4gZWl0aGVyIGNhc2UsIHJvbGxiYWNrIHRoZSBmYWxzZSBpbmRleC4KCSAqLwoJY29tbWl0X3N0eWxlID0gQ09NTUlUX1BBUlRJQUw7CgoJaWYgKHdoZW5jZSAhPSBGUk9NX0NPTU1JVCkKCQlkaWUoXygiY2Fubm90IGRvIGEgcGFydGlhbCBjb21taXQgZHVyaW5nIGEgJXMuIiksIHdoZW5jZV9zKCkpOwoKCW1lbXNldCgmcGFydGlhbCwgMCwgc2l6ZW9mKHBhcnRpYWwpKTsKCXBhcnRpYWwuc3RyZHVwX3N0cmluZ3MgPSAxOwoJaWYgKGxpc3RfcGF0aHMoJnBhcnRpYWwsIGluaXRpYWxfY29tbWl0ID8gTlVMTCA6ICJIRUFEIiwgcHJlZml4LCBwYXRoc3BlYykpCgkJZXhpdCgxKTsKCglkaXNjYXJkX2NhY2hlKCk7CglpZiAocmVhZF9jYWNoZSgpIDwgMCkKCQlkaWUoXygiY2Fubm90IHJlYWQgdGhlIGluZGV4IikpOwoKCWZkID0gaG9sZF9sb2NrZWRfaW5kZXgoJmluZGV4X2xvY2ssIDEpOwoJYWRkX3JlbW92ZV9maWxlcygmcGFydGlhbCk7CglyZWZyZXNoX2NhY2hlKFJFRlJFU0hfUVVJRVQpOwoJaWYgKHdyaXRlX2NhY2hlKGZkLCBhY3RpdmVfY2FjaGUsIGFjdGl2ZV9ucikgfHwKCSAgICBjbG9zZV9sb2NrX2ZpbGUoJmluZGV4X2xvY2spKQoJCWRpZShfKCJ1bmFibGUgdG8gd3JpdGUgbmV3X2luZGV4IGZpbGUiKSk7CgoJZmQgPSBob2xkX2xvY2tfZmlsZV9mb3JfdXBkYXRlKCZmYWxzZV9sb2NrLAoJCQkJICAgICAgIGdpdF9wYXRoKCJuZXh0LWluZGV4LSUiUFJJdU1BWCwKCQkJCQkJKHVpbnRtYXhfdCkgZ2V0cGlkKCkpLAoJCQkJICAgICAgIExPQ0tfRElFX09OX0VSUk9SKTsKCgljcmVhdGVfYmFzZV9pbmRleCgpOwoJYWRkX3JlbW92ZV9maWxlcygmcGFydGlhbCk7CglyZWZyZXNoX2NhY2hlKFJFRlJFU0hfUVVJRVQpOwoKCWlmICh3cml0ZV9jYWNoZShmZCwgYWN0aXZlX2NhY2hlLCBhY3RpdmVfbnIpIHx8CgkgICAgY2xvc2VfbG9ja19maWxlKCZmYWxzZV9sb2NrKSkKCQlkaWUoXygidW5hYmxlIHRvIHdyaXRlIHRlbXBvcmFyeSBpbmRleCBmaWxlIikpOwoKCWRpc2NhcmRfY2FjaGUoKTsKCXJlYWRfY2FjaGVfZnJvbShmYWxzZV9sb2NrLmZpbGVuYW1lKTsKCglyZXR1cm4gZmFsc2VfbG9jay5maWxlbmFtZTsKfQoKc3RhdGljIGludCBydW5fc3RhdHVzKEZJTEUgKmZwLCBjb25zdCBjaGFyICppbmRleF9maWxlLCBjb25zdCBjaGFyICpwcmVmaXgsIGludCBub3dhcm4sCgkJICAgICAgc3RydWN0IHd0X3N0YXR1cyAqcykKewoJdW5zaWduZWQgY2hhciBzaGExWzIwXTsKCglpZiAocy0+cmVsYXRpdmVfcGF0aHMpCgkJcy0+cHJlZml4ID0gcHJlZml4OwoKCWlmIChhbWVuZCkgewoJCXMtPmFtZW5kID0gMTsKCQlzLT5yZWZlcmVuY2UgPSAiSEVBRF4xIjsKCX0KCXMtPnZlcmJvc2UgPSB2ZXJib3NlOwoJcy0+aW5kZXhfZmlsZSA9IGluZGV4X2ZpbGU7CglzLT5mcCA9IGZwOwoJcy0+bm93YXJuID0gbm93YXJuOwoJcy0+aXNfaW5pdGlhbCA9IGdldF9zaGExKHMtPnJlZmVyZW5jZSwgc2hhMSkgPyAxIDogMDsKCgl3dF9zdGF0dXNfY29sbGVjdChzKTsKCglzd2l0Y2ggKHN0YXR1c19mb3JtYXQpIHsKCWNhc2UgU1RBVFVTX0ZPUk1BVF9TSE9SVDoKCQl3dF9zaG9ydHN0YXR1c19wcmludChzLCBudWxsX3Rlcm1pbmF0aW9uLCBzdGF0dXNfc2hvd19icmFuY2gpOwoJCWJyZWFrOwoJY2FzZSBTVEFUVVNfRk9STUFUX1BPUkNFTEFJTjoKCQl3dF9wb3JjZWxhaW5fcHJpbnQocywgbnVsbF90ZXJtaW5hdGlvbik7CgkJYnJlYWs7CgljYXNlIFNUQVRVU19GT1JNQVRfTE9ORzoKCQl3dF9zdGF0dXNfcHJpbnQocyk7CgkJYnJlYWs7Cgl9CgoJcmV0dXJuIHMtPmNvbW1pdGFibGU7Cn0KCnN0YXRpYyBpbnQgaXNfYV9tZXJnZShjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExKQp7CglzdHJ1Y3QgY29tbWl0ICpjb21taXQgPSBsb29rdXBfY29tbWl0KHNoYTEpOwoJaWYgKCFjb21taXQgfHwgcGFyc2VfY29tbWl0KGNvbW1pdCkpCgkJZGllKF8oImNvdWxkIG5vdCBwYXJzZSBIRUFEIGNvbW1pdCIpKTsKCXJldHVybiAhIShjb21taXQtPnBhcmVudHMgJiYgY29tbWl0LT5wYXJlbnRzLT5uZXh0KTsKfQoKc3RhdGljIGNvbnN0IGNoYXIgc2lnbl9vZmZfaGVhZGVyW10gPSAiU2lnbmVkLW9mZi1ieTogIjsKCnN0YXRpYyB2b2lkIGRldGVybWluZV9hdXRob3JfaW5mbyhzdHJ1Y3Qgc3RyYnVmICphdXRob3JfaWRlbnQpCnsKCWNoYXIgKm5hbWUsICplbWFpbCwgKmRhdGU7CgoJbmFtZSA9IGdldGVudigiR0lUX0FVVEhPUl9OQU1FIik7CgllbWFpbCA9IGdldGVudigiR0lUX0FVVEhPUl9FTUFJTCIpOwoJZGF0ZSA9IGdldGVudigiR0lUX0FVVEhPUl9EQVRFIik7CgoJaWYgKGF1dGhvcl9tZXNzYWdlKSB7CgkJY29uc3QgY2hhciAqYSwgKmxiLCAqcmIsICplb2w7CgoJCWEgPSBzdHJzdHIoYXV0aG9yX21lc3NhZ2VfYnVmZmVyLCAiXG5hdXRob3IgIik7CgkJaWYgKCFhKQoJCQlkaWUoXygiaW52YWxpZCBjb21taXQ6ICVzIiksIGF1dGhvcl9tZXNzYWdlKTsKCgkJbGIgPSBzdHJjaHJudWwoYSArIHN0cmxlbigiXG5hdXRob3IgIiksICc8Jyk7CgkJcmIgPSBzdHJjaHJudWwobGIsICc+Jyk7CgkJZW9sID0gc3RyY2hybnVsKHJiLCAnXG4nKTsKCQlpZiAoISpsYiB8fCAhKnJiIHx8ICEqZW9sKQoJCQlkaWUoXygiaW52YWxpZCBjb21taXQ6ICVzIiksIGF1dGhvcl9tZXNzYWdlKTsKCgkJaWYgKGxiID09IGEgKyBzdHJsZW4oIlxuYXV0aG9yICIpKQoJCQkvKiBcbmF1dGhvciA8Zm9vQGV4YW1wbGUuY29tPiAqLwoJCQluYW1lID0geGNhbGxvYygxLCAxKTsKCQllbHNlCgkJCW5hbWUgPSB4bWVtZHVweihhICsgc3RybGVuKCJcbmF1dGhvciAiKSwKCQkJCQkobGIgLSBzdHJsZW4oIiAiKSAtCgkJCQkJIChhICsgc3RybGVuKCJcbmF1dGhvciAiKSkpKTsKCQllbWFpbCA9IHhtZW1kdXB6KGxiICsgc3RybGVuKCI8IiksIHJiIC0gKGxiICsgc3RybGVuKCI8IikpKTsKCQlkYXRlID0geG1lbWR1cHoocmIgKyBzdHJsZW4oIj4gIiksIGVvbCAtIChyYiArIHN0cmxlbigiPiAiKSkpOwoJfQoKCWlmIChmb3JjZV9hdXRob3IpIHsKCQljb25zdCBjaGFyICpsYiA9IHN0cnN0cihmb3JjZV9hdXRob3IsICIgPCIpOwoJCWNvbnN0IGNoYXIgKnJiID0gc3RyY2hyKGZvcmNlX2F1dGhvciwgJz4nKTsKCgkJaWYgKCFsYiB8fCAhcmIpCgkJCWRpZShfKCJtYWxmb3JtZWQgLS1hdXRob3IgcGFyYW1ldGVyIikpOwoJCW5hbWUgPSB4c3RybmR1cChmb3JjZV9hdXRob3IsIGxiIC0gZm9yY2VfYXV0aG9yKTsKCQllbWFpbCA9IHhzdHJuZHVwKGxiICsgMiwgcmIgLSAobGIgKyAyKSk7Cgl9CgoJaWYgKGZvcmNlX2RhdGUpCgkJZGF0ZSA9IGZvcmNlX2RhdGU7CglzdHJidWZfYWRkc3RyKGF1dGhvcl9pZGVudCwgZm10X2lkZW50KG5hbWUsIGVtYWlsLCBkYXRlLAoJCQkJCSAgICAgIElERU5UX0VSUk9SX09OX05PX05BTUUpKTsKfQoKc3RhdGljIGludCBlbmRzX3JmYzI4MjJfZm9vdGVyKHN0cnVjdCBzdHJidWYgKnNiKQp7CglpbnQgY2g7CglpbnQgaGl0ID0gMDsKCWludCBpLCBqLCBrOwoJaW50IGxlbiA9IHNiLT5sZW47CglpbnQgZmlyc3QgPSAxOwoJY29uc3QgY2hhciAqYnVmID0gc2ItPmJ1ZjsKCglmb3IgKGkgPSBsZW4gLSAxOyBpID4gMDsgaS0tKSB7CgkJaWYgKGhpdCAmJiBidWZbaV0gPT0gJ1xuJykKCQkJYnJlYWs7CgkJaGl0ID0gKGJ1ZltpXSA9PSAnXG4nKTsKCX0KCgl3aGlsZSAoaSA8IGxlbiAtIDEgJiYgYnVmW2ldID09ICdcbicpCgkJaSsrOwoKCWZvciAoOyBpIDwgbGVuOyBpID0gaykgewoJCWZvciAoayA9IGk7IGsgPCBsZW4gJiYgYnVmW2tdICE9ICdcbic7IGsrKykKCQkJOyAvKiBkbyBub3RoaW5nICovCgkJaysrOwoKCQlpZiAoKGJ1ZltrXSA9PSAnICcgfHwgYnVmW2tdID09ICdcdCcpICYmICFmaXJzdCkKCQkJY29udGludWU7CgoJCWZpcnN0ID0gMDsKCgkJZm9yIChqID0gMDsgaSArIGogPCBsZW47IGorKykgewoJCQljaCA9IGJ1ZltpICsgal07CgkJCWlmIChjaCA9PSAnOicpCgkJCQlicmVhazsKCQkJaWYgKGlzYWxudW0oY2gpIHx8CgkJCSAgICAoY2ggPT0gJy0nKSkKCQkJCWNvbnRpbnVlOwoJCQlyZXR1cm4gMDsKCQl9Cgl9CglyZXR1cm4gMTsKfQoKc3RhdGljIGNoYXIgKmN1dF9pZGVudF90aW1lc3RhbXBfcGFydChjaGFyICpzdHJpbmcpCnsKCWNoYXIgKmtldCA9IHN0cnJjaHIoc3RyaW5nLCAnPicpOwoJaWYgKCFrZXQgfHwga2V0WzFdICE9ICcgJykKCQlkaWUoXygiTWFsZm9ybWVkIGlkZW50IHN0cmluZzogJyVzJyIpLCBzdHJpbmcpOwoJKisra2V0ID0gJ1wwJzsKCXJldHVybiBrZXQ7Cn0KCnN0YXRpYyBpbnQgcHJlcGFyZV90b19jb21taXQoY29uc3QgY2hhciAqaW5kZXhfZmlsZSwgY29uc3QgY2hhciAqcHJlZml4LAoJCQkgICAgIHN0cnVjdCB3dF9zdGF0dXMgKnMsCgkJCSAgICAgc3RydWN0IHN0cmJ1ZiAqYXV0aG9yX2lkZW50KQp7CglzdHJ1Y3Qgc3RhdCBzdGF0YnVmOwoJc3RydWN0IHN0cmJ1ZiBjb21taXR0ZXJfaWRlbnQgPSBTVFJCVUZfSU5JVDsKCWludCBjb21taXRhYmxlLCBzYXZlZF9jb2xvcl9zZXR0aW5nOwoJc3RydWN0IHN0cmJ1ZiBzYiA9IFNUUkJVRl9JTklUOwoJY2hhciAqYnVmZmVyOwoJY29uc3QgY2hhciAqaG9va19hcmcxID0gTlVMTDsKCWNvbnN0IGNoYXIgKmhvb2tfYXJnMiA9IE5VTEw7CglpbnQgaWRlbnRfc2hvd24gPSAwOwoKCWlmICghbm9fdmVyaWZ5ICYmIHJ1bl9ob29rKGluZGV4X2ZpbGUsICJwcmUtY29tbWl0IiwgTlVMTCkpCgkJcmV0dXJuIDA7CgoJaWYgKHNxdWFzaF9tZXNzYWdlKSB7CgkJLyoKCQkgKiBJbnNlcnQgdGhlIHByb3BlciBzdWJqZWN0IGxpbmUgYmVmb3JlIG90aGVyIGNvbW1pdAoJCSAqIG1lc3NhZ2Ugb3B0aW9ucyBhZGQgdGhlaXIgY29udGVudC4KCQkgKi8KCQlpZiAodXNlX21lc3NhZ2UgJiYgIXN0cmNtcCh1c2VfbWVzc2FnZSwgc3F1YXNoX21lc3NhZ2UpKQoJCQlzdHJidWZfYWRkc3RyKCZzYiwgInNxdWFzaCEgIik7CgkJZWxzZSB7CgkJCXN0cnVjdCBwcmV0dHlfcHJpbnRfY29udGV4dCBjdHggPSB7MH07CgkJCXN0cnVjdCBjb21taXQgKmM7CgkJCWMgPSBsb29rdXBfY29tbWl0X3JlZmVyZW5jZV9ieV9uYW1lKHNxdWFzaF9tZXNzYWdlKTsKCQkJaWYgKCFjKQoJCQkJZGllKF8oImNvdWxkIG5vdCBsb29rdXAgY29tbWl0ICVzIiksIHNxdWFzaF9tZXNzYWdlKTsKCQkJY3R4Lm91dHB1dF9lbmNvZGluZyA9IGdldF9jb21taXRfb3V0cHV0X2VuY29kaW5nKCk7CgkJCWZvcm1hdF9jb21taXRfbWVzc2FnZShjLCAic3F1YXNoISAlc1xuXG4iLCAmc2IsCgkJCQkJICAgICAgJmN0eCk7CgkJfQoJfQoKCWlmIChtZXNzYWdlLmxlbikgewoJCXN0cmJ1Zl9hZGRidWYoJnNiLCAmbWVzc2FnZSk7CgkJaG9va19hcmcxID0gIm1lc3NhZ2UiOwoJfSBlbHNlIGlmIChsb2dmaWxlICYmICFzdHJjbXAobG9nZmlsZSwgIi0iKSkgewoJCWlmIChpc2F0dHkoMCkpCgkJCWZwcmludGYoc3RkZXJyLCBfKCIocmVhZGluZyBsb2cgbWVzc2FnZSBmcm9tIHN0YW5kYXJkIGlucHV0KVxuIikpOwoJCWlmIChzdHJidWZfcmVhZCgmc2IsIDAsIDApIDwgMCkKCQkJZGllX2Vycm5vKF8oImNvdWxkIG5vdCByZWFkIGxvZyBmcm9tIHN0YW5kYXJkIGlucHV0IikpOwoJCWhvb2tfYXJnMSA9ICJtZXNzYWdlIjsKCX0gZWxzZSBpZiAobG9nZmlsZSkgewoJCWlmIChzdHJidWZfcmVhZF9maWxlKCZzYiwgbG9nZmlsZSwgMCkgPCAwKQoJCQlkaWVfZXJybm8oXygiY291bGQgbm90IHJlYWQgbG9nIGZpbGUgJyVzJyIpLAoJCQkJICBsb2dmaWxlKTsKCQlob29rX2FyZzEgPSAibWVzc2FnZSI7Cgl9IGVsc2UgaWYgKHVzZV9tZXNzYWdlKSB7CgkJYnVmZmVyID0gc3Ryc3RyKHVzZV9tZXNzYWdlX2J1ZmZlciwgIlxuXG4iKTsKCQlpZiAoIWJ1ZmZlciB8fCBidWZmZXJbMl0gPT0gJ1wwJykKCQkJZGllKF8oImNvbW1pdCBoYXMgZW1wdHkgbWVzc2FnZSIpKTsKCQlzdHJidWZfYWRkKCZzYiwgYnVmZmVyICsgMiwgc3RybGVuKGJ1ZmZlciArIDIpKTsKCQlob29rX2FyZzEgPSAiY29tbWl0IjsKCQlob29rX2FyZzIgPSB1c2VfbWVzc2FnZTsKCX0gZWxzZSBpZiAoZml4dXBfbWVzc2FnZSkgewoJCXN0cnVjdCBwcmV0dHlfcHJpbnRfY29udGV4dCBjdHggPSB7MH07CgkJc3RydWN0IGNvbW1pdCAqY29tbWl0OwoJCWNvbW1pdCA9IGxvb2t1cF9jb21taXRfcmVmZXJlbmNlX2J5X25hbWUoZml4dXBfbWVzc2FnZSk7CgkJaWYgKCFjb21taXQpCgkJCWRpZShfKCJjb3VsZCBub3QgbG9va3VwIGNvbW1pdCAlcyIpLCBmaXh1cF9tZXNzYWdlKTsKCQljdHgub3V0cHV0X2VuY29kaW5nID0gZ2V0X2NvbW1pdF9vdXRwdXRfZW5jb2RpbmcoKTsKCQlmb3JtYXRfY29tbWl0X21lc3NhZ2UoY29tbWl0LCAiZml4dXAhICVzXG5cbiIsCgkJCQkgICAgICAmc2IsICZjdHgpOwoJCWhvb2tfYXJnMSA9ICJtZXNzYWdlIjsKCX0gZWxzZSBpZiAoIXN0YXQoZ2l0X3BhdGgoIk1FUkdFX01TRyIpLCAmc3RhdGJ1ZikpIHsKCQlpZiAoc3RyYnVmX3JlYWRfZmlsZSgmc2IsIGdpdF9wYXRoKCJNRVJHRV9NU0ciKSwgMCkgPCAwKQoJCQlkaWVfZXJybm8oXygiY291bGQgbm90IHJlYWQgTUVSR0VfTVNHIikpOwoJCWhvb2tfYXJnMSA9ICJtZXJnZSI7Cgl9IGVsc2UgaWYgKCFzdGF0KGdpdF9wYXRoKCJTUVVBU0hfTVNHIiksICZzdGF0YnVmKSkgewoJCWlmIChzdHJidWZfcmVhZF9maWxlKCZzYiwgZ2l0X3BhdGgoIlNRVUFTSF9NU0ciKSwgMCkgPCAwKQoJCQlkaWVfZXJybm8oXygiY291bGQgbm90IHJlYWQgU1FVQVNIX01TRyIpKTsKCQlob29rX2FyZzEgPSAic3F1YXNoIjsKCX0gZWxzZSBpZiAodGVtcGxhdGVfZmlsZSkgewoJCWlmIChzdHJidWZfcmVhZF9maWxlKCZzYiwgdGVtcGxhdGVfZmlsZSwgMCkgPCAwKQoJCQlkaWVfZXJybm8oXygiY291bGQgbm90IHJlYWQgJyVzJyIpLCB0ZW1wbGF0ZV9maWxlKTsKCQlob29rX2FyZzEgPSAidGVtcGxhdGUiOwoJfQoKCS8qCgkgKiBUaGUgcmVtYWluaW5nIGNhc2VzIGRvbid0IG1vZGlmeSB0aGUgdGVtcGxhdGUgbWVzc2FnZSwgYnV0CgkgKiBqdXN0IHNldCB0aGUgYXJndW1lbnQocykgdG8gdGhlIHByZXBhcmUtY29tbWl0LW1zZyBob29rLgoJICovCgllbHNlIGlmICh3aGVuY2UgPT0gRlJPTV9NRVJHRSkKCQlob29rX2FyZzEgPSAibWVyZ2UiOwoJZWxzZSBpZiAod2hlbmNlID09IEZST01fQ0hFUlJZX1BJQ0spIHsKCQlob29rX2FyZzEgPSAiY29tbWl0IjsKCQlob29rX2FyZzIgPSAiQ0hFUlJZX1BJQ0tfSEVBRCI7Cgl9CgoJaWYgKHNxdWFzaF9tZXNzYWdlKSB7CgkJLyoKCQkgKiBJZiBzcXVhc2hfY29tbWl0IHdhcyB1c2VkIGZvciB0aGUgY29tbWl0IHN1YmplY3QsCgkJICogdGhlbiB3ZSdyZSBwb3NzaWJseSBoaWphY2tpbmcgb3RoZXIgY29tbWl0IGxvZyBvcHRpb25zLgoJCSAqIFJlc2V0IHRoZSBob29rIGFyZ3MgdG8gdGVsbCB0aGUgcmVhbCBzdG9yeS4KCQkgKi8KCQlob29rX2FyZzEgPSAibWVzc2FnZSI7CgkJaG9va19hcmcyID0gIiI7Cgl9CgoJcy0+ZnAgPSBmb3BlbihnaXRfcGF0aChjb21taXRfZWRpdG1zZyksICJ3Iik7CglpZiAocy0+ZnAgPT0gTlVMTCkKCQlkaWVfZXJybm8oXygiY291bGQgbm90IG9wZW4gJyVzJyIpLCBnaXRfcGF0aChjb21taXRfZWRpdG1zZykpOwoKCWlmIChjbGVhbnVwX21vZGUgIT0gQ0xFQU5VUF9OT05FKQoJCXN0cmlwc3BhY2UoJnNiLCAwKTsKCglpZiAoc2lnbm9mZikgewoJCXN0cnVjdCBzdHJidWYgc29iID0gU1RSQlVGX0lOSVQ7CgkJaW50IGk7CgoJCXN0cmJ1Zl9hZGRzdHIoJnNvYiwgc2lnbl9vZmZfaGVhZGVyKTsKCQlzdHJidWZfYWRkc3RyKCZzb2IsIGZtdF9uYW1lKGdldGVudigiR0lUX0NPTU1JVFRFUl9OQU1FIiksCgkJCQkJICAgICBnZXRlbnYoIkdJVF9DT01NSVRURVJfRU1BSUwiKSkpOwoJCXN0cmJ1Zl9hZGRjaCgmc29iLCAnXG4nKTsKCQlmb3IgKGkgPSBzYi5sZW4gLSAxOyBpID4gMCAmJiBzYi5idWZbaSAtIDFdICE9ICdcbic7IGktLSkKCQkJOyAvKiBkbyBub3RoaW5nICovCgkJaWYgKHByZWZpeGNtcChzYi5idWYgKyBpLCBzb2IuYnVmKSkgewoJCQlpZiAoIWkgfHwgIWVuZHNfcmZjMjgyMl9mb290ZXIoJnNiKSkKCQkJCXN0cmJ1Zl9hZGRjaCgmc2IsICdcbicpOwoJCQlzdHJidWZfYWRkYnVmKCZzYiwgJnNvYik7CgkJfQoJCXN0cmJ1Zl9yZWxlYXNlKCZzb2IpOwoJfQoKCWlmIChmd3JpdGUoc2IuYnVmLCAxLCBzYi5sZW4sIHMtPmZwKSA8IHNiLmxlbikKCQlkaWVfZXJybm8oXygiY291bGQgbm90IHdyaXRlIGNvbW1pdCB0ZW1wbGF0ZSIpKTsKCglzdHJidWZfcmVsZWFzZSgmc2IpOwoKCS8qIFRoaXMgY2hlY2tzIGFuZCBiYXJmcyBpZiBhdXRob3IgaXMgYmFkbHkgc3BlY2lmaWVkICovCglkZXRlcm1pbmVfYXV0aG9yX2luZm8oYXV0aG9yX2lkZW50KTsKCgkvKiBUaGlzIGNoZWNrcyBpZiBjb21taXR0ZXIgaWRlbnQgaXMgZXhwbGljaXRseSBnaXZlbiAqLwoJc3RyYnVmX2FkZHN0cigmY29tbWl0dGVyX2lkZW50LCBnaXRfY29tbWl0dGVyX2luZm8oMCkpOwoJaWYgKHVzZV9lZGl0b3IgJiYgaW5jbHVkZV9zdGF0dXMpIHsKCQljaGFyICphaV90bXAsICpjaV90bXA7CgkJaWYgKHdoZW5jZSAhPSBGUk9NX0NPTU1JVCkKCQkJc3RhdHVzX3ByaW50Zl9sbihzLCBHSVRfQ09MT1JfTk9STUFMLAoJCQkJXygiXG4iCgkJCQkiSXQgbG9va3MgbGlrZSB5b3UgbWF5IGJlIGNvbW1pdHRpbmcgYSAlcy5cbiIKCQkJCSJJZiB0aGlzIGlzIG5vdCBjb3JyZWN0LCBwbGVhc2UgcmVtb3ZlIHRoZSBmaWxlXG4iCgkJCQkiCSVzXG4iCgkJCQkiYW5kIHRyeSBhZ2Fpbi5cbiIKCQkJCSIiKSwKCQkJCXdoZW5jZV9zKCksCgkJCQlnaXRfcGF0aCh3aGVuY2UgPT0gRlJPTV9NRVJHRQoJCQkJCSA/ICJNRVJHRV9IRUFEIgoJCQkJCSA6ICJDSEVSUllfUElDS19IRUFEIikpOwoKCQlmcHJpbnRmKHMtPmZwLCAiXG4iKTsKCQlzdGF0dXNfcHJpbnRmKHMsIEdJVF9DT0xPUl9OT1JNQUwsCgkJCV8oIlBsZWFzZSBlbnRlciB0aGUgY29tbWl0IG1lc3NhZ2UgZm9yIHlvdXIgY2hhbmdlcy4iKSk7CgkJaWYgKGNsZWFudXBfbW9kZSA9PSBDTEVBTlVQX0FMTCkKCQkJc3RhdHVzX3ByaW50Zl9tb3JlKHMsIEdJVF9DT0xPUl9OT1JNQUwsCgkJCQlfKCIgTGluZXMgc3RhcnRpbmdcbiIKCQkJCSJ3aXRoICcjJyB3aWxsIGJlIGlnbm9yZWQsIGFuZCBhbiBlbXB0eSIKCQkJCSIgbWVzc2FnZSBhYm9ydHMgdGhlIGNvbW1pdC5cbiIpKTsKCQllbHNlIC8qIENMRUFOVVBfU1BBQ0UsIHRoYXQgaXMuICovCgkJCXN0YXR1c19wcmludGZfbW9yZShzLCBHSVRfQ09MT1JfTk9STUFMLAoJCQkJXygiIExpbmVzIHN0YXJ0aW5nXG4iCgkJCQkid2l0aCAnIycgd2lsbCBiZSBrZXB0OyB5b3UgbWF5IHJlbW92ZSB0aGVtIgoJCQkJIiB5b3Vyc2VsZiBpZiB5b3Ugd2FudCB0by5cbiIKCQkJCSJBbiBlbXB0eSBtZXNzYWdlIGFib3J0cyB0aGUgY29tbWl0LlxuIikpOwoJCWlmIChvbmx5X2luY2x1ZGVfYXNzdW1lZCkKCQkJc3RhdHVzX3ByaW50Zl9sbihzLCBHSVRfQ09MT1JfTk9STUFMLAoJCQkJCSIlcyIsIG9ubHlfaW5jbHVkZV9hc3N1bWVkKTsKCgkJYWlfdG1wID0gY3V0X2lkZW50X3RpbWVzdGFtcF9wYXJ0KGF1dGhvcl9pZGVudC0+YnVmKTsKCQljaV90bXAgPSBjdXRfaWRlbnRfdGltZXN0YW1wX3BhcnQoY29tbWl0dGVyX2lkZW50LmJ1Zik7CgkJaWYgKHN0cmNtcChhdXRob3JfaWRlbnQtPmJ1ZiwgY29tbWl0dGVyX2lkZW50LmJ1ZikpCgkJCXN0YXR1c19wcmludGZfbG4ocywgR0lUX0NPTE9SX05PUk1BTCwKCQkJCV8oIiVzIgoJCQkJIkF1dGhvcjogICAgJXMiKSwKCQkJCWlkZW50X3Nob3duKysgPyAiIiA6ICJcbiIsCgkJCQlhdXRob3JfaWRlbnQtPmJ1Zik7CgoJCWlmICghdXNlcl9pZGVudF9zdWZmaWNpZW50bHlfZ2l2ZW4oKSkKCQkJc3RhdHVzX3ByaW50Zl9sbihzLCBHSVRfQ09MT1JfTk9STUFMLAoJCQkJXygiJXMiCgkJCQkiQ29tbWl0dGVyOiAlcyIpLAoJCQkJaWRlbnRfc2hvd24rKyA/ICIiIDogIlxuIiwKCQkJCWNvbW1pdHRlcl9pZGVudC5idWYpOwoKCQlpZiAoaWRlbnRfc2hvd24pCgkJCXN0YXR1c19wcmludGZfbG4ocywgR0lUX0NPTE9SX05PUk1BTCwgIiIpOwoKCQlzYXZlZF9jb2xvcl9zZXR0aW5nID0gcy0+dXNlX2NvbG9yOwoJCXMtPnVzZV9jb2xvciA9IDA7CgkJY29tbWl0YWJsZSA9IHJ1bl9zdGF0dXMocy0+ZnAsIGluZGV4X2ZpbGUsIHByZWZpeCwgMSwgcyk7CgkJcy0+dXNlX2NvbG9yID0gc2F2ZWRfY29sb3Jfc2V0dGluZzsKCgkJKmFpX3RtcCA9ICcgJzsKCQkqY2lfdG1wID0gJyAnOwoJfSBlbHNlIHsKCQl1bnNpZ25lZCBjaGFyIHNoYTFbMjBdOwoJCWNvbnN0IGNoYXIgKnBhcmVudCA9ICJIRUFEIjsKCgkJaWYgKCFhY3RpdmVfbnIgJiYgcmVhZF9jYWNoZSgpIDwgMCkKCQkJZGllKF8oIkNhbm5vdCByZWFkIGluZGV4IikpOwoKCQlpZiAoYW1lbmQpCgkJCXBhcmVudCA9ICJIRUFEXjEiOwoKCQlpZiAoZ2V0X3NoYTEocGFyZW50LCBzaGExKSkKCQkJY29tbWl0YWJsZSA9ICEhYWN0aXZlX25yOwoJCWVsc2UKCQkJY29tbWl0YWJsZSA9IGluZGV4X2RpZmZlcnNfZnJvbShwYXJlbnQsIDApOwoJfQoJc3RyYnVmX3JlbGVhc2UoJmNvbW1pdHRlcl9pZGVudCk7CgoJZmNsb3NlKHMtPmZwKTsKCgkvKgoJICogUmVqZWN0IGFuIGF0dGVtcHQgdG8gcmVjb3JkIGEgbm9uLW1lcmdlIGVtcHR5IGNvbW1pdCB3aXRob3V0CgkgKiBleHBsaWNpdCAtLWFsbG93LWVtcHR5LiBJbiB0aGUgY2hlcnJ5LXBpY2sgY2FzZSwgaXQgbWF5IGJlCgkgKiBlbXB0eSBkdWUgdG8gY29uZmxpY3QgcmVzb2x1dGlvbiwgd2hpY2ggdGhlIHVzZXIgc2hvdWxkIG9rYXkuCgkgKi8KCWlmICghY29tbWl0YWJsZSAmJiB3aGVuY2UgIT0gRlJPTV9NRVJHRSAmJiAhYWxsb3dfZW1wdHkgJiYKCSAgICAhKGFtZW5kICYmIGlzX2FfbWVyZ2UoaGVhZF9zaGExKSkpIHsKCQlydW5fc3RhdHVzKHN0ZG91dCwgaW5kZXhfZmlsZSwgcHJlZml4LCAwLCBzKTsKCQlpZiAoYW1lbmQpCgkJCWZwdXRzKF8oZW1wdHlfYW1lbmRfYWR2aWNlKSwgc3RkZXJyKTsKCQllbHNlIGlmICh3aGVuY2UgPT0gRlJPTV9DSEVSUllfUElDSykKCQkJZnB1dHMoXyhlbXB0eV9jaGVycnlfcGlja19hZHZpY2UpLCBzdGRlcnIpOwoJCXJldHVybiAwOwoJfQoKCS8qCgkgKiBSZS1yZWFkIHRoZSBpbmRleCBhcyBwcmUtY29tbWl0IGhvb2sgY291bGQgaGF2ZSB1cGRhdGVkIGl0LAoJICogYW5kIHdyaXRlIGl0IG91dCBhcyBhIHRyZWUuICBXZSBtdXN0IGRvIHRoaXMgYmVmb3JlIHdlIGludm9rZQoJICogdGhlIGVkaXRvciBhbmQgYWZ0ZXIgd2UgaW52b2tlIHJ1bl9zdGF0dXMgYWJvdmUuCgkgKi8KCWRpc2NhcmRfY2FjaGUoKTsKCXJlYWRfY2FjaGVfZnJvbShpbmRleF9maWxlKTsKCWlmICghYWN0aXZlX2NhY2hlX3RyZWUpCgkJYWN0aXZlX2NhY2hlX3RyZWUgPSBjYWNoZV90cmVlKCk7CglpZiAoY2FjaGVfdHJlZV91cGRhdGUoYWN0aXZlX2NhY2hlX3RyZWUsCgkJCSAgICAgIGFjdGl2ZV9jYWNoZSwgYWN0aXZlX25yLCAwLCAwKSA8IDApIHsKCQllcnJvcihfKCJFcnJvciBidWlsZGluZyB0cmVlcyIpKTsKCQlyZXR1cm4gMDsKCX0KCglpZiAocnVuX2hvb2soaW5kZXhfZmlsZSwgInByZXBhcmUtY29tbWl0LW1zZyIsCgkJICAgICBnaXRfcGF0aChjb21taXRfZWRpdG1zZyksIGhvb2tfYXJnMSwgaG9va19hcmcyLCBOVUxMKSkKCQlyZXR1cm4gMDsKCglpZiAodXNlX2VkaXRvcikgewoJCWNoYXIgaW5kZXhbUEFUSF9NQVhdOwoJCWNvbnN0IGNoYXIgKmVudlsyXSA9IHsgTlVMTCB9OwoJCWVudlswXSA9ICBpbmRleDsKCQlzbnByaW50ZihpbmRleCwgc2l6ZW9mKGluZGV4KSwgIkdJVF9JTkRFWF9GSUxFPSVzIiwgaW5kZXhfZmlsZSk7CgkJaWYgKGxhdW5jaF9lZGl0b3IoZ2l0X3BhdGgoY29tbWl0X2VkaXRtc2cpLCBOVUxMLCBlbnYpKSB7CgkJCWZwcmludGYoc3RkZXJyLAoJCQlfKCJQbGVhc2Ugc3VwcGx5IHRoZSBtZXNzYWdlIHVzaW5nIGVpdGhlciAtbSBvciAtRiBvcHRpb24uXG4iKSk7CgkJCWV4aXQoMSk7CgkJfQoJfQoKCWlmICghbm9fdmVyaWZ5ICYmCgkgICAgcnVuX2hvb2soaW5kZXhfZmlsZSwgImNvbW1pdC1tc2ciLCBnaXRfcGF0aChjb21taXRfZWRpdG1zZyksIE5VTEwpKSB7CgkJcmV0dXJuIDA7Cgl9CgoJcmV0dXJuIDE7Cn0KCi8qCiAqIEZpbmQgb3V0IGlmIHRoZSBtZXNzYWdlIGluIHRoZSBzdHJidWYgY29udGFpbnMgb25seSB3aGl0ZXNwYWNlIGFuZAogKiBTaWduZWQtb2ZmLWJ5IGxpbmVzLgogKi8Kc3RhdGljIGludCBtZXNzYWdlX2lzX2VtcHR5KHN0cnVjdCBzdHJidWYgKnNiKQp7CglzdHJ1Y3Qgc3RyYnVmIHRtcGwgPSBTVFJCVUZfSU5JVDsKCWNvbnN0IGNoYXIgKm5sOwoJaW50IGVvbCwgaSwgc3RhcnQgPSAwOwoKCWlmIChjbGVhbnVwX21vZGUgPT0gQ0xFQU5VUF9OT05FICYmIHNiLT5sZW4pCgkJcmV0dXJuIDA7CgoJLyogU2VlIGlmIHRoZSB0ZW1wbGF0ZSBpcyBqdXN0IGEgcHJlZml4IG9mIHRoZSBtZXNzYWdlLiAqLwoJaWYgKHRlbXBsYXRlX2ZpbGUgJiYgc3RyYnVmX3JlYWRfZmlsZSgmdG1wbCwgdGVtcGxhdGVfZmlsZSwgMCkgPiAwKSB7CgkJc3RyaXBzcGFjZSgmdG1wbCwgY2xlYW51cF9tb2RlID09IENMRUFOVVBfQUxMKTsKCQlpZiAoc3RhcnQgKyB0bXBsLmxlbiA8PSBzYi0+bGVuICYmCgkJICAgIG1lbWNtcCh0bXBsLmJ1Ziwgc2ItPmJ1ZiArIHN0YXJ0LCB0bXBsLmxlbikgPT0gMCkKCQkJc3RhcnQgKz0gdG1wbC5sZW47Cgl9CglzdHJidWZfcmVsZWFzZSgmdG1wbCk7CgoJLyogQ2hlY2sgaWYgdGhlIHJlc3QgaXMganVzdCB3aGl0ZXNwYWNlIGFuZCBTaWduZWQtb2YtYnkncy4gKi8KCWZvciAoaSA9IHN0YXJ0OyBpIDwgc2ItPmxlbjsgaSsrKSB7CgkJbmwgPSBtZW1jaHIoc2ItPmJ1ZiArIGksICdcbicsIHNiLT5sZW4gLSBpKTsKCQlpZiAobmwpCgkJCWVvbCA9IG5sIC0gc2ItPmJ1ZjsKCQllbHNlCgkJCWVvbCA9IHNiLT5sZW47CgoJCWlmIChzdHJsZW4oc2lnbl9vZmZfaGVhZGVyKSA8PSBlb2wgLSBpICYmCgkJICAgICFwcmVmaXhjbXAoc2ItPmJ1ZiArIGksIHNpZ25fb2ZmX2hlYWRlcikpIHsKCQkJaSA9IGVvbDsKCQkJY29udGludWU7CgkJfQoJCXdoaWxlIChpIDwgZW9sKQoJCQlpZiAoIWlzc3BhY2Uoc2ItPmJ1ZltpKytdKSkKCQkJCXJldHVybiAwOwoJfQoKCXJldHVybiAxOwp9CgpzdGF0aWMgY29uc3QgY2hhciAqZmluZF9hdXRob3JfYnlfbmlja25hbWUoY29uc3QgY2hhciAqbmFtZSkKewoJc3RydWN0IHJldl9pbmZvIHJldnM7CglzdHJ1Y3QgY29tbWl0ICpjb21taXQ7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoJY29uc3QgY2hhciAqYXZbMjBdOwoJaW50IGFjID0gMDsKCglpbml0X3JldmlzaW9ucygmcmV2cywgTlVMTCk7CglzdHJidWZfYWRkZigmYnVmLCAiLS1hdXRob3I9JXMiLCBuYW1lKTsKCWF2WysrYWNdID0gIi0tYWxsIjsKCWF2WysrYWNdID0gIi1pIjsKCWF2WysrYWNdID0gYnVmLmJ1ZjsKCWF2WysrYWNdID0gTlVMTDsKCXNldHVwX3JldmlzaW9ucyhhYywgYXYsICZyZXZzLCBOVUxMKTsKCXByZXBhcmVfcmV2aXNpb25fd2FsaygmcmV2cyk7Cgljb21taXQgPSBnZXRfcmV2aXNpb24oJnJldnMpOwoJaWYgKGNvbW1pdCkgewoJCXN0cnVjdCBwcmV0dHlfcHJpbnRfY29udGV4dCBjdHggPSB7MH07CgkJY3R4LmRhdGVfbW9kZSA9IERBVEVfTk9STUFMOwoJCXN0cmJ1Zl9yZWxlYXNlKCZidWYpOwoJCWZvcm1hdF9jb21taXRfbWVzc2FnZShjb21taXQsICIlYW4gPCVhZT4iLCAmYnVmLCAmY3R4KTsKCQlyZXR1cm4gc3RyYnVmX2RldGFjaCgmYnVmLCBOVUxMKTsKCX0KCWRpZShfKCJObyBleGlzdGluZyBhdXRob3IgZm91bmQgd2l0aCAnJXMnIiksIG5hbWUpOwp9CgoKc3RhdGljIHZvaWQgaGFuZGxlX3VudHJhY2tlZF9maWxlc19hcmcoc3RydWN0IHd0X3N0YXR1cyAqcykKewoJaWYgKCF1bnRyYWNrZWRfZmlsZXNfYXJnKQoJCTsgLyogZGVmYXVsdCBhbHJlYWR5IGluaXRpYWxpemVkICovCgllbHNlIGlmICghc3RyY21wKHVudHJhY2tlZF9maWxlc19hcmcsICJubyIpKQoJCXMtPnNob3dfdW50cmFja2VkX2ZpbGVzID0gU0hPV19OT19VTlRSQUNLRURfRklMRVM7CgllbHNlIGlmICghc3RyY21wKHVudHJhY2tlZF9maWxlc19hcmcsICJub3JtYWwiKSkKCQlzLT5zaG93X3VudHJhY2tlZF9maWxlcyA9IFNIT1dfTk9STUFMX1VOVFJBQ0tFRF9GSUxFUzsKCWVsc2UgaWYgKCFzdHJjbXAodW50cmFja2VkX2ZpbGVzX2FyZywgImFsbCIpKQoJCXMtPnNob3dfdW50cmFja2VkX2ZpbGVzID0gU0hPV19BTExfVU5UUkFDS0VEX0ZJTEVTOwoJZWxzZQoJCWRpZShfKCJJbnZhbGlkIHVudHJhY2tlZCBmaWxlcyBtb2RlICclcyciKSwgdW50cmFja2VkX2ZpbGVzX2FyZyk7Cn0KCnN0YXRpYyBjb25zdCBjaGFyICpyZWFkX2NvbW1pdF9tZXNzYWdlKGNvbnN0IGNoYXIgKm5hbWUpCnsKCWNvbnN0IGNoYXIgKm91dF9lbmMsICpvdXQ7CglzdHJ1Y3QgY29tbWl0ICpjb21taXQ7CgoJY29tbWl0ID0gbG9va3VwX2NvbW1pdF9yZWZlcmVuY2VfYnlfbmFtZShuYW1lKTsKCWlmICghY29tbWl0KQoJCWRpZShfKCJjb3VsZCBub3QgbG9va3VwIGNvbW1pdCAlcyIpLCBuYW1lKTsKCW91dF9lbmMgPSBnZXRfY29tbWl0X291dHB1dF9lbmNvZGluZygpOwoJb3V0ID0gbG9nbXNnX3JlZW5jb2RlKGNvbW1pdCwgb3V0X2VuYyk7CgoJLyoKCSAqIElmIHdlIGZhaWxlZCB0byByZWVuY29kZSB0aGUgYnVmZmVyLCBqdXN0IGNvcHkgaXQKCSAqIGJ5dGUgZm9yIGJ5dGUgc28gdGhlIHVzZXIgY2FuIHRyeSB0byBmaXggaXQgdXAuCgkgKiBUaGlzIGFsc28gaGFuZGxlcyB0aGUgY2FzZSB3aGVyZSBpbnB1dCBhbmQgb3V0cHV0CgkgKiBlbmNvZGluZ3MgYXJlIGlkZW50aWNhbC4KCSAqLwoJaWYgKG91dCA9PSBOVUxMKQoJCW91dCA9IHhzdHJkdXAoY29tbWl0LT5idWZmZXIpOwoJcmV0dXJuIG91dDsKfQoKc3RhdGljIGludCBwYXJzZV9hbmRfdmFsaWRhdGVfb3B0aW9ucyhpbnQgYXJnYywgY29uc3QgY2hhciAqYXJndltdLAoJCQkJICAgICAgY29uc3QgY2hhciAqIGNvbnN0IHVzYWdlW10sCgkJCQkgICAgICBjb25zdCBjaGFyICpwcmVmaXgsCgkJCQkgICAgICBzdHJ1Y3Qgd3Rfc3RhdHVzICpzKQp7CglpbnQgZiA9IDA7CgoJYXJnYyA9IHBhcnNlX29wdGlvbnMoYXJnYywgYXJndiwgcHJlZml4LCBidWlsdGluX2NvbW1pdF9vcHRpb25zLCB1c2FnZSwKCQkJICAgICAwKTsKCglpZiAoZm9yY2VfYXV0aG9yICYmICFzdHJjaHIoZm9yY2VfYXV0aG9yLCAnPicpKQoJCWZvcmNlX2F1dGhvciA9IGZpbmRfYXV0aG9yX2J5X25pY2tuYW1lKGZvcmNlX2F1dGhvcik7CgoJaWYgKGZvcmNlX2F1dGhvciAmJiByZW5ld19hdXRob3JzaGlwKQoJCWRpZShfKCJVc2luZyBib3RoIC0tcmVzZXQtYXV0aG9yIGFuZCAtLWF1dGhvciBkb2VzIG5vdCBtYWtlIHNlbnNlIikpOwoKCWlmIChsb2dmaWxlIHx8IG1lc3NhZ2UubGVuIHx8IHVzZV9tZXNzYWdlIHx8IGZpeHVwX21lc3NhZ2UpCgkJdXNlX2VkaXRvciA9IDA7CglpZiAoZWRpdF9mbGFnKQoJCXVzZV9lZGl0b3IgPSAxOwoJaWYgKCF1c2VfZWRpdG9yKQoJCXNldGVudigiR0lUX0VESVRPUiIsICI6IiwgMSk7CgoJaWYgKGdldF9zaGExKCJIRUFEIiwgaGVhZF9zaGExKSkKCQlpbml0aWFsX2NvbW1pdCA9IDE7CgoJLyogU2FuaXR5IGNoZWNrIG9wdGlvbnMgKi8KCWlmIChhbWVuZCAmJiBpbml0aWFsX2NvbW1pdCkKCQlkaWUoXygiWW91IGhhdmUgbm90aGluZyB0byBhbWVuZC4iKSk7CglpZiAoYW1lbmQgJiYgd2hlbmNlICE9IEZST01fQ09NTUlUKQoJCWRpZShfKCJZb3UgYXJlIGluIHRoZSBtaWRkbGUgb2YgYSAlcyAtLSBjYW5ub3QgYW1lbmQuIiksIHdoZW5jZV9zKCkpOwoJaWYgKGZpeHVwX21lc3NhZ2UgJiYgc3F1YXNoX21lc3NhZ2UpCgkJZGllKF8oIk9wdGlvbnMgLS1zcXVhc2ggYW5kIC0tZml4dXAgY2Fubm90IGJlIHVzZWQgdG9nZXRoZXIiKSk7CglpZiAodXNlX21lc3NhZ2UpCgkJZisrOwoJaWYgKGVkaXRfbWVzc2FnZSkKCQlmKys7CglpZiAoZml4dXBfbWVzc2FnZSkKCQlmKys7CglpZiAobG9nZmlsZSkKCQlmKys7CglpZiAoZiA+IDEpCgkJZGllKF8oIk9ubHkgb25lIG9mIC1jLy1DLy1GLy0tZml4dXAgY2FuIGJlIHVzZWQuIikpOwoJaWYgKG1lc3NhZ2UubGVuICYmIGYgPiAwKQoJCWRpZSgoXygiT3B0aW9uIC1tIGNhbm5vdCBiZSBjb21iaW5lZCB3aXRoIC1jLy1DLy1GLy0tZml4dXAuIikpKTsKCWlmIChlZGl0X21lc3NhZ2UpCgkJdXNlX21lc3NhZ2UgPSBlZGl0X21lc3NhZ2U7CglpZiAoYW1lbmQgJiYgIXVzZV9tZXNzYWdlICYmICFmaXh1cF9tZXNzYWdlKQoJCXVzZV9tZXNzYWdlID0gIkhFQUQiOwoJaWYgKCF1c2VfbWVzc2FnZSAmJiB3aGVuY2UgIT0gRlJPTV9DSEVSUllfUElDSyAmJiByZW5ld19hdXRob3JzaGlwKQoJCWRpZShfKCItLXJlc2V0LWF1dGhvciBjYW4gYmUgdXNlZCBvbmx5IHdpdGggLUMsIC1jIG9yIC0tYW1lbmQuIikpOwoJaWYgKHVzZV9tZXNzYWdlKSB7CgkJdXNlX21lc3NhZ2VfYnVmZmVyID0gcmVhZF9jb21taXRfbWVzc2FnZSh1c2VfbWVzc2FnZSk7CgkJaWYgKCFyZW5ld19hdXRob3JzaGlwKSB7CgkJCWF1dGhvcl9tZXNzYWdlID0gdXNlX21lc3NhZ2U7CgkJCWF1dGhvcl9tZXNzYWdlX2J1ZmZlciA9IHVzZV9tZXNzYWdlX2J1ZmZlcjsKCQl9Cgl9CglpZiAod2hlbmNlID09IEZST01fQ0hFUlJZX1BJQ0sgJiYgIXJlbmV3X2F1dGhvcnNoaXApIHsKCQlhdXRob3JfbWVzc2FnZSA9ICJDSEVSUllfUElDS19IRUFEIjsKCQlhdXRob3JfbWVzc2FnZV9idWZmZXIgPSByZWFkX2NvbW1pdF9tZXNzYWdlKGF1dGhvcl9tZXNzYWdlKTsKCX0KCglpZiAocGF0Y2hfaW50ZXJhY3RpdmUpCgkJaW50ZXJhY3RpdmUgPSAxOwoKCWlmICghIWFsc28gKyAhIW9ubHkgKyAhIWFsbCArICEhaW50ZXJhY3RpdmUgPiAxKQoJCWRpZShfKCJPbmx5IG9uZSBvZiAtLWluY2x1ZGUvLS1vbmx5Ly0tYWxsLy0taW50ZXJhY3RpdmUvLS1wYXRjaCBjYW4gYmUgdXNlZC4iKSk7CglpZiAoYXJnYyA9PSAwICYmIChhbHNvIHx8IChvbmx5ICYmICFhbWVuZCkpKQoJCWRpZShfKCJObyBwYXRocyB3aXRoIC0taW5jbHVkZS8tLW9ubHkgZG9lcyBub3QgbWFrZSBzZW5zZS4iKSk7CglpZiAoYXJnYyA9PSAwICYmIG9ubHkgJiYgYW1lbmQpCgkJb25seV9pbmNsdWRlX2Fzc3VtZWQgPSBfKCJDbGV2ZXIuLi4gYW1lbmRpbmcgdGhlIGxhc3Qgb25lIHdpdGggZGlydHkgaW5kZXguIik7CglpZiAoYXJnYyA+IDAgJiYgIWFsc28gJiYgIW9ubHkpCgkJb25seV9pbmNsdWRlX2Fzc3VtZWQgPSBfKCJFeHBsaWNpdCBwYXRocyBzcGVjaWZpZWQgd2l0aG91dCAtaSBub3IgLW87IGFzc3VtaW5nIC0tb25seSBwYXRocy4uLiIpOwoJaWYgKCFjbGVhbnVwX2FyZyB8fCAhc3RyY21wKGNsZWFudXBfYXJnLCAiZGVmYXVsdCIpKQoJCWNsZWFudXBfbW9kZSA9IHVzZV9lZGl0b3IgPyBDTEVBTlVQX0FMTCA6IENMRUFOVVBfU1BBQ0U7CgllbHNlIGlmICghc3RyY21wKGNsZWFudXBfYXJnLCAidmVyYmF0aW0iKSkKCQljbGVhbnVwX21vZGUgPSBDTEVBTlVQX05PTkU7CgllbHNlIGlmICghc3RyY21wKGNsZWFudXBfYXJnLCAid2hpdGVzcGFjZSIpKQoJCWNsZWFudXBfbW9kZSA9IENMRUFOVVBfU1BBQ0U7CgllbHNlIGlmICghc3RyY21wKGNsZWFudXBfYXJnLCAic3RyaXAiKSkKCQljbGVhbnVwX21vZGUgPSBDTEVBTlVQX0FMTDsKCWVsc2UKCQlkaWUoXygiSW52YWxpZCBjbGVhbnVwIG1vZGUgJXMiKSwgY2xlYW51cF9hcmcpOwoKCWhhbmRsZV91bnRyYWNrZWRfZmlsZXNfYXJnKHMpOwoKCWlmIChhbGwgJiYgYXJnYyA+IDApCgkJZGllKF8oIlBhdGhzIHdpdGggLWEgZG9lcyBub3QgbWFrZSBzZW5zZS4iKSk7CgoJaWYgKG51bGxfdGVybWluYXRpb24gJiYgc3RhdHVzX2Zvcm1hdCA9PSBTVEFUVVNfRk9STUFUX0xPTkcpCgkJc3RhdHVzX2Zvcm1hdCA9IFNUQVRVU19GT1JNQVRfUE9SQ0VMQUlOOwoJaWYgKHN0YXR1c19mb3JtYXQgIT0gU1RBVFVTX0ZPUk1BVF9MT05HKQoJCWRyeV9ydW4gPSAxOwoKCXJldHVybiBhcmdjOwp9CgpzdGF0aWMgaW50IGRyeV9ydW5fY29tbWl0KGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndiwgY29uc3QgY2hhciAqcHJlZml4LAoJCQkgIHN0cnVjdCB3dF9zdGF0dXMgKnMpCnsKCWludCBjb21taXRhYmxlOwoJY29uc3QgY2hhciAqaW5kZXhfZmlsZTsKCglpbmRleF9maWxlID0gcHJlcGFyZV9pbmRleChhcmdjLCBhcmd2LCBwcmVmaXgsIDEpOwoJY29tbWl0YWJsZSA9IHJ1bl9zdGF0dXMoc3Rkb3V0LCBpbmRleF9maWxlLCBwcmVmaXgsIDAsIHMpOwoJcm9sbGJhY2tfaW5kZXhfZmlsZXMoKTsKCglyZXR1cm4gY29tbWl0YWJsZSA/IDAgOiAxOwp9CgpzdGF0aWMgaW50IHBhcnNlX3N0YXR1c19zbG90KGNvbnN0IGNoYXIgKnZhciwgaW50IG9mZnNldCkKewoJaWYgKCFzdHJjYXNlY21wKHZhcitvZmZzZXQsICJoZWFkZXIiKSkKCQlyZXR1cm4gV1RfU1RBVFVTX0hFQURFUjsKCWlmICghc3RyY2FzZWNtcCh2YXIrb2Zmc2V0LCAiYnJhbmNoIikpCgkJcmV0dXJuIFdUX1NUQVRVU19PTkJSQU5DSDsKCWlmICghc3RyY2FzZWNtcCh2YXIrb2Zmc2V0LCAidXBkYXRlZCIpCgkJfHwgIXN0cmNhc2VjbXAodmFyK29mZnNldCwgImFkZGVkIikpCgkJcmV0dXJuIFdUX1NUQVRVU19VUERBVEVEOwoJaWYgKCFzdHJjYXNlY21wKHZhcitvZmZzZXQsICJjaGFuZ2VkIikpCgkJcmV0dXJuIFdUX1NUQVRVU19DSEFOR0VEOwoJaWYgKCFzdHJjYXNlY21wKHZhcitvZmZzZXQsICJ1bnRyYWNrZWQiKSkKCQlyZXR1cm4gV1RfU1RBVFVTX1VOVFJBQ0tFRDsKCWlmICghc3RyY2FzZWNtcCh2YXIrb2Zmc2V0LCAibm9icmFuY2giKSkKCQlyZXR1cm4gV1RfU1RBVFVTX05PQlJBTkNIOwoJaWYgKCFzdHJjYXNlY21wKHZhcitvZmZzZXQsICJ1bm1lcmdlZCIpKQoJCXJldHVybiBXVF9TVEFUVVNfVU5NRVJHRUQ7CglyZXR1cm4gLTE7Cn0KCnN0YXRpYyBpbnQgZ2l0X3N0YXR1c19jb25maWcoY29uc3QgY2hhciAqaywgY29uc3QgY2hhciAqdiwgdm9pZCAqY2IpCnsKCXN0cnVjdCB3dF9zdGF0dXMgKnMgPSBjYjsKCglpZiAoIXN0cmNtcChrLCAic3RhdHVzLnN1Ym1vZHVsZXN1bW1hcnkiKSkgewoJCWludCBpc19ib29sOwoJCXMtPnN1Ym1vZHVsZV9zdW1tYXJ5ID0gZ2l0X2NvbmZpZ19ib29sX29yX2ludChrLCB2LCAmaXNfYm9vbCk7CgkJaWYgKGlzX2Jvb2wgJiYgcy0+c3VibW9kdWxlX3N1bW1hcnkpCgkJCXMtPnN1Ym1vZHVsZV9zdW1tYXJ5ID0gLTE7CgkJcmV0dXJuIDA7Cgl9CglpZiAoIXN0cmNtcChrLCAic3RhdHVzLmNvbG9yIikgfHwgIXN0cmNtcChrLCAiY29sb3Iuc3RhdHVzIikpIHsKCQlzLT51c2VfY29sb3IgPSBnaXRfY29uZmlnX2NvbG9yYm9vbChrLCB2LCAtMSk7CgkJcmV0dXJuIDA7Cgl9CglpZiAoIXByZWZpeGNtcChrLCAic3RhdHVzLmNvbG9yLiIpIHx8ICFwcmVmaXhjbXAoaywgImNvbG9yLnN0YXR1cy4iKSkgewoJCWludCBzbG90ID0gcGFyc2Vfc3RhdHVzX3Nsb3QoaywgMTMpOwoJCWlmIChzbG90IDwgMCkKCQkJcmV0dXJuIDA7CgkJaWYgKCF2KQoJCQlyZXR1cm4gY29uZmlnX2Vycm9yX25vbmJvb2woayk7CgkJY29sb3JfcGFyc2Uodiwgaywgcy0+Y29sb3JfcGFsZXR0ZVtzbG90XSk7CgkJcmV0dXJuIDA7Cgl9CglpZiAoIXN0cmNtcChrLCAic3RhdHVzLnJlbGF0aXZlcGF0aHMiKSkgewoJCXMtPnJlbGF0aXZlX3BhdGhzID0gZ2l0X2NvbmZpZ19ib29sKGssIHYpOwoJCXJldHVybiAwOwoJfQoJaWYgKCFzdHJjbXAoaywgInN0YXR1cy5zaG93dW50cmFja2VkZmlsZXMiKSkgewoJCWlmICghdikKCQkJcmV0dXJuIGNvbmZpZ19lcnJvcl9ub25ib29sKGspOwoJCWVsc2UgaWYgKCFzdHJjbXAodiwgIm5vIikpCgkJCXMtPnNob3dfdW50cmFja2VkX2ZpbGVzID0gU0hPV19OT19VTlRSQUNLRURfRklMRVM7CgkJZWxzZSBpZiAoIXN0cmNtcCh2LCAibm9ybWFsIikpCgkJCXMtPnNob3dfdW50cmFja2VkX2ZpbGVzID0gU0hPV19OT1JNQUxfVU5UUkFDS0VEX0ZJTEVTOwoJCWVsc2UgaWYgKCFzdHJjbXAodiwgImFsbCIpKQoJCQlzLT5zaG93X3VudHJhY2tlZF9maWxlcyA9IFNIT1dfQUxMX1VOVFJBQ0tFRF9GSUxFUzsKCQllbHNlCgkJCXJldHVybiBlcnJvcihfKCJJbnZhbGlkIHVudHJhY2tlZCBmaWxlcyBtb2RlICclcyciKSwgdik7CgkJcmV0dXJuIDA7Cgl9CglyZXR1cm4gZ2l0X2RpZmZfdWlfY29uZmlnKGssIHYsIE5VTEwpOwp9CgppbnQgY21kX3N0YXR1cyhpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsIGNvbnN0IGNoYXIgKnByZWZpeCkKewoJc3RydWN0IHd0X3N0YXR1cyBzOwoJaW50IGZkOwoJdW5zaWduZWQgY2hhciBzaGExWzIwXTsKCXN0YXRpYyBzdHJ1Y3Qgb3B0aW9uIGJ1aWx0aW5fc3RhdHVzX29wdGlvbnNbXSA9IHsKCQlPUFRfX1ZFUkJPU0UoJnZlcmJvc2UsICJiZSB2ZXJib3NlIiksCgkJT1BUX1NFVF9JTlQoJ3MnLCAic2hvcnQiLCAmc3RhdHVzX2Zvcm1hdCwKCQkJICAgICJzaG93IHN0YXR1cyBjb25jaXNlbHkiLCBTVEFUVVNfRk9STUFUX1NIT1JUKSwKCQlPUFRfQk9PTEVBTignYicsICJicmFuY2giLCAmc3RhdHVzX3Nob3dfYnJhbmNoLAoJCQkgICAgInNob3cgYnJhbmNoIGluZm9ybWF0aW9uIiksCgkJT1BUX1NFVF9JTlQoMCwgInBvcmNlbGFpbiIsICZzdGF0dXNfZm9ybWF0LAoJCQkgICAgIm1hY2hpbmUtcmVhZGFibGUgb3V0cHV0IiwKCQkJICAgIFNUQVRVU19GT1JNQVRfUE9SQ0VMQUlOKSwKCQlPUFRfQk9PTEVBTigneicsICJudWxsIiwgJm51bGxfdGVybWluYXRpb24sCgkJCSAgICAidGVybWluYXRlIGVudHJpZXMgd2l0aCBOVUwiKSwKCQl7IE9QVElPTl9TVFJJTkcsICd1JywgInVudHJhY2tlZC1maWxlcyIsICZ1bnRyYWNrZWRfZmlsZXNfYXJnLAoJCSAgIm1vZGUiLAoJCSAgInNob3cgdW50cmFja2VkIGZpbGVzLCBvcHRpb25hbCBtb2RlczogYWxsLCBub3JtYWwsIG5vLiAoRGVmYXVsdDogYWxsKSIsCgkJICBQQVJTRV9PUFRfT1BUQVJHLCBOVUxMLCAoaW50cHRyX3QpImFsbCIgfSwKCQlPUFRfQk9PTEVBTigwLCAiaWdub3JlZCIsICZzaG93X2lnbm9yZWRfaW5fc3RhdHVzLAoJCQkgICAgInNob3cgaWdub3JlZCBmaWxlcyIpLAoJCXsgT1BUSU9OX1NUUklORywgMCwgImlnbm9yZS1zdWJtb2R1bGVzIiwgJmlnbm9yZV9zdWJtb2R1bGVfYXJnLCAid2hlbiIsCgkJICAiaWdub3JlIGNoYW5nZXMgdG8gc3VibW9kdWxlcywgb3B0aW9uYWwgd2hlbjogYWxsLCBkaXJ0eSwgdW50cmFja2VkLiAoRGVmYXVsdDogYWxsKSIsCgkJICBQQVJTRV9PUFRfT1BUQVJHLCBOVUxMLCAoaW50cHRyX3QpImFsbCIgfSwKCQlPUFRfRU5EKCksCgl9OwoKCWlmIChhcmdjID09IDIgJiYgIXN0cmNtcChhcmd2WzFdLCAiLWgiKSkKCQl1c2FnZV93aXRoX29wdGlvbnMoYnVpbHRpbl9zdGF0dXNfdXNhZ2UsIGJ1aWx0aW5fc3RhdHVzX29wdGlvbnMpOwoKCWlmIChudWxsX3Rlcm1pbmF0aW9uICYmIHN0YXR1c19mb3JtYXQgPT0gU1RBVFVTX0ZPUk1BVF9MT05HKQoJCXN0YXR1c19mb3JtYXQgPSBTVEFUVVNfRk9STUFUX1BPUkNFTEFJTjsKCgl3dF9zdGF0dXNfcHJlcGFyZSgmcyk7CglnaXRtb2R1bGVzX2NvbmZpZygpOwoJZ2l0X2NvbmZpZyhnaXRfc3RhdHVzX2NvbmZpZywgJnMpOwoJZGV0ZXJtaW5lX3doZW5jZSgmcyk7CglhcmdjID0gcGFyc2Vfb3B0aW9ucyhhcmdjLCBhcmd2LCBwcmVmaXgsCgkJCSAgICAgYnVpbHRpbl9zdGF0dXNfb3B0aW9ucywKCQkJICAgICBidWlsdGluX3N0YXR1c191c2FnZSwgMCk7CgloYW5kbGVfdW50cmFja2VkX2ZpbGVzX2FyZygmcyk7CglpZiAoc2hvd19pZ25vcmVkX2luX3N0YXR1cykKCQlzLnNob3dfaWdub3JlZF9maWxlcyA9IDE7CglpZiAoKmFyZ3YpCgkJcy5wYXRoc3BlYyA9IGdldF9wYXRoc3BlYyhwcmVmaXgsIGFyZ3YpOwoKCXJlYWRfY2FjaGVfcHJlbG9hZChzLnBhdGhzcGVjKTsKCXJlZnJlc2hfaW5kZXgoJnRoZV9pbmRleCwgUkVGUkVTSF9RVUlFVHxSRUZSRVNIX1VOTUVSR0VELCBzLnBhdGhzcGVjLCBOVUxMLCBOVUxMKTsKCglmZCA9IGhvbGRfbG9ja2VkX2luZGV4KCZpbmRleF9sb2NrLCAwKTsKCWlmICgwIDw9IGZkKQoJCXVwZGF0ZV9pbmRleF9pZl9hYmxlKCZ0aGVfaW5kZXgsICZpbmRleF9sb2NrKTsKCglzLmlzX2luaXRpYWwgPSBnZXRfc2hhMShzLnJlZmVyZW5jZSwgc2hhMSkgPyAxIDogMDsKCXMuaWdub3JlX3N1Ym1vZHVsZV9hcmcgPSBpZ25vcmVfc3VibW9kdWxlX2FyZzsKCXd0X3N0YXR1c19jb2xsZWN0KCZzKTsKCglpZiAocy5yZWxhdGl2ZV9wYXRocykKCQlzLnByZWZpeCA9IHByZWZpeDsKCWlmIChzLnVzZV9jb2xvciA9PSAtMSkKCQlzLnVzZV9jb2xvciA9IGdpdF91c2VfY29sb3JfZGVmYXVsdDsKCWlmIChkaWZmX3VzZV9jb2xvcl9kZWZhdWx0ID09IC0xKQoJCWRpZmZfdXNlX2NvbG9yX2RlZmF1bHQgPSBnaXRfdXNlX2NvbG9yX2RlZmF1bHQ7CgoJc3dpdGNoIChzdGF0dXNfZm9ybWF0KSB7CgljYXNlIFNUQVRVU19GT1JNQVRfU0hPUlQ6CgkJd3Rfc2hvcnRzdGF0dXNfcHJpbnQoJnMsIG51bGxfdGVybWluYXRpb24sIHN0YXR1c19zaG93X2JyYW5jaCk7CgkJYnJlYWs7CgljYXNlIFNUQVRVU19GT1JNQVRfUE9SQ0VMQUlOOgoJCXd0X3BvcmNlbGFpbl9wcmludCgmcywgbnVsbF90ZXJtaW5hdGlvbik7CgkJYnJlYWs7CgljYXNlIFNUQVRVU19GT1JNQVRfTE9ORzoKCQlzLnZlcmJvc2UgPSB2ZXJib3NlOwoJCXMuaWdub3JlX3N1Ym1vZHVsZV9hcmcgPSBpZ25vcmVfc3VibW9kdWxlX2FyZzsKCQl3dF9zdGF0dXNfcHJpbnQoJnMpOwoJCWJyZWFrOwoJfQoJcmV0dXJuIDA7Cn0KCnN0YXRpYyB2b2lkIHByaW50X3N1bW1hcnkoY29uc3QgY2hhciAqcHJlZml4LCBjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExKQp7CglzdHJ1Y3QgcmV2X2luZm8gcmV2OwoJc3RydWN0IGNvbW1pdCAqY29tbWl0OwoJc3RydWN0IHN0cmJ1ZiBmb3JtYXQgPSBTVFJCVUZfSU5JVDsKCXVuc2lnbmVkIGNoYXIganVua19zaGExWzIwXTsKCWNvbnN0IGNoYXIgKmhlYWQgPSByZXNvbHZlX3JlZigiSEVBRCIsIGp1bmtfc2hhMSwgMCwgTlVMTCk7CglzdHJ1Y3QgcHJldHR5X3ByaW50X2NvbnRleHQgcGN0eCA9IHswfTsKCXN0cnVjdCBzdHJidWYgYXV0aG9yX2lkZW50ID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3Qgc3RyYnVmIGNvbW1pdHRlcl9pZGVudCA9IFNUUkJVRl9JTklUOwoKCWNvbW1pdCA9IGxvb2t1cF9jb21taXQoc2hhMSk7CglpZiAoIWNvbW1pdCkKCQlkaWUoXygiY291bGRuJ3QgbG9vayB1cCBuZXdseSBjcmVhdGVkIGNvbW1pdCIpKTsKCWlmICghY29tbWl0IHx8IHBhcnNlX2NvbW1pdChjb21taXQpKQoJCWRpZShfKCJjb3VsZCBub3QgcGFyc2UgbmV3bHkgY3JlYXRlZCBjb21taXQiKSk7CgoJc3RyYnVmX2FkZHN0cigmZm9ybWF0LCAiZm9ybWF0OiVoXSAlcyIpOwoKCWZvcm1hdF9jb21taXRfbWVzc2FnZShjb21taXQsICIlYW4gPCVhZT4iLCAmYXV0aG9yX2lkZW50LCAmcGN0eCk7Cglmb3JtYXRfY29tbWl0X21lc3NhZ2UoY29tbWl0LCAiJWNuIDwlY2U+IiwgJmNvbW1pdHRlcl9pZGVudCwgJnBjdHgpOwoJaWYgKHN0cmJ1Zl9jbXAoJmF1dGhvcl9pZGVudCwgJmNvbW1pdHRlcl9pZGVudCkpIHsKCQlzdHJidWZfYWRkc3RyKCZmb3JtYXQsICJcbiBBdXRob3I6ICIpOwoJCXN0cmJ1Zl9hZGRidWZfcGVyY2VudHF1b3RlKCZmb3JtYXQsICZhdXRob3JfaWRlbnQpOwoJfQoJaWYgKCF1c2VyX2lkZW50X3N1ZmZpY2llbnRseV9naXZlbigpKSB7CgkJc3RyYnVmX2FkZHN0cigmZm9ybWF0LCAiXG4gQ29tbWl0dGVyOiAiKTsKCQlzdHJidWZfYWRkYnVmX3BlcmNlbnRxdW90ZSgmZm9ybWF0LCAmY29tbWl0dGVyX2lkZW50KTsKCQlpZiAoYWR2aWNlX2ltcGxpY2l0X2lkZW50aXR5KSB7CgkJCXN0cmJ1Zl9hZGRjaCgmZm9ybWF0LCAnXG4nKTsKCQkJc3RyYnVmX2FkZHN0cigmZm9ybWF0LCBfKGltcGxpY2l0X2lkZW50X2FkdmljZSkpOwoJCX0KCX0KCXN0cmJ1Zl9yZWxlYXNlKCZhdXRob3JfaWRlbnQpOwoJc3RyYnVmX3JlbGVhc2UoJmNvbW1pdHRlcl9pZGVudCk7CgoJaW5pdF9yZXZpc2lvbnMoJnJldiwgcHJlZml4KTsKCXNldHVwX3JldmlzaW9ucygwLCBOVUxMLCAmcmV2LCBOVUxMKTsKCglyZXYuZGlmZiA9IDE7CglyZXYuZGlmZm9wdC5vdXRwdXRfZm9ybWF0ID0KCQlESUZGX0ZPUk1BVF9TSE9SVFNUQVQgfCBESUZGX0ZPUk1BVF9TVU1NQVJZOwoKCXJldi52ZXJib3NlX2hlYWRlciA9IDE7CglyZXYuc2hvd19yb290X2RpZmYgPSAxOwoJZ2V0X2NvbW1pdF9mb3JtYXQoZm9ybWF0LmJ1ZiwgJnJldik7CglyZXYuYWx3YXlzX3Nob3dfaGVhZGVyID0gMDsKCXJldi5kaWZmb3B0LmRldGVjdF9yZW5hbWUgPSAxOwoJcmV2LmRpZmZvcHQuYnJlYWtfb3B0ID0gMDsKCWRpZmZfc2V0dXBfZG9uZSgmcmV2LmRpZmZvcHQpOwoKCXByaW50ZigiWyVzJXMgIiwKCQkhcHJlZml4Y21wKGhlYWQsICJyZWZzL2hlYWRzLyIpID8KCQkJaGVhZCArIDExIDoKCQkJIXN0cmNtcChoZWFkLCAiSEVBRCIpID8KCQkJCV8oImRldGFjaGVkIEhFQUQiKSA6CgkJCQloZWFkLAoJCWluaXRpYWxfY29tbWl0ID8gXygiIChyb290LWNvbW1pdCkiKSA6ICIiKTsKCglpZiAoIWxvZ190cmVlX2NvbW1pdCgmcmV2LCBjb21taXQpKSB7CgkJcmV2LmFsd2F5c19zaG93X2hlYWRlciA9IDE7CgkJcmV2LnVzZV90ZXJtaW5hdG9yID0gMTsKCQlsb2dfdHJlZV9jb21taXQoJnJldiwgY29tbWl0KTsKCX0KCglzdHJidWZfcmVsZWFzZSgmZm9ybWF0KTsKfQoKc3RhdGljIGludCBnaXRfY29tbWl0X2NvbmZpZyhjb25zdCBjaGFyICprLCBjb25zdCBjaGFyICp2LCB2b2lkICpjYikKewoJc3RydWN0IHd0X3N0YXR1cyAqcyA9IGNiOwoKCWlmICghc3RyY21wKGssICJjb21taXQudGVtcGxhdGUiKSkKCQlyZXR1cm4gZ2l0X2NvbmZpZ19wYXRobmFtZSgmdGVtcGxhdGVfZmlsZSwgaywgdik7CglpZiAoIXN0cmNtcChrLCAiY29tbWl0LnN0YXR1cyIpKSB7CgkJaW5jbHVkZV9zdGF0dXMgPSBnaXRfY29uZmlnX2Jvb2woaywgdik7CgkJcmV0dXJuIDA7Cgl9CgoJcmV0dXJuIGdpdF9zdGF0dXNfY29uZmlnKGssIHYsIHMpOwp9CgpzdGF0aWMgY29uc3QgY2hhciBwb3N0X3Jld3JpdGVfaG9va1tdID0gImhvb2tzL3Bvc3QtcmV3cml0ZSI7CgpzdGF0aWMgaW50IHJ1bl9yZXdyaXRlX2hvb2soY29uc3QgdW5zaWduZWQgY2hhciAqb2xkc2hhMSwKCQkJICAgIGNvbnN0IHVuc2lnbmVkIGNoYXIgKm5ld3NoYTEpCnsKCS8qIG9sZHNoYTEgU1AgbmV3c2hhMSBMRiBOVUwgKi8KCXN0YXRpYyBjaGFyIGJ1ZlsyKjQwICsgM107CglzdHJ1Y3QgY2hpbGRfcHJvY2VzcyBwcm9jOwoJY29uc3QgY2hhciAqYXJndlszXTsKCWludCBjb2RlOwoJc2l6ZV90IG47CgoJaWYgKGFjY2VzcyhnaXRfcGF0aChwb3N0X3Jld3JpdGVfaG9vayksIFhfT0spIDwgMCkKCQlyZXR1cm4gMDsKCglhcmd2WzBdID0gZ2l0X3BhdGgocG9zdF9yZXdyaXRlX2hvb2spOwoJYXJndlsxXSA9ICJhbWVuZCI7Cglhcmd2WzJdID0gTlVMTDsKCgltZW1zZXQoJnByb2MsIDAsIHNpemVvZihwcm9jKSk7Cglwcm9jLmFyZ3YgPSBhcmd2OwoJcHJvYy5pbiA9IC0xOwoJcHJvYy5zdGRvdXRfdG9fc3RkZXJyID0gMTsKCgljb2RlID0gc3RhcnRfY29tbWFuZCgmcHJvYyk7CglpZiAoY29kZSkKCQlyZXR1cm4gY29kZTsKCW4gPSBzbnByaW50ZihidWYsIHNpemVvZihidWYpLCAiJXMgJXNcbiIsCgkJICAgICBzaGExX3RvX2hleChvbGRzaGExKSwgc2hhMV90b19oZXgobmV3c2hhMSkpOwoJd3JpdGVfaW5fZnVsbChwcm9jLmluLCBidWYsIG4pOwoJY2xvc2UocHJvYy5pbik7CglyZXR1cm4gZmluaXNoX2NvbW1hbmQoJnByb2MpOwp9CgppbnQgY21kX2NvbW1pdChpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsIGNvbnN0IGNoYXIgKnByZWZpeCkKewoJc3RydWN0IHN0cmJ1ZiBzYiA9IFNUUkJVRl9JTklUOwoJc3RydWN0IHN0cmJ1ZiBhdXRob3JfaWRlbnQgPSBTVFJCVUZfSU5JVDsKCWNvbnN0IGNoYXIgKmluZGV4X2ZpbGUsICpyZWZsb2dfbXNnOwoJY2hhciAqbmwsICpwOwoJdW5zaWduZWQgY2hhciBjb21taXRfc2hhMVsyMF07CglzdHJ1Y3QgcmVmX2xvY2sgKnJlZl9sb2NrOwoJc3RydWN0IGNvbW1pdF9saXN0ICpwYXJlbnRzID0gTlVMTCwgKipwcHRyID0gJnBhcmVudHM7CglzdHJ1Y3Qgc3RhdCBzdGF0YnVmOwoJaW50IGFsbG93X2Zhc3RfZm9yd2FyZCA9IDE7CglzdHJ1Y3Qgd3Rfc3RhdHVzIHM7CgoJaWYgKGFyZ2MgPT0gMiAmJiAhc3RyY21wKGFyZ3ZbMV0sICItaCIpKQoJCXVzYWdlX3dpdGhfb3B0aW9ucyhidWlsdGluX2NvbW1pdF91c2FnZSwgYnVpbHRpbl9jb21taXRfb3B0aW9ucyk7CgoJd3Rfc3RhdHVzX3ByZXBhcmUoJnMpOwoJZ2l0X2NvbmZpZyhnaXRfY29tbWl0X2NvbmZpZywgJnMpOwoJZGV0ZXJtaW5lX3doZW5jZSgmcyk7CgoJaWYgKHMudXNlX2NvbG9yID09IC0xKQoJCXMudXNlX2NvbG9yID0gZ2l0X3VzZV9jb2xvcl9kZWZhdWx0OwoJYXJnYyA9IHBhcnNlX2FuZF92YWxpZGF0ZV9vcHRpb25zKGFyZ2MsIGFyZ3YsIGJ1aWx0aW5fY29tbWl0X3VzYWdlLAoJCQkJCSAgcHJlZml4LCAmcyk7CglpZiAoZHJ5X3J1bikgewoJCWlmIChkaWZmX3VzZV9jb2xvcl9kZWZhdWx0ID09IC0xKQoJCQlkaWZmX3VzZV9jb2xvcl9kZWZhdWx0ID0gZ2l0X3VzZV9jb2xvcl9kZWZhdWx0OwoJCXJldHVybiBkcnlfcnVuX2NvbW1pdChhcmdjLCBhcmd2LCBwcmVmaXgsICZzKTsKCX0KCWluZGV4X2ZpbGUgPSBwcmVwYXJlX2luZGV4KGFyZ2MsIGFyZ3YsIHByZWZpeCwgMCk7CgoJLyogU2V0IHVwIGV2ZXJ5dGhpbmcgZm9yIHdyaXRpbmcgdGhlIGNvbW1pdCBvYmplY3QuICBUaGlzIGluY2x1ZGVzCgkgICBydW5uaW5nIGhvb2tzLCB3cml0aW5nIHRoZSB0cmVlcywgYW5kIGludGVyYWN0aW5nIHdpdGggdGhlIHVzZXIuICAqLwoJaWYgKCFwcmVwYXJlX3RvX2NvbW1pdChpbmRleF9maWxlLCBwcmVmaXgsICZzLCAmYXV0aG9yX2lkZW50KSkgewoJCXJvbGxiYWNrX2luZGV4X2ZpbGVzKCk7CgkJcmV0dXJuIDE7Cgl9CgoJLyogRGV0ZXJtaW5lIHBhcmVudHMgKi8KCXJlZmxvZ19tc2cgPSBnZXRlbnYoIkdJVF9SRUZMT0dfQUNUSU9OIik7CglpZiAoaW5pdGlhbF9jb21taXQpIHsKCQlpZiAoIXJlZmxvZ19tc2cpCgkJCXJlZmxvZ19tc2cgPSAiY29tbWl0IChpbml0aWFsKSI7Cgl9IGVsc2UgaWYgKGFtZW5kKSB7CgkJc3RydWN0IGNvbW1pdF9saXN0ICpjOwoJCXN0cnVjdCBjb21taXQgKmNvbW1pdDsKCgkJaWYgKCFyZWZsb2dfbXNnKQoJCQlyZWZsb2dfbXNnID0gImNvbW1pdCAoYW1lbmQpIjsKCQljb21taXQgPSBsb29rdXBfY29tbWl0KGhlYWRfc2hhMSk7CgkJaWYgKCFjb21taXQgfHwgcGFyc2VfY29tbWl0KGNvbW1pdCkpCgkJCWRpZShfKCJjb3VsZCBub3QgcGFyc2UgSEVBRCBjb21taXQiKSk7CgoJCWZvciAoYyA9IGNvbW1pdC0+cGFyZW50czsgYzsgYyA9IGMtPm5leHQpCgkJCXBwdHIgPSAmY29tbWl0X2xpc3RfaW5zZXJ0KGMtPml0ZW0sIHBwdHIpLT5uZXh0OwoJfSBlbHNlIGlmICh3aGVuY2UgPT0gRlJPTV9NRVJHRSkgewoJCXN0cnVjdCBzdHJidWYgbSA9IFNUUkJVRl9JTklUOwoJCUZJTEUgKmZwOwoKCQlpZiAoIXJlZmxvZ19tc2cpCgkJCXJlZmxvZ19tc2cgPSAiY29tbWl0IChtZXJnZSkiOwoJCXBwdHIgPSAmY29tbWl0X2xpc3RfaW5zZXJ0KGxvb2t1cF9jb21taXQoaGVhZF9zaGExKSwgcHB0ciktPm5leHQ7CgkJZnAgPSBmb3BlbihnaXRfcGF0aCgiTUVSR0VfSEVBRCIpLCAiciIpOwoJCWlmIChmcCA9PSBOVUxMKQoJCQlkaWVfZXJybm8oXygiY291bGQgbm90IG9wZW4gJyVzJyBmb3IgcmVhZGluZyIpLAoJCQkJICBnaXRfcGF0aCgiTUVSR0VfSEVBRCIpKTsKCQl3aGlsZSAoc3RyYnVmX2dldGxpbmUoJm0sIGZwLCAnXG4nKSAhPSBFT0YpIHsKCQkJdW5zaWduZWQgY2hhciBzaGExWzIwXTsKCQkJaWYgKGdldF9zaGExX2hleChtLmJ1Ziwgc2hhMSkgPCAwKQoJCQkJZGllKF8oIkNvcnJ1cHQgTUVSR0VfSEVBRCBmaWxlICglcykiKSwgbS5idWYpOwoJCQlwcHRyID0gJmNvbW1pdF9saXN0X2luc2VydChsb29rdXBfY29tbWl0KHNoYTEpLCBwcHRyKS0+bmV4dDsKCQl9CgkJZmNsb3NlKGZwKTsKCQlzdHJidWZfcmVsZWFzZSgmbSk7CgkJaWYgKCFzdGF0KGdpdF9wYXRoKCJNRVJHRV9NT0RFIiksICZzdGF0YnVmKSkgewoJCQlpZiAoc3RyYnVmX3JlYWRfZmlsZSgmc2IsIGdpdF9wYXRoKCJNRVJHRV9NT0RFIiksIDApIDwgMCkKCQkJCWRpZV9lcnJubyhfKCJjb3VsZCBub3QgcmVhZCBNRVJHRV9NT0RFIikpOwoJCQlpZiAoIXN0cmNtcChzYi5idWYsICJuby1mZiIpKQoJCQkJYWxsb3dfZmFzdF9mb3J3YXJkID0gMDsKCQl9CgkJaWYgKGFsbG93X2Zhc3RfZm9yd2FyZCkKCQkJcGFyZW50cyA9IHJlZHVjZV9oZWFkcyhwYXJlbnRzKTsKCX0gZWxzZSB7CgkJaWYgKCFyZWZsb2dfbXNnKQoJCQlyZWZsb2dfbXNnID0gKHdoZW5jZSA9PSBGUk9NX0NIRVJSWV9QSUNLKQoJCQkJCT8gImNvbW1pdCAoY2hlcnJ5LXBpY2spIgoJCQkJCTogImNvbW1pdCI7CgkJcHB0ciA9ICZjb21taXRfbGlzdF9pbnNlcnQobG9va3VwX2NvbW1pdChoZWFkX3NoYTEpLCBwcHRyKS0+bmV4dDsKCX0KCgkvKiBGaW5hbGx5LCBnZXQgdGhlIGNvbW1pdCBtZXNzYWdlICovCglzdHJidWZfcmVzZXQoJnNiKTsKCWlmIChzdHJidWZfcmVhZF9maWxlKCZzYiwgZ2l0X3BhdGgoY29tbWl0X2VkaXRtc2cpLCAwKSA8IDApIHsKCQlpbnQgc2F2ZWRfZXJybm8gPSBlcnJubzsKCQlyb2xsYmFja19pbmRleF9maWxlcygpOwoJCWRpZShfKCJjb3VsZCBub3QgcmVhZCBjb21taXQgbWVzc2FnZTogJXMiKSwgc3RyZXJyb3Ioc2F2ZWRfZXJybm8pKTsKCX0KCgkvKiBUcnVuY2F0ZSB0aGUgbWVzc2FnZSBqdXN0IGJlZm9yZSB0aGUgZGlmZiwgaWYgYW55LiAqLwoJaWYgKHZlcmJvc2UpIHsKCQlwID0gc3Ryc3RyKHNiLmJ1ZiwgIlxuZGlmZiAtLWdpdCAiKTsKCQlpZiAocCAhPSBOVUxMKQoJCQlzdHJidWZfc2V0bGVuKCZzYiwgcCAtIHNiLmJ1ZiArIDEpOwoJfQoKCWlmIChjbGVhbnVwX21vZGUgIT0gQ0xFQU5VUF9OT05FKQoJCXN0cmlwc3BhY2UoJnNiLCBjbGVhbnVwX21vZGUgPT0gQ0xFQU5VUF9BTEwpOwoJaWYgKG1lc3NhZ2VfaXNfZW1wdHkoJnNiKSAmJiAhYWxsb3dfZW1wdHlfbWVzc2FnZSkgewoJCXJvbGxiYWNrX2luZGV4X2ZpbGVzKCk7CgkJZnByaW50ZihzdGRlcnIsIF8oIkFib3J0aW5nIGNvbW1pdCBkdWUgdG8gZW1wdHkgY29tbWl0IG1lc3NhZ2UuXG4iKSk7CgkJZXhpdCgxKTsKCX0KCglpZiAoY29tbWl0X3RyZWUoc2IuYnVmLCBhY3RpdmVfY2FjaGVfdHJlZS0+c2hhMSwgcGFyZW50cywgY29tbWl0X3NoYTEsCgkJCWF1dGhvcl9pZGVudC5idWYpKSB7CgkJcm9sbGJhY2tfaW5kZXhfZmlsZXMoKTsKCQlkaWUoXygiZmFpbGVkIHRvIHdyaXRlIGNvbW1pdCBvYmplY3QiKSk7Cgl9CglzdHJidWZfcmVsZWFzZSgmYXV0aG9yX2lkZW50KTsKCglyZWZfbG9jayA9IGxvY2tfYW55X3JlZl9mb3JfdXBkYXRlKCJIRUFEIiwKCQkJCQkgICBpbml0aWFsX2NvbW1pdCA/IE5VTEwgOiBoZWFkX3NoYTEsCgkJCQkJICAgMCk7CgoJbmwgPSBzdHJjaHIoc2IuYnVmLCAnXG4nKTsKCWlmIChubCkKCQlzdHJidWZfc2V0bGVuKCZzYiwgbmwgKyAxIC0gc2IuYnVmKTsKCWVsc2UKCQlzdHJidWZfYWRkY2goJnNiLCAnXG4nKTsKCXN0cmJ1Zl9pbnNlcnQoJnNiLCAwLCByZWZsb2dfbXNnLCBzdHJsZW4ocmVmbG9nX21zZykpOwoJc3RyYnVmX2luc2VydCgmc2IsIHN0cmxlbihyZWZsb2dfbXNnKSwgIjogIiwgMik7CgoJaWYgKCFyZWZfbG9jaykgewoJCXJvbGxiYWNrX2luZGV4X2ZpbGVzKCk7CgkJZGllKF8oImNhbm5vdCBsb2NrIEhFQUQgcmVmIikpOwoJfQoJaWYgKHdyaXRlX3JlZl9zaGExKHJlZl9sb2NrLCBjb21taXRfc2hhMSwgc2IuYnVmKSA8IDApIHsKCQlyb2xsYmFja19pbmRleF9maWxlcygpOwoJCWRpZShfKCJjYW5ub3QgdXBkYXRlIEhFQUQgcmVmIikpOwoJfQoKCXVubGluayhnaXRfcGF0aCgiQ0hFUlJZX1BJQ0tfSEVBRCIpKTsKCXVubGluayhnaXRfcGF0aCgiTUVSR0VfSEVBRCIpKTsKCXVubGluayhnaXRfcGF0aCgiTUVSR0VfTVNHIikpOwoJdW5saW5rKGdpdF9wYXRoKCJNRVJHRV9NT0RFIikpOwoJdW5saW5rKGdpdF9wYXRoKCJTUVVBU0hfTVNHIikpOwoKCWlmIChjb21taXRfaW5kZXhfZmlsZXMoKSkKCQlkaWUgKF8oIlJlcG9zaXRvcnkgaGFzIGJlZW4gdXBkYXRlZCwgYnV0IHVuYWJsZSB0byB3cml0ZVxuIgoJCSAgICAgIm5ld19pbmRleCBmaWxlLiBDaGVjayB0aGF0IGRpc2sgaXMgbm90IGZ1bGwgb3IgcXVvdGEgaXNcbiIKCQkgICAgICJub3QgZXhjZWVkZWQsIGFuZCB0aGVuIFwiZ2l0IHJlc2V0IEhFQURcIiB0byByZWNvdmVyLiIpKTsKCglyZXJlcmUoMCk7CglydW5faG9vayhnZXRfaW5kZXhfZmlsZSgpLCAicG9zdC1jb21taXQiLCBOVUxMKTsKCWlmIChhbWVuZCAmJiAhbm9fcG9zdF9yZXdyaXRlKSB7CgkJc3RydWN0IG5vdGVzX3Jld3JpdGVfY2ZnICpjZmc7CgkJY2ZnID0gaW5pdF9jb3B5X25vdGVzX2Zvcl9yZXdyaXRlKCJhbWVuZCIpOwoJCWlmIChjZmcpIHsKCQkJY29weV9ub3RlX2Zvcl9yZXdyaXRlKGNmZywgaGVhZF9zaGExLCBjb21taXRfc2hhMSk7CgkJCWZpbmlzaF9jb3B5X25vdGVzX2Zvcl9yZXdyaXRlKGNmZyk7CgkJfQoJCXJ1bl9yZXdyaXRlX2hvb2soaGVhZF9zaGExLCBjb21taXRfc2hhMSk7Cgl9CglpZiAoIXF1aWV0KQoJCXByaW50X3N1bW1hcnkocHJlZml4LCBjb21taXRfc2hhMSk7CgoJcmV0dXJuIDA7Cn0K",
    "text": "/*\n * Builtin \"git commit\"\n *\n * Copyright (c) 2007 Kristian H\u00f8gsberg <krh@redhat.com>\n * Based on git-commit.sh by Junio C Hamano and Linus Torvalds\n */\n\n#include \"cache.h\"\n#include \"cache-tree.h\"\n#include \"color.h\"\n#include \"dir.h\"\n#include \"builtin.h\"\n#include \"diff.h\"\n#include \"diffcore.h\"\n#include \"commit.h\"\n#include \"revision.h\"\n#include \"wt-status.h\"\n#include \"run-command.h\"\n#include \"refs.h\"\n#include \"log-tree.h\"\n#include \"strbuf.h\"\n#include \"utf8.h\"\n#include \"parse-options.h\"\n#include \"string-list.h\"\n#include \"rerere.h\"\n#include \"unpack-trees.h\"\n#include \"quote.h\"\n#include \"submodule.h\"\n\nstatic const char * const builtin_commit_usage[] = {\n\t\"git commit [options] [--] <filepattern>...\",\n\tNULL\n};\n\nstatic const char * const builtin_status_usage[] = {\n\t\"git status [options] [--] <filepattern>...\",\n\tNULL\n};\n\nstatic const char implicit_ident_advice[] =\nN_(\"Your name and email address were configured automatically based\\n\"\n\"on your username and hostname. Please check that they are accurate.\\n\"\n\"You can suppress this message by setting them explicitly:\\n\"\n\"\\n\"\n\"    git config --global user.name \\\"Your Name\\\"\\n\"\n\"    git config --global user.email you@example.com\\n\"\n\"\\n\"\n\"After doing this, you may fix the identity used for this commit with:\\n\"\n\"\\n\"\n\"    git commit --amend --reset-author\\n\");\n\nstatic const char empty_amend_advice[] =\nN_(\"You asked to amend the most recent commit, but doing so would make\\n\"\n\"it empty. You can repeat your command with --allow-empty, or you can\\n\"\n\"remove the commit entirely with \\\"git reset HEAD^\\\".\\n\");\n\nstatic const char empty_cherry_pick_advice[] =\nN_(\"The previous cherry-pick is now empty, possibly due to conflict resolution.\\n\"\n\"If you wish to commit it anyway, use:\\n\"\n\"\\n\"\n\"    git commit --allow-empty\\n\"\n\"\\n\"\n\"Otherwise, please use 'git reset'\\n\");\n\nstatic unsigned char head_sha1[20];\n\nstatic const char *use_message_buffer;\nstatic const char commit_editmsg[] = \"COMMIT_EDITMSG\";\nstatic struct lock_file index_lock; /* real index */\nstatic struct lock_file false_lock; /* used only for partial commits */\nstatic enum {\n\tCOMMIT_AS_IS = 1,\n\tCOMMIT_NORMAL,\n\tCOMMIT_PARTIAL\n} commit_style;\n\nstatic const char *logfile, *force_author;\nstatic const char *template_file;\n/*\n * The _message variables are commit names from which to take\n * the commit message and/or authorship.\n */\nstatic const char *author_message, *author_message_buffer;\nstatic char *edit_message, *use_message;\nstatic char *fixup_message, *squash_message;\nstatic int all, edit_flag, also, interactive, patch_interactive, only, amend, signoff;\nstatic int quiet, verbose, no_verify, allow_empty, dry_run, renew_authorship;\nstatic int no_post_rewrite, allow_empty_message;\nstatic char *untracked_files_arg, *force_date, *ignore_submodule_arg;\n/*\n * The default commit message cleanup mode will remove the lines\n * beginning with # (shell comments) and leading and trailing\n * whitespaces (empty lines or containing only whitespaces)\n * if editor is used, and only the whitespaces if the message\n * is specified explicitly.\n */\nstatic enum {\n\tCLEANUP_SPACE,\n\tCLEANUP_NONE,\n\tCLEANUP_ALL\n} cleanup_mode;\nstatic char *cleanup_arg;\n\nstatic enum commit_whence whence;\nstatic int use_editor = 1, initial_commit, include_status = 1;\nstatic int show_ignored_in_status;\nstatic const char *only_include_assumed;\nstatic struct strbuf message;\n\nstatic int null_termination;\nstatic enum {\n\tSTATUS_FORMAT_LONG,\n\tSTATUS_FORMAT_SHORT,\n\tSTATUS_FORMAT_PORCELAIN\n} status_format = STATUS_FORMAT_LONG;\nstatic int status_show_branch;\n\nstatic int opt_parse_m(const struct option *opt, const char *arg, int unset)\n{\n\tstruct strbuf *buf = opt->value;\n\tif (unset)\n\t\tstrbuf_setlen(buf, 0);\n\telse {\n\t\tstrbuf_addstr(buf, arg);\n\t\tstrbuf_addstr(buf, \"\\n\\n\");\n\t}\n\treturn 0;\n}\n\nstatic struct option builtin_commit_options[] = {\n\tOPT__QUIET(&quiet, \"suppress summary after successful commit\"),\n\tOPT__VERBOSE(&verbose, \"show diff in commit message template\"),\n\n\tOPT_GROUP(\"Commit message options\"),\n\tOPT_FILENAME('F', \"file\", &logfile, \"read message from file\"),\n\tOPT_STRING(0, \"author\", &force_author, \"author\", \"override author for commit\"),\n\tOPT_STRING(0, \"date\", &force_date, \"date\", \"override date for commit\"),\n\tOPT_CALLBACK('m', \"message\", &message, \"message\", \"commit message\", opt_parse_m),\n\tOPT_STRING('c', \"reedit-message\", &edit_message, \"commit\", \"reuse and edit message from specified commit\"),\n\tOPT_STRING('C', \"reuse-message\", &use_message, \"commit\", \"reuse message from specified commit\"),\n\tOPT_STRING(0, \"fixup\", &fixup_message, \"commit\", \"use autosquash formatted message to fixup specified commit\"),\n\tOPT_STRING(0, \"squash\", &squash_message, \"commit\", \"use autosquash formatted message to squash specified commit\"),\n\tOPT_BOOLEAN(0, \"reset-author\", &renew_authorship, \"the commit is authored by me now (used with -C-c/--amend)\"),\n\tOPT_BOOLEAN('s', \"signoff\", &signoff, \"add Signed-off-by:\"),\n\tOPT_FILENAME('t', \"template\", &template_file, \"use specified template file\"),\n\tOPT_BOOLEAN('e', \"edit\", &edit_flag, \"force edit of commit\"),\n\tOPT_STRING(0, \"cleanup\", &cleanup_arg, \"default\", \"how to strip spaces and #comments from message\"),\n\tOPT_BOOLEAN(0, \"status\", &include_status, \"include status in commit message template\"),\n\t/* end commit message options */\n\n\tOPT_GROUP(\"Commit contents options\"),\n\tOPT_BOOLEAN('a', \"all\", &all, \"commit all changed files\"),\n\tOPT_BOOLEAN('i', \"include\", &also, \"add specified files to index for commit\"),\n\tOPT_BOOLEAN(0, \"interactive\", &interactive, \"interactively add files\"),\n\tOPT_BOOLEAN('p', \"patch\", &patch_interactive, \"interactively add changes\"),\n\tOPT_BOOLEAN('o', \"only\", &only, \"commit only specified files\"),\n\tOPT_BOOLEAN('n', \"no-verify\", &no_verify, \"bypass pre-commit hook\"),\n\tOPT_BOOLEAN(0, \"dry-run\", &dry_run, \"show what would be committed\"),\n\tOPT_SET_INT(0, \"short\", &status_format, \"show status concisely\",\n\t\t    STATUS_FORMAT_SHORT),\n\tOPT_BOOLEAN(0, \"branch\", &status_show_branch, \"show branch information\"),\n\tOPT_SET_INT(0, \"porcelain\", &status_format,\n\t\t    \"machine-readable output\", STATUS_FORMAT_PORCELAIN),\n\tOPT_BOOLEAN('z', \"null\", &null_termination,\n\t\t    \"terminate entries with NUL\"),\n\tOPT_BOOLEAN(0, \"amend\", &amend, \"amend previous commit\"),\n\tOPT_BOOLEAN(0, \"no-post-rewrite\", &no_post_rewrite, \"bypass post-rewrite hook\"),\n\t{ OPTION_STRING, 'u', \"untracked-files\", &untracked_files_arg, \"mode\", \"show untracked files, optional modes: all, normal, no. (Default: all)\", PARSE_OPT_OPTARG, NULL, (intptr_t)\"all\" },\n\t/* end commit contents options */\n\n\t{ OPTION_BOOLEAN, 0, \"allow-empty\", &allow_empty, NULL,\n\t  \"ok to record an empty change\",\n\t  PARSE_OPT_NOARG | PARSE_OPT_HIDDEN },\n\t{ OPTION_BOOLEAN, 0, \"allow-empty-message\", &allow_empty_message, NULL,\n\t  \"ok to record a change with an empty message\",\n\t  PARSE_OPT_NOARG | PARSE_OPT_HIDDEN },\n\n\tOPT_END()\n};\n\nstatic void determine_whence(struct wt_status *s)\n{\n\tif (file_exists(git_path(\"MERGE_HEAD\")))\n\t\twhence = FROM_MERGE;\n\telse if (file_exists(git_path(\"CHERRY_PICK_HEAD\")))\n\t\twhence = FROM_CHERRY_PICK;\n\telse\n\t\twhence = FROM_COMMIT;\n\tif (s)\n\t\ts->whence = whence;\n}\n\nstatic const char *whence_s(void)\n{\n\tchar *s = \"\";\n\n\tswitch (whence) {\n\tcase FROM_COMMIT:\n\t\tbreak;\n\tcase FROM_MERGE:\n\t\ts = \"merge\";\n\t\tbreak;\n\tcase FROM_CHERRY_PICK:\n\t\ts = \"cherry-pick\";\n\t\tbreak;\n\t}\n\n\treturn s;\n}\n\nstatic void rollback_index_files(void)\n{\n\tswitch (commit_style) {\n\tcase COMMIT_AS_IS:\n\t\tbreak; /* nothing to do */\n\tcase COMMIT_NORMAL:\n\t\trollback_lock_file(&index_lock);\n\t\tbreak;\n\tcase COMMIT_PARTIAL:\n\t\trollback_lock_file(&index_lock);\n\t\trollback_lock_file(&false_lock);\n\t\tbreak;\n\t}\n}\n\nstatic int commit_index_files(void)\n{\n\tint err = 0;\n\n\tswitch (commit_style) {\n\tcase COMMIT_AS_IS:\n\t\tbreak; /* nothing to do */\n\tcase COMMIT_NORMAL:\n\t\terr = commit_lock_file(&index_lock);\n\t\tbreak;\n\tcase COMMIT_PARTIAL:\n\t\terr = commit_lock_file(&index_lock);\n\t\trollback_lock_file(&false_lock);\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\n/*\n * Take a union of paths in the index and the named tree (typically, \"HEAD\"),\n * and return the paths that match the given pattern in list.\n */\nstatic int list_paths(struct string_list *list, const char *with_tree,\n\t\t      const char *prefix, const char **pattern)\n{\n\tint i;\n\tchar *m;\n\n\tfor (i = 0; pattern[i]; i++)\n\t\t;\n\tm = xcalloc(1, i);\n\n\tif (with_tree)\n\t\toverlay_tree_on_cache(with_tree, prefix);\n\n\tfor (i = 0; i < active_nr; i++) {\n\t\tstruct cache_entry *ce = active_cache[i];\n\t\tstruct string_list_item *item;\n\n\t\tif (ce->ce_flags & CE_UPDATE)\n\t\t\tcontinue;\n\t\tif (!match_pathspec(pattern, ce->name, ce_namelen(ce), 0, m))\n\t\t\tcontinue;\n\t\titem = string_list_insert(list, ce->name);\n\t\tif (ce_skip_worktree(ce))\n\t\t\titem->util = item; /* better a valid pointer than a fake one */\n\t}\n\n\treturn report_path_error(m, pattern, prefix ? strlen(prefix) : 0);\n}\n\nstatic void add_remove_files(struct string_list *list)\n{\n\tint i;\n\tfor (i = 0; i < list->nr; i++) {\n\t\tstruct stat st;\n\t\tstruct string_list_item *p = &(list->items[i]);\n\n\t\t/* p->util is skip-worktree */\n\t\tif (p->util)\n\t\t\tcontinue;\n\n\t\tif (!lstat(p->string, &st)) {\n\t\t\tif (add_to_cache(p->string, &st, 0))\n\t\t\t\tdie(_(\"updating files failed\"));\n\t\t} else\n\t\t\tremove_file_from_cache(p->string);\n\t}\n}\n\nstatic void create_base_index(void)\n{\n\tstruct tree *tree;\n\tstruct unpack_trees_options opts;\n\tstruct tree_desc t;\n\n\tif (initial_commit) {\n\t\tdiscard_cache();\n\t\treturn;\n\t}\n\n\tmemset(&opts, 0, sizeof(opts));\n\topts.head_idx = 1;\n\topts.index_only = 1;\n\topts.merge = 1;\n\topts.src_index = &the_index;\n\topts.dst_index = &the_index;\n\n\topts.fn = oneway_merge;\n\ttree = parse_tree_indirect(head_sha1);\n\tif (!tree)\n\t\tdie(_(\"failed to unpack HEAD tree object\"));\n\tparse_tree(tree);\n\tinit_tree_desc(&t, tree->buffer, tree->size);\n\tif (unpack_trees(1, &t, &opts))\n\t\texit(128); /* We've already reported the error, finish dying */\n}\n\nstatic void refresh_cache_or_die(int refresh_flags)\n{\n\t/*\n\t * refresh_flags contains REFRESH_QUIET, so the only errors\n\t * are for unmerged entries.\n\t */\n\tif (refresh_cache(refresh_flags | REFRESH_IN_PORCELAIN))\n\t\tdie_resolve_conflict(\"commit\");\n}\n\nstatic char *prepare_index(int argc, const char **argv, const char *prefix, int is_status)\n{\n\tint fd;\n\tstruct string_list partial;\n\tconst char **pathspec = NULL;\n\tchar *old_index_env = NULL;\n\tint refresh_flags = REFRESH_QUIET;\n\n\tif (is_status)\n\t\trefresh_flags |= REFRESH_UNMERGED;\n\n\tif (*argv)\n\t\tpathspec = get_pathspec(prefix, argv);\n\n\tif (read_cache_preload(pathspec) < 0)\n\t\tdie(_(\"index file corrupt\"));\n\n\tif (interactive) {\n\t\tfd = hold_locked_index(&index_lock, 1);\n\n\t\trefresh_cache_or_die(refresh_flags);\n\n\t\tif (write_cache(fd, active_cache, active_nr) ||\n\t\t    close_lock_file(&index_lock))\n\t\t\tdie(_(\"unable to create temporary index\"));\n\n\t\told_index_env = getenv(INDEX_ENVIRONMENT);\n\t\tsetenv(INDEX_ENVIRONMENT, index_lock.filename, 1);\n\n\t\tif (interactive_add(argc, argv, prefix, patch_interactive) != 0)\n\t\t\tdie(_(\"interactive add failed\"));\n\n\t\tif (old_index_env && *old_index_env)\n\t\t\tsetenv(INDEX_ENVIRONMENT, old_index_env, 1);\n\t\telse\n\t\t\tunsetenv(INDEX_ENVIRONMENT);\n\n\t\tdiscard_cache();\n\t\tread_cache_from(index_lock.filename);\n\n\t\tcommit_style = COMMIT_NORMAL;\n\t\treturn index_lock.filename;\n\t}\n\n\t/*\n\t * Non partial, non as-is commit.\n\t *\n\t * (1) get the real index;\n\t * (2) update the_index as necessary;\n\t * (3) write the_index out to the real index (still locked);\n\t * (4) return the name of the locked index file.\n\t *\n\t * The caller should run hooks on the locked real index, and\n\t * (A) if all goes well, commit the real index;\n\t * (B) on failure, rollback the real index.\n\t */\n\tif (all || (also && pathspec && *pathspec)) {\n\t\tfd = hold_locked_index(&index_lock, 1);\n\t\tadd_files_to_cache(also ? prefix : NULL, pathspec, 0);\n\t\trefresh_cache_or_die(refresh_flags);\n\t\tif (write_cache(fd, active_cache, active_nr) ||\n\t\t    close_lock_file(&index_lock))\n\t\t\tdie(_(\"unable to write new_index file\"));\n\t\tcommit_style = COMMIT_NORMAL;\n\t\treturn index_lock.filename;\n\t}\n\n\t/*\n\t * As-is commit.\n\t *\n\t * (1) return the name of the real index file.\n\t *\n\t * The caller should run hooks on the real index,\n\t * and create commit from the_index.\n\t * We still need to refresh the index here.\n\t */\n\tif (!pathspec || !*pathspec) {\n\t\tfd = hold_locked_index(&index_lock, 1);\n\t\trefresh_cache_or_die(refresh_flags);\n\t\tif (active_cache_changed) {\n\t\t\tif (write_cache(fd, active_cache, active_nr) ||\n\t\t\t    commit_locked_index(&index_lock))\n\t\t\t\tdie(_(\"unable to write new_index file\"));\n\t\t} else {\n\t\t\trollback_lock_file(&index_lock);\n\t\t}\n\t\tcommit_style = COMMIT_AS_IS;\n\t\treturn get_index_file();\n\t}\n\n\t/*\n\t * A partial commit.\n\t *\n\t * (0) find the set of affected paths;\n\t * (1) get lock on the real index file;\n\t * (2) update the_index with the given paths;\n\t * (3) write the_index out to the real index (still locked);\n\t * (4) get lock on the false index file;\n\t * (5) reset the_index from HEAD;\n\t * (6) update the_index the same way as (2);\n\t * (7) write the_index out to the false index file;\n\t * (8) return the name of the false index file (still locked);\n\t *\n\t * The caller should run hooks on the locked false index, and\n\t * create commit from it.  Then\n\t * (A) if all goes well, commit the real index;\n\t * (B) on failure, rollback the real index;\n\t * In either case, rollback the false index.\n\t */\n\tcommit_style = COMMIT_PARTIAL;\n\n\tif (whence != FROM_COMMIT)\n\t\tdie(_(\"cannot do a partial commit during a %s.\"), whence_s());\n\n\tmemset(&partial, 0, sizeof(partial));\n\tpartial.strdup_strings = 1;\n\tif (list_paths(&partial, initial_commit ? NULL : \"HEAD\", prefix, pathspec))\n\t\texit(1);\n\n\tdiscard_cache();\n\tif (read_cache() < 0)\n\t\tdie(_(\"cannot read the index\"));\n\n\tfd = hold_locked_index(&index_lock, 1);\n\tadd_remove_files(&partial);\n\trefresh_cache(REFRESH_QUIET);\n\tif (write_cache(fd, active_cache, active_nr) ||\n\t    close_lock_file(&index_lock))\n\t\tdie(_(\"unable to write new_index file\"));\n\n\tfd = hold_lock_file_for_update(&false_lock,\n\t\t\t\t       git_path(\"next-index-%\"PRIuMAX,\n\t\t\t\t\t\t(uintmax_t) getpid()),\n\t\t\t\t       LOCK_DIE_ON_ERROR);\n\n\tcreate_base_index();\n\tadd_remove_files(&partial);\n\trefresh_cache(REFRESH_QUIET);\n\n\tif (write_cache(fd, active_cache, active_nr) ||\n\t    close_lock_file(&false_lock))\n\t\tdie(_(\"unable to write temporary index file\"));\n\n\tdiscard_cache();\n\tread_cache_from(false_lock.filename);\n\n\treturn false_lock.filename;\n}\n\nstatic int run_status(FILE *fp, const char *index_file, const char *prefix, int nowarn,\n\t\t      struct wt_status *s)\n{\n\tunsigned char sha1[20];\n\n\tif (s->relative_paths)\n\t\ts->prefix = prefix;\n\n\tif (amend) {\n\t\ts->amend = 1;\n\t\ts->reference = \"HEAD^1\";\n\t}\n\ts->verbose = verbose;\n\ts->index_file = index_file;\n\ts->fp = fp;\n\ts->nowarn = nowarn;\n\ts->is_initial = get_sha1(s->reference, sha1) ? 1 : 0;\n\n\twt_status_collect(s);\n\n\tswitch (status_format) {\n\tcase STATUS_FORMAT_SHORT:\n\t\twt_shortstatus_print(s, null_termination, status_show_branch);\n\t\tbreak;\n\tcase STATUS_FORMAT_PORCELAIN:\n\t\twt_porcelain_print(s, null_termination);\n\t\tbreak;\n\tcase STATUS_FORMAT_LONG:\n\t\twt_status_print(s);\n\t\tbreak;\n\t}\n\n\treturn s->commitable;\n}\n\nstatic int is_a_merge(const unsigned char *sha1)\n{\n\tstruct commit *commit = lookup_commit(sha1);\n\tif (!commit || parse_commit(commit))\n\t\tdie(_(\"could not parse HEAD commit\"));\n\treturn !!(commit->parents && commit->parents->next);\n}\n\nstatic const char sign_off_header[] = \"Signed-off-by: \";\n\nstatic void determine_author_info(struct strbuf *author_ident)\n{\n\tchar *name, *email, *date;\n\n\tname = getenv(\"GIT_AUTHOR_NAME\");\n\temail = getenv(\"GIT_AUTHOR_EMAIL\");\n\tdate = getenv(\"GIT_AUTHOR_DATE\");\n\n\tif (author_message) {\n\t\tconst char *a, *lb, *rb, *eol;\n\n\t\ta = strstr(author_message_buffer, \"\\nauthor \");\n\t\tif (!a)\n\t\t\tdie(_(\"invalid commit: %s\"), author_message);\n\n\t\tlb = strchrnul(a + strlen(\"\\nauthor \"), '<');\n\t\trb = strchrnul(lb, '>');\n\t\teol = strchrnul(rb, '\\n');\n\t\tif (!*lb || !*rb || !*eol)\n\t\t\tdie(_(\"invalid commit: %s\"), author_message);\n\n\t\tif (lb == a + strlen(\"\\nauthor \"))\n\t\t\t/* \\nauthor <foo@example.com> */\n\t\t\tname = xcalloc(1, 1);\n\t\telse\n\t\t\tname = xmemdupz(a + strlen(\"\\nauthor \"),\n\t\t\t\t\t(lb - strlen(\" \") -\n\t\t\t\t\t (a + strlen(\"\\nauthor \"))));\n\t\temail = xmemdupz(lb + strlen(\"<\"), rb - (lb + strlen(\"<\")));\n\t\tdate = xmemdupz(rb + strlen(\"> \"), eol - (rb + strlen(\"> \")));\n\t}\n\n\tif (force_author) {\n\t\tconst char *lb = strstr(force_author, \" <\");\n\t\tconst char *rb = strchr(force_author, '>');\n\n\t\tif (!lb || !rb)\n\t\t\tdie(_(\"malformed --author parameter\"));\n\t\tname = xstrndup(force_author, lb - force_author);\n\t\temail = xstrndup(lb + 2, rb - (lb + 2));\n\t}\n\n\tif (force_date)\n\t\tdate = force_date;\n\tstrbuf_addstr(author_ident, fmt_ident(name, email, date,\n\t\t\t\t\t      IDENT_ERROR_ON_NO_NAME));\n}\n\nstatic int ends_rfc2822_footer(struct strbuf *sb)\n{\n\tint ch;\n\tint hit = 0;\n\tint i, j, k;\n\tint len = sb->len;\n\tint first = 1;\n\tconst char *buf = sb->buf;\n\n\tfor (i = len - 1; i > 0; i--) {\n\t\tif (hit && buf[i] == '\\n')\n\t\t\tbreak;\n\t\thit = (buf[i] == '\\n');\n\t}\n\n\twhile (i < len - 1 && buf[i] == '\\n')\n\t\ti++;\n\n\tfor (; i < len; i = k) {\n\t\tfor (k = i; k < len && buf[k] != '\\n'; k++)\n\t\t\t; /* do nothing */\n\t\tk++;\n\n\t\tif ((buf[k] == ' ' || buf[k] == '\\t') && !first)\n\t\t\tcontinue;\n\n\t\tfirst = 0;\n\n\t\tfor (j = 0; i + j < len; j++) {\n\t\t\tch = buf[i + j];\n\t\t\tif (ch == ':')\n\t\t\t\tbreak;\n\t\t\tif (isalnum(ch) ||\n\t\t\t    (ch == '-'))\n\t\t\t\tcontinue;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic char *cut_ident_timestamp_part(char *string)\n{\n\tchar *ket = strrchr(string, '>');\n\tif (!ket || ket[1] != ' ')\n\t\tdie(_(\"Malformed ident string: '%s'\"), string);\n\t*++ket = '\\0';\n\treturn ket;\n}\n\nstatic int prepare_to_commit(const char *index_file, const char *prefix,\n\t\t\t     struct wt_status *s,\n\t\t\t     struct strbuf *author_ident)\n{\n\tstruct stat statbuf;\n\tstruct strbuf committer_ident = STRBUF_INIT;\n\tint commitable, saved_color_setting;\n\tstruct strbuf sb = STRBUF_INIT;\n\tchar *buffer;\n\tconst char *hook_arg1 = NULL;\n\tconst char *hook_arg2 = NULL;\n\tint ident_shown = 0;\n\n\tif (!no_verify && run_hook(index_file, \"pre-commit\", NULL))\n\t\treturn 0;\n\n\tif (squash_message) {\n\t\t/*\n\t\t * Insert the proper subject line before other commit\n\t\t * message options add their content.\n\t\t */\n\t\tif (use_message && !strcmp(use_message, squash_message))\n\t\t\tstrbuf_addstr(&sb, \"squash! \");\n\t\telse {\n\t\t\tstruct pretty_print_context ctx = {0};\n\t\t\tstruct commit *c;\n\t\t\tc = lookup_commit_reference_by_name(squash_message);\n\t\t\tif (!c)\n\t\t\t\tdie(_(\"could not lookup commit %s\"), squash_message);\n\t\t\tctx.output_encoding = get_commit_output_encoding();\n\t\t\tformat_commit_message(c, \"squash! %s\\n\\n\", &sb,\n\t\t\t\t\t      &ctx);\n\t\t}\n\t}\n\n\tif (message.len) {\n\t\tstrbuf_addbuf(&sb, &message);\n\t\thook_arg1 = \"message\";\n\t} else if (logfile && !strcmp(logfile, \"-\")) {\n\t\tif (isatty(0))\n\t\t\tfprintf(stderr, _(\"(reading log message from standard input)\\n\"));\n\t\tif (strbuf_read(&sb, 0, 0) < 0)\n\t\t\tdie_errno(_(\"could not read log from standard input\"));\n\t\thook_arg1 = \"message\";\n\t} else if (logfile) {\n\t\tif (strbuf_read_file(&sb, logfile, 0) < 0)\n\t\t\tdie_errno(_(\"could not read log file '%s'\"),\n\t\t\t\t  logfile);\n\t\thook_arg1 = \"message\";\n\t} else if (use_message) {\n\t\tbuffer = strstr(use_message_buffer, \"\\n\\n\");\n\t\tif (!buffer || buffer[2] == '\\0')\n\t\t\tdie(_(\"commit has empty message\"));\n\t\tstrbuf_add(&sb, buffer + 2, strlen(buffer + 2));\n\t\thook_arg1 = \"commit\";\n\t\thook_arg2 = use_message;\n\t} else if (fixup_message) {\n\t\tstruct pretty_print_context ctx = {0};\n\t\tstruct commit *commit;\n\t\tcommit = lookup_commit_reference_by_name(fixup_message);\n\t\tif (!commit)\n\t\t\tdie(_(\"could not lookup commit %s\"), fixup_message);\n\t\tctx.output_encoding = get_commit_output_encoding();\n\t\tformat_commit_message(commit, \"fixup! %s\\n\\n\",\n\t\t\t\t      &sb, &ctx);\n\t\thook_arg1 = \"message\";\n\t} else if (!stat(git_path(\"MERGE_MSG\"), &statbuf)) {\n\t\tif (strbuf_read_file(&sb, git_path(\"MERGE_MSG\"), 0) < 0)\n\t\t\tdie_errno(_(\"could not read MERGE_MSG\"));\n\t\thook_arg1 = \"merge\";\n\t} else if (!stat(git_path(\"SQUASH_MSG\"), &statbuf)) {\n\t\tif (strbuf_read_file(&sb, git_path(\"SQUASH_MSG\"), 0) < 0)\n\t\t\tdie_errno(_(\"could not read SQUASH_MSG\"));\n\t\thook_arg1 = \"squash\";\n\t} else if (template_file) {\n\t\tif (strbuf_read_file(&sb, template_file, 0) < 0)\n\t\t\tdie_errno(_(\"could not read '%s'\"), template_file);\n\t\thook_arg1 = \"template\";\n\t}\n\n\t/*\n\t * The remaining cases don't modify the template message, but\n\t * just set the argument(s) to the prepare-commit-msg hook.\n\t */\n\telse if (whence == FROM_MERGE)\n\t\thook_arg1 = \"merge\";\n\telse if (whence == FROM_CHERRY_PICK) {\n\t\thook_arg1 = \"commit\";\n\t\thook_arg2 = \"CHERRY_PICK_HEAD\";\n\t}\n\n\tif (squash_message) {\n\t\t/*\n\t\t * If squash_commit was used for the commit subject,\n\t\t * then we're possibly hijacking other commit log options.\n\t\t * Reset the hook args to tell the real story.\n\t\t */\n\t\thook_arg1 = \"message\";\n\t\thook_arg2 = \"\";\n\t}\n\n\ts->fp = fopen(git_path(commit_editmsg), \"w\");\n\tif (s->fp == NULL)\n\t\tdie_errno(_(\"could not open '%s'\"), git_path(commit_editmsg));\n\n\tif (cleanup_mode != CLEANUP_NONE)\n\t\tstripspace(&sb, 0);\n\n\tif (signoff) {\n\t\tstruct strbuf sob = STRBUF_INIT;\n\t\tint i;\n\n\t\tstrbuf_addstr(&sob, sign_off_header);\n\t\tstrbuf_addstr(&sob, fmt_name(getenv(\"GIT_COMMITTER_NAME\"),\n\t\t\t\t\t     getenv(\"GIT_COMMITTER_EMAIL\")));\n\t\tstrbuf_addch(&sob, '\\n');\n\t\tfor (i = sb.len - 1; i > 0 && sb.buf[i - 1] != '\\n'; i--)\n\t\t\t; /* do nothing */\n\t\tif (prefixcmp(sb.buf + i, sob.buf)) {\n\t\t\tif (!i || !ends_rfc2822_footer(&sb))\n\t\t\t\tstrbuf_addch(&sb, '\\n');\n\t\t\tstrbuf_addbuf(&sb, &sob);\n\t\t}\n\t\tstrbuf_release(&sob);\n\t}\n\n\tif (fwrite(sb.buf, 1, sb.len, s->fp) < sb.len)\n\t\tdie_errno(_(\"could not write commit template\"));\n\n\tstrbuf_release(&sb);\n\n\t/* This checks and barfs if author is badly specified */\n\tdetermine_author_info(author_ident);\n\n\t/* This checks if committer ident is explicitly given */\n\tstrbuf_addstr(&committer_ident, git_committer_info(0));\n\tif (use_editor && include_status) {\n\t\tchar *ai_tmp, *ci_tmp;\n\t\tif (whence != FROM_COMMIT)\n\t\t\tstatus_printf_ln(s, GIT_COLOR_NORMAL,\n\t\t\t\t_(\"\\n\"\n\t\t\t\t\"It looks like you may be committing a %s.\\n\"\n\t\t\t\t\"If this is not correct, please remove the file\\n\"\n\t\t\t\t\"\t%s\\n\"\n\t\t\t\t\"and try again.\\n\"\n\t\t\t\t\"\"),\n\t\t\t\twhence_s(),\n\t\t\t\tgit_path(whence == FROM_MERGE\n\t\t\t\t\t ? \"MERGE_HEAD\"\n\t\t\t\t\t : \"CHERRY_PICK_HEAD\"));\n\n\t\tfprintf(s->fp, \"\\n\");\n\t\tstatus_printf(s, GIT_COLOR_NORMAL,\n\t\t\t_(\"Please enter the commit message for your changes.\"));\n\t\tif (cleanup_mode == CLEANUP_ALL)\n\t\t\tstatus_printf_more(s, GIT_COLOR_NORMAL,\n\t\t\t\t_(\" Lines starting\\n\"\n\t\t\t\t\"with '#' will be ignored, and an empty\"\n\t\t\t\t\" message aborts the commit.\\n\"));\n\t\telse /* CLEANUP_SPACE, that is. */\n\t\t\tstatus_printf_more(s, GIT_COLOR_NORMAL,\n\t\t\t\t_(\" Lines starting\\n\"\n\t\t\t\t\"with '#' will be kept; you may remove them\"\n\t\t\t\t\" yourself if you want to.\\n\"\n\t\t\t\t\"An empty message aborts the commit.\\n\"));\n\t\tif (only_include_assumed)\n\t\t\tstatus_printf_ln(s, GIT_COLOR_NORMAL,\n\t\t\t\t\t\"%s\", only_include_assumed);\n\n\t\tai_tmp = cut_ident_timestamp_part(author_ident->buf);\n\t\tci_tmp = cut_ident_timestamp_part(committer_ident.buf);\n\t\tif (strcmp(author_ident->buf, committer_ident.buf))\n\t\t\tstatus_printf_ln(s, GIT_COLOR_NORMAL,\n\t\t\t\t_(\"%s\"\n\t\t\t\t\"Author:    %s\"),\n\t\t\t\tident_shown++ ? \"\" : \"\\n\",\n\t\t\t\tauthor_ident->buf);\n\n\t\tif (!user_ident_sufficiently_given())\n\t\t\tstatus_printf_ln(s, GIT_COLOR_NORMAL,\n\t\t\t\t_(\"%s\"\n\t\t\t\t\"Committer: %s\"),\n\t\t\t\tident_shown++ ? \"\" : \"\\n\",\n\t\t\t\tcommitter_ident.buf);\n\n\t\tif (ident_shown)\n\t\t\tstatus_printf_ln(s, GIT_COLOR_NORMAL, \"\");\n\n\t\tsaved_color_setting = s->use_color;\n\t\ts->use_color = 0;\n\t\tcommitable = run_status(s->fp, index_file, prefix, 1, s);\n\t\ts->use_color = saved_color_setting;\n\n\t\t*ai_tmp = ' ';\n\t\t*ci_tmp = ' ';\n\t} else {\n\t\tunsigned char sha1[20];\n\t\tconst char *parent = \"HEAD\";\n\n\t\tif (!active_nr && read_cache() < 0)\n\t\t\tdie(_(\"Cannot read index\"));\n\n\t\tif (amend)\n\t\t\tparent = \"HEAD^1\";\n\n\t\tif (get_sha1(parent, sha1))\n\t\t\tcommitable = !!active_nr;\n\t\telse\n\t\t\tcommitable = index_differs_from(parent, 0);\n\t}\n\tstrbuf_release(&committer_ident);\n\n\tfclose(s->fp);\n\n\t/*\n\t * Reject an attempt to record a non-merge empty commit without\n\t * explicit --allow-empty. In the cherry-pick case, it may be\n\t * empty due to conflict resolution, which the user should okay.\n\t */\n\tif (!commitable && whence != FROM_MERGE && !allow_empty &&\n\t    !(amend && is_a_merge(head_sha1))) {\n\t\trun_status(stdout, index_file, prefix, 0, s);\n\t\tif (amend)\n\t\t\tfputs(_(empty_amend_advice), stderr);\n\t\telse if (whence == FROM_CHERRY_PICK)\n\t\t\tfputs(_(empty_cherry_pick_advice), stderr);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Re-read the index as pre-commit hook could have updated it,\n\t * and write it out as a tree.  We must do this before we invoke\n\t * the editor and after we invoke run_status above.\n\t */\n\tdiscard_cache();\n\tread_cache_from(index_file);\n\tif (!active_cache_tree)\n\t\tactive_cache_tree = cache_tree();\n\tif (cache_tree_update(active_cache_tree,\n\t\t\t      active_cache, active_nr, 0, 0) < 0) {\n\t\terror(_(\"Error building trees\"));\n\t\treturn 0;\n\t}\n\n\tif (run_hook(index_file, \"prepare-commit-msg\",\n\t\t     git_path(commit_editmsg), hook_arg1, hook_arg2, NULL))\n\t\treturn 0;\n\n\tif (use_editor) {\n\t\tchar index[PATH_MAX];\n\t\tconst char *env[2] = { NULL };\n\t\tenv[0] =  index;\n\t\tsnprintf(index, sizeof(index), \"GIT_INDEX_FILE=%s\", index_file);\n\t\tif (launch_editor(git_path(commit_editmsg), NULL, env)) {\n\t\t\tfprintf(stderr,\n\t\t\t_(\"Please supply the message using either -m or -F option.\\n\"));\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif (!no_verify &&\n\t    run_hook(index_file, \"commit-msg\", git_path(commit_editmsg), NULL)) {\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n/*\n * Find out if the message in the strbuf contains only whitespace and\n * Signed-off-by lines.\n */\nstatic int message_is_empty(struct strbuf *sb)\n{\n\tstruct strbuf tmpl = STRBUF_INIT;\n\tconst char *nl;\n\tint eol, i, start = 0;\n\n\tif (cleanup_mode == CLEANUP_NONE && sb->len)\n\t\treturn 0;\n\n\t/* See if the template is just a prefix of the message. */\n\tif (template_file && strbuf_read_file(&tmpl, template_file, 0) > 0) {\n\t\tstripspace(&tmpl, cleanup_mode == CLEANUP_ALL);\n\t\tif (start + tmpl.len <= sb->len &&\n\t\t    memcmp(tmpl.buf, sb->buf + start, tmpl.len) == 0)\n\t\t\tstart += tmpl.len;\n\t}\n\tstrbuf_release(&tmpl);\n\n\t/* Check if the rest is just whitespace and Signed-of-by's. */\n\tfor (i = start; i < sb->len; i++) {\n\t\tnl = memchr(sb->buf + i, '\\n', sb->len - i);\n\t\tif (nl)\n\t\t\teol = nl - sb->buf;\n\t\telse\n\t\t\teol = sb->len;\n\n\t\tif (strlen(sign_off_header) <= eol - i &&\n\t\t    !prefixcmp(sb->buf + i, sign_off_header)) {\n\t\t\ti = eol;\n\t\t\tcontinue;\n\t\t}\n\t\twhile (i < eol)\n\t\t\tif (!isspace(sb->buf[i++]))\n\t\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic const char *find_author_by_nickname(const char *name)\n{\n\tstruct rev_info revs;\n\tstruct commit *commit;\n\tstruct strbuf buf = STRBUF_INIT;\n\tconst char *av[20];\n\tint ac = 0;\n\n\tinit_revisions(&revs, NULL);\n\tstrbuf_addf(&buf, \"--author=%s\", name);\n\tav[++ac] = \"--all\";\n\tav[++ac] = \"-i\";\n\tav[++ac] = buf.buf;\n\tav[++ac] = NULL;\n\tsetup_revisions(ac, av, &revs, NULL);\n\tprepare_revision_walk(&revs);\n\tcommit = get_revision(&revs);\n\tif (commit) {\n\t\tstruct pretty_print_context ctx = {0};\n\t\tctx.date_mode = DATE_NORMAL;\n\t\tstrbuf_release(&buf);\n\t\tformat_commit_message(commit, \"%an <%ae>\", &buf, &ctx);\n\t\treturn strbuf_detach(&buf, NULL);\n\t}\n\tdie(_(\"No existing author found with '%s'\"), name);\n}\n\n\nstatic void handle_untracked_files_arg(struct wt_status *s)\n{\n\tif (!untracked_files_arg)\n\t\t; /* default already initialized */\n\telse if (!strcmp(untracked_files_arg, \"no\"))\n\t\ts->show_untracked_files = SHOW_NO_UNTRACKED_FILES;\n\telse if (!strcmp(untracked_files_arg, \"normal\"))\n\t\ts->show_untracked_files = SHOW_NORMAL_UNTRACKED_FILES;\n\telse if (!strcmp(untracked_files_arg, \"all\"))\n\t\ts->show_untracked_files = SHOW_ALL_UNTRACKED_FILES;\n\telse\n\t\tdie(_(\"Invalid untracked files mode '%s'\"), untracked_files_arg);\n}\n\nstatic const char *read_commit_message(const char *name)\n{\n\tconst char *out_enc, *out;\n\tstruct commit *commit;\n\n\tcommit = lookup_commit_reference_by_name(name);\n\tif (!commit)\n\t\tdie(_(\"could not lookup commit %s\"), name);\n\tout_enc = get_commit_output_encoding();\n\tout = logmsg_reencode(commit, out_enc);\n\n\t/*\n\t * If we failed to reencode the buffer, just copy it\n\t * byte for byte so the user can try to fix it up.\n\t * This also handles the case where input and output\n\t * encodings are identical.\n\t */\n\tif (out == NULL)\n\t\tout = xstrdup(commit->buffer);\n\treturn out;\n}\n\nstatic int parse_and_validate_options(int argc, const char *argv[],\n\t\t\t\t      const char * const usage[],\n\t\t\t\t      const char *prefix,\n\t\t\t\t      struct wt_status *s)\n{\n\tint f = 0;\n\n\targc = parse_options(argc, argv, prefix, builtin_commit_options, usage,\n\t\t\t     0);\n\n\tif (force_author && !strchr(force_author, '>'))\n\t\tforce_author = find_author_by_nickname(force_author);\n\n\tif (force_author && renew_authorship)\n\t\tdie(_(\"Using both --reset-author and --author does not make sense\"));\n\n\tif (logfile || message.len || use_message || fixup_message)\n\t\tuse_editor = 0;\n\tif (edit_flag)\n\t\tuse_editor = 1;\n\tif (!use_editor)\n\t\tsetenv(\"GIT_EDITOR\", \":\", 1);\n\n\tif (get_sha1(\"HEAD\", head_sha1))\n\t\tinitial_commit = 1;\n\n\t/* Sanity check options */\n\tif (amend && initial_commit)\n\t\tdie(_(\"You have nothing to amend.\"));\n\tif (amend && whence != FROM_COMMIT)\n\t\tdie(_(\"You are in the middle of a %s -- cannot amend.\"), whence_s());\n\tif (fixup_message && squash_message)\n\t\tdie(_(\"Options --squash and --fixup cannot be used together\"));\n\tif (use_message)\n\t\tf++;\n\tif (edit_message)\n\t\tf++;\n\tif (fixup_message)\n\t\tf++;\n\tif (logfile)\n\t\tf++;\n\tif (f > 1)\n\t\tdie(_(\"Only one of -c/-C/-F/--fixup can be used.\"));\n\tif (message.len && f > 0)\n\t\tdie((_(\"Option -m cannot be combined with -c/-C/-F/--fixup.\")));\n\tif (edit_message)\n\t\tuse_message = edit_message;\n\tif (amend && !use_message && !fixup_message)\n\t\tuse_message = \"HEAD\";\n\tif (!use_message && whence != FROM_CHERRY_PICK && renew_authorship)\n\t\tdie(_(\"--reset-author can be used only with -C, -c or --amend.\"));\n\tif (use_message) {\n\t\tuse_message_buffer = read_commit_message(use_message);\n\t\tif (!renew_authorship) {\n\t\t\tauthor_message = use_message;\n\t\t\tauthor_message_buffer = use_message_buffer;\n\t\t}\n\t}\n\tif (whence == FROM_CHERRY_PICK && !renew_authorship) {\n\t\tauthor_message = \"CHERRY_PICK_HEAD\";\n\t\tauthor_message_buffer = read_commit_message(author_message);\n\t}\n\n\tif (patch_interactive)\n\t\tinteractive = 1;\n\n\tif (!!also + !!only + !!all + !!interactive > 1)\n\t\tdie(_(\"Only one of --include/--only/--all/--interactive/--patch can be used.\"));\n\tif (argc == 0 && (also || (only && !amend)))\n\t\tdie(_(\"No paths with --include/--only does not make sense.\"));\n\tif (argc == 0 && only && amend)\n\t\tonly_include_assumed = _(\"Clever... amending the last one with dirty index.\");\n\tif (argc > 0 && !also && !only)\n\t\tonly_include_assumed = _(\"Explicit paths specified without -i nor -o; assuming --only paths...\");\n\tif (!cleanup_arg || !strcmp(cleanup_arg, \"default\"))\n\t\tcleanup_mode = use_editor ? CLEANUP_ALL : CLEANUP_SPACE;\n\telse if (!strcmp(cleanup_arg, \"verbatim\"))\n\t\tcleanup_mode = CLEANUP_NONE;\n\telse if (!strcmp(cleanup_arg, \"whitespace\"))\n\t\tcleanup_mode = CLEANUP_SPACE;\n\telse if (!strcmp(cleanup_arg, \"strip\"))\n\t\tcleanup_mode = CLEANUP_ALL;\n\telse\n\t\tdie(_(\"Invalid cleanup mode %s\"), cleanup_arg);\n\n\thandle_untracked_files_arg(s);\n\n\tif (all && argc > 0)\n\t\tdie(_(\"Paths with -a does not make sense.\"));\n\n\tif (null_termination && status_format == STATUS_FORMAT_LONG)\n\t\tstatus_format = STATUS_FORMAT_PORCELAIN;\n\tif (status_format != STATUS_FORMAT_LONG)\n\t\tdry_run = 1;\n\n\treturn argc;\n}\n\nstatic int dry_run_commit(int argc, const char **argv, const char *prefix,\n\t\t\t  struct wt_status *s)\n{\n\tint commitable;\n\tconst char *index_file;\n\n\tindex_file = prepare_index(argc, argv, prefix, 1);\n\tcommitable = run_status(stdout, index_file, prefix, 0, s);\n\trollback_index_files();\n\n\treturn commitable ? 0 : 1;\n}\n\nstatic int parse_status_slot(const char *var, int offset)\n{\n\tif (!strcasecmp(var+offset, \"header\"))\n\t\treturn WT_STATUS_HEADER;\n\tif (!strcasecmp(var+offset, \"branch\"))\n\t\treturn WT_STATUS_ONBRANCH;\n\tif (!strcasecmp(var+offset, \"updated\")\n\t\t|| !strcasecmp(var+offset, \"added\"))\n\t\treturn WT_STATUS_UPDATED;\n\tif (!strcasecmp(var+offset, \"changed\"))\n\t\treturn WT_STATUS_CHANGED;\n\tif (!strcasecmp(var+offset, \"untracked\"))\n\t\treturn WT_STATUS_UNTRACKED;\n\tif (!strcasecmp(var+offset, \"nobranch\"))\n\t\treturn WT_STATUS_NOBRANCH;\n\tif (!strcasecmp(var+offset, \"unmerged\"))\n\t\treturn WT_STATUS_UNMERGED;\n\treturn -1;\n}\n\nstatic int git_status_config(const char *k, const char *v, void *cb)\n{\n\tstruct wt_status *s = cb;\n\n\tif (!strcmp(k, \"status.submodulesummary\")) {\n\t\tint is_bool;\n\t\ts->submodule_summary = git_config_bool_or_int(k, v, &is_bool);\n\t\tif (is_bool && s->submodule_summary)\n\t\t\ts->submodule_summary = -1;\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"status.color\") || !strcmp(k, \"color.status\")) {\n\t\ts->use_color = git_config_colorbool(k, v, -1);\n\t\treturn 0;\n\t}\n\tif (!prefixcmp(k, \"status.color.\") || !prefixcmp(k, \"color.status.\")) {\n\t\tint slot = parse_status_slot(k, 13);\n\t\tif (slot < 0)\n\t\t\treturn 0;\n\t\tif (!v)\n\t\t\treturn config_error_nonbool(k);\n\t\tcolor_parse(v, k, s->color_palette[slot]);\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"status.relativepaths\")) {\n\t\ts->relative_paths = git_config_bool(k, v);\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"status.showuntrackedfiles\")) {\n\t\tif (!v)\n\t\t\treturn config_error_nonbool(k);\n\t\telse if (!strcmp(v, \"no\"))\n\t\t\ts->show_untracked_files = SHOW_NO_UNTRACKED_FILES;\n\t\telse if (!strcmp(v, \"normal\"))\n\t\t\ts->show_untracked_files = SHOW_NORMAL_UNTRACKED_FILES;\n\t\telse if (!strcmp(v, \"all\"))\n\t\t\ts->show_untracked_files = SHOW_ALL_UNTRACKED_FILES;\n\t\telse\n\t\t\treturn error(_(\"Invalid untracked files mode '%s'\"), v);\n\t\treturn 0;\n\t}\n\treturn git_diff_ui_config(k, v, NULL);\n}\n\nint cmd_status(int argc, const char **argv, const char *prefix)\n{\n\tstruct wt_status s;\n\tint fd;\n\tunsigned char sha1[20];\n\tstatic struct option builtin_status_options[] = {\n\t\tOPT__VERBOSE(&verbose, \"be verbose\"),\n\t\tOPT_SET_INT('s', \"short\", &status_format,\n\t\t\t    \"show status concisely\", STATUS_FORMAT_SHORT),\n\t\tOPT_BOOLEAN('b', \"branch\", &status_show_branch,\n\t\t\t    \"show branch information\"),\n\t\tOPT_SET_INT(0, \"porcelain\", &status_format,\n\t\t\t    \"machine-readable output\",\n\t\t\t    STATUS_FORMAT_PORCELAIN),\n\t\tOPT_BOOLEAN('z', \"null\", &null_termination,\n\t\t\t    \"terminate entries with NUL\"),\n\t\t{ OPTION_STRING, 'u', \"untracked-files\", &untracked_files_arg,\n\t\t  \"mode\",\n\t\t  \"show untracked files, optional modes: all, normal, no. (Default: all)\",\n\t\t  PARSE_OPT_OPTARG, NULL, (intptr_t)\"all\" },\n\t\tOPT_BOOLEAN(0, \"ignored\", &show_ignored_in_status,\n\t\t\t    \"show ignored files\"),\n\t\t{ OPTION_STRING, 0, \"ignore-submodules\", &ignore_submodule_arg, \"when\",\n\t\t  \"ignore changes to submodules, optional when: all, dirty, untracked. (Default: all)\",\n\t\t  PARSE_OPT_OPTARG, NULL, (intptr_t)\"all\" },\n\t\tOPT_END(),\n\t};\n\n\tif (argc == 2 && !strcmp(argv[1], \"-h\"))\n\t\tusage_with_options(builtin_status_usage, builtin_status_options);\n\n\tif (null_termination && status_format == STATUS_FORMAT_LONG)\n\t\tstatus_format = STATUS_FORMAT_PORCELAIN;\n\n\twt_status_prepare(&s);\n\tgitmodules_config();\n\tgit_config(git_status_config, &s);\n\tdetermine_whence(&s);\n\targc = parse_options(argc, argv, prefix,\n\t\t\t     builtin_status_options,\n\t\t\t     builtin_status_usage, 0);\n\thandle_untracked_files_arg(&s);\n\tif (show_ignored_in_status)\n\t\ts.show_ignored_files = 1;\n\tif (*argv)\n\t\ts.pathspec = get_pathspec(prefix, argv);\n\n\tread_cache_preload(s.pathspec);\n\trefresh_index(&the_index, REFRESH_QUIET|REFRESH_UNMERGED, s.pathspec, NULL, NULL);\n\n\tfd = hold_locked_index(&index_lock, 0);\n\tif (0 <= fd)\n\t\tupdate_index_if_able(&the_index, &index_lock);\n\n\ts.is_initial = get_sha1(s.reference, sha1) ? 1 : 0;\n\ts.ignore_submodule_arg = ignore_submodule_arg;\n\twt_status_collect(&s);\n\n\tif (s.relative_paths)\n\t\ts.prefix = prefix;\n\tif (s.use_color == -1)\n\t\ts.use_color = git_use_color_default;\n\tif (diff_use_color_default == -1)\n\t\tdiff_use_color_default = git_use_color_default;\n\n\tswitch (status_format) {\n\tcase STATUS_FORMAT_SHORT:\n\t\twt_shortstatus_print(&s, null_termination, status_show_branch);\n\t\tbreak;\n\tcase STATUS_FORMAT_PORCELAIN:\n\t\twt_porcelain_print(&s, null_termination);\n\t\tbreak;\n\tcase STATUS_FORMAT_LONG:\n\t\ts.verbose = verbose;\n\t\ts.ignore_submodule_arg = ignore_submodule_arg;\n\t\twt_status_print(&s);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void print_summary(const char *prefix, const unsigned char *sha1)\n{\n\tstruct rev_info rev;\n\tstruct commit *commit;\n\tstruct strbuf format = STRBUF_INIT;\n\tunsigned char junk_sha1[20];\n\tconst char *head = resolve_ref(\"HEAD\", junk_sha1, 0, NULL);\n\tstruct pretty_print_context pctx = {0};\n\tstruct strbuf author_ident = STRBUF_INIT;\n\tstruct strbuf committer_ident = STRBUF_INIT;\n\n\tcommit = lookup_commit(sha1);\n\tif (!commit)\n\t\tdie(_(\"couldn't look up newly created commit\"));\n\tif (!commit || parse_commit(commit))\n\t\tdie(_(\"could not parse newly created commit\"));\n\n\tstrbuf_addstr(&format, \"format:%h] %s\");\n\n\tformat_commit_message(commit, \"%an <%ae>\", &author_ident, &pctx);\n\tformat_commit_message(commit, \"%cn <%ce>\", &committer_ident, &pctx);\n\tif (strbuf_cmp(&author_ident, &committer_ident)) {\n\t\tstrbuf_addstr(&format, \"\\n Author: \");\n\t\tstrbuf_addbuf_percentquote(&format, &author_ident);\n\t}\n\tif (!user_ident_sufficiently_given()) {\n\t\tstrbuf_addstr(&format, \"\\n Committer: \");\n\t\tstrbuf_addbuf_percentquote(&format, &committer_ident);\n\t\tif (advice_implicit_identity) {\n\t\t\tstrbuf_addch(&format, '\\n');\n\t\t\tstrbuf_addstr(&format, _(implicit_ident_advice));\n\t\t}\n\t}\n\tstrbuf_release(&author_ident);\n\tstrbuf_release(&committer_ident);\n\n\tinit_revisions(&rev, prefix);\n\tsetup_revisions(0, NULL, &rev, NULL);\n\n\trev.diff = 1;\n\trev.diffopt.output_format =\n\t\tDIFF_FORMAT_SHORTSTAT | DIFF_FORMAT_SUMMARY;\n\n\trev.verbose_header = 1;\n\trev.show_root_diff = 1;\n\tget_commit_format(format.buf, &rev);\n\trev.always_show_header = 0;\n\trev.diffopt.detect_rename = 1;\n\trev.diffopt.break_opt = 0;\n\tdiff_setup_done(&rev.diffopt);\n\n\tprintf(\"[%s%s \",\n\t\t!prefixcmp(head, \"refs/heads/\") ?\n\t\t\thead + 11 :\n\t\t\t!strcmp(head, \"HEAD\") ?\n\t\t\t\t_(\"detached HEAD\") :\n\t\t\t\thead,\n\t\tinitial_commit ? _(\" (root-commit)\") : \"\");\n\n\tif (!log_tree_commit(&rev, commit)) {\n\t\trev.always_show_header = 1;\n\t\trev.use_terminator = 1;\n\t\tlog_tree_commit(&rev, commit);\n\t}\n\n\tstrbuf_release(&format);\n}\n\nstatic int git_commit_config(const char *k, const char *v, void *cb)\n{\n\tstruct wt_status *s = cb;\n\n\tif (!strcmp(k, \"commit.template\"))\n\t\treturn git_config_pathname(&template_file, k, v);\n\tif (!strcmp(k, \"commit.status\")) {\n\t\tinclude_status = git_config_bool(k, v);\n\t\treturn 0;\n\t}\n\n\treturn git_status_config(k, v, s);\n}\n\nstatic const char post_rewrite_hook[] = \"hooks/post-rewrite\";\n\nstatic int run_rewrite_hook(const unsigned char *oldsha1,\n\t\t\t    const unsigned char *newsha1)\n{\n\t/* oldsha1 SP newsha1 LF NUL */\n\tstatic char buf[2*40 + 3];\n\tstruct child_process proc;\n\tconst char *argv[3];\n\tint code;\n\tsize_t n;\n\n\tif (access(git_path(post_rewrite_hook), X_OK) < 0)\n\t\treturn 0;\n\n\targv[0] = git_path(post_rewrite_hook);\n\targv[1] = \"amend\";\n\targv[2] = NULL;\n\n\tmemset(&proc, 0, sizeof(proc));\n\tproc.argv = argv;\n\tproc.in = -1;\n\tproc.stdout_to_stderr = 1;\n\n\tcode = start_command(&proc);\n\tif (code)\n\t\treturn code;\n\tn = snprintf(buf, sizeof(buf), \"%s %s\\n\",\n\t\t     sha1_to_hex(oldsha1), sha1_to_hex(newsha1));\n\twrite_in_full(proc.in, buf, n);\n\tclose(proc.in);\n\treturn finish_command(&proc);\n}\n\nint cmd_commit(int argc, const char **argv, const char *prefix)\n{\n\tstruct strbuf sb = STRBUF_INIT;\n\tstruct strbuf author_ident = STRBUF_INIT;\n\tconst char *index_file, *reflog_msg;\n\tchar *nl, *p;\n\tunsigned char commit_sha1[20];\n\tstruct ref_lock *ref_lock;\n\tstruct commit_list *parents = NULL, **pptr = &parents;\n\tstruct stat statbuf;\n\tint allow_fast_forward = 1;\n\tstruct wt_status s;\n\n\tif (argc == 2 && !strcmp(argv[1], \"-h\"))\n\t\tusage_with_options(builtin_commit_usage, builtin_commit_options);\n\n\twt_status_prepare(&s);\n\tgit_config(git_commit_config, &s);\n\tdetermine_whence(&s);\n\n\tif (s.use_color == -1)\n\t\ts.use_color = git_use_color_default;\n\targc = parse_and_validate_options(argc, argv, builtin_commit_usage,\n\t\t\t\t\t  prefix, &s);\n\tif (dry_run) {\n\t\tif (diff_use_color_default == -1)\n\t\t\tdiff_use_color_default = git_use_color_default;\n\t\treturn dry_run_commit(argc, argv, prefix, &s);\n\t}\n\tindex_file = prepare_index(argc, argv, prefix, 0);\n\n\t/* Set up everything for writing the commit object.  This includes\n\t   running hooks, writing the trees, and interacting with the user.  */\n\tif (!prepare_to_commit(index_file, prefix, &s, &author_ident)) {\n\t\trollback_index_files();\n\t\treturn 1;\n\t}\n\n\t/* Determine parents */\n\treflog_msg = getenv(\"GIT_REFLOG_ACTION\");\n\tif (initial_commit) {\n\t\tif (!reflog_msg)\n\t\t\treflog_msg = \"commit (initial)\";\n\t} else if (amend) {\n\t\tstruct commit_list *c;\n\t\tstruct commit *commit;\n\n\t\tif (!reflog_msg)\n\t\t\treflog_msg = \"commit (amend)\";\n\t\tcommit = lookup_commit(head_sha1);\n\t\tif (!commit || parse_commit(commit))\n\t\t\tdie(_(\"could not parse HEAD commit\"));\n\n\t\tfor (c = commit->parents; c; c = c->next)\n\t\t\tpptr = &commit_list_insert(c->item, pptr)->next;\n\t} else if (whence == FROM_MERGE) {\n\t\tstruct strbuf m = STRBUF_INIT;\n\t\tFILE *fp;\n\n\t\tif (!reflog_msg)\n\t\t\treflog_msg = \"commit (merge)\";\n\t\tpptr = &commit_list_insert(lookup_commit(head_sha1), pptr)->next;\n\t\tfp = fopen(git_path(\"MERGE_HEAD\"), \"r\");\n\t\tif (fp == NULL)\n\t\t\tdie_errno(_(\"could not open '%s' for reading\"),\n\t\t\t\t  git_path(\"MERGE_HEAD\"));\n\t\twhile (strbuf_getline(&m, fp, '\\n') != EOF) {\n\t\t\tunsigned char sha1[20];\n\t\t\tif (get_sha1_hex(m.buf, sha1) < 0)\n\t\t\t\tdie(_(\"Corrupt MERGE_HEAD file (%s)\"), m.buf);\n\t\t\tpptr = &commit_list_insert(lookup_commit(sha1), pptr)->next;\n\t\t}\n\t\tfclose(fp);\n\t\tstrbuf_release(&m);\n\t\tif (!stat(git_path(\"MERGE_MODE\"), &statbuf)) {\n\t\t\tif (strbuf_read_file(&sb, git_path(\"MERGE_MODE\"), 0) < 0)\n\t\t\t\tdie_errno(_(\"could not read MERGE_MODE\"));\n\t\t\tif (!strcmp(sb.buf, \"no-ff\"))\n\t\t\t\tallow_fast_forward = 0;\n\t\t}\n\t\tif (allow_fast_forward)\n\t\t\tparents = reduce_heads(parents);\n\t} else {\n\t\tif (!reflog_msg)\n\t\t\treflog_msg = (whence == FROM_CHERRY_PICK)\n\t\t\t\t\t? \"commit (cherry-pick)\"\n\t\t\t\t\t: \"commit\";\n\t\tpptr = &commit_list_insert(lookup_commit(head_sha1), pptr)->next;\n\t}\n\n\t/* Finally, get the commit message */\n\tstrbuf_reset(&sb);\n\tif (strbuf_read_file(&sb, git_path(commit_editmsg), 0) < 0) {\n\t\tint saved_errno = errno;\n\t\trollback_index_files();\n\t\tdie(_(\"could not read commit message: %s\"), strerror(saved_errno));\n\t}\n\n\t/* Truncate the message just before the diff, if any. */\n\tif (verbose) {\n\t\tp = strstr(sb.buf, \"\\ndiff --git \");\n\t\tif (p != NULL)\n\t\t\tstrbuf_setlen(&sb, p - sb.buf + 1);\n\t}\n\n\tif (cleanup_mode != CLEANUP_NONE)\n\t\tstripspace(&sb, cleanup_mode == CLEANUP_ALL);\n\tif (message_is_empty(&sb) && !allow_empty_message) {\n\t\trollback_index_files();\n\t\tfprintf(stderr, _(\"Aborting commit due to empty commit message.\\n\"));\n\t\texit(1);\n\t}\n\n\tif (commit_tree(sb.buf, active_cache_tree->sha1, parents, commit_sha1,\n\t\t\tauthor_ident.buf)) {\n\t\trollback_index_files();\n\t\tdie(_(\"failed to write commit object\"));\n\t}\n\tstrbuf_release(&author_ident);\n\n\tref_lock = lock_any_ref_for_update(\"HEAD\",\n\t\t\t\t\t   initial_commit ? NULL : head_sha1,\n\t\t\t\t\t   0);\n\n\tnl = strchr(sb.buf, '\\n');\n\tif (nl)\n\t\tstrbuf_setlen(&sb, nl + 1 - sb.buf);\n\telse\n\t\tstrbuf_addch(&sb, '\\n');\n\tstrbuf_insert(&sb, 0, reflog_msg, strlen(reflog_msg));\n\tstrbuf_insert(&sb, strlen(reflog_msg), \": \", 2);\n\n\tif (!ref_lock) {\n\t\trollback_index_files();\n\t\tdie(_(\"cannot lock HEAD ref\"));\n\t}\n\tif (write_ref_sha1(ref_lock, commit_sha1, sb.buf) < 0) {\n\t\trollback_index_files();\n\t\tdie(_(\"cannot update HEAD ref\"));\n\t}\n\n\tunlink(git_path(\"CHERRY_PICK_HEAD\"));\n\tunlink(git_path(\"MERGE_HEAD\"));\n\tunlink(git_path(\"MERGE_MSG\"));\n\tunlink(git_path(\"MERGE_MODE\"));\n\tunlink(git_path(\"SQUASH_MSG\"));\n\n\tif (commit_index_files())\n\t\tdie (_(\"Repository has been updated, but unable to write\\n\"\n\t\t     \"new_index file. Check that disk is not full or quota is\\n\"\n\t\t     \"not exceeded, and then \\\"git reset HEAD\\\" to recover.\"));\n\n\trerere(0);\n\trun_hook(get_index_file(), \"post-commit\", NULL);\n\tif (amend && !no_post_rewrite) {\n\t\tstruct notes_rewrite_cfg *cfg;\n\t\tcfg = init_copy_notes_for_rewrite(\"amend\");\n\t\tif (cfg) {\n\t\t\tcopy_note_for_rewrite(cfg, head_sha1, commit_sha1);\n\t\t\tfinish_copy_notes_for_rewrite(cfg);\n\t\t}\n\t\trun_rewrite_hook(head_sha1, commit_sha1);\n\t}\n\tif (!quiet)\n\t\tprint_summary(prefix, commit_sha1);\n\n\treturn 0;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "008c1ec8380af17de62452dbf580c0c81912bf8e",
  "sha1_ok": true,
  "size": 43917
}
