{
  "content": {
    "base64": "I2luY2x1ZGUgImdpdC1jb21wYXQtdXRpbC5oIgojaW5jbHVkZSAiYWJzcGF0aC5oIgojaW5jbHVkZSAiYWR2aWNlLmgiCiNpbmNsdWRlICJnZXR0ZXh0LmgiCiNpbmNsdWRlICJob29rLmgiCiNpbmNsdWRlICJwYXRoLmgiCiNpbmNsdWRlICJydW4tY29tbWFuZC5oIgojaW5jbHVkZSAiY29uZmlnLmgiCiNpbmNsdWRlICJzdHJidWYuaCIKI2luY2x1ZGUgImVudmlyb25tZW50LmgiCiNpbmNsdWRlICJzZXR1cC5oIgoKY29uc3QgY2hhciAqZmluZF9ob29rKHN0cnVjdCByZXBvc2l0b3J5ICpyLCBjb25zdCBjaGFyICpuYW1lKQp7CglzdGF0aWMgc3RydWN0IHN0cmJ1ZiBwYXRoID0gU1RSQlVGX0lOSVQ7CgoJaW50IGZvdW5kX2hvb2s7CgoJcmVwb19naXRfcGF0aF9yZXBsYWNlKHIsICZwYXRoLCAiaG9va3MvJXMiLCBuYW1lKTsKCWZvdW5kX2hvb2sgPSBhY2Nlc3MocGF0aC5idWYsIFhfT0spID49IDA7CiNpZmRlZiBTVFJJUF9FWFRFTlNJT04KCWlmICghZm91bmRfaG9vaykgewoJCWludCBlcnIgPSBlcnJubzsKCgkJc3RyYnVmX2FkZHN0cigmcGF0aCwgU1RSSVBfRVhURU5TSU9OKTsKCQlmb3VuZF9ob29rID0gYWNjZXNzKHBhdGguYnVmLCBYX09LKSA+PSAwOwoJCWlmICghZm91bmRfaG9vaykKCQkJZXJybm8gPSBlcnI7Cgl9CiNlbmRpZgoKCWlmICghZm91bmRfaG9vaykgewoJCWlmIChlcnJubyA9PSBFQUNDRVMgJiYgYWR2aWNlX2VuYWJsZWQoQURWSUNFX0lHTk9SRURfSE9PSykpIHsKCQkJc3RhdGljIHN0cnVjdCBzdHJpbmdfbGlzdCBhZHZpc2VfZ2l2ZW4gPSBTVFJJTkdfTElTVF9JTklUX0RVUDsKCgkJCWlmICghc3RyaW5nX2xpc3RfbG9va3VwKCZhZHZpc2VfZ2l2ZW4sIG5hbWUpKSB7CgkJCQlzdHJpbmdfbGlzdF9pbnNlcnQoJmFkdmlzZV9naXZlbiwgbmFtZSk7CgkJCQlhZHZpc2UoXygiVGhlICclcycgaG9vayB3YXMgaWdub3JlZCBiZWNhdXNlICIKCQkJCQkgIml0J3Mgbm90IHNldCBhcyBleGVjdXRhYmxlLlxuIgoJCQkJCSAiWW91IGNhbiBkaXNhYmxlIHRoaXMgd2FybmluZyB3aXRoICIKCQkJCQkgImBnaXQgY29uZmlnIHNldCBhZHZpY2UuaWdub3JlZEhvb2sgZmFsc2VgLiIpLAoJCQkJICAgICAgIHBhdGguYnVmKTsKCQkJfQoJCX0KCQlyZXR1cm4gTlVMTDsKCX0KCXJldHVybiBwYXRoLmJ1ZjsKfQoKaW50IGhvb2tfZXhpc3RzKHN0cnVjdCByZXBvc2l0b3J5ICpyLCBjb25zdCBjaGFyICpuYW1lKQp7CglyZXR1cm4gISFmaW5kX2hvb2sociwgbmFtZSk7Cn0KCnN0YXRpYyBpbnQgcGlja19uZXh0X2hvb2soc3RydWN0IGNoaWxkX3Byb2Nlc3MgKmNwLAoJCQkgIHN0cnVjdCBzdHJidWYgKm91dCBVTlVTRUQsCgkJCSAgdm9pZCAqcHBfY2IsCgkJCSAgdm9pZCAqKnBwX3Rhc2tfY2IpCnsKCXN0cnVjdCBob29rX2NiX2RhdGEgKmhvb2tfY2IgPSBwcF9jYjsKCWNvbnN0IGNoYXIgKmhvb2tfcGF0aCA9IGhvb2tfY2ItPmhvb2tfcGF0aDsKCglpZiAoIWhvb2tfcGF0aCkKCQlyZXR1cm4gMDsKCgljcC0+bm9fc3RkaW4gPSAxOwoJc3RydmVjX3B1c2h2KCZjcC0+ZW52LCBob29rX2NiLT5vcHRpb25zLT5lbnYudik7CgoJaWYgKGhvb2tfY2ItPm9wdGlvbnMtPnBhdGhfdG9fc3RkaW4gJiYgaG9va19jYi0+b3B0aW9ucy0+ZmVlZF9waXBlKQoJCUJVRygib3B0aW9ucyBwYXRoX3RvX3N0ZGluIGFuZCBmZWVkX3BpcGUgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZSIpOwoKCS8qIHJlb3BlbiB0aGUgZmlsZSBmb3Igc3RkaW47IHJ1bl9jb21tYW5kIGNsb3NlcyBpdC4gKi8KCWlmIChob29rX2NiLT5vcHRpb25zLT5wYXRoX3RvX3N0ZGluKSB7CgkJY3AtPm5vX3N0ZGluID0gMDsKCQljcC0+aW4gPSB4b3Blbihob29rX2NiLT5vcHRpb25zLT5wYXRoX3RvX3N0ZGluLCBPX1JET05MWSk7Cgl9CgoJaWYgKGhvb2tfY2ItPm9wdGlvbnMtPmZlZWRfcGlwZSkgewoJCWNwLT5ub19zdGRpbiA9IDA7CgkJLyogc3RhcnRfY29tbWFuZCgpIHdpbGwgYWxsb2NhdGUgYSBwaXBlIC8gc3RkaW4gZmQgZm9yIHVzICovCgkJY3AtPmluID0gLTE7Cgl9CgoJY3AtPnN0ZG91dF90b19zdGRlcnIgPSAxOwoJY3AtPnRyYWNlMl9ob29rX25hbWUgPSBob29rX2NiLT5ob29rX25hbWU7CgljcC0+ZGlyID0gaG9va19jYi0+b3B0aW9ucy0+ZGlyOwoKCXN0cnZlY19wdXNoKCZjcC0+YXJncywgaG9va19wYXRoKTsKCXN0cnZlY19wdXNodigmY3AtPmFyZ3MsIGhvb2tfY2ItPm9wdGlvbnMtPmFyZ3Mudik7CgoJLyoKCSAqIFByb3ZpZGUgcGVyLWhvb2sgaW50ZXJuYWwgc3RhdGUgdmlhIHRhc2tfY2IgZm9yIGVhc3kgYWNjZXNzLCBzbwoJICogaG9vayBjYWxsYmFja3MgZG9uJ3QgaGF2ZSB0byBnbyB0aHJvdWdoIGhvb2tfY2ItPm9wdGlvbnMuCgkgKi8KCSpwcF90YXNrX2NiID0gaG9va19jYi0+b3B0aW9ucy0+ZmVlZF9waXBlX2NiX2RhdGE7CgoJLyoKCSAqIFRoaXMgcGlja19uZXh0X2hvb2soKSB3aWxsIGJlIGNhbGxlZCBhZ2Fpbiwgd2UncmUgb25seQoJICogcnVubmluZyBvbmUgaG9vaywgc28gaW5kaWNhdGUgdGhhdCBubyBtb3JlIHdvcmsgd2lsbCBiZQoJICogZG9uZS4KCSAqLwoJaG9va19jYi0+aG9va19wYXRoID0gTlVMTDsKCglyZXR1cm4gMTsKfQoKc3RhdGljIGludCBub3RpZnlfc3RhcnRfZmFpbHVyZShzdHJ1Y3Qgc3RyYnVmICpvdXQgVU5VU0VELAoJCQkJdm9pZCAqcHBfY2IsCgkJCQl2b2lkICpwcF90YXNrX2NwIFVOVVNFRCkKewoJc3RydWN0IGhvb2tfY2JfZGF0YSAqaG9va19jYiA9IHBwX2NiOwoKCWhvb2tfY2ItPnJjIHw9IDE7CgoJcmV0dXJuIDE7Cn0KCnN0YXRpYyBpbnQgbm90aWZ5X2hvb2tfZmluaXNoZWQoaW50IHJlc3VsdCwKCQkJCXN0cnVjdCBzdHJidWYgKm91dCBVTlVTRUQsCgkJCQl2b2lkICpwcF9jYiwKCQkJCXZvaWQgKnBwX3Rhc2tfY2IgVU5VU0VEKQp7CglzdHJ1Y3QgaG9va19jYl9kYXRhICpob29rX2NiID0gcHBfY2I7CglzdHJ1Y3QgcnVuX2hvb2tzX29wdCAqb3B0ID0gaG9va19jYi0+b3B0aW9uczsKCglob29rX2NiLT5yYyB8PSByZXN1bHQ7CgoJaWYgKG9wdC0+aW52b2tlZF9ob29rKQoJCSpvcHQtPmludm9rZWRfaG9vayA9IDE7CgoJcmV0dXJuIDA7Cn0KCnN0YXRpYyB2b2lkIHJ1bl9ob29rc19vcHRfY2xlYXIoc3RydWN0IHJ1bl9ob29rc19vcHQgKm9wdGlvbnMpCnsKCXN0cnZlY19jbGVhcigmb3B0aW9ucy0+ZW52KTsKCXN0cnZlY19jbGVhcigmb3B0aW9ucy0+YXJncyk7Cn0KCmludCBydW5faG9va3Nfb3B0KHN0cnVjdCByZXBvc2l0b3J5ICpyLCBjb25zdCBjaGFyICpob29rX25hbWUsCgkJICBzdHJ1Y3QgcnVuX2hvb2tzX29wdCAqb3B0aW9ucykKewoJc3RydWN0IHN0cmJ1ZiBhYnNfcGF0aCA9IFNUUkJVRl9JTklUOwoJc3RydWN0IGhvb2tfY2JfZGF0YSBjYl9kYXRhID0gewoJCS5yYyA9IDAsCgkJLmhvb2tfbmFtZSA9IGhvb2tfbmFtZSwKCQkub3B0aW9ucyA9IG9wdGlvbnMsCgl9OwoJY29uc3QgY2hhciAqY29uc3QgaG9va19wYXRoID0gZmluZF9ob29rKHIsIGhvb2tfbmFtZSk7CglpbnQgcmV0ID0gMDsKCWNvbnN0IHN0cnVjdCBydW5fcHJvY2Vzc19wYXJhbGxlbF9vcHRzIG9wdHMgPSB7CgkJLnRyMl9jYXRlZ29yeSA9ICJob29rIiwKCQkudHIyX2xhYmVsID0gaG9va19uYW1lLAoKCQkucHJvY2Vzc2VzID0gMSwKCQkudW5ncm91cCA9IG9wdGlvbnMtPnVuZ3JvdXAsCgoJCS5nZXRfbmV4dF90YXNrID0gcGlja19uZXh0X2hvb2ssCgkJLnN0YXJ0X2ZhaWx1cmUgPSBub3RpZnlfc3RhcnRfZmFpbHVyZSwKCQkuZmVlZF9waXBlID0gb3B0aW9ucy0+ZmVlZF9waXBlLAoJCS50YXNrX2ZpbmlzaGVkID0gbm90aWZ5X2hvb2tfZmluaXNoZWQsCgoJCS5kYXRhID0gJmNiX2RhdGEsCgl9OwoKCWlmICghb3B0aW9ucykKCQlCVUcoImEgc3RydWN0IHJ1bl9ob29rc19vcHQgbXVzdCBiZSBwcm92aWRlZCB0byBydW5faG9va3MiKTsKCglpZiAob3B0aW9ucy0+cGF0aF90b19zdGRpbiAmJiBvcHRpb25zLT5mZWVkX3BpcGUpCgkJQlVHKCJvcHRpb25zIHBhdGhfdG9fc3RkaW4gYW5kIGZlZWRfcGlwZSBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlIik7CgoJaWYgKG9wdGlvbnMtPmludm9rZWRfaG9vaykKCQkqb3B0aW9ucy0+aW52b2tlZF9ob29rID0gMDsKCglpZiAoIWhvb2tfcGF0aCAmJiAhb3B0aW9ucy0+ZXJyb3JfaWZfbWlzc2luZykKCQlnb3RvIGNsZWFudXA7CgoJaWYgKCFob29rX3BhdGgpIHsKCQlyZXQgPSBlcnJvcigiY2Fubm90IGZpbmQgYSBob29rIG5hbWVkICVzIiwgaG9va19uYW1lKTsKCQlnb3RvIGNsZWFudXA7Cgl9CgoJY2JfZGF0YS5ob29rX3BhdGggPSBob29rX3BhdGg7CglpZiAob3B0aW9ucy0+ZGlyKSB7CgkJc3RyYnVmX2FkZF9hYnNvbHV0ZV9wYXRoKCZhYnNfcGF0aCwgaG9va19wYXRoKTsKCQljYl9kYXRhLmhvb2tfcGF0aCA9IGFic19wYXRoLmJ1ZjsKCX0KCglydW5fcHJvY2Vzc2VzX3BhcmFsbGVsKCZvcHRzKTsKCXJldCA9IGNiX2RhdGEucmM7CmNsZWFudXA6CglzdHJidWZfcmVsZWFzZSgmYWJzX3BhdGgpOwoJcnVuX2hvb2tzX29wdF9jbGVhcihvcHRpb25zKTsKCXJldHVybiByZXQ7Cn0KCmludCBydW5faG9va3Moc3RydWN0IHJlcG9zaXRvcnkgKnIsIGNvbnN0IGNoYXIgKmhvb2tfbmFtZSkKewoJc3RydWN0IHJ1bl9ob29rc19vcHQgb3B0ID0gUlVOX0hPT0tTX09QVF9JTklUOwoKCS8qIEFsbCB1c2UtY2FzZXMgb2YgdGhpcyBBUEkgcmVxdWlyZSB1bmdyb3VwaW5nLiAqLwoJb3B0LnVuZ3JvdXAgPSAxOwoKCXJldHVybiBydW5faG9va3Nfb3B0KHIsIGhvb2tfbmFtZSwgJm9wdCk7Cn0KCmludCBydW5faG9va3NfbChzdHJ1Y3QgcmVwb3NpdG9yeSAqciwgY29uc3QgY2hhciAqaG9va19uYW1lLCAuLi4pCnsKCXN0cnVjdCBydW5faG9va3Nfb3B0IG9wdCA9IFJVTl9IT09LU19PUFRfSU5JVDsKCXZhX2xpc3QgYXA7Cgljb25zdCBjaGFyICphcmc7CgoJdmFfc3RhcnQoYXAsIGhvb2tfbmFtZSk7Cgl3aGlsZSAoKGFyZyA9IHZhX2FyZyhhcCwgY29uc3QgY2hhciAqKSkpCgkJc3RydmVjX3B1c2goJm9wdC5hcmdzLCBhcmcpOwoJdmFfZW5kKGFwKTsKCglyZXR1cm4gcnVuX2hvb2tzX29wdChyLCBob29rX25hbWUsICZvcHQpOwp9Cg==",
    "text": "#include \"git-compat-util.h\"\n#include \"abspath.h\"\n#include \"advice.h\"\n#include \"gettext.h\"\n#include \"hook.h\"\n#include \"path.h\"\n#include \"run-command.h\"\n#include \"config.h\"\n#include \"strbuf.h\"\n#include \"environment.h\"\n#include \"setup.h\"\n\nconst char *find_hook(struct repository *r, const char *name)\n{\n\tstatic struct strbuf path = STRBUF_INIT;\n\n\tint found_hook;\n\n\trepo_git_path_replace(r, &path, \"hooks/%s\", name);\n\tfound_hook = access(path.buf, X_OK) >= 0;\n#ifdef STRIP_EXTENSION\n\tif (!found_hook) {\n\t\tint err = errno;\n\n\t\tstrbuf_addstr(&path, STRIP_EXTENSION);\n\t\tfound_hook = access(path.buf, X_OK) >= 0;\n\t\tif (!found_hook)\n\t\t\terrno = err;\n\t}\n#endif\n\n\tif (!found_hook) {\n\t\tif (errno == EACCES && advice_enabled(ADVICE_IGNORED_HOOK)) {\n\t\t\tstatic struct string_list advise_given = STRING_LIST_INIT_DUP;\n\n\t\t\tif (!string_list_lookup(&advise_given, name)) {\n\t\t\t\tstring_list_insert(&advise_given, name);\n\t\t\t\tadvise(_(\"The '%s' hook was ignored because \"\n\t\t\t\t\t \"it's not set as executable.\\n\"\n\t\t\t\t\t \"You can disable this warning with \"\n\t\t\t\t\t \"`git config set advice.ignoredHook false`.\"),\n\t\t\t\t       path.buf);\n\t\t\t}\n\t\t}\n\t\treturn NULL;\n\t}\n\treturn path.buf;\n}\n\nint hook_exists(struct repository *r, const char *name)\n{\n\treturn !!find_hook(r, name);\n}\n\nstatic int pick_next_hook(struct child_process *cp,\n\t\t\t  struct strbuf *out UNUSED,\n\t\t\t  void *pp_cb,\n\t\t\t  void **pp_task_cb)\n{\n\tstruct hook_cb_data *hook_cb = pp_cb;\n\tconst char *hook_path = hook_cb->hook_path;\n\n\tif (!hook_path)\n\t\treturn 0;\n\n\tcp->no_stdin = 1;\n\tstrvec_pushv(&cp->env, hook_cb->options->env.v);\n\n\tif (hook_cb->options->path_to_stdin && hook_cb->options->feed_pipe)\n\t\tBUG(\"options path_to_stdin and feed_pipe are mutually exclusive\");\n\n\t/* reopen the file for stdin; run_command closes it. */\n\tif (hook_cb->options->path_to_stdin) {\n\t\tcp->no_stdin = 0;\n\t\tcp->in = xopen(hook_cb->options->path_to_stdin, O_RDONLY);\n\t}\n\n\tif (hook_cb->options->feed_pipe) {\n\t\tcp->no_stdin = 0;\n\t\t/* start_command() will allocate a pipe / stdin fd for us */\n\t\tcp->in = -1;\n\t}\n\n\tcp->stdout_to_stderr = 1;\n\tcp->trace2_hook_name = hook_cb->hook_name;\n\tcp->dir = hook_cb->options->dir;\n\n\tstrvec_push(&cp->args, hook_path);\n\tstrvec_pushv(&cp->args, hook_cb->options->args.v);\n\n\t/*\n\t * Provide per-hook internal state via task_cb for easy access, so\n\t * hook callbacks don't have to go through hook_cb->options.\n\t */\n\t*pp_task_cb = hook_cb->options->feed_pipe_cb_data;\n\n\t/*\n\t * This pick_next_hook() will be called again, we're only\n\t * running one hook, so indicate that no more work will be\n\t * done.\n\t */\n\thook_cb->hook_path = NULL;\n\n\treturn 1;\n}\n\nstatic int notify_start_failure(struct strbuf *out UNUSED,\n\t\t\t\tvoid *pp_cb,\n\t\t\t\tvoid *pp_task_cp UNUSED)\n{\n\tstruct hook_cb_data *hook_cb = pp_cb;\n\n\thook_cb->rc |= 1;\n\n\treturn 1;\n}\n\nstatic int notify_hook_finished(int result,\n\t\t\t\tstruct strbuf *out UNUSED,\n\t\t\t\tvoid *pp_cb,\n\t\t\t\tvoid *pp_task_cb UNUSED)\n{\n\tstruct hook_cb_data *hook_cb = pp_cb;\n\tstruct run_hooks_opt *opt = hook_cb->options;\n\n\thook_cb->rc |= result;\n\n\tif (opt->invoked_hook)\n\t\t*opt->invoked_hook = 1;\n\n\treturn 0;\n}\n\nstatic void run_hooks_opt_clear(struct run_hooks_opt *options)\n{\n\tstrvec_clear(&options->env);\n\tstrvec_clear(&options->args);\n}\n\nint run_hooks_opt(struct repository *r, const char *hook_name,\n\t\t  struct run_hooks_opt *options)\n{\n\tstruct strbuf abs_path = STRBUF_INIT;\n\tstruct hook_cb_data cb_data = {\n\t\t.rc = 0,\n\t\t.hook_name = hook_name,\n\t\t.options = options,\n\t};\n\tconst char *const hook_path = find_hook(r, hook_name);\n\tint ret = 0;\n\tconst struct run_process_parallel_opts opts = {\n\t\t.tr2_category = \"hook\",\n\t\t.tr2_label = hook_name,\n\n\t\t.processes = 1,\n\t\t.ungroup = options->ungroup,\n\n\t\t.get_next_task = pick_next_hook,\n\t\t.start_failure = notify_start_failure,\n\t\t.feed_pipe = options->feed_pipe,\n\t\t.task_finished = notify_hook_finished,\n\n\t\t.data = &cb_data,\n\t};\n\n\tif (!options)\n\t\tBUG(\"a struct run_hooks_opt must be provided to run_hooks\");\n\n\tif (options->path_to_stdin && options->feed_pipe)\n\t\tBUG(\"options path_to_stdin and feed_pipe are mutually exclusive\");\n\n\tif (options->invoked_hook)\n\t\t*options->invoked_hook = 0;\n\n\tif (!hook_path && !options->error_if_missing)\n\t\tgoto cleanup;\n\n\tif (!hook_path) {\n\t\tret = error(\"cannot find a hook named %s\", hook_name);\n\t\tgoto cleanup;\n\t}\n\n\tcb_data.hook_path = hook_path;\n\tif (options->dir) {\n\t\tstrbuf_add_absolute_path(&abs_path, hook_path);\n\t\tcb_data.hook_path = abs_path.buf;\n\t}\n\n\trun_processes_parallel(&opts);\n\tret = cb_data.rc;\ncleanup:\n\tstrbuf_release(&abs_path);\n\trun_hooks_opt_clear(options);\n\treturn ret;\n}\n\nint run_hooks(struct repository *r, const char *hook_name)\n{\n\tstruct run_hooks_opt opt = RUN_HOOKS_OPT_INIT;\n\n\t/* All use-cases of this API require ungrouping. */\n\topt.ungroup = 1;\n\n\treturn run_hooks_opt(r, hook_name, &opt);\n}\n\nint run_hooks_l(struct repository *r, const char *hook_name, ...)\n{\n\tstruct run_hooks_opt opt = RUN_HOOKS_OPT_INIT;\n\tva_list ap;\n\tconst char *arg;\n\n\tva_start(ap, hook_name);\n\twhile ((arg = va_arg(ap, const char *)))\n\t\tstrvec_push(&opt.args, arg);\n\tva_end(ap);\n\n\treturn run_hooks_opt(r, hook_name, &opt);\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00a1e2ad22a9d77daa4c221bd5d21105e85c2ed7",
  "sha1_ok": true,
  "size": 5059
}
