{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJwYWNrLmgiCiNpbmNsdWRlICJjc3VtLWZpbGUuaCIKI2luY2x1ZGUgInJlbW90ZS5oIgojaW5jbHVkZSAiY2h1bmstZm9ybWF0LmgiCiNpbmNsdWRlICJwYWNrLW10aW1lcy5oIgojaW5jbHVkZSAib2lkbWFwLmgiCiNpbmNsdWRlICJjaHVuay1mb3JtYXQuaCIKI2luY2x1ZGUgInBhY2stb2JqZWN0cy5oIgoKdm9pZCByZXNldF9wYWNrX2lkeF9vcHRpb24oc3RydWN0IHBhY2tfaWR4X29wdGlvbiAqb3B0cykKewoJbWVtc2V0KG9wdHMsIDAsIHNpemVvZigqb3B0cykpOwoJb3B0cy0+dmVyc2lvbiA9IDI7CglvcHRzLT5vZmYzMl9saW1pdCA9IDB4N2ZmZmZmZmY7Cn0KCnN0YXRpYyBpbnQgc2hhMV9jb21wYXJlKGNvbnN0IHZvaWQgKl9hLCBjb25zdCB2b2lkICpfYikKewoJc3RydWN0IHBhY2tfaWR4X2VudHJ5ICphID0gKihzdHJ1Y3QgcGFja19pZHhfZW50cnkgKiopX2E7CglzdHJ1Y3QgcGFja19pZHhfZW50cnkgKmIgPSAqKHN0cnVjdCBwYWNrX2lkeF9lbnRyeSAqKilfYjsKCXJldHVybiBvaWRjbXAoJmEtPm9pZCwgJmItPm9pZCk7Cn0KCnN0YXRpYyBpbnQgY21wX3VpbnQzMihjb25zdCB2b2lkICphXywgY29uc3Qgdm9pZCAqYl8pCnsKCXVpbnQzMl90IGEgPSAqKCh1aW50MzJfdCAqKWFfKTsKCXVpbnQzMl90IGIgPSAqKCh1aW50MzJfdCAqKWJfKTsKCglyZXR1cm4gKGEgPCBiKSA/IC0xIDogKGEgIT0gYik7Cn0KCnN0YXRpYyBpbnQgbmVlZF9sYXJnZV9vZmZzZXQob2ZmX3Qgb2Zmc2V0LCBjb25zdCBzdHJ1Y3QgcGFja19pZHhfb3B0aW9uICpvcHRzKQp7Cgl1aW50MzJfdCBvZnN2YWw7CgoJaWYgKChvZmZzZXQgPj4gMzEpIHx8IChvcHRzLT5vZmYzMl9saW1pdCA8IG9mZnNldCkpCgkJcmV0dXJuIDE7CglpZiAoIW9wdHMtPmFub21hbHlfbnIpCgkJcmV0dXJuIDA7CglvZnN2YWwgPSBvZmZzZXQ7CglyZXR1cm4gISFic2VhcmNoKCZvZnN2YWwsIG9wdHMtPmFub21hbHksIG9wdHMtPmFub21hbHlfbnIsCgkJCSBzaXplb2Yob2ZzdmFsKSwgY21wX3VpbnQzMik7Cn0KCi8qCiAqIFRoZSAqc2hhMSBjb250YWlucyB0aGUgcGFjayBjb250ZW50IFNIQTEgaGFzaC4KICogVGhlIG9iamVjdHMgYXJyYXkgcGFzc2VkIGluIHdpbGwgYmUgc29ydGVkIGJ5IFNIQTEgb24gZXhpdC4KICovCmNvbnN0IGNoYXIgKndyaXRlX2lkeF9maWxlKGNvbnN0IGNoYXIgKmluZGV4X25hbWUsIHN0cnVjdCBwYWNrX2lkeF9lbnRyeSAqKm9iamVjdHMsCgkJCSAgIGludCBucl9vYmplY3RzLCBjb25zdCBzdHJ1Y3QgcGFja19pZHhfb3B0aW9uICpvcHRzLAoJCQkgICBjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExKQp7CglzdHJ1Y3QgaGFzaGZpbGUgKmY7CglzdHJ1Y3QgcGFja19pZHhfZW50cnkgKipzb3J0ZWRfYnlfc2hhLCAqKmxpc3QsICoqbGFzdDsKCW9mZl90IGxhc3Rfb2JqX29mZnNldCA9IDA7CglpbnQgaSwgZmQ7Cgl1aW50MzJfdCBpbmRleF92ZXJzaW9uOwoKCWlmIChucl9vYmplY3RzKSB7CgkJc29ydGVkX2J5X3NoYSA9IG9iamVjdHM7CgkJbGlzdCA9IHNvcnRlZF9ieV9zaGE7CgkJbGFzdCA9IHNvcnRlZF9ieV9zaGEgKyBucl9vYmplY3RzOwoJCWZvciAoaSA9IDA7IGkgPCBucl9vYmplY3RzOyArK2kpIHsKCQkJaWYgKG9iamVjdHNbaV0tPm9mZnNldCA+IGxhc3Rfb2JqX29mZnNldCkKCQkJCWxhc3Rfb2JqX29mZnNldCA9IG9iamVjdHNbaV0tPm9mZnNldDsKCQl9CgkJUVNPUlQoc29ydGVkX2J5X3NoYSwgbnJfb2JqZWN0cywgc2hhMV9jb21wYXJlKTsKCX0KCWVsc2UKCQlzb3J0ZWRfYnlfc2hhID0gbGlzdCA9IGxhc3QgPSBOVUxMOwoKCWlmIChvcHRzLT5mbGFncyAmIFdSSVRFX0lEWF9WRVJJRlkpIHsKCQlhc3NlcnQoaW5kZXhfbmFtZSk7CgkJZiA9IGhhc2hmZF9jaGVjayhpbmRleF9uYW1lKTsKCX0gZWxzZSB7CgkJaWYgKCFpbmRleF9uYW1lKSB7CgkJCXN0cnVjdCBzdHJidWYgdG1wX2ZpbGUgPSBTVFJCVUZfSU5JVDsKCQkJZmQgPSBvZGJfbWtzdGVtcCgmdG1wX2ZpbGUsICJwYWNrL3RtcF9pZHhfWFhYWFhYIik7CgkJCWluZGV4X25hbWUgPSBzdHJidWZfZGV0YWNoKCZ0bXBfZmlsZSwgTlVMTCk7CgkJfSBlbHNlIHsKCQkJdW5saW5rKGluZGV4X25hbWUpOwoJCQlmZCA9IHhvcGVuKGluZGV4X25hbWUsIE9fQ1JFQVR8T19FWENMfE9fV1JPTkxZLCAwNjAwKTsKCQl9CgkJZiA9IGhhc2hmZChmZCwgaW5kZXhfbmFtZSk7Cgl9CgoJLyogaWYgbGFzdCBvYmplY3QncyBvZmZzZXQgaXMgPj0gMl4zMSB3ZSBzaG91bGQgdXNlIGluZGV4IFYyICovCglpbmRleF92ZXJzaW9uID0gbmVlZF9sYXJnZV9vZmZzZXQobGFzdF9vYmpfb2Zmc2V0LCBvcHRzKSA/IDIgOiBvcHRzLT52ZXJzaW9uOwoKCS8qIGluZGV4IHZlcnNpb25zIDIgYW5kIGFib3ZlIG5lZWQgYSBoZWFkZXIgKi8KCWlmIChpbmRleF92ZXJzaW9uID49IDIpIHsKCQlzdHJ1Y3QgcGFja19pZHhfaGVhZGVyIGhkcjsKCQloZHIuaWR4X3NpZ25hdHVyZSA9IGh0b25sKFBBQ0tfSURYX1NJR05BVFVSRSk7CgkJaGRyLmlkeF92ZXJzaW9uID0gaHRvbmwoaW5kZXhfdmVyc2lvbik7CgkJaGFzaHdyaXRlKGYsICZoZHIsIHNpemVvZihoZHIpKTsKCX0KCgkvKgoJICogV3JpdGUgdGhlIGZpcnN0LWxldmVsIHRhYmxlICh0aGUgbGlzdCBpcyBzb3J0ZWQsCgkgKiBidXQgd2UgdXNlIGEgMjU2LWVudHJ5IGxvb2t1cCB0byBiZSBhYmxlIHRvIGF2b2lkCgkgKiBoYXZpbmcgdG8gZG8gZWlnaHQgZXh0cmEgYmluYXJ5IHNlYXJjaCBpdGVyYXRpb25zKS4KCSAqLwoJZm9yIChpID0gMDsgaSA8IDI1NjsgaSsrKSB7CgkJc3RydWN0IHBhY2tfaWR4X2VudHJ5ICoqbmV4dCA9IGxpc3Q7CgkJd2hpbGUgKG5leHQgPCBsYXN0KSB7CgkJCXN0cnVjdCBwYWNrX2lkeF9lbnRyeSAqb2JqID0gKm5leHQ7CgkJCWlmIChvYmotPm9pZC5oYXNoWzBdICE9IGkpCgkJCQlicmVhazsKCQkJbmV4dCsrOwoJCX0KCQloYXNod3JpdGVfYmUzMihmLCBuZXh0IC0gc29ydGVkX2J5X3NoYSk7CgkJbGlzdCA9IG5leHQ7Cgl9CgoJLyoKCSAqIFdyaXRlIHRoZSBhY3R1YWwgU0hBMSBlbnRyaWVzLi4KCSAqLwoJbGlzdCA9IHNvcnRlZF9ieV9zaGE7Cglmb3IgKGkgPSAwOyBpIDwgbnJfb2JqZWN0czsgaSsrKSB7CgkJc3RydWN0IHBhY2tfaWR4X2VudHJ5ICpvYmogPSAqbGlzdCsrOwoJCWlmIChpbmRleF92ZXJzaW9uIDwgMikKCQkJaGFzaHdyaXRlX2JlMzIoZiwgb2JqLT5vZmZzZXQpOwoJCWhhc2h3cml0ZShmLCBvYmotPm9pZC5oYXNoLCB0aGVfaGFzaF9hbGdvLT5yYXdzeik7CgkJaWYgKChvcHRzLT5mbGFncyAmIFdSSVRFX0lEWF9TVFJJQ1QpICYmCgkJICAgIChpICYmIG9pZGVxKCZsaXN0Wy0yXS0+b2lkLCAmb2JqLT5vaWQpKSkKCQkJZGllKCJUaGUgc2FtZSBvYmplY3QgJXMgYXBwZWFycyB0d2ljZSBpbiB0aGUgcGFjayIsCgkJCSAgICBvaWRfdG9faGV4KCZvYmotPm9pZCkpOwoJfQoKCWlmIChpbmRleF92ZXJzaW9uID49IDIpIHsKCQl1bnNpZ25lZCBpbnQgbnJfbGFyZ2Vfb2Zmc2V0ID0gMDsKCgkJLyogd3JpdGUgdGhlIGNyYzMyIHRhYmxlICovCgkJbGlzdCA9IHNvcnRlZF9ieV9zaGE7CgkJZm9yIChpID0gMDsgaSA8IG5yX29iamVjdHM7IGkrKykgewoJCQlzdHJ1Y3QgcGFja19pZHhfZW50cnkgKm9iaiA9ICpsaXN0Kys7CgkJCWhhc2h3cml0ZV9iZTMyKGYsIG9iai0+Y3JjMzIpOwoJCX0KCgkJLyogd3JpdGUgdGhlIDMyLWJpdCBvZmZzZXQgdGFibGUgKi8KCQlsaXN0ID0gc29ydGVkX2J5X3NoYTsKCQlmb3IgKGkgPSAwOyBpIDwgbnJfb2JqZWN0czsgaSsrKSB7CgkJCXN0cnVjdCBwYWNrX2lkeF9lbnRyeSAqb2JqID0gKmxpc3QrKzsKCQkJdWludDMyX3Qgb2Zmc2V0OwoKCQkJb2Zmc2V0ID0gKG5lZWRfbGFyZ2Vfb2Zmc2V0KG9iai0+b2Zmc2V0LCBvcHRzKQoJCQkJICA/ICgweDgwMDAwMDAwIHwgbnJfbGFyZ2Vfb2Zmc2V0KyspCgkJCQkgIDogb2JqLT5vZmZzZXQpOwoJCQloYXNod3JpdGVfYmUzMihmLCBvZmZzZXQpOwoJCX0KCgkJLyogd3JpdGUgdGhlIGxhcmdlIG9mZnNldCB0YWJsZSAqLwoJCWxpc3QgPSBzb3J0ZWRfYnlfc2hhOwoJCXdoaWxlIChucl9sYXJnZV9vZmZzZXQpIHsKCQkJc3RydWN0IHBhY2tfaWR4X2VudHJ5ICpvYmogPSAqbGlzdCsrOwoJCQl1aW50NjRfdCBvZmZzZXQgPSBvYmotPm9mZnNldDsKCgkJCWlmICghbmVlZF9sYXJnZV9vZmZzZXQob2Zmc2V0LCBvcHRzKSkKCQkJCWNvbnRpbnVlOwoJCQloYXNod3JpdGVfYmU2NChmLCBvZmZzZXQpOwoJCQlucl9sYXJnZV9vZmZzZXQtLTsKCQl9Cgl9CgoJaGFzaHdyaXRlKGYsIHNoYTEsIHRoZV9oYXNoX2FsZ28tPnJhd3N6KTsKCWZpbmFsaXplX2hhc2hmaWxlKGYsIE5VTEwsIEZTWU5DX0NPTVBPTkVOVF9QQUNLX01FVEFEQVRBLAoJCQkgIENTVU1fSEFTSF9JTl9TVFJFQU0gfCBDU1VNX0NMT1NFIHwKCQkJICAoKG9wdHMtPmZsYWdzICYgV1JJVEVfSURYX1ZFUklGWSkgPyAwIDogQ1NVTV9GU1lOQykpOwoJcmV0dXJuIGluZGV4X25hbWU7Cn0KCnN0YXRpYyBpbnQgcGFja19vcmRlcl9jbXAoY29uc3Qgdm9pZCAqdmEsIGNvbnN0IHZvaWQgKnZiLCB2b2lkICpjdHgpCnsKCXN0cnVjdCBwYWNrX2lkeF9lbnRyeSAqKm9iamVjdHMgPSBjdHg7CgoJb2ZmX3Qgb2EgPSBvYmplY3RzWyoodWludDMyX3QqKXZhXS0+b2Zmc2V0OwoJb2ZmX3Qgb2IgPSBvYmplY3RzWyoodWludDMyX3QqKXZiXS0+b2Zmc2V0OwoKCWlmIChvYSA8IG9iKQoJCXJldHVybiAtMTsKCWlmIChvYSA+IG9iKQoJCXJldHVybiAxOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyB2b2lkIHdyaXRlX3Jldl9oZWFkZXIoc3RydWN0IGhhc2hmaWxlICpmKQp7CgloYXNod3JpdGVfYmUzMihmLCBSSURYX1NJR05BVFVSRSk7CgloYXNod3JpdGVfYmUzMihmLCBSSURYX1ZFUlNJT04pOwoJaGFzaHdyaXRlX2JlMzIoZiwgb2lkX3ZlcnNpb24odGhlX2hhc2hfYWxnbykpOwp9CgpzdGF0aWMgdm9pZCB3cml0ZV9yZXZfaW5kZXhfcG9zaXRpb25zKHN0cnVjdCBoYXNoZmlsZSAqZiwKCQkJCSAgICAgIHVpbnQzMl90ICpwYWNrX29yZGVyLAoJCQkJICAgICAgdWludDMyX3QgbnJfb2JqZWN0cykKewoJdWludDMyX3QgaTsKCWZvciAoaSA9IDA7IGkgPCBucl9vYmplY3RzOyBpKyspCgkJaGFzaHdyaXRlX2JlMzIoZiwgcGFja19vcmRlcltpXSk7Cn0KCnN0YXRpYyB2b2lkIHdyaXRlX3Jldl90cmFpbGVyKHN0cnVjdCBoYXNoZmlsZSAqZiwgY29uc3QgdW5zaWduZWQgY2hhciAqaGFzaCkKewoJaGFzaHdyaXRlKGYsIGhhc2gsIHRoZV9oYXNoX2FsZ28tPnJhd3N6KTsKfQoKY29uc3QgY2hhciAqd3JpdGVfcmV2X2ZpbGUoY29uc3QgY2hhciAqcmV2X25hbWUsCgkJCSAgIHN0cnVjdCBwYWNrX2lkeF9lbnRyeSAqKm9iamVjdHMsCgkJCSAgIHVpbnQzMl90IG5yX29iamVjdHMsCgkJCSAgIGNvbnN0IHVuc2lnbmVkIGNoYXIgKmhhc2gsCgkJCSAgIHVuc2lnbmVkIGZsYWdzKQp7Cgl1aW50MzJfdCAqcGFja19vcmRlcjsKCXVpbnQzMl90IGk7Cgljb25zdCBjaGFyICpyZXQ7CgoJaWYgKCEoZmxhZ3MgJiBXUklURV9SRVYpICYmICEoZmxhZ3MgJiBXUklURV9SRVZfVkVSSUZZKSkKCQlyZXR1cm4gTlVMTDsKCglBTExPQ19BUlJBWShwYWNrX29yZGVyLCBucl9vYmplY3RzKTsKCWZvciAoaSA9IDA7IGkgPCBucl9vYmplY3RzOyBpKyspCgkJcGFja19vcmRlcltpXSA9IGk7CglRU09SVF9TKHBhY2tfb3JkZXIsIG5yX29iamVjdHMsIHBhY2tfb3JkZXJfY21wLCBvYmplY3RzKTsKCglyZXQgPSB3cml0ZV9yZXZfZmlsZV9vcmRlcihyZXZfbmFtZSwgcGFja19vcmRlciwgbnJfb2JqZWN0cywgaGFzaCwKCQkJCSAgIGZsYWdzKTsKCglmcmVlKHBhY2tfb3JkZXIpOwoKCXJldHVybiByZXQ7Cn0KCmNvbnN0IGNoYXIgKndyaXRlX3Jldl9maWxlX29yZGVyKGNvbnN0IGNoYXIgKnJldl9uYW1lLAoJCQkJIHVpbnQzMl90ICpwYWNrX29yZGVyLAoJCQkJIHVpbnQzMl90IG5yX29iamVjdHMsCgkJCQkgY29uc3QgdW5zaWduZWQgY2hhciAqaGFzaCwKCQkJCSB1bnNpZ25lZCBmbGFncykKewoJc3RydWN0IGhhc2hmaWxlICpmOwoJaW50IGZkOwoKCWlmICgoZmxhZ3MgJiBXUklURV9SRVYpICYmIChmbGFncyAmIFdSSVRFX1JFVl9WRVJJRlkpKQoJCWRpZShfKCJjYW5ub3QgYm90aCB3cml0ZSBhbmQgdmVyaWZ5IHJldmVyc2UgaW5kZXgiKSk7CgoJaWYgKGZsYWdzICYgV1JJVEVfUkVWKSB7CgkJaWYgKCFyZXZfbmFtZSkgewoJCQlzdHJ1Y3Qgc3RyYnVmIHRtcF9maWxlID0gU1RSQlVGX0lOSVQ7CgkJCWZkID0gb2RiX21rc3RlbXAoJnRtcF9maWxlLCAicGFjay90bXBfcmV2X1hYWFhYWCIpOwoJCQlyZXZfbmFtZSA9IHN0cmJ1Zl9kZXRhY2goJnRtcF9maWxlLCBOVUxMKTsKCQl9IGVsc2UgewoJCQl1bmxpbmsocmV2X25hbWUpOwoJCQlmZCA9IHhvcGVuKHJldl9uYW1lLCBPX0NSRUFUfE9fRVhDTHxPX1dST05MWSwgMDYwMCk7CgkJfQoJCWYgPSBoYXNoZmQoZmQsIHJldl9uYW1lKTsKCX0gZWxzZSBpZiAoZmxhZ3MgJiBXUklURV9SRVZfVkVSSUZZKSB7CgkJc3RydWN0IHN0YXQgc3RhdGJ1ZjsKCQlpZiAoc3RhdChyZXZfbmFtZSwgJnN0YXRidWYpKSB7CgkJCWlmIChlcnJubyA9PSBFTk9FTlQpIHsKCQkJCS8qIC5yZXYgZmlsZXMgYXJlIG9wdGlvbmFsICovCgkJCQlyZXR1cm4gTlVMTDsKCQkJfSBlbHNlCgkJCQlkaWVfZXJybm8oXygiY291bGQgbm90IHN0YXQ6ICVzIiksIHJldl9uYW1lKTsKCQl9CgkJZiA9IGhhc2hmZF9jaGVjayhyZXZfbmFtZSk7Cgl9IGVsc2UKCQlyZXR1cm4gTlVMTDsKCgl3cml0ZV9yZXZfaGVhZGVyKGYpOwoKCXdyaXRlX3Jldl9pbmRleF9wb3NpdGlvbnMoZiwgcGFja19vcmRlciwgbnJfb2JqZWN0cyk7Cgl3cml0ZV9yZXZfdHJhaWxlcihmLCBoYXNoKTsKCglpZiAocmV2X25hbWUgJiYgYWRqdXN0X3NoYXJlZF9wZXJtKHJldl9uYW1lKSA8IDApCgkJZGllKF8oImZhaWxlZCB0byBtYWtlICVzIHJlYWRhYmxlIiksIHJldl9uYW1lKTsKCglmaW5hbGl6ZV9oYXNoZmlsZShmLCBOVUxMLCBGU1lOQ19DT01QT05FTlRfUEFDS19NRVRBREFUQSwKCQkJICBDU1VNX0hBU0hfSU5fU1RSRUFNIHwgQ1NVTV9DTE9TRSB8CgkJCSAgKChmbGFncyAmIFdSSVRFX0lEWF9WRVJJRlkpID8gMCA6IENTVU1fRlNZTkMpKTsKCglyZXR1cm4gcmV2X25hbWU7Cn0KCnN0YXRpYyB2b2lkIHdyaXRlX210aW1lc19oZWFkZXIoc3RydWN0IGhhc2hmaWxlICpmKQp7CgloYXNod3JpdGVfYmUzMihmLCBNVElNRVNfU0lHTkFUVVJFKTsKCWhhc2h3cml0ZV9iZTMyKGYsIE1USU1FU19WRVJTSU9OKTsKCWhhc2h3cml0ZV9iZTMyKGYsIG9pZF92ZXJzaW9uKHRoZV9oYXNoX2FsZ28pKTsKfQoKLyoKICogV3JpdGVzIHRoZSBvYmplY3QgbXRpbWVzIG9mICJvYmplY3RzIiBmb3IgdXNlIGluIGEgLm10aW1lcyBmaWxlLgogKiBOb3RlIHRoYXQgb2JqZWN0cyBtdXN0IGJlIGluIGxleGljb2dyYXBoaWMgKGluZGV4KSBvcmRlciwgd2hpY2ggaXMKICogdGhlIGV4cGVjdGVkIG9yZGVyaW5nIG9mIHRoZXNlIHZhbHVlcyBpbiB0aGUgLm10aW1lcyBmaWxlLgogKi8Kc3RhdGljIHZvaWQgd3JpdGVfbXRpbWVzX29iamVjdHMoc3RydWN0IGhhc2hmaWxlICpmLAoJCQkJIHN0cnVjdCBwYWNraW5nX2RhdGEgKnRvX3BhY2ssCgkJCQkgc3RydWN0IHBhY2tfaWR4X2VudHJ5ICoqb2JqZWN0cywKCQkJCSB1aW50MzJfdCBucl9vYmplY3RzKQp7Cgl1aW50MzJfdCBpOwoJZm9yIChpID0gMDsgaSA8IG5yX29iamVjdHM7IGkrKykgewoJCXN0cnVjdCBvYmplY3RfZW50cnkgKmUgPSAoc3RydWN0IG9iamVjdF9lbnRyeSopb2JqZWN0c1tpXTsKCQloYXNod3JpdGVfYmUzMihmLCBvZV9jcnVmdF9tdGltZSh0b19wYWNrLCBlKSk7Cgl9Cn0KCnN0YXRpYyB2b2lkIHdyaXRlX210aW1lc190cmFpbGVyKHN0cnVjdCBoYXNoZmlsZSAqZiwgY29uc3QgdW5zaWduZWQgY2hhciAqaGFzaCkKewoJaGFzaHdyaXRlKGYsIGhhc2gsIHRoZV9oYXNoX2FsZ28tPnJhd3N6KTsKfQoKc3RhdGljIGNvbnN0IGNoYXIgKndyaXRlX210aW1lc19maWxlKHN0cnVjdCBwYWNraW5nX2RhdGEgKnRvX3BhY2ssCgkJCQkgICAgIHN0cnVjdCBwYWNrX2lkeF9lbnRyeSAqKm9iamVjdHMsCgkJCQkgICAgIHVpbnQzMl90IG5yX29iamVjdHMsCgkJCQkgICAgIGNvbnN0IHVuc2lnbmVkIGNoYXIgKmhhc2gpCnsKCXN0cnVjdCBzdHJidWYgdG1wX2ZpbGUgPSBTVFJCVUZfSU5JVDsKCWNvbnN0IGNoYXIgKm10aW1lc19uYW1lOwoJc3RydWN0IGhhc2hmaWxlICpmOwoJaW50IGZkOwoKCWlmICghdG9fcGFjaykKCQlCVUcoImNhbm5vdCBjYWxsIHdyaXRlX210aW1lc19maWxlIHdpdGggTlVMTCBwYWNraW5nX2RhdGEiKTsKCglmZCA9IG9kYl9ta3N0ZW1wKCZ0bXBfZmlsZSwgInBhY2svdG1wX210aW1lc19YWFhYWFgiKTsKCW10aW1lc19uYW1lID0gc3RyYnVmX2RldGFjaCgmdG1wX2ZpbGUsIE5VTEwpOwoJZiA9IGhhc2hmZChmZCwgbXRpbWVzX25hbWUpOwoKCXdyaXRlX210aW1lc19oZWFkZXIoZik7Cgl3cml0ZV9tdGltZXNfb2JqZWN0cyhmLCB0b19wYWNrLCBvYmplY3RzLCBucl9vYmplY3RzKTsKCXdyaXRlX210aW1lc190cmFpbGVyKGYsIGhhc2gpOwoKCWlmIChhZGp1c3Rfc2hhcmVkX3Blcm0obXRpbWVzX25hbWUpIDwgMCkKCQlkaWUoXygiZmFpbGVkIHRvIG1ha2UgJXMgcmVhZGFibGUiKSwgbXRpbWVzX25hbWUpOwoKCWZpbmFsaXplX2hhc2hmaWxlKGYsIE5VTEwsIEZTWU5DX0NPTVBPTkVOVF9QQUNLX01FVEFEQVRBLAoJCQkgIENTVU1fSEFTSF9JTl9TVFJFQU0gfCBDU1VNX0NMT1NFIHwgQ1NVTV9GU1lOQyk7CgoJcmV0dXJuIG10aW1lc19uYW1lOwp9CgpvZmZfdCB3cml0ZV9wYWNrX2hlYWRlcihzdHJ1Y3QgaGFzaGZpbGUgKmYsIHVpbnQzMl90IG5yX2VudHJpZXMpCnsKCXN0cnVjdCBwYWNrX2hlYWRlciBoZHI7CgoJaGRyLmhkcl9zaWduYXR1cmUgPSBodG9ubChQQUNLX1NJR05BVFVSRSk7CgloZHIuaGRyX3ZlcnNpb24gPSBodG9ubChQQUNLX1ZFUlNJT04pOwoJaGRyLmhkcl9lbnRyaWVzID0gaHRvbmwobnJfZW50cmllcyk7CgloYXNod3JpdGUoZiwgJmhkciwgc2l6ZW9mKGhkcikpOwoJcmV0dXJuIHNpemVvZihoZHIpOwp9CgovKgogKiBVcGRhdGUgcGFjayBoZWFkZXIgd2l0aCBvYmplY3RfY291bnQgYW5kIGNvbXB1dGUgbmV3IFNIQTEgZm9yIHBhY2sgZGF0YQogKiBhc3NvY2lhdGVkIHRvIHBhY2tfZmQsIGFuZCB3cml0ZSB0aGF0IFNIQTEgYXQgdGhlIGVuZC4gIFRoYXQgbmV3IFNIQTEKICogaXMgYWxzbyByZXR1cm5lZCBpbiBuZXdfcGFja19zaGExLgogKgogKiBJZiBwYXJ0aWFsX3BhY2tfc2hhMSBpcyBub24gbnVsbCwgdGhlbiB0aGUgU0hBMSBvZiB0aGUgZXhpc3RpbmcgcGFjawogKiAod2l0aG91dCB0aGUgaGVhZGVyIHVwZGF0ZSkgaXMgY29tcHV0ZWQgYW5kIHZhbGlkYXRlZCBhZ2FpbnN0IHRoZQogKiBvbmUgcHJvdmlkZWQgaW4gcGFydGlhbF9wYWNrX3NoYTEuICBUaGUgdmFsaWRhdGlvbiBpcyBwZXJmb3JtZWQgYXQKICogcGFydGlhbF9wYWNrX29mZnNldCBieXRlcyBpbiB0aGUgcGFjayBmaWxlLiAgVGhlIFNIQTEgb2YgdGhlIHJlbWFpbmluZwogKiBkYXRhIChpLmUuIGZyb20gcGFydGlhbF9wYWNrX29mZnNldCB0byB0aGUgZW5kKSBpcyB0aGVuIGNvbXB1dGVkIGFuZAogKiByZXR1cm5lZCBpbiBwYXJ0aWFsX3BhY2tfc2hhMS4KICoKICogTm90ZSB0aGF0IG5ld19wYWNrX3NoYTEgaXMgdXBkYXRlZCBsYXN0LCBzbyBib3RoIG5ld19wYWNrX3NoYTEgYW5kCiAqIHBhcnRpYWxfcGFja19zaGExIGNhbiByZWZlciB0byB0aGUgc2FtZSBidWZmZXIgaWYgdGhlIGNhbGxlciBpcyBub3QKICogaW50ZXJlc3RlZCBpbiB0aGUgcmVzdWx0aW5nIFNIQTEgb2YgcGFjayBkYXRhIGFib3ZlIHBhcnRpYWxfcGFja19vZmZzZXQuCiAqLwp2b2lkIGZpeHVwX3BhY2tfaGVhZGVyX2Zvb3RlcihpbnQgcGFja19mZCwKCQkJIHVuc2lnbmVkIGNoYXIgKm5ld19wYWNrX2hhc2gsCgkJCSBjb25zdCBjaGFyICpwYWNrX25hbWUsCgkJCSB1aW50MzJfdCBvYmplY3RfY291bnQsCgkJCSB1bnNpZ25lZCBjaGFyICpwYXJ0aWFsX3BhY2tfaGFzaCwKCQkJIG9mZl90IHBhcnRpYWxfcGFja19vZmZzZXQpCnsKCWludCBhbGlnbmVkX3N6LCBidWZfc3ogPSA4ICogMTAyNDsKCWdpdF9oYXNoX2N0eCBvbGRfaGFzaF9jdHgsIG5ld19oYXNoX2N0eDsKCXN0cnVjdCBwYWNrX2hlYWRlciBoZHI7CgljaGFyICpidWY7Cglzc2l6ZV90IHJlYWRfcmVzdWx0OwoKCXRoZV9oYXNoX2FsZ28tPmluaXRfZm4oJm9sZF9oYXNoX2N0eCk7Cgl0aGVfaGFzaF9hbGdvLT5pbml0X2ZuKCZuZXdfaGFzaF9jdHgpOwoKCWlmIChsc2VlayhwYWNrX2ZkLCAwLCBTRUVLX1NFVCkgIT0gMCkKCQlkaWVfZXJybm8oIkZhaWxlZCBzZWVraW5nIHRvIHN0YXJ0IG9mICclcyciLCBwYWNrX25hbWUpOwoJcmVhZF9yZXN1bHQgPSByZWFkX2luX2Z1bGwocGFja19mZCwgJmhkciwgc2l6ZW9mKGhkcikpOwoJaWYgKHJlYWRfcmVzdWx0IDwgMCkKCQlkaWVfZXJybm8oIlVuYWJsZSB0byByZXJlYWQgaGVhZGVyIG9mICclcyciLCBwYWNrX25hbWUpOwoJZWxzZSBpZiAocmVhZF9yZXN1bHQgIT0gc2l6ZW9mKGhkcikpCgkJZGllX2Vycm5vKCJVbmV4cGVjdGVkIHNob3J0IHJlYWQgZm9yIGhlYWRlciBvZiAnJXMnIiwKCQkJICBwYWNrX25hbWUpOwoJaWYgKGxzZWVrKHBhY2tfZmQsIDAsIFNFRUtfU0VUKSAhPSAwKQoJCWRpZV9lcnJubygiRmFpbGVkIHNlZWtpbmcgdG8gc3RhcnQgb2YgJyVzJyIsIHBhY2tfbmFtZSk7Cgl0aGVfaGFzaF9hbGdvLT51cGRhdGVfZm4oJm9sZF9oYXNoX2N0eCwgJmhkciwgc2l6ZW9mKGhkcikpOwoJaGRyLmhkcl9lbnRyaWVzID0gaHRvbmwob2JqZWN0X2NvdW50KTsKCXRoZV9oYXNoX2FsZ28tPnVwZGF0ZV9mbigmbmV3X2hhc2hfY3R4LCAmaGRyLCBzaXplb2YoaGRyKSk7Cgl3cml0ZV9vcl9kaWUocGFja19mZCwgJmhkciwgc2l6ZW9mKGhkcikpOwoJcGFydGlhbF9wYWNrX29mZnNldCAtPSBzaXplb2YoaGRyKTsKCglidWYgPSB4bWFsbG9jKGJ1Zl9zeik7CglhbGlnbmVkX3N6ID0gYnVmX3N6IC0gc2l6ZW9mKGhkcik7Cglmb3IgKDs7KSB7CgkJc3NpemVfdCBtLCBuOwoJCW0gPSAocGFydGlhbF9wYWNrX2hhc2ggJiYgcGFydGlhbF9wYWNrX29mZnNldCA8IGFsaWduZWRfc3opID8KCQkJcGFydGlhbF9wYWNrX29mZnNldCA6IGFsaWduZWRfc3o7CgkJbiA9IHhyZWFkKHBhY2tfZmQsIGJ1ZiwgbSk7CgkJaWYgKCFuKQoJCQlicmVhazsKCQlpZiAobiA8IDApCgkJCWRpZV9lcnJubygiRmFpbGVkIHRvIGNoZWNrc3VtICclcyciLCBwYWNrX25hbWUpOwoJCXRoZV9oYXNoX2FsZ28tPnVwZGF0ZV9mbigmbmV3X2hhc2hfY3R4LCBidWYsIG4pOwoKCQlhbGlnbmVkX3N6IC09IG47CgkJaWYgKCFhbGlnbmVkX3N6KQoJCQlhbGlnbmVkX3N6ID0gYnVmX3N6OwoKCQlpZiAoIXBhcnRpYWxfcGFja19oYXNoKQoJCQljb250aW51ZTsKCgkJdGhlX2hhc2hfYWxnby0+dXBkYXRlX2ZuKCZvbGRfaGFzaF9jdHgsIGJ1Ziwgbik7CgkJcGFydGlhbF9wYWNrX29mZnNldCAtPSBuOwoJCWlmIChwYXJ0aWFsX3BhY2tfb2Zmc2V0ID09IDApIHsKCQkJdW5zaWduZWQgY2hhciBoYXNoW0dJVF9NQVhfUkFXU1pdOwoJCQl0aGVfaGFzaF9hbGdvLT5maW5hbF9mbihoYXNoLCAmb2xkX2hhc2hfY3R4KTsKCQkJaWYgKCFoYXNoZXEoaGFzaCwgcGFydGlhbF9wYWNrX2hhc2gpKQoJCQkJZGllKCJVbmV4cGVjdGVkIGNoZWNrc3VtIGZvciAlcyAiCgkJCQkgICAgIihkaXNrIGNvcnJ1cHRpb24/KSIsIHBhY2tfbmFtZSk7CgkJCS8qCgkJCSAqIE5vdyBsZXQncyBjb21wdXRlIHRoZSBTSEExIG9mIHRoZSByZW1haW5kZXIgb2YgdGhlCgkJCSAqIHBhY2ssIHdoaWNoIGFsc28gbWVhbnMgbWFraW5nIHBhcnRpYWxfcGFja19vZmZzZXQKCQkJICogYmlnIGVub3VnaCBub3QgdG8gbWF0dGVyIGFueW1vcmUuCgkJCSAqLwoJCQl0aGVfaGFzaF9hbGdvLT5pbml0X2ZuKCZvbGRfaGFzaF9jdHgpOwoJCQlwYXJ0aWFsX3BhY2tfb2Zmc2V0ID0gfnBhcnRpYWxfcGFja19vZmZzZXQ7CgkJCXBhcnRpYWxfcGFja19vZmZzZXQgLT0gTVNCKHBhcnRpYWxfcGFja19vZmZzZXQsIDEpOwoJCX0KCX0KCWZyZWUoYnVmKTsKCglpZiAocGFydGlhbF9wYWNrX2hhc2gpCgkJdGhlX2hhc2hfYWxnby0+ZmluYWxfZm4ocGFydGlhbF9wYWNrX2hhc2gsICZvbGRfaGFzaF9jdHgpOwoJdGhlX2hhc2hfYWxnby0+ZmluYWxfZm4obmV3X3BhY2tfaGFzaCwgJm5ld19oYXNoX2N0eCk7Cgl3cml0ZV9vcl9kaWUocGFja19mZCwgbmV3X3BhY2tfaGFzaCwgdGhlX2hhc2hfYWxnby0+cmF3c3opOwoJZnN5bmNfY29tcG9uZW50X29yX2RpZShGU1lOQ19DT01QT05FTlRfUEFDSywgcGFja19mZCwgcGFja19uYW1lKTsKfQoKY2hhciAqaW5kZXhfcGFja19sb2NrZmlsZShpbnQgaXBfb3V0LCBpbnQgKmlzX3dlbGxfZm9ybWVkKQp7CgljaGFyIHBhY2tuYW1lW0dJVF9NQVhfSEVYU1ogKyA2XTsKCWNvbnN0IGludCBsZW4gPSB0aGVfaGFzaF9hbGdvLT5oZXhzeiArIDY7CgoJLyoKCSAqIFRoZSBmaXJzdCB0aGluZyB3ZSBleHBlY3QgZnJvbSBpbmRleC1wYWNrJ3Mgb3V0cHV0CgkgKiBpcyAicGFja1x0JTQwc1xuIiBvciAia2VlcFx0JTQwc1xuIiAoNDYgYnl0ZXMpIHdoZXJlCgkgKiAlNDBzIGlzIHRoZSBuZXdseSBjcmVhdGVkIHBhY2sgU0hBMSBuYW1lLiAgSW4gdGhlICJrZWVwIgoJICogY2FzZSwgd2UgbmVlZCBpdCB0byByZW1vdmUgdGhlIGNvcnJlc3BvbmRpbmcgLmtlZXAgZmlsZQoJICogbGF0ZXIgb24uICBJZiB3ZSBkb24ndCBnZXQgdGhhdCB0aGVuIHRvdWdoIGx1Y2sgd2l0aCBpdC4KCSAqLwoJaWYgKHJlYWRfaW5fZnVsbChpcF9vdXQsIHBhY2tuYW1lLCBsZW4pID09IGxlbiAmJiBwYWNrbmFtZVtsZW4tMV0gPT0gJ1xuJykgewoJCWNvbnN0IGNoYXIgKm5hbWU7CgoJCWlmIChpc193ZWxsX2Zvcm1lZCkKCQkJKmlzX3dlbGxfZm9ybWVkID0gMTsKCQlwYWNrbmFtZVtsZW4tMV0gPSAwOwoJCWlmIChza2lwX3ByZWZpeChwYWNrbmFtZSwgImtlZXBcdCIsICZuYW1lKSkKCQkJcmV0dXJuIHhzdHJmbXQoIiVzL3BhY2svcGFjay0lcy5rZWVwIiwKCQkJCSAgICAgICBnZXRfb2JqZWN0X2RpcmVjdG9yeSgpLCBuYW1lKTsKCQlyZXR1cm4gTlVMTDsKCX0KCWlmIChpc193ZWxsX2Zvcm1lZCkKCQkqaXNfd2VsbF9mb3JtZWQgPSAwOwoJcmV0dXJuIE5VTEw7Cn0KCi8qCiAqIFRoZSBwZXItb2JqZWN0IGhlYWRlciBpcyBhIHByZXR0eSBkZW5zZSB0aGluZywgd2hpY2ggaXMKICogIC0gZmlyc3QgYnl0ZTogbG93IGZvdXIgYml0cyBhcmUgInNpemUiLCB0aGVuIHRocmVlIGJpdHMgb2YgInR5cGUiLAogKiAgICBhbmQgdGhlIGhpZ2ggYml0IGlzICJzaXplIGNvbnRpbnVlcyIuCiAqICAtIGVhY2ggYnl0ZSBhZnRlcndhcmRzOiBsb3cgc2V2ZW4gYml0cyBhcmUgc2l6ZSBjb250aW51YXRpb24sCiAqICAgIHdpdGggdGhlIGhpZ2ggYml0IGJlaW5nICJzaXplIGNvbnRpbnVlcyIKICovCmludCBlbmNvZGVfaW5fcGFja19vYmplY3RfaGVhZGVyKHVuc2lnbmVkIGNoYXIgKmhkciwgaW50IGhkcl9sZW4sCgkJCQkgZW51bSBvYmplY3RfdHlwZSB0eXBlLCB1aW50bWF4X3Qgc2l6ZSkKewoJaW50IG4gPSAxOwoJdW5zaWduZWQgY2hhciBjOwoKCWlmICh0eXBlIDwgT0JKX0NPTU1JVCB8fCB0eXBlID4gT0JKX1JFRl9ERUxUQSkKCQlkaWUoImJhZCB0eXBlICVkIiwgdHlwZSk7CgoJYyA9ICh0eXBlIDw8IDQpIHwgKHNpemUgJiAxNSk7CglzaXplID4+PSA0OwoJd2hpbGUgKHNpemUpIHsKCQlpZiAobiA9PSBoZHJfbGVuKQoJCQlkaWUoIm9iamVjdCBzaXplIGlzIHRvbyBlbm9ybW91cyB0byBmb3JtYXQiKTsKCQkqaGRyKysgPSBjIHwgMHg4MDsKCQljID0gc2l6ZSAmIDB4N2Y7CgkJc2l6ZSA+Pj0gNzsKCQluKys7Cgl9CgkqaGRyID0gYzsKCXJldHVybiBuOwp9CgpzdHJ1Y3QgaGFzaGZpbGUgKmNyZWF0ZV90bXBfcGFja2ZpbGUoY2hhciAqKnBhY2tfdG1wX25hbWUpCnsKCXN0cnVjdCBzdHJidWYgdG1wbmFtZSA9IFNUUkJVRl9JTklUOwoJaW50IGZkOwoKCWZkID0gb2RiX21rc3RlbXAoJnRtcG5hbWUsICJwYWNrL3RtcF9wYWNrX1hYWFhYWCIpOwoJKnBhY2tfdG1wX25hbWUgPSBzdHJidWZfZGV0YWNoKCZ0bXBuYW1lLCBOVUxMKTsKCXJldHVybiBoYXNoZmQoZmQsICpwYWNrX3RtcF9uYW1lKTsKfQoKc3RhdGljIHZvaWQgcmVuYW1lX3RtcF9wYWNrZmlsZShzdHJ1Y3Qgc3RyYnVmICpuYW1lX3ByZWZpeCwgY29uc3QgY2hhciAqc291cmNlLAoJCQkJY29uc3QgY2hhciAqZXh0KQp7CglzaXplX3QgbmFtZV9wcmVmaXhfbGVuID0gbmFtZV9wcmVmaXgtPmxlbjsKCglzdHJidWZfYWRkc3RyKG5hbWVfcHJlZml4LCBleHQpOwoJaWYgKHJlbmFtZShzb3VyY2UsIG5hbWVfcHJlZml4LT5idWYpKQoJCWRpZV9lcnJubygidW5hYmxlIHRvIHJlbmFtZSB0ZW1wb3JhcnkgZmlsZSB0byAnJXMnIiwKCQkJICBuYW1lX3ByZWZpeC0+YnVmKTsKCXN0cmJ1Zl9zZXRsZW4obmFtZV9wcmVmaXgsIG5hbWVfcHJlZml4X2xlbik7Cn0KCnZvaWQgcmVuYW1lX3RtcF9wYWNrZmlsZV9pZHgoc3RydWN0IHN0cmJ1ZiAqbmFtZV9idWZmZXIsCgkJCSAgICAgY2hhciAqKmlkeF90bXBfbmFtZSkKewoJcmVuYW1lX3RtcF9wYWNrZmlsZShuYW1lX2J1ZmZlciwgKmlkeF90bXBfbmFtZSwgImlkeCIpOwp9Cgp2b2lkIHN0YWdlX3RtcF9wYWNrZmlsZXMoc3RydWN0IHN0cmJ1ZiAqbmFtZV9idWZmZXIsCgkJCSBjb25zdCBjaGFyICpwYWNrX3RtcF9uYW1lLAoJCQkgc3RydWN0IHBhY2tfaWR4X2VudHJ5ICoqd3JpdHRlbl9saXN0LAoJCQkgdWludDMyX3QgbnJfd3JpdHRlbiwKCQkJIHN0cnVjdCBwYWNraW5nX2RhdGEgKnRvX3BhY2ssCgkJCSBzdHJ1Y3QgcGFja19pZHhfb3B0aW9uICpwYWNrX2lkeF9vcHRzLAoJCQkgdW5zaWduZWQgY2hhciBoYXNoW10sCgkJCSBjaGFyICoqaWR4X3RtcF9uYW1lKQp7Cgljb25zdCBjaGFyICpyZXZfdG1wX25hbWUgPSBOVUxMOwoJY29uc3QgY2hhciAqbXRpbWVzX3RtcF9uYW1lID0gTlVMTDsKCglpZiAoYWRqdXN0X3NoYXJlZF9wZXJtKHBhY2tfdG1wX25hbWUpKQoJCWRpZV9lcnJubygidW5hYmxlIHRvIG1ha2UgdGVtcG9yYXJ5IHBhY2sgZmlsZSByZWFkYWJsZSIpOwoKCSppZHhfdG1wX25hbWUgPSAoY2hhciAqKXdyaXRlX2lkeF9maWxlKE5VTEwsIHdyaXR0ZW5fbGlzdCwgbnJfd3JpdHRlbiwKCQkJCQkgICAgICAgcGFja19pZHhfb3B0cywgaGFzaCk7CglpZiAoYWRqdXN0X3NoYXJlZF9wZXJtKCppZHhfdG1wX25hbWUpKQoJCWRpZV9lcnJubygidW5hYmxlIHRvIG1ha2UgdGVtcG9yYXJ5IGluZGV4IGZpbGUgcmVhZGFibGUiKTsKCglyZXZfdG1wX25hbWUgPSB3cml0ZV9yZXZfZmlsZShOVUxMLCB3cml0dGVuX2xpc3QsIG5yX3dyaXR0ZW4sIGhhc2gsCgkJCQkgICAgICBwYWNrX2lkeF9vcHRzLT5mbGFncyk7CgoJaWYgKHBhY2tfaWR4X29wdHMtPmZsYWdzICYgV1JJVEVfTVRJTUVTKSB7CgkJbXRpbWVzX3RtcF9uYW1lID0gd3JpdGVfbXRpbWVzX2ZpbGUodG9fcGFjaywgd3JpdHRlbl9saXN0LAoJCQkJCQkgICAgbnJfd3JpdHRlbiwKCQkJCQkJICAgIGhhc2gpOwoJfQoKCXJlbmFtZV90bXBfcGFja2ZpbGUobmFtZV9idWZmZXIsIHBhY2tfdG1wX25hbWUsICJwYWNrIik7CglpZiAocmV2X3RtcF9uYW1lKQoJCXJlbmFtZV90bXBfcGFja2ZpbGUobmFtZV9idWZmZXIsIHJldl90bXBfbmFtZSwgInJldiIpOwoJaWYgKG10aW1lc190bXBfbmFtZSkKCQlyZW5hbWVfdG1wX3BhY2tmaWxlKG5hbWVfYnVmZmVyLCBtdGltZXNfdG1wX25hbWUsICJtdGltZXMiKTsKfQoKdm9pZCB3cml0ZV9wcm9taXNvcl9maWxlKGNvbnN0IGNoYXIgKnByb21pc29yX25hbWUsIHN0cnVjdCByZWYgKipzb3VnaHQsIGludCBucl9zb3VnaHQpCnsKCWludCBpLCBlcnI7CglGSUxFICpvdXRwdXQgPSB4Zm9wZW4ocHJvbWlzb3JfbmFtZSwgInciKTsKCglmb3IgKGkgPSAwOyBpIDwgbnJfc291Z2h0OyBpKyspCgkJZnByaW50ZihvdXRwdXQsICIlcyAlc1xuIiwgb2lkX3RvX2hleCgmc291Z2h0W2ldLT5vbGRfb2lkKSwKCQkJc291Z2h0W2ldLT5uYW1lKTsKCgllcnIgPSBmZXJyb3Iob3V0cHV0KTsKCWVyciB8PSBmY2xvc2Uob3V0cHV0KTsKCWlmIChlcnIpCgkJZGllKF8oImNvdWxkIG5vdCB3cml0ZSAnJXMnIHByb21pc29yIGZpbGUiKSwgcHJvbWlzb3JfbmFtZSk7Cn0K",
    "text": "#include \"cache.h\"\n#include \"pack.h\"\n#include \"csum-file.h\"\n#include \"remote.h\"\n#include \"chunk-format.h\"\n#include \"pack-mtimes.h\"\n#include \"oidmap.h\"\n#include \"chunk-format.h\"\n#include \"pack-objects.h\"\n\nvoid reset_pack_idx_option(struct pack_idx_option *opts)\n{\n\tmemset(opts, 0, sizeof(*opts));\n\topts->version = 2;\n\topts->off32_limit = 0x7fffffff;\n}\n\nstatic int sha1_compare(const void *_a, const void *_b)\n{\n\tstruct pack_idx_entry *a = *(struct pack_idx_entry **)_a;\n\tstruct pack_idx_entry *b = *(struct pack_idx_entry **)_b;\n\treturn oidcmp(&a->oid, &b->oid);\n}\n\nstatic int cmp_uint32(const void *a_, const void *b_)\n{\n\tuint32_t a = *((uint32_t *)a_);\n\tuint32_t b = *((uint32_t *)b_);\n\n\treturn (a < b) ? -1 : (a != b);\n}\n\nstatic int need_large_offset(off_t offset, const struct pack_idx_option *opts)\n{\n\tuint32_t ofsval;\n\n\tif ((offset >> 31) || (opts->off32_limit < offset))\n\t\treturn 1;\n\tif (!opts->anomaly_nr)\n\t\treturn 0;\n\tofsval = offset;\n\treturn !!bsearch(&ofsval, opts->anomaly, opts->anomaly_nr,\n\t\t\t sizeof(ofsval), cmp_uint32);\n}\n\n/*\n * The *sha1 contains the pack content SHA1 hash.\n * The objects array passed in will be sorted by SHA1 on exit.\n */\nconst char *write_idx_file(const char *index_name, struct pack_idx_entry **objects,\n\t\t\t   int nr_objects, const struct pack_idx_option *opts,\n\t\t\t   const unsigned char *sha1)\n{\n\tstruct hashfile *f;\n\tstruct pack_idx_entry **sorted_by_sha, **list, **last;\n\toff_t last_obj_offset = 0;\n\tint i, fd;\n\tuint32_t index_version;\n\n\tif (nr_objects) {\n\t\tsorted_by_sha = objects;\n\t\tlist = sorted_by_sha;\n\t\tlast = sorted_by_sha + nr_objects;\n\t\tfor (i = 0; i < nr_objects; ++i) {\n\t\t\tif (objects[i]->offset > last_obj_offset)\n\t\t\t\tlast_obj_offset = objects[i]->offset;\n\t\t}\n\t\tQSORT(sorted_by_sha, nr_objects, sha1_compare);\n\t}\n\telse\n\t\tsorted_by_sha = list = last = NULL;\n\n\tif (opts->flags & WRITE_IDX_VERIFY) {\n\t\tassert(index_name);\n\t\tf = hashfd_check(index_name);\n\t} else {\n\t\tif (!index_name) {\n\t\t\tstruct strbuf tmp_file = STRBUF_INIT;\n\t\t\tfd = odb_mkstemp(&tmp_file, \"pack/tmp_idx_XXXXXX\");\n\t\t\tindex_name = strbuf_detach(&tmp_file, NULL);\n\t\t} else {\n\t\t\tunlink(index_name);\n\t\t\tfd = xopen(index_name, O_CREAT|O_EXCL|O_WRONLY, 0600);\n\t\t}\n\t\tf = hashfd(fd, index_name);\n\t}\n\n\t/* if last object's offset is >= 2^31 we should use index V2 */\n\tindex_version = need_large_offset(last_obj_offset, opts) ? 2 : opts->version;\n\n\t/* index versions 2 and above need a header */\n\tif (index_version >= 2) {\n\t\tstruct pack_idx_header hdr;\n\t\thdr.idx_signature = htonl(PACK_IDX_SIGNATURE);\n\t\thdr.idx_version = htonl(index_version);\n\t\thashwrite(f, &hdr, sizeof(hdr));\n\t}\n\n\t/*\n\t * Write the first-level table (the list is sorted,\n\t * but we use a 256-entry lookup to be able to avoid\n\t * having to do eight extra binary search iterations).\n\t */\n\tfor (i = 0; i < 256; i++) {\n\t\tstruct pack_idx_entry **next = list;\n\t\twhile (next < last) {\n\t\t\tstruct pack_idx_entry *obj = *next;\n\t\t\tif (obj->oid.hash[0] != i)\n\t\t\t\tbreak;\n\t\t\tnext++;\n\t\t}\n\t\thashwrite_be32(f, next - sorted_by_sha);\n\t\tlist = next;\n\t}\n\n\t/*\n\t * Write the actual SHA1 entries..\n\t */\n\tlist = sorted_by_sha;\n\tfor (i = 0; i < nr_objects; i++) {\n\t\tstruct pack_idx_entry *obj = *list++;\n\t\tif (index_version < 2)\n\t\t\thashwrite_be32(f, obj->offset);\n\t\thashwrite(f, obj->oid.hash, the_hash_algo->rawsz);\n\t\tif ((opts->flags & WRITE_IDX_STRICT) &&\n\t\t    (i && oideq(&list[-2]->oid, &obj->oid)))\n\t\t\tdie(\"The same object %s appears twice in the pack\",\n\t\t\t    oid_to_hex(&obj->oid));\n\t}\n\n\tif (index_version >= 2) {\n\t\tunsigned int nr_large_offset = 0;\n\n\t\t/* write the crc32 table */\n\t\tlist = sorted_by_sha;\n\t\tfor (i = 0; i < nr_objects; i++) {\n\t\t\tstruct pack_idx_entry *obj = *list++;\n\t\t\thashwrite_be32(f, obj->crc32);\n\t\t}\n\n\t\t/* write the 32-bit offset table */\n\t\tlist = sorted_by_sha;\n\t\tfor (i = 0; i < nr_objects; i++) {\n\t\t\tstruct pack_idx_entry *obj = *list++;\n\t\t\tuint32_t offset;\n\n\t\t\toffset = (need_large_offset(obj->offset, opts)\n\t\t\t\t  ? (0x80000000 | nr_large_offset++)\n\t\t\t\t  : obj->offset);\n\t\t\thashwrite_be32(f, offset);\n\t\t}\n\n\t\t/* write the large offset table */\n\t\tlist = sorted_by_sha;\n\t\twhile (nr_large_offset) {\n\t\t\tstruct pack_idx_entry *obj = *list++;\n\t\t\tuint64_t offset = obj->offset;\n\n\t\t\tif (!need_large_offset(offset, opts))\n\t\t\t\tcontinue;\n\t\t\thashwrite_be64(f, offset);\n\t\t\tnr_large_offset--;\n\t\t}\n\t}\n\n\thashwrite(f, sha1, the_hash_algo->rawsz);\n\tfinalize_hashfile(f, NULL, FSYNC_COMPONENT_PACK_METADATA,\n\t\t\t  CSUM_HASH_IN_STREAM | CSUM_CLOSE |\n\t\t\t  ((opts->flags & WRITE_IDX_VERIFY) ? 0 : CSUM_FSYNC));\n\treturn index_name;\n}\n\nstatic int pack_order_cmp(const void *va, const void *vb, void *ctx)\n{\n\tstruct pack_idx_entry **objects = ctx;\n\n\toff_t oa = objects[*(uint32_t*)va]->offset;\n\toff_t ob = objects[*(uint32_t*)vb]->offset;\n\n\tif (oa < ob)\n\t\treturn -1;\n\tif (oa > ob)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic void write_rev_header(struct hashfile *f)\n{\n\thashwrite_be32(f, RIDX_SIGNATURE);\n\thashwrite_be32(f, RIDX_VERSION);\n\thashwrite_be32(f, oid_version(the_hash_algo));\n}\n\nstatic void write_rev_index_positions(struct hashfile *f,\n\t\t\t\t      uint32_t *pack_order,\n\t\t\t\t      uint32_t nr_objects)\n{\n\tuint32_t i;\n\tfor (i = 0; i < nr_objects; i++)\n\t\thashwrite_be32(f, pack_order[i]);\n}\n\nstatic void write_rev_trailer(struct hashfile *f, const unsigned char *hash)\n{\n\thashwrite(f, hash, the_hash_algo->rawsz);\n}\n\nconst char *write_rev_file(const char *rev_name,\n\t\t\t   struct pack_idx_entry **objects,\n\t\t\t   uint32_t nr_objects,\n\t\t\t   const unsigned char *hash,\n\t\t\t   unsigned flags)\n{\n\tuint32_t *pack_order;\n\tuint32_t i;\n\tconst char *ret;\n\n\tif (!(flags & WRITE_REV) && !(flags & WRITE_REV_VERIFY))\n\t\treturn NULL;\n\n\tALLOC_ARRAY(pack_order, nr_objects);\n\tfor (i = 0; i < nr_objects; i++)\n\t\tpack_order[i] = i;\n\tQSORT_S(pack_order, nr_objects, pack_order_cmp, objects);\n\n\tret = write_rev_file_order(rev_name, pack_order, nr_objects, hash,\n\t\t\t\t   flags);\n\n\tfree(pack_order);\n\n\treturn ret;\n}\n\nconst char *write_rev_file_order(const char *rev_name,\n\t\t\t\t uint32_t *pack_order,\n\t\t\t\t uint32_t nr_objects,\n\t\t\t\t const unsigned char *hash,\n\t\t\t\t unsigned flags)\n{\n\tstruct hashfile *f;\n\tint fd;\n\n\tif ((flags & WRITE_REV) && (flags & WRITE_REV_VERIFY))\n\t\tdie(_(\"cannot both write and verify reverse index\"));\n\n\tif (flags & WRITE_REV) {\n\t\tif (!rev_name) {\n\t\t\tstruct strbuf tmp_file = STRBUF_INIT;\n\t\t\tfd = odb_mkstemp(&tmp_file, \"pack/tmp_rev_XXXXXX\");\n\t\t\trev_name = strbuf_detach(&tmp_file, NULL);\n\t\t} else {\n\t\t\tunlink(rev_name);\n\t\t\tfd = xopen(rev_name, O_CREAT|O_EXCL|O_WRONLY, 0600);\n\t\t}\n\t\tf = hashfd(fd, rev_name);\n\t} else if (flags & WRITE_REV_VERIFY) {\n\t\tstruct stat statbuf;\n\t\tif (stat(rev_name, &statbuf)) {\n\t\t\tif (errno == ENOENT) {\n\t\t\t\t/* .rev files are optional */\n\t\t\t\treturn NULL;\n\t\t\t} else\n\t\t\t\tdie_errno(_(\"could not stat: %s\"), rev_name);\n\t\t}\n\t\tf = hashfd_check(rev_name);\n\t} else\n\t\treturn NULL;\n\n\twrite_rev_header(f);\n\n\twrite_rev_index_positions(f, pack_order, nr_objects);\n\twrite_rev_trailer(f, hash);\n\n\tif (rev_name && adjust_shared_perm(rev_name) < 0)\n\t\tdie(_(\"failed to make %s readable\"), rev_name);\n\n\tfinalize_hashfile(f, NULL, FSYNC_COMPONENT_PACK_METADATA,\n\t\t\t  CSUM_HASH_IN_STREAM | CSUM_CLOSE |\n\t\t\t  ((flags & WRITE_IDX_VERIFY) ? 0 : CSUM_FSYNC));\n\n\treturn rev_name;\n}\n\nstatic void write_mtimes_header(struct hashfile *f)\n{\n\thashwrite_be32(f, MTIMES_SIGNATURE);\n\thashwrite_be32(f, MTIMES_VERSION);\n\thashwrite_be32(f, oid_version(the_hash_algo));\n}\n\n/*\n * Writes the object mtimes of \"objects\" for use in a .mtimes file.\n * Note that objects must be in lexicographic (index) order, which is\n * the expected ordering of these values in the .mtimes file.\n */\nstatic void write_mtimes_objects(struct hashfile *f,\n\t\t\t\t struct packing_data *to_pack,\n\t\t\t\t struct pack_idx_entry **objects,\n\t\t\t\t uint32_t nr_objects)\n{\n\tuint32_t i;\n\tfor (i = 0; i < nr_objects; i++) {\n\t\tstruct object_entry *e = (struct object_entry*)objects[i];\n\t\thashwrite_be32(f, oe_cruft_mtime(to_pack, e));\n\t}\n}\n\nstatic void write_mtimes_trailer(struct hashfile *f, const unsigned char *hash)\n{\n\thashwrite(f, hash, the_hash_algo->rawsz);\n}\n\nstatic const char *write_mtimes_file(struct packing_data *to_pack,\n\t\t\t\t     struct pack_idx_entry **objects,\n\t\t\t\t     uint32_t nr_objects,\n\t\t\t\t     const unsigned char *hash)\n{\n\tstruct strbuf tmp_file = STRBUF_INIT;\n\tconst char *mtimes_name;\n\tstruct hashfile *f;\n\tint fd;\n\n\tif (!to_pack)\n\t\tBUG(\"cannot call write_mtimes_file with NULL packing_data\");\n\n\tfd = odb_mkstemp(&tmp_file, \"pack/tmp_mtimes_XXXXXX\");\n\tmtimes_name = strbuf_detach(&tmp_file, NULL);\n\tf = hashfd(fd, mtimes_name);\n\n\twrite_mtimes_header(f);\n\twrite_mtimes_objects(f, to_pack, objects, nr_objects);\n\twrite_mtimes_trailer(f, hash);\n\n\tif (adjust_shared_perm(mtimes_name) < 0)\n\t\tdie(_(\"failed to make %s readable\"), mtimes_name);\n\n\tfinalize_hashfile(f, NULL, FSYNC_COMPONENT_PACK_METADATA,\n\t\t\t  CSUM_HASH_IN_STREAM | CSUM_CLOSE | CSUM_FSYNC);\n\n\treturn mtimes_name;\n}\n\noff_t write_pack_header(struct hashfile *f, uint32_t nr_entries)\n{\n\tstruct pack_header hdr;\n\n\thdr.hdr_signature = htonl(PACK_SIGNATURE);\n\thdr.hdr_version = htonl(PACK_VERSION);\n\thdr.hdr_entries = htonl(nr_entries);\n\thashwrite(f, &hdr, sizeof(hdr));\n\treturn sizeof(hdr);\n}\n\n/*\n * Update pack header with object_count and compute new SHA1 for pack data\n * associated to pack_fd, and write that SHA1 at the end.  That new SHA1\n * is also returned in new_pack_sha1.\n *\n * If partial_pack_sha1 is non null, then the SHA1 of the existing pack\n * (without the header update) is computed and validated against the\n * one provided in partial_pack_sha1.  The validation is performed at\n * partial_pack_offset bytes in the pack file.  The SHA1 of the remaining\n * data (i.e. from partial_pack_offset to the end) is then computed and\n * returned in partial_pack_sha1.\n *\n * Note that new_pack_sha1 is updated last, so both new_pack_sha1 and\n * partial_pack_sha1 can refer to the same buffer if the caller is not\n * interested in the resulting SHA1 of pack data above partial_pack_offset.\n */\nvoid fixup_pack_header_footer(int pack_fd,\n\t\t\t unsigned char *new_pack_hash,\n\t\t\t const char *pack_name,\n\t\t\t uint32_t object_count,\n\t\t\t unsigned char *partial_pack_hash,\n\t\t\t off_t partial_pack_offset)\n{\n\tint aligned_sz, buf_sz = 8 * 1024;\n\tgit_hash_ctx old_hash_ctx, new_hash_ctx;\n\tstruct pack_header hdr;\n\tchar *buf;\n\tssize_t read_result;\n\n\tthe_hash_algo->init_fn(&old_hash_ctx);\n\tthe_hash_algo->init_fn(&new_hash_ctx);\n\n\tif (lseek(pack_fd, 0, SEEK_SET) != 0)\n\t\tdie_errno(\"Failed seeking to start of '%s'\", pack_name);\n\tread_result = read_in_full(pack_fd, &hdr, sizeof(hdr));\n\tif (read_result < 0)\n\t\tdie_errno(\"Unable to reread header of '%s'\", pack_name);\n\telse if (read_result != sizeof(hdr))\n\t\tdie_errno(\"Unexpected short read for header of '%s'\",\n\t\t\t  pack_name);\n\tif (lseek(pack_fd, 0, SEEK_SET) != 0)\n\t\tdie_errno(\"Failed seeking to start of '%s'\", pack_name);\n\tthe_hash_algo->update_fn(&old_hash_ctx, &hdr, sizeof(hdr));\n\thdr.hdr_entries = htonl(object_count);\n\tthe_hash_algo->update_fn(&new_hash_ctx, &hdr, sizeof(hdr));\n\twrite_or_die(pack_fd, &hdr, sizeof(hdr));\n\tpartial_pack_offset -= sizeof(hdr);\n\n\tbuf = xmalloc(buf_sz);\n\taligned_sz = buf_sz - sizeof(hdr);\n\tfor (;;) {\n\t\tssize_t m, n;\n\t\tm = (partial_pack_hash && partial_pack_offset < aligned_sz) ?\n\t\t\tpartial_pack_offset : aligned_sz;\n\t\tn = xread(pack_fd, buf, m);\n\t\tif (!n)\n\t\t\tbreak;\n\t\tif (n < 0)\n\t\t\tdie_errno(\"Failed to checksum '%s'\", pack_name);\n\t\tthe_hash_algo->update_fn(&new_hash_ctx, buf, n);\n\n\t\taligned_sz -= n;\n\t\tif (!aligned_sz)\n\t\t\taligned_sz = buf_sz;\n\n\t\tif (!partial_pack_hash)\n\t\t\tcontinue;\n\n\t\tthe_hash_algo->update_fn(&old_hash_ctx, buf, n);\n\t\tpartial_pack_offset -= n;\n\t\tif (partial_pack_offset == 0) {\n\t\t\tunsigned char hash[GIT_MAX_RAWSZ];\n\t\t\tthe_hash_algo->final_fn(hash, &old_hash_ctx);\n\t\t\tif (!hasheq(hash, partial_pack_hash))\n\t\t\t\tdie(\"Unexpected checksum for %s \"\n\t\t\t\t    \"(disk corruption?)\", pack_name);\n\t\t\t/*\n\t\t\t * Now let's compute the SHA1 of the remainder of the\n\t\t\t * pack, which also means making partial_pack_offset\n\t\t\t * big enough not to matter anymore.\n\t\t\t */\n\t\t\tthe_hash_algo->init_fn(&old_hash_ctx);\n\t\t\tpartial_pack_offset = ~partial_pack_offset;\n\t\t\tpartial_pack_offset -= MSB(partial_pack_offset, 1);\n\t\t}\n\t}\n\tfree(buf);\n\n\tif (partial_pack_hash)\n\t\tthe_hash_algo->final_fn(partial_pack_hash, &old_hash_ctx);\n\tthe_hash_algo->final_fn(new_pack_hash, &new_hash_ctx);\n\twrite_or_die(pack_fd, new_pack_hash, the_hash_algo->rawsz);\n\tfsync_component_or_die(FSYNC_COMPONENT_PACK, pack_fd, pack_name);\n}\n\nchar *index_pack_lockfile(int ip_out, int *is_well_formed)\n{\n\tchar packname[GIT_MAX_HEXSZ + 6];\n\tconst int len = the_hash_algo->hexsz + 6;\n\n\t/*\n\t * The first thing we expect from index-pack's output\n\t * is \"pack\\t%40s\\n\" or \"keep\\t%40s\\n\" (46 bytes) where\n\t * %40s is the newly created pack SHA1 name.  In the \"keep\"\n\t * case, we need it to remove the corresponding .keep file\n\t * later on.  If we don't get that then tough luck with it.\n\t */\n\tif (read_in_full(ip_out, packname, len) == len && packname[len-1] == '\\n') {\n\t\tconst char *name;\n\n\t\tif (is_well_formed)\n\t\t\t*is_well_formed = 1;\n\t\tpackname[len-1] = 0;\n\t\tif (skip_prefix(packname, \"keep\\t\", &name))\n\t\t\treturn xstrfmt(\"%s/pack/pack-%s.keep\",\n\t\t\t\t       get_object_directory(), name);\n\t\treturn NULL;\n\t}\n\tif (is_well_formed)\n\t\t*is_well_formed = 0;\n\treturn NULL;\n}\n\n/*\n * The per-object header is a pretty dense thing, which is\n *  - first byte: low four bits are \"size\", then three bits of \"type\",\n *    and the high bit is \"size continues\".\n *  - each byte afterwards: low seven bits are size continuation,\n *    with the high bit being \"size continues\"\n */\nint encode_in_pack_object_header(unsigned char *hdr, int hdr_len,\n\t\t\t\t enum object_type type, uintmax_t size)\n{\n\tint n = 1;\n\tunsigned char c;\n\n\tif (type < OBJ_COMMIT || type > OBJ_REF_DELTA)\n\t\tdie(\"bad type %d\", type);\n\n\tc = (type << 4) | (size & 15);\n\tsize >>= 4;\n\twhile (size) {\n\t\tif (n == hdr_len)\n\t\t\tdie(\"object size is too enormous to format\");\n\t\t*hdr++ = c | 0x80;\n\t\tc = size & 0x7f;\n\t\tsize >>= 7;\n\t\tn++;\n\t}\n\t*hdr = c;\n\treturn n;\n}\n\nstruct hashfile *create_tmp_packfile(char **pack_tmp_name)\n{\n\tstruct strbuf tmpname = STRBUF_INIT;\n\tint fd;\n\n\tfd = odb_mkstemp(&tmpname, \"pack/tmp_pack_XXXXXX\");\n\t*pack_tmp_name = strbuf_detach(&tmpname, NULL);\n\treturn hashfd(fd, *pack_tmp_name);\n}\n\nstatic void rename_tmp_packfile(struct strbuf *name_prefix, const char *source,\n\t\t\t\tconst char *ext)\n{\n\tsize_t name_prefix_len = name_prefix->len;\n\n\tstrbuf_addstr(name_prefix, ext);\n\tif (rename(source, name_prefix->buf))\n\t\tdie_errno(\"unable to rename temporary file to '%s'\",\n\t\t\t  name_prefix->buf);\n\tstrbuf_setlen(name_prefix, name_prefix_len);\n}\n\nvoid rename_tmp_packfile_idx(struct strbuf *name_buffer,\n\t\t\t     char **idx_tmp_name)\n{\n\trename_tmp_packfile(name_buffer, *idx_tmp_name, \"idx\");\n}\n\nvoid stage_tmp_packfiles(struct strbuf *name_buffer,\n\t\t\t const char *pack_tmp_name,\n\t\t\t struct pack_idx_entry **written_list,\n\t\t\t uint32_t nr_written,\n\t\t\t struct packing_data *to_pack,\n\t\t\t struct pack_idx_option *pack_idx_opts,\n\t\t\t unsigned char hash[],\n\t\t\t char **idx_tmp_name)\n{\n\tconst char *rev_tmp_name = NULL;\n\tconst char *mtimes_tmp_name = NULL;\n\n\tif (adjust_shared_perm(pack_tmp_name))\n\t\tdie_errno(\"unable to make temporary pack file readable\");\n\n\t*idx_tmp_name = (char *)write_idx_file(NULL, written_list, nr_written,\n\t\t\t\t\t       pack_idx_opts, hash);\n\tif (adjust_shared_perm(*idx_tmp_name))\n\t\tdie_errno(\"unable to make temporary index file readable\");\n\n\trev_tmp_name = write_rev_file(NULL, written_list, nr_written, hash,\n\t\t\t\t      pack_idx_opts->flags);\n\n\tif (pack_idx_opts->flags & WRITE_MTIMES) {\n\t\tmtimes_tmp_name = write_mtimes_file(to_pack, written_list,\n\t\t\t\t\t\t    nr_written,\n\t\t\t\t\t\t    hash);\n\t}\n\n\trename_tmp_packfile(name_buffer, pack_tmp_name, \"pack\");\n\tif (rev_tmp_name)\n\t\trename_tmp_packfile(name_buffer, rev_tmp_name, \"rev\");\n\tif (mtimes_tmp_name)\n\t\trename_tmp_packfile(name_buffer, mtimes_tmp_name, \"mtimes\");\n}\n\nvoid write_promisor_file(const char *promisor_name, struct ref **sought, int nr_sought)\n{\n\tint i, err;\n\tFILE *output = xfopen(promisor_name, \"w\");\n\n\tfor (i = 0; i < nr_sought; i++)\n\t\tfprintf(output, \"%s %s\\n\", oid_to_hex(&sought[i]->old_oid),\n\t\t\tsought[i]->name);\n\n\terr = ferror(output);\n\terr |= fclose(output);\n\tif (err)\n\t\tdie(_(\"could not write '%s' promisor file\"), promisor_name);\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00787e306db4c010ae68845f27ed69966fb9e250",
  "sha1_ok": true,
  "size": 16194
}
