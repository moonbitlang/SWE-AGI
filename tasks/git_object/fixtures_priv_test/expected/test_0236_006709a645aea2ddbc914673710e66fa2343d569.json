{
  "content": {
    "base64": "LyoKQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQwoKVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUKbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0Cmh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL29wZW4tc291cmNlL2xpY2Vuc2VzL2JzZAoqLwoKI2luY2x1ZGUgInJlYWRlci5oIgoKI2luY2x1ZGUgInN5c3RlbS5oIgojaW5jbHVkZSAiYmxvY2suaCIKI2luY2x1ZGUgImNvbnN0YW50cy5oIgojaW5jbHVkZSAiZ2VuZXJpYy5oIgojaW5jbHVkZSAiaXRlci5oIgojaW5jbHVkZSAicmVjb3JkLmgiCiNpbmNsdWRlICJyZWZ0YWJsZS1lcnJvci5oIgojaW5jbHVkZSAicmVmdGFibGUtZ2VuZXJpYy5oIgojaW5jbHVkZSAidHJlZS5oIgoKdWludDY0X3QgYmxvY2tfc291cmNlX3NpemUoc3RydWN0IHJlZnRhYmxlX2Jsb2NrX3NvdXJjZSAqc291cmNlKQp7CglyZXR1cm4gc291cmNlLT5vcHMtPnNpemUoc291cmNlLT5hcmcpOwp9CgppbnQgYmxvY2tfc291cmNlX3JlYWRfYmxvY2soc3RydWN0IHJlZnRhYmxlX2Jsb2NrX3NvdXJjZSAqc291cmNlLAoJCQkgICAgc3RydWN0IHJlZnRhYmxlX2Jsb2NrICpkZXN0LCB1aW50NjRfdCBvZmYsCgkJCSAgICB1aW50MzJfdCBzaXplKQp7CglpbnQgcmVzdWx0ID0gc291cmNlLT5vcHMtPnJlYWRfYmxvY2soc291cmNlLT5hcmcsIGRlc3QsIG9mZiwgc2l6ZSk7CglkZXN0LT5zb3VyY2UgPSAqc291cmNlOwoJcmV0dXJuIHJlc3VsdDsKfQoKdm9pZCBibG9ja19zb3VyY2VfY2xvc2Uoc3RydWN0IHJlZnRhYmxlX2Jsb2NrX3NvdXJjZSAqc291cmNlKQp7CglpZiAoIXNvdXJjZS0+b3BzKSB7CgkJcmV0dXJuOwoJfQoKCXNvdXJjZS0+b3BzLT5jbG9zZShzb3VyY2UtPmFyZyk7Cglzb3VyY2UtPm9wcyA9IE5VTEw7Cn0KCnN0YXRpYyBzdHJ1Y3QgcmVmdGFibGVfcmVhZGVyX29mZnNldHMgKgpyZWFkZXJfb2Zmc2V0c19mb3Ioc3RydWN0IHJlZnRhYmxlX3JlYWRlciAqciwgdWludDhfdCB0eXApCnsKCXN3aXRjaCAodHlwKSB7CgljYXNlIEJMT0NLX1RZUEVfUkVGOgoJCXJldHVybiAmci0+cmVmX29mZnNldHM7CgljYXNlIEJMT0NLX1RZUEVfTE9HOgoJCXJldHVybiAmci0+bG9nX29mZnNldHM7CgljYXNlIEJMT0NLX1RZUEVfT0JKOgoJCXJldHVybiAmci0+b2JqX29mZnNldHM7Cgl9CglhYm9ydCgpOwp9CgpzdGF0aWMgaW50IHJlYWRlcl9nZXRfYmxvY2soc3RydWN0IHJlZnRhYmxlX3JlYWRlciAqciwKCQkJICAgIHN0cnVjdCByZWZ0YWJsZV9ibG9jayAqZGVzdCwgdWludDY0X3Qgb2ZmLAoJCQkgICAgdWludDMyX3Qgc3opCnsKCWlmIChvZmYgPj0gci0+c2l6ZSkKCQlyZXR1cm4gMDsKCglpZiAob2ZmICsgc3ogPiByLT5zaXplKSB7CgkJc3ogPSByLT5zaXplIC0gb2ZmOwoJfQoKCXJldHVybiBibG9ja19zb3VyY2VfcmVhZF9ibG9jaygmci0+c291cmNlLCBkZXN0LCBvZmYsIHN6KTsKfQoKdWludDMyX3QgcmVmdGFibGVfcmVhZGVyX2hhc2hfaWQoc3RydWN0IHJlZnRhYmxlX3JlYWRlciAqcikKewoJcmV0dXJuIHItPmhhc2hfaWQ7Cn0KCmNvbnN0IGNoYXIgKnJlYWRlcl9uYW1lKHN0cnVjdCByZWZ0YWJsZV9yZWFkZXIgKnIpCnsKCXJldHVybiByLT5uYW1lOwp9CgpzdGF0aWMgaW50IHBhcnNlX2Zvb3RlcihzdHJ1Y3QgcmVmdGFibGVfcmVhZGVyICpyLCB1aW50OF90ICpmb290ZXIsCgkJCXVpbnQ4X3QgKmhlYWRlcikKewoJdWludDhfdCAqZiA9IGZvb3RlcjsKCXVpbnQ4X3QgZmlyc3RfYmxvY2tfdHlwOwoJaW50IGVyciA9IDA7Cgl1aW50MzJfdCBjb21wdXRlZF9jcmM7Cgl1aW50MzJfdCBmaWxlX2NyYzsKCglpZiAobWVtY21wKGYsICJSRUZUIiwgNCkpIHsKCQllcnIgPSBSRUZUQUJMRV9GT1JNQVRfRVJST1I7CgkJZ290byBkb25lOwoJfQoJZiArPSA0OwoKCWlmIChtZW1jbXAoZm9vdGVyLCBoZWFkZXIsIGhlYWRlcl9zaXplKHItPnZlcnNpb24pKSkgewoJCWVyciA9IFJFRlRBQkxFX0ZPUk1BVF9FUlJPUjsKCQlnb3RvIGRvbmU7Cgl9CgoJZisrOwoJci0+YmxvY2tfc2l6ZSA9IGdldF9iZTI0KGYpOwoKCWYgKz0gMzsKCXItPm1pbl91cGRhdGVfaW5kZXggPSBnZXRfYmU2NChmKTsKCWYgKz0gODsKCXItPm1heF91cGRhdGVfaW5kZXggPSBnZXRfYmU2NChmKTsKCWYgKz0gODsKCglpZiAoci0+dmVyc2lvbiA9PSAxKSB7CgkJci0+aGFzaF9pZCA9IEdJVF9TSEExX0ZPUk1BVF9JRDsKCX0gZWxzZSB7CgkJci0+aGFzaF9pZCA9IGdldF9iZTMyKGYpOwoJCXN3aXRjaCAoci0+aGFzaF9pZCkgewoJCWNhc2UgR0lUX1NIQTFfRk9STUFUX0lEOgoJCQlicmVhazsKCQljYXNlIEdJVF9TSEEyNTZfRk9STUFUX0lEOgoJCQlicmVhazsKCQlkZWZhdWx0OgoJCQllcnIgPSBSRUZUQUJMRV9GT1JNQVRfRVJST1I7CgkJCWdvdG8gZG9uZTsKCQl9CgkJZiArPSA0OwoJfQoKCXItPnJlZl9vZmZzZXRzLmluZGV4X29mZnNldCA9IGdldF9iZTY0KGYpOwoJZiArPSA4OwoKCXItPm9ial9vZmZzZXRzLm9mZnNldCA9IGdldF9iZTY0KGYpOwoJZiArPSA4OwoKCXItPm9iamVjdF9pZF9sZW4gPSByLT5vYmpfb2Zmc2V0cy5vZmZzZXQgJiAoKDEgPDwgNSkgLSAxKTsKCXItPm9ial9vZmZzZXRzLm9mZnNldCA+Pj0gNTsKCglyLT5vYmpfb2Zmc2V0cy5pbmRleF9vZmZzZXQgPSBnZXRfYmU2NChmKTsKCWYgKz0gODsKCXItPmxvZ19vZmZzZXRzLm9mZnNldCA9IGdldF9iZTY0KGYpOwoJZiArPSA4OwoJci0+bG9nX29mZnNldHMuaW5kZXhfb2Zmc2V0ID0gZ2V0X2JlNjQoZik7CglmICs9IDg7CgoJY29tcHV0ZWRfY3JjID0gY3JjMzIoMCwgZm9vdGVyLCBmIC0gZm9vdGVyKTsKCWZpbGVfY3JjID0gZ2V0X2JlMzIoZik7CglmICs9IDQ7CglpZiAoY29tcHV0ZWRfY3JjICE9IGZpbGVfY3JjKSB7CgkJZXJyID0gUkVGVEFCTEVfRk9STUFUX0VSUk9SOwoJCWdvdG8gZG9uZTsKCX0KCglmaXJzdF9ibG9ja190eXAgPSBoZWFkZXJbaGVhZGVyX3NpemUoci0+dmVyc2lvbildOwoJci0+cmVmX29mZnNldHMuaXNfcHJlc2VudCA9IChmaXJzdF9ibG9ja190eXAgPT0gQkxPQ0tfVFlQRV9SRUYpOwoJci0+cmVmX29mZnNldHMub2Zmc2V0ID0gMDsKCXItPmxvZ19vZmZzZXRzLmlzX3ByZXNlbnQgPSAoZmlyc3RfYmxvY2tfdHlwID09IEJMT0NLX1RZUEVfTE9HIHx8CgkJCQkgICAgIHItPmxvZ19vZmZzZXRzLm9mZnNldCA+IDApOwoJci0+b2JqX29mZnNldHMuaXNfcHJlc2VudCA9IHItPm9ial9vZmZzZXRzLm9mZnNldCA+IDA7CgllcnIgPSAwOwpkb25lOgoJcmV0dXJuIGVycjsKfQoKaW50IGluaXRfcmVhZGVyKHN0cnVjdCByZWZ0YWJsZV9yZWFkZXIgKnIsIHN0cnVjdCByZWZ0YWJsZV9ibG9ja19zb3VyY2UgKnNvdXJjZSwKCQljb25zdCBjaGFyICpuYW1lKQp7CglzdHJ1Y3QgcmVmdGFibGVfYmxvY2sgZm9vdGVyID0geyBOVUxMIH07CglzdHJ1Y3QgcmVmdGFibGVfYmxvY2sgaGVhZGVyID0geyBOVUxMIH07CglpbnQgZXJyID0gMDsKCXVpbnQ2NF90IGZpbGVfc2l6ZSA9IGJsb2NrX3NvdXJjZV9zaXplKHNvdXJjZSk7CgoJLyogTmVlZCArMSB0byByZWFkIHR5cGUgb2YgZmlyc3QgYmxvY2suICovCgl1aW50MzJfdCByZWFkX3NpemUgPSBoZWFkZXJfc2l6ZSgyKSArIDE7IC8qIHJlYWQgdjIgYmVjYXVzZSBpdCdzIGxhcmdlci4gICovCgltZW1zZXQociwgMCwgc2l6ZW9mKHN0cnVjdCByZWZ0YWJsZV9yZWFkZXIpKTsKCglpZiAocmVhZF9zaXplID4gZmlsZV9zaXplKSB7CgkJZXJyID0gUkVGVEFCTEVfRk9STUFUX0VSUk9SOwoJCWdvdG8gZG9uZTsKCX0KCgllcnIgPSBibG9ja19zb3VyY2VfcmVhZF9ibG9jayhzb3VyY2UsICZoZWFkZXIsIDAsIHJlYWRfc2l6ZSk7CglpZiAoZXJyICE9IHJlYWRfc2l6ZSkgewoJCWVyciA9IFJFRlRBQkxFX0lPX0VSUk9SOwoJCWdvdG8gZG9uZTsKCX0KCglpZiAobWVtY21wKGhlYWRlci5kYXRhLCAiUkVGVCIsIDQpKSB7CgkJZXJyID0gUkVGVEFCTEVfRk9STUFUX0VSUk9SOwoJCWdvdG8gZG9uZTsKCX0KCXItPnZlcnNpb24gPSBoZWFkZXIuZGF0YVs0XTsKCWlmIChyLT52ZXJzaW9uICE9IDEgJiYgci0+dmVyc2lvbiAhPSAyKSB7CgkJZXJyID0gUkVGVEFCTEVfRk9STUFUX0VSUk9SOwoJCWdvdG8gZG9uZTsKCX0KCglyLT5zaXplID0gZmlsZV9zaXplIC0gZm9vdGVyX3NpemUoci0+dmVyc2lvbik7CglyLT5zb3VyY2UgPSAqc291cmNlOwoJci0+bmFtZSA9IHhzdHJkdXAobmFtZSk7CglyLT5oYXNoX2lkID0gMDsKCgllcnIgPSBibG9ja19zb3VyY2VfcmVhZF9ibG9jayhzb3VyY2UsICZmb290ZXIsIHItPnNpemUsCgkJCQkgICAgICBmb290ZXJfc2l6ZShyLT52ZXJzaW9uKSk7CglpZiAoZXJyICE9IGZvb3Rlcl9zaXplKHItPnZlcnNpb24pKSB7CgkJZXJyID0gUkVGVEFCTEVfSU9fRVJST1I7CgkJZ290byBkb25lOwoJfQoKCWVyciA9IHBhcnNlX2Zvb3RlcihyLCBmb290ZXIuZGF0YSwgaGVhZGVyLmRhdGEpOwpkb25lOgoJcmVmdGFibGVfYmxvY2tfZG9uZSgmZm9vdGVyKTsKCXJlZnRhYmxlX2Jsb2NrX2RvbmUoJmhlYWRlcik7CglyZXR1cm4gZXJyOwp9CgpzdHJ1Y3QgdGFibGVfaXRlciB7CglzdHJ1Y3QgcmVmdGFibGVfcmVhZGVyICpyOwoJdWludDhfdCB0eXA7Cgl1aW50NjRfdCBibG9ja19vZmY7CglzdHJ1Y3QgYmxvY2tfaXRlciBiaTsKCWludCBpc19maW5pc2hlZDsKfTsKI2RlZmluZSBUQUJMRV9JVEVSX0lOSVQgICAgICAgICAgICAgICAgICAgICAgICAgIFwKCXsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAoJCS5iaSA9IHsubGFzdF9rZXkgPSBTVFJCVUZfSU5JVCB9IFwKCX0KCnN0YXRpYyB2b2lkIHRhYmxlX2l0ZXJfY29weV9mcm9tKHN0cnVjdCB0YWJsZV9pdGVyICpkZXN0LAoJCQkJIHN0cnVjdCB0YWJsZV9pdGVyICpzcmMpCnsKCWRlc3QtPnIgPSBzcmMtPnI7CglkZXN0LT50eXAgPSBzcmMtPnR5cDsKCWRlc3QtPmJsb2NrX29mZiA9IHNyYy0+YmxvY2tfb2ZmOwoJZGVzdC0+aXNfZmluaXNoZWQgPSBzcmMtPmlzX2ZpbmlzaGVkOwoJYmxvY2tfaXRlcl9jb3B5X2Zyb20oJmRlc3QtPmJpLCAmc3JjLT5iaSk7Cn0KCnN0YXRpYyBpbnQgdGFibGVfaXRlcl9uZXh0X2luX2Jsb2NrKHN0cnVjdCB0YWJsZV9pdGVyICp0aSwKCQkJCSAgICBzdHJ1Y3QgcmVmdGFibGVfcmVjb3JkICpyZWMpCnsKCWludCByZXMgPSBibG9ja19pdGVyX25leHQoJnRpLT5iaSwgcmVjKTsKCWlmIChyZXMgPT0gMCAmJiByZWZ0YWJsZV9yZWNvcmRfdHlwZShyZWMpID09IEJMT0NLX1RZUEVfUkVGKSB7CgkJKChzdHJ1Y3QgcmVmdGFibGVfcmVmX3JlY29yZCAqKXJlYy0+ZGF0YSktPnVwZGF0ZV9pbmRleCArPQoJCQl0aS0+ci0+bWluX3VwZGF0ZV9pbmRleDsKCX0KCglyZXR1cm4gcmVzOwp9CgpzdGF0aWMgdm9pZCB0YWJsZV9pdGVyX2Jsb2NrX2RvbmUoc3RydWN0IHRhYmxlX2l0ZXIgKnRpKQp7CglpZiAoIXRpLT5iaS5icikgewoJCXJldHVybjsKCX0KCXJlZnRhYmxlX2Jsb2NrX2RvbmUoJnRpLT5iaS5ici0+YmxvY2spOwoJRlJFRV9BTkRfTlVMTCh0aS0+YmkuYnIpOwoKCXRpLT5iaS5sYXN0X2tleS5sZW4gPSAwOwoJdGktPmJpLm5leHRfb2ZmID0gMDsKfQoKc3RhdGljIGludDMyX3QgZXh0cmFjdF9ibG9ja19zaXplKHVpbnQ4X3QgKmRhdGEsIHVpbnQ4X3QgKnR5cCwgdWludDY0X3Qgb2ZmLAoJCQkJICBpbnQgdmVyc2lvbikKewoJaW50MzJfdCByZXN1bHQgPSAwOwoKCWlmIChvZmYgPT0gMCkgewoJCWRhdGEgKz0gaGVhZGVyX3NpemUodmVyc2lvbik7Cgl9CgoJKnR5cCA9IGRhdGFbMF07CglpZiAocmVmdGFibGVfaXNfYmxvY2tfdHlwZSgqdHlwKSkgewoJCXJlc3VsdCA9IGdldF9iZTI0KGRhdGEgKyAxKTsKCX0KCXJldHVybiByZXN1bHQ7Cn0KCmludCByZWFkZXJfaW5pdF9ibG9ja19yZWFkZXIoc3RydWN0IHJlZnRhYmxlX3JlYWRlciAqciwgc3RydWN0IGJsb2NrX3JlYWRlciAqYnIsCgkJCSAgICAgdWludDY0X3QgbmV4dF9vZmYsIHVpbnQ4X3Qgd2FudF90eXApCnsKCWludDMyX3QgZ3Vlc3NfYmxvY2tfc2l6ZSA9IHItPmJsb2NrX3NpemUgPyByLT5ibG9ja19zaXplIDoKCQkJCQkJCSBERUZBVUxUX0JMT0NLX1NJWkU7CglzdHJ1Y3QgcmVmdGFibGVfYmxvY2sgYmxvY2sgPSB7IE5VTEwgfTsKCXVpbnQ4X3QgYmxvY2tfdHlwID0gMDsKCWludCBlcnIgPSAwOwoJdWludDMyX3QgaGVhZGVyX29mZiA9IG5leHRfb2ZmID8gMCA6IGhlYWRlcl9zaXplKHItPnZlcnNpb24pOwoJaW50MzJfdCBibG9ja19zaXplID0gMDsKCglpZiAobmV4dF9vZmYgPj0gci0+c2l6ZSkKCQlyZXR1cm4gMTsKCgllcnIgPSByZWFkZXJfZ2V0X2Jsb2NrKHIsICZibG9jaywgbmV4dF9vZmYsIGd1ZXNzX2Jsb2NrX3NpemUpOwoJaWYgKGVyciA8IDApCgkJcmV0dXJuIGVycjsKCglibG9ja19zaXplID0gZXh0cmFjdF9ibG9ja19zaXplKGJsb2NrLmRhdGEsICZibG9ja190eXAsIG5leHRfb2ZmLAoJCQkJCXItPnZlcnNpb24pOwoJaWYgKGJsb2NrX3NpemUgPCAwKQoJCXJldHVybiBibG9ja19zaXplOwoKCWlmICh3YW50X3R5cCAhPSBCTE9DS19UWVBFX0FOWSAmJiBibG9ja190eXAgIT0gd2FudF90eXApIHsKCQlyZWZ0YWJsZV9ibG9ja19kb25lKCZibG9jayk7CgkJcmV0dXJuIDE7Cgl9CgoJaWYgKGJsb2NrX3NpemUgPiBndWVzc19ibG9ja19zaXplKSB7CgkJcmVmdGFibGVfYmxvY2tfZG9uZSgmYmxvY2spOwoJCWVyciA9IHJlYWRlcl9nZXRfYmxvY2sociwgJmJsb2NrLCBuZXh0X29mZiwgYmxvY2tfc2l6ZSk7CgkJaWYgKGVyciA8IDApIHsKCQkJcmV0dXJuIGVycjsKCQl9Cgl9CgoJcmV0dXJuIGJsb2NrX3JlYWRlcl9pbml0KGJyLCAmYmxvY2ssIGhlYWRlcl9vZmYsIHItPmJsb2NrX3NpemUsCgkJCQkgaGFzaF9zaXplKHItPmhhc2hfaWQpKTsKfQoKc3RhdGljIGludCB0YWJsZV9pdGVyX25leHRfYmxvY2soc3RydWN0IHRhYmxlX2l0ZXIgKmRlc3QsCgkJCQkgc3RydWN0IHRhYmxlX2l0ZXIgKnNyYykKewoJdWludDY0X3QgbmV4dF9ibG9ja19vZmYgPSBzcmMtPmJsb2NrX29mZiArIHNyYy0+YmkuYnItPmZ1bGxfYmxvY2tfc2l6ZTsKCXN0cnVjdCBibG9ja19yZWFkZXIgYnIgPSB7IDAgfTsKCWludCBlcnIgPSAwOwoKCWRlc3QtPnIgPSBzcmMtPnI7CglkZXN0LT50eXAgPSBzcmMtPnR5cDsKCWRlc3QtPmJsb2NrX29mZiA9IG5leHRfYmxvY2tfb2ZmOwoKCWVyciA9IHJlYWRlcl9pbml0X2Jsb2NrX3JlYWRlcihzcmMtPnIsICZiciwgbmV4dF9ibG9ja19vZmYsIHNyYy0+dHlwKTsKCWlmIChlcnIgPiAwKSB7CgkJZGVzdC0+aXNfZmluaXNoZWQgPSAxOwoJCXJldHVybiAxOwoJfQoJaWYgKGVyciAhPSAwKQoJCXJldHVybiBlcnI7CgllbHNlIHsKCQlzdHJ1Y3QgYmxvY2tfcmVhZGVyICpicnAgPQoJCQlyZWZ0YWJsZV9tYWxsb2Moc2l6ZW9mKHN0cnVjdCBibG9ja19yZWFkZXIpKTsKCQkqYnJwID0gYnI7CgoJCWRlc3QtPmlzX2ZpbmlzaGVkID0gMDsKCQlibG9ja19yZWFkZXJfc3RhcnQoYnJwLCAmZGVzdC0+YmkpOwoJfQoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgdGFibGVfaXRlcl9uZXh0KHN0cnVjdCB0YWJsZV9pdGVyICp0aSwgc3RydWN0IHJlZnRhYmxlX3JlY29yZCAqcmVjKQp7CglpZiAocmVmdGFibGVfcmVjb3JkX3R5cGUocmVjKSAhPSB0aS0+dHlwKQoJCXJldHVybiBSRUZUQUJMRV9BUElfRVJST1I7CgoJd2hpbGUgKDEpIHsKCQlzdHJ1Y3QgdGFibGVfaXRlciBuZXh0ID0gVEFCTEVfSVRFUl9JTklUOwoJCWludCBlcnIgPSAwOwoJCWlmICh0aS0+aXNfZmluaXNoZWQpIHsKCQkJcmV0dXJuIDE7CgkJfQoKCQllcnIgPSB0YWJsZV9pdGVyX25leHRfaW5fYmxvY2sodGksIHJlYyk7CgkJaWYgKGVyciA8PSAwKSB7CgkJCXJldHVybiBlcnI7CgkJfQoKCQllcnIgPSB0YWJsZV9pdGVyX25leHRfYmxvY2soJm5leHQsIHRpKTsKCQlpZiAoZXJyICE9IDApIHsKCQkJdGktPmlzX2ZpbmlzaGVkID0gMTsKCQl9CgkJdGFibGVfaXRlcl9ibG9ja19kb25lKHRpKTsKCQlpZiAoZXJyICE9IDApIHsKCQkJcmV0dXJuIGVycjsKCQl9CgkJdGFibGVfaXRlcl9jb3B5X2Zyb20odGksICZuZXh0KTsKCQlibG9ja19pdGVyX2Nsb3NlKCZuZXh0LmJpKTsKCX0KfQoKc3RhdGljIGludCB0YWJsZV9pdGVyX25leHRfdm9pZCh2b2lkICp0aSwgc3RydWN0IHJlZnRhYmxlX3JlY29yZCAqcmVjKQp7CglyZXR1cm4gdGFibGVfaXRlcl9uZXh0KHRpLCByZWMpOwp9CgpzdGF0aWMgdm9pZCB0YWJsZV9pdGVyX2Nsb3NlKHZvaWQgKnApCnsKCXN0cnVjdCB0YWJsZV9pdGVyICp0aSA9IHA7Cgl0YWJsZV9pdGVyX2Jsb2NrX2RvbmUodGkpOwoJYmxvY2tfaXRlcl9jbG9zZSgmdGktPmJpKTsKfQoKc3RhdGljIHN0cnVjdCByZWZ0YWJsZV9pdGVyYXRvcl92dGFibGUgdGFibGVfaXRlcl92dGFibGUgPSB7CgkubmV4dCA9ICZ0YWJsZV9pdGVyX25leHRfdm9pZCwKCS5jbG9zZSA9ICZ0YWJsZV9pdGVyX2Nsb3NlLAp9OwoKc3RhdGljIHZvaWQgaXRlcmF0b3JfZnJvbV90YWJsZV9pdGVyKHN0cnVjdCByZWZ0YWJsZV9pdGVyYXRvciAqaXQsCgkJCQkgICAgIHN0cnVjdCB0YWJsZV9pdGVyICp0aSkKewoJYXNzZXJ0KCFpdC0+b3BzKTsKCWl0LT5pdGVyX2FyZyA9IHRpOwoJaXQtPm9wcyA9ICZ0YWJsZV9pdGVyX3Z0YWJsZTsKfQoKc3RhdGljIGludCByZWFkZXJfdGFibGVfaXRlcl9hdChzdHJ1Y3QgcmVmdGFibGVfcmVhZGVyICpyLAoJCQkJc3RydWN0IHRhYmxlX2l0ZXIgKnRpLCB1aW50NjRfdCBvZmYsCgkJCQl1aW50OF90IHR5cCkKewoJc3RydWN0IGJsb2NrX3JlYWRlciBiciA9IHsgMCB9OwoJc3RydWN0IGJsb2NrX3JlYWRlciAqYnJwID0gTlVMTDsKCglpbnQgZXJyID0gcmVhZGVyX2luaXRfYmxvY2tfcmVhZGVyKHIsICZiciwgb2ZmLCB0eXApOwoJaWYgKGVyciAhPSAwKQoJCXJldHVybiBlcnI7CgoJYnJwID0gcmVmdGFibGVfbWFsbG9jKHNpemVvZihzdHJ1Y3QgYmxvY2tfcmVhZGVyKSk7CgkqYnJwID0gYnI7Cgl0aS0+ciA9IHI7Cgl0aS0+dHlwID0gYmxvY2tfcmVhZGVyX3R5cGUoYnJwKTsKCXRpLT5ibG9ja19vZmYgPSBvZmY7CglibG9ja19yZWFkZXJfc3RhcnQoYnJwLCAmdGktPmJpKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IHJlYWRlcl9zdGFydChzdHJ1Y3QgcmVmdGFibGVfcmVhZGVyICpyLCBzdHJ1Y3QgdGFibGVfaXRlciAqdGksCgkJCXVpbnQ4X3QgdHlwLCBpbnQgaW5kZXgpCnsKCXN0cnVjdCByZWZ0YWJsZV9yZWFkZXJfb2Zmc2V0cyAqb2ZmcyA9IHJlYWRlcl9vZmZzZXRzX2ZvcihyLCB0eXApOwoJdWludDY0X3Qgb2ZmID0gb2Zmcy0+b2Zmc2V0OwoJaWYgKGluZGV4KSB7CgkJb2ZmID0gb2Zmcy0+aW5kZXhfb2Zmc2V0OwoJCWlmIChvZmYgPT0gMCkgewoJCQlyZXR1cm4gMTsKCQl9CgkJdHlwID0gQkxPQ0tfVFlQRV9JTkRFWDsKCX0KCglyZXR1cm4gcmVhZGVyX3RhYmxlX2l0ZXJfYXQociwgdGksIG9mZiwgdHlwKTsKfQoKc3RhdGljIGludCByZWFkZXJfc2Vla19saW5lYXIoc3RydWN0IHJlZnRhYmxlX3JlYWRlciAqciwgc3RydWN0IHRhYmxlX2l0ZXIgKnRpLAoJCQkgICAgICBzdHJ1Y3QgcmVmdGFibGVfcmVjb3JkICp3YW50KQp7CglzdHJ1Y3QgcmVmdGFibGVfcmVjb3JkIHJlYyA9CgkJcmVmdGFibGVfbmV3X3JlY29yZChyZWZ0YWJsZV9yZWNvcmRfdHlwZSh3YW50KSk7CglzdHJ1Y3Qgc3RyYnVmIHdhbnRfa2V5ID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3Qgc3RyYnVmIGdvdF9rZXkgPSBTVFJCVUZfSU5JVDsKCXN0cnVjdCB0YWJsZV9pdGVyIG5leHQgPSBUQUJMRV9JVEVSX0lOSVQ7CglpbnQgZXJyID0gLTE7CgoJcmVmdGFibGVfcmVjb3JkX2tleSh3YW50LCAmd2FudF9rZXkpOwoKCXdoaWxlICgxKSB7CgkJZXJyID0gdGFibGVfaXRlcl9uZXh0X2Jsb2NrKCZuZXh0LCB0aSk7CgkJaWYgKGVyciA8IDApCgkJCWdvdG8gZG9uZTsKCgkJaWYgKGVyciA+IDApIHsKCQkJYnJlYWs7CgkJfQoKCQllcnIgPSBibG9ja19yZWFkZXJfZmlyc3Rfa2V5KG5leHQuYmkuYnIsICZnb3Rfa2V5KTsKCQlpZiAoZXJyIDwgMCkKCQkJZ290byBkb25lOwoKCQlpZiAoc3RyYnVmX2NtcCgmZ290X2tleSwgJndhbnRfa2V5KSA+IDApIHsKCQkJdGFibGVfaXRlcl9ibG9ja19kb25lKCZuZXh0KTsKCQkJYnJlYWs7CgkJfQoKCQl0YWJsZV9pdGVyX2Jsb2NrX2RvbmUodGkpOwoJCXRhYmxlX2l0ZXJfY29weV9mcm9tKHRpLCAmbmV4dCk7Cgl9CgoJZXJyID0gYmxvY2tfaXRlcl9zZWVrKCZ0aS0+YmksICZ3YW50X2tleSk7CglpZiAoZXJyIDwgMCkKCQlnb3RvIGRvbmU7CgllcnIgPSAwOwoKZG9uZToKCWJsb2NrX2l0ZXJfY2xvc2UoJm5leHQuYmkpOwoJcmVmdGFibGVfcmVjb3JkX2Rlc3Ryb3koJnJlYyk7CglzdHJidWZfcmVsZWFzZSgmd2FudF9rZXkpOwoJc3RyYnVmX3JlbGVhc2UoJmdvdF9rZXkpOwoJcmV0dXJuIGVycjsKfQoKc3RhdGljIGludCByZWFkZXJfc2Vla19pbmRleGVkKHN0cnVjdCByZWZ0YWJsZV9yZWFkZXIgKnIsCgkJCSAgICAgICBzdHJ1Y3QgcmVmdGFibGVfaXRlcmF0b3IgKml0LAoJCQkgICAgICAgc3RydWN0IHJlZnRhYmxlX3JlY29yZCAqcmVjKQp7CglzdHJ1Y3QgcmVmdGFibGVfaW5kZXhfcmVjb3JkIHdhbnRfaW5kZXggPSB7IC5sYXN0X2tleSA9IFNUUkJVRl9JTklUIH07CglzdHJ1Y3QgcmVmdGFibGVfcmVjb3JkIHdhbnRfaW5kZXhfcmVjID0geyBOVUxMIH07CglzdHJ1Y3QgcmVmdGFibGVfaW5kZXhfcmVjb3JkIGluZGV4X3Jlc3VsdCA9IHsgLmxhc3Rfa2V5ID0gU1RSQlVGX0lOSVQgfTsKCXN0cnVjdCByZWZ0YWJsZV9yZWNvcmQgaW5kZXhfcmVzdWx0X3JlYyA9IHsgTlVMTCB9OwoJc3RydWN0IHRhYmxlX2l0ZXIgaW5kZXhfaXRlciA9IFRBQkxFX0lURVJfSU5JVDsKCXN0cnVjdCB0YWJsZV9pdGVyIG5leHQgPSBUQUJMRV9JVEVSX0lOSVQ7CglpbnQgZXJyID0gMDsKCglyZWZ0YWJsZV9yZWNvcmRfa2V5KHJlYywgJndhbnRfaW5kZXgubGFzdF9rZXkpOwoJcmVmdGFibGVfcmVjb3JkX2Zyb21faW5kZXgoJndhbnRfaW5kZXhfcmVjLCAmd2FudF9pbmRleCk7CglyZWZ0YWJsZV9yZWNvcmRfZnJvbV9pbmRleCgmaW5kZXhfcmVzdWx0X3JlYywgJmluZGV4X3Jlc3VsdCk7CgoJZXJyID0gcmVhZGVyX3N0YXJ0KHIsICZpbmRleF9pdGVyLCByZWZ0YWJsZV9yZWNvcmRfdHlwZShyZWMpLCAxKTsKCWlmIChlcnIgPCAwKQoJCWdvdG8gZG9uZTsKCgllcnIgPSByZWFkZXJfc2Vla19saW5lYXIociwgJmluZGV4X2l0ZXIsICZ3YW50X2luZGV4X3JlYyk7Cgl3aGlsZSAoMSkgewoJCWVyciA9IHRhYmxlX2l0ZXJfbmV4dCgmaW5kZXhfaXRlciwgJmluZGV4X3Jlc3VsdF9yZWMpOwoJCXRhYmxlX2l0ZXJfYmxvY2tfZG9uZSgmaW5kZXhfaXRlcik7CgkJaWYgKGVyciAhPSAwKQoJCQlnb3RvIGRvbmU7CgoJCWVyciA9IHJlYWRlcl90YWJsZV9pdGVyX2F0KHIsICZuZXh0LCBpbmRleF9yZXN1bHQub2Zmc2V0LCAwKTsKCQlpZiAoZXJyICE9IDApCgkJCWdvdG8gZG9uZTsKCgkJZXJyID0gYmxvY2tfaXRlcl9zZWVrKCZuZXh0LmJpLCAmd2FudF9pbmRleC5sYXN0X2tleSk7CgkJaWYgKGVyciA8IDApCgkJCWdvdG8gZG9uZTsKCgkJaWYgKG5leHQudHlwID09IHJlZnRhYmxlX3JlY29yZF90eXBlKHJlYykpIHsKCQkJZXJyID0gMDsKCQkJYnJlYWs7CgkJfQoKCQlpZiAobmV4dC50eXAgIT0gQkxPQ0tfVFlQRV9JTkRFWCkgewoJCQllcnIgPSBSRUZUQUJMRV9GT1JNQVRfRVJST1I7CgkJCWJyZWFrOwoJCX0KCgkJdGFibGVfaXRlcl9jb3B5X2Zyb20oJmluZGV4X2l0ZXIsICZuZXh0KTsKCX0KCglpZiAoZXJyID09IDApIHsKCQlzdHJ1Y3QgdGFibGVfaXRlciBlbXB0eSA9IFRBQkxFX0lURVJfSU5JVDsKCQlzdHJ1Y3QgdGFibGVfaXRlciAqbWFsbG9jZWQgPQoJCQlyZWZ0YWJsZV9jYWxsb2Moc2l6ZW9mKHN0cnVjdCB0YWJsZV9pdGVyKSk7CgkJKm1hbGxvY2VkID0gZW1wdHk7CgkJdGFibGVfaXRlcl9jb3B5X2Zyb20obWFsbG9jZWQsICZuZXh0KTsKCQlpdGVyYXRvcl9mcm9tX3RhYmxlX2l0ZXIoaXQsIG1hbGxvY2VkKTsKCX0KZG9uZToKCWJsb2NrX2l0ZXJfY2xvc2UoJm5leHQuYmkpOwoJdGFibGVfaXRlcl9jbG9zZSgmaW5kZXhfaXRlcik7CglyZWZ0YWJsZV9yZWNvcmRfcmVsZWFzZSgmd2FudF9pbmRleF9yZWMpOwoJcmVmdGFibGVfcmVjb3JkX3JlbGVhc2UoJmluZGV4X3Jlc3VsdF9yZWMpOwoJcmV0dXJuIGVycjsKfQoKc3RhdGljIGludCByZWFkZXJfc2Vla19pbnRlcm5hbChzdHJ1Y3QgcmVmdGFibGVfcmVhZGVyICpyLAoJCQkJc3RydWN0IHJlZnRhYmxlX2l0ZXJhdG9yICppdCwKCQkJCXN0cnVjdCByZWZ0YWJsZV9yZWNvcmQgKnJlYykKewoJc3RydWN0IHJlZnRhYmxlX3JlYWRlcl9vZmZzZXRzICpvZmZzID0KCQlyZWFkZXJfb2Zmc2V0c19mb3IociwgcmVmdGFibGVfcmVjb3JkX3R5cGUocmVjKSk7Cgl1aW50NjRfdCBpZHggPSBvZmZzLT5pbmRleF9vZmZzZXQ7CglzdHJ1Y3QgdGFibGVfaXRlciB0aSA9IFRBQkxFX0lURVJfSU5JVDsKCWludCBlcnIgPSAwOwoJaWYgKGlkeCA+IDApCgkJcmV0dXJuIHJlYWRlcl9zZWVrX2luZGV4ZWQociwgaXQsIHJlYyk7CgoJZXJyID0gcmVhZGVyX3N0YXJ0KHIsICZ0aSwgcmVmdGFibGVfcmVjb3JkX3R5cGUocmVjKSwgMCk7CglpZiAoZXJyIDwgMCkKCQlyZXR1cm4gZXJyOwoJZXJyID0gcmVhZGVyX3NlZWtfbGluZWFyKHIsICZ0aSwgcmVjKTsKCWlmIChlcnIgPCAwKQoJCXJldHVybiBlcnI7CgllbHNlIHsKCQlzdHJ1Y3QgdGFibGVfaXRlciAqcCA9CgkJCXJlZnRhYmxlX21hbGxvYyhzaXplb2Yoc3RydWN0IHRhYmxlX2l0ZXIpKTsKCQkqcCA9IHRpOwoJCWl0ZXJhdG9yX2Zyb21fdGFibGVfaXRlcihpdCwgcCk7Cgl9CgoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgcmVhZGVyX3NlZWsoc3RydWN0IHJlZnRhYmxlX3JlYWRlciAqciwgc3RydWN0IHJlZnRhYmxlX2l0ZXJhdG9yICppdCwKCQkgICAgICAgc3RydWN0IHJlZnRhYmxlX3JlY29yZCAqcmVjKQp7Cgl1aW50OF90IHR5cCA9IHJlZnRhYmxlX3JlY29yZF90eXBlKHJlYyk7CgoJc3RydWN0IHJlZnRhYmxlX3JlYWRlcl9vZmZzZXRzICpvZmZzID0gcmVhZGVyX29mZnNldHNfZm9yKHIsIHR5cCk7CglpZiAoIW9mZnMtPmlzX3ByZXNlbnQpIHsKCQlpdGVyYXRvcl9zZXRfZW1wdHkoaXQpOwoJCXJldHVybiAwOwoJfQoKCXJldHVybiByZWFkZXJfc2Vla19pbnRlcm5hbChyLCBpdCwgcmVjKTsKfQoKaW50IHJlZnRhYmxlX3JlYWRlcl9zZWVrX3JlZihzdHJ1Y3QgcmVmdGFibGVfcmVhZGVyICpyLAoJCQkgICAgIHN0cnVjdCByZWZ0YWJsZV9pdGVyYXRvciAqaXQsIGNvbnN0IGNoYXIgKm5hbWUpCnsKCXN0cnVjdCByZWZ0YWJsZV9yZWZfcmVjb3JkIHJlZiA9IHsKCQkucmVmbmFtZSA9IChjaGFyICopbmFtZSwKCX07CglzdHJ1Y3QgcmVmdGFibGVfcmVjb3JkIHJlYyA9IHsgTlVMTCB9OwoJcmVmdGFibGVfcmVjb3JkX2Zyb21fcmVmKCZyZWMsICZyZWYpOwoJcmV0dXJuIHJlYWRlcl9zZWVrKHIsIGl0LCAmcmVjKTsKfQoKaW50IHJlZnRhYmxlX3JlYWRlcl9zZWVrX2xvZ19hdChzdHJ1Y3QgcmVmdGFibGVfcmVhZGVyICpyLAoJCQkJc3RydWN0IHJlZnRhYmxlX2l0ZXJhdG9yICppdCwgY29uc3QgY2hhciAqbmFtZSwKCQkJCXVpbnQ2NF90IHVwZGF0ZV9pbmRleCkKewoJc3RydWN0IHJlZnRhYmxlX2xvZ19yZWNvcmQgbG9nID0gewoJCS5yZWZuYW1lID0gKGNoYXIgKiluYW1lLAoJCS51cGRhdGVfaW5kZXggPSB1cGRhdGVfaW5kZXgsCgl9OwoJc3RydWN0IHJlZnRhYmxlX3JlY29yZCByZWMgPSB7IE5VTEwgfTsKCXJlZnRhYmxlX3JlY29yZF9mcm9tX2xvZygmcmVjLCAmbG9nKTsKCXJldHVybiByZWFkZXJfc2VlayhyLCBpdCwgJnJlYyk7Cn0KCmludCByZWZ0YWJsZV9yZWFkZXJfc2Vla19sb2coc3RydWN0IHJlZnRhYmxlX3JlYWRlciAqciwKCQkJICAgICBzdHJ1Y3QgcmVmdGFibGVfaXRlcmF0b3IgKml0LCBjb25zdCBjaGFyICpuYW1lKQp7Cgl1aW50NjRfdCBtYXggPSB+KCh1aW50NjRfdCkwKTsKCXJldHVybiByZWZ0YWJsZV9yZWFkZXJfc2Vla19sb2dfYXQociwgaXQsIG5hbWUsIG1heCk7Cn0KCnZvaWQgcmVhZGVyX2Nsb3NlKHN0cnVjdCByZWZ0YWJsZV9yZWFkZXIgKnIpCnsKCWJsb2NrX3NvdXJjZV9jbG9zZSgmci0+c291cmNlKTsKCUZSRUVfQU5EX05VTEwoci0+bmFtZSk7Cn0KCmludCByZWZ0YWJsZV9uZXdfcmVhZGVyKHN0cnVjdCByZWZ0YWJsZV9yZWFkZXIgKipwLAoJCQlzdHJ1Y3QgcmVmdGFibGVfYmxvY2tfc291cmNlICpzcmMsIGNoYXIgY29uc3QgKm5hbWUpCnsKCXN0cnVjdCByZWZ0YWJsZV9yZWFkZXIgKnJkID0KCQlyZWZ0YWJsZV9jYWxsb2Moc2l6ZW9mKHN0cnVjdCByZWZ0YWJsZV9yZWFkZXIpKTsKCWludCBlcnIgPSBpbml0X3JlYWRlcihyZCwgc3JjLCBuYW1lKTsKCWlmIChlcnIgPT0gMCkgewoJCSpwID0gcmQ7Cgl9IGVsc2UgewoJCWJsb2NrX3NvdXJjZV9jbG9zZShzcmMpOwoJCXJlZnRhYmxlX2ZyZWUocmQpOwoJfQoJcmV0dXJuIGVycjsKfQoKdm9pZCByZWZ0YWJsZV9yZWFkZXJfZnJlZShzdHJ1Y3QgcmVmdGFibGVfcmVhZGVyICpyKQp7CglyZWFkZXJfY2xvc2Uocik7CglyZWZ0YWJsZV9mcmVlKHIpOwp9CgpzdGF0aWMgaW50IHJlZnRhYmxlX3JlYWRlcl9yZWZzX2Zvcl9pbmRleGVkKHN0cnVjdCByZWZ0YWJsZV9yZWFkZXIgKnIsCgkJCQkJICAgIHN0cnVjdCByZWZ0YWJsZV9pdGVyYXRvciAqaXQsCgkJCQkJICAgIHVpbnQ4X3QgKm9pZCkKewoJc3RydWN0IHJlZnRhYmxlX29ial9yZWNvcmQgd2FudCA9IHsKCQkuaGFzaF9wcmVmaXggPSBvaWQsCgkJLmhhc2hfcHJlZml4X2xlbiA9IHItPm9iamVjdF9pZF9sZW4sCgl9OwoJc3RydWN0IHJlZnRhYmxlX3JlY29yZCB3YW50X3JlYyA9IHsgTlVMTCB9OwoJc3RydWN0IHJlZnRhYmxlX2l0ZXJhdG9yIG9pdCA9IHsgTlVMTCB9OwoJc3RydWN0IHJlZnRhYmxlX29ial9yZWNvcmQgZ290ID0geyBOVUxMIH07CglzdHJ1Y3QgcmVmdGFibGVfcmVjb3JkIGdvdF9yZWMgPSB7IE5VTEwgfTsKCWludCBlcnIgPSAwOwoJc3RydWN0IGluZGV4ZWRfdGFibGVfcmVmX2l0ZXIgKml0ciA9IE5VTEw7CgoJLyogTG9vayB0aHJvdWdoIHRoZSByZXZlcnNlIGluZGV4LiAqLwoJcmVmdGFibGVfcmVjb3JkX2Zyb21fb2JqKCZ3YW50X3JlYywgJndhbnQpOwoJZXJyID0gcmVhZGVyX3NlZWsociwgJm9pdCwgJndhbnRfcmVjKTsKCWlmIChlcnIgIT0gMCkKCQlnb3RvIGRvbmU7CgoJLyogcmVhZCBvdXQgdGhlIHJlZnRhYmxlX29ial9yZWNvcmQgKi8KCXJlZnRhYmxlX3JlY29yZF9mcm9tX29iaigmZ290X3JlYywgJmdvdCk7CgllcnIgPSBpdGVyYXRvcl9uZXh0KCZvaXQsICZnb3RfcmVjKTsKCWlmIChlcnIgPCAwKQoJCWdvdG8gZG9uZTsKCglpZiAoZXJyID4gMCB8fAoJICAgIG1lbWNtcCh3YW50Lmhhc2hfcHJlZml4LCBnb3QuaGFzaF9wcmVmaXgsIHItPm9iamVjdF9pZF9sZW4pKSB7CgkJLyogZGlkbid0IGZpbmQgaXQ7IHJldHVybiBlbXB0eSBpdGVyYXRvciAqLwoJCWl0ZXJhdG9yX3NldF9lbXB0eShpdCk7CgkJZXJyID0gMDsKCQlnb3RvIGRvbmU7Cgl9CgoJZXJyID0gbmV3X2luZGV4ZWRfdGFibGVfcmVmX2l0ZXIoJml0ciwgciwgb2lkLCBoYXNoX3NpemUoci0+aGFzaF9pZCksCgkJCQkJIGdvdC5vZmZzZXRzLCBnb3Qub2Zmc2V0X2xlbik7CglpZiAoZXJyIDwgMCkKCQlnb3RvIGRvbmU7Cglnb3Qub2Zmc2V0cyA9IE5VTEw7CglpdGVyYXRvcl9mcm9tX2luZGV4ZWRfdGFibGVfcmVmX2l0ZXIoaXQsIGl0cik7Cgpkb25lOgoJcmVmdGFibGVfaXRlcmF0b3JfZGVzdHJveSgmb2l0KTsKCXJlZnRhYmxlX3JlY29yZF9yZWxlYXNlKCZnb3RfcmVjKTsKCXJldHVybiBlcnI7Cn0KCnN0YXRpYyBpbnQgcmVmdGFibGVfcmVhZGVyX3JlZnNfZm9yX3VuaW5kZXhlZChzdHJ1Y3QgcmVmdGFibGVfcmVhZGVyICpyLAoJCQkJCSAgICAgIHN0cnVjdCByZWZ0YWJsZV9pdGVyYXRvciAqaXQsCgkJCQkJICAgICAgdWludDhfdCAqb2lkKQp7CglzdHJ1Y3QgdGFibGVfaXRlciB0aV9lbXB0eSA9IFRBQkxFX0lURVJfSU5JVDsKCXN0cnVjdCB0YWJsZV9pdGVyICp0aSA9IHJlZnRhYmxlX2NhbGxvYyhzaXplb2Yoc3RydWN0IHRhYmxlX2l0ZXIpKTsKCXN0cnVjdCBmaWx0ZXJpbmdfcmVmX2l0ZXJhdG9yICpmaWx0ZXIgPSBOVUxMOwoJc3RydWN0IGZpbHRlcmluZ19yZWZfaXRlcmF0b3IgZW1wdHkgPSBGSUxURVJJTkdfUkVGX0lURVJBVE9SX0lOSVQ7CglpbnQgb2lkX2xlbiA9IGhhc2hfc2l6ZShyLT5oYXNoX2lkKTsKCWludCBlcnI7CgoJKnRpID0gdGlfZW1wdHk7CgllcnIgPSByZWFkZXJfc3RhcnQociwgdGksIEJMT0NLX1RZUEVfUkVGLCAwKTsKCWlmIChlcnIgPCAwKSB7CgkJcmVmdGFibGVfZnJlZSh0aSk7CgkJcmV0dXJuIGVycjsKCX0KCglmaWx0ZXIgPSByZWZ0YWJsZV9tYWxsb2Moc2l6ZW9mKHN0cnVjdCBmaWx0ZXJpbmdfcmVmX2l0ZXJhdG9yKSk7CgkqZmlsdGVyID0gZW1wdHk7CgoJc3RyYnVmX2FkZCgmZmlsdGVyLT5vaWQsIG9pZCwgb2lkX2xlbik7CglyZWZ0YWJsZV90YWJsZV9mcm9tX3JlYWRlcigmZmlsdGVyLT50YWIsIHIpOwoJZmlsdGVyLT5kb3VibGVfY2hlY2sgPSAwOwoJaXRlcmF0b3JfZnJvbV90YWJsZV9pdGVyKCZmaWx0ZXItPml0LCB0aSk7CgoJaXRlcmF0b3JfZnJvbV9maWx0ZXJpbmdfcmVmX2l0ZXJhdG9yKGl0LCBmaWx0ZXIpOwoJcmV0dXJuIDA7Cn0KCmludCByZWZ0YWJsZV9yZWFkZXJfcmVmc19mb3Ioc3RydWN0IHJlZnRhYmxlX3JlYWRlciAqciwKCQkJICAgICBzdHJ1Y3QgcmVmdGFibGVfaXRlcmF0b3IgKml0LCB1aW50OF90ICpvaWQpCnsKCWlmIChyLT5vYmpfb2Zmc2V0cy5pc19wcmVzZW50KQoJCXJldHVybiByZWZ0YWJsZV9yZWFkZXJfcmVmc19mb3JfaW5kZXhlZChyLCBpdCwgb2lkKTsKCXJldHVybiByZWZ0YWJsZV9yZWFkZXJfcmVmc19mb3JfdW5pbmRleGVkKHIsIGl0LCBvaWQpOwp9Cgp1aW50NjRfdCByZWZ0YWJsZV9yZWFkZXJfbWF4X3VwZGF0ZV9pbmRleChzdHJ1Y3QgcmVmdGFibGVfcmVhZGVyICpyKQp7CglyZXR1cm4gci0+bWF4X3VwZGF0ZV9pbmRleDsKfQoKdWludDY0X3QgcmVmdGFibGVfcmVhZGVyX21pbl91cGRhdGVfaW5kZXgoc3RydWN0IHJlZnRhYmxlX3JlYWRlciAqcikKewoJcmV0dXJuIHItPm1pbl91cGRhdGVfaW5kZXg7Cn0KCi8qIGdlbmVyaWMgdGFibGUgaW50ZXJmYWNlLiAqLwoKc3RhdGljIGludCByZWZ0YWJsZV9yZWFkZXJfc2Vla192b2lkKHZvaWQgKnRhYiwgc3RydWN0IHJlZnRhYmxlX2l0ZXJhdG9yICppdCwKCQkJCSAgICAgc3RydWN0IHJlZnRhYmxlX3JlY29yZCAqcmVjKQp7CglyZXR1cm4gcmVhZGVyX3NlZWsodGFiLCBpdCwgcmVjKTsKfQoKc3RhdGljIHVpbnQzMl90IHJlZnRhYmxlX3JlYWRlcl9oYXNoX2lkX3ZvaWQodm9pZCAqdGFiKQp7CglyZXR1cm4gcmVmdGFibGVfcmVhZGVyX2hhc2hfaWQodGFiKTsKfQoKc3RhdGljIHVpbnQ2NF90IHJlZnRhYmxlX3JlYWRlcl9taW5fdXBkYXRlX2luZGV4X3ZvaWQodm9pZCAqdGFiKQp7CglyZXR1cm4gcmVmdGFibGVfcmVhZGVyX21pbl91cGRhdGVfaW5kZXgodGFiKTsKfQoKc3RhdGljIHVpbnQ2NF90IHJlZnRhYmxlX3JlYWRlcl9tYXhfdXBkYXRlX2luZGV4X3ZvaWQodm9pZCAqdGFiKQp7CglyZXR1cm4gcmVmdGFibGVfcmVhZGVyX21heF91cGRhdGVfaW5kZXgodGFiKTsKfQoKc3RhdGljIHN0cnVjdCByZWZ0YWJsZV90YWJsZV92dGFibGUgcmVhZGVyX3Z0YWJsZSA9IHsKCS5zZWVrX3JlY29yZCA9IHJlZnRhYmxlX3JlYWRlcl9zZWVrX3ZvaWQsCgkuaGFzaF9pZCA9IHJlZnRhYmxlX3JlYWRlcl9oYXNoX2lkX3ZvaWQsCgkubWluX3VwZGF0ZV9pbmRleCA9IHJlZnRhYmxlX3JlYWRlcl9taW5fdXBkYXRlX2luZGV4X3ZvaWQsCgkubWF4X3VwZGF0ZV9pbmRleCA9IHJlZnRhYmxlX3JlYWRlcl9tYXhfdXBkYXRlX2luZGV4X3ZvaWQsCn07Cgp2b2lkIHJlZnRhYmxlX3RhYmxlX2Zyb21fcmVhZGVyKHN0cnVjdCByZWZ0YWJsZV90YWJsZSAqdGFiLAoJCQkJc3RydWN0IHJlZnRhYmxlX3JlYWRlciAqcmVhZGVyKQp7Cglhc3NlcnQoIXRhYi0+b3BzKTsKCXRhYi0+b3BzID0gJnJlYWRlcl92dGFibGU7Cgl0YWItPnRhYmxlX2FyZyA9IHJlYWRlcjsKfQoKCmludCByZWZ0YWJsZV9yZWFkZXJfcHJpbnRfZmlsZShjb25zdCBjaGFyICp0YWJsZW5hbWUpCnsKCXN0cnVjdCByZWZ0YWJsZV9ibG9ja19zb3VyY2Ugc3JjID0geyBOVUxMIH07CglpbnQgZXJyID0gcmVmdGFibGVfYmxvY2tfc291cmNlX2Zyb21fZmlsZSgmc3JjLCB0YWJsZW5hbWUpOwoJc3RydWN0IHJlZnRhYmxlX3JlYWRlciAqciA9IE5VTEw7CglzdHJ1Y3QgcmVmdGFibGVfdGFibGUgdGFiID0geyBOVUxMIH07CglpZiAoZXJyIDwgMCkKCQlnb3RvIGRvbmU7CgoJZXJyID0gcmVmdGFibGVfbmV3X3JlYWRlcigmciwgJnNyYywgdGFibGVuYW1lKTsKCWlmIChlcnIgPCAwKQoJCWdvdG8gZG9uZTsKCglyZWZ0YWJsZV90YWJsZV9mcm9tX3JlYWRlcigmdGFiLCByKTsKCWVyciA9IHJlZnRhYmxlX3RhYmxlX3ByaW50KCZ0YWIpOwpkb25lOgoJcmVmdGFibGVfcmVhZGVyX2ZyZWUocik7CglyZXR1cm4gZXJyOwp9Cg==",
    "text": "/*\nCopyright 2020 Google LLC\n\nUse of this source code is governed by a BSD-style\nlicense that can be found in the LICENSE file or at\nhttps://developers.google.com/open-source/licenses/bsd\n*/\n\n#include \"reader.h\"\n\n#include \"system.h\"\n#include \"block.h\"\n#include \"constants.h\"\n#include \"generic.h\"\n#include \"iter.h\"\n#include \"record.h\"\n#include \"reftable-error.h\"\n#include \"reftable-generic.h\"\n#include \"tree.h\"\n\nuint64_t block_source_size(struct reftable_block_source *source)\n{\n\treturn source->ops->size(source->arg);\n}\n\nint block_source_read_block(struct reftable_block_source *source,\n\t\t\t    struct reftable_block *dest, uint64_t off,\n\t\t\t    uint32_t size)\n{\n\tint result = source->ops->read_block(source->arg, dest, off, size);\n\tdest->source = *source;\n\treturn result;\n}\n\nvoid block_source_close(struct reftable_block_source *source)\n{\n\tif (!source->ops) {\n\t\treturn;\n\t}\n\n\tsource->ops->close(source->arg);\n\tsource->ops = NULL;\n}\n\nstatic struct reftable_reader_offsets *\nreader_offsets_for(struct reftable_reader *r, uint8_t typ)\n{\n\tswitch (typ) {\n\tcase BLOCK_TYPE_REF:\n\t\treturn &r->ref_offsets;\n\tcase BLOCK_TYPE_LOG:\n\t\treturn &r->log_offsets;\n\tcase BLOCK_TYPE_OBJ:\n\t\treturn &r->obj_offsets;\n\t}\n\tabort();\n}\n\nstatic int reader_get_block(struct reftable_reader *r,\n\t\t\t    struct reftable_block *dest, uint64_t off,\n\t\t\t    uint32_t sz)\n{\n\tif (off >= r->size)\n\t\treturn 0;\n\n\tif (off + sz > r->size) {\n\t\tsz = r->size - off;\n\t}\n\n\treturn block_source_read_block(&r->source, dest, off, sz);\n}\n\nuint32_t reftable_reader_hash_id(struct reftable_reader *r)\n{\n\treturn r->hash_id;\n}\n\nconst char *reader_name(struct reftable_reader *r)\n{\n\treturn r->name;\n}\n\nstatic int parse_footer(struct reftable_reader *r, uint8_t *footer,\n\t\t\tuint8_t *header)\n{\n\tuint8_t *f = footer;\n\tuint8_t first_block_typ;\n\tint err = 0;\n\tuint32_t computed_crc;\n\tuint32_t file_crc;\n\n\tif (memcmp(f, \"REFT\", 4)) {\n\t\terr = REFTABLE_FORMAT_ERROR;\n\t\tgoto done;\n\t}\n\tf += 4;\n\n\tif (memcmp(footer, header, header_size(r->version))) {\n\t\terr = REFTABLE_FORMAT_ERROR;\n\t\tgoto done;\n\t}\n\n\tf++;\n\tr->block_size = get_be24(f);\n\n\tf += 3;\n\tr->min_update_index = get_be64(f);\n\tf += 8;\n\tr->max_update_index = get_be64(f);\n\tf += 8;\n\n\tif (r->version == 1) {\n\t\tr->hash_id = GIT_SHA1_FORMAT_ID;\n\t} else {\n\t\tr->hash_id = get_be32(f);\n\t\tswitch (r->hash_id) {\n\t\tcase GIT_SHA1_FORMAT_ID:\n\t\t\tbreak;\n\t\tcase GIT_SHA256_FORMAT_ID:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = REFTABLE_FORMAT_ERROR;\n\t\t\tgoto done;\n\t\t}\n\t\tf += 4;\n\t}\n\n\tr->ref_offsets.index_offset = get_be64(f);\n\tf += 8;\n\n\tr->obj_offsets.offset = get_be64(f);\n\tf += 8;\n\n\tr->object_id_len = r->obj_offsets.offset & ((1 << 5) - 1);\n\tr->obj_offsets.offset >>= 5;\n\n\tr->obj_offsets.index_offset = get_be64(f);\n\tf += 8;\n\tr->log_offsets.offset = get_be64(f);\n\tf += 8;\n\tr->log_offsets.index_offset = get_be64(f);\n\tf += 8;\n\n\tcomputed_crc = crc32(0, footer, f - footer);\n\tfile_crc = get_be32(f);\n\tf += 4;\n\tif (computed_crc != file_crc) {\n\t\terr = REFTABLE_FORMAT_ERROR;\n\t\tgoto done;\n\t}\n\n\tfirst_block_typ = header[header_size(r->version)];\n\tr->ref_offsets.is_present = (first_block_typ == BLOCK_TYPE_REF);\n\tr->ref_offsets.offset = 0;\n\tr->log_offsets.is_present = (first_block_typ == BLOCK_TYPE_LOG ||\n\t\t\t\t     r->log_offsets.offset > 0);\n\tr->obj_offsets.is_present = r->obj_offsets.offset > 0;\n\terr = 0;\ndone:\n\treturn err;\n}\n\nint init_reader(struct reftable_reader *r, struct reftable_block_source *source,\n\t\tconst char *name)\n{\n\tstruct reftable_block footer = { NULL };\n\tstruct reftable_block header = { NULL };\n\tint err = 0;\n\tuint64_t file_size = block_source_size(source);\n\n\t/* Need +1 to read type of first block. */\n\tuint32_t read_size = header_size(2) + 1; /* read v2 because it's larger.  */\n\tmemset(r, 0, sizeof(struct reftable_reader));\n\n\tif (read_size > file_size) {\n\t\terr = REFTABLE_FORMAT_ERROR;\n\t\tgoto done;\n\t}\n\n\terr = block_source_read_block(source, &header, 0, read_size);\n\tif (err != read_size) {\n\t\terr = REFTABLE_IO_ERROR;\n\t\tgoto done;\n\t}\n\n\tif (memcmp(header.data, \"REFT\", 4)) {\n\t\terr = REFTABLE_FORMAT_ERROR;\n\t\tgoto done;\n\t}\n\tr->version = header.data[4];\n\tif (r->version != 1 && r->version != 2) {\n\t\terr = REFTABLE_FORMAT_ERROR;\n\t\tgoto done;\n\t}\n\n\tr->size = file_size - footer_size(r->version);\n\tr->source = *source;\n\tr->name = xstrdup(name);\n\tr->hash_id = 0;\n\n\terr = block_source_read_block(source, &footer, r->size,\n\t\t\t\t      footer_size(r->version));\n\tif (err != footer_size(r->version)) {\n\t\terr = REFTABLE_IO_ERROR;\n\t\tgoto done;\n\t}\n\n\terr = parse_footer(r, footer.data, header.data);\ndone:\n\treftable_block_done(&footer);\n\treftable_block_done(&header);\n\treturn err;\n}\n\nstruct table_iter {\n\tstruct reftable_reader *r;\n\tuint8_t typ;\n\tuint64_t block_off;\n\tstruct block_iter bi;\n\tint is_finished;\n};\n#define TABLE_ITER_INIT                          \\\n\t{                                        \\\n\t\t.bi = {.last_key = STRBUF_INIT } \\\n\t}\n\nstatic void table_iter_copy_from(struct table_iter *dest,\n\t\t\t\t struct table_iter *src)\n{\n\tdest->r = src->r;\n\tdest->typ = src->typ;\n\tdest->block_off = src->block_off;\n\tdest->is_finished = src->is_finished;\n\tblock_iter_copy_from(&dest->bi, &src->bi);\n}\n\nstatic int table_iter_next_in_block(struct table_iter *ti,\n\t\t\t\t    struct reftable_record *rec)\n{\n\tint res = block_iter_next(&ti->bi, rec);\n\tif (res == 0 && reftable_record_type(rec) == BLOCK_TYPE_REF) {\n\t\t((struct reftable_ref_record *)rec->data)->update_index +=\n\t\t\tti->r->min_update_index;\n\t}\n\n\treturn res;\n}\n\nstatic void table_iter_block_done(struct table_iter *ti)\n{\n\tif (!ti->bi.br) {\n\t\treturn;\n\t}\n\treftable_block_done(&ti->bi.br->block);\n\tFREE_AND_NULL(ti->bi.br);\n\n\tti->bi.last_key.len = 0;\n\tti->bi.next_off = 0;\n}\n\nstatic int32_t extract_block_size(uint8_t *data, uint8_t *typ, uint64_t off,\n\t\t\t\t  int version)\n{\n\tint32_t result = 0;\n\n\tif (off == 0) {\n\t\tdata += header_size(version);\n\t}\n\n\t*typ = data[0];\n\tif (reftable_is_block_type(*typ)) {\n\t\tresult = get_be24(data + 1);\n\t}\n\treturn result;\n}\n\nint reader_init_block_reader(struct reftable_reader *r, struct block_reader *br,\n\t\t\t     uint64_t next_off, uint8_t want_typ)\n{\n\tint32_t guess_block_size = r->block_size ? r->block_size :\n\t\t\t\t\t\t\t DEFAULT_BLOCK_SIZE;\n\tstruct reftable_block block = { NULL };\n\tuint8_t block_typ = 0;\n\tint err = 0;\n\tuint32_t header_off = next_off ? 0 : header_size(r->version);\n\tint32_t block_size = 0;\n\n\tif (next_off >= r->size)\n\t\treturn 1;\n\n\terr = reader_get_block(r, &block, next_off, guess_block_size);\n\tif (err < 0)\n\t\treturn err;\n\n\tblock_size = extract_block_size(block.data, &block_typ, next_off,\n\t\t\t\t\tr->version);\n\tif (block_size < 0)\n\t\treturn block_size;\n\n\tif (want_typ != BLOCK_TYPE_ANY && block_typ != want_typ) {\n\t\treftable_block_done(&block);\n\t\treturn 1;\n\t}\n\n\tif (block_size > guess_block_size) {\n\t\treftable_block_done(&block);\n\t\terr = reader_get_block(r, &block, next_off, block_size);\n\t\tif (err < 0) {\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn block_reader_init(br, &block, header_off, r->block_size,\n\t\t\t\t hash_size(r->hash_id));\n}\n\nstatic int table_iter_next_block(struct table_iter *dest,\n\t\t\t\t struct table_iter *src)\n{\n\tuint64_t next_block_off = src->block_off + src->bi.br->full_block_size;\n\tstruct block_reader br = { 0 };\n\tint err = 0;\n\n\tdest->r = src->r;\n\tdest->typ = src->typ;\n\tdest->block_off = next_block_off;\n\n\terr = reader_init_block_reader(src->r, &br, next_block_off, src->typ);\n\tif (err > 0) {\n\t\tdest->is_finished = 1;\n\t\treturn 1;\n\t}\n\tif (err != 0)\n\t\treturn err;\n\telse {\n\t\tstruct block_reader *brp =\n\t\t\treftable_malloc(sizeof(struct block_reader));\n\t\t*brp = br;\n\n\t\tdest->is_finished = 0;\n\t\tblock_reader_start(brp, &dest->bi);\n\t}\n\treturn 0;\n}\n\nstatic int table_iter_next(struct table_iter *ti, struct reftable_record *rec)\n{\n\tif (reftable_record_type(rec) != ti->typ)\n\t\treturn REFTABLE_API_ERROR;\n\n\twhile (1) {\n\t\tstruct table_iter next = TABLE_ITER_INIT;\n\t\tint err = 0;\n\t\tif (ti->is_finished) {\n\t\t\treturn 1;\n\t\t}\n\n\t\terr = table_iter_next_in_block(ti, rec);\n\t\tif (err <= 0) {\n\t\t\treturn err;\n\t\t}\n\n\t\terr = table_iter_next_block(&next, ti);\n\t\tif (err != 0) {\n\t\t\tti->is_finished = 1;\n\t\t}\n\t\ttable_iter_block_done(ti);\n\t\tif (err != 0) {\n\t\t\treturn err;\n\t\t}\n\t\ttable_iter_copy_from(ti, &next);\n\t\tblock_iter_close(&next.bi);\n\t}\n}\n\nstatic int table_iter_next_void(void *ti, struct reftable_record *rec)\n{\n\treturn table_iter_next(ti, rec);\n}\n\nstatic void table_iter_close(void *p)\n{\n\tstruct table_iter *ti = p;\n\ttable_iter_block_done(ti);\n\tblock_iter_close(&ti->bi);\n}\n\nstatic struct reftable_iterator_vtable table_iter_vtable = {\n\t.next = &table_iter_next_void,\n\t.close = &table_iter_close,\n};\n\nstatic void iterator_from_table_iter(struct reftable_iterator *it,\n\t\t\t\t     struct table_iter *ti)\n{\n\tassert(!it->ops);\n\tit->iter_arg = ti;\n\tit->ops = &table_iter_vtable;\n}\n\nstatic int reader_table_iter_at(struct reftable_reader *r,\n\t\t\t\tstruct table_iter *ti, uint64_t off,\n\t\t\t\tuint8_t typ)\n{\n\tstruct block_reader br = { 0 };\n\tstruct block_reader *brp = NULL;\n\n\tint err = reader_init_block_reader(r, &br, off, typ);\n\tif (err != 0)\n\t\treturn err;\n\n\tbrp = reftable_malloc(sizeof(struct block_reader));\n\t*brp = br;\n\tti->r = r;\n\tti->typ = block_reader_type(brp);\n\tti->block_off = off;\n\tblock_reader_start(brp, &ti->bi);\n\treturn 0;\n}\n\nstatic int reader_start(struct reftable_reader *r, struct table_iter *ti,\n\t\t\tuint8_t typ, int index)\n{\n\tstruct reftable_reader_offsets *offs = reader_offsets_for(r, typ);\n\tuint64_t off = offs->offset;\n\tif (index) {\n\t\toff = offs->index_offset;\n\t\tif (off == 0) {\n\t\t\treturn 1;\n\t\t}\n\t\ttyp = BLOCK_TYPE_INDEX;\n\t}\n\n\treturn reader_table_iter_at(r, ti, off, typ);\n}\n\nstatic int reader_seek_linear(struct reftable_reader *r, struct table_iter *ti,\n\t\t\t      struct reftable_record *want)\n{\n\tstruct reftable_record rec =\n\t\treftable_new_record(reftable_record_type(want));\n\tstruct strbuf want_key = STRBUF_INIT;\n\tstruct strbuf got_key = STRBUF_INIT;\n\tstruct table_iter next = TABLE_ITER_INIT;\n\tint err = -1;\n\n\treftable_record_key(want, &want_key);\n\n\twhile (1) {\n\t\terr = table_iter_next_block(&next, ti);\n\t\tif (err < 0)\n\t\t\tgoto done;\n\n\t\tif (err > 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\terr = block_reader_first_key(next.bi.br, &got_key);\n\t\tif (err < 0)\n\t\t\tgoto done;\n\n\t\tif (strbuf_cmp(&got_key, &want_key) > 0) {\n\t\t\ttable_iter_block_done(&next);\n\t\t\tbreak;\n\t\t}\n\n\t\ttable_iter_block_done(ti);\n\t\ttable_iter_copy_from(ti, &next);\n\t}\n\n\terr = block_iter_seek(&ti->bi, &want_key);\n\tif (err < 0)\n\t\tgoto done;\n\terr = 0;\n\ndone:\n\tblock_iter_close(&next.bi);\n\treftable_record_destroy(&rec);\n\tstrbuf_release(&want_key);\n\tstrbuf_release(&got_key);\n\treturn err;\n}\n\nstatic int reader_seek_indexed(struct reftable_reader *r,\n\t\t\t       struct reftable_iterator *it,\n\t\t\t       struct reftable_record *rec)\n{\n\tstruct reftable_index_record want_index = { .last_key = STRBUF_INIT };\n\tstruct reftable_record want_index_rec = { NULL };\n\tstruct reftable_index_record index_result = { .last_key = STRBUF_INIT };\n\tstruct reftable_record index_result_rec = { NULL };\n\tstruct table_iter index_iter = TABLE_ITER_INIT;\n\tstruct table_iter next = TABLE_ITER_INIT;\n\tint err = 0;\n\n\treftable_record_key(rec, &want_index.last_key);\n\treftable_record_from_index(&want_index_rec, &want_index);\n\treftable_record_from_index(&index_result_rec, &index_result);\n\n\terr = reader_start(r, &index_iter, reftable_record_type(rec), 1);\n\tif (err < 0)\n\t\tgoto done;\n\n\terr = reader_seek_linear(r, &index_iter, &want_index_rec);\n\twhile (1) {\n\t\terr = table_iter_next(&index_iter, &index_result_rec);\n\t\ttable_iter_block_done(&index_iter);\n\t\tif (err != 0)\n\t\t\tgoto done;\n\n\t\terr = reader_table_iter_at(r, &next, index_result.offset, 0);\n\t\tif (err != 0)\n\t\t\tgoto done;\n\n\t\terr = block_iter_seek(&next.bi, &want_index.last_key);\n\t\tif (err < 0)\n\t\t\tgoto done;\n\n\t\tif (next.typ == reftable_record_type(rec)) {\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (next.typ != BLOCK_TYPE_INDEX) {\n\t\t\terr = REFTABLE_FORMAT_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\ttable_iter_copy_from(&index_iter, &next);\n\t}\n\n\tif (err == 0) {\n\t\tstruct table_iter empty = TABLE_ITER_INIT;\n\t\tstruct table_iter *malloced =\n\t\t\treftable_calloc(sizeof(struct table_iter));\n\t\t*malloced = empty;\n\t\ttable_iter_copy_from(malloced, &next);\n\t\titerator_from_table_iter(it, malloced);\n\t}\ndone:\n\tblock_iter_close(&next.bi);\n\ttable_iter_close(&index_iter);\n\treftable_record_release(&want_index_rec);\n\treftable_record_release(&index_result_rec);\n\treturn err;\n}\n\nstatic int reader_seek_internal(struct reftable_reader *r,\n\t\t\t\tstruct reftable_iterator *it,\n\t\t\t\tstruct reftable_record *rec)\n{\n\tstruct reftable_reader_offsets *offs =\n\t\treader_offsets_for(r, reftable_record_type(rec));\n\tuint64_t idx = offs->index_offset;\n\tstruct table_iter ti = TABLE_ITER_INIT;\n\tint err = 0;\n\tif (idx > 0)\n\t\treturn reader_seek_indexed(r, it, rec);\n\n\terr = reader_start(r, &ti, reftable_record_type(rec), 0);\n\tif (err < 0)\n\t\treturn err;\n\terr = reader_seek_linear(r, &ti, rec);\n\tif (err < 0)\n\t\treturn err;\n\telse {\n\t\tstruct table_iter *p =\n\t\t\treftable_malloc(sizeof(struct table_iter));\n\t\t*p = ti;\n\t\titerator_from_table_iter(it, p);\n\t}\n\n\treturn 0;\n}\n\nstatic int reader_seek(struct reftable_reader *r, struct reftable_iterator *it,\n\t\t       struct reftable_record *rec)\n{\n\tuint8_t typ = reftable_record_type(rec);\n\n\tstruct reftable_reader_offsets *offs = reader_offsets_for(r, typ);\n\tif (!offs->is_present) {\n\t\titerator_set_empty(it);\n\t\treturn 0;\n\t}\n\n\treturn reader_seek_internal(r, it, rec);\n}\n\nint reftable_reader_seek_ref(struct reftable_reader *r,\n\t\t\t     struct reftable_iterator *it, const char *name)\n{\n\tstruct reftable_ref_record ref = {\n\t\t.refname = (char *)name,\n\t};\n\tstruct reftable_record rec = { NULL };\n\treftable_record_from_ref(&rec, &ref);\n\treturn reader_seek(r, it, &rec);\n}\n\nint reftable_reader_seek_log_at(struct reftable_reader *r,\n\t\t\t\tstruct reftable_iterator *it, const char *name,\n\t\t\t\tuint64_t update_index)\n{\n\tstruct reftable_log_record log = {\n\t\t.refname = (char *)name,\n\t\t.update_index = update_index,\n\t};\n\tstruct reftable_record rec = { NULL };\n\treftable_record_from_log(&rec, &log);\n\treturn reader_seek(r, it, &rec);\n}\n\nint reftable_reader_seek_log(struct reftable_reader *r,\n\t\t\t     struct reftable_iterator *it, const char *name)\n{\n\tuint64_t max = ~((uint64_t)0);\n\treturn reftable_reader_seek_log_at(r, it, name, max);\n}\n\nvoid reader_close(struct reftable_reader *r)\n{\n\tblock_source_close(&r->source);\n\tFREE_AND_NULL(r->name);\n}\n\nint reftable_new_reader(struct reftable_reader **p,\n\t\t\tstruct reftable_block_source *src, char const *name)\n{\n\tstruct reftable_reader *rd =\n\t\treftable_calloc(sizeof(struct reftable_reader));\n\tint err = init_reader(rd, src, name);\n\tif (err == 0) {\n\t\t*p = rd;\n\t} else {\n\t\tblock_source_close(src);\n\t\treftable_free(rd);\n\t}\n\treturn err;\n}\n\nvoid reftable_reader_free(struct reftable_reader *r)\n{\n\treader_close(r);\n\treftable_free(r);\n}\n\nstatic int reftable_reader_refs_for_indexed(struct reftable_reader *r,\n\t\t\t\t\t    struct reftable_iterator *it,\n\t\t\t\t\t    uint8_t *oid)\n{\n\tstruct reftable_obj_record want = {\n\t\t.hash_prefix = oid,\n\t\t.hash_prefix_len = r->object_id_len,\n\t};\n\tstruct reftable_record want_rec = { NULL };\n\tstruct reftable_iterator oit = { NULL };\n\tstruct reftable_obj_record got = { NULL };\n\tstruct reftable_record got_rec = { NULL };\n\tint err = 0;\n\tstruct indexed_table_ref_iter *itr = NULL;\n\n\t/* Look through the reverse index. */\n\treftable_record_from_obj(&want_rec, &want);\n\terr = reader_seek(r, &oit, &want_rec);\n\tif (err != 0)\n\t\tgoto done;\n\n\t/* read out the reftable_obj_record */\n\treftable_record_from_obj(&got_rec, &got);\n\terr = iterator_next(&oit, &got_rec);\n\tif (err < 0)\n\t\tgoto done;\n\n\tif (err > 0 ||\n\t    memcmp(want.hash_prefix, got.hash_prefix, r->object_id_len)) {\n\t\t/* didn't find it; return empty iterator */\n\t\titerator_set_empty(it);\n\t\terr = 0;\n\t\tgoto done;\n\t}\n\n\terr = new_indexed_table_ref_iter(&itr, r, oid, hash_size(r->hash_id),\n\t\t\t\t\t got.offsets, got.offset_len);\n\tif (err < 0)\n\t\tgoto done;\n\tgot.offsets = NULL;\n\titerator_from_indexed_table_ref_iter(it, itr);\n\ndone:\n\treftable_iterator_destroy(&oit);\n\treftable_record_release(&got_rec);\n\treturn err;\n}\n\nstatic int reftable_reader_refs_for_unindexed(struct reftable_reader *r,\n\t\t\t\t\t      struct reftable_iterator *it,\n\t\t\t\t\t      uint8_t *oid)\n{\n\tstruct table_iter ti_empty = TABLE_ITER_INIT;\n\tstruct table_iter *ti = reftable_calloc(sizeof(struct table_iter));\n\tstruct filtering_ref_iterator *filter = NULL;\n\tstruct filtering_ref_iterator empty = FILTERING_REF_ITERATOR_INIT;\n\tint oid_len = hash_size(r->hash_id);\n\tint err;\n\n\t*ti = ti_empty;\n\terr = reader_start(r, ti, BLOCK_TYPE_REF, 0);\n\tif (err < 0) {\n\t\treftable_free(ti);\n\t\treturn err;\n\t}\n\n\tfilter = reftable_malloc(sizeof(struct filtering_ref_iterator));\n\t*filter = empty;\n\n\tstrbuf_add(&filter->oid, oid, oid_len);\n\treftable_table_from_reader(&filter->tab, r);\n\tfilter->double_check = 0;\n\titerator_from_table_iter(&filter->it, ti);\n\n\titerator_from_filtering_ref_iterator(it, filter);\n\treturn 0;\n}\n\nint reftable_reader_refs_for(struct reftable_reader *r,\n\t\t\t     struct reftable_iterator *it, uint8_t *oid)\n{\n\tif (r->obj_offsets.is_present)\n\t\treturn reftable_reader_refs_for_indexed(r, it, oid);\n\treturn reftable_reader_refs_for_unindexed(r, it, oid);\n}\n\nuint64_t reftable_reader_max_update_index(struct reftable_reader *r)\n{\n\treturn r->max_update_index;\n}\n\nuint64_t reftable_reader_min_update_index(struct reftable_reader *r)\n{\n\treturn r->min_update_index;\n}\n\n/* generic table interface. */\n\nstatic int reftable_reader_seek_void(void *tab, struct reftable_iterator *it,\n\t\t\t\t     struct reftable_record *rec)\n{\n\treturn reader_seek(tab, it, rec);\n}\n\nstatic uint32_t reftable_reader_hash_id_void(void *tab)\n{\n\treturn reftable_reader_hash_id(tab);\n}\n\nstatic uint64_t reftable_reader_min_update_index_void(void *tab)\n{\n\treturn reftable_reader_min_update_index(tab);\n}\n\nstatic uint64_t reftable_reader_max_update_index_void(void *tab)\n{\n\treturn reftable_reader_max_update_index(tab);\n}\n\nstatic struct reftable_table_vtable reader_vtable = {\n\t.seek_record = reftable_reader_seek_void,\n\t.hash_id = reftable_reader_hash_id_void,\n\t.min_update_index = reftable_reader_min_update_index_void,\n\t.max_update_index = reftable_reader_max_update_index_void,\n};\n\nvoid reftable_table_from_reader(struct reftable_table *tab,\n\t\t\t\tstruct reftable_reader *reader)\n{\n\tassert(!tab->ops);\n\ttab->ops = &reader_vtable;\n\ttab->table_arg = reader;\n}\n\n\nint reftable_reader_print_file(const char *tablename)\n{\n\tstruct reftable_block_source src = { NULL };\n\tint err = reftable_block_source_from_file(&src, tablename);\n\tstruct reftable_reader *r = NULL;\n\tstruct reftable_table tab = { NULL };\n\tif (err < 0)\n\t\tgoto done;\n\n\terr = reftable_new_reader(&r, &src, tablename);\n\tif (err < 0)\n\t\tgoto done;\n\n\treftable_table_from_reader(&tab, r);\n\terr = reftable_table_print(&tab);\ndone:\n\treftable_reader_free(r);\n\treturn err;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "006709a645aea2ddbc914673710e66fa2343d569",
  "sha1_ok": true,
  "size": 18553
}
