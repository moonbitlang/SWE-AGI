{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJjb21taXQuaCIKI2luY2x1ZGUgImNvbG9yLmgiCiNpbmNsdWRlICJncmFwaC5oIgojaW5jbHVkZSAiZGlmZi5oIgojaW5jbHVkZSAicmV2aXNpb24uaCIKI2luY2x1ZGUgImFyZ3YtYXJyYXkuaCIKCi8qIEludGVybmFsIEFQSSAqLwoKLyoKICogT3V0cHV0IGEgcGFkZGluZyBsaW5lIGluIHRoZSBncmFwaC4KICogVGhpcyBpcyBzaW1pbGFyIHRvIGdyYXBoX25leHRfbGluZSgpLiAgSG93ZXZlciwgaXQgaXMgZ3VhcmFudGVlZCB0bwogKiBuZXZlciBwcmludCB0aGUgY3VycmVudCBjb21taXQgbGluZS4gIEluc3RlYWQsIGlmIHRoZSBjb21taXQgbGluZSBpcwogKiBuZXh0LCBpdCB3aWxsIHNpbXBseSBvdXRwdXQgYSBsaW5lIG9mIHZlcnRpY2FsIHBhZGRpbmcsIGV4dGVuZGluZyB0aGUKICogYnJhbmNoIGxpbmVzIGRvd253YXJkcywgYnV0IGxlYXZpbmcgdGhlbSBvdGhlcndpc2UgdW5jaGFuZ2VkLgogKi8Kc3RhdGljIHZvaWQgZ3JhcGhfcGFkZGluZ19saW5lKHN0cnVjdCBnaXRfZ3JhcGggKmdyYXBoLCBzdHJ1Y3Qgc3RyYnVmICpzYik7CgovKgogKiBQcmludCBhIHN0cmJ1Zi4gIElmIHRoZSBncmFwaCBpcyBub24tTlVMTCwgYWxsIGxpbmVzIGJ1dCB0aGUgZmlyc3Qgd2lsbCBiZQogKiBwcmVmaXhlZCB3aXRoIHRoZSBncmFwaCBvdXRwdXQuCiAqCiAqIElmIHRoZSBzdHJidWYgZW5kcyB3aXRoIGEgbmV3bGluZSwgdGhlIG91dHB1dCB3aWxsIGVuZCBhZnRlciB0aGlzCiAqIG5ld2xpbmUuICBBIG5ldyBncmFwaCBsaW5lIHdpbGwgbm90IGJlIHByaW50ZWQgYWZ0ZXIgdGhlIGZpbmFsIG5ld2xpbmUuCiAqIElmIHRoZSBzdHJidWYgaXMgZW1wdHksIG5vIG91dHB1dCB3aWxsIGJlIHByaW50ZWQuCiAqCiAqIFNpbmNlIHRoZSBmaXJzdCBsaW5lIHdpbGwgbm90IGluY2x1ZGUgdGhlIGdyYXBoIG91dHB1dCwgdGhlIGNhbGxlciBpcwogKiByZXNwb25zaWJsZSBmb3IgcHJpbnRpbmcgdGhpcyBsaW5lJ3MgZ3JhcGggKHBlcmhhcHMgdmlhCiAqIGdyYXBoX3Nob3dfY29tbWl0KCkgb3IgZ3JhcGhfc2hvd19vbmVsaW5lKCkpIGJlZm9yZSBjYWxsaW5nCiAqIGdyYXBoX3Nob3dfc3RyYnVmKCkuCiAqLwpzdGF0aWMgdm9pZCBncmFwaF9zaG93X3N0cmJ1ZihzdHJ1Y3QgZ2l0X2dyYXBoICpncmFwaCwgc3RydWN0IHN0cmJ1ZiBjb25zdCAqc2IpOwoKLyoKICogVE9ETzoKICogLSBMaW1pdCB0aGUgbnVtYmVyIG9mIGNvbHVtbnMsIHNpbWlsYXIgdG8gdGhlIHdheSBnaXRrIGRvZXMuCiAqICAgSWYgd2UgcmVhY2ggbW9yZSB0aGFuIGEgc3BlY2lmaWVkIG51bWJlciBvZiBjb2x1bW5zLCBvbWl0CiAqICAgc2VjdGlvbnMgb2Ygc29tZSBjb2x1bW5zLgogKi8KCnN0cnVjdCBjb2x1bW4gewoJLyoKCSAqIFRoZSBwYXJlbnQgY29tbWl0IG9mIHRoaXMgY29sdW1uLgoJICovCglzdHJ1Y3QgY29tbWl0ICpjb21taXQ7CgkvKgoJICogVGhlIGNvbG9yIHRvIChvcHRpb25hbGx5KSBwcmludCB0aGlzIGNvbHVtbiBpbi4gIFRoaXMgaXMgYW4KCSAqIGluZGV4IGludG8gY29sdW1uX2NvbG9ycy4KCSAqLwoJdW5zaWduZWQgc2hvcnQgY29sb3I7Cn07CgplbnVtIGdyYXBoX3N0YXRlIHsKCUdSQVBIX1BBRERJTkcsCglHUkFQSF9TS0lQLAoJR1JBUEhfUFJFX0NPTU1JVCwKCUdSQVBIX0NPTU1JVCwKCUdSQVBIX1BPU1RfTUVSR0UsCglHUkFQSF9DT0xMQVBTSU5HCn07CgpzdGF0aWMgY29uc3QgY2hhciAqKmNvbHVtbl9jb2xvcnM7CnN0YXRpYyB1bnNpZ25lZCBzaG9ydCBjb2x1bW5fY29sb3JzX21heDsKCnN0YXRpYyB2b2lkIHBhcnNlX2dyYXBoX2NvbG9yc19jb25maWcoc3RydWN0IGFyZ3ZfYXJyYXkgKmNvbG9ycywgY29uc3QgY2hhciAqc3RyaW5nKQp7Cgljb25zdCBjaGFyICplbmQsICpzdGFydDsKCglzdGFydCA9IHN0cmluZzsKCWVuZCA9IHN0cmluZyArIHN0cmxlbihzdHJpbmcpOwoJd2hpbGUgKHN0YXJ0IDwgZW5kKSB7CgkJY29uc3QgY2hhciAqY29tbWEgPSBzdHJjaHJudWwoc3RhcnQsICcsJyk7CgkJY2hhciBjb2xvcltDT0xPUl9NQVhMRU5dOwoKCQlpZiAoIWNvbG9yX3BhcnNlX21lbShzdGFydCwgY29tbWEgLSBzdGFydCwgY29sb3IpKQoJCQlhcmd2X2FycmF5X3B1c2goY29sb3JzLCBjb2xvcik7CgkJZWxzZQoJCQl3YXJuaW5nKF8oImlnbm9yZSBpbnZhbGlkIGNvbG9yICclLipzJyBpbiBsb2cuZ3JhcGhDb2xvcnMiKSwKCQkJCShpbnQpKGNvbW1hIC0gc3RhcnQpLCBzdGFydCk7CgkJc3RhcnQgPSBjb21tYSArIDE7Cgl9Cglhcmd2X2FycmF5X3B1c2goY29sb3JzLCBHSVRfQ09MT1JfUkVTRVQpOwp9Cgp2b2lkIGdyYXBoX3NldF9jb2x1bW5fY29sb3JzKGNvbnN0IGNoYXIgKipjb2xvcnMsIHVuc2lnbmVkIHNob3J0IGNvbG9yc19tYXgpCnsKCWNvbHVtbl9jb2xvcnMgPSBjb2xvcnM7Cgljb2x1bW5fY29sb3JzX21heCA9IGNvbG9yc19tYXg7Cn0KCnN0YXRpYyBjb25zdCBjaGFyICpjb2x1bW5fZ2V0X2NvbG9yX2NvZGUodW5zaWduZWQgc2hvcnQgY29sb3IpCnsKCXJldHVybiBjb2x1bW5fY29sb3JzW2NvbG9yXTsKfQoKc3RhdGljIHZvaWQgc3RyYnVmX3dyaXRlX2NvbHVtbihzdHJ1Y3Qgc3RyYnVmICpzYiwgY29uc3Qgc3RydWN0IGNvbHVtbiAqYywKCQkJCWNoYXIgY29sX2NoYXIpCnsKCWlmIChjLT5jb2xvciA8IGNvbHVtbl9jb2xvcnNfbWF4KQoJCXN0cmJ1Zl9hZGRzdHIoc2IsIGNvbHVtbl9nZXRfY29sb3JfY29kZShjLT5jb2xvcikpOwoJc3RyYnVmX2FkZGNoKHNiLCBjb2xfY2hhcik7CglpZiAoYy0+Y29sb3IgPCBjb2x1bW5fY29sb3JzX21heCkKCQlzdHJidWZfYWRkc3RyKHNiLCBjb2x1bW5fZ2V0X2NvbG9yX2NvZGUoY29sdW1uX2NvbG9yc19tYXgpKTsKfQoKc3RydWN0IGdpdF9ncmFwaCB7CgkvKgoJICogVGhlIGNvbW1pdCBjdXJyZW50bHkgYmVpbmcgcHJvY2Vzc2VkCgkgKi8KCXN0cnVjdCBjb21taXQgKmNvbW1pdDsKCS8qIFRoZSByZXYtaW5mbyB1c2VkIGZvciB0aGUgY3VycmVudCB0cmF2ZXJzYWwgKi8KCXN0cnVjdCByZXZfaW5mbyAqcmV2czsKCS8qCgkgKiBUaGUgbnVtYmVyIG9mIGludGVyZXN0aW5nIHBhcmVudHMgdGhhdCB0aGlzIGNvbW1pdCBoYXMuCgkgKgoJICogTm90ZSB0aGF0IHRoaXMgaXMgbm90IHRoZSBzYW1lIGFzIHRoZSBhY3R1YWwgbnVtYmVyIG9mIHBhcmVudHMuCgkgKiBUaGlzIGNvdW50IGV4Y2x1ZGVzIHBhcmVudHMgdGhhdCB3b24ndCBiZSBwcmludGVkIGluIHRoZSBncmFwaAoJICogb3V0cHV0LCBhcyBkZXRlcm1pbmVkIGJ5IGdyYXBoX2lzX2ludGVyZXN0aW5nKCkuCgkgKi8KCWludCBudW1fcGFyZW50czsKCS8qCgkgKiBUaGUgd2lkdGggb2YgdGhlIGdyYXBoIG91dHB1dCBmb3IgdGhpcyBjb21taXQuCgkgKiBBbGwgcm93cyBmb3IgdGhpcyBjb21taXQgYXJlIHBhZGRlZCB0byB0aGlzIHdpZHRoLCBzbyB0aGF0CgkgKiBtZXNzYWdlcyBwcmludGVkIGFmdGVyIHRoZSBncmFwaCBvdXRwdXQgYXJlIGFsaWduZWQuCgkgKi8KCWludCB3aWR0aDsKCS8qCgkgKiBUaGUgbmV4dCBleHBhbnNpb24gcm93IHRvIHByaW50CgkgKiB3aGVuIHN0YXRlIGlzIEdSQVBIX1BSRV9DT01NSVQKCSAqLwoJaW50IGV4cGFuc2lvbl9yb3c7CgkvKgoJICogVGhlIGN1cnJlbnQgb3V0cHV0IHN0YXRlLgoJICogVGhpcyB0ZWxscyB1cyB3aGF0IGtpbmQgb2YgbGluZSBncmFwaF9uZXh0X2xpbmUoKSBzaG91bGQgb3V0cHV0LgoJICovCgllbnVtIGdyYXBoX3N0YXRlIHN0YXRlOwoJLyoKCSAqIFRoZSBvdXRwdXQgc3RhdGUgZm9yIHRoZSBwcmV2aW91cyBsaW5lIG9mIG91dHB1dC4KCSAqIFRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gZGV0ZXJtaW5lIGhvdyB0aGUgZmlyc3QgbWVyZ2UgbGluZQoJICogc2hvdWxkIGFwcGVhciwgYmFzZWQgb24gdGhlIGxhc3QgbGluZSBvZiB0aGUgcHJldmlvdXMgY29tbWl0LgoJICovCgllbnVtIGdyYXBoX3N0YXRlIHByZXZfc3RhdGU7CgkvKgoJICogVGhlIGluZGV4IG9mIHRoZSBjb2x1bW4gdGhhdCByZWZlcnMgdG8gdGhpcyBjb21taXQuCgkgKgoJICogSWYgbm9uZSBvZiB0aGUgaW5jb21pbmcgY29sdW1ucyByZWZlciB0byB0aGlzIGNvbW1pdCwKCSAqIHRoaXMgd2lsbCBiZSBlcXVhbCB0byBudW1fY29sdW1ucy4KCSAqLwoJaW50IGNvbW1pdF9pbmRleDsKCS8qCgkgKiBUaGUgY29tbWl0X2luZGV4IGZvciB0aGUgcHJldmlvdXNseSBkaXNwbGF5ZWQgY29tbWl0LgoJICoKCSAqIFRoaXMgaXMgdXNlZCB0byBkZXRlcm1pbmUgaG93IHRoZSBmaXJzdCBsaW5lIG9mIGEgbWVyZ2UKCSAqIGdyYXBoIG91dHB1dCBzaG91bGQgYXBwZWFyLCBiYXNlZCBvbiB0aGUgbGFzdCBsaW5lIG9mIHRoZQoJICogcHJldmlvdXMgY29tbWl0LgoJICovCglpbnQgcHJldl9jb21taXRfaW5kZXg7CgkvKgoJICogVGhlIG1heGltdW0gbnVtYmVyIG9mIGNvbHVtbnMgdGhhdCBjYW4gYmUgc3RvcmVkIGluIHRoZSBjb2x1bW5zCgkgKiBhbmQgbmV3X2NvbHVtbnMgYXJyYXlzLiAgVGhpcyBpcyBhbHNvIGhhbGYgdGhlIG51bWJlciBvZiBlbnRyaWVzCgkgKiB0aGF0IGNhbiBiZSBzdG9yZWQgaW4gdGhlIG1hcHBpbmcgYW5kIG5ld19tYXBwaW5nIGFycmF5cy4KCSAqLwoJaW50IGNvbHVtbl9jYXBhY2l0eTsKCS8qCgkgKiBUaGUgbnVtYmVyIG9mIGNvbHVtbnMgKGFsc28gY2FsbGVkICJicmFuY2ggbGluZXMiIGluIHNvbWUgcGxhY2VzKQoJICovCglpbnQgbnVtX2NvbHVtbnM7CgkvKgoJICogVGhlIG51bWJlciBvZiBjb2x1bW5zIGluIHRoZSBuZXdfY29sdW1ucyBhcnJheQoJICovCglpbnQgbnVtX25ld19jb2x1bW5zOwoJLyoKCSAqIFRoZSBudW1iZXIgb2YgZW50cmllcyBpbiB0aGUgbWFwcGluZyBhcnJheQoJICovCglpbnQgbWFwcGluZ19zaXplOwoJLyoKCSAqIFRoZSBjb2x1bW4gc3RhdGUgYmVmb3JlIHdlIG91dHB1dCB0aGUgY3VycmVudCBjb21taXQuCgkgKi8KCXN0cnVjdCBjb2x1bW4gKmNvbHVtbnM7CgkvKgoJICogVGhlIG5ldyBjb2x1bW4gc3RhdGUgYWZ0ZXIgd2Ugb3V0cHV0IHRoZSBjdXJyZW50IGNvbW1pdC4KCSAqIE9ubHkgdmFsaWQgd2hlbiBzdGF0ZSBpcyBHUkFQSF9DT0xMQVBTSU5HLgoJICovCglzdHJ1Y3QgY29sdW1uICpuZXdfY29sdW1uczsKCS8qCgkgKiBBbiBhcnJheSB0aGF0IHRyYWNrcyB0aGUgY3VycmVudCBzdGF0ZSBvZiBlYWNoCgkgKiBjaGFyYWN0ZXIgaW4gdGhlIG91dHB1dCBsaW5lIGR1cmluZyBzdGF0ZSBHUkFQSF9DT0xMQVBTSU5HLgoJICogRWFjaCBlbnRyeSBpcyAtMSBpZiB0aGlzIGNoYXJhY3RlciBpcyBlbXB0eSwgb3IgYSBub24tbmVnYXRpdmUKCSAqIGludGVnZXIgaWYgdGhlIGNoYXJhY3RlciBjb250YWlucyBhIGJyYW5jaCBsaW5lLiAgVGhlIHZhbHVlIG9mCgkgKiB0aGUgaW50ZWdlciBpbmRpY2F0ZXMgdGhlIHRhcmdldCBwb3NpdGlvbiBmb3IgdGhpcyBicmFuY2ggbGluZS4KCSAqIChJLmUuLCB0aGlzIGFycmF5IG1hcHMgdGhlIGN1cnJlbnQgY29sdW1uIHBvc2l0aW9ucyB0byB0aGVpcgoJICogZGVzaXJlZCBwb3NpdGlvbnMuKQoJICoKCSAqIFRoZSBtYXhpbXVtIGNhcGFjaXR5IG9mIHRoaXMgYXJyYXkgaXMgYWx3YXlzCgkgKiBzaXplb2YoaW50KSAqIDIgKiBjb2x1bW5fY2FwYWNpdHkuCgkgKi8KCWludCAqbWFwcGluZzsKCS8qCgkgKiBBIHRlbXBvcmFyeSBhcnJheSBmb3IgY29tcHV0aW5nIHRoZSBuZXh0IG1hcHBpbmcgc3RhdGUKCSAqIHdoaWxlIHdlIGFyZSBvdXRwdXR0aW5nIGEgbWFwcGluZyBsaW5lLiAgVGhpcyBpcyBzdG9yZWQgYXMgcGFydAoJICogb2YgdGhlIGdpdF9ncmFwaCBzaW1wbHkgc28gd2UgZG9uJ3QgaGF2ZSB0byBhbGxvY2F0ZSBhIG5ldwoJICogdGVtcG9yYXJ5IGFycmF5IGVhY2ggdGltZSB3ZSBoYXZlIHRvIG91dHB1dCBhIGNvbGxhcHNpbmcgbGluZS4KCSAqLwoJaW50ICpuZXdfbWFwcGluZzsKCS8qCgkgKiBUaGUgY3VycmVudCBkZWZhdWx0IGNvbHVtbiBjb2xvciBiZWluZyB1c2VkLiAgVGhpcyBpcwoJICogc3RvcmVkIGFzIGFuIGluZGV4IGludG8gdGhlIGFycmF5IGNvbHVtbl9jb2xvcnMuCgkgKi8KCXVuc2lnbmVkIHNob3J0IGRlZmF1bHRfY29sdW1uX2NvbG9yOwp9OwoKc3RhdGljIHN0cnVjdCBzdHJidWYgKmRpZmZfb3V0cHV0X3ByZWZpeF9jYWxsYmFjayhzdHJ1Y3QgZGlmZl9vcHRpb25zICpvcHQsIHZvaWQgKmRhdGEpCnsKCXN0cnVjdCBnaXRfZ3JhcGggKmdyYXBoID0gZGF0YTsKCXN0YXRpYyBzdHJ1Y3Qgc3RyYnVmIG1zZ2J1ZiA9IFNUUkJVRl9JTklUOwoKCWFzc2VydChvcHQpOwoJYXNzZXJ0KGdyYXBoKTsKCglvcHQtPm91dHB1dF9wcmVmaXhfbGVuZ3RoID0gZ3JhcGgtPndpZHRoOwoJc3RyYnVmX3Jlc2V0KCZtc2didWYpOwoJZ3JhcGhfcGFkZGluZ19saW5lKGdyYXBoLCAmbXNnYnVmKTsKCXJldHVybiAmbXNnYnVmOwp9CgpzdHJ1Y3QgZ2l0X2dyYXBoICpncmFwaF9pbml0KHN0cnVjdCByZXZfaW5mbyAqb3B0KQp7CglzdHJ1Y3QgZ2l0X2dyYXBoICpncmFwaCA9IHhtYWxsb2Moc2l6ZW9mKHN0cnVjdCBnaXRfZ3JhcGgpKTsKCglpZiAoIWNvbHVtbl9jb2xvcnMpIHsKCQljaGFyICpzdHJpbmc7CgkJaWYgKGdpdF9jb25maWdfZ2V0X3N0cmluZygibG9nLmdyYXBoY29sb3JzIiwgJnN0cmluZykpIHsKCQkJLyogbm90IGNvbmZpZ3VyZWQgLS0gdXNlIGRlZmF1bHQgKi8KCQkJZ3JhcGhfc2V0X2NvbHVtbl9jb2xvcnMoY29sdW1uX2NvbG9yc19hbnNpLAoJCQkJCQljb2x1bW5fY29sb3JzX2Fuc2lfbWF4KTsKCQl9IGVsc2UgewoJCQlzdGF0aWMgc3RydWN0IGFyZ3ZfYXJyYXkgY3VzdG9tX2NvbG9ycyA9IEFSR1ZfQVJSQVlfSU5JVDsKCQkJYXJndl9hcnJheV9jbGVhcigmY3VzdG9tX2NvbG9ycyk7CgkJCXBhcnNlX2dyYXBoX2NvbG9yc19jb25maWcoJmN1c3RvbV9jb2xvcnMsIHN0cmluZyk7CgkJCWZyZWUoc3RyaW5nKTsKCQkJLyogZ3JhcGhfc2V0X2NvbHVtbl9jb2xvcnMgdGFrZXMgYSBtYXgtaW5kZXgsIG5vdCBhIGNvdW50ICovCgkJCWdyYXBoX3NldF9jb2x1bW5fY29sb3JzKGN1c3RvbV9jb2xvcnMuYXJndiwKCQkJCQkJY3VzdG9tX2NvbG9ycy5hcmdjIC0gMSk7CgkJfQoJfQoKCWdyYXBoLT5jb21taXQgPSBOVUxMOwoJZ3JhcGgtPnJldnMgPSBvcHQ7CglncmFwaC0+bnVtX3BhcmVudHMgPSAwOwoJZ3JhcGgtPmV4cGFuc2lvbl9yb3cgPSAwOwoJZ3JhcGgtPnN0YXRlID0gR1JBUEhfUEFERElORzsKCWdyYXBoLT5wcmV2X3N0YXRlID0gR1JBUEhfUEFERElORzsKCWdyYXBoLT5jb21taXRfaW5kZXggPSAwOwoJZ3JhcGgtPnByZXZfY29tbWl0X2luZGV4ID0gMDsKCWdyYXBoLT5udW1fY29sdW1ucyA9IDA7CglncmFwaC0+bnVtX25ld19jb2x1bW5zID0gMDsKCWdyYXBoLT5tYXBwaW5nX3NpemUgPSAwOwoJLyoKCSAqIFN0YXJ0IHRoZSBjb2x1bW4gY29sb3IgYXQgdGhlIG1heGltdW0gdmFsdWUsIHNpbmNlIHdlJ2xsCgkgKiBhbHdheXMgaW5jcmVtZW50IGl0IGZvciB0aGUgZmlyc3QgY29tbWl0IHdlIG91dHB1dC4KCSAqIFRoaXMgd2F5IHdlIHN0YXJ0IGF0IDAgZm9yIHRoZSBmaXJzdCBjb21taXQuCgkgKi8KCWdyYXBoLT5kZWZhdWx0X2NvbHVtbl9jb2xvciA9IGNvbHVtbl9jb2xvcnNfbWF4IC0gMTsKCgkvKgoJICogQWxsb2NhdGUgYSByZWFzb25hYmx5IGxhcmdlIGRlZmF1bHQgbnVtYmVyIG9mIGNvbHVtbnMKCSAqIFdlJ2xsIGF1dG9tYXRpY2FsbHkgZ3JvdyBjb2x1bW5zIGxhdGVyIGlmIHdlIG5lZWQgbW9yZSByb29tLgoJICovCglncmFwaC0+Y29sdW1uX2NhcGFjaXR5ID0gMzA7CglBTExPQ19BUlJBWShncmFwaC0+Y29sdW1ucywgZ3JhcGgtPmNvbHVtbl9jYXBhY2l0eSk7CglBTExPQ19BUlJBWShncmFwaC0+bmV3X2NvbHVtbnMsIGdyYXBoLT5jb2x1bW5fY2FwYWNpdHkpOwoJQUxMT0NfQVJSQVkoZ3JhcGgtPm1hcHBpbmcsIDIgKiBncmFwaC0+Y29sdW1uX2NhcGFjaXR5KTsKCUFMTE9DX0FSUkFZKGdyYXBoLT5uZXdfbWFwcGluZywgMiAqIGdyYXBoLT5jb2x1bW5fY2FwYWNpdHkpOwoKCS8qCgkgKiBUaGUgZGlmZiBvdXRwdXQgcHJlZml4IGNhbGxiYWNrLCB3aXRoIHRoaXMgd2UgY2FuIG1ha2UKCSAqIGFsbCB0aGUgZGlmZiBvdXRwdXQgdG8gYWxpZ24gd2l0aCB0aGUgZ3JhcGggbGluZXMuCgkgKi8KCW9wdC0+ZGlmZm9wdC5vdXRwdXRfcHJlZml4ID0gZGlmZl9vdXRwdXRfcHJlZml4X2NhbGxiYWNrOwoJb3B0LT5kaWZmb3B0Lm91dHB1dF9wcmVmaXhfZGF0YSA9IGdyYXBoOwoJb3B0LT5kaWZmb3B0Lm91dHB1dF9wcmVmaXhfbGVuZ3RoID0gMDsKCglyZXR1cm4gZ3JhcGg7Cn0KCnN0YXRpYyB2b2lkIGdyYXBoX3VwZGF0ZV9zdGF0ZShzdHJ1Y3QgZ2l0X2dyYXBoICpncmFwaCwgZW51bSBncmFwaF9zdGF0ZSBzKQp7CglncmFwaC0+cHJldl9zdGF0ZSA9IGdyYXBoLT5zdGF0ZTsKCWdyYXBoLT5zdGF0ZSA9IHM7Cn0KCnN0YXRpYyB2b2lkIGdyYXBoX2Vuc3VyZV9jYXBhY2l0eShzdHJ1Y3QgZ2l0X2dyYXBoICpncmFwaCwgaW50IG51bV9jb2x1bW5zKQp7CglpZiAoZ3JhcGgtPmNvbHVtbl9jYXBhY2l0eSA+PSBudW1fY29sdW1ucykKCQlyZXR1cm47CgoJZG8gewoJCWdyYXBoLT5jb2x1bW5fY2FwYWNpdHkgKj0gMjsKCX0gd2hpbGUgKGdyYXBoLT5jb2x1bW5fY2FwYWNpdHkgPCBudW1fY29sdW1ucyk7CgoJUkVBTExPQ19BUlJBWShncmFwaC0+Y29sdW1ucywgZ3JhcGgtPmNvbHVtbl9jYXBhY2l0eSk7CglSRUFMTE9DX0FSUkFZKGdyYXBoLT5uZXdfY29sdW1ucywgZ3JhcGgtPmNvbHVtbl9jYXBhY2l0eSk7CglSRUFMTE9DX0FSUkFZKGdyYXBoLT5tYXBwaW5nLCBncmFwaC0+Y29sdW1uX2NhcGFjaXR5ICogMik7CglSRUFMTE9DX0FSUkFZKGdyYXBoLT5uZXdfbWFwcGluZywgZ3JhcGgtPmNvbHVtbl9jYXBhY2l0eSAqIDIpOwp9CgovKgogKiBSZXR1cm5zIDEgaWYgdGhlIGNvbW1pdCB3aWxsIGJlIHByaW50ZWQgaW4gdGhlIGdyYXBoIG91dHB1dCwKICogYW5kIDAgb3RoZXJ3aXNlLgogKi8Kc3RhdGljIGludCBncmFwaF9pc19pbnRlcmVzdGluZyhzdHJ1Y3QgZ2l0X2dyYXBoICpncmFwaCwgc3RydWN0IGNvbW1pdCAqY29tbWl0KQp7CgkvKgoJICogSWYgcmV2cy0+Ym91bmRhcnkgaXMgc2V0LCBjb21taXRzIHdob3NlIGNoaWxkcmVuIGhhdmUKCSAqIGJlZW4gc2hvd24gYXJlIGFsd2F5cyBpbnRlcmVzdGluZywgZXZlbiBpZiB0aGV5IGhhdmUgdGhlCgkgKiBVTklOVEVSRVNUSU5HIG9yIFRSRUVTQU1FIGZsYWdzIHNldC4KCSAqLwoJaWYgKGdyYXBoLT5yZXZzICYmIGdyYXBoLT5yZXZzLT5ib3VuZGFyeSkgewoJCWlmIChjb21taXQtPm9iamVjdC5mbGFncyAmIENISUxEX1NIT1dOKQoJCQlyZXR1cm4gMTsKCX0KCgkvKgoJICogT3RoZXJ3aXNlLCB1c2UgZ2V0X2NvbW1pdF9hY3Rpb24oKSB0byBzZWUgaWYgdGhpcyBjb21taXQgaXMKCSAqIGludGVyZXN0aW5nCgkgKi8KCXJldHVybiBnZXRfY29tbWl0X2FjdGlvbihncmFwaC0+cmV2cywgY29tbWl0KSA9PSBjb21taXRfc2hvdzsKfQoKc3RhdGljIHN0cnVjdCBjb21taXRfbGlzdCAqbmV4dF9pbnRlcmVzdGluZ19wYXJlbnQoc3RydWN0IGdpdF9ncmFwaCAqZ3JhcGgsCgkJCQkJCSAgIHN0cnVjdCBjb21taXRfbGlzdCAqb3JpZykKewoJc3RydWN0IGNvbW1pdF9saXN0ICpsaXN0OwoKCS8qCgkgKiBJZiByZXZzLT5maXJzdF9wYXJlbnRfb25seSBpcyBzZXQsIG9ubHkgdGhlIGZpcnN0CgkgKiBwYXJlbnQgaXMgaW50ZXJlc3RpbmcuICBOb25lIG9mIHRoZSBvdGhlcnMgYXJlLgoJICovCglpZiAoZ3JhcGgtPnJldnMtPmZpcnN0X3BhcmVudF9vbmx5KQoJCXJldHVybiBOVUxMOwoKCS8qCgkgKiBSZXR1cm4gdGhlIG5leHQgaW50ZXJlc3RpbmcgY29tbWl0IGFmdGVyIG9yaWcKCSAqLwoJZm9yIChsaXN0ID0gb3JpZy0+bmV4dDsgbGlzdDsgbGlzdCA9IGxpc3QtPm5leHQpIHsKCQlpZiAoZ3JhcGhfaXNfaW50ZXJlc3RpbmcoZ3JhcGgsIGxpc3QtPml0ZW0pKQoJCQlyZXR1cm4gbGlzdDsKCX0KCglyZXR1cm4gTlVMTDsKfQoKc3RhdGljIHN0cnVjdCBjb21taXRfbGlzdCAqZmlyc3RfaW50ZXJlc3RpbmdfcGFyZW50KHN0cnVjdCBnaXRfZ3JhcGggKmdyYXBoKQp7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKnBhcmVudHMgPSBncmFwaC0+Y29tbWl0LT5wYXJlbnRzOwoKCS8qCgkgKiBJZiB0aGlzIGNvbW1pdCBoYXMgbm8gcGFyZW50cywgaWdub3JlIGl0CgkgKi8KCWlmICghcGFyZW50cykKCQlyZXR1cm4gTlVMTDsKCgkvKgoJICogSWYgdGhlIGZpcnN0IHBhcmVudCBpcyBpbnRlcmVzdGluZywgcmV0dXJuIGl0CgkgKi8KCWlmIChncmFwaF9pc19pbnRlcmVzdGluZyhncmFwaCwgcGFyZW50cy0+aXRlbSkpCgkJcmV0dXJuIHBhcmVudHM7CgoJLyoKCSAqIE90aGVyd2lzZSwgY2FsbCBuZXh0X2ludGVyZXN0aW5nX3BhcmVudCgpIHRvIGdldAoJICogdGhlIG5leHQgaW50ZXJlc3RpbmcgcGFyZW50CgkgKi8KCXJldHVybiBuZXh0X2ludGVyZXN0aW5nX3BhcmVudChncmFwaCwgcGFyZW50cyk7Cn0KCnN0YXRpYyB1bnNpZ25lZCBzaG9ydCBncmFwaF9nZXRfY3VycmVudF9jb2x1bW5fY29sb3IoY29uc3Qgc3RydWN0IGdpdF9ncmFwaCAqZ3JhcGgpCnsKCWlmICghd2FudF9jb2xvcihncmFwaC0+cmV2cy0+ZGlmZm9wdC51c2VfY29sb3IpKQoJCXJldHVybiBjb2x1bW5fY29sb3JzX21heDsKCXJldHVybiBncmFwaC0+ZGVmYXVsdF9jb2x1bW5fY29sb3I7Cn0KCi8qCiAqIFVwZGF0ZSB0aGUgZ3JhcGgncyBkZWZhdWx0IGNvbHVtbiBjb2xvci4KICovCnN0YXRpYyB2b2lkIGdyYXBoX2luY3JlbWVudF9jb2x1bW5fY29sb3Ioc3RydWN0IGdpdF9ncmFwaCAqZ3JhcGgpCnsKCWdyYXBoLT5kZWZhdWx0X2NvbHVtbl9jb2xvciA9IChncmFwaC0+ZGVmYXVsdF9jb2x1bW5fY29sb3IgKyAxKSAlCgkJY29sdW1uX2NvbG9yc19tYXg7Cn0KCnN0YXRpYyB1bnNpZ25lZCBzaG9ydCBncmFwaF9maW5kX2NvbW1pdF9jb2xvcihjb25zdCBzdHJ1Y3QgZ2l0X2dyYXBoICpncmFwaCwKCQkJCQkgICAgICBjb25zdCBzdHJ1Y3QgY29tbWl0ICpjb21taXQpCnsKCWludCBpOwoJZm9yIChpID0gMDsgaSA8IGdyYXBoLT5udW1fY29sdW1uczsgaSsrKSB7CgkJaWYgKGdyYXBoLT5jb2x1bW5zW2ldLmNvbW1pdCA9PSBjb21taXQpCgkJCXJldHVybiBncmFwaC0+Y29sdW1uc1tpXS5jb2xvcjsKCX0KCXJldHVybiBncmFwaF9nZXRfY3VycmVudF9jb2x1bW5fY29sb3IoZ3JhcGgpOwp9CgpzdGF0aWMgdm9pZCBncmFwaF9pbnNlcnRfaW50b19uZXdfY29sdW1ucyhzdHJ1Y3QgZ2l0X2dyYXBoICpncmFwaCwKCQkJCQkgIHN0cnVjdCBjb21taXQgKmNvbW1pdCwKCQkJCQkgIGludCAqbWFwcGluZ19pbmRleCkKewoJaW50IGk7CgoJLyoKCSAqIElmIHRoZSBjb21taXQgaXMgYWxyZWFkeSBpbiB0aGUgbmV3X2NvbHVtbnMgbGlzdCwgd2UgZG9uJ3QgbmVlZCB0bwoJICogYWRkIGl0LiAgSnVzdCB1cGRhdGUgdGhlIG1hcHBpbmcgY29ycmVjdGx5LgoJICovCglmb3IgKGkgPSAwOyBpIDwgZ3JhcGgtPm51bV9uZXdfY29sdW1uczsgaSsrKSB7CgkJaWYgKGdyYXBoLT5uZXdfY29sdW1uc1tpXS5jb21taXQgPT0gY29tbWl0KSB7CgkJCWdyYXBoLT5tYXBwaW5nWyptYXBwaW5nX2luZGV4XSA9IGk7CgkJCSptYXBwaW5nX2luZGV4ICs9IDI7CgkJCXJldHVybjsKCQl9Cgl9CgoJLyoKCSAqIFRoaXMgY29tbWl0IGlzbid0IGFscmVhZHkgaW4gbmV3X2NvbHVtbnMuICBBZGQgaXQuCgkgKi8KCWdyYXBoLT5uZXdfY29sdW1uc1tncmFwaC0+bnVtX25ld19jb2x1bW5zXS5jb21taXQgPSBjb21taXQ7CglncmFwaC0+bmV3X2NvbHVtbnNbZ3JhcGgtPm51bV9uZXdfY29sdW1uc10uY29sb3IgPSBncmFwaF9maW5kX2NvbW1pdF9jb2xvcihncmFwaCwgY29tbWl0KTsKCWdyYXBoLT5tYXBwaW5nWyptYXBwaW5nX2luZGV4XSA9IGdyYXBoLT5udW1fbmV3X2NvbHVtbnM7CgkqbWFwcGluZ19pbmRleCArPSAyOwoJZ3JhcGgtPm51bV9uZXdfY29sdW1ucysrOwp9CgpzdGF0aWMgdm9pZCBncmFwaF91cGRhdGVfd2lkdGgoc3RydWN0IGdpdF9ncmFwaCAqZ3JhcGgsCgkJCSAgICAgICBpbnQgaXNfY29tbWl0X2luX2V4aXN0aW5nX2NvbHVtbnMpCnsKCS8qCgkgKiBDb21wdXRlIHRoZSB3aWR0aCBuZWVkZWQgdG8gZGlzcGxheSB0aGUgZ3JhcGggZm9yIHRoaXMgY29tbWl0LgoJICogVGhpcyBpcyB0aGUgbWF4aW11bSB3aWR0aCBuZWVkZWQgZm9yIGFueSByb3cuICBBbGwgb3RoZXIgcm93cwoJICogd2lsbCBiZSBwYWRkZWQgdG8gdGhpcyB3aWR0aC4KCSAqCgkgKiBDb21wdXRlIHRoZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgd2lkZXN0IHJvdzoKCSAqIENvdW50IGVhY2ggZXhpc3RpbmcgY29sdW1uIChncmFwaC0+bnVtX2NvbHVtbnMpLCBhbmQgZWFjaCBuZXcKCSAqIGNvbHVtbiBhZGRlZCBieSB0aGlzIGNvbW1pdC4KCSAqLwoJaW50IG1heF9jb2xzID0gZ3JhcGgtPm51bV9jb2x1bW5zICsgZ3JhcGgtPm51bV9wYXJlbnRzOwoKCS8qCgkgKiBFdmVuIGlmIHRoZSBjdXJyZW50IGNvbW1pdCBoYXMgbm8gcGFyZW50cyB0byBiZSBwcmludGVkLCBpdAoJICogc3RpbGwgdGFrZXMgdXAgYSBjb2x1bW4gZm9yIGl0c2VsZi4KCSAqLwoJaWYgKGdyYXBoLT5udW1fcGFyZW50cyA8IDEpCgkJbWF4X2NvbHMrKzsKCgkvKgoJICogV2UgYWRkZWQgYSBjb2x1bW4gZm9yIHRoZSBjdXJyZW50IGNvbW1pdCBhcyBwYXJ0IG9mCgkgKiBncmFwaC0+bnVtX3BhcmVudHMuICBJZiB0aGUgY3VycmVudCBjb21taXQgd2FzIGFscmVhZHkgaW4KCSAqIGdyYXBoLT5jb2x1bW5zLCB0aGVuIHdlIGhhdmUgZG91YmxlIGNvdW50ZWQgaXQuCgkgKi8KCWlmIChpc19jb21taXRfaW5fZXhpc3RpbmdfY29sdW1ucykKCQltYXhfY29scy0tOwoKCS8qCgkgKiBFYWNoIGNvbHVtbiB0YWtlcyB1cCAyIHNwYWNlcwoJICovCglncmFwaC0+d2lkdGggPSBtYXhfY29scyAqIDI7Cn0KCnN0YXRpYyB2b2lkIGdyYXBoX3VwZGF0ZV9jb2x1bW5zKHN0cnVjdCBnaXRfZ3JhcGggKmdyYXBoKQp7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKnBhcmVudDsKCXN0cnVjdCBjb2x1bW4gKnRtcF9jb2x1bW5zOwoJaW50IG1heF9uZXdfY29sdW1uczsKCWludCBtYXBwaW5nX2lkeDsKCWludCBpLCBzZWVuX3RoaXMsIGlzX2NvbW1pdF9pbl9jb2x1bW5zOwoKCS8qCgkgKiBTd2FwIGdyYXBoLT5jb2x1bW5zIHdpdGggZ3JhcGgtPm5ld19jb2x1bW5zCgkgKiBncmFwaC0+Y29sdW1ucyBjb250YWlucyB0aGUgc3RhdGUgZm9yIHRoZSBwcmV2aW91cyBjb21taXQsCgkgKiBhbmQgbmV3X2NvbHVtbnMgbm93IGNvbnRhaW5zIHRoZSBzdGF0ZSBmb3Igb3VyIGNvbW1pdC4KCSAqCgkgKiBXZSdsbCByZS11c2UgdGhlIG9sZCBjb2x1bW5zIGFycmF5IGFzIHN0b3JhZ2UgdG8gY29tcHV0ZSB0aGUgbmV3CgkgKiBjb2x1bW5zIGxpc3QgZm9yIHRoZSBjb21taXQgYWZ0ZXIgdGhpcyBvbmUuCgkgKi8KCXRtcF9jb2x1bW5zID0gZ3JhcGgtPmNvbHVtbnM7CglncmFwaC0+Y29sdW1ucyA9IGdyYXBoLT5uZXdfY29sdW1uczsKCWdyYXBoLT5udW1fY29sdW1ucyA9IGdyYXBoLT5udW1fbmV3X2NvbHVtbnM7CgoJZ3JhcGgtPm5ld19jb2x1bW5zID0gdG1wX2NvbHVtbnM7CglncmFwaC0+bnVtX25ld19jb2x1bW5zID0gMDsKCgkvKgoJICogTm93IHVwZGF0ZSBuZXdfY29sdW1ucyBhbmQgbWFwcGluZyB3aXRoIHRoZSBpbmZvcm1hdGlvbiBmb3IgdGhlCgkgKiBjb21taXQgYWZ0ZXIgdGhpcyBvbmUuCgkgKgoJICogRmlyc3QsIG1ha2Ugc3VyZSB3ZSBoYXZlIGVub3VnaCByb29tLiAgQXQgbW9zdCwgdGhlcmUgd2lsbAoJICogYmUgZ3JhcGgtPm51bV9jb2x1bW5zICsgZ3JhcGgtPm51bV9wYXJlbnRzIGNvbHVtbnMgZm9yIHRoZSBuZXh0CgkgKiBjb21taXQuCgkgKi8KCW1heF9uZXdfY29sdW1ucyA9IGdyYXBoLT5udW1fY29sdW1ucyArIGdyYXBoLT5udW1fcGFyZW50czsKCWdyYXBoX2Vuc3VyZV9jYXBhY2l0eShncmFwaCwgbWF4X25ld19jb2x1bW5zKTsKCgkvKgoJICogQ2xlYXIgb3V0IGdyYXBoLT5tYXBwaW5nCgkgKi8KCWdyYXBoLT5tYXBwaW5nX3NpemUgPSAyICogbWF4X25ld19jb2x1bW5zOwoJZm9yIChpID0gMDsgaSA8IGdyYXBoLT5tYXBwaW5nX3NpemU7IGkrKykKCQlncmFwaC0+bWFwcGluZ1tpXSA9IC0xOwoKCS8qCgkgKiBQb3B1bGF0ZSBncmFwaC0+bmV3X2NvbHVtbnMgYW5kIGdyYXBoLT5tYXBwaW5nCgkgKgoJICogU29tZSBvZiB0aGUgcGFyZW50cyBvZiB0aGlzIGNvbW1pdCBtYXkgYWxyZWFkeSBiZSBpbgoJICogZ3JhcGgtPmNvbHVtbnMuICBJZiBzbywgZ3JhcGgtPm5ld19jb2x1bW5zIHNob3VsZCBvbmx5IGNvbnRhaW4gYQoJICogc2luZ2xlIGVudHJ5IGZvciBlYWNoIHN1Y2ggY29tbWl0LiAgZ3JhcGgtPm1hcHBpbmcgc2hvdWxkCgkgKiBjb250YWluIGluZm9ybWF0aW9uIGFib3V0IHdoZXJlIGVhY2ggY3VycmVudCBicmFuY2ggbGluZSBpcwoJICogc3VwcG9zZWQgdG8gZW5kIHVwIGFmdGVyIHRoZSBjb2xsYXBzaW5nIGlzIHBlcmZvcm1lZC4KCSAqLwoJc2Vlbl90aGlzID0gMDsKCW1hcHBpbmdfaWR4ID0gMDsKCWlzX2NvbW1pdF9pbl9jb2x1bW5zID0gMTsKCWZvciAoaSA9IDA7IGkgPD0gZ3JhcGgtPm51bV9jb2x1bW5zOyBpKyspIHsKCQlzdHJ1Y3QgY29tbWl0ICpjb2xfY29tbWl0OwoJCWlmIChpID09IGdyYXBoLT5udW1fY29sdW1ucykgewoJCQlpZiAoc2Vlbl90aGlzKQoJCQkJYnJlYWs7CgkJCWlzX2NvbW1pdF9pbl9jb2x1bW5zID0gMDsKCQkJY29sX2NvbW1pdCA9IGdyYXBoLT5jb21taXQ7CgkJfSBlbHNlIHsKCQkJY29sX2NvbW1pdCA9IGdyYXBoLT5jb2x1bW5zW2ldLmNvbW1pdDsKCQl9CgoJCWlmIChjb2xfY29tbWl0ID09IGdyYXBoLT5jb21taXQpIHsKCQkJaW50IG9sZF9tYXBwaW5nX2lkeCA9IG1hcHBpbmdfaWR4OwoJCQlzZWVuX3RoaXMgPSAxOwoJCQlncmFwaC0+Y29tbWl0X2luZGV4ID0gaTsKCQkJZm9yIChwYXJlbnQgPSBmaXJzdF9pbnRlcmVzdGluZ19wYXJlbnQoZ3JhcGgpOwoJCQkgICAgIHBhcmVudDsKCQkJICAgICBwYXJlbnQgPSBuZXh0X2ludGVyZXN0aW5nX3BhcmVudChncmFwaCwgcGFyZW50KSkgewoJCQkJLyoKCQkJCSAqIElmIHRoaXMgaXMgYSBtZXJnZSwgb3IgdGhlIHN0YXJ0IG9mIGEgbmV3CgkJCQkgKiBjaGlsZGxlc3MgY29sdW1uLCBpbmNyZW1lbnQgdGhlIGN1cnJlbnQKCQkJCSAqIGNvbG9yLgoJCQkJICovCgkJCQlpZiAoZ3JhcGgtPm51bV9wYXJlbnRzID4gMSB8fAoJCQkJICAgICFpc19jb21taXRfaW5fY29sdW1ucykgewoJCQkJCWdyYXBoX2luY3JlbWVudF9jb2x1bW5fY29sb3IoZ3JhcGgpOwoJCQkJfQoJCQkJZ3JhcGhfaW5zZXJ0X2ludG9fbmV3X2NvbHVtbnMoZ3JhcGgsCgkJCQkJCQkgICAgICBwYXJlbnQtPml0ZW0sCgkJCQkJCQkgICAgICAmbWFwcGluZ19pZHgpOwoJCQl9CgkJCS8qCgkJCSAqIFdlIGFsd2F5cyBuZWVkIHRvIGluY3JlbWVudCBtYXBwaW5nX2lkeCBieSBhdAoJCQkgKiBsZWFzdCAyLCBldmVuIGlmIGl0IGhhcyBubyBpbnRlcmVzdGluZyBwYXJlbnRzLgoJCQkgKiBUaGUgY3VycmVudCBjb21taXQgYWx3YXlzIHRha2VzIHVwIGF0IGxlYXN0IDIKCQkJICogc3BhY2VzLgoJCQkgKi8KCQkJaWYgKG1hcHBpbmdfaWR4ID09IG9sZF9tYXBwaW5nX2lkeCkKCQkJCW1hcHBpbmdfaWR4ICs9IDI7CgkJfSBlbHNlIHsKCQkJZ3JhcGhfaW5zZXJ0X2ludG9fbmV3X2NvbHVtbnMoZ3JhcGgsIGNvbF9jb21taXQsCgkJCQkJCSAgICAgICZtYXBwaW5nX2lkeCk7CgkJfQoJfQoKCS8qCgkgKiBTaHJpbmsgbWFwcGluZ19zaXplIHRvIGJlIHRoZSBtaW5pbXVtIG5lY2Vzc2FyeQoJICovCgl3aGlsZSAoZ3JhcGgtPm1hcHBpbmdfc2l6ZSA+IDEgJiYKCSAgICAgICBncmFwaC0+bWFwcGluZ1tncmFwaC0+bWFwcGluZ19zaXplIC0gMV0gPCAwKQoJCWdyYXBoLT5tYXBwaW5nX3NpemUtLTsKCgkvKgoJICogQ29tcHV0ZSBncmFwaC0+d2lkdGggZm9yIHRoaXMgY29tbWl0CgkgKi8KCWdyYXBoX3VwZGF0ZV93aWR0aChncmFwaCwgaXNfY29tbWl0X2luX2NvbHVtbnMpOwp9Cgp2b2lkIGdyYXBoX3VwZGF0ZShzdHJ1Y3QgZ2l0X2dyYXBoICpncmFwaCwgc3RydWN0IGNvbW1pdCAqY29tbWl0KQp7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKnBhcmVudDsKCgkvKgoJICogU2V0IHRoZSBuZXcgY29tbWl0CgkgKi8KCWdyYXBoLT5jb21taXQgPSBjb21taXQ7CgoJLyoKCSAqIENvdW50IGhvdyBtYW55IGludGVyZXN0aW5nIHBhcmVudHMgdGhpcyBjb21taXQgaGFzCgkgKi8KCWdyYXBoLT5udW1fcGFyZW50cyA9IDA7Cglmb3IgKHBhcmVudCA9IGZpcnN0X2ludGVyZXN0aW5nX3BhcmVudChncmFwaCk7CgkgICAgIHBhcmVudDsKCSAgICAgcGFyZW50ID0gbmV4dF9pbnRlcmVzdGluZ19wYXJlbnQoZ3JhcGgsIHBhcmVudCkpCgl7CgkJZ3JhcGgtPm51bV9wYXJlbnRzKys7Cgl9CgoJLyoKCSAqIFN0b3JlIHRoZSBvbGQgY29tbWl0X2luZGV4IGluIHByZXZfY29tbWl0X2luZGV4LgoJICogZ3JhcGhfdXBkYXRlX2NvbHVtbnMoKSB3aWxsIHVwZGF0ZSBncmFwaC0+Y29tbWl0X2luZGV4IGZvciB0aGlzCgkgKiBjb21taXQuCgkgKi8KCWdyYXBoLT5wcmV2X2NvbW1pdF9pbmRleCA9IGdyYXBoLT5jb21taXRfaW5kZXg7CgoJLyoKCSAqIENhbGwgZ3JhcGhfdXBkYXRlX2NvbHVtbnMoKSB0byB1cGRhdGUKCSAqIGNvbHVtbnMsIG5ld19jb2x1bW5zLCBhbmQgbWFwcGluZy4KCSAqLwoJZ3JhcGhfdXBkYXRlX2NvbHVtbnMoZ3JhcGgpOwoKCWdyYXBoLT5leHBhbnNpb25fcm93ID0gMDsKCgkvKgoJICogVXBkYXRlIGdyYXBoLT5zdGF0ZS4KCSAqIE5vdGUgdGhhdCB3ZSBkb24ndCBjYWxsIGdyYXBoX3VwZGF0ZV9zdGF0ZSgpIGhlcmUsIHNpbmNlCgkgKiB3ZSBkb24ndCB3YW50IHRvIHVwZGF0ZSBncmFwaC0+cHJldl9zdGF0ZS4gIE5vIGxpbmUgZm9yCgkgKiBncmFwaC0+c3RhdGUgd2FzIGV2ZXIgcHJpbnRlZC4KCSAqCgkgKiBJZiB0aGUgcHJldmlvdXMgY29tbWl0IGRpZG4ndCBnZXQgdG8gdGhlIEdSQVBIX1BBRERJTkcgc3RhdGUsCgkgKiBpdCBuZXZlciBmaW5pc2hlZCBpdHMgb3V0cHV0LiAgR290byBHUkFQSF9TS0lQLCB0byBwcmludCBvdXQKCSAqIGEgbGluZSB0byBpbmRpY2F0ZSB0aGF0IHBvcnRpb24gb2YgdGhlIGdyYXBoIGlzIG1pc3NpbmcuCgkgKgoJICogSWYgdGhlcmUgYXJlIDMgb3IgbW9yZSBwYXJlbnRzLCB3ZSBtYXkgbmVlZCB0byBwcmludCBleHRyYSByb3dzCgkgKiBiZWZvcmUgdGhlIGNvbW1pdCwgdG8gZXhwYW5kIHRoZSBicmFuY2ggbGluZXMgYXJvdW5kIGl0IGFuZCBtYWtlCgkgKiByb29tIGZvciBpdC4gIFdlIG5lZWQgdG8gZG8gdGhpcyBvbmx5IGlmIHRoZXJlIGlzIGEgYnJhbmNoIHJvdwoJICogKG9yIG1vcmUpIHRvIHRoZSByaWdodCBvZiB0aGlzIGNvbW1pdC4KCSAqCgkgKiBJZiB0aGVyZSBhcmUgbGVzcyB0aGFuIDMgcGFyZW50cywgd2UgY2FuIGltbWVkaWF0ZWx5IHByaW50IHRoZQoJICogY29tbWl0IGxpbmUuCgkgKi8KCWlmIChncmFwaC0+c3RhdGUgIT0gR1JBUEhfUEFERElORykKCQlncmFwaC0+c3RhdGUgPSBHUkFQSF9TS0lQOwoJZWxzZSBpZiAoZ3JhcGgtPm51bV9wYXJlbnRzID49IDMgJiYKCQkgZ3JhcGgtPmNvbW1pdF9pbmRleCA8IChncmFwaC0+bnVtX2NvbHVtbnMgLSAxKSkKCQlncmFwaC0+c3RhdGUgPSBHUkFQSF9QUkVfQ09NTUlUOwoJZWxzZQoJCWdyYXBoLT5zdGF0ZSA9IEdSQVBIX0NPTU1JVDsKfQoKc3RhdGljIGludCBncmFwaF9pc19tYXBwaW5nX2NvcnJlY3Qoc3RydWN0IGdpdF9ncmFwaCAqZ3JhcGgpCnsKCWludCBpOwoKCS8qCgkgKiBUaGUgbWFwcGluZyBpcyB1cCB0byBkYXRlIGlmIGVhY2ggZW50cnkgaXMgYXQgaXRzIHRhcmdldCwKCSAqIG9yIGlzIDEgZ3JlYXRlciB0aGFuIGl0cyB0YXJnZXQuCgkgKiAoSWYgaXQgaXMgMSBncmVhdGVyIHRoYW4gdGhlIHRhcmdldCwgJy8nIHdpbGwgYmUgcHJpbnRlZCwgc28gaXQKCSAqIHdpbGwgbG9vayBjb3JyZWN0IG9uIHRoZSBuZXh0IHJvdy4pCgkgKi8KCWZvciAoaSA9IDA7IGkgPCBncmFwaC0+bWFwcGluZ19zaXplOyBpKyspIHsKCQlpbnQgdGFyZ2V0ID0gZ3JhcGgtPm1hcHBpbmdbaV07CgkJaWYgKHRhcmdldCA8IDApCgkJCWNvbnRpbnVlOwoJCWlmICh0YXJnZXQgPT0gKGkgLyAyKSkKCQkJY29udGludWU7CgkJcmV0dXJuIDA7Cgl9CgoJcmV0dXJuIDE7Cn0KCnN0YXRpYyB2b2lkIGdyYXBoX3BhZF9ob3Jpem9udGFsbHkoc3RydWN0IGdpdF9ncmFwaCAqZ3JhcGgsIHN0cnVjdCBzdHJidWYgKnNiLAoJCQkJICAgaW50IGNoYXJzX3dyaXR0ZW4pCnsKCS8qCgkgKiBBZGQgYWRkaXRpb25hbCBzcGFjZXMgdG8gdGhlIGVuZCBvZiB0aGUgc3RyYnVmLCBzbyB0aGF0IGFsbAoJICogbGluZXMgZm9yIGEgcGFydGljdWxhciBjb21taXQgaGF2ZSB0aGUgc2FtZSB3aWR0aC4KCSAqCgkgKiBUaGlzIHdheSwgZmllbGRzIHByaW50ZWQgdG8gdGhlIHJpZ2h0IG9mIHRoZSBncmFwaCB3aWxsIHJlbWFpbgoJICogYWxpZ25lZCBmb3IgdGhlIGVudGlyZSBjb21taXQuCgkgKi8KCWludCBleHRyYTsKCWlmIChjaGFyc193cml0dGVuID49IGdyYXBoLT53aWR0aCkKCQlyZXR1cm47CgoJZXh0cmEgPSBncmFwaC0+d2lkdGggLSBjaGFyc193cml0dGVuOwoJc3RyYnVmX2FkZGYoc2IsICIlKnMiLCAoaW50KSBleHRyYSwgIiIpOwp9CgpzdGF0aWMgdm9pZCBncmFwaF9vdXRwdXRfcGFkZGluZ19saW5lKHN0cnVjdCBnaXRfZ3JhcGggKmdyYXBoLAoJCQkJICAgICAgc3RydWN0IHN0cmJ1ZiAqc2IpCnsKCWludCBpOwoKCS8qCgkgKiBXZSBjb3VsZCBjb25jZWl2YWJsZSBiZSBjYWxsZWQgd2l0aCBhIE5VTEwgY29tbWl0CgkgKiBpZiBvdXIgY2FsbGVyIGhhcyBhIGJ1ZywgYW5kIGludm9rZXMgZ3JhcGhfbmV4dF9saW5lKCkKCSAqIGltbWVkaWF0ZWx5IGFmdGVyIGdyYXBoX2luaXQoKSwgd2l0aG91dCBmaXJzdCBjYWxsaW5nCgkgKiBncmFwaF91cGRhdGUoKS4gIFJldHVybiB3aXRob3V0IG91dHB1dHRpbmcgYW55dGhpbmcgaW4gdGhpcwoJICogY2FzZS4KCSAqLwoJaWYgKCFncmFwaC0+Y29tbWl0KQoJCXJldHVybjsKCgkvKgoJICogT3V0cHV0IGEgcGFkZGluZyByb3csIHRoYXQgbGVhdmVzIGFsbCBicmFuY2ggbGluZXMgdW5jaGFuZ2VkCgkgKi8KCWZvciAoaSA9IDA7IGkgPCBncmFwaC0+bnVtX25ld19jb2x1bW5zOyBpKyspIHsKCQlzdHJidWZfd3JpdGVfY29sdW1uKHNiLCAmZ3JhcGgtPm5ld19jb2x1bW5zW2ldLCAnfCcpOwoJCXN0cmJ1Zl9hZGRjaChzYiwgJyAnKTsKCX0KCglncmFwaF9wYWRfaG9yaXpvbnRhbGx5KGdyYXBoLCBzYiwgZ3JhcGgtPm51bV9uZXdfY29sdW1ucyAqIDIpOwp9CgoKaW50IGdyYXBoX3dpZHRoKHN0cnVjdCBnaXRfZ3JhcGggKmdyYXBoKQp7CglyZXR1cm4gZ3JhcGgtPndpZHRoOwp9CgoKc3RhdGljIHZvaWQgZ3JhcGhfb3V0cHV0X3NraXBfbGluZShzdHJ1Y3QgZ2l0X2dyYXBoICpncmFwaCwgc3RydWN0IHN0cmJ1ZiAqc2IpCnsKCS8qCgkgKiBPdXRwdXQgYW4gZWxsaXBzaXMgdG8gaW5kaWNhdGUgdGhhdCBhIHBvcnRpb24KCSAqIG9mIHRoZSBncmFwaCBpcyBtaXNzaW5nLgoJICovCglzdHJidWZfYWRkc3RyKHNiLCAiLi4uIik7CglncmFwaF9wYWRfaG9yaXpvbnRhbGx5KGdyYXBoLCBzYiwgMyk7CgoJaWYgKGdyYXBoLT5udW1fcGFyZW50cyA+PSAzICYmCgkgICAgZ3JhcGgtPmNvbW1pdF9pbmRleCA8IChncmFwaC0+bnVtX2NvbHVtbnMgLSAxKSkKCQlncmFwaF91cGRhdGVfc3RhdGUoZ3JhcGgsIEdSQVBIX1BSRV9DT01NSVQpOwoJZWxzZQoJCWdyYXBoX3VwZGF0ZV9zdGF0ZShncmFwaCwgR1JBUEhfQ09NTUlUKTsKfQoKc3RhdGljIHZvaWQgZ3JhcGhfb3V0cHV0X3ByZV9jb21taXRfbGluZShzdHJ1Y3QgZ2l0X2dyYXBoICpncmFwaCwKCQkJCQkgc3RydWN0IHN0cmJ1ZiAqc2IpCnsKCWludCBudW1fZXhwYW5zaW9uX3Jvd3M7CglpbnQgaSwgc2Vlbl90aGlzOwoJaW50IGNoYXJzX3dyaXR0ZW47CgoJLyoKCSAqIFRoaXMgZnVuY3Rpb24gZm9ybWF0cyBhIHJvdyB0aGF0IGluY3JlYXNlcyB0aGUgc3BhY2UgYXJvdW5kIGEgY29tbWl0CgkgKiB3aXRoIG11bHRpcGxlIHBhcmVudHMsIHRvIG1ha2Ugcm9vbSBmb3IgaXQuICBJdCBzaG91bGQgb25seSBiZQoJICogY2FsbGVkIHdoZW4gdGhlcmUgYXJlIDMgb3IgbW9yZSBwYXJlbnRzLgoJICoKCSAqIFdlIG5lZWQgMiBleHRyYSByb3dzIGZvciBldmVyeSBwYXJlbnQgb3ZlciAyLgoJICovCglhc3NlcnQoZ3JhcGgtPm51bV9wYXJlbnRzID49IDMpOwoJbnVtX2V4cGFuc2lvbl9yb3dzID0gKGdyYXBoLT5udW1fcGFyZW50cyAtIDIpICogMjsKCgkvKgoJICogZ3JhcGgtPmV4cGFuc2lvbl9yb3cgdHJhY2tzIHRoZSBjdXJyZW50IGV4cGFuc2lvbiByb3cgd2UgYXJlIG9uLgoJICogSXQgc2hvdWxkIGJlIGluIHRoZSByYW5nZSBbMCwgbnVtX2V4cGFuc2lvbl9yb3dzIC0gMV0KCSAqLwoJYXNzZXJ0KDAgPD0gZ3JhcGgtPmV4cGFuc2lvbl9yb3cgJiYKCSAgICAgICBncmFwaC0+ZXhwYW5zaW9uX3JvdyA8IG51bV9leHBhbnNpb25fcm93cyk7CgoJLyoKCSAqIE91dHB1dCB0aGUgcm93CgkgKi8KCXNlZW5fdGhpcyA9IDA7CgljaGFyc193cml0dGVuID0gMDsKCWZvciAoaSA9IDA7IGkgPCBncmFwaC0+bnVtX2NvbHVtbnM7IGkrKykgewoJCXN0cnVjdCBjb2x1bW4gKmNvbCA9ICZncmFwaC0+Y29sdW1uc1tpXTsKCQlpZiAoY29sLT5jb21taXQgPT0gZ3JhcGgtPmNvbW1pdCkgewoJCQlzZWVuX3RoaXMgPSAxOwoJCQlzdHJidWZfd3JpdGVfY29sdW1uKHNiLCBjb2wsICd8Jyk7CgkJCXN0cmJ1Zl9hZGRmKHNiLCAiJSpzIiwgZ3JhcGgtPmV4cGFuc2lvbl9yb3csICIiKTsKCQkJY2hhcnNfd3JpdHRlbiArPSAxICsgZ3JhcGgtPmV4cGFuc2lvbl9yb3c7CgkJfSBlbHNlIGlmIChzZWVuX3RoaXMgJiYgKGdyYXBoLT5leHBhbnNpb25fcm93ID09IDApKSB7CgkJCS8qCgkJCSAqIFRoaXMgaXMgdGhlIGZpcnN0IGxpbmUgb2YgdGhlIHByZS1jb21taXQgb3V0cHV0LgoJCQkgKiBJZiB0aGUgcHJldmlvdXMgY29tbWl0IHdhcyBhIG1lcmdlIGNvbW1pdCBhbmQKCQkJICogZW5kZWQgaW4gdGhlIEdSQVBIX1BPU1RfTUVSR0Ugc3RhdGUsIGFsbCBicmFuY2gKCQkJICogbGluZXMgYWZ0ZXIgZ3JhcGgtPnByZXZfY29tbWl0X2luZGV4IHdlcmUKCQkJICogcHJpbnRlZCBhcyAiXCIgb24gdGhlIHByZXZpb3VzIGxpbmUuICBDb250aW51ZQoJCQkgKiB0byBwcmludCB0aGVtIGFzICJcIiBvbiB0aGlzIGxpbmUuICBPdGhlcndpc2UsCgkJCSAqIHByaW50IHRoZSBicmFuY2ggbGluZXMgYXMgInwiLgoJCQkgKi8KCQkJaWYgKGdyYXBoLT5wcmV2X3N0YXRlID09IEdSQVBIX1BPU1RfTUVSR0UgJiYKCQkJICAgIGdyYXBoLT5wcmV2X2NvbW1pdF9pbmRleCA8IGkpCgkJCQlzdHJidWZfd3JpdGVfY29sdW1uKHNiLCBjb2wsICdcXCcpOwoJCQllbHNlCgkJCQlzdHJidWZfd3JpdGVfY29sdW1uKHNiLCBjb2wsICd8Jyk7CgkJCWNoYXJzX3dyaXR0ZW4rKzsKCQl9IGVsc2UgaWYgKHNlZW5fdGhpcyAmJiAoZ3JhcGgtPmV4cGFuc2lvbl9yb3cgPiAwKSkgewoJCQlzdHJidWZfd3JpdGVfY29sdW1uKHNiLCBjb2wsICdcXCcpOwoJCQljaGFyc193cml0dGVuKys7CgkJfSBlbHNlIHsKCQkJc3RyYnVmX3dyaXRlX2NvbHVtbihzYiwgY29sLCAnfCcpOwoJCQljaGFyc193cml0dGVuKys7CgkJfQoJCXN0cmJ1Zl9hZGRjaChzYiwgJyAnKTsKCQljaGFyc193cml0dGVuKys7Cgl9CgoJZ3JhcGhfcGFkX2hvcml6b250YWxseShncmFwaCwgc2IsIGNoYXJzX3dyaXR0ZW4pOwoKCS8qCgkgKiBJbmNyZW1lbnQgZ3JhcGgtPmV4cGFuc2lvbl9yb3csCgkgKiBhbmQgbW92ZSB0byBzdGF0ZSBHUkFQSF9DT01NSVQgaWYgbmVjZXNzYXJ5CgkgKi8KCWdyYXBoLT5leHBhbnNpb25fcm93Kys7CglpZiAoZ3JhcGgtPmV4cGFuc2lvbl9yb3cgPj0gbnVtX2V4cGFuc2lvbl9yb3dzKQoJCWdyYXBoX3VwZGF0ZV9zdGF0ZShncmFwaCwgR1JBUEhfQ09NTUlUKTsKfQoKc3RhdGljIHZvaWQgZ3JhcGhfb3V0cHV0X2NvbW1pdF9jaGFyKHN0cnVjdCBnaXRfZ3JhcGggKmdyYXBoLCBzdHJ1Y3Qgc3RyYnVmICpzYikKewoJLyoKCSAqIEZvciBib3VuZGFyeSBjb21taXRzLCBwcmludCAnbycKCSAqIChXZSBzaG91bGQgb25seSBzZWUgYm91bmRhcnkgY29tbWl0cyB3aGVuIHJldnMtPmJvdW5kYXJ5IGlzIHNldC4pCgkgKi8KCWlmIChncmFwaC0+Y29tbWl0LT5vYmplY3QuZmxhZ3MgJiBCT1VOREFSWSkgewoJCWFzc2VydChncmFwaC0+cmV2cy0+Ym91bmRhcnkpOwoJCXN0cmJ1Zl9hZGRjaChzYiwgJ28nKTsKCQlyZXR1cm47Cgl9CgoJLyoKCSAqIGdldF9yZXZpc2lvbl9tYXJrKCkgaGFuZGxlcyBhbGwgb3RoZXIgY2FzZXMgd2l0aG91dCBhc3NlcnQoKQoJICovCglzdHJidWZfYWRkc3RyKHNiLCBnZXRfcmV2aXNpb25fbWFyayhncmFwaC0+cmV2cywgZ3JhcGgtPmNvbW1pdCkpOwp9CgovKgogKiBEcmF3IGFuIG9jdG9wdXMgbWVyZ2UgYW5kIHJldHVybiB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgd3JpdHRlbi4KICovCnN0YXRpYyBpbnQgZ3JhcGhfZHJhd19vY3RvcHVzX21lcmdlKHN0cnVjdCBnaXRfZ3JhcGggKmdyYXBoLAoJCQkJICAgIHN0cnVjdCBzdHJidWYgKnNiKQp7CgkvKgoJICogSGVyZSBkYXNobGVzc19jb21taXRzIHJlcHJlc2VudHMgdGhlIG51bWJlciBvZiBwYXJlbnRzCgkgKiB3aGljaCBkb24ndCBuZWVkIHRvIGhhdmUgZGFzaGVzIChiZWNhdXNlIHRoZWlyIGVkZ2VzIGZpdAoJICogbmVhdGx5IHVuZGVyIHRoZSBjb21taXQpLgoJICovCgljb25zdCBpbnQgZGFzaGxlc3NfY29tbWl0cyA9IDI7CglpbnQgY29sX251bSwgaTsKCWludCBudW1fZGFzaGVzID0KCQkoKGdyYXBoLT5udW1fcGFyZW50cyAtIGRhc2hsZXNzX2NvbW1pdHMpICogMikgLSAxOwoJZm9yIChpID0gMDsgaSA8IG51bV9kYXNoZXM7IGkrKykgewoJCWNvbF9udW0gPSAoaSAvIDIpICsgZGFzaGxlc3NfY29tbWl0cyArIGdyYXBoLT5jb21taXRfaW5kZXg7CgkJc3RyYnVmX3dyaXRlX2NvbHVtbihzYiwgJmdyYXBoLT5uZXdfY29sdW1uc1tjb2xfbnVtXSwgJy0nKTsKCX0KCWNvbF9udW0gPSAoaSAvIDIpICsgZGFzaGxlc3NfY29tbWl0cyArIGdyYXBoLT5jb21taXRfaW5kZXg7CglzdHJidWZfd3JpdGVfY29sdW1uKHNiLCAmZ3JhcGgtPm5ld19jb2x1bW5zW2NvbF9udW1dLCAnLicpOwoJcmV0dXJuIG51bV9kYXNoZXMgKyAxOwp9CgpzdGF0aWMgdm9pZCBncmFwaF9vdXRwdXRfY29tbWl0X2xpbmUoc3RydWN0IGdpdF9ncmFwaCAqZ3JhcGgsIHN0cnVjdCBzdHJidWYgKnNiKQp7CglpbnQgc2Vlbl90aGlzID0gMDsKCWludCBpLCBjaGFyc193cml0dGVuOwoKCS8qCgkgKiBPdXRwdXQgdGhlIHJvdyBjb250YWluaW5nIHRoaXMgY29tbWl0CgkgKiBJdGVyYXRlIHVwIHRvIGFuZCBpbmNsdWRpbmcgZ3JhcGgtPm51bV9jb2x1bW5zLAoJICogc2luY2UgdGhlIGN1cnJlbnQgY29tbWl0IG1heSBub3QgYmUgaW4gYW55IG9mIHRoZSBleGlzdGluZwoJICogY29sdW1ucy4gIChUaGlzIGhhcHBlbnMgd2hlbiB0aGUgY3VycmVudCBjb21taXQgZG9lc24ndCBoYXZlIGFueQoJICogY2hpbGRyZW4gdGhhdCB3ZSBoYXZlIGFscmVhZHkgcHJvY2Vzc2VkLikKCSAqLwoJc2Vlbl90aGlzID0gMDsKCWNoYXJzX3dyaXR0ZW4gPSAwOwoJZm9yIChpID0gMDsgaSA8PSBncmFwaC0+bnVtX2NvbHVtbnM7IGkrKykgewoJCXN0cnVjdCBjb2x1bW4gKmNvbCA9ICZncmFwaC0+Y29sdW1uc1tpXTsKCQlzdHJ1Y3QgY29tbWl0ICpjb2xfY29tbWl0OwoJCWlmIChpID09IGdyYXBoLT5udW1fY29sdW1ucykgewoJCQlpZiAoc2Vlbl90aGlzKQoJCQkJYnJlYWs7CgkJCWNvbF9jb21taXQgPSBncmFwaC0+Y29tbWl0OwoJCX0gZWxzZSB7CgkJCWNvbF9jb21taXQgPSBncmFwaC0+Y29sdW1uc1tpXS5jb21taXQ7CgkJfQoKCQlpZiAoY29sX2NvbW1pdCA9PSBncmFwaC0+Y29tbWl0KSB7CgkJCXNlZW5fdGhpcyA9IDE7CgkJCWdyYXBoX291dHB1dF9jb21taXRfY2hhcihncmFwaCwgc2IpOwoJCQljaGFyc193cml0dGVuKys7CgoJCQlpZiAoZ3JhcGgtPm51bV9wYXJlbnRzID4gMikKCQkJCWNoYXJzX3dyaXR0ZW4gKz0gZ3JhcGhfZHJhd19vY3RvcHVzX21lcmdlKGdyYXBoLAoJCQkJCQkJCQkgIHNiKTsKCQl9IGVsc2UgaWYgKHNlZW5fdGhpcyAmJiAoZ3JhcGgtPm51bV9wYXJlbnRzID4gMikpIHsKCQkJc3RyYnVmX3dyaXRlX2NvbHVtbihzYiwgY29sLCAnXFwnKTsKCQkJY2hhcnNfd3JpdHRlbisrOwoJCX0gZWxzZSBpZiAoc2Vlbl90aGlzICYmIChncmFwaC0+bnVtX3BhcmVudHMgPT0gMikpIHsKCQkJLyoKCQkJICogVGhpcyBpcyBhIDItd2F5IG1lcmdlIGNvbW1pdC4KCQkJICogVGhlcmUgaXMgbm8gR1JBUEhfUFJFX0NPTU1JVCBzdGFnZSBmb3IgMi13YXkKCQkJICogbWVyZ2VzLCBzbyB0aGlzIGlzIHRoZSBmaXJzdCBsaW5lIG9mIG91dHB1dAoJCQkgKiBmb3IgdGhpcyBjb21taXQuICBDaGVjayB0byBzZWUgd2hhdCB0aGUgcHJldmlvdXMKCQkJICogbGluZSBvZiBvdXRwdXQgd2FzLgoJCQkgKgoJCQkgKiBJZiBpdCB3YXMgR1JBUEhfUE9TVF9NRVJHRSwgdGhlIGJyYW5jaCBsaW5lCgkJCSAqIGNvbWluZyBpbnRvIHRoaXMgY29tbWl0IG1heSBoYXZlIGJlZW4gJ1wnLAoJCQkgKiBhbmQgbm90ICd8JyBvciAnLycuICBJZiBzbywgb3V0cHV0IHRoZSBicmFuY2gKCQkJICogbGluZSBhcyAnXCcgb24gdGhpcyBsaW5lLCBpbnN0ZWFkIG9mICd8Jy4gIFRoaXMKCQkJICogbWFrZXMgdGhlIG91dHB1dCBsb29rIG5pY2VyLgoJCQkgKi8KCQkJaWYgKGdyYXBoLT5wcmV2X3N0YXRlID09IEdSQVBIX1BPU1RfTUVSR0UgJiYKCQkJICAgIGdyYXBoLT5wcmV2X2NvbW1pdF9pbmRleCA8IGkpCgkJCQlzdHJidWZfd3JpdGVfY29sdW1uKHNiLCBjb2wsICdcXCcpOwoJCQllbHNlCgkJCQlzdHJidWZfd3JpdGVfY29sdW1uKHNiLCBjb2wsICd8Jyk7CgkJCWNoYXJzX3dyaXR0ZW4rKzsKCQl9IGVsc2UgewoJCQlzdHJidWZfd3JpdGVfY29sdW1uKHNiLCBjb2wsICd8Jyk7CgkJCWNoYXJzX3dyaXR0ZW4rKzsKCQl9CgkJc3RyYnVmX2FkZGNoKHNiLCAnICcpOwoJCWNoYXJzX3dyaXR0ZW4rKzsKCX0KCglncmFwaF9wYWRfaG9yaXpvbnRhbGx5KGdyYXBoLCBzYiwgY2hhcnNfd3JpdHRlbik7CgoJLyoKCSAqIFVwZGF0ZSBncmFwaC0+c3RhdGUKCSAqLwoJaWYgKGdyYXBoLT5udW1fcGFyZW50cyA+IDEpCgkJZ3JhcGhfdXBkYXRlX3N0YXRlKGdyYXBoLCBHUkFQSF9QT1NUX01FUkdFKTsKCWVsc2UgaWYgKGdyYXBoX2lzX21hcHBpbmdfY29ycmVjdChncmFwaCkpCgkJZ3JhcGhfdXBkYXRlX3N0YXRlKGdyYXBoLCBHUkFQSF9QQURESU5HKTsKCWVsc2UKCQlncmFwaF91cGRhdGVfc3RhdGUoZ3JhcGgsIEdSQVBIX0NPTExBUFNJTkcpOwp9CgpzdGF0aWMgc3RydWN0IGNvbHVtbiAqZmluZF9uZXdfY29sdW1uX2J5X2NvbW1pdChzdHJ1Y3QgZ2l0X2dyYXBoICpncmFwaCwKCQkJCQkJc3RydWN0IGNvbW1pdCAqY29tbWl0KQp7CglpbnQgaTsKCWZvciAoaSA9IDA7IGkgPCBncmFwaC0+bnVtX25ld19jb2x1bW5zOyBpKyspIHsKCQlpZiAoZ3JhcGgtPm5ld19jb2x1bW5zW2ldLmNvbW1pdCA9PSBjb21taXQpCgkJCXJldHVybiAmZ3JhcGgtPm5ld19jb2x1bW5zW2ldOwoJfQoJcmV0dXJuIE5VTEw7Cn0KCnN0YXRpYyB2b2lkIGdyYXBoX291dHB1dF9wb3N0X21lcmdlX2xpbmUoc3RydWN0IGdpdF9ncmFwaCAqZ3JhcGgsIHN0cnVjdCBzdHJidWYgKnNiKQp7CglpbnQgc2Vlbl90aGlzID0gMDsKCWludCBpLCBqLCBjaGFyc193cml0dGVuOwoKCS8qCgkgKiBPdXRwdXQgdGhlIHBvc3QtbWVyZ2Ugcm93CgkgKi8KCWNoYXJzX3dyaXR0ZW4gPSAwOwoJZm9yIChpID0gMDsgaSA8PSBncmFwaC0+bnVtX2NvbHVtbnM7IGkrKykgewoJCXN0cnVjdCBjb2x1bW4gKmNvbCA9ICZncmFwaC0+Y29sdW1uc1tpXTsKCQlzdHJ1Y3QgY29tbWl0ICpjb2xfY29tbWl0OwoJCWlmIChpID09IGdyYXBoLT5udW1fY29sdW1ucykgewoJCQlpZiAoc2Vlbl90aGlzKQoJCQkJYnJlYWs7CgkJCWNvbF9jb21taXQgPSBncmFwaC0+Y29tbWl0OwoJCX0gZWxzZSB7CgkJCWNvbF9jb21taXQgPSBjb2wtPmNvbW1pdDsKCQl9CgoJCWlmIChjb2xfY29tbWl0ID09IGdyYXBoLT5jb21taXQpIHsKCQkJLyoKCQkJICogU2luY2UgdGhlIGN1cnJlbnQgY29tbWl0IGlzIGEgbWVyZ2UgZmluZAoJCQkgKiB0aGUgY29sdW1ucyBmb3IgdGhlIHBhcmVudCBjb21taXRzIGluCgkJCSAqIG5ld19jb2x1bW5zIGFuZCB1c2UgdGhvc2UgdG8gZm9ybWF0IHRoZQoJCQkgKiBlZGdlcy4KCQkJICovCgkJCXN0cnVjdCBjb21taXRfbGlzdCAqcGFyZW50cyA9IE5VTEw7CgkJCXN0cnVjdCBjb2x1bW4gKnBhcl9jb2x1bW47CgkJCXNlZW5fdGhpcyA9IDE7CgkJCXBhcmVudHMgPSBmaXJzdF9pbnRlcmVzdGluZ19wYXJlbnQoZ3JhcGgpOwoJCQlhc3NlcnQocGFyZW50cyk7CgkJCXBhcl9jb2x1bW4gPSBmaW5kX25ld19jb2x1bW5fYnlfY29tbWl0KGdyYXBoLCBwYXJlbnRzLT5pdGVtKTsKCQkJYXNzZXJ0KHBhcl9jb2x1bW4pOwoKCQkJc3RyYnVmX3dyaXRlX2NvbHVtbihzYiwgcGFyX2NvbHVtbiwgJ3wnKTsKCQkJY2hhcnNfd3JpdHRlbisrOwoJCQlmb3IgKGogPSAwOyBqIDwgZ3JhcGgtPm51bV9wYXJlbnRzIC0gMTsgaisrKSB7CgkJCQlwYXJlbnRzID0gbmV4dF9pbnRlcmVzdGluZ19wYXJlbnQoZ3JhcGgsIHBhcmVudHMpOwoJCQkJYXNzZXJ0KHBhcmVudHMpOwoJCQkJcGFyX2NvbHVtbiA9IGZpbmRfbmV3X2NvbHVtbl9ieV9jb21taXQoZ3JhcGgsIHBhcmVudHMtPml0ZW0pOwoJCQkJYXNzZXJ0KHBhcl9jb2x1bW4pOwoJCQkJc3RyYnVmX3dyaXRlX2NvbHVtbihzYiwgcGFyX2NvbHVtbiwgJ1xcJyk7CgkJCQlzdHJidWZfYWRkY2goc2IsICcgJyk7CgkJCX0KCQkJY2hhcnNfd3JpdHRlbiArPSBqICogMjsKCQl9IGVsc2UgaWYgKHNlZW5fdGhpcykgewoJCQlzdHJidWZfd3JpdGVfY29sdW1uKHNiLCBjb2wsICdcXCcpOwoJCQlzdHJidWZfYWRkY2goc2IsICcgJyk7CgkJCWNoYXJzX3dyaXR0ZW4gKz0gMjsKCQl9IGVsc2UgewoJCQlzdHJidWZfd3JpdGVfY29sdW1uKHNiLCBjb2wsICd8Jyk7CgkJCXN0cmJ1Zl9hZGRjaChzYiwgJyAnKTsKCQkJY2hhcnNfd3JpdHRlbiArPSAyOwoJCX0KCX0KCglncmFwaF9wYWRfaG9yaXpvbnRhbGx5KGdyYXBoLCBzYiwgY2hhcnNfd3JpdHRlbik7CgoJLyoKCSAqIFVwZGF0ZSBncmFwaC0+c3RhdGUKCSAqLwoJaWYgKGdyYXBoX2lzX21hcHBpbmdfY29ycmVjdChncmFwaCkpCgkJZ3JhcGhfdXBkYXRlX3N0YXRlKGdyYXBoLCBHUkFQSF9QQURESU5HKTsKCWVsc2UKCQlncmFwaF91cGRhdGVfc3RhdGUoZ3JhcGgsIEdSQVBIX0NPTExBUFNJTkcpOwp9CgpzdGF0aWMgdm9pZCBncmFwaF9vdXRwdXRfY29sbGFwc2luZ19saW5lKHN0cnVjdCBnaXRfZ3JhcGggKmdyYXBoLCBzdHJ1Y3Qgc3RyYnVmICpzYikKewoJaW50IGk7CglpbnQgKnRtcF9tYXBwaW5nOwoJc2hvcnQgdXNlZF9ob3Jpem9udGFsID0gMDsKCWludCBob3Jpem9udGFsX2VkZ2UgPSAtMTsKCWludCBob3Jpem9udGFsX2VkZ2VfdGFyZ2V0ID0gLTE7CgoJLyoKCSAqIENsZWFyIG91dCB0aGUgbmV3X21hcHBpbmcgYXJyYXkKCSAqLwoJZm9yIChpID0gMDsgaSA8IGdyYXBoLT5tYXBwaW5nX3NpemU7IGkrKykKCQlncmFwaC0+bmV3X21hcHBpbmdbaV0gPSAtMTsKCglmb3IgKGkgPSAwOyBpIDwgZ3JhcGgtPm1hcHBpbmdfc2l6ZTsgaSsrKSB7CgkJaW50IHRhcmdldCA9IGdyYXBoLT5tYXBwaW5nW2ldOwoJCWlmICh0YXJnZXQgPCAwKQoJCQljb250aW51ZTsKCgkJLyoKCQkgKiBTaW5jZSB1cGRhdGVfY29sdW1ucygpIGFsd2F5cyBpbnNlcnRzIHRoZSBsZWZ0bW9zdAoJCSAqIGNvbHVtbiBmaXJzdCwgZWFjaCBicmFuY2gncyB0YXJnZXQgbG9jYXRpb24gc2hvdWxkCgkJICogYWx3YXlzIGJlIGVpdGhlciBpdHMgY3VycmVudCBsb2NhdGlvbiBvciB0byB0aGUgbGVmdCBvZgoJCSAqIGl0cyBjdXJyZW50IGxvY2F0aW9uLgoJCSAqCgkJICogV2UgbmV2ZXIgaGF2ZSB0byBtb3ZlIGJyYW5jaGVzIHRvIHRoZSByaWdodC4gIFRoaXMgbWFrZXMKCQkgKiB0aGUgZ3JhcGggbXVjaCBtb3JlIGxlZ2libGUsIHNpbmNlIHdoZW5ldmVyIGJyYW5jaGVzCgkJICogY3Jvc3MsIG9ubHkgb25lIGlzIG1vdmluZyBkaXJlY3Rpb25zLgoJCSAqLwoJCWFzc2VydCh0YXJnZXQgKiAyIDw9IGkpOwoKCQlpZiAodGFyZ2V0ICogMiA9PSBpKSB7CgkJCS8qCgkJCSAqIFRoaXMgY29sdW1uIGlzIGFscmVhZHkgaW4gdGhlCgkJCSAqIGNvcnJlY3QgcGxhY2UKCQkJICovCgkJCWFzc2VydChncmFwaC0+bmV3X21hcHBpbmdbaV0gPT0gLTEpOwoJCQlncmFwaC0+bmV3X21hcHBpbmdbaV0gPSB0YXJnZXQ7CgkJfSBlbHNlIGlmIChncmFwaC0+bmV3X21hcHBpbmdbaSAtIDFdIDwgMCkgewoJCQkvKgoJCQkgKiBOb3RoaW5nIGlzIHRvIHRoZSBsZWZ0LgoJCQkgKiBNb3ZlIHRvIHRoZSBsZWZ0IGJ5IG9uZQoJCQkgKi8KCQkJZ3JhcGgtPm5ld19tYXBwaW5nW2kgLSAxXSA9IHRhcmdldDsKCQkJLyoKCQkJICogSWYgdGhlcmUgaXNuJ3QgYWxyZWFkeSBhbiBlZGdlIG1vdmluZyBob3Jpem9udGFsbHkKCQkJICogc2VsZWN0IHRoaXMgb25lLgoJCQkgKi8KCQkJaWYgKGhvcml6b250YWxfZWRnZSA9PSAtMSkgewoJCQkJaW50IGo7CgkJCQlob3Jpem9udGFsX2VkZ2UgPSBpOwoJCQkJaG9yaXpvbnRhbF9lZGdlX3RhcmdldCA9IHRhcmdldDsKCQkJCS8qCgkJCQkgKiBUaGUgdmFyaWFibGUgdGFyZ2V0IGlzIHRoZSBpbmRleCBvZiB0aGUgZ3JhcGgKCQkJCSAqIGNvbHVtbiwgYW5kIHRoZXJlZm9yZSB0YXJnZXQqMiszIGlzIHRoZQoJCQkJICogYWN0dWFsIHNjcmVlbiBjb2x1bW4gb2YgdGhlIGZpcnN0IGhvcml6b250YWwKCQkJCSAqIGxpbmUuCgkJCQkgKi8KCQkJCWZvciAoaiA9ICh0YXJnZXQgKiAyKSszOyBqIDwgKGkgLSAyKTsgaiArPSAyKQoJCQkJCWdyYXBoLT5uZXdfbWFwcGluZ1tqXSA9IHRhcmdldDsKCQkJfQoJCX0gZWxzZSBpZiAoZ3JhcGgtPm5ld19tYXBwaW5nW2kgLSAxXSA9PSB0YXJnZXQpIHsKCQkJLyoKCQkJICogVGhlcmUgaXMgYSBicmFuY2ggbGluZSB0byBvdXIgbGVmdAoJCQkgKiBhbHJlYWR5LCBhbmQgaXQgaXMgb3VyIHRhcmdldC4gIFdlCgkJCSAqIGNvbWJpbmUgd2l0aCB0aGlzIGxpbmUsIHNpbmNlIHdlIHNoYXJlCgkJCSAqIHRoZSBzYW1lIHBhcmVudCBjb21taXQuCgkJCSAqCgkJCSAqIFdlIGRvbid0IGhhdmUgdG8gYWRkIGFueXRoaW5nIHRvIHRoZQoJCQkgKiBvdXRwdXQgb3IgbmV3X21hcHBpbmcsIHNpbmNlIHRoZQoJCQkgKiBleGlzdGluZyBicmFuY2ggbGluZSBoYXMgYWxyZWFkeSB0YWtlbgoJCQkgKiBjYXJlIG9mIGl0LgoJCQkgKi8KCQl9IGVsc2UgewoJCQkvKgoJCQkgKiBUaGVyZSBpcyBhIGJyYW5jaCBsaW5lIHRvIG91ciBsZWZ0LAoJCQkgKiBidXQgaXQgaXNuJ3Qgb3VyIHRhcmdldC4gIFdlIG5lZWQgdG8KCQkJICogY3Jvc3Mgb3ZlciBpdC4KCQkJICoKCQkJICogVGhlIHNwYWNlIGp1c3QgdG8gdGhlIGxlZnQgb2YgdGhpcwoJCQkgKiBicmFuY2ggc2hvdWxkIGFsd2F5cyBiZSBlbXB0eS4KCQkJICoKCQkJICogVGhlIGJyYW5jaCB0byB0aGUgbGVmdCBvZiB0aGF0IHNwYWNlCgkJCSAqIHNob3VsZCBiZSBvdXIgZXZlbnR1YWwgdGFyZ2V0LgoJCQkgKi8KCQkJYXNzZXJ0KGdyYXBoLT5uZXdfbWFwcGluZ1tpIC0gMV0gPiB0YXJnZXQpOwoJCQlhc3NlcnQoZ3JhcGgtPm5ld19tYXBwaW5nW2kgLSAyXSA8IDApOwoJCQlhc3NlcnQoZ3JhcGgtPm5ld19tYXBwaW5nW2kgLSAzXSA9PSB0YXJnZXQpOwoJCQlncmFwaC0+bmV3X21hcHBpbmdbaSAtIDJdID0gdGFyZ2V0OwoJCQkvKgoJCQkgKiBNYXJrIHRoaXMgYnJhbmNoIGFzIHRoZSBob3Jpem9udGFsIGVkZ2UgdG8KCQkJICogcHJldmVudCBhbnkgb3RoZXIgZWRnZXMgZnJvbSBtb3ZpbmcKCQkJICogaG9yaXpvbnRhbGx5LgoJCQkgKi8KCQkJaWYgKGhvcml6b250YWxfZWRnZSA9PSAtMSkKCQkJCWhvcml6b250YWxfZWRnZSA9IGk7CgkJfQoJfQoKCS8qCgkgKiBUaGUgbmV3IG1hcHBpbmcgbWF5IGJlIDEgc21hbGxlciB0aGFuIHRoZSBvbGQgbWFwcGluZwoJICovCglpZiAoZ3JhcGgtPm5ld19tYXBwaW5nW2dyYXBoLT5tYXBwaW5nX3NpemUgLSAxXSA8IDApCgkJZ3JhcGgtPm1hcHBpbmdfc2l6ZS0tOwoKCS8qCgkgKiBPdXRwdXQgb3V0IGEgbGluZSBiYXNlZCBvbiB0aGUgbmV3IG1hcHBpbmcgaW5mbwoJICovCglmb3IgKGkgPSAwOyBpIDwgZ3JhcGgtPm1hcHBpbmdfc2l6ZTsgaSsrKSB7CgkJaW50IHRhcmdldCA9IGdyYXBoLT5uZXdfbWFwcGluZ1tpXTsKCQlpZiAodGFyZ2V0IDwgMCkKCQkJc3RyYnVmX2FkZGNoKHNiLCAnICcpOwoJCWVsc2UgaWYgKHRhcmdldCAqIDIgPT0gaSkKCQkJc3RyYnVmX3dyaXRlX2NvbHVtbihzYiwgJmdyYXBoLT5uZXdfY29sdW1uc1t0YXJnZXRdLCAnfCcpOwoJCWVsc2UgaWYgKHRhcmdldCA9PSBob3Jpem9udGFsX2VkZ2VfdGFyZ2V0ICYmCgkJCSBpICE9IGhvcml6b250YWxfZWRnZSAtIDEpIHsKCQkJCS8qCgkJCQkgKiBTZXQgdGhlIG1hcHBpbmdzIGZvciBhbGwgYnV0IHRoZQoJCQkJICogZmlyc3Qgc2VnbWVudCB0byAtMSBzbyB0aGF0IHRoZXkKCQkJCSAqIHdvbid0IGNvbnRpbnVlIGludG8gdGhlIG5leHQgbGluZS4KCQkJCSAqLwoJCQkJaWYgKGkgIT0gKHRhcmdldCAqIDIpKzMpCgkJCQkJZ3JhcGgtPm5ld19tYXBwaW5nW2ldID0gLTE7CgkJCQl1c2VkX2hvcml6b250YWwgPSAxOwoJCQlzdHJidWZfd3JpdGVfY29sdW1uKHNiLCAmZ3JhcGgtPm5ld19jb2x1bW5zW3RhcmdldF0sICdfJyk7CgkJfSBlbHNlIHsKCQkJaWYgKHVzZWRfaG9yaXpvbnRhbCAmJiBpIDwgaG9yaXpvbnRhbF9lZGdlKQoJCQkJZ3JhcGgtPm5ld19tYXBwaW5nW2ldID0gLTE7CgkJCXN0cmJ1Zl93cml0ZV9jb2x1bW4oc2IsICZncmFwaC0+bmV3X2NvbHVtbnNbdGFyZ2V0XSwgJy8nKTsKCgkJfQoJfQoKCWdyYXBoX3BhZF9ob3Jpem9udGFsbHkoZ3JhcGgsIHNiLCBncmFwaC0+bWFwcGluZ19zaXplKTsKCgkvKgoJICogU3dhcCBtYXBwaW5nIGFuZCBuZXdfbWFwcGluZwoJICovCgl0bXBfbWFwcGluZyA9IGdyYXBoLT5tYXBwaW5nOwoJZ3JhcGgtPm1hcHBpbmcgPSBncmFwaC0+bmV3X21hcHBpbmc7CglncmFwaC0+bmV3X21hcHBpbmcgPSB0bXBfbWFwcGluZzsKCgkvKgoJICogSWYgZ3JhcGgtPm1hcHBpbmcgaW5kaWNhdGVzIHRoYXQgYWxsIG9mIHRoZSBicmFuY2ggbGluZXMKCSAqIGFyZSBhbHJlYWR5IGluIHRoZSBjb3JyZWN0IHBvc2l0aW9ucywgd2UgYXJlIGRvbmUuCgkgKiBPdGhlcndpc2UsIHdlIG5lZWQgdG8gY29sbGFwc2Ugc29tZSBicmFuY2ggbGluZXMgdG9nZXRoZXIuCgkgKi8KCWlmIChncmFwaF9pc19tYXBwaW5nX2NvcnJlY3QoZ3JhcGgpKQoJCWdyYXBoX3VwZGF0ZV9zdGF0ZShncmFwaCwgR1JBUEhfUEFERElORyk7Cn0KCmludCBncmFwaF9uZXh0X2xpbmUoc3RydWN0IGdpdF9ncmFwaCAqZ3JhcGgsIHN0cnVjdCBzdHJidWYgKnNiKQp7Cglzd2l0Y2ggKGdyYXBoLT5zdGF0ZSkgewoJY2FzZSBHUkFQSF9QQURESU5HOgoJCWdyYXBoX291dHB1dF9wYWRkaW5nX2xpbmUoZ3JhcGgsIHNiKTsKCQlyZXR1cm4gMDsKCWNhc2UgR1JBUEhfU0tJUDoKCQlncmFwaF9vdXRwdXRfc2tpcF9saW5lKGdyYXBoLCBzYik7CgkJcmV0dXJuIDA7CgljYXNlIEdSQVBIX1BSRV9DT01NSVQ6CgkJZ3JhcGhfb3V0cHV0X3ByZV9jb21taXRfbGluZShncmFwaCwgc2IpOwoJCXJldHVybiAwOwoJY2FzZSBHUkFQSF9DT01NSVQ6CgkJZ3JhcGhfb3V0cHV0X2NvbW1pdF9saW5lKGdyYXBoLCBzYik7CgkJcmV0dXJuIDE7CgljYXNlIEdSQVBIX1BPU1RfTUVSR0U6CgkJZ3JhcGhfb3V0cHV0X3Bvc3RfbWVyZ2VfbGluZShncmFwaCwgc2IpOwoJCXJldHVybiAwOwoJY2FzZSBHUkFQSF9DT0xMQVBTSU5HOgoJCWdyYXBoX291dHB1dF9jb2xsYXBzaW5nX2xpbmUoZ3JhcGgsIHNiKTsKCQlyZXR1cm4gMDsKCX0KCglhc3NlcnQoMCk7CglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgZ3JhcGhfcGFkZGluZ19saW5lKHN0cnVjdCBnaXRfZ3JhcGggKmdyYXBoLCBzdHJ1Y3Qgc3RyYnVmICpzYikKewoJaW50IGk7CgoJaWYgKGdyYXBoLT5zdGF0ZSAhPSBHUkFQSF9DT01NSVQpIHsKCQlncmFwaF9uZXh0X2xpbmUoZ3JhcGgsIHNiKTsKCQlyZXR1cm47Cgl9CgoJLyoKCSAqIE91dHB1dCB0aGUgcm93IGNvbnRhaW5pbmcgdGhpcyBjb21taXQKCSAqIEl0ZXJhdGUgdXAgdG8gYW5kIGluY2x1ZGluZyBncmFwaC0+bnVtX2NvbHVtbnMsCgkgKiBzaW5jZSB0aGUgY3VycmVudCBjb21taXQgbWF5IG5vdCBiZSBpbiBhbnkgb2YgdGhlIGV4aXN0aW5nCgkgKiBjb2x1bW5zLiAgKFRoaXMgaGFwcGVucyB3aGVuIHRoZSBjdXJyZW50IGNvbW1pdCBkb2Vzbid0IGhhdmUgYW55CgkgKiBjaGlsZHJlbiB0aGF0IHdlIGhhdmUgYWxyZWFkeSBwcm9jZXNzZWQuKQoJICovCglmb3IgKGkgPSAwOyBpIDwgZ3JhcGgtPm51bV9jb2x1bW5zOyBpKyspIHsKCQlzdHJ1Y3QgY29sdW1uICpjb2wgPSAmZ3JhcGgtPmNvbHVtbnNbaV07CgkJc3RyYnVmX3dyaXRlX2NvbHVtbihzYiwgY29sLCAnfCcpOwoJCWlmIChjb2wtPmNvbW1pdCA9PSBncmFwaC0+Y29tbWl0ICYmIGdyYXBoLT5udW1fcGFyZW50cyA+IDIpCgkJCXN0cmJ1Zl9hZGRjaGFycyhzYiwgJyAnLCAoZ3JhcGgtPm51bV9wYXJlbnRzIC0gMikgKiAyKTsKCQllbHNlCgkJCXN0cmJ1Zl9hZGRjaChzYiwgJyAnKTsKCX0KCglncmFwaF9wYWRfaG9yaXpvbnRhbGx5KGdyYXBoLCBzYiwgZ3JhcGgtPm51bV9jb2x1bW5zKTsKCgkvKgoJICogVXBkYXRlIGdyYXBoLT5wcmV2X3N0YXRlIHNpbmNlIHdlIGhhdmUgb3V0cHV0IGEgcGFkZGluZyBsaW5lCgkgKi8KCWdyYXBoLT5wcmV2X3N0YXRlID0gR1JBUEhfUEFERElORzsKfQoKaW50IGdyYXBoX2lzX2NvbW1pdF9maW5pc2hlZChzdHJ1Y3QgZ2l0X2dyYXBoIGNvbnN0ICpncmFwaCkKewoJcmV0dXJuIChncmFwaC0+c3RhdGUgPT0gR1JBUEhfUEFERElORyk7Cn0KCnZvaWQgZ3JhcGhfc2hvd19jb21taXQoc3RydWN0IGdpdF9ncmFwaCAqZ3JhcGgpCnsKCXN0cnVjdCBzdHJidWYgbXNnYnVmID0gU1RSQlVGX0lOSVQ7CglpbnQgc2hvd25fY29tbWl0X2xpbmUgPSAwOwoKCWlmICghZ3JhcGgpCgkJcmV0dXJuOwoKCS8qCgkgKiBXaGVuIHNob3dpbmcgYSBkaWZmIG9mIGEgbWVyZ2UgYWdhaW5zdCBlYWNoIG9mIGl0cyBwYXJlbnRzLCB3ZQoJICogYXJlIGNhbGxlZCBvbmNlIGZvciBlYWNoIHBhcmVudCB3aXRob3V0IGdyYXBoX3VwZGF0ZSBoYXZpbmcgYmVlbgoJICogY2FsbGVkLiAgSW4gdGhpcyBjYXNlLCBzaW1wbHkgb3V0cHV0IGEgc2luZ2xlIHBhZGRpbmcgbGluZS4KCSAqLwoJaWYgKGdyYXBoX2lzX2NvbW1pdF9maW5pc2hlZChncmFwaCkpIHsKCQlncmFwaF9zaG93X3BhZGRpbmcoZ3JhcGgpOwoJCXNob3duX2NvbW1pdF9saW5lID0gMTsKCX0KCgl3aGlsZSAoIXNob3duX2NvbW1pdF9saW5lICYmICFncmFwaF9pc19jb21taXRfZmluaXNoZWQoZ3JhcGgpKSB7CgkJc2hvd25fY29tbWl0X2xpbmUgPSBncmFwaF9uZXh0X2xpbmUoZ3JhcGgsICZtc2didWYpOwoJCWZ3cml0ZShtc2didWYuYnVmLCBzaXplb2YoY2hhciksIG1zZ2J1Zi5sZW4sCgkJCWdyYXBoLT5yZXZzLT5kaWZmb3B0LmZpbGUpOwoJCWlmICghc2hvd25fY29tbWl0X2xpbmUpCgkJCXB1dGMoJ1xuJywgZ3JhcGgtPnJldnMtPmRpZmZvcHQuZmlsZSk7CgkJc3RyYnVmX3NldGxlbigmbXNnYnVmLCAwKTsKCX0KCglzdHJidWZfcmVsZWFzZSgmbXNnYnVmKTsKfQoKdm9pZCBncmFwaF9zaG93X29uZWxpbmUoc3RydWN0IGdpdF9ncmFwaCAqZ3JhcGgpCnsKCXN0cnVjdCBzdHJidWYgbXNnYnVmID0gU1RSQlVGX0lOSVQ7CgoJaWYgKCFncmFwaCkKCQlyZXR1cm47CgoJZ3JhcGhfbmV4dF9saW5lKGdyYXBoLCAmbXNnYnVmKTsKCWZ3cml0ZShtc2didWYuYnVmLCBzaXplb2YoY2hhciksIG1zZ2J1Zi5sZW4sIGdyYXBoLT5yZXZzLT5kaWZmb3B0LmZpbGUpOwoJc3RyYnVmX3JlbGVhc2UoJm1zZ2J1Zik7Cn0KCnZvaWQgZ3JhcGhfc2hvd19wYWRkaW5nKHN0cnVjdCBnaXRfZ3JhcGggKmdyYXBoKQp7CglzdHJ1Y3Qgc3RyYnVmIG1zZ2J1ZiA9IFNUUkJVRl9JTklUOwoKCWlmICghZ3JhcGgpCgkJcmV0dXJuOwoKCWdyYXBoX3BhZGRpbmdfbGluZShncmFwaCwgJm1zZ2J1Zik7Cglmd3JpdGUobXNnYnVmLmJ1Ziwgc2l6ZW9mKGNoYXIpLCBtc2didWYubGVuLCBncmFwaC0+cmV2cy0+ZGlmZm9wdC5maWxlKTsKCXN0cmJ1Zl9yZWxlYXNlKCZtc2didWYpOwp9CgppbnQgZ3JhcGhfc2hvd19yZW1haW5kZXIoc3RydWN0IGdpdF9ncmFwaCAqZ3JhcGgpCnsKCXN0cnVjdCBzdHJidWYgbXNnYnVmID0gU1RSQlVGX0lOSVQ7CglpbnQgc2hvd24gPSAwOwoKCWlmICghZ3JhcGgpCgkJcmV0dXJuIDA7CgoJaWYgKGdyYXBoX2lzX2NvbW1pdF9maW5pc2hlZChncmFwaCkpCgkJcmV0dXJuIDA7CgoJZm9yICg7OykgewoJCWdyYXBoX25leHRfbGluZShncmFwaCwgJm1zZ2J1Zik7CgkJZndyaXRlKG1zZ2J1Zi5idWYsIHNpemVvZihjaGFyKSwgbXNnYnVmLmxlbiwKCQkJZ3JhcGgtPnJldnMtPmRpZmZvcHQuZmlsZSk7CgkJc3RyYnVmX3NldGxlbigmbXNnYnVmLCAwKTsKCQlzaG93biA9IDE7CgoJCWlmICghZ3JhcGhfaXNfY29tbWl0X2ZpbmlzaGVkKGdyYXBoKSkKCQkJcHV0YygnXG4nLCBncmFwaC0+cmV2cy0+ZGlmZm9wdC5maWxlKTsKCQllbHNlCgkJCWJyZWFrOwoJfQoJc3RyYnVmX3JlbGVhc2UoJm1zZ2J1Zik7CgoJcmV0dXJuIHNob3duOwp9CgoKc3RhdGljIHZvaWQgZ3JhcGhfc2hvd19zdHJidWYoc3RydWN0IGdpdF9ncmFwaCAqZ3JhcGgsIHN0cnVjdCBzdHJidWYgY29uc3QgKnNiKQp7CgljaGFyICpwOwoKCWlmICghZ3JhcGgpIHsKCQlmd3JpdGUoc2ItPmJ1Ziwgc2l6ZW9mKGNoYXIpLCBzYi0+bGVuLAoJCQlncmFwaC0+cmV2cy0+ZGlmZm9wdC5maWxlKTsKCQlyZXR1cm47Cgl9CgoJLyoKCSAqIFByaW50IHRoZSBzdHJidWYgbGluZSBieSBsaW5lLAoJICogYW5kIGRpc3BsYXkgdGhlIGdyYXBoIGluZm8gYmVmb3JlIGVhY2ggbGluZSBidXQgdGhlIGZpcnN0LgoJICovCglwID0gc2ItPmJ1ZjsKCXdoaWxlIChwKSB7CgkJc2l6ZV90IGxlbjsKCQljaGFyICpuZXh0X3AgPSBzdHJjaHIocCwgJ1xuJyk7CgkJaWYgKG5leHRfcCkgewoJCQluZXh0X3ArKzsKCQkJbGVuID0gbmV4dF9wIC0gcDsKCQl9IGVsc2UgewoJCQlsZW4gPSAoc2ItPmJ1ZiArIHNiLT5sZW4pIC0gcDsKCQl9CgkJZndyaXRlKHAsIHNpemVvZihjaGFyKSwgbGVuLCBncmFwaC0+cmV2cy0+ZGlmZm9wdC5maWxlKTsKCQlpZiAobmV4dF9wICYmICpuZXh0X3AgIT0gJ1wwJykKCQkJZ3JhcGhfc2hvd19vbmVsaW5lKGdyYXBoKTsKCQlwID0gbmV4dF9wOwoJfQp9Cgp2b2lkIGdyYXBoX3Nob3dfY29tbWl0X21zZyhzdHJ1Y3QgZ2l0X2dyYXBoICpncmFwaCwKCQkJICAgc3RydWN0IHN0cmJ1ZiBjb25zdCAqc2IpCnsKCWludCBuZXdsaW5lX3Rlcm1pbmF0ZWQ7CgoJaWYgKCFncmFwaCkgewoJCS8qCgkJICogSWYgdGhlcmUncyBubyBncmFwaCwganVzdCBwcmludCB0aGUgbWVzc2FnZSBidWZmZXIuCgkJICoKCQkgKiBUaGUgbWVzc2FnZSBidWZmZXIgZm9yIENNSVRfRk1UX09ORUxJTkUgYW5kCgkJICogQ01JVF9GTVRfVVNFUkZPUk1BVCBhcmUgYWxyZWFkeSBtaXNzaW5nIGEgdGVybWluYXRpbmcKCQkgKiBuZXdsaW5lLiAgQWxsIG9mIHRoZSBvdGhlciBmb3JtYXRzIHNob3VsZCBoYXZlIGl0LgoJCSAqLwoJCWZ3cml0ZShzYi0+YnVmLCBzaXplb2YoY2hhciksIHNiLT5sZW4sCgkJCWdyYXBoLT5yZXZzLT5kaWZmb3B0LmZpbGUpOwoJCXJldHVybjsKCX0KCgluZXdsaW5lX3Rlcm1pbmF0ZWQgPSAoc2ItPmxlbiAmJiBzYi0+YnVmW3NiLT5sZW4gLSAxXSA9PSAnXG4nKTsKCgkvKgoJICogU2hvdyB0aGUgY29tbWl0IG1lc3NhZ2UKCSAqLwoJZ3JhcGhfc2hvd19zdHJidWYoZ3JhcGgsIHNiKTsKCgkvKgoJICogSWYgdGhlcmUgaXMgbW9yZSBvdXRwdXQgbmVlZGVkIGZvciB0aGlzIGNvbW1pdCwgc2hvdyBpdCBub3cKCSAqLwoJaWYgKCFncmFwaF9pc19jb21taXRfZmluaXNoZWQoZ3JhcGgpKSB7CgkJLyoKCQkgKiBJZiBzYiBkb2Vzbid0IGhhdmUgYSB0ZXJtaW5hdGluZyBuZXdsaW5lLCBwcmludCBvbmUgbm93LAoJCSAqIHNvIHdlIGNhbiBzdGFydCB0aGUgcmVtYWluZGVyIG9mIHRoZSBncmFwaCBvdXRwdXQgb24gYQoJCSAqIG5ldyBsaW5lLgoJCSAqLwoJCWlmICghbmV3bGluZV90ZXJtaW5hdGVkKQoJCQlwdXRjKCdcbicsIGdyYXBoLT5yZXZzLT5kaWZmb3B0LmZpbGUpOwoKCQlncmFwaF9zaG93X3JlbWFpbmRlcihncmFwaCk7CgoJCS8qCgkJICogSWYgc2IgZW5kcyB3aXRoIGEgbmV3bGluZSwgb3VyIG91dHB1dCBzaG91bGQgdG9vLgoJCSAqLwoJCWlmIChuZXdsaW5lX3Rlcm1pbmF0ZWQpCgkJCXB1dGMoJ1xuJywgZ3JhcGgtPnJldnMtPmRpZmZvcHQuZmlsZSk7Cgl9Cn0K",
    "text": "#include \"cache.h\"\n#include \"commit.h\"\n#include \"color.h\"\n#include \"graph.h\"\n#include \"diff.h\"\n#include \"revision.h\"\n#include \"argv-array.h\"\n\n/* Internal API */\n\n/*\n * Output a padding line in the graph.\n * This is similar to graph_next_line().  However, it is guaranteed to\n * never print the current commit line.  Instead, if the commit line is\n * next, it will simply output a line of vertical padding, extending the\n * branch lines downwards, but leaving them otherwise unchanged.\n */\nstatic void graph_padding_line(struct git_graph *graph, struct strbuf *sb);\n\n/*\n * Print a strbuf.  If the graph is non-NULL, all lines but the first will be\n * prefixed with the graph output.\n *\n * If the strbuf ends with a newline, the output will end after this\n * newline.  A new graph line will not be printed after the final newline.\n * If the strbuf is empty, no output will be printed.\n *\n * Since the first line will not include the graph output, the caller is\n * responsible for printing this line's graph (perhaps via\n * graph_show_commit() or graph_show_oneline()) before calling\n * graph_show_strbuf().\n */\nstatic void graph_show_strbuf(struct git_graph *graph, struct strbuf const *sb);\n\n/*\n * TODO:\n * - Limit the number of columns, similar to the way gitk does.\n *   If we reach more than a specified number of columns, omit\n *   sections of some columns.\n */\n\nstruct column {\n\t/*\n\t * The parent commit of this column.\n\t */\n\tstruct commit *commit;\n\t/*\n\t * The color to (optionally) print this column in.  This is an\n\t * index into column_colors.\n\t */\n\tunsigned short color;\n};\n\nenum graph_state {\n\tGRAPH_PADDING,\n\tGRAPH_SKIP,\n\tGRAPH_PRE_COMMIT,\n\tGRAPH_COMMIT,\n\tGRAPH_POST_MERGE,\n\tGRAPH_COLLAPSING\n};\n\nstatic const char **column_colors;\nstatic unsigned short column_colors_max;\n\nstatic void parse_graph_colors_config(struct argv_array *colors, const char *string)\n{\n\tconst char *end, *start;\n\n\tstart = string;\n\tend = string + strlen(string);\n\twhile (start < end) {\n\t\tconst char *comma = strchrnul(start, ',');\n\t\tchar color[COLOR_MAXLEN];\n\n\t\tif (!color_parse_mem(start, comma - start, color))\n\t\t\targv_array_push(colors, color);\n\t\telse\n\t\t\twarning(_(\"ignore invalid color '%.*s' in log.graphColors\"),\n\t\t\t\t(int)(comma - start), start);\n\t\tstart = comma + 1;\n\t}\n\targv_array_push(colors, GIT_COLOR_RESET);\n}\n\nvoid graph_set_column_colors(const char **colors, unsigned short colors_max)\n{\n\tcolumn_colors = colors;\n\tcolumn_colors_max = colors_max;\n}\n\nstatic const char *column_get_color_code(unsigned short color)\n{\n\treturn column_colors[color];\n}\n\nstatic void strbuf_write_column(struct strbuf *sb, const struct column *c,\n\t\t\t\tchar col_char)\n{\n\tif (c->color < column_colors_max)\n\t\tstrbuf_addstr(sb, column_get_color_code(c->color));\n\tstrbuf_addch(sb, col_char);\n\tif (c->color < column_colors_max)\n\t\tstrbuf_addstr(sb, column_get_color_code(column_colors_max));\n}\n\nstruct git_graph {\n\t/*\n\t * The commit currently being processed\n\t */\n\tstruct commit *commit;\n\t/* The rev-info used for the current traversal */\n\tstruct rev_info *revs;\n\t/*\n\t * The number of interesting parents that this commit has.\n\t *\n\t * Note that this is not the same as the actual number of parents.\n\t * This count excludes parents that won't be printed in the graph\n\t * output, as determined by graph_is_interesting().\n\t */\n\tint num_parents;\n\t/*\n\t * The width of the graph output for this commit.\n\t * All rows for this commit are padded to this width, so that\n\t * messages printed after the graph output are aligned.\n\t */\n\tint width;\n\t/*\n\t * The next expansion row to print\n\t * when state is GRAPH_PRE_COMMIT\n\t */\n\tint expansion_row;\n\t/*\n\t * The current output state.\n\t * This tells us what kind of line graph_next_line() should output.\n\t */\n\tenum graph_state state;\n\t/*\n\t * The output state for the previous line of output.\n\t * This is primarily used to determine how the first merge line\n\t * should appear, based on the last line of the previous commit.\n\t */\n\tenum graph_state prev_state;\n\t/*\n\t * The index of the column that refers to this commit.\n\t *\n\t * If none of the incoming columns refer to this commit,\n\t * this will be equal to num_columns.\n\t */\n\tint commit_index;\n\t/*\n\t * The commit_index for the previously displayed commit.\n\t *\n\t * This is used to determine how the first line of a merge\n\t * graph output should appear, based on the last line of the\n\t * previous commit.\n\t */\n\tint prev_commit_index;\n\t/*\n\t * The maximum number of columns that can be stored in the columns\n\t * and new_columns arrays.  This is also half the number of entries\n\t * that can be stored in the mapping and new_mapping arrays.\n\t */\n\tint column_capacity;\n\t/*\n\t * The number of columns (also called \"branch lines\" in some places)\n\t */\n\tint num_columns;\n\t/*\n\t * The number of columns in the new_columns array\n\t */\n\tint num_new_columns;\n\t/*\n\t * The number of entries in the mapping array\n\t */\n\tint mapping_size;\n\t/*\n\t * The column state before we output the current commit.\n\t */\n\tstruct column *columns;\n\t/*\n\t * The new column state after we output the current commit.\n\t * Only valid when state is GRAPH_COLLAPSING.\n\t */\n\tstruct column *new_columns;\n\t/*\n\t * An array that tracks the current state of each\n\t * character in the output line during state GRAPH_COLLAPSING.\n\t * Each entry is -1 if this character is empty, or a non-negative\n\t * integer if the character contains a branch line.  The value of\n\t * the integer indicates the target position for this branch line.\n\t * (I.e., this array maps the current column positions to their\n\t * desired positions.)\n\t *\n\t * The maximum capacity of this array is always\n\t * sizeof(int) * 2 * column_capacity.\n\t */\n\tint *mapping;\n\t/*\n\t * A temporary array for computing the next mapping state\n\t * while we are outputting a mapping line.  This is stored as part\n\t * of the git_graph simply so we don't have to allocate a new\n\t * temporary array each time we have to output a collapsing line.\n\t */\n\tint *new_mapping;\n\t/*\n\t * The current default column color being used.  This is\n\t * stored as an index into the array column_colors.\n\t */\n\tunsigned short default_column_color;\n};\n\nstatic struct strbuf *diff_output_prefix_callback(struct diff_options *opt, void *data)\n{\n\tstruct git_graph *graph = data;\n\tstatic struct strbuf msgbuf = STRBUF_INIT;\n\n\tassert(opt);\n\tassert(graph);\n\n\topt->output_prefix_length = graph->width;\n\tstrbuf_reset(&msgbuf);\n\tgraph_padding_line(graph, &msgbuf);\n\treturn &msgbuf;\n}\n\nstruct git_graph *graph_init(struct rev_info *opt)\n{\n\tstruct git_graph *graph = xmalloc(sizeof(struct git_graph));\n\n\tif (!column_colors) {\n\t\tchar *string;\n\t\tif (git_config_get_string(\"log.graphcolors\", &string)) {\n\t\t\t/* not configured -- use default */\n\t\t\tgraph_set_column_colors(column_colors_ansi,\n\t\t\t\t\t\tcolumn_colors_ansi_max);\n\t\t} else {\n\t\t\tstatic struct argv_array custom_colors = ARGV_ARRAY_INIT;\n\t\t\targv_array_clear(&custom_colors);\n\t\t\tparse_graph_colors_config(&custom_colors, string);\n\t\t\tfree(string);\n\t\t\t/* graph_set_column_colors takes a max-index, not a count */\n\t\t\tgraph_set_column_colors(custom_colors.argv,\n\t\t\t\t\t\tcustom_colors.argc - 1);\n\t\t}\n\t}\n\n\tgraph->commit = NULL;\n\tgraph->revs = opt;\n\tgraph->num_parents = 0;\n\tgraph->expansion_row = 0;\n\tgraph->state = GRAPH_PADDING;\n\tgraph->prev_state = GRAPH_PADDING;\n\tgraph->commit_index = 0;\n\tgraph->prev_commit_index = 0;\n\tgraph->num_columns = 0;\n\tgraph->num_new_columns = 0;\n\tgraph->mapping_size = 0;\n\t/*\n\t * Start the column color at the maximum value, since we'll\n\t * always increment it for the first commit we output.\n\t * This way we start at 0 for the first commit.\n\t */\n\tgraph->default_column_color = column_colors_max - 1;\n\n\t/*\n\t * Allocate a reasonably large default number of columns\n\t * We'll automatically grow columns later if we need more room.\n\t */\n\tgraph->column_capacity = 30;\n\tALLOC_ARRAY(graph->columns, graph->column_capacity);\n\tALLOC_ARRAY(graph->new_columns, graph->column_capacity);\n\tALLOC_ARRAY(graph->mapping, 2 * graph->column_capacity);\n\tALLOC_ARRAY(graph->new_mapping, 2 * graph->column_capacity);\n\n\t/*\n\t * The diff output prefix callback, with this we can make\n\t * all the diff output to align with the graph lines.\n\t */\n\topt->diffopt.output_prefix = diff_output_prefix_callback;\n\topt->diffopt.output_prefix_data = graph;\n\topt->diffopt.output_prefix_length = 0;\n\n\treturn graph;\n}\n\nstatic void graph_update_state(struct git_graph *graph, enum graph_state s)\n{\n\tgraph->prev_state = graph->state;\n\tgraph->state = s;\n}\n\nstatic void graph_ensure_capacity(struct git_graph *graph, int num_columns)\n{\n\tif (graph->column_capacity >= num_columns)\n\t\treturn;\n\n\tdo {\n\t\tgraph->column_capacity *= 2;\n\t} while (graph->column_capacity < num_columns);\n\n\tREALLOC_ARRAY(graph->columns, graph->column_capacity);\n\tREALLOC_ARRAY(graph->new_columns, graph->column_capacity);\n\tREALLOC_ARRAY(graph->mapping, graph->column_capacity * 2);\n\tREALLOC_ARRAY(graph->new_mapping, graph->column_capacity * 2);\n}\n\n/*\n * Returns 1 if the commit will be printed in the graph output,\n * and 0 otherwise.\n */\nstatic int graph_is_interesting(struct git_graph *graph, struct commit *commit)\n{\n\t/*\n\t * If revs->boundary is set, commits whose children have\n\t * been shown are always interesting, even if they have the\n\t * UNINTERESTING or TREESAME flags set.\n\t */\n\tif (graph->revs && graph->revs->boundary) {\n\t\tif (commit->object.flags & CHILD_SHOWN)\n\t\t\treturn 1;\n\t}\n\n\t/*\n\t * Otherwise, use get_commit_action() to see if this commit is\n\t * interesting\n\t */\n\treturn get_commit_action(graph->revs, commit) == commit_show;\n}\n\nstatic struct commit_list *next_interesting_parent(struct git_graph *graph,\n\t\t\t\t\t\t   struct commit_list *orig)\n{\n\tstruct commit_list *list;\n\n\t/*\n\t * If revs->first_parent_only is set, only the first\n\t * parent is interesting.  None of the others are.\n\t */\n\tif (graph->revs->first_parent_only)\n\t\treturn NULL;\n\n\t/*\n\t * Return the next interesting commit after orig\n\t */\n\tfor (list = orig->next; list; list = list->next) {\n\t\tif (graph_is_interesting(graph, list->item))\n\t\t\treturn list;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct commit_list *first_interesting_parent(struct git_graph *graph)\n{\n\tstruct commit_list *parents = graph->commit->parents;\n\n\t/*\n\t * If this commit has no parents, ignore it\n\t */\n\tif (!parents)\n\t\treturn NULL;\n\n\t/*\n\t * If the first parent is interesting, return it\n\t */\n\tif (graph_is_interesting(graph, parents->item))\n\t\treturn parents;\n\n\t/*\n\t * Otherwise, call next_interesting_parent() to get\n\t * the next interesting parent\n\t */\n\treturn next_interesting_parent(graph, parents);\n}\n\nstatic unsigned short graph_get_current_column_color(const struct git_graph *graph)\n{\n\tif (!want_color(graph->revs->diffopt.use_color))\n\t\treturn column_colors_max;\n\treturn graph->default_column_color;\n}\n\n/*\n * Update the graph's default column color.\n */\nstatic void graph_increment_column_color(struct git_graph *graph)\n{\n\tgraph->default_column_color = (graph->default_column_color + 1) %\n\t\tcolumn_colors_max;\n}\n\nstatic unsigned short graph_find_commit_color(const struct git_graph *graph,\n\t\t\t\t\t      const struct commit *commit)\n{\n\tint i;\n\tfor (i = 0; i < graph->num_columns; i++) {\n\t\tif (graph->columns[i].commit == commit)\n\t\t\treturn graph->columns[i].color;\n\t}\n\treturn graph_get_current_column_color(graph);\n}\n\nstatic void graph_insert_into_new_columns(struct git_graph *graph,\n\t\t\t\t\t  struct commit *commit,\n\t\t\t\t\t  int *mapping_index)\n{\n\tint i;\n\n\t/*\n\t * If the commit is already in the new_columns list, we don't need to\n\t * add it.  Just update the mapping correctly.\n\t */\n\tfor (i = 0; i < graph->num_new_columns; i++) {\n\t\tif (graph->new_columns[i].commit == commit) {\n\t\t\tgraph->mapping[*mapping_index] = i;\n\t\t\t*mapping_index += 2;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * This commit isn't already in new_columns.  Add it.\n\t */\n\tgraph->new_columns[graph->num_new_columns].commit = commit;\n\tgraph->new_columns[graph->num_new_columns].color = graph_find_commit_color(graph, commit);\n\tgraph->mapping[*mapping_index] = graph->num_new_columns;\n\t*mapping_index += 2;\n\tgraph->num_new_columns++;\n}\n\nstatic void graph_update_width(struct git_graph *graph,\n\t\t\t       int is_commit_in_existing_columns)\n{\n\t/*\n\t * Compute the width needed to display the graph for this commit.\n\t * This is the maximum width needed for any row.  All other rows\n\t * will be padded to this width.\n\t *\n\t * Compute the number of columns in the widest row:\n\t * Count each existing column (graph->num_columns), and each new\n\t * column added by this commit.\n\t */\n\tint max_cols = graph->num_columns + graph->num_parents;\n\n\t/*\n\t * Even if the current commit has no parents to be printed, it\n\t * still takes up a column for itself.\n\t */\n\tif (graph->num_parents < 1)\n\t\tmax_cols++;\n\n\t/*\n\t * We added a column for the current commit as part of\n\t * graph->num_parents.  If the current commit was already in\n\t * graph->columns, then we have double counted it.\n\t */\n\tif (is_commit_in_existing_columns)\n\t\tmax_cols--;\n\n\t/*\n\t * Each column takes up 2 spaces\n\t */\n\tgraph->width = max_cols * 2;\n}\n\nstatic void graph_update_columns(struct git_graph *graph)\n{\n\tstruct commit_list *parent;\n\tstruct column *tmp_columns;\n\tint max_new_columns;\n\tint mapping_idx;\n\tint i, seen_this, is_commit_in_columns;\n\n\t/*\n\t * Swap graph->columns with graph->new_columns\n\t * graph->columns contains the state for the previous commit,\n\t * and new_columns now contains the state for our commit.\n\t *\n\t * We'll re-use the old columns array as storage to compute the new\n\t * columns list for the commit after this one.\n\t */\n\ttmp_columns = graph->columns;\n\tgraph->columns = graph->new_columns;\n\tgraph->num_columns = graph->num_new_columns;\n\n\tgraph->new_columns = tmp_columns;\n\tgraph->num_new_columns = 0;\n\n\t/*\n\t * Now update new_columns and mapping with the information for the\n\t * commit after this one.\n\t *\n\t * First, make sure we have enough room.  At most, there will\n\t * be graph->num_columns + graph->num_parents columns for the next\n\t * commit.\n\t */\n\tmax_new_columns = graph->num_columns + graph->num_parents;\n\tgraph_ensure_capacity(graph, max_new_columns);\n\n\t/*\n\t * Clear out graph->mapping\n\t */\n\tgraph->mapping_size = 2 * max_new_columns;\n\tfor (i = 0; i < graph->mapping_size; i++)\n\t\tgraph->mapping[i] = -1;\n\n\t/*\n\t * Populate graph->new_columns and graph->mapping\n\t *\n\t * Some of the parents of this commit may already be in\n\t * graph->columns.  If so, graph->new_columns should only contain a\n\t * single entry for each such commit.  graph->mapping should\n\t * contain information about where each current branch line is\n\t * supposed to end up after the collapsing is performed.\n\t */\n\tseen_this = 0;\n\tmapping_idx = 0;\n\tis_commit_in_columns = 1;\n\tfor (i = 0; i <= graph->num_columns; i++) {\n\t\tstruct commit *col_commit;\n\t\tif (i == graph->num_columns) {\n\t\t\tif (seen_this)\n\t\t\t\tbreak;\n\t\t\tis_commit_in_columns = 0;\n\t\t\tcol_commit = graph->commit;\n\t\t} else {\n\t\t\tcol_commit = graph->columns[i].commit;\n\t\t}\n\n\t\tif (col_commit == graph->commit) {\n\t\t\tint old_mapping_idx = mapping_idx;\n\t\t\tseen_this = 1;\n\t\t\tgraph->commit_index = i;\n\t\t\tfor (parent = first_interesting_parent(graph);\n\t\t\t     parent;\n\t\t\t     parent = next_interesting_parent(graph, parent)) {\n\t\t\t\t/*\n\t\t\t\t * If this is a merge, or the start of a new\n\t\t\t\t * childless column, increment the current\n\t\t\t\t * color.\n\t\t\t\t */\n\t\t\t\tif (graph->num_parents > 1 ||\n\t\t\t\t    !is_commit_in_columns) {\n\t\t\t\t\tgraph_increment_column_color(graph);\n\t\t\t\t}\n\t\t\t\tgraph_insert_into_new_columns(graph,\n\t\t\t\t\t\t\t      parent->item,\n\t\t\t\t\t\t\t      &mapping_idx);\n\t\t\t}\n\t\t\t/*\n\t\t\t * We always need to increment mapping_idx by at\n\t\t\t * least 2, even if it has no interesting parents.\n\t\t\t * The current commit always takes up at least 2\n\t\t\t * spaces.\n\t\t\t */\n\t\t\tif (mapping_idx == old_mapping_idx)\n\t\t\t\tmapping_idx += 2;\n\t\t} else {\n\t\t\tgraph_insert_into_new_columns(graph, col_commit,\n\t\t\t\t\t\t      &mapping_idx);\n\t\t}\n\t}\n\n\t/*\n\t * Shrink mapping_size to be the minimum necessary\n\t */\n\twhile (graph->mapping_size > 1 &&\n\t       graph->mapping[graph->mapping_size - 1] < 0)\n\t\tgraph->mapping_size--;\n\n\t/*\n\t * Compute graph->width for this commit\n\t */\n\tgraph_update_width(graph, is_commit_in_columns);\n}\n\nvoid graph_update(struct git_graph *graph, struct commit *commit)\n{\n\tstruct commit_list *parent;\n\n\t/*\n\t * Set the new commit\n\t */\n\tgraph->commit = commit;\n\n\t/*\n\t * Count how many interesting parents this commit has\n\t */\n\tgraph->num_parents = 0;\n\tfor (parent = first_interesting_parent(graph);\n\t     parent;\n\t     parent = next_interesting_parent(graph, parent))\n\t{\n\t\tgraph->num_parents++;\n\t}\n\n\t/*\n\t * Store the old commit_index in prev_commit_index.\n\t * graph_update_columns() will update graph->commit_index for this\n\t * commit.\n\t */\n\tgraph->prev_commit_index = graph->commit_index;\n\n\t/*\n\t * Call graph_update_columns() to update\n\t * columns, new_columns, and mapping.\n\t */\n\tgraph_update_columns(graph);\n\n\tgraph->expansion_row = 0;\n\n\t/*\n\t * Update graph->state.\n\t * Note that we don't call graph_update_state() here, since\n\t * we don't want to update graph->prev_state.  No line for\n\t * graph->state was ever printed.\n\t *\n\t * If the previous commit didn't get to the GRAPH_PADDING state,\n\t * it never finished its output.  Goto GRAPH_SKIP, to print out\n\t * a line to indicate that portion of the graph is missing.\n\t *\n\t * If there are 3 or more parents, we may need to print extra rows\n\t * before the commit, to expand the branch lines around it and make\n\t * room for it.  We need to do this only if there is a branch row\n\t * (or more) to the right of this commit.\n\t *\n\t * If there are less than 3 parents, we can immediately print the\n\t * commit line.\n\t */\n\tif (graph->state != GRAPH_PADDING)\n\t\tgraph->state = GRAPH_SKIP;\n\telse if (graph->num_parents >= 3 &&\n\t\t graph->commit_index < (graph->num_columns - 1))\n\t\tgraph->state = GRAPH_PRE_COMMIT;\n\telse\n\t\tgraph->state = GRAPH_COMMIT;\n}\n\nstatic int graph_is_mapping_correct(struct git_graph *graph)\n{\n\tint i;\n\n\t/*\n\t * The mapping is up to date if each entry is at its target,\n\t * or is 1 greater than its target.\n\t * (If it is 1 greater than the target, '/' will be printed, so it\n\t * will look correct on the next row.)\n\t */\n\tfor (i = 0; i < graph->mapping_size; i++) {\n\t\tint target = graph->mapping[i];\n\t\tif (target < 0)\n\t\t\tcontinue;\n\t\tif (target == (i / 2))\n\t\t\tcontinue;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic void graph_pad_horizontally(struct git_graph *graph, struct strbuf *sb,\n\t\t\t\t   int chars_written)\n{\n\t/*\n\t * Add additional spaces to the end of the strbuf, so that all\n\t * lines for a particular commit have the same width.\n\t *\n\t * This way, fields printed to the right of the graph will remain\n\t * aligned for the entire commit.\n\t */\n\tint extra;\n\tif (chars_written >= graph->width)\n\t\treturn;\n\n\textra = graph->width - chars_written;\n\tstrbuf_addf(sb, \"%*s\", (int) extra, \"\");\n}\n\nstatic void graph_output_padding_line(struct git_graph *graph,\n\t\t\t\t      struct strbuf *sb)\n{\n\tint i;\n\n\t/*\n\t * We could conceivable be called with a NULL commit\n\t * if our caller has a bug, and invokes graph_next_line()\n\t * immediately after graph_init(), without first calling\n\t * graph_update().  Return without outputting anything in this\n\t * case.\n\t */\n\tif (!graph->commit)\n\t\treturn;\n\n\t/*\n\t * Output a padding row, that leaves all branch lines unchanged\n\t */\n\tfor (i = 0; i < graph->num_new_columns; i++) {\n\t\tstrbuf_write_column(sb, &graph->new_columns[i], '|');\n\t\tstrbuf_addch(sb, ' ');\n\t}\n\n\tgraph_pad_horizontally(graph, sb, graph->num_new_columns * 2);\n}\n\n\nint graph_width(struct git_graph *graph)\n{\n\treturn graph->width;\n}\n\n\nstatic void graph_output_skip_line(struct git_graph *graph, struct strbuf *sb)\n{\n\t/*\n\t * Output an ellipsis to indicate that a portion\n\t * of the graph is missing.\n\t */\n\tstrbuf_addstr(sb, \"...\");\n\tgraph_pad_horizontally(graph, sb, 3);\n\n\tif (graph->num_parents >= 3 &&\n\t    graph->commit_index < (graph->num_columns - 1))\n\t\tgraph_update_state(graph, GRAPH_PRE_COMMIT);\n\telse\n\t\tgraph_update_state(graph, GRAPH_COMMIT);\n}\n\nstatic void graph_output_pre_commit_line(struct git_graph *graph,\n\t\t\t\t\t struct strbuf *sb)\n{\n\tint num_expansion_rows;\n\tint i, seen_this;\n\tint chars_written;\n\n\t/*\n\t * This function formats a row that increases the space around a commit\n\t * with multiple parents, to make room for it.  It should only be\n\t * called when there are 3 or more parents.\n\t *\n\t * We need 2 extra rows for every parent over 2.\n\t */\n\tassert(graph->num_parents >= 3);\n\tnum_expansion_rows = (graph->num_parents - 2) * 2;\n\n\t/*\n\t * graph->expansion_row tracks the current expansion row we are on.\n\t * It should be in the range [0, num_expansion_rows - 1]\n\t */\n\tassert(0 <= graph->expansion_row &&\n\t       graph->expansion_row < num_expansion_rows);\n\n\t/*\n\t * Output the row\n\t */\n\tseen_this = 0;\n\tchars_written = 0;\n\tfor (i = 0; i < graph->num_columns; i++) {\n\t\tstruct column *col = &graph->columns[i];\n\t\tif (col->commit == graph->commit) {\n\t\t\tseen_this = 1;\n\t\t\tstrbuf_write_column(sb, col, '|');\n\t\t\tstrbuf_addf(sb, \"%*s\", graph->expansion_row, \"\");\n\t\t\tchars_written += 1 + graph->expansion_row;\n\t\t} else if (seen_this && (graph->expansion_row == 0)) {\n\t\t\t/*\n\t\t\t * This is the first line of the pre-commit output.\n\t\t\t * If the previous commit was a merge commit and\n\t\t\t * ended in the GRAPH_POST_MERGE state, all branch\n\t\t\t * lines after graph->prev_commit_index were\n\t\t\t * printed as \"\\\" on the previous line.  Continue\n\t\t\t * to print them as \"\\\" on this line.  Otherwise,\n\t\t\t * print the branch lines as \"|\".\n\t\t\t */\n\t\t\tif (graph->prev_state == GRAPH_POST_MERGE &&\n\t\t\t    graph->prev_commit_index < i)\n\t\t\t\tstrbuf_write_column(sb, col, '\\\\');\n\t\t\telse\n\t\t\t\tstrbuf_write_column(sb, col, '|');\n\t\t\tchars_written++;\n\t\t} else if (seen_this && (graph->expansion_row > 0)) {\n\t\t\tstrbuf_write_column(sb, col, '\\\\');\n\t\t\tchars_written++;\n\t\t} else {\n\t\t\tstrbuf_write_column(sb, col, '|');\n\t\t\tchars_written++;\n\t\t}\n\t\tstrbuf_addch(sb, ' ');\n\t\tchars_written++;\n\t}\n\n\tgraph_pad_horizontally(graph, sb, chars_written);\n\n\t/*\n\t * Increment graph->expansion_row,\n\t * and move to state GRAPH_COMMIT if necessary\n\t */\n\tgraph->expansion_row++;\n\tif (graph->expansion_row >= num_expansion_rows)\n\t\tgraph_update_state(graph, GRAPH_COMMIT);\n}\n\nstatic void graph_output_commit_char(struct git_graph *graph, struct strbuf *sb)\n{\n\t/*\n\t * For boundary commits, print 'o'\n\t * (We should only see boundary commits when revs->boundary is set.)\n\t */\n\tif (graph->commit->object.flags & BOUNDARY) {\n\t\tassert(graph->revs->boundary);\n\t\tstrbuf_addch(sb, 'o');\n\t\treturn;\n\t}\n\n\t/*\n\t * get_revision_mark() handles all other cases without assert()\n\t */\n\tstrbuf_addstr(sb, get_revision_mark(graph->revs, graph->commit));\n}\n\n/*\n * Draw an octopus merge and return the number of characters written.\n */\nstatic int graph_draw_octopus_merge(struct git_graph *graph,\n\t\t\t\t    struct strbuf *sb)\n{\n\t/*\n\t * Here dashless_commits represents the number of parents\n\t * which don't need to have dashes (because their edges fit\n\t * neatly under the commit).\n\t */\n\tconst int dashless_commits = 2;\n\tint col_num, i;\n\tint num_dashes =\n\t\t((graph->num_parents - dashless_commits) * 2) - 1;\n\tfor (i = 0; i < num_dashes; i++) {\n\t\tcol_num = (i / 2) + dashless_commits + graph->commit_index;\n\t\tstrbuf_write_column(sb, &graph->new_columns[col_num], '-');\n\t}\n\tcol_num = (i / 2) + dashless_commits + graph->commit_index;\n\tstrbuf_write_column(sb, &graph->new_columns[col_num], '.');\n\treturn num_dashes + 1;\n}\n\nstatic void graph_output_commit_line(struct git_graph *graph, struct strbuf *sb)\n{\n\tint seen_this = 0;\n\tint i, chars_written;\n\n\t/*\n\t * Output the row containing this commit\n\t * Iterate up to and including graph->num_columns,\n\t * since the current commit may not be in any of the existing\n\t * columns.  (This happens when the current commit doesn't have any\n\t * children that we have already processed.)\n\t */\n\tseen_this = 0;\n\tchars_written = 0;\n\tfor (i = 0; i <= graph->num_columns; i++) {\n\t\tstruct column *col = &graph->columns[i];\n\t\tstruct commit *col_commit;\n\t\tif (i == graph->num_columns) {\n\t\t\tif (seen_this)\n\t\t\t\tbreak;\n\t\t\tcol_commit = graph->commit;\n\t\t} else {\n\t\t\tcol_commit = graph->columns[i].commit;\n\t\t}\n\n\t\tif (col_commit == graph->commit) {\n\t\t\tseen_this = 1;\n\t\t\tgraph_output_commit_char(graph, sb);\n\t\t\tchars_written++;\n\n\t\t\tif (graph->num_parents > 2)\n\t\t\t\tchars_written += graph_draw_octopus_merge(graph,\n\t\t\t\t\t\t\t\t\t  sb);\n\t\t} else if (seen_this && (graph->num_parents > 2)) {\n\t\t\tstrbuf_write_column(sb, col, '\\\\');\n\t\t\tchars_written++;\n\t\t} else if (seen_this && (graph->num_parents == 2)) {\n\t\t\t/*\n\t\t\t * This is a 2-way merge commit.\n\t\t\t * There is no GRAPH_PRE_COMMIT stage for 2-way\n\t\t\t * merges, so this is the first line of output\n\t\t\t * for this commit.  Check to see what the previous\n\t\t\t * line of output was.\n\t\t\t *\n\t\t\t * If it was GRAPH_POST_MERGE, the branch line\n\t\t\t * coming into this commit may have been '\\',\n\t\t\t * and not '|' or '/'.  If so, output the branch\n\t\t\t * line as '\\' on this line, instead of '|'.  This\n\t\t\t * makes the output look nicer.\n\t\t\t */\n\t\t\tif (graph->prev_state == GRAPH_POST_MERGE &&\n\t\t\t    graph->prev_commit_index < i)\n\t\t\t\tstrbuf_write_column(sb, col, '\\\\');\n\t\t\telse\n\t\t\t\tstrbuf_write_column(sb, col, '|');\n\t\t\tchars_written++;\n\t\t} else {\n\t\t\tstrbuf_write_column(sb, col, '|');\n\t\t\tchars_written++;\n\t\t}\n\t\tstrbuf_addch(sb, ' ');\n\t\tchars_written++;\n\t}\n\n\tgraph_pad_horizontally(graph, sb, chars_written);\n\n\t/*\n\t * Update graph->state\n\t */\n\tif (graph->num_parents > 1)\n\t\tgraph_update_state(graph, GRAPH_POST_MERGE);\n\telse if (graph_is_mapping_correct(graph))\n\t\tgraph_update_state(graph, GRAPH_PADDING);\n\telse\n\t\tgraph_update_state(graph, GRAPH_COLLAPSING);\n}\n\nstatic struct column *find_new_column_by_commit(struct git_graph *graph,\n\t\t\t\t\t\tstruct commit *commit)\n{\n\tint i;\n\tfor (i = 0; i < graph->num_new_columns; i++) {\n\t\tif (graph->new_columns[i].commit == commit)\n\t\t\treturn &graph->new_columns[i];\n\t}\n\treturn NULL;\n}\n\nstatic void graph_output_post_merge_line(struct git_graph *graph, struct strbuf *sb)\n{\n\tint seen_this = 0;\n\tint i, j, chars_written;\n\n\t/*\n\t * Output the post-merge row\n\t */\n\tchars_written = 0;\n\tfor (i = 0; i <= graph->num_columns; i++) {\n\t\tstruct column *col = &graph->columns[i];\n\t\tstruct commit *col_commit;\n\t\tif (i == graph->num_columns) {\n\t\t\tif (seen_this)\n\t\t\t\tbreak;\n\t\t\tcol_commit = graph->commit;\n\t\t} else {\n\t\t\tcol_commit = col->commit;\n\t\t}\n\n\t\tif (col_commit == graph->commit) {\n\t\t\t/*\n\t\t\t * Since the current commit is a merge find\n\t\t\t * the columns for the parent commits in\n\t\t\t * new_columns and use those to format the\n\t\t\t * edges.\n\t\t\t */\n\t\t\tstruct commit_list *parents = NULL;\n\t\t\tstruct column *par_column;\n\t\t\tseen_this = 1;\n\t\t\tparents = first_interesting_parent(graph);\n\t\t\tassert(parents);\n\t\t\tpar_column = find_new_column_by_commit(graph, parents->item);\n\t\t\tassert(par_column);\n\n\t\t\tstrbuf_write_column(sb, par_column, '|');\n\t\t\tchars_written++;\n\t\t\tfor (j = 0; j < graph->num_parents - 1; j++) {\n\t\t\t\tparents = next_interesting_parent(graph, parents);\n\t\t\t\tassert(parents);\n\t\t\t\tpar_column = find_new_column_by_commit(graph, parents->item);\n\t\t\t\tassert(par_column);\n\t\t\t\tstrbuf_write_column(sb, par_column, '\\\\');\n\t\t\t\tstrbuf_addch(sb, ' ');\n\t\t\t}\n\t\t\tchars_written += j * 2;\n\t\t} else if (seen_this) {\n\t\t\tstrbuf_write_column(sb, col, '\\\\');\n\t\t\tstrbuf_addch(sb, ' ');\n\t\t\tchars_written += 2;\n\t\t} else {\n\t\t\tstrbuf_write_column(sb, col, '|');\n\t\t\tstrbuf_addch(sb, ' ');\n\t\t\tchars_written += 2;\n\t\t}\n\t}\n\n\tgraph_pad_horizontally(graph, sb, chars_written);\n\n\t/*\n\t * Update graph->state\n\t */\n\tif (graph_is_mapping_correct(graph))\n\t\tgraph_update_state(graph, GRAPH_PADDING);\n\telse\n\t\tgraph_update_state(graph, GRAPH_COLLAPSING);\n}\n\nstatic void graph_output_collapsing_line(struct git_graph *graph, struct strbuf *sb)\n{\n\tint i;\n\tint *tmp_mapping;\n\tshort used_horizontal = 0;\n\tint horizontal_edge = -1;\n\tint horizontal_edge_target = -1;\n\n\t/*\n\t * Clear out the new_mapping array\n\t */\n\tfor (i = 0; i < graph->mapping_size; i++)\n\t\tgraph->new_mapping[i] = -1;\n\n\tfor (i = 0; i < graph->mapping_size; i++) {\n\t\tint target = graph->mapping[i];\n\t\tif (target < 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Since update_columns() always inserts the leftmost\n\t\t * column first, each branch's target location should\n\t\t * always be either its current location or to the left of\n\t\t * its current location.\n\t\t *\n\t\t * We never have to move branches to the right.  This makes\n\t\t * the graph much more legible, since whenever branches\n\t\t * cross, only one is moving directions.\n\t\t */\n\t\tassert(target * 2 <= i);\n\n\t\tif (target * 2 == i) {\n\t\t\t/*\n\t\t\t * This column is already in the\n\t\t\t * correct place\n\t\t\t */\n\t\t\tassert(graph->new_mapping[i] == -1);\n\t\t\tgraph->new_mapping[i] = target;\n\t\t} else if (graph->new_mapping[i - 1] < 0) {\n\t\t\t/*\n\t\t\t * Nothing is to the left.\n\t\t\t * Move to the left by one\n\t\t\t */\n\t\t\tgraph->new_mapping[i - 1] = target;\n\t\t\t/*\n\t\t\t * If there isn't already an edge moving horizontally\n\t\t\t * select this one.\n\t\t\t */\n\t\t\tif (horizontal_edge == -1) {\n\t\t\t\tint j;\n\t\t\t\thorizontal_edge = i;\n\t\t\t\thorizontal_edge_target = target;\n\t\t\t\t/*\n\t\t\t\t * The variable target is the index of the graph\n\t\t\t\t * column, and therefore target*2+3 is the\n\t\t\t\t * actual screen column of the first horizontal\n\t\t\t\t * line.\n\t\t\t\t */\n\t\t\t\tfor (j = (target * 2)+3; j < (i - 2); j += 2)\n\t\t\t\t\tgraph->new_mapping[j] = target;\n\t\t\t}\n\t\t} else if (graph->new_mapping[i - 1] == target) {\n\t\t\t/*\n\t\t\t * There is a branch line to our left\n\t\t\t * already, and it is our target.  We\n\t\t\t * combine with this line, since we share\n\t\t\t * the same parent commit.\n\t\t\t *\n\t\t\t * We don't have to add anything to the\n\t\t\t * output or new_mapping, since the\n\t\t\t * existing branch line has already taken\n\t\t\t * care of it.\n\t\t\t */\n\t\t} else {\n\t\t\t/*\n\t\t\t * There is a branch line to our left,\n\t\t\t * but it isn't our target.  We need to\n\t\t\t * cross over it.\n\t\t\t *\n\t\t\t * The space just to the left of this\n\t\t\t * branch should always be empty.\n\t\t\t *\n\t\t\t * The branch to the left of that space\n\t\t\t * should be our eventual target.\n\t\t\t */\n\t\t\tassert(graph->new_mapping[i - 1] > target);\n\t\t\tassert(graph->new_mapping[i - 2] < 0);\n\t\t\tassert(graph->new_mapping[i - 3] == target);\n\t\t\tgraph->new_mapping[i - 2] = target;\n\t\t\t/*\n\t\t\t * Mark this branch as the horizontal edge to\n\t\t\t * prevent any other edges from moving\n\t\t\t * horizontally.\n\t\t\t */\n\t\t\tif (horizontal_edge == -1)\n\t\t\t\thorizontal_edge = i;\n\t\t}\n\t}\n\n\t/*\n\t * The new mapping may be 1 smaller than the old mapping\n\t */\n\tif (graph->new_mapping[graph->mapping_size - 1] < 0)\n\t\tgraph->mapping_size--;\n\n\t/*\n\t * Output out a line based on the new mapping info\n\t */\n\tfor (i = 0; i < graph->mapping_size; i++) {\n\t\tint target = graph->new_mapping[i];\n\t\tif (target < 0)\n\t\t\tstrbuf_addch(sb, ' ');\n\t\telse if (target * 2 == i)\n\t\t\tstrbuf_write_column(sb, &graph->new_columns[target], '|');\n\t\telse if (target == horizontal_edge_target &&\n\t\t\t i != horizontal_edge - 1) {\n\t\t\t\t/*\n\t\t\t\t * Set the mappings for all but the\n\t\t\t\t * first segment to -1 so that they\n\t\t\t\t * won't continue into the next line.\n\t\t\t\t */\n\t\t\t\tif (i != (target * 2)+3)\n\t\t\t\t\tgraph->new_mapping[i] = -1;\n\t\t\t\tused_horizontal = 1;\n\t\t\tstrbuf_write_column(sb, &graph->new_columns[target], '_');\n\t\t} else {\n\t\t\tif (used_horizontal && i < horizontal_edge)\n\t\t\t\tgraph->new_mapping[i] = -1;\n\t\t\tstrbuf_write_column(sb, &graph->new_columns[target], '/');\n\n\t\t}\n\t}\n\n\tgraph_pad_horizontally(graph, sb, graph->mapping_size);\n\n\t/*\n\t * Swap mapping and new_mapping\n\t */\n\ttmp_mapping = graph->mapping;\n\tgraph->mapping = graph->new_mapping;\n\tgraph->new_mapping = tmp_mapping;\n\n\t/*\n\t * If graph->mapping indicates that all of the branch lines\n\t * are already in the correct positions, we are done.\n\t * Otherwise, we need to collapse some branch lines together.\n\t */\n\tif (graph_is_mapping_correct(graph))\n\t\tgraph_update_state(graph, GRAPH_PADDING);\n}\n\nint graph_next_line(struct git_graph *graph, struct strbuf *sb)\n{\n\tswitch (graph->state) {\n\tcase GRAPH_PADDING:\n\t\tgraph_output_padding_line(graph, sb);\n\t\treturn 0;\n\tcase GRAPH_SKIP:\n\t\tgraph_output_skip_line(graph, sb);\n\t\treturn 0;\n\tcase GRAPH_PRE_COMMIT:\n\t\tgraph_output_pre_commit_line(graph, sb);\n\t\treturn 0;\n\tcase GRAPH_COMMIT:\n\t\tgraph_output_commit_line(graph, sb);\n\t\treturn 1;\n\tcase GRAPH_POST_MERGE:\n\t\tgraph_output_post_merge_line(graph, sb);\n\t\treturn 0;\n\tcase GRAPH_COLLAPSING:\n\t\tgraph_output_collapsing_line(graph, sb);\n\t\treturn 0;\n\t}\n\n\tassert(0);\n\treturn 0;\n}\n\nstatic void graph_padding_line(struct git_graph *graph, struct strbuf *sb)\n{\n\tint i;\n\n\tif (graph->state != GRAPH_COMMIT) {\n\t\tgraph_next_line(graph, sb);\n\t\treturn;\n\t}\n\n\t/*\n\t * Output the row containing this commit\n\t * Iterate up to and including graph->num_columns,\n\t * since the current commit may not be in any of the existing\n\t * columns.  (This happens when the current commit doesn't have any\n\t * children that we have already processed.)\n\t */\n\tfor (i = 0; i < graph->num_columns; i++) {\n\t\tstruct column *col = &graph->columns[i];\n\t\tstrbuf_write_column(sb, col, '|');\n\t\tif (col->commit == graph->commit && graph->num_parents > 2)\n\t\t\tstrbuf_addchars(sb, ' ', (graph->num_parents - 2) * 2);\n\t\telse\n\t\t\tstrbuf_addch(sb, ' ');\n\t}\n\n\tgraph_pad_horizontally(graph, sb, graph->num_columns);\n\n\t/*\n\t * Update graph->prev_state since we have output a padding line\n\t */\n\tgraph->prev_state = GRAPH_PADDING;\n}\n\nint graph_is_commit_finished(struct git_graph const *graph)\n{\n\treturn (graph->state == GRAPH_PADDING);\n}\n\nvoid graph_show_commit(struct git_graph *graph)\n{\n\tstruct strbuf msgbuf = STRBUF_INIT;\n\tint shown_commit_line = 0;\n\n\tif (!graph)\n\t\treturn;\n\n\t/*\n\t * When showing a diff of a merge against each of its parents, we\n\t * are called once for each parent without graph_update having been\n\t * called.  In this case, simply output a single padding line.\n\t */\n\tif (graph_is_commit_finished(graph)) {\n\t\tgraph_show_padding(graph);\n\t\tshown_commit_line = 1;\n\t}\n\n\twhile (!shown_commit_line && !graph_is_commit_finished(graph)) {\n\t\tshown_commit_line = graph_next_line(graph, &msgbuf);\n\t\tfwrite(msgbuf.buf, sizeof(char), msgbuf.len,\n\t\t\tgraph->revs->diffopt.file);\n\t\tif (!shown_commit_line)\n\t\t\tputc('\\n', graph->revs->diffopt.file);\n\t\tstrbuf_setlen(&msgbuf, 0);\n\t}\n\n\tstrbuf_release(&msgbuf);\n}\n\nvoid graph_show_oneline(struct git_graph *graph)\n{\n\tstruct strbuf msgbuf = STRBUF_INIT;\n\n\tif (!graph)\n\t\treturn;\n\n\tgraph_next_line(graph, &msgbuf);\n\tfwrite(msgbuf.buf, sizeof(char), msgbuf.len, graph->revs->diffopt.file);\n\tstrbuf_release(&msgbuf);\n}\n\nvoid graph_show_padding(struct git_graph *graph)\n{\n\tstruct strbuf msgbuf = STRBUF_INIT;\n\n\tif (!graph)\n\t\treturn;\n\n\tgraph_padding_line(graph, &msgbuf);\n\tfwrite(msgbuf.buf, sizeof(char), msgbuf.len, graph->revs->diffopt.file);\n\tstrbuf_release(&msgbuf);\n}\n\nint graph_show_remainder(struct git_graph *graph)\n{\n\tstruct strbuf msgbuf = STRBUF_INIT;\n\tint shown = 0;\n\n\tif (!graph)\n\t\treturn 0;\n\n\tif (graph_is_commit_finished(graph))\n\t\treturn 0;\n\n\tfor (;;) {\n\t\tgraph_next_line(graph, &msgbuf);\n\t\tfwrite(msgbuf.buf, sizeof(char), msgbuf.len,\n\t\t\tgraph->revs->diffopt.file);\n\t\tstrbuf_setlen(&msgbuf, 0);\n\t\tshown = 1;\n\n\t\tif (!graph_is_commit_finished(graph))\n\t\t\tputc('\\n', graph->revs->diffopt.file);\n\t\telse\n\t\t\tbreak;\n\t}\n\tstrbuf_release(&msgbuf);\n\n\treturn shown;\n}\n\n\nstatic void graph_show_strbuf(struct git_graph *graph, struct strbuf const *sb)\n{\n\tchar *p;\n\n\tif (!graph) {\n\t\tfwrite(sb->buf, sizeof(char), sb->len,\n\t\t\tgraph->revs->diffopt.file);\n\t\treturn;\n\t}\n\n\t/*\n\t * Print the strbuf line by line,\n\t * and display the graph info before each line but the first.\n\t */\n\tp = sb->buf;\n\twhile (p) {\n\t\tsize_t len;\n\t\tchar *next_p = strchr(p, '\\n');\n\t\tif (next_p) {\n\t\t\tnext_p++;\n\t\t\tlen = next_p - p;\n\t\t} else {\n\t\t\tlen = (sb->buf + sb->len) - p;\n\t\t}\n\t\tfwrite(p, sizeof(char), len, graph->revs->diffopt.file);\n\t\tif (next_p && *next_p != '\\0')\n\t\t\tgraph_show_oneline(graph);\n\t\tp = next_p;\n\t}\n}\n\nvoid graph_show_commit_msg(struct git_graph *graph,\n\t\t\t   struct strbuf const *sb)\n{\n\tint newline_terminated;\n\n\tif (!graph) {\n\t\t/*\n\t\t * If there's no graph, just print the message buffer.\n\t\t *\n\t\t * The message buffer for CMIT_FMT_ONELINE and\n\t\t * CMIT_FMT_USERFORMAT are already missing a terminating\n\t\t * newline.  All of the other formats should have it.\n\t\t */\n\t\tfwrite(sb->buf, sizeof(char), sb->len,\n\t\t\tgraph->revs->diffopt.file);\n\t\treturn;\n\t}\n\n\tnewline_terminated = (sb->len && sb->buf[sb->len - 1] == '\\n');\n\n\t/*\n\t * Show the commit message\n\t */\n\tgraph_show_strbuf(graph, sb);\n\n\t/*\n\t * If there is more output needed for this commit, show it now\n\t */\n\tif (!graph_is_commit_finished(graph)) {\n\t\t/*\n\t\t * If sb doesn't have a terminating newline, print one now,\n\t\t * so we can start the remainder of the graph output on a\n\t\t * new line.\n\t\t */\n\t\tif (!newline_terminated)\n\t\t\tputc('\\n', graph->revs->diffopt.file);\n\n\t\tgraph_show_remainder(graph);\n\n\t\t/*\n\t\t * If sb ends with a newline, our output should too.\n\t\t */\n\t\tif (newline_terminated)\n\t\t\tputc('\\n', graph->revs->diffopt.file);\n\t}\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00aeee36d8a048d56ab686b136cc68bc111f9929",
  "sha1_ok": true,
  "size": 36504
}
