{
  "content": {
    "base64": "LyoKICogQnVpbHRpbiAiZ2l0IGRpZmYiCiAqCiAqIENvcHlyaWdodCAoYykgMjAwNiBKdW5pbyBDIEhhbWFubwogKi8KI2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJjb2xvci5oIgojaW5jbHVkZSAiY29tbWl0LmgiCiNpbmNsdWRlICJibG9iLmgiCiNpbmNsdWRlICJ0YWcuaCIKI2luY2x1ZGUgImRpZmYuaCIKI2luY2x1ZGUgImRpZmZjb3JlLmgiCiNpbmNsdWRlICJyZXZpc2lvbi5oIgojaW5jbHVkZSAibG9nLXRyZWUuaCIKI2luY2x1ZGUgImJ1aWx0aW4uaCIKI2luY2x1ZGUgInN1Ym1vZHVsZS5oIgoKc3RydWN0IGJsb2JpbmZvIHsKCXVuc2lnbmVkIGNoYXIgc2hhMVsyMF07Cgljb25zdCBjaGFyICpuYW1lOwoJdW5zaWduZWQgbW9kZTsKfTsKCnN0YXRpYyBjb25zdCBjaGFyIGJ1aWx0aW5fZGlmZl91c2FnZVtdID0KImdpdCBkaWZmIFs8b3B0aW9ucz5dIFs8Y29tbWl0PiBbPGNvbW1pdD5dXSBbLS1dIFs8cGF0aD4uLi5dIjsKCnN0YXRpYyB2b2lkIHN0dWZmX2NoYW5nZShzdHJ1Y3QgZGlmZl9vcHRpb25zICpvcHQsCgkJCSB1bnNpZ25lZCBvbGRfbW9kZSwgdW5zaWduZWQgbmV3X21vZGUsCgkJCSBjb25zdCB1bnNpZ25lZCBjaGFyICpvbGRfc2hhMSwKCQkJIGNvbnN0IHVuc2lnbmVkIGNoYXIgKm5ld19zaGExLAoJCQkgY29uc3QgY2hhciAqb2xkX25hbWUsCgkJCSBjb25zdCBjaGFyICpuZXdfbmFtZSkKewoJc3RydWN0IGRpZmZfZmlsZXNwZWMgKm9uZSwgKnR3bzsKCglpZiAoIWlzX251bGxfc2hhMShvbGRfc2hhMSkgJiYgIWlzX251bGxfc2hhMShuZXdfc2hhMSkgJiYKCSAgICAhaGFzaGNtcChvbGRfc2hhMSwgbmV3X3NoYTEpICYmIChvbGRfbW9kZSA9PSBuZXdfbW9kZSkpCgkJcmV0dXJuOwoKCWlmIChESUZGX09QVF9UU1Qob3B0LCBSRVZFUlNFX0RJRkYpKSB7CgkJdW5zaWduZWQgdG1wOwoJCWNvbnN0IHVuc2lnbmVkIGNoYXIgKnRtcF91OwoJCWNvbnN0IGNoYXIgKnRtcF9jOwoJCXRtcCA9IG9sZF9tb2RlOyBvbGRfbW9kZSA9IG5ld19tb2RlOyBuZXdfbW9kZSA9IHRtcDsKCQl0bXBfdSA9IG9sZF9zaGExOyBvbGRfc2hhMSA9IG5ld19zaGExOyBuZXdfc2hhMSA9IHRtcF91OwoJCXRtcF9jID0gb2xkX25hbWU7IG9sZF9uYW1lID0gbmV3X25hbWU7IG5ld19uYW1lID0gdG1wX2M7Cgl9CgoJaWYgKG9wdC0+cHJlZml4ICYmCgkgICAgKHN0cm5jbXAob2xkX25hbWUsIG9wdC0+cHJlZml4LCBvcHQtPnByZWZpeF9sZW5ndGgpIHx8CgkgICAgIHN0cm5jbXAobmV3X25hbWUsIG9wdC0+cHJlZml4LCBvcHQtPnByZWZpeF9sZW5ndGgpKSkKCQlyZXR1cm47CgoJb25lID0gYWxsb2NfZmlsZXNwZWMob2xkX25hbWUpOwoJdHdvID0gYWxsb2NfZmlsZXNwZWMobmV3X25hbWUpOwoJZmlsbF9maWxlc3BlYyhvbmUsIG9sZF9zaGExLCBvbGRfbW9kZSk7CglmaWxsX2ZpbGVzcGVjKHR3bywgbmV3X3NoYTEsIG5ld19tb2RlKTsKCglkaWZmX3F1ZXVlKCZkaWZmX3F1ZXVlZF9kaWZmLCBvbmUsIHR3byk7Cn0KCnN0YXRpYyBpbnQgYnVpbHRpbl9kaWZmX2JfZihzdHJ1Y3QgcmV2X2luZm8gKnJldnMsCgkJCSAgICBpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsCgkJCSAgICBzdHJ1Y3QgYmxvYmluZm8gKmJsb2IsCgkJCSAgICBjb25zdCBjaGFyICpwYXRoKQp7CgkvKiBCbG9iIHZzIGZpbGUgaW4gdGhlIHdvcmtpbmcgdHJlZSovCglzdHJ1Y3Qgc3RhdCBzdDsKCglpZiAoYXJnYyA+IDEpCgkJdXNhZ2UoYnVpbHRpbl9kaWZmX3VzYWdlKTsKCglpZiAobHN0YXQocGF0aCwgJnN0KSkKCQlkaWVfZXJybm8oXygiZmFpbGVkIHRvIHN0YXQgJyVzJyIpLCBwYXRoKTsKCWlmICghKFNfSVNSRUcoc3Quc3RfbW9kZSkgfHwgU19JU0xOSyhzdC5zdF9tb2RlKSkpCgkJZGllKF8oIiclcyc6IG5vdCBhIHJlZ3VsYXIgZmlsZSBvciBzeW1saW5rIiksIHBhdGgpOwoKCWRpZmZfc2V0X21uZW1vbmljX3ByZWZpeCgmcmV2cy0+ZGlmZm9wdCwgIm8vIiwgIncvIik7CgoJaWYgKGJsb2JbMF0ubW9kZSA9PSBTX0lGSU5WQUxJRCkKCQlibG9iWzBdLm1vZGUgPSBjYW5vbl9tb2RlKHN0LnN0X21vZGUpOwoKCXN0dWZmX2NoYW5nZSgmcmV2cy0+ZGlmZm9wdCwKCQkgICAgIGJsb2JbMF0ubW9kZSwgY2Fub25fbW9kZShzdC5zdF9tb2RlKSwKCQkgICAgIGJsb2JbMF0uc2hhMSwgbnVsbF9zaGExLAoJCSAgICAgcGF0aCwgcGF0aCk7CglkaWZmY29yZV9zdGQoJnJldnMtPmRpZmZvcHQpOwoJZGlmZl9mbHVzaCgmcmV2cy0+ZGlmZm9wdCk7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBidWlsdGluX2RpZmZfYmxvYnMoc3RydWN0IHJldl9pbmZvICpyZXZzLAoJCQkgICAgICBpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsCgkJCSAgICAgIHN0cnVjdCBibG9iaW5mbyAqYmxvYikKewoJdW5zaWduZWQgbW9kZSA9IGNhbm9uX21vZGUoU19JRlJFRyB8IDA2NDQpOwoKCWlmIChhcmdjID4gMSkKCQl1c2FnZShidWlsdGluX2RpZmZfdXNhZ2UpOwoKCWlmIChibG9iWzBdLm1vZGUgPT0gU19JRklOVkFMSUQpCgkJYmxvYlswXS5tb2RlID0gbW9kZTsKCglpZiAoYmxvYlsxXS5tb2RlID09IFNfSUZJTlZBTElEKQoJCWJsb2JbMV0ubW9kZSA9IG1vZGU7CgoJc3R1ZmZfY2hhbmdlKCZyZXZzLT5kaWZmb3B0LAoJCSAgICAgYmxvYlswXS5tb2RlLCBibG9iWzFdLm1vZGUsCgkJICAgICBibG9iWzBdLnNoYTEsIGJsb2JbMV0uc2hhMSwKCQkgICAgIGJsb2JbMF0ubmFtZSwgYmxvYlsxXS5uYW1lKTsKCWRpZmZjb3JlX3N0ZCgmcmV2cy0+ZGlmZm9wdCk7CglkaWZmX2ZsdXNoKCZyZXZzLT5kaWZmb3B0KTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGJ1aWx0aW5fZGlmZl9pbmRleChzdHJ1Y3QgcmV2X2luZm8gKnJldnMsCgkJCSAgICAgIGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndikKewoJaW50IGNhY2hlZCA9IDA7Cgl3aGlsZSAoMSA8IGFyZ2MpIHsKCQljb25zdCBjaGFyICphcmcgPSBhcmd2WzFdOwoJCWlmICghc3RyY21wKGFyZywgIi0tY2FjaGVkIikgfHwgIXN0cmNtcChhcmcsICItLXN0YWdlZCIpKQoJCQljYWNoZWQgPSAxOwoJCWVsc2UKCQkJdXNhZ2UoYnVpbHRpbl9kaWZmX3VzYWdlKTsKCQlhcmd2Kys7IGFyZ2MtLTsKCX0KCWlmICghY2FjaGVkKQoJCXNldHVwX3dvcmtfdHJlZSgpOwoJLyoKCSAqIE1ha2Ugc3VyZSB0aGVyZSBpcyBvbmUgcmV2aXNpb24gKGkuZS4gcGVuZGluZyBvYmplY3QpLAoJICogYW5kIHRoZXJlIGlzIG5vIHJldmlzaW9uIGZpbHRlcmluZyBwYXJhbWV0ZXJzLgoJICovCglpZiAocmV2cy0+cGVuZGluZy5uciAhPSAxIHx8CgkgICAgcmV2cy0+bWF4X2NvdW50ICE9IC0xIHx8IHJldnMtPm1pbl9hZ2UgIT0gLTEgfHwKCSAgICByZXZzLT5tYXhfYWdlICE9IC0xKQoJCXVzYWdlKGJ1aWx0aW5fZGlmZl91c2FnZSk7CglpZiAocmVhZF9jYWNoZV9wcmVsb2FkKHJldnMtPmRpZmZvcHQucGF0aHMpIDwgMCkgewoJCXBlcnJvcigicmVhZF9jYWNoZV9wcmVsb2FkIik7CgkJcmV0dXJuIC0xOwoJfQoJcmV0dXJuIHJ1bl9kaWZmX2luZGV4KHJldnMsIGNhY2hlZCk7Cn0KCnN0YXRpYyBpbnQgYnVpbHRpbl9kaWZmX3RyZWUoc3RydWN0IHJldl9pbmZvICpyZXZzLAoJCQkgICAgIGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndiwKCQkJICAgICBzdHJ1Y3Qgb2JqZWN0X2FycmF5X2VudHJ5ICplbnQpCnsKCWNvbnN0IHVuc2lnbmVkIGNoYXIgKihzaGExWzJdKTsKCWludCBzd2FwID0gMDsKCglpZiAoYXJnYyA+IDEpCgkJdXNhZ2UoYnVpbHRpbl9kaWZmX3VzYWdlKTsKCgkvKiBXZSBzYXcgdHdvIHRyZWVzLCBlbnRbMF0gYW5kIGVudFsxXS4KCSAqIGlmIGVudFsxXSBpcyB1bmludGVyZXN0aW5nLCB0aGV5IGFyZSBzd2FwcGVkCgkgKi8KCWlmIChlbnRbMV0uaXRlbS0+ZmxhZ3MgJiBVTklOVEVSRVNUSU5HKQoJCXN3YXAgPSAxOwoJc2hhMVtzd2FwXSA9IGVudFswXS5pdGVtLT5zaGExOwoJc2hhMVsxLXN3YXBdID0gZW50WzFdLml0ZW0tPnNoYTE7CglkaWZmX3RyZWVfc2hhMShzaGExWzBdLCBzaGExWzFdLCAiIiwgJnJldnMtPmRpZmZvcHQpOwoJbG9nX3RyZWVfZGlmZl9mbHVzaChyZXZzKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGJ1aWx0aW5fZGlmZl9jb21iaW5lZChzdHJ1Y3QgcmV2X2luZm8gKnJldnMsCgkJCQkgaW50IGFyZ2MsIGNvbnN0IGNoYXIgKiphcmd2LAoJCQkJIHN0cnVjdCBvYmplY3RfYXJyYXlfZW50cnkgKmVudCwKCQkJCSBpbnQgZW50cykKewoJY29uc3QgdW5zaWduZWQgY2hhciAoKnBhcmVudClbMjBdOwoJaW50IGk7CgoJaWYgKGFyZ2MgPiAxKQoJCXVzYWdlKGJ1aWx0aW5fZGlmZl91c2FnZSk7CgoJaWYgKCFyZXZzLT5kZW5zZV9jb21iaW5lZF9tZXJnZXMgJiYgIXJldnMtPmNvbWJpbmVfbWVyZ2VzKQoJCXJldnMtPmRlbnNlX2NvbWJpbmVkX21lcmdlcyA9IHJldnMtPmNvbWJpbmVfbWVyZ2VzID0gMTsKCXBhcmVudCA9IHhtYWxsb2MoZW50cyAqIHNpemVvZigqcGFyZW50KSk7Cglmb3IgKGkgPSAwOyBpIDwgZW50czsgaSsrKQoJCWhhc2hjcHkoKHVuc2lnbmVkIGNoYXIgKikocGFyZW50ICsgaSksIGVudFtpXS5pdGVtLT5zaGExKTsKCWRpZmZfdHJlZV9jb21iaW5lZChwYXJlbnRbMF0sIHBhcmVudCArIDEsIGVudHMgLSAxLAoJCQkgICByZXZzLT5kZW5zZV9jb21iaW5lZF9tZXJnZXMsIHJldnMpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyB2b2lkIHJlZnJlc2hfaW5kZXhfcXVpZXRseSh2b2lkKQp7CglzdHJ1Y3QgbG9ja19maWxlICpsb2NrX2ZpbGU7CglpbnQgZmQ7CgoJbG9ja19maWxlID0geGNhbGxvYygxLCBzaXplb2Yoc3RydWN0IGxvY2tfZmlsZSkpOwoJZmQgPSBob2xkX2xvY2tlZF9pbmRleChsb2NrX2ZpbGUsIDApOwoJaWYgKGZkIDwgMCkKCQlyZXR1cm47CglkaXNjYXJkX2NhY2hlKCk7CglyZWFkX2NhY2hlKCk7CglyZWZyZXNoX2NhY2hlKFJFRlJFU0hfUVVJRVR8UkVGUkVTSF9VTk1FUkdFRCk7CgoJaWYgKGFjdGl2ZV9jYWNoZV9jaGFuZ2VkICYmCgkgICAgIXdyaXRlX2NhY2hlKGZkLCBhY3RpdmVfY2FjaGUsIGFjdGl2ZV9ucikpCgkJY29tbWl0X2xvY2tlZF9pbmRleChsb2NrX2ZpbGUpOwoKCXJvbGxiYWNrX2xvY2tfZmlsZShsb2NrX2ZpbGUpOwp9CgpzdGF0aWMgaW50IGJ1aWx0aW5fZGlmZl9maWxlcyhzdHJ1Y3QgcmV2X2luZm8gKnJldnMsIGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndikKewoJaW50IHJlc3VsdDsKCXVuc2lnbmVkIGludCBvcHRpb25zID0gMDsKCgl3aGlsZSAoMSA8IGFyZ2MgJiYgYXJndlsxXVswXSA9PSAnLScpIHsKCQlpZiAoIXN0cmNtcChhcmd2WzFdLCAiLS1iYXNlIikpCgkJCXJldnMtPm1heF9jb3VudCA9IDE7CgkJZWxzZSBpZiAoIXN0cmNtcChhcmd2WzFdLCAiLS1vdXJzIikpCgkJCXJldnMtPm1heF9jb3VudCA9IDI7CgkJZWxzZSBpZiAoIXN0cmNtcChhcmd2WzFdLCAiLS10aGVpcnMiKSkKCQkJcmV2cy0+bWF4X2NvdW50ID0gMzsKCQllbHNlIGlmICghc3RyY21wKGFyZ3ZbMV0sICItcSIpKQoJCQlvcHRpb25zIHw9IERJRkZfU0lMRU5UX09OX1JFTU9WRUQ7CgkJZWxzZSBpZiAoIXN0cmNtcChhcmd2WzFdLCAiLWgiKSkKCQkJdXNhZ2UoYnVpbHRpbl9kaWZmX3VzYWdlKTsKCQllbHNlCgkJCXJldHVybiBlcnJvcihfKCJpbnZhbGlkIG9wdGlvbjogJXMiKSwgYXJndlsxXSk7CgkJYXJndisrOyBhcmdjLS07Cgl9CgoJLyoKCSAqICJkaWZmIC0tYmFzZSIgc2hvdWxkIG5vdCBjb21iaW5lIG1lcmdlcyBiZWNhdXNlIGl0IHdhcyBub3QKCSAqIGFza2VkIHRvLiAgImRpZmYgLWMiIHNob3VsZCBub3QgZGVuc2lmeSAoaWYgdGhlIHVzZXIgd2FudHMKCSAqIGRlbnNlIG9uZSwgLS1jYyBjYW4gYmUgZXhwbGljaXRseSBhc2tlZCBmb3IsIG9yIGp1c3QgcmVseQoJICogb24gdGhlIGRlZmF1bHQpLgoJICovCglpZiAocmV2cy0+bWF4X2NvdW50ID09IC0xICYmICFyZXZzLT5jb21iaW5lX21lcmdlcyAmJgoJICAgIChyZXZzLT5kaWZmb3B0Lm91dHB1dF9mb3JtYXQgJiBESUZGX0ZPUk1BVF9QQVRDSCkpCgkJcmV2cy0+Y29tYmluZV9tZXJnZXMgPSByZXZzLT5kZW5zZV9jb21iaW5lZF9tZXJnZXMgPSAxOwoKCXNldHVwX3dvcmtfdHJlZSgpOwoJaWYgKHJlYWRfY2FjaGVfcHJlbG9hZChyZXZzLT5kaWZmb3B0LnBhdGhzKSA8IDApIHsKCQlwZXJyb3IoInJlYWRfY2FjaGVfcHJlbG9hZCIpOwoJCXJldHVybiAtMTsKCX0KCXJlc3VsdCA9IHJ1bl9kaWZmX2ZpbGVzKHJldnMsIG9wdGlvbnMpOwoJcmV0dXJuIGRpZmZfcmVzdWx0X2NvZGUoJnJldnMtPmRpZmZvcHQsIHJlc3VsdCk7Cn0KCmludCBjbWRfZGlmZihpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsIGNvbnN0IGNoYXIgKnByZWZpeCkKewoJaW50IGk7CglzdHJ1Y3QgcmV2X2luZm8gcmV2OwoJc3RydWN0IG9iamVjdF9hcnJheV9lbnRyeSBlbnRbMTAwXTsKCWludCBlbnRzID0gMCwgYmxvYnMgPSAwLCBwYXRocyA9IDA7Cgljb25zdCBjaGFyICpwYXRoID0gTlVMTDsKCXN0cnVjdCBibG9iaW5mbyBibG9iWzJdOwoJaW50IG5vbmdpdDsKCWludCByZXN1bHQgPSAwOwoKCS8qCgkgKiBXZSBjb3VsZCBnZXQgTiB0cmVlLWlzaCBpbiB0aGUgcmV2LnBlbmRpbmdfb2JqZWN0cyBsaXN0LgoJICogQWxzbyB0aGVyZSBjb3VsZCBiZSBNIGJsb2JzIHRoZXJlLCBhbmQgUCBwYXRoc3BlY3MuCgkgKgoJICogTj0wLCBNPTA6CgkgKgljYWNoZSB2cyBmaWxlcyAoZGlmZi1maWxlcykKCSAqIE49MCwgTT0yOgoJICogICAgICBjb21wYXJlIHR3byByYW5kb20gYmxvYnMuICBQIG11c3QgYmUgemVyby4KCSAqIE49MCwgTT0xLCBQPTE6CgkgKgljb21wYXJlIGEgYmxvYiB3aXRoIGEgd29ya2luZyB0cmVlIGZpbGUuCgkgKgoJICogTj0xLCBNPTA6CgkgKiAgICAgIHRyZWUgdnMgY2FjaGUgKGRpZmYtaW5kZXggLS1jYWNoZWQpCgkgKgoJICogTj0yLCBNPTA6CgkgKiAgICAgIHRyZWUgdnMgdHJlZSAoZGlmZi10cmVlKQoJICoKCSAqIE49MCwgTT0wLCBQPTI6CgkgKiAgICAgIGNvbXBhcmUgdHdvIGZpbGVzeXN0ZW0gZW50aXRpZXMgKGFrYSAtLW5vLWluZGV4KS4KCSAqCgkgKiBPdGhlciBjYXNlcyBhcmUgZXJyb3JzLgoJICovCgoJcHJlZml4ID0gc2V0dXBfZ2l0X2RpcmVjdG9yeV9nZW50bHkoJm5vbmdpdCk7CglnaXRtb2R1bGVzX2NvbmZpZygpOwoJZ2l0X2NvbmZpZyhnaXRfZGlmZl91aV9jb25maWcsIE5VTEwpOwoKCWlmIChkaWZmX3VzZV9jb2xvcl9kZWZhdWx0ID09IC0xKQoJCWRpZmZfdXNlX2NvbG9yX2RlZmF1bHQgPSBnaXRfdXNlX2NvbG9yX2RlZmF1bHQ7CgoJaW5pdF9yZXZpc2lvbnMoJnJldiwgcHJlZml4KTsKCgkvKiBJZiB0aGlzIGlzIGEgbm8taW5kZXggZGlmZiwganVzdCBydW4gaXQgYW5kIGV4aXQgdGhlcmUuICovCglkaWZmX25vX2luZGV4KCZyZXYsIGFyZ2MsIGFyZ3YsIG5vbmdpdCwgcHJlZml4KTsKCgkvKiBPdGhlcndpc2UsIHdlIGFyZSBkb2luZyB0aGUgdXN1YWwgImdpdCIgZGlmZiAqLwoJcmV2LmRpZmZvcHQuc2tpcF9zdGF0X3VubWF0Y2ggPSAhIWRpZmZfYXV0b19yZWZyZXNoX2luZGV4OwoKCS8qIERlZmF1bHQgdG8gbGV0IGV4dGVybmFsIGFuZCB0ZXh0Y29udiBiZSB1c2VkICovCglESUZGX09QVF9TRVQoJnJldi5kaWZmb3B0LCBBTExPV19FWFRFUk5BTCk7CglESUZGX09QVF9TRVQoJnJldi5kaWZmb3B0LCBBTExPV19URVhUQ09OVik7CgoJaWYgKG5vbmdpdCkKCQlkaWUoXygiTm90IGEgZ2l0IHJlcG9zaXRvcnkiKSk7CglhcmdjID0gc2V0dXBfcmV2aXNpb25zKGFyZ2MsIGFyZ3YsICZyZXYsIE5VTEwpOwoJaWYgKCFyZXYuZGlmZm9wdC5vdXRwdXRfZm9ybWF0KSB7CgkJcmV2LmRpZmZvcHQub3V0cHV0X2Zvcm1hdCA9IERJRkZfRk9STUFUX1BBVENIOwoJCWlmIChkaWZmX3NldHVwX2RvbmUoJnJldi5kaWZmb3B0KSA8IDApCgkJCWRpZShfKCJkaWZmX3NldHVwX2RvbmUgZmFpbGVkIikpOwoJfQoKCURJRkZfT1BUX1NFVCgmcmV2LmRpZmZvcHQsIFJFQ1VSU0lWRSk7CgoJLyoKCSAqIElmIHRoZSB1c2VyIGFza2VkIGZvciBvdXIgZXhpdCBjb2RlIHRoZW4gZG9uJ3Qgc3RhcnQgYQoJICogcGFnZXIgb3Igd2Ugd291bGQgZW5kIHVwIHJlcG9ydGluZyBpdHMgZXhpdCBjb2RlIGluc3RlYWQuCgkgKi8KCWlmICghRElGRl9PUFRfVFNUKCZyZXYuZGlmZm9wdCwgRVhJVF9XSVRIX1NUQVRVUykgJiYKCSAgICBjaGVja19wYWdlcl9jb25maWcoImRpZmYiKSAhPSAwKQoJCXNldHVwX3BhZ2VyKCk7CgoJLyoKCSAqIERvIHdlIGhhdmUgLS1jYWNoZWQgYW5kIG5vdCBoYXZlIGEgcGVuZGluZyBvYmplY3QsIHRoZW4KCSAqIGRlZmF1bHQgdG8gSEVBRCBieSBoYW5kLiAgRWVrLgoJICovCglpZiAoIXJldi5wZW5kaW5nLm5yKSB7CgkJaW50IGk7CgkJZm9yIChpID0gMTsgaSA8IGFyZ2M7IGkrKykgewoJCQljb25zdCBjaGFyICphcmcgPSBhcmd2W2ldOwoJCQlpZiAoIXN0cmNtcChhcmcsICItLSIpKQoJCQkJYnJlYWs7CgkJCWVsc2UgaWYgKCFzdHJjbXAoYXJnLCAiLS1jYWNoZWQiKSB8fAoJCQkJICFzdHJjbXAoYXJnLCAiLS1zdGFnZWQiKSkgewoJCQkJYWRkX2hlYWRfdG9fcGVuZGluZygmcmV2KTsKCQkJCWlmICghcmV2LnBlbmRpbmcubnIpIHsKCQkJCQlzdHJ1Y3QgdHJlZSAqdHJlZTsKCQkJCQl0cmVlID0gbG9va3VwX3RyZWUoKGNvbnN0IHVuc2lnbmVkIGNoYXIqKUVNUFRZX1RSRUVfU0hBMV9CSU4pOwoJCQkJCWFkZF9wZW5kaW5nX29iamVjdCgmcmV2LCAmdHJlZS0+b2JqZWN0LCAiSEVBRCIpOwoJCQkJfQoJCQkJYnJlYWs7CgkJCX0KCQl9Cgl9CgoJZm9yIChpID0gMDsgaSA8IHJldi5wZW5kaW5nLm5yOyBpKyspIHsKCQlzdHJ1Y3Qgb2JqZWN0X2FycmF5X2VudHJ5ICpsaXN0ID0gcmV2LnBlbmRpbmcub2JqZWN0cytpOwoJCXN0cnVjdCBvYmplY3QgKm9iaiA9IGxpc3QtPml0ZW07CgkJY29uc3QgY2hhciAqbmFtZSA9IGxpc3QtPm5hbWU7CgkJaW50IGZsYWdzID0gKG9iai0+ZmxhZ3MgJiBVTklOVEVSRVNUSU5HKTsKCQlpZiAoIW9iai0+cGFyc2VkKQoJCQlvYmogPSBwYXJzZV9vYmplY3Qob2JqLT5zaGExKTsKCQlvYmogPSBkZXJlZl90YWcob2JqLCBOVUxMLCAwKTsKCQlpZiAoIW9iaikKCQkJZGllKF8oImludmFsaWQgb2JqZWN0ICclcycgZ2l2ZW4uIiksIG5hbWUpOwoJCWlmIChvYmotPnR5cGUgPT0gT0JKX0NPTU1JVCkKCQkJb2JqID0gJigoc3RydWN0IGNvbW1pdCAqKW9iaiktPnRyZWUtPm9iamVjdDsKCQlpZiAob2JqLT50eXBlID09IE9CSl9UUkVFKSB7CgkJCWlmIChBUlJBWV9TSVpFKGVudCkgPD0gZW50cykKCQkJCWRpZShfKCJtb3JlIHRoYW4gJWQgdHJlZXMgZ2l2ZW46ICclcyciKSwKCQkJCSAgICAoaW50KSBBUlJBWV9TSVpFKGVudCksIG5hbWUpOwoJCQlvYmotPmZsYWdzIHw9IGZsYWdzOwoJCQllbnRbZW50c10uaXRlbSA9IG9iajsKCQkJZW50W2VudHNdLm5hbWUgPSBuYW1lOwoJCQllbnRzKys7CgkJCWNvbnRpbnVlOwoJCX0KCQlpZiAob2JqLT50eXBlID09IE9CSl9CTE9CKSB7CgkJCWlmICgyIDw9IGJsb2JzKQoJCQkJZGllKF8oIm1vcmUgdGhhbiB0d28gYmxvYnMgZ2l2ZW46ICclcyciKSwgbmFtZSk7CgkJCWhhc2hjcHkoYmxvYltibG9ic10uc2hhMSwgb2JqLT5zaGExKTsKCQkJYmxvYltibG9ic10ubmFtZSA9IG5hbWU7CgkJCWJsb2JbYmxvYnNdLm1vZGUgPSBsaXN0LT5tb2RlOwoJCQlibG9icysrOwoJCQljb250aW51ZTsKCgkJfQoJCWRpZShfKCJ1bmhhbmRsZWQgb2JqZWN0ICclcycgZ2l2ZW4uIiksIG5hbWUpOwoJfQoJaWYgKHJldi5wcnVuZV9kYXRhKSB7CgkJY29uc3QgY2hhciAqKnBhdGhzcGVjID0gcmV2LnBydW5lX2RhdGE7CgkJd2hpbGUgKCpwYXRoc3BlYykgewoJCQlpZiAoIXBhdGgpCgkJCQlwYXRoID0gKnBhdGhzcGVjOwoJCQlwYXRocysrOwoJCQlwYXRoc3BlYysrOwoJCX0KCX0KCgkvKgoJICogTm93LCBkbyB0aGUgYXJndW1lbnRzIGxvb2sgcmVhc29uYWJsZT8KCSAqLwoJaWYgKCFlbnRzKSB7CgkJc3dpdGNoIChibG9icykgewoJCWNhc2UgMDoKCQkJcmVzdWx0ID0gYnVpbHRpbl9kaWZmX2ZpbGVzKCZyZXYsIGFyZ2MsIGFyZ3YpOwoJCQlicmVhazsKCQljYXNlIDE6CgkJCWlmIChwYXRocyAhPSAxKQoJCQkJdXNhZ2UoYnVpbHRpbl9kaWZmX3VzYWdlKTsKCQkJcmVzdWx0ID0gYnVpbHRpbl9kaWZmX2JfZigmcmV2LCBhcmdjLCBhcmd2LCBibG9iLCBwYXRoKTsKCQkJYnJlYWs7CgkJY2FzZSAyOgoJCQlpZiAocGF0aHMpCgkJCQl1c2FnZShidWlsdGluX2RpZmZfdXNhZ2UpOwoJCQlyZXN1bHQgPSBidWlsdGluX2RpZmZfYmxvYnMoJnJldiwgYXJnYywgYXJndiwgYmxvYik7CgkJCWJyZWFrOwoJCWRlZmF1bHQ6CgkJCXVzYWdlKGJ1aWx0aW5fZGlmZl91c2FnZSk7CgkJfQoJfQoJZWxzZSBpZiAoYmxvYnMpCgkJdXNhZ2UoYnVpbHRpbl9kaWZmX3VzYWdlKTsKCWVsc2UgaWYgKGVudHMgPT0gMSkKCQlyZXN1bHQgPSBidWlsdGluX2RpZmZfaW5kZXgoJnJldiwgYXJnYywgYXJndik7CgllbHNlIGlmIChlbnRzID09IDIpCgkJcmVzdWx0ID0gYnVpbHRpbl9kaWZmX3RyZWUoJnJldiwgYXJnYywgYXJndiwgZW50KTsKCWVsc2UgaWYgKGVudFswXS5pdGVtLT5mbGFncyAmIFVOSU5URVJFU1RJTkcpIHsKCQkvKgoJCSAqIGRpZmYgQS4uLkIgd2hlcmUgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIG1lcmdlIGJhc2UKCQkgKiBiZXR3ZWVuIEEgYW5kIEIuICBXZSBoYXZlIGVudFswXSA9PSBtZXJnZS1iYXNlLAoJCSAqIGVudFtlbnRzLTJdID09IEEsIGFuZCBlbnRbZW50cy0xXSA9PSBCLiAgU2hvdyBkaWZmCgkJICogYmV0d2VlbiB0aGUgYmFzZSBhbmQgQi4gIE5vdGUgdGhhdCB3ZSBwaWNrIG9uZQoJCSAqIG1lcmdlIGJhc2UgYXQgcmFuZG9tIGlmIHRoZXJlIGFyZSBtb3JlIHRoYW4gb25lLgoJCSAqLwoJCWVudFsxXSA9IGVudFtlbnRzLTFdOwoJCXJlc3VsdCA9IGJ1aWx0aW5fZGlmZl90cmVlKCZyZXYsIGFyZ2MsIGFyZ3YsIGVudCk7Cgl9IGVsc2UKCQlyZXN1bHQgPSBidWlsdGluX2RpZmZfY29tYmluZWQoJnJldiwgYXJnYywgYXJndiwKCQkJCQkgICAgICAgZW50LCBlbnRzKTsKCXJlc3VsdCA9IGRpZmZfcmVzdWx0X2NvZGUoJnJldi5kaWZmb3B0LCByZXN1bHQpOwoJaWYgKDEgPCByZXYuZGlmZm9wdC5za2lwX3N0YXRfdW5tYXRjaCkKCQlyZWZyZXNoX2luZGV4X3F1aWV0bHkoKTsKCXJldHVybiByZXN1bHQ7Cn0K",
    "text": "/*\n * Builtin \"git diff\"\n *\n * Copyright (c) 2006 Junio C Hamano\n */\n#include \"cache.h\"\n#include \"color.h\"\n#include \"commit.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"diff.h\"\n#include \"diffcore.h\"\n#include \"revision.h\"\n#include \"log-tree.h\"\n#include \"builtin.h\"\n#include \"submodule.h\"\n\nstruct blobinfo {\n\tunsigned char sha1[20];\n\tconst char *name;\n\tunsigned mode;\n};\n\nstatic const char builtin_diff_usage[] =\n\"git diff [<options>] [<commit> [<commit>]] [--] [<path>...]\";\n\nstatic void stuff_change(struct diff_options *opt,\n\t\t\t unsigned old_mode, unsigned new_mode,\n\t\t\t const unsigned char *old_sha1,\n\t\t\t const unsigned char *new_sha1,\n\t\t\t const char *old_name,\n\t\t\t const char *new_name)\n{\n\tstruct diff_filespec *one, *two;\n\n\tif (!is_null_sha1(old_sha1) && !is_null_sha1(new_sha1) &&\n\t    !hashcmp(old_sha1, new_sha1) && (old_mode == new_mode))\n\t\treturn;\n\n\tif (DIFF_OPT_TST(opt, REVERSE_DIFF)) {\n\t\tunsigned tmp;\n\t\tconst unsigned char *tmp_u;\n\t\tconst char *tmp_c;\n\t\ttmp = old_mode; old_mode = new_mode; new_mode = tmp;\n\t\ttmp_u = old_sha1; old_sha1 = new_sha1; new_sha1 = tmp_u;\n\t\ttmp_c = old_name; old_name = new_name; new_name = tmp_c;\n\t}\n\n\tif (opt->prefix &&\n\t    (strncmp(old_name, opt->prefix, opt->prefix_length) ||\n\t     strncmp(new_name, opt->prefix, opt->prefix_length)))\n\t\treturn;\n\n\tone = alloc_filespec(old_name);\n\ttwo = alloc_filespec(new_name);\n\tfill_filespec(one, old_sha1, old_mode);\n\tfill_filespec(two, new_sha1, new_mode);\n\n\tdiff_queue(&diff_queued_diff, one, two);\n}\n\nstatic int builtin_diff_b_f(struct rev_info *revs,\n\t\t\t    int argc, const char **argv,\n\t\t\t    struct blobinfo *blob,\n\t\t\t    const char *path)\n{\n\t/* Blob vs file in the working tree*/\n\tstruct stat st;\n\n\tif (argc > 1)\n\t\tusage(builtin_diff_usage);\n\n\tif (lstat(path, &st))\n\t\tdie_errno(_(\"failed to stat '%s'\"), path);\n\tif (!(S_ISREG(st.st_mode) || S_ISLNK(st.st_mode)))\n\t\tdie(_(\"'%s': not a regular file or symlink\"), path);\n\n\tdiff_set_mnemonic_prefix(&revs->diffopt, \"o/\", \"w/\");\n\n\tif (blob[0].mode == S_IFINVALID)\n\t\tblob[0].mode = canon_mode(st.st_mode);\n\n\tstuff_change(&revs->diffopt,\n\t\t     blob[0].mode, canon_mode(st.st_mode),\n\t\t     blob[0].sha1, null_sha1,\n\t\t     path, path);\n\tdiffcore_std(&revs->diffopt);\n\tdiff_flush(&revs->diffopt);\n\treturn 0;\n}\n\nstatic int builtin_diff_blobs(struct rev_info *revs,\n\t\t\t      int argc, const char **argv,\n\t\t\t      struct blobinfo *blob)\n{\n\tunsigned mode = canon_mode(S_IFREG | 0644);\n\n\tif (argc > 1)\n\t\tusage(builtin_diff_usage);\n\n\tif (blob[0].mode == S_IFINVALID)\n\t\tblob[0].mode = mode;\n\n\tif (blob[1].mode == S_IFINVALID)\n\t\tblob[1].mode = mode;\n\n\tstuff_change(&revs->diffopt,\n\t\t     blob[0].mode, blob[1].mode,\n\t\t     blob[0].sha1, blob[1].sha1,\n\t\t     blob[0].name, blob[1].name);\n\tdiffcore_std(&revs->diffopt);\n\tdiff_flush(&revs->diffopt);\n\treturn 0;\n}\n\nstatic int builtin_diff_index(struct rev_info *revs,\n\t\t\t      int argc, const char **argv)\n{\n\tint cached = 0;\n\twhile (1 < argc) {\n\t\tconst char *arg = argv[1];\n\t\tif (!strcmp(arg, \"--cached\") || !strcmp(arg, \"--staged\"))\n\t\t\tcached = 1;\n\t\telse\n\t\t\tusage(builtin_diff_usage);\n\t\targv++; argc--;\n\t}\n\tif (!cached)\n\t\tsetup_work_tree();\n\t/*\n\t * Make sure there is one revision (i.e. pending object),\n\t * and there is no revision filtering parameters.\n\t */\n\tif (revs->pending.nr != 1 ||\n\t    revs->max_count != -1 || revs->min_age != -1 ||\n\t    revs->max_age != -1)\n\t\tusage(builtin_diff_usage);\n\tif (read_cache_preload(revs->diffopt.paths) < 0) {\n\t\tperror(\"read_cache_preload\");\n\t\treturn -1;\n\t}\n\treturn run_diff_index(revs, cached);\n}\n\nstatic int builtin_diff_tree(struct rev_info *revs,\n\t\t\t     int argc, const char **argv,\n\t\t\t     struct object_array_entry *ent)\n{\n\tconst unsigned char *(sha1[2]);\n\tint swap = 0;\n\n\tif (argc > 1)\n\t\tusage(builtin_diff_usage);\n\n\t/* We saw two trees, ent[0] and ent[1].\n\t * if ent[1] is uninteresting, they are swapped\n\t */\n\tif (ent[1].item->flags & UNINTERESTING)\n\t\tswap = 1;\n\tsha1[swap] = ent[0].item->sha1;\n\tsha1[1-swap] = ent[1].item->sha1;\n\tdiff_tree_sha1(sha1[0], sha1[1], \"\", &revs->diffopt);\n\tlog_tree_diff_flush(revs);\n\treturn 0;\n}\n\nstatic int builtin_diff_combined(struct rev_info *revs,\n\t\t\t\t int argc, const char **argv,\n\t\t\t\t struct object_array_entry *ent,\n\t\t\t\t int ents)\n{\n\tconst unsigned char (*parent)[20];\n\tint i;\n\n\tif (argc > 1)\n\t\tusage(builtin_diff_usage);\n\n\tif (!revs->dense_combined_merges && !revs->combine_merges)\n\t\trevs->dense_combined_merges = revs->combine_merges = 1;\n\tparent = xmalloc(ents * sizeof(*parent));\n\tfor (i = 0; i < ents; i++)\n\t\thashcpy((unsigned char *)(parent + i), ent[i].item->sha1);\n\tdiff_tree_combined(parent[0], parent + 1, ents - 1,\n\t\t\t   revs->dense_combined_merges, revs);\n\treturn 0;\n}\n\nstatic void refresh_index_quietly(void)\n{\n\tstruct lock_file *lock_file;\n\tint fd;\n\n\tlock_file = xcalloc(1, sizeof(struct lock_file));\n\tfd = hold_locked_index(lock_file, 0);\n\tif (fd < 0)\n\t\treturn;\n\tdiscard_cache();\n\tread_cache();\n\trefresh_cache(REFRESH_QUIET|REFRESH_UNMERGED);\n\n\tif (active_cache_changed &&\n\t    !write_cache(fd, active_cache, active_nr))\n\t\tcommit_locked_index(lock_file);\n\n\trollback_lock_file(lock_file);\n}\n\nstatic int builtin_diff_files(struct rev_info *revs, int argc, const char **argv)\n{\n\tint result;\n\tunsigned int options = 0;\n\n\twhile (1 < argc && argv[1][0] == '-') {\n\t\tif (!strcmp(argv[1], \"--base\"))\n\t\t\trevs->max_count = 1;\n\t\telse if (!strcmp(argv[1], \"--ours\"))\n\t\t\trevs->max_count = 2;\n\t\telse if (!strcmp(argv[1], \"--theirs\"))\n\t\t\trevs->max_count = 3;\n\t\telse if (!strcmp(argv[1], \"-q\"))\n\t\t\toptions |= DIFF_SILENT_ON_REMOVED;\n\t\telse if (!strcmp(argv[1], \"-h\"))\n\t\t\tusage(builtin_diff_usage);\n\t\telse\n\t\t\treturn error(_(\"invalid option: %s\"), argv[1]);\n\t\targv++; argc--;\n\t}\n\n\t/*\n\t * \"diff --base\" should not combine merges because it was not\n\t * asked to.  \"diff -c\" should not densify (if the user wants\n\t * dense one, --cc can be explicitly asked for, or just rely\n\t * on the default).\n\t */\n\tif (revs->max_count == -1 && !revs->combine_merges &&\n\t    (revs->diffopt.output_format & DIFF_FORMAT_PATCH))\n\t\trevs->combine_merges = revs->dense_combined_merges = 1;\n\n\tsetup_work_tree();\n\tif (read_cache_preload(revs->diffopt.paths) < 0) {\n\t\tperror(\"read_cache_preload\");\n\t\treturn -1;\n\t}\n\tresult = run_diff_files(revs, options);\n\treturn diff_result_code(&revs->diffopt, result);\n}\n\nint cmd_diff(int argc, const char **argv, const char *prefix)\n{\n\tint i;\n\tstruct rev_info rev;\n\tstruct object_array_entry ent[100];\n\tint ents = 0, blobs = 0, paths = 0;\n\tconst char *path = NULL;\n\tstruct blobinfo blob[2];\n\tint nongit;\n\tint result = 0;\n\n\t/*\n\t * We could get N tree-ish in the rev.pending_objects list.\n\t * Also there could be M blobs there, and P pathspecs.\n\t *\n\t * N=0, M=0:\n\t *\tcache vs files (diff-files)\n\t * N=0, M=2:\n\t *      compare two random blobs.  P must be zero.\n\t * N=0, M=1, P=1:\n\t *\tcompare a blob with a working tree file.\n\t *\n\t * N=1, M=0:\n\t *      tree vs cache (diff-index --cached)\n\t *\n\t * N=2, M=0:\n\t *      tree vs tree (diff-tree)\n\t *\n\t * N=0, M=0, P=2:\n\t *      compare two filesystem entities (aka --no-index).\n\t *\n\t * Other cases are errors.\n\t */\n\n\tprefix = setup_git_directory_gently(&nongit);\n\tgitmodules_config();\n\tgit_config(git_diff_ui_config, NULL);\n\n\tif (diff_use_color_default == -1)\n\t\tdiff_use_color_default = git_use_color_default;\n\n\tinit_revisions(&rev, prefix);\n\n\t/* If this is a no-index diff, just run it and exit there. */\n\tdiff_no_index(&rev, argc, argv, nongit, prefix);\n\n\t/* Otherwise, we are doing the usual \"git\" diff */\n\trev.diffopt.skip_stat_unmatch = !!diff_auto_refresh_index;\n\n\t/* Default to let external and textconv be used */\n\tDIFF_OPT_SET(&rev.diffopt, ALLOW_EXTERNAL);\n\tDIFF_OPT_SET(&rev.diffopt, ALLOW_TEXTCONV);\n\n\tif (nongit)\n\t\tdie(_(\"Not a git repository\"));\n\targc = setup_revisions(argc, argv, &rev, NULL);\n\tif (!rev.diffopt.output_format) {\n\t\trev.diffopt.output_format = DIFF_FORMAT_PATCH;\n\t\tif (diff_setup_done(&rev.diffopt) < 0)\n\t\t\tdie(_(\"diff_setup_done failed\"));\n\t}\n\n\tDIFF_OPT_SET(&rev.diffopt, RECURSIVE);\n\n\t/*\n\t * If the user asked for our exit code then don't start a\n\t * pager or we would end up reporting its exit code instead.\n\t */\n\tif (!DIFF_OPT_TST(&rev.diffopt, EXIT_WITH_STATUS) &&\n\t    check_pager_config(\"diff\") != 0)\n\t\tsetup_pager();\n\n\t/*\n\t * Do we have --cached and not have a pending object, then\n\t * default to HEAD by hand.  Eek.\n\t */\n\tif (!rev.pending.nr) {\n\t\tint i;\n\t\tfor (i = 1; i < argc; i++) {\n\t\t\tconst char *arg = argv[i];\n\t\t\tif (!strcmp(arg, \"--\"))\n\t\t\t\tbreak;\n\t\t\telse if (!strcmp(arg, \"--cached\") ||\n\t\t\t\t !strcmp(arg, \"--staged\")) {\n\t\t\t\tadd_head_to_pending(&rev);\n\t\t\t\tif (!rev.pending.nr) {\n\t\t\t\t\tstruct tree *tree;\n\t\t\t\t\ttree = lookup_tree((const unsigned char*)EMPTY_TREE_SHA1_BIN);\n\t\t\t\t\tadd_pending_object(&rev, &tree->object, \"HEAD\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < rev.pending.nr; i++) {\n\t\tstruct object_array_entry *list = rev.pending.objects+i;\n\t\tstruct object *obj = list->item;\n\t\tconst char *name = list->name;\n\t\tint flags = (obj->flags & UNINTERESTING);\n\t\tif (!obj->parsed)\n\t\t\tobj = parse_object(obj->sha1);\n\t\tobj = deref_tag(obj, NULL, 0);\n\t\tif (!obj)\n\t\t\tdie(_(\"invalid object '%s' given.\"), name);\n\t\tif (obj->type == OBJ_COMMIT)\n\t\t\tobj = &((struct commit *)obj)->tree->object;\n\t\tif (obj->type == OBJ_TREE) {\n\t\t\tif (ARRAY_SIZE(ent) <= ents)\n\t\t\t\tdie(_(\"more than %d trees given: '%s'\"),\n\t\t\t\t    (int) ARRAY_SIZE(ent), name);\n\t\t\tobj->flags |= flags;\n\t\t\tent[ents].item = obj;\n\t\t\tent[ents].name = name;\n\t\t\tents++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (obj->type == OBJ_BLOB) {\n\t\t\tif (2 <= blobs)\n\t\t\t\tdie(_(\"more than two blobs given: '%s'\"), name);\n\t\t\thashcpy(blob[blobs].sha1, obj->sha1);\n\t\t\tblob[blobs].name = name;\n\t\t\tblob[blobs].mode = list->mode;\n\t\t\tblobs++;\n\t\t\tcontinue;\n\n\t\t}\n\t\tdie(_(\"unhandled object '%s' given.\"), name);\n\t}\n\tif (rev.prune_data) {\n\t\tconst char **pathspec = rev.prune_data;\n\t\twhile (*pathspec) {\n\t\t\tif (!path)\n\t\t\t\tpath = *pathspec;\n\t\t\tpaths++;\n\t\t\tpathspec++;\n\t\t}\n\t}\n\n\t/*\n\t * Now, do the arguments look reasonable?\n\t */\n\tif (!ents) {\n\t\tswitch (blobs) {\n\t\tcase 0:\n\t\t\tresult = builtin_diff_files(&rev, argc, argv);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (paths != 1)\n\t\t\t\tusage(builtin_diff_usage);\n\t\t\tresult = builtin_diff_b_f(&rev, argc, argv, blob, path);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (paths)\n\t\t\t\tusage(builtin_diff_usage);\n\t\t\tresult = builtin_diff_blobs(&rev, argc, argv, blob);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage(builtin_diff_usage);\n\t\t}\n\t}\n\telse if (blobs)\n\t\tusage(builtin_diff_usage);\n\telse if (ents == 1)\n\t\tresult = builtin_diff_index(&rev, argc, argv);\n\telse if (ents == 2)\n\t\tresult = builtin_diff_tree(&rev, argc, argv, ent);\n\telse if (ent[0].item->flags & UNINTERESTING) {\n\t\t/*\n\t\t * diff A...B where there is at least one merge base\n\t\t * between A and B.  We have ent[0] == merge-base,\n\t\t * ent[ents-2] == A, and ent[ents-1] == B.  Show diff\n\t\t * between the base and B.  Note that we pick one\n\t\t * merge base at random if there are more than one.\n\t\t */\n\t\tent[1] = ent[ents-1];\n\t\tresult = builtin_diff_tree(&rev, argc, argv, ent);\n\t} else\n\t\tresult = builtin_diff_combined(&rev, argc, argv,\n\t\t\t\t\t       ent, ents);\n\tresult = diff_result_code(&rev.diffopt, result);\n\tif (1 < rev.diffopt.skip_stat_unmatch)\n\t\trefresh_index_quietly();\n\treturn result;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00342730b651c89d38e3f8af14f350a1077ffde2",
  "sha1_ok": true,
  "size": 11106
}
