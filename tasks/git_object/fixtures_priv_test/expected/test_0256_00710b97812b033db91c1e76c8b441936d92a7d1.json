{
  "content": {
    "base64": "I2RlZmluZSBOT19USEVfSU5ERVhfQ09NUEFUSUJJTElUWV9NQUNST1MKI2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJkaXIuaCIKI2luY2x1ZGUgInRyZWUuaCIKI2luY2x1ZGUgInRyZWUtd2Fsay5oIgojaW5jbHVkZSAiY2FjaGUtdHJlZS5oIgojaW5jbHVkZSAidW5wYWNrLXRyZWVzLmgiCiNpbmNsdWRlICJwcm9ncmVzcy5oIgojaW5jbHVkZSAicmVmcy5oIgojaW5jbHVkZSAiYXR0ci5oIgoKLyoKICogRXJyb3IgbWVzc2FnZXMgZXhwZWN0ZWQgYnkgc2NyaXB0cyBvdXQgb2YgcGx1bWJpbmcgY29tbWFuZHMgc3VjaCBhcwogKiByZWFkLXRyZWUuICBOb24tc2NyaXB0ZWQgUG9yY2VsYWluIGlzIG5vdCByZXF1aXJlZCB0byB1c2UgdGhlc2UgbWVzc2FnZXMKICogYW5kIGluIGZhY3QgYXJlIGVuY291cmFnZWQgdG8gcmV3b3JkIHRoZW0gdG8gYmV0dGVyIHN1aXQgdGhlaXIgcGFydGljdWxhcgogKiBzaXR1YXRpb24gYmV0dGVyLiAgU2VlIGhvdyAiZ2l0IGNoZWNrb3V0IiBhbmQgImdpdCBtZXJnZSIgcmVwbGFjZXMKICogdGhlbSB1c2luZyBzZXR1cF91bnBhY2tfdHJlZXNfcG9yY2VsYWluKCksIGZvciBleGFtcGxlLgogKi8Kc3RhdGljIGNvbnN0IGNoYXIgKnVucGFja19wbHVtYmluZ19lcnJvcnNbTkJfVU5QQUNLX1RSRUVTX0VSUk9SX1RZUEVTXSA9IHsKCS8qIEVSUk9SX1dPVUxEX09WRVJXUklURSAqLwoJIkVudHJ5ICclcycgd291bGQgYmUgb3ZlcndyaXR0ZW4gYnkgbWVyZ2UuIENhbm5vdCBtZXJnZS4iLAoKCS8qIEVSUk9SX05PVF9VUFRPREFURV9GSUxFICovCgkiRW50cnkgJyVzJyBub3QgdXB0b2RhdGUuIENhbm5vdCBtZXJnZS4iLAoKCS8qIEVSUk9SX05PVF9VUFRPREFURV9ESVIgKi8KCSJVcGRhdGluZyAnJXMnIHdvdWxkIGxvc2UgdW50cmFja2VkIGZpbGVzIGluIGl0IiwKCgkvKiBFUlJPUl9XT1VMRF9MT1NFX1VOVFJBQ0tFRF9PVkVSV1JJVFRFTiAqLwoJIlVudHJhY2tlZCB3b3JraW5nIHRyZWUgZmlsZSAnJXMnIHdvdWxkIGJlIG92ZXJ3cml0dGVuIGJ5IG1lcmdlLiIsCgoJLyogRVJST1JfV09VTERfTE9TRV9VTlRSQUNLRURfUkVNT1ZFRCAqLwoJIlVudHJhY2tlZCB3b3JraW5nIHRyZWUgZmlsZSAnJXMnIHdvdWxkIGJlIHJlbW92ZWQgYnkgbWVyZ2UuIiwKCgkvKiBFUlJPUl9CSU5EX09WRVJMQVAgKi8KCSJFbnRyeSAnJXMnIG92ZXJsYXBzIHdpdGggJyVzJy4gIENhbm5vdCBiaW5kLiIsCgoJLyogRVJST1JfU1BBUlNFX05PVF9VUFRPREFURV9GSUxFICovCgkiRW50cnkgJyVzJyBub3QgdXB0b2RhdGUuIENhbm5vdCB1cGRhdGUgc3BhcnNlIGNoZWNrb3V0LiIsCgoJLyogRVJST1JfV09VTERfTE9TRV9PUlBIQU5FRF9PVkVSV1JJVFRFTiAqLwoJIldvcmtpbmcgdHJlZSBmaWxlICclcycgd291bGQgYmUgb3ZlcndyaXR0ZW4gYnkgc3BhcnNlIGNoZWNrb3V0IHVwZGF0ZS4iLAoKCS8qIEVSUk9SX1dPVUxEX0xPU0VfT1JQSEFORURfUkVNT1ZFRCAqLwoJIldvcmtpbmcgdHJlZSBmaWxlICclcycgd291bGQgYmUgcmVtb3ZlZCBieSBzcGFyc2UgY2hlY2tvdXQgdXBkYXRlLiIsCn07CgojZGVmaW5lIEVSUk9STVNHKG8sdHlwZSkgXAoJKCAoKG8pICYmIChvKS0+bXNnc1sodHlwZSldKSBcCgkgID8gKChvKS0+bXNnc1sodHlwZSldKSAgICAgIFwKCSAgOiAodW5wYWNrX3BsdW1iaW5nX2Vycm9yc1sodHlwZSldKSApCgp2b2lkIHNldHVwX3VucGFja190cmVlc19wb3JjZWxhaW4oc3RydWN0IHVucGFja190cmVlc19vcHRpb25zICpvcHRzLAoJCQkJICBjb25zdCBjaGFyICpjbWQpCnsKCWludCBpOwoJY29uc3QgY2hhciAqKm1zZ3MgPSBvcHRzLT5tc2dzOwoJY29uc3QgY2hhciAqbXNnOwoJY2hhciAqdG1wOwoJY29uc3QgY2hhciAqY21kMiA9IHN0cmNtcChjbWQsICJjaGVja291dCIpID8gY21kIDogInN3aXRjaCBicmFuY2hlcyI7CglpZiAoYWR2aWNlX2NvbW1pdF9iZWZvcmVfbWVyZ2UpCgkJbXNnID0gIllvdXIgbG9jYWwgY2hhbmdlcyB0byB0aGUgZm9sbG93aW5nIGZpbGVzIHdvdWxkIGJlIG92ZXJ3cml0dGVuIGJ5ICVzOlxuJSVzIgoJCQkiUGxlYXNlLCBjb21taXQgeW91ciBjaGFuZ2VzIG9yIHN0YXNoIHRoZW0gYmVmb3JlIHlvdSBjYW4gJXMuIjsKCWVsc2UKCQltc2cgPSAiWW91ciBsb2NhbCBjaGFuZ2VzIHRvIHRoZSBmb2xsb3dpbmcgZmlsZXMgd291bGQgYmUgb3ZlcndyaXR0ZW4gYnkgJXM6XG4lJXMiOwoJdG1wID0geG1hbGxvYyhzdHJsZW4obXNnKSArIHN0cmxlbihjbWQpICsgc3RybGVuKGNtZDIpIC0gMik7CglzcHJpbnRmKHRtcCwgbXNnLCBjbWQsIGNtZDIpOwoJbXNnc1tFUlJPUl9XT1VMRF9PVkVSV1JJVEVdID0gdG1wOwoJbXNnc1tFUlJPUl9OT1RfVVBUT0RBVEVfRklMRV0gPSB0bXA7CgoJbXNnc1tFUlJPUl9OT1RfVVBUT0RBVEVfRElSXSA9CgkJIlVwZGF0aW5nIHRoZSBmb2xsb3dpbmcgZGlyZWN0b3JpZXMgd291bGQgbG9zZSB1bnRyYWNrZWQgZmlsZXMgaW4gaXQ6XG4lcyI7CgoJaWYgKGFkdmljZV9jb21taXRfYmVmb3JlX21lcmdlKQoJCW1zZyA9ICJUaGUgZm9sbG93aW5nIHVudHJhY2tlZCB3b3JraW5nIHRyZWUgZmlsZXMgd291bGQgYmUgJXMgYnkgJXM6XG4lJXMiCgkJCSJQbGVhc2UgbW92ZSBvciByZW1vdmUgdGhlbSBiZWZvcmUgeW91IGNhbiAlcy4iOwoJZWxzZQoJCW1zZyA9ICJUaGUgZm9sbG93aW5nIHVudHJhY2tlZCB3b3JraW5nIHRyZWUgZmlsZXMgd291bGQgYmUgJXMgYnkgJXM6XG4lJXMiOwoJdG1wID0geG1hbGxvYyhzdHJsZW4obXNnKSArIHN0cmxlbihjbWQpICsgc3RybGVuKCJyZW1vdmVkIikgKyBzdHJsZW4oY21kMikgLSA0KTsKCXNwcmludGYodG1wLCBtc2csICJyZW1vdmVkIiwgY21kLCBjbWQyKTsKCW1zZ3NbRVJST1JfV09VTERfTE9TRV9VTlRSQUNLRURfUkVNT1ZFRF0gPSB0bXA7Cgl0bXAgPSB4bWFsbG9jKHN0cmxlbihtc2cpICsgc3RybGVuKGNtZCkgKyBzdHJsZW4oIm92ZXJ3cml0dGVuIikgKyBzdHJsZW4oY21kMikgLSA0KTsKCXNwcmludGYodG1wLCBtc2csICJvdmVyd3JpdHRlbiIsIGNtZCwgY21kMik7Cgltc2dzW0VSUk9SX1dPVUxEX0xPU0VfVU5UUkFDS0VEX09WRVJXUklUVEVOXSA9IHRtcDsKCgkvKgoJICogU3BlY2lhbCBjYXNlOiBFUlJPUl9CSU5EX09WRVJMQVAgcmVmZXJzIHRvIGEgcGFpciBvZiBwYXRocywgd2UKCSAqIGNhbm5vdCBlYXNpbHkgZGlzcGxheSBpdCBhcyBhIGxpc3QuCgkgKi8KCW1zZ3NbRVJST1JfQklORF9PVkVSTEFQXSA9ICJFbnRyeSAnJXMnIG92ZXJsYXBzIHdpdGggJyVzJy4gIENhbm5vdCBiaW5kLiI7CgoJbXNnc1tFUlJPUl9TUEFSU0VfTk9UX1VQVE9EQVRFX0ZJTEVdID0KCQkiQ2Fubm90IHVwZGF0ZSBzcGFyc2UgY2hlY2tvdXQ6IHRoZSBmb2xsb3dpbmcgZW50cmllcyBhcmUgbm90IHVwLXRvLWRhdGU6XG4lcyI7Cgltc2dzW0VSUk9SX1dPVUxEX0xPU0VfT1JQSEFORURfT1ZFUldSSVRURU5dID0KCQkiVGhlIGZvbGxvd2luZyBXb3JraW5nIHRyZWUgZmlsZXMgd291bGQgYmUgb3ZlcndyaXR0ZW4gYnkgc3BhcnNlIGNoZWNrb3V0IHVwZGF0ZTpcbiVzIjsKCW1zZ3NbRVJST1JfV09VTERfTE9TRV9PUlBIQU5FRF9SRU1PVkVEXSA9CgkJIlRoZSBmb2xsb3dpbmcgV29ya2luZyB0cmVlIGZpbGVzIHdvdWxkIGJlIHJlbW92ZWQgYnkgc3BhcnNlIGNoZWNrb3V0IHVwZGF0ZTpcbiVzIjsKCglvcHRzLT5zaG93X2FsbF9lcnJvcnMgPSAxOwoJLyogcmVqZWN0ZWQgcGF0aHMgbWF5IG5vdCBoYXZlIGEgc3RhdGljIGJ1ZmZlciAqLwoJZm9yIChpID0gMDsgaSA8IEFSUkFZX1NJWkUob3B0cy0+dW5wYWNrX3JlamVjdHMpOyBpKyspCgkJb3B0cy0+dW5wYWNrX3JlamVjdHNbaV0uc3RyZHVwX3N0cmluZ3MgPSAxOwp9CgpzdGF0aWMgdm9pZCBkb19hZGRfZW50cnkoc3RydWN0IHVucGFja190cmVlc19vcHRpb25zICpvLCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlLAoJCQkgdW5zaWduZWQgaW50IHNldCwgdW5zaWduZWQgaW50IGNsZWFyKQp7CgljbGVhciB8PSBDRV9IQVNIRUQgfCBDRV9VTkhBU0hFRDsKCglpZiAoc2V0ICYgQ0VfUkVNT1ZFKQoJCXNldCB8PSBDRV9XVF9SRU1PVkU7CgoJY2UtPm5leHQgPSBOVUxMOwoJY2UtPmNlX2ZsYWdzID0gKGNlLT5jZV9mbGFncyAmIH5jbGVhcikgfCBzZXQ7CglhZGRfaW5kZXhfZW50cnkoJm8tPnJlc3VsdCwgY2UsCgkJCUFERF9DQUNIRV9PS19UT19BREQgfCBBRERfQ0FDSEVfT0tfVE9fUkVQTEFDRSk7Cn0KCnN0YXRpYyB2b2lkIGFkZF9lbnRyeShzdHJ1Y3QgdW5wYWNrX3RyZWVzX29wdGlvbnMgKm8sIHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UsCgl1bnNpZ25lZCBpbnQgc2V0LCB1bnNpZ25lZCBpbnQgY2xlYXIpCnsKCXVuc2lnbmVkIGludCBzaXplID0gY2Vfc2l6ZShjZSk7CglzdHJ1Y3QgY2FjaGVfZW50cnkgKm5ldyA9IHhtYWxsb2Moc2l6ZSk7CgoJbWVtY3B5KG5ldywgY2UsIHNpemUpOwoJZG9fYWRkX2VudHJ5KG8sIG5ldywgc2V0LCBjbGVhcik7Cn0KCi8qCiAqIGFkZCBlcnJvciBtZXNzYWdlcyBvbiBwYXRoIDxwYXRoPgogKiBjb3JyZXNwb25kaW5nIHRvIHRoZSB0eXBlIDxlPiB3aXRoIHRoZSBtZXNzYWdlIDxtc2c+CiAqIGluZGljYXRpbmcgaWYgaXQgc2hvdWxkIGJlIGRpc3BsYXkgaW4gcG9yY2VsYWluIG9yIG5vdAogKi8Kc3RhdGljIGludCBhZGRfcmVqZWN0ZWRfcGF0aChzdHJ1Y3QgdW5wYWNrX3RyZWVzX29wdGlvbnMgKm8sCgkJCSAgICAgZW51bSB1bnBhY2tfdHJlZXNfZXJyb3JfdHlwZXMgZSwKCQkJICAgICBjb25zdCBjaGFyICpwYXRoKQp7CglpZiAoIW8tPnNob3dfYWxsX2Vycm9ycykKCQlyZXR1cm4gZXJyb3IoRVJST1JNU0cobywgZSksIHBhdGgpOwoKCS8qCgkgKiBPdGhlcndpc2UsIGluc2VydCBpbiBhIGxpc3QgZm9yIGZ1dHVyZSBkaXNwbGF5IGJ5CgkgKiBkaXNwbGF5X2Vycm9yX21zZ3MoKQoJICovCglzdHJpbmdfbGlzdF9hcHBlbmQoJm8tPnVucGFja19yZWplY3RzW2VdLCBwYXRoKTsKCXJldHVybiAtMTsKfQoKLyoKICogZGlzcGxheSBhbGwgdGhlIGVycm9yIG1lc3NhZ2VzIHN0b3JlZCBpbiBhIG5pY2Ugd2F5CiAqLwpzdGF0aWMgdm9pZCBkaXNwbGF5X2Vycm9yX21zZ3Moc3RydWN0IHVucGFja190cmVlc19vcHRpb25zICpvKQp7CglpbnQgZSwgaTsKCWludCBzb21ldGhpbmdfZGlzcGxheWVkID0gMDsKCWZvciAoZSA9IDA7IGUgPCBOQl9VTlBBQ0tfVFJFRVNfRVJST1JfVFlQRVM7IGUrKykgewoJCXN0cnVjdCBzdHJpbmdfbGlzdCAqcmVqZWN0cyA9ICZvLT51bnBhY2tfcmVqZWN0c1tlXTsKCQlpZiAocmVqZWN0cy0+bnIgPiAwKSB7CgkJCXN0cnVjdCBzdHJidWYgcGF0aCA9IFNUUkJVRl9JTklUOwoJCQlzb21ldGhpbmdfZGlzcGxheWVkID0gMTsKCQkJZm9yIChpID0gMDsgaSA8IHJlamVjdHMtPm5yOyBpKyspCgkJCQlzdHJidWZfYWRkZigmcGF0aCwgIlx0JXNcbiIsIHJlamVjdHMtPml0ZW1zW2ldLnN0cmluZyk7CgkJCWVycm9yKEVSUk9STVNHKG8sIGUpLCBwYXRoLmJ1Zik7CgkJCXN0cmJ1Zl9yZWxlYXNlKCZwYXRoKTsKCQl9CgkJc3RyaW5nX2xpc3RfY2xlYXIocmVqZWN0cywgMCk7Cgl9CglpZiAoc29tZXRoaW5nX2Rpc3BsYXllZCkKCQlmcHJpbnRmKHN0ZGVyciwgIkFib3J0aW5nXG4iKTsKfQoKLyoKICogVW5saW5rIHRoZSBsYXN0IGNvbXBvbmVudCBhbmQgc2NoZWR1bGUgdGhlIGxlYWRpbmcgZGlyZWN0b3JpZXMgZm9yCiAqIHJlbW92YWwsIHN1Y2ggdGhhdCBlbXB0eSBkaXJlY3RvcmllcyBnZXQgcmVtb3ZlZC4KICovCnN0YXRpYyB2b2lkIHVubGlua19lbnRyeShzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlKQp7CglpZiAoIWNoZWNrX2xlYWRpbmdfcGF0aChjZS0+bmFtZSwgY2VfbmFtZWxlbihjZSkpKQoJCXJldHVybjsKCWlmIChyZW1vdmVfb3Jfd2FybihjZS0+Y2VfbW9kZSwgY2UtPm5hbWUpKQoJCXJldHVybjsKCXNjaGVkdWxlX2Rpcl9mb3JfcmVtb3ZhbChjZS0+bmFtZSwgY2VfbmFtZWxlbihjZSkpOwp9CgpzdGF0aWMgc3RydWN0IGNoZWNrb3V0IHN0YXRlOwpzdGF0aWMgaW50IGNoZWNrX3VwZGF0ZXMoc3RydWN0IHVucGFja190cmVlc19vcHRpb25zICpvKQp7Cgl1bnNpZ25lZCBjbnQgPSAwLCB0b3RhbCA9IDA7CglzdHJ1Y3QgcHJvZ3Jlc3MgKnByb2dyZXNzID0gTlVMTDsKCXN0cnVjdCBpbmRleF9zdGF0ZSAqaW5kZXggPSAmby0+cmVzdWx0OwoJaW50IGk7CglpbnQgZXJycyA9IDA7CgoJaWYgKG8tPnVwZGF0ZSAmJiBvLT52ZXJib3NlX3VwZGF0ZSkgewoJCWZvciAodG90YWwgPSBjbnQgPSAwOyBjbnQgPCBpbmRleC0+Y2FjaGVfbnI7IGNudCsrKSB7CgkJCXN0cnVjdCBjYWNoZV9lbnRyeSAqY2UgPSBpbmRleC0+Y2FjaGVbY250XTsKCQkJaWYgKGNlLT5jZV9mbGFncyAmIChDRV9VUERBVEUgfCBDRV9XVF9SRU1PVkUpKQoJCQkJdG90YWwrKzsKCQl9CgoJCXByb2dyZXNzID0gc3RhcnRfcHJvZ3Jlc3NfZGVsYXkoIkNoZWNraW5nIG91dCBmaWxlcyIsCgkJCQkJCXRvdGFsLCA1MCwgMSk7CgkJY250ID0gMDsKCX0KCglpZiAoby0+dXBkYXRlKQoJCWdpdF9hdHRyX3NldF9kaXJlY3Rpb24oR0lUX0FUVFJfQ0hFQ0tPVVQsICZvLT5yZXN1bHQpOwoJZm9yIChpID0gMDsgaSA8IGluZGV4LT5jYWNoZV9ucjsgaSsrKSB7CgkJc3RydWN0IGNhY2hlX2VudHJ5ICpjZSA9IGluZGV4LT5jYWNoZVtpXTsKCgkJaWYgKGNlLT5jZV9mbGFncyAmIENFX1dUX1JFTU9WRSkgewoJCQlkaXNwbGF5X3Byb2dyZXNzKHByb2dyZXNzLCArK2NudCk7CgkJCWlmIChvLT51cGRhdGUgJiYgIW8tPmRyeV9ydW4pCgkJCQl1bmxpbmtfZW50cnkoY2UpOwoJCQljb250aW51ZTsKCQl9Cgl9CglyZW1vdmVfbWFya2VkX2NhY2hlX2VudHJpZXMoJm8tPnJlc3VsdCk7CglyZW1vdmVfc2NoZWR1bGVkX2RpcnMoKTsKCglmb3IgKGkgPSAwOyBpIDwgaW5kZXgtPmNhY2hlX25yOyBpKyspIHsKCQlzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlID0gaW5kZXgtPmNhY2hlW2ldOwoKCQlpZiAoY2UtPmNlX2ZsYWdzICYgQ0VfVVBEQVRFKSB7CgkJCWRpc3BsYXlfcHJvZ3Jlc3MocHJvZ3Jlc3MsICsrY250KTsKCQkJY2UtPmNlX2ZsYWdzICY9IH5DRV9VUERBVEU7CgkJCWlmIChvLT51cGRhdGUgJiYgIW8tPmRyeV9ydW4pIHsKCQkJCWVycnMgfD0gY2hlY2tvdXRfZW50cnkoY2UsICZzdGF0ZSwgTlVMTCk7CgkJCX0KCQl9Cgl9CglzdG9wX3Byb2dyZXNzKCZwcm9ncmVzcyk7CglpZiAoby0+dXBkYXRlKQoJCWdpdF9hdHRyX3NldF9kaXJlY3Rpb24oR0lUX0FUVFJfQ0hFQ0tJTiwgTlVMTCk7CglyZXR1cm4gZXJycyAhPSAwOwp9CgpzdGF0aWMgaW50IHZlcmlmeV91cHRvZGF0ZV9zcGFyc2Uoc3RydWN0IGNhY2hlX2VudHJ5ICpjZSwgc3RydWN0IHVucGFja190cmVlc19vcHRpb25zICpvKTsKc3RhdGljIGludCB2ZXJpZnlfYWJzZW50X3NwYXJzZShzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlLCBlbnVtIHVucGFja190cmVlc19lcnJvcl90eXBlcywgc3RydWN0IHVucGFja190cmVlc19vcHRpb25zICpvKTsKCnN0YXRpYyBpbnQgYXBwbHlfc3BhcnNlX2NoZWNrb3V0KHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UsIHN0cnVjdCB1bnBhY2tfdHJlZXNfb3B0aW9ucyAqbykKewoJaW50IHdhc19za2lwX3dvcmt0cmVlID0gY2Vfc2tpcF93b3JrdHJlZShjZSk7CgoJaWYgKGNlLT5jZV9mbGFncyAmIENFX05FV19TS0lQX1dPUktUUkVFKQoJCWNlLT5jZV9mbGFncyB8PSBDRV9TS0lQX1dPUktUUkVFOwoJZWxzZQoJCWNlLT5jZV9mbGFncyAmPSB+Q0VfU0tJUF9XT1JLVFJFRTsKCgkvKgoJICogaWYgKCF3YXNfc2tpcF93b3JrdHJlZSAmJiAhY2Vfc2tpcF93b3JrdHJlZSgpKSB7CgkgKglUaGlzIGlzIHBlcmZlY3RseSBub3JtYWwuIE1vdmUgb247CgkgKiB9CgkgKi8KCgkvKgoJICogTWVyZ2Ugc3RyYXRlZ2llcyBtYXkgc2V0IENFX1VQREFURXxDRV9SRU1PVkUgb3V0c2lkZSBjaGVja291dAoJICogYXJlYSBhcyBhIHJlc3VsdCBvZiBjZV9za2lwX3dvcmt0cmVlKCkgc2hvcnRjdXRzIGluCgkgKiB2ZXJpZnlfYWJzZW50KCkgYW5kIHZlcmlmeV91cHRvZGF0ZSgpLgoJICogTWFrZSBzdXJlIHRoZXkgZG9uJ3QgbW9kaWZ5IHdvcmt0cmVlIGlmIHRoZXkgYXJlIGFscmVhZHkKCSAqIG91dHNpZGUgY2hlY2tvdXQgYXJlYQoJICovCglpZiAod2FzX3NraXBfd29ya3RyZWUgJiYgY2Vfc2tpcF93b3JrdHJlZShjZSkpIHsKCQljZS0+Y2VfZmxhZ3MgJj0gfkNFX1VQREFURTsKCgkJLyoKCQkgKiBCeSBkZWZhdWx0LCB3aGVuIENFX1JFTU9WRSBpcyBvbiwgQ0VfV1RfUkVNT1ZFIGlzIGFsc28KCQkgKiBvbiB0byBnZXQgdGhhdCBmaWxlIHJlbW92ZWQgZnJvbSBib3RoIGluZGV4IGFuZCB3b3JrdHJlZS4KCQkgKiBJZiB0aGF0IGZpbGUgaXMgYWxyZWFkeSBvdXRzaWRlIHdvcmt0cmVlIGFyZWEsIGRvbid0CgkJICogYm90aGVyIHJlbW92ZSBpdC4KCQkgKi8KCQlpZiAoY2UtPmNlX2ZsYWdzICYgQ0VfUkVNT1ZFKQoJCQljZS0+Y2VfZmxhZ3MgJj0gfkNFX1dUX1JFTU9WRTsKCX0KCglpZiAoIXdhc19za2lwX3dvcmt0cmVlICYmIGNlX3NraXBfd29ya3RyZWUoY2UpKSB7CgkJLyoKCQkgKiBJZiBDRV9VUERBVEUgaXMgc2V0LCB2ZXJpZnlfdXB0b2RhdGUoKSBtdXN0IGJlIGNhbGxlZCBhbHJlYWR5CgkJICogYWxzbyBzdGF0IGluZm8gbWF5IGhhdmUgbG9zdCBhZnRlciBtZXJnZWRfZW50cnkoKSBzbyBjYWxsaW5nCgkJICogdmVyaWZ5X3VwdG9kYXRlKCkgYWdhaW4gbWF5IGZhaWwKCQkgKi8KCQlpZiAoIShjZS0+Y2VfZmxhZ3MgJiBDRV9VUERBVEUpICYmIHZlcmlmeV91cHRvZGF0ZV9zcGFyc2UoY2UsIG8pKQoJCQlyZXR1cm4gLTE7CgkJY2UtPmNlX2ZsYWdzIHw9IENFX1dUX1JFTU9WRTsKCX0KCWlmICh3YXNfc2tpcF93b3JrdHJlZSAmJiAhY2Vfc2tpcF93b3JrdHJlZShjZSkpIHsKCQlpZiAodmVyaWZ5X2Fic2VudF9zcGFyc2UoY2UsIEVSUk9SX1dPVUxEX0xPU0VfVU5UUkFDS0VEX09WRVJXUklUVEVOLCBvKSkKCQkJcmV0dXJuIC0xOwoJCWNlLT5jZV9mbGFncyB8PSBDRV9VUERBVEU7Cgl9CglyZXR1cm4gMDsKfQoKc3RhdGljIGlubGluZSBpbnQgY2FsbF91bnBhY2tfZm4oc3RydWN0IGNhY2hlX2VudHJ5ICoqc3JjLCBzdHJ1Y3QgdW5wYWNrX3RyZWVzX29wdGlvbnMgKm8pCnsKCWludCByZXQgPSBvLT5mbihzcmMsIG8pOwoJaWYgKHJldCA+IDApCgkJcmV0ID0gMDsKCXJldHVybiByZXQ7Cn0KCnN0YXRpYyB2b2lkIG1hcmtfY2VfdXNlZChzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlLCBzdHJ1Y3QgdW5wYWNrX3RyZWVzX29wdGlvbnMgKm8pCnsKCWNlLT5jZV9mbGFncyB8PSBDRV9VTlBBQ0tFRDsKCglpZiAoby0+Y2FjaGVfYm90dG9tIDwgby0+c3JjX2luZGV4LT5jYWNoZV9uciAmJgoJICAgIG8tPnNyY19pbmRleC0+Y2FjaGVbby0+Y2FjaGVfYm90dG9tXSA9PSBjZSkgewoJCWludCBib3R0b20gPSBvLT5jYWNoZV9ib3R0b207CgkJd2hpbGUgKGJvdHRvbSA8IG8tPnNyY19pbmRleC0+Y2FjaGVfbnIgJiYKCQkgICAgICAgby0+c3JjX2luZGV4LT5jYWNoZVtib3R0b21dLT5jZV9mbGFncyAmIENFX1VOUEFDS0VEKQoJCQlib3R0b20rKzsKCQlvLT5jYWNoZV9ib3R0b20gPSBib3R0b207Cgl9Cn0KCnN0YXRpYyB2b2lkIG1hcmtfYWxsX2NlX3VudXNlZChzdHJ1Y3QgaW5kZXhfc3RhdGUgKmluZGV4KQp7CglpbnQgaTsKCWZvciAoaSA9IDA7IGkgPCBpbmRleC0+Y2FjaGVfbnI7IGkrKykKCQlpbmRleC0+Y2FjaGVbaV0tPmNlX2ZsYWdzICY9IH4oQ0VfVU5QQUNLRUQgfCBDRV9BRERFRCB8IENFX05FV19TS0lQX1dPUktUUkVFKTsKfQoKc3RhdGljIGludCBsb2NhdGVfaW5fc3JjX2luZGV4KHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UsCgkJCSAgICAgICBzdHJ1Y3QgdW5wYWNrX3RyZWVzX29wdGlvbnMgKm8pCnsKCXN0cnVjdCBpbmRleF9zdGF0ZSAqaW5kZXggPSBvLT5zcmNfaW5kZXg7CglpbnQgbGVuID0gY2VfbmFtZWxlbihjZSk7CglpbnQgcG9zID0gaW5kZXhfbmFtZV9wb3MoaW5kZXgsIGNlLT5uYW1lLCBsZW4pOwoJaWYgKHBvcyA8IDApCgkJcG9zID0gLTEgLSBwb3M7CglyZXR1cm4gcG9zOwp9CgovKgogKiBXZSBjYWxsIHVucGFja19pbmRleF9lbnRyeSgpIHdpdGggYW4gdW5tZXJnZWQgY2FjaGUgZW50cnkKICogb25seSBpbiBkaWZmLWluZGV4LCBhbmQgaXQgd2FudHMgYSBzaW5nbGUgY2FsbGJhY2suICBTa2lwCiAqIHRoZSBvdGhlciB1bm1lcmdlZCBlbnRyeSB3aXRoIHRoZSBzYW1lIG5hbWUuCiAqLwpzdGF0aWMgdm9pZCBtYXJrX2NlX3VzZWRfc2FtZV9uYW1lKHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UsCgkJCQkgICBzdHJ1Y3QgdW5wYWNrX3RyZWVzX29wdGlvbnMgKm8pCnsKCXN0cnVjdCBpbmRleF9zdGF0ZSAqaW5kZXggPSBvLT5zcmNfaW5kZXg7CglpbnQgbGVuID0gY2VfbmFtZWxlbihjZSk7CglpbnQgcG9zOwoKCWZvciAocG9zID0gbG9jYXRlX2luX3NyY19pbmRleChjZSwgbyk7IHBvcyA8IGluZGV4LT5jYWNoZV9ucjsgcG9zKyspIHsKCQlzdHJ1Y3QgY2FjaGVfZW50cnkgKm5leHQgPSBpbmRleC0+Y2FjaGVbcG9zXTsKCQlpZiAobGVuICE9IGNlX25hbWVsZW4obmV4dCkgfHwKCQkgICAgbWVtY21wKGNlLT5uYW1lLCBuZXh0LT5uYW1lLCBsZW4pKQoJCQlicmVhazsKCQltYXJrX2NlX3VzZWQobmV4dCwgbyk7Cgl9Cn0KCnN0YXRpYyBzdHJ1Y3QgY2FjaGVfZW50cnkgKm5leHRfY2FjaGVfZW50cnkoc3RydWN0IHVucGFja190cmVlc19vcHRpb25zICpvKQp7Cgljb25zdCBzdHJ1Y3QgaW5kZXhfc3RhdGUgKmluZGV4ID0gby0+c3JjX2luZGV4OwoJaW50IHBvcyA9IG8tPmNhY2hlX2JvdHRvbTsKCgl3aGlsZSAocG9zIDwgaW5kZXgtPmNhY2hlX25yKSB7CgkJc3RydWN0IGNhY2hlX2VudHJ5ICpjZSA9IGluZGV4LT5jYWNoZVtwb3NdOwoJCWlmICghKGNlLT5jZV9mbGFncyAmIENFX1VOUEFDS0VEKSkKCQkJcmV0dXJuIGNlOwoJCXBvcysrOwoJfQoJcmV0dXJuIE5VTEw7Cn0KCnN0YXRpYyB2b2lkIGFkZF9zYW1lX3VubWVyZ2VkKHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UsCgkJCSAgICAgIHN0cnVjdCB1bnBhY2tfdHJlZXNfb3B0aW9ucyAqbykKewoJc3RydWN0IGluZGV4X3N0YXRlICppbmRleCA9IG8tPnNyY19pbmRleDsKCWludCBsZW4gPSBjZV9uYW1lbGVuKGNlKTsKCWludCBwb3MgPSBpbmRleF9uYW1lX3BvcyhpbmRleCwgY2UtPm5hbWUsIGxlbik7CgoJaWYgKDAgPD0gcG9zKQoJCWRpZSgicHJvZ3JhbW1pbmcgZXJyb3IgaW4gYSBjYWxsZXIgb2YgbWFya19jZV91c2VkX3NhbWVfbmFtZSIpOwoJZm9yIChwb3MgPSAtcG9zIC0gMTsgcG9zIDwgaW5kZXgtPmNhY2hlX25yOyBwb3MrKykgewoJCXN0cnVjdCBjYWNoZV9lbnRyeSAqbmV4dCA9IGluZGV4LT5jYWNoZVtwb3NdOwoJCWlmIChsZW4gIT0gY2VfbmFtZWxlbihuZXh0KSB8fAoJCSAgICBtZW1jbXAoY2UtPm5hbWUsIG5leHQtPm5hbWUsIGxlbikpCgkJCWJyZWFrOwoJCWFkZF9lbnRyeShvLCBuZXh0LCAwLCAwKTsKCQltYXJrX2NlX3VzZWQobmV4dCwgbyk7Cgl9Cn0KCnN0YXRpYyBpbnQgdW5wYWNrX2luZGV4X2VudHJ5KHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UsCgkJCSAgICAgIHN0cnVjdCB1bnBhY2tfdHJlZXNfb3B0aW9ucyAqbykKewoJc3RydWN0IGNhY2hlX2VudHJ5ICpzcmNbTUFYX1VOUEFDS19UUkVFUyArIDFdID0geyBOVUxMLCB9OwoJaW50IHJldDsKCglzcmNbMF0gPSBjZTsKCgltYXJrX2NlX3VzZWQoY2UsIG8pOwoJaWYgKGNlX3N0YWdlKGNlKSkgewoJCWlmIChvLT5za2lwX3VubWVyZ2VkKSB7CgkJCWFkZF9lbnRyeShvLCBjZSwgMCwgMCk7CgkJCXJldHVybiAwOwoJCX0KCX0KCXJldCA9IGNhbGxfdW5wYWNrX2ZuKHNyYywgbyk7CglpZiAoY2Vfc3RhZ2UoY2UpKQoJCW1hcmtfY2VfdXNlZF9zYW1lX25hbWUoY2UsIG8pOwoJcmV0dXJuIHJldDsKfQoKc3RhdGljIGludCBmaW5kX2NhY2hlX3BvcyhzdHJ1Y3QgdHJhdmVyc2VfaW5mbyAqLCBjb25zdCBzdHJ1Y3QgbmFtZV9lbnRyeSAqKTsKCnN0YXRpYyB2b2lkIHJlc3RvcmVfY2FjaGVfYm90dG9tKHN0cnVjdCB0cmF2ZXJzZV9pbmZvICppbmZvLCBpbnQgYm90dG9tKQp7CglzdHJ1Y3QgdW5wYWNrX3RyZWVzX29wdGlvbnMgKm8gPSBpbmZvLT5kYXRhOwoKCWlmIChvLT5kaWZmX2luZGV4X2NhY2hlZCkKCQlyZXR1cm47CglvLT5jYWNoZV9ib3R0b20gPSBib3R0b207Cn0KCnN0YXRpYyBpbnQgc3dpdGNoX2NhY2hlX2JvdHRvbShzdHJ1Y3QgdHJhdmVyc2VfaW5mbyAqaW5mbykKewoJc3RydWN0IHVucGFja190cmVlc19vcHRpb25zICpvID0gaW5mby0+ZGF0YTsKCWludCByZXQsIHBvczsKCglpZiAoby0+ZGlmZl9pbmRleF9jYWNoZWQpCgkJcmV0dXJuIDA7CglyZXQgPSBvLT5jYWNoZV9ib3R0b207Cglwb3MgPSBmaW5kX2NhY2hlX3BvcyhpbmZvLT5wcmV2LCAmaW5mby0+bmFtZSk7CgoJaWYgKHBvcyA8IC0xKQoJCW8tPmNhY2hlX2JvdHRvbSA9IC0yIC0gcG9zOwoJZWxzZSBpZiAocG9zIDwgMCkKCQlvLT5jYWNoZV9ib3R0b20gPSBvLT5zcmNfaW5kZXgtPmNhY2hlX25yOwoJcmV0dXJuIHJldDsKfQoKc3RhdGljIGludCB0cmF2ZXJzZV90cmVlc19yZWN1cnNpdmUoaW50IG4sIHVuc2lnbmVkIGxvbmcgZGlybWFzaywKCQkJCSAgICB1bnNpZ25lZCBsb25nIGRmX2NvbmZsaWN0cywKCQkJCSAgICBzdHJ1Y3QgbmFtZV9lbnRyeSAqbmFtZXMsCgkJCQkgICAgc3RydWN0IHRyYXZlcnNlX2luZm8gKmluZm8pCnsKCWludCBpLCByZXQsIGJvdHRvbTsKCXN0cnVjdCB0cmVlX2Rlc2MgdFtNQVhfVU5QQUNLX1RSRUVTXTsKCXZvaWQgKmJ1ZltNQVhfVU5QQUNLX1RSRUVTXTsKCXN0cnVjdCB0cmF2ZXJzZV9pbmZvIG5ld2luZm87CglzdHJ1Y3QgbmFtZV9lbnRyeSAqcDsKCglwID0gbmFtZXM7Cgl3aGlsZSAoIXAtPm1vZGUpCgkJcCsrOwoKCW5ld2luZm8gPSAqaW5mbzsKCW5ld2luZm8ucHJldiA9IGluZm87CgluZXdpbmZvLnBhdGhzcGVjID0gaW5mby0+cGF0aHNwZWM7CgluZXdpbmZvLm5hbWUgPSAqcDsKCW5ld2luZm8ucGF0aGxlbiArPSB0cmVlX2VudHJ5X2xlbihwKSArIDE7CgluZXdpbmZvLmNvbmZsaWN0cyB8PSBkZl9jb25mbGljdHM7CgoJZm9yIChpID0gMDsgaSA8IG47IGkrKywgZGlybWFzayA+Pj0gMSkgewoJCWNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEgPSBOVUxMOwoJCWlmIChkaXJtYXNrICYgMSkKCQkJc2hhMSA9IG5hbWVzW2ldLnNoYTE7CgkJYnVmW2ldID0gZmlsbF90cmVlX2Rlc2NyaXB0b3IodCtpLCBzaGExKTsKCX0KCglib3R0b20gPSBzd2l0Y2hfY2FjaGVfYm90dG9tKCZuZXdpbmZvKTsKCXJldCA9IHRyYXZlcnNlX3RyZWVzKG4sIHQsICZuZXdpbmZvKTsKCXJlc3RvcmVfY2FjaGVfYm90dG9tKCZuZXdpbmZvLCBib3R0b20pOwoKCWZvciAoaSA9IDA7IGkgPCBuOyBpKyspCgkJZnJlZShidWZbaV0pOwoKCXJldHVybiByZXQ7Cn0KCi8qCiAqIENvbXBhcmUgdGhlIHRyYXZlcnNlLXBhdGggdG8gdGhlIGNhY2hlIGVudHJ5IHdpdGhvdXQgYWN0dWFsbHkKICogaGF2aW5nIHRvIGdlbmVyYXRlIHRoZSB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0cmF2ZXJzZQogKiBwYXRoLgogKgogKiBOT1RFISBUaGlzICpvbmx5KiBjb21wYXJlcyB1cCB0byB0aGUgc2l6ZSBvZiB0aGUgdHJhdmVyc2UgcGF0aAogKiBpdHNlbGYgLSB0aGUgY2FsbGVyIG5lZWRzIHRvIGRvIHRoZSBmaW5hbCBjaGVjayBmb3IgdGhlIGNhY2hlCiAqIGVudHJ5IGhhdmluZyBtb3JlIGRhdGEgYXQgdGhlIGVuZCEKICovCnN0YXRpYyBpbnQgZG9fY29tcGFyZV9lbnRyeShjb25zdCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlLCBjb25zdCBzdHJ1Y3QgdHJhdmVyc2VfaW5mbyAqaW5mbywgY29uc3Qgc3RydWN0IG5hbWVfZW50cnkgKm4pCnsKCWludCBsZW4sIHBhdGhsZW4sIGNlX2xlbjsKCWNvbnN0IGNoYXIgKmNlX25hbWU7CgoJaWYgKGluZm8tPnByZXYpIHsKCQlpbnQgY21wID0gZG9fY29tcGFyZV9lbnRyeShjZSwgaW5mby0+cHJldiwgJmluZm8tPm5hbWUpOwoJCWlmIChjbXApCgkJCXJldHVybiBjbXA7Cgl9CglwYXRobGVuID0gaW5mby0+cGF0aGxlbjsKCWNlX2xlbiA9IGNlX25hbWVsZW4oY2UpOwoKCS8qIElmIGNlX2xlbiA8IHBhdGhsZW4gdGhlbiB3ZSBtdXN0IGhhdmUgcHJldmlvdXNseSBoaXQgIm5hbWUgPT0gZGlyZWN0b3J5IiBlbnRyeSAqLwoJaWYgKGNlX2xlbiA8IHBhdGhsZW4pCgkJcmV0dXJuIC0xOwoKCWNlX2xlbiAtPSBwYXRobGVuOwoJY2VfbmFtZSA9IGNlLT5uYW1lICsgcGF0aGxlbjsKCglsZW4gPSB0cmVlX2VudHJ5X2xlbihuKTsKCXJldHVybiBkZl9uYW1lX2NvbXBhcmUoY2VfbmFtZSwgY2VfbGVuLCBTX0lGUkVHLCBuLT5wYXRoLCBsZW4sIG4tPm1vZGUpOwp9CgpzdGF0aWMgaW50IGNvbXBhcmVfZW50cnkoY29uc3Qgc3RydWN0IGNhY2hlX2VudHJ5ICpjZSwgY29uc3Qgc3RydWN0IHRyYXZlcnNlX2luZm8gKmluZm8sIGNvbnN0IHN0cnVjdCBuYW1lX2VudHJ5ICpuKQp7CglpbnQgY21wID0gZG9fY29tcGFyZV9lbnRyeShjZSwgaW5mbywgbik7CglpZiAoY21wKQoJCXJldHVybiBjbXA7CgoJLyoKCSAqIEV2ZW4gaWYgdGhlIGJlZ2lubmluZyBjb21wYXJlZCBpZGVudGljYWxseSwgdGhlIGNlIHNob3VsZAoJICogY29tcGFyZSBhcyBiaWdnZXIgdGhhbiBhIGRpcmVjdG9yeSBsZWFkaW5nIHVwIHRvIGl0IQoJICovCglyZXR1cm4gY2VfbmFtZWxlbihjZSkgPiB0cmF2ZXJzZV9wYXRoX2xlbihpbmZvLCBuKTsKfQoKc3RhdGljIGludCBjZV9pbl90cmF2ZXJzZV9wYXRoKGNvbnN0IHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UsCgkJCSAgICAgICBjb25zdCBzdHJ1Y3QgdHJhdmVyc2VfaW5mbyAqaW5mbykKewoJaWYgKCFpbmZvLT5wcmV2KQoJCXJldHVybiAxOwoJaWYgKGRvX2NvbXBhcmVfZW50cnkoY2UsIGluZm8tPnByZXYsICZpbmZvLT5uYW1lKSkKCQlyZXR1cm4gMDsKCS8qCgkgKiBJZiBjZSAoYmxvYikgaXMgdGhlIHNhbWUgbmFtZSBhcyB0aGUgcGF0aCAod2hpY2ggaXMgYSB0cmVlCgkgKiB3ZSB3aWxsIGJlIGRlc2NlbmRpbmcgaW50byksIGl0IHdvbid0IGJlIGluc2lkZSBpdC4KCSAqLwoJcmV0dXJuIChpbmZvLT5wYXRobGVuIDwgY2VfbmFtZWxlbihjZSkpOwp9CgpzdGF0aWMgc3RydWN0IGNhY2hlX2VudHJ5ICpjcmVhdGVfY2VfZW50cnkoY29uc3Qgc3RydWN0IHRyYXZlcnNlX2luZm8gKmluZm8sIGNvbnN0IHN0cnVjdCBuYW1lX2VudHJ5ICpuLCBpbnQgc3RhZ2UpCnsKCWludCBsZW4gPSB0cmF2ZXJzZV9wYXRoX2xlbihpbmZvLCBuKTsKCXN0cnVjdCBjYWNoZV9lbnRyeSAqY2UgPSB4Y2FsbG9jKDEsIGNhY2hlX2VudHJ5X3NpemUobGVuKSk7CgoJY2UtPmNlX21vZGUgPSBjcmVhdGVfY2VfbW9kZShuLT5tb2RlKTsKCWNlLT5jZV9mbGFncyA9IGNyZWF0ZV9jZV9mbGFncyhzdGFnZSk7CgljZS0+Y2VfbmFtZWxlbiA9IGxlbjsKCWhhc2hjcHkoY2UtPnNoYTEsIG4tPnNoYTEpOwoJbWFrZV90cmF2ZXJzZV9wYXRoKGNlLT5uYW1lLCBpbmZvLCBuKTsKCglyZXR1cm4gY2U7Cn0KCnN0YXRpYyBpbnQgdW5wYWNrX25vbmRpcmVjdG9yaWVzKGludCBuLCB1bnNpZ25lZCBsb25nIG1hc2ssCgkJCQkgdW5zaWduZWQgbG9uZyBkaXJtYXNrLAoJCQkJIHN0cnVjdCBjYWNoZV9lbnRyeSAqKnNyYywKCQkJCSBjb25zdCBzdHJ1Y3QgbmFtZV9lbnRyeSAqbmFtZXMsCgkJCQkgY29uc3Qgc3RydWN0IHRyYXZlcnNlX2luZm8gKmluZm8pCnsKCWludCBpOwoJc3RydWN0IHVucGFja190cmVlc19vcHRpb25zICpvID0gaW5mby0+ZGF0YTsKCXVuc2lnbmVkIGxvbmcgY29uZmxpY3RzOwoKCS8qIERvIHdlIGhhdmUgKm9ubHkqIGRpcmVjdG9yaWVzPyBOb3RoaW5nIHRvIGRvICovCglpZiAobWFzayA9PSBkaXJtYXNrICYmICFzcmNbMF0pCgkJcmV0dXJuIDA7CgoJY29uZmxpY3RzID0gaW5mby0+Y29uZmxpY3RzOwoJaWYgKG8tPm1lcmdlKQoJCWNvbmZsaWN0cyA+Pj0gMTsKCWNvbmZsaWN0cyB8PSBkaXJtYXNrOwoKCS8qCgkgKiBPaywgd2UndmUgZmlsbGVkIGluIHVwIHRvIGFueSBwb3RlbnRpYWwgaW5kZXggZW50cnkgaW4gc3JjWzBdLAoJICogbm93IGRvIHRoZSByZXN0LgoJICovCglmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7CgkJaW50IHN0YWdlOwoJCXVuc2lnbmVkIGludCBiaXQgPSAxdWwgPDwgaTsKCQlpZiAoY29uZmxpY3RzICYgYml0KSB7CgkJCXNyY1tpICsgby0+bWVyZ2VdID0gby0+ZGZfY29uZmxpY3RfZW50cnk7CgkJCWNvbnRpbnVlOwoJCX0KCQlpZiAoIShtYXNrICYgYml0KSkKCQkJY29udGludWU7CgkJaWYgKCFvLT5tZXJnZSkKCQkJc3RhZ2UgPSAwOwoJCWVsc2UgaWYgKGkgKyAxIDwgby0+aGVhZF9pZHgpCgkJCXN0YWdlID0gMTsKCQllbHNlIGlmIChpICsgMSA+IG8tPmhlYWRfaWR4KQoJCQlzdGFnZSA9IDM7CgkJZWxzZQoJCQlzdGFnZSA9IDI7CgkJc3JjW2kgKyBvLT5tZXJnZV0gPSBjcmVhdGVfY2VfZW50cnkoaW5mbywgbmFtZXMgKyBpLCBzdGFnZSk7Cgl9CgoJaWYgKG8tPm1lcmdlKQoJCXJldHVybiBjYWxsX3VucGFja19mbihzcmMsIG8pOwoKCWZvciAoaSA9IDA7IGkgPCBuOyBpKyspCgkJaWYgKHNyY1tpXSAmJiBzcmNbaV0gIT0gby0+ZGZfY29uZmxpY3RfZW50cnkpCgkJCWRvX2FkZF9lbnRyeShvLCBzcmNbaV0sIDAsIDApOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgdW5wYWNrX2ZhaWxlZChzdHJ1Y3QgdW5wYWNrX3RyZWVzX29wdGlvbnMgKm8sIGNvbnN0IGNoYXIgKm1lc3NhZ2UpCnsKCWRpc2NhcmRfaW5kZXgoJm8tPnJlc3VsdCk7CglpZiAoIW8tPmdlbnRseSAmJiAhby0+ZXhpdGluZ19lYXJseSkgewoJCWlmIChtZXNzYWdlKQoJCQlyZXR1cm4gZXJyb3IoIiVzIiwgbWVzc2FnZSk7CgkJcmV0dXJuIC0xOwoJfQoJcmV0dXJuIC0xOwp9CgovKiBORUVEU1dPUks6IGdpdmUgdGhpcyBhIGJldHRlciBuYW1lIGFuZCBzaGFyZSB3aXRoIHRyZWUtd2Fsay5jICovCnN0YXRpYyBpbnQgbmFtZV9jb21wYXJlKGNvbnN0IGNoYXIgKmEsIGludCBhX2xlbiwKCQkJY29uc3QgY2hhciAqYiwgaW50IGJfbGVuKQp7CglpbnQgbGVuID0gKGFfbGVuIDwgYl9sZW4pID8gYV9sZW4gOiBiX2xlbjsKCWludCBjbXAgPSBtZW1jbXAoYSwgYiwgbGVuKTsKCWlmIChjbXApCgkJcmV0dXJuIGNtcDsKCXJldHVybiAoYV9sZW4gLSBiX2xlbik7Cn0KCi8qCiAqIFRoZSB0cmVlIHRyYXZlcnNhbCBpcyBsb29raW5nIGF0IG5hbWUgcC4gIElmIHdlIGhhdmUgYSBtYXRjaGluZyBlbnRyeSwKICogcmV0dXJuIGl0LiAgSWYgbmFtZSBwIGlzIGEgZGlyZWN0b3J5IGluIHRoZSBpbmRleCwgZG8gbm90IHJldHVybgogKiBhbnl0aGluZywgYXMgd2Ugd2lsbCB3YW50IHRvIG1hdGNoIGl0IHdoZW4gdGhlIHRyYXZlcnNhbCBkZXNjZW5kcyBpbnRvCiAqIHRoZSBkaXJlY3RvcnkuCiAqLwpzdGF0aWMgaW50IGZpbmRfY2FjaGVfcG9zKHN0cnVjdCB0cmF2ZXJzZV9pbmZvICppbmZvLAoJCQkgIGNvbnN0IHN0cnVjdCBuYW1lX2VudHJ5ICpwKQp7CglpbnQgcG9zOwoJc3RydWN0IHVucGFja190cmVlc19vcHRpb25zICpvID0gaW5mby0+ZGF0YTsKCXN0cnVjdCBpbmRleF9zdGF0ZSAqaW5kZXggPSBvLT5zcmNfaW5kZXg7CglpbnQgcGZ4bGVuID0gaW5mby0+cGF0aGxlbjsKCWludCBwX2xlbiA9IHRyZWVfZW50cnlfbGVuKHApOwoKCWZvciAocG9zID0gby0+Y2FjaGVfYm90dG9tOyBwb3MgPCBpbmRleC0+Y2FjaGVfbnI7IHBvcysrKSB7CgkJc3RydWN0IGNhY2hlX2VudHJ5ICpjZSA9IGluZGV4LT5jYWNoZVtwb3NdOwoJCWNvbnN0IGNoYXIgKmNlX25hbWUsICpjZV9zbGFzaDsKCQlpbnQgY21wLCBjZV9sZW47CgoJCWlmIChjZS0+Y2VfZmxhZ3MgJiBDRV9VTlBBQ0tFRCkgewoJCQkvKgoJCQkgKiBjYWNoZV9ib3R0b20gZW50cnkgaXMgYWxyZWFkeSB1bnBhY2tlZCwgc28KCQkJICogd2UgY2FuIG5ldmVyIG1hdGNoIGl0OyBkb24ndCBjaGVjayBpdAoJCQkgKiBhZ2Fpbi4KCQkJICovCgkJCWlmIChwb3MgPT0gby0+Y2FjaGVfYm90dG9tKQoJCQkJKytvLT5jYWNoZV9ib3R0b207CgkJCWNvbnRpbnVlOwoJCX0KCQlpZiAoIWNlX2luX3RyYXZlcnNlX3BhdGgoY2UsIGluZm8pKQoJCQljb250aW51ZTsKCQljZV9uYW1lID0gY2UtPm5hbWUgKyBwZnhsZW47CgkJY2Vfc2xhc2ggPSBzdHJjaHIoY2VfbmFtZSwgJy8nKTsKCQlpZiAoY2Vfc2xhc2gpCgkJCWNlX2xlbiA9IGNlX3NsYXNoIC0gY2VfbmFtZTsKCQllbHNlCgkJCWNlX2xlbiA9IGNlX25hbWVsZW4oY2UpIC0gcGZ4bGVuOwoJCWNtcCA9IG5hbWVfY29tcGFyZShwLT5wYXRoLCBwX2xlbiwgY2VfbmFtZSwgY2VfbGVuKTsKCQkvKgoJCSAqIEV4YWN0IG1hdGNoOyBpZiB3ZSBoYXZlIGEgZGlyZWN0b3J5IHdlIG5lZWQgdG8KCQkgKiBkZWxheSByZXR1cm5pbmcgaXQuCgkJICovCgkJaWYgKCFjbXApCgkJCXJldHVybiBjZV9zbGFzaCA/IC0yIC0gcG9zIDogcG9zOwoJCWlmICgwIDwgY21wKQoJCQljb250aW51ZTsgLyoga2VlcCBsb29raW5nICovCgkJLyoKCQkgKiBjZV9uYW1lIHNvcnRzIGFmdGVyIHAtPnBhdGg7IGNvdWxkIGl0IGJlIHRoYXQgd2UKCQkgKiBoYXZlIGZpbGVzIHVuZGVyIHAtPnBhdGggZGlyZWN0b3J5IGluIHRoZSBpbmRleD8KCQkgKiBFLmcuICBjZV9uYW1lID09ICJ0LWkiLCBhbmQgcC0+cGF0aCA9PSAidCI7IHdlIG1heQoJCSAqIGhhdmUgInQvYSIgaW4gdGhlIGluZGV4LgoJCSAqLwoJCWlmIChwX2xlbiA8IGNlX2xlbiAmJiAhbWVtY21wKGNlX25hbWUsIHAtPnBhdGgsIHBfbGVuKSAmJgoJCSAgICBjZV9uYW1lW3BfbGVuXSA8ICcvJykKCQkJY29udGludWU7IC8qIGtlZXAgbG9va2luZyAqLwoJCWJyZWFrOwoJfQoJcmV0dXJuIC0xOwp9CgpzdGF0aWMgc3RydWN0IGNhY2hlX2VudHJ5ICpmaW5kX2NhY2hlX2VudHJ5KHN0cnVjdCB0cmF2ZXJzZV9pbmZvICppbmZvLAoJCQkJCSAgICBjb25zdCBzdHJ1Y3QgbmFtZV9lbnRyeSAqcCkKewoJaW50IHBvcyA9IGZpbmRfY2FjaGVfcG9zKGluZm8sIHApOwoJc3RydWN0IHVucGFja190cmVlc19vcHRpb25zICpvID0gaW5mby0+ZGF0YTsKCglpZiAoMCA8PSBwb3MpCgkJcmV0dXJuIG8tPnNyY19pbmRleC0+Y2FjaGVbcG9zXTsKCWVsc2UKCQlyZXR1cm4gTlVMTDsKfQoKc3RhdGljIHZvaWQgZGVidWdfcGF0aChzdHJ1Y3QgdHJhdmVyc2VfaW5mbyAqaW5mbykKewoJaWYgKGluZm8tPnByZXYpIHsKCQlkZWJ1Z19wYXRoKGluZm8tPnByZXYpOwoJCWlmICgqaW5mby0+cHJldi0+bmFtZS5wYXRoKQoJCQlwdXRjaGFyKCcvJyk7Cgl9CglwcmludGYoIiVzIiwgaW5mby0+bmFtZS5wYXRoKTsKfQoKc3RhdGljIHZvaWQgZGVidWdfbmFtZV9lbnRyeShpbnQgaSwgc3RydWN0IG5hbWVfZW50cnkgKm4pCnsKCXByaW50ZigiZW50IyVkICUwNm8gJXNcbiIsIGksCgkgICAgICAgbi0+cGF0aCA/IG4tPm1vZGUgOiAwLAoJICAgICAgIG4tPnBhdGggPyBuLT5wYXRoIDogIihtaXNzaW5nKSIpOwp9CgpzdGF0aWMgdm9pZCBkZWJ1Z191bnBhY2tfY2FsbGJhY2soaW50IG4sCgkJCQkgIHVuc2lnbmVkIGxvbmcgbWFzaywKCQkJCSAgdW5zaWduZWQgbG9uZyBkaXJtYXNrLAoJCQkJICBzdHJ1Y3QgbmFtZV9lbnRyeSAqbmFtZXMsCgkJCQkgIHN0cnVjdCB0cmF2ZXJzZV9pbmZvICppbmZvKQp7CglpbnQgaTsKCXByaW50ZigiKiB1bnBhY2sgbWFzayAlbHUsIGRpcm1hc2sgJWx1LCBjbnQgJWQgIiwKCSAgICAgICBtYXNrLCBkaXJtYXNrLCBuKTsKCWRlYnVnX3BhdGgoaW5mbyk7CglwdXRjaGFyKCdcbicpOwoJZm9yIChpID0gMDsgaSA8IG47IGkrKykKCQlkZWJ1Z19uYW1lX2VudHJ5KGksIG5hbWVzICsgaSk7Cn0KCnN0YXRpYyBpbnQgdW5wYWNrX2NhbGxiYWNrKGludCBuLCB1bnNpZ25lZCBsb25nIG1hc2ssIHVuc2lnbmVkIGxvbmcgZGlybWFzaywgc3RydWN0IG5hbWVfZW50cnkgKm5hbWVzLCBzdHJ1Y3QgdHJhdmVyc2VfaW5mbyAqaW5mbykKewoJc3RydWN0IGNhY2hlX2VudHJ5ICpzcmNbTUFYX1VOUEFDS19UUkVFUyArIDFdID0geyBOVUxMLCB9OwoJc3RydWN0IHVucGFja190cmVlc19vcHRpb25zICpvID0gaW5mby0+ZGF0YTsKCWNvbnN0IHN0cnVjdCBuYW1lX2VudHJ5ICpwID0gbmFtZXM7CgoJLyogRmluZCBmaXJzdCBlbnRyeSB3aXRoIGEgcmVhbCBuYW1lICh3ZSBjb3VsZCB1c2UgIm1hc2siIHRvbykgKi8KCXdoaWxlICghcC0+bW9kZSkKCQlwKys7CgoJaWYgKG8tPmRlYnVnX3VucGFjaykKCQlkZWJ1Z191bnBhY2tfY2FsbGJhY2sobiwgbWFzaywgZGlybWFzaywgbmFtZXMsIGluZm8pOwoKCS8qIEFyZSB3ZSBzdXBwb3NlZCB0byBsb29rIGF0IHRoZSBpbmRleCB0b28/ICovCglpZiAoby0+bWVyZ2UpIHsKCQl3aGlsZSAoMSkgewoJCQlpbnQgY21wOwoJCQlzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlOwoKCQkJaWYgKG8tPmRpZmZfaW5kZXhfY2FjaGVkKQoJCQkJY2UgPSBuZXh0X2NhY2hlX2VudHJ5KG8pOwoJCQllbHNlCgkJCQljZSA9IGZpbmRfY2FjaGVfZW50cnkoaW5mbywgcCk7CgoJCQlpZiAoIWNlKQoJCQkJYnJlYWs7CgkJCWNtcCA9IGNvbXBhcmVfZW50cnkoY2UsIGluZm8sIHApOwoJCQlpZiAoY21wIDwgMCkgewoJCQkJaWYgKHVucGFja19pbmRleF9lbnRyeShjZSwgbykgPCAwKQoJCQkJCXJldHVybiB1bnBhY2tfZmFpbGVkKG8sIE5VTEwpOwoJCQkJY29udGludWU7CgkJCX0KCQkJaWYgKCFjbXApIHsKCQkJCWlmIChjZV9zdGFnZShjZSkpIHsKCQkJCQkvKgoJCQkJCSAqIElmIHdlIHNraXAgdW5tZXJnZWQgaW5kZXgKCQkJCQkgKiBlbnRyaWVzLCB3ZSdsbCBza2lwIHRoaXMKCQkJCQkgKiBlbnRyeSAqYW5kKiB0aGUgdHJlZQoJCQkJCSAqIGVudHJpZXMgYXNzb2NpYXRlZCB3aXRoIGl0IQoJCQkJCSAqLwoJCQkJCWlmIChvLT5za2lwX3VubWVyZ2VkKSB7CgkJCQkJCWFkZF9zYW1lX3VubWVyZ2VkKGNlLCBvKTsKCQkJCQkJcmV0dXJuIG1hc2s7CgkJCQkJfQoJCQkJfQoJCQkJc3JjWzBdID0gY2U7CgkJCX0KCQkJYnJlYWs7CgkJfQoJfQoKCWlmICh1bnBhY2tfbm9uZGlyZWN0b3JpZXMobiwgbWFzaywgZGlybWFzaywgc3JjLCBuYW1lcywgaW5mbykgPCAwKQoJCXJldHVybiAtMTsKCglpZiAoby0+bWVyZ2UgJiYgc3JjWzBdKSB7CgkJaWYgKGNlX3N0YWdlKHNyY1swXSkpCgkJCW1hcmtfY2VfdXNlZF9zYW1lX25hbWUoc3JjWzBdLCBvKTsKCQllbHNlCgkJCW1hcmtfY2VfdXNlZChzcmNbMF0sIG8pOwoJfQoKCS8qIE5vdyBoYW5kbGUgYW55IGRpcmVjdG9yaWVzLi4gKi8KCWlmIChkaXJtYXNrKSB7CgkJdW5zaWduZWQgbG9uZyBjb25mbGljdHMgPSBtYXNrICYgfmRpcm1hc2s7CgkJaWYgKG8tPm1lcmdlKSB7CgkJCWNvbmZsaWN0cyA8PD0gMTsKCQkJaWYgKHNyY1swXSkKCQkJCWNvbmZsaWN0cyB8PSAxOwoJCX0KCgkJLyogc3BlY2lhbCBjYXNlOiAiZGlmZi1pbmRleCAtLWNhY2hlZCIgbG9va2luZyBhdCBhIHRyZWUgKi8KCQlpZiAoby0+ZGlmZl9pbmRleF9jYWNoZWQgJiYKCQkgICAgbiA9PSAxICYmIGRpcm1hc2sgPT0gMSAmJiBTX0lTRElSKG5hbWVzLT5tb2RlKSkgewoJCQlpbnQgbWF0Y2hlczsKCQkJbWF0Y2hlcyA9IGNhY2hlX3RyZWVfbWF0Y2hlc190cmF2ZXJzYWwoby0+c3JjX2luZGV4LT5jYWNoZV90cmVlLAoJCQkJCQkJICAgICAgIG5hbWVzLCBpbmZvKTsKCQkJLyoKCQkJICogRXZlcnl0aGluZyB1bmRlciB0aGUgbmFtZSBtYXRjaGVzOyBza2lwIHRoZQoJCQkgKiBlbnRpcmUgaGllcmFyY2h5LiAgZGlmZl9pbmRleF9jYWNoZWQgY29kZXBhdGgKCQkJICogc3BlY2lhbCBjYXNlcyBEL0YgY29uZmxpY3RzIGluIHN1Y2ggYSB3YXkgdGhhdAoJCQkgKiBpdCBkb2VzIG5vdCBkbyBhbnkgbG9vay1haGVhZCwgc28gdGhpcyBpcyBzYWZlLgoJCQkgKi8KCQkJaWYgKG1hdGNoZXMpIHsKCQkJCW8tPmNhY2hlX2JvdHRvbSArPSBtYXRjaGVzOwoJCQkJcmV0dXJuIG1hc2s7CgkJCX0KCQl9CgoJCWlmICh0cmF2ZXJzZV90cmVlc19yZWN1cnNpdmUobiwgZGlybWFzaywgY29uZmxpY3RzLAoJCQkJCSAgICAgbmFtZXMsIGluZm8pIDwgMCkKCQkJcmV0dXJuIC0xOwoJCXJldHVybiBtYXNrOwoJfQoKCXJldHVybiBtYXNrOwp9CgpzdGF0aWMgaW50IGNsZWFyX2NlX2ZsYWdzXzEoc3RydWN0IGNhY2hlX2VudHJ5ICoqY2FjaGUsIGludCBuciwKCQkJICAgIGNoYXIgKnByZWZpeCwgaW50IHByZWZpeF9sZW4sCgkJCSAgICBpbnQgc2VsZWN0X21hc2ssIGludCBjbGVhcl9tYXNrLAoJCQkgICAgc3RydWN0IGV4Y2x1ZGVfbGlzdCAqZWwsIGludCBkZWZ2YWwpOwoKLyogV2hvbGUgZGlyZWN0b3J5IG1hdGNoaW5nICovCnN0YXRpYyBpbnQgY2xlYXJfY2VfZmxhZ3NfZGlyKHN0cnVjdCBjYWNoZV9lbnRyeSAqKmNhY2hlLCBpbnQgbnIsCgkJCSAgICAgIGNoYXIgKnByZWZpeCwgaW50IHByZWZpeF9sZW4sCgkJCSAgICAgIGNoYXIgKmJhc2VuYW1lLAoJCQkgICAgICBpbnQgc2VsZWN0X21hc2ssIGludCBjbGVhcl9tYXNrLAoJCQkgICAgICBzdHJ1Y3QgZXhjbHVkZV9saXN0ICplbCwgaW50IGRlZnZhbCkKewoJc3RydWN0IGNhY2hlX2VudHJ5ICoqY2FjaGVfZW5kOwoJaW50IGR0eXBlID0gRFRfRElSOwoJaW50IHJldCA9IGV4Y2x1ZGVkX2Zyb21fbGlzdChwcmVmaXgsIHByZWZpeF9sZW4sIGJhc2VuYW1lLCAmZHR5cGUsIGVsKTsKCglwcmVmaXhbcHJlZml4X2xlbisrXSA9ICcvJzsKCgkvKiBJZiB1bmRlY2lkZWQsIHVzZSBtYXRjaGluZyByZXN1bHQgb2YgcGFyZW50IGRpciBpbiBkZWZ2YWwgKi8KCWlmIChyZXQgPCAwKQoJCXJldCA9IGRlZnZhbDsKCglmb3IgKGNhY2hlX2VuZCA9IGNhY2hlOyBjYWNoZV9lbmQgIT0gY2FjaGUgKyBucjsgY2FjaGVfZW5kKyspIHsKCQlzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlID0gKmNhY2hlX2VuZDsKCQlpZiAoc3RybmNtcChjZS0+bmFtZSwgcHJlZml4LCBwcmVmaXhfbGVuKSkKCQkJYnJlYWs7Cgl9CgoJLyoKCSAqIFRPRE86IGNoZWNrIGVsLCBpZiB0aGVyZSBhcmUgbm8gcGF0dGVybnMgdGhhdCBtYXkgY29uZmxpY3QKCSAqIHdpdGggcmV0IChpb3csIHdlIGtub3cgaW4gYWR2YW5jZSB0aGUgaW5jbC9leGNsCgkgKiBkZWNpc2lvbiBmb3IgdGhlIGVudGlyZSBkaXJlY3RvcnkpLCBjbGVhciBmbGFnIGhlcmUgd2l0aG91dAoJICogY2FsbGluZyBjbGVhcl9jZV9mbGFnc18xKCkuIFRoYXQgZnVuY3Rpb24gd2lsbCBjYWxsCgkgKiB0aGUgZXhwZW5zaXZlIGV4Y2x1ZGVkX2Zyb21fbGlzdCgpIG9uIGV2ZXJ5IGVudHJ5LgoJICovCglyZXR1cm4gY2xlYXJfY2VfZmxhZ3NfMShjYWNoZSwgY2FjaGVfZW5kIC0gY2FjaGUsCgkJCQlwcmVmaXgsIHByZWZpeF9sZW4sCgkJCQlzZWxlY3RfbWFzaywgY2xlYXJfbWFzaywKCQkJCWVsLCByZXQpOwp9CgovKgogKiBUcmF2ZXJzZSB0aGUgaW5kZXgsIGZpbmQgZXZlcnkgZW50cnkgdGhhdCBtYXRjaGVzIGFjY29yZGluZyB0bwogKiBvLT5lbC4gRG8gImNlX2ZsYWdzICY9IH5jbGVhcl9tYXNrIiBvbiB0aG9zZSBlbnRyaWVzLiBSZXR1cm4gdGhlCiAqIG51bWJlciBvZiB0cmF2ZXJzZWQgZW50cmllcy4KICoKICogSWYgc2VsZWN0X21hc2sgaXMgbm9uLXplcm8sIG9ubHkgZW50cmllcyB3aG9zZSBjZV9mbGFncyBoYXMgb24gb2YKICogdGhvc2UgYml0cyBlbmFibGVkIGFyZSB0cmF2ZXJzZWQuCiAqCiAqIGNhY2hlCTogcG9pbnRlciB0byBhbiBpbmRleCBlbnRyeQogKiBwcmVmaXhfbGVuCTogYW4gb2Zmc2V0IHRvIGl0cyBwYXRoCiAqCiAqIFRoZSBjdXJyZW50IHBhdGggKCJwcmVmaXgiKSBpbmNsdWRpbmcgdGhlIHRyYWlsaW5nICcvJyBpcwogKiAgIGNhY2hlWzBdLT5uYW1lWzAuLihwcmVmaXhfbGVuLTEpXQogKiBUb3AgbGV2ZWwgcGF0aCBoYXMgcHJlZml4X2xlbiB6ZXJvLgogKi8Kc3RhdGljIGludCBjbGVhcl9jZV9mbGFnc18xKHN0cnVjdCBjYWNoZV9lbnRyeSAqKmNhY2hlLCBpbnQgbnIsCgkJCSAgICBjaGFyICpwcmVmaXgsIGludCBwcmVmaXhfbGVuLAoJCQkgICAgaW50IHNlbGVjdF9tYXNrLCBpbnQgY2xlYXJfbWFzaywKCQkJICAgIHN0cnVjdCBleGNsdWRlX2xpc3QgKmVsLCBpbnQgZGVmdmFsKQp7CglzdHJ1Y3QgY2FjaGVfZW50cnkgKipjYWNoZV9lbmQgPSBjYWNoZSArIG5yOwoKCS8qCgkgKiBQcm9jZXNzIGFsbCBlbnRyaWVzIHRoYXQgaGF2ZSB0aGUgZ2l2ZW4gcHJlZml4IGFuZCBtZWV0CgkgKiBzZWxlY3RfbWFzayBjb25kaXRpb24KCSAqLwoJd2hpbGUoY2FjaGUgIT0gY2FjaGVfZW5kKSB7CgkJc3RydWN0IGNhY2hlX2VudHJ5ICpjZSA9ICpjYWNoZTsKCQljb25zdCBjaGFyICpuYW1lLCAqc2xhc2g7CgkJaW50IGxlbiwgZHR5cGUsIHJldDsKCgkJaWYgKHNlbGVjdF9tYXNrICYmICEoY2UtPmNlX2ZsYWdzICYgc2VsZWN0X21hc2spKSB7CgkJCWNhY2hlKys7CgkJCWNvbnRpbnVlOwoJCX0KCgkJaWYgKHByZWZpeF9sZW4gJiYgc3RybmNtcChjZS0+bmFtZSwgcHJlZml4LCBwcmVmaXhfbGVuKSkKCQkJYnJlYWs7CgoJCW5hbWUgPSBjZS0+bmFtZSArIHByZWZpeF9sZW47CgkJc2xhc2ggPSBzdHJjaHIobmFtZSwgJy8nKTsKCgkJLyogSWYgaXQncyBhIGRpcmVjdG9yeSwgdHJ5IHdob2xlIGRpcmVjdG9yeSBtYXRjaCBmaXJzdCAqLwoJCWlmIChzbGFzaCkgewoJCQlpbnQgcHJvY2Vzc2VkOwoKCQkJbGVuID0gc2xhc2ggLSBuYW1lOwoJCQltZW1jcHkocHJlZml4ICsgcHJlZml4X2xlbiwgbmFtZSwgbGVuKTsKCgkJCS8qCgkJCSAqIHRlcm1pbmF0ZSB0aGUgc3RyaW5nIChubyB0cmFpbGluZyBzbGFzaCksCgkJCSAqIGNsZWFyX2NfZl9kaXIgbmVlZHMgaXQKCQkJICovCgkJCXByZWZpeFtwcmVmaXhfbGVuICsgbGVuXSA9ICdcMCc7CgkJCXByb2Nlc3NlZCA9IGNsZWFyX2NlX2ZsYWdzX2RpcihjYWNoZSwgY2FjaGVfZW5kIC0gY2FjaGUsCgkJCQkJCSAgICAgICBwcmVmaXgsIHByZWZpeF9sZW4gKyBsZW4sCgkJCQkJCSAgICAgICBwcmVmaXggKyBwcmVmaXhfbGVuLAoJCQkJCQkgICAgICAgc2VsZWN0X21hc2ssIGNsZWFyX21hc2ssCgkJCQkJCSAgICAgICBlbCwgZGVmdmFsKTsKCgkJCS8qIGNsZWFyX2NfZl9kaXIgZWF0cyBhIHdob2xlIGRpciBhbHJlYWR5PyAqLwoJCQlpZiAocHJvY2Vzc2VkKSB7CgkJCQljYWNoZSArPSBwcm9jZXNzZWQ7CgkJCQljb250aW51ZTsKCQkJfQoKCQkJcHJlZml4W3ByZWZpeF9sZW4gKyBsZW4rK10gPSAnLyc7CgkJCWNhY2hlICs9IGNsZWFyX2NlX2ZsYWdzXzEoY2FjaGUsIGNhY2hlX2VuZCAtIGNhY2hlLAoJCQkJCQkgIHByZWZpeCwgcHJlZml4X2xlbiArIGxlbiwKCQkJCQkJICBzZWxlY3RfbWFzaywgY2xlYXJfbWFzaywgZWwsIGRlZnZhbCk7CgkJCWNvbnRpbnVlOwoJCX0KCgkJLyogTm9uLWRpcmVjdG9yeSAqLwoJCWR0eXBlID0gY2VfdG9fZHR5cGUoY2UpOwoJCXJldCA9IGV4Y2x1ZGVkX2Zyb21fbGlzdChjZS0+bmFtZSwgY2VfbmFtZWxlbihjZSksIG5hbWUsICZkdHlwZSwgZWwpOwoJCWlmIChyZXQgPCAwKQoJCQlyZXQgPSBkZWZ2YWw7CgkJaWYgKHJldCA+IDApCgkJCWNlLT5jZV9mbGFncyAmPSB+Y2xlYXJfbWFzazsKCQljYWNoZSsrOwoJfQoJcmV0dXJuIG5yIC0gKGNhY2hlX2VuZCAtIGNhY2hlKTsKfQoKc3RhdGljIGludCBjbGVhcl9jZV9mbGFncyhzdHJ1Y3QgY2FjaGVfZW50cnkgKipjYWNoZSwgaW50IG5yLAoJCQkgICAgaW50IHNlbGVjdF9tYXNrLCBpbnQgY2xlYXJfbWFzaywKCQkJICAgIHN0cnVjdCBleGNsdWRlX2xpc3QgKmVsKQp7CgljaGFyIHByZWZpeFtQQVRIX01BWF07CglyZXR1cm4gY2xlYXJfY2VfZmxhZ3NfMShjYWNoZSwgbnIsCgkJCQlwcmVmaXgsIDAsCgkJCQlzZWxlY3RfbWFzaywgY2xlYXJfbWFzaywKCQkJCWVsLCAwKTsKfQoKLyoKICogU2V0L0NsZWFyIENFX05FV19TS0lQX1dPUktUUkVFIGFjY29yZGluZyB0byAkR0lUX0RJUi9pbmZvL3NwYXJzZS1jaGVja291dAogKi8Kc3RhdGljIHZvaWQgbWFya19uZXdfc2tpcF93b3JrdHJlZShzdHJ1Y3QgZXhjbHVkZV9saXN0ICplbCwKCQkJCSAgIHN0cnVjdCBpbmRleF9zdGF0ZSAqdGhlX2luZGV4LAoJCQkJICAgaW50IHNlbGVjdF9mbGFnLCBpbnQgc2tpcF93dF9mbGFnKQp7CglpbnQgaTsKCgkvKgoJICogMS4gUHJldGVuZCB0aGUgbmFycm93ZXN0IHdvcmt0cmVlOiBvbmx5IHVubWVyZ2VkIGVudHJpZXMKCSAqIGFyZSBjaGVja2VkIG91dAoJICovCglmb3IgKGkgPSAwOyBpIDwgdGhlX2luZGV4LT5jYWNoZV9ucjsgaSsrKSB7CgkJc3RydWN0IGNhY2hlX2VudHJ5ICpjZSA9IHRoZV9pbmRleC0+Y2FjaGVbaV07CgoJCWlmIChzZWxlY3RfZmxhZyAmJiAhKGNlLT5jZV9mbGFncyAmIHNlbGVjdF9mbGFnKSkKCQkJY29udGludWU7CgoJCWlmICghY2Vfc3RhZ2UoY2UpKQoJCQljZS0+Y2VfZmxhZ3MgfD0gc2tpcF93dF9mbGFnOwoJCWVsc2UKCQkJY2UtPmNlX2ZsYWdzICY9IH5za2lwX3d0X2ZsYWc7Cgl9CgoJLyoKCSAqIDIuIFdpZGVuIHdvcmt0cmVlIGFjY29yZGluZyB0byBzcGFyc2UtY2hlY2tvdXQgZmlsZS4KCSAqIE1hdGNoZWQgZW50cmllcyB3aWxsIGhhdmUgc2tpcF93dF9mbGFnIGNsZWFyZWQgKGkuZS4gImluIikKCSAqLwoJY2xlYXJfY2VfZmxhZ3ModGhlX2luZGV4LT5jYWNoZSwgdGhlX2luZGV4LT5jYWNoZV9uciwKCQkgICAgICAgc2VsZWN0X2ZsYWcsIHNraXBfd3RfZmxhZywgZWwpOwp9CgpzdGF0aWMgaW50IHZlcmlmeV9hYnNlbnQoc3RydWN0IGNhY2hlX2VudHJ5ICosIGVudW0gdW5wYWNrX3RyZWVzX2Vycm9yX3R5cGVzLCBzdHJ1Y3QgdW5wYWNrX3RyZWVzX29wdGlvbnMgKik7Ci8qCiAqIE4td2F5IG1lcmdlICJsZW4iIHRyZWVzLiAgUmV0dXJucyAwIG9uIHN1Y2Nlc3MsIC0xIG9uIGZhaWx1cmUgdG8gbWFuaXB1bGF0ZSB0aGUKICogcmVzdWx0aW5nIGluZGV4LCAtMiBvbiBmYWlsdXJlIHRvIHJlZmxlY3QgdGhlIGNoYW5nZXMgdG8gdGhlIHdvcmsgdHJlZS4KICoKICogQ0VfQURERUQsIENFX1VOUEFDS0VEIGFuZCBDRV9ORVdfU0tJUF9XT1JLVFJFRSBhcmUgdXNlZCBpbnRlcm5hbGx5CiAqLwppbnQgdW5wYWNrX3RyZWVzKHVuc2lnbmVkIGxlbiwgc3RydWN0IHRyZWVfZGVzYyAqdCwgc3RydWN0IHVucGFja190cmVlc19vcHRpb25zICpvKQp7CglpbnQgaSwgcmV0OwoJc3RhdGljIHN0cnVjdCBjYWNoZV9lbnRyeSAqZGZjOwoJc3RydWN0IGV4Y2x1ZGVfbGlzdCBlbDsKCglpZiAobGVuID4gTUFYX1VOUEFDS19UUkVFUykKCQlkaWUoInVucGFja190cmVlcyB0YWtlcyBhdCBtb3N0ICVkIHRyZWVzIiwgTUFYX1VOUEFDS19UUkVFUyk7CgltZW1zZXQoJnN0YXRlLCAwLCBzaXplb2Yoc3RhdGUpKTsKCXN0YXRlLmJhc2VfZGlyID0gIiI7CglzdGF0ZS5mb3JjZSA9IDE7CglzdGF0ZS5xdWlldCA9IDE7CglzdGF0ZS5yZWZyZXNoX2NhY2hlID0gMTsKCgltZW1zZXQoJmVsLCAwLCBzaXplb2YoZWwpKTsKCWlmICghY29yZV9hcHBseV9zcGFyc2VfY2hlY2tvdXQgfHwgIW8tPnVwZGF0ZSkKCQlvLT5za2lwX3NwYXJzZV9jaGVja291dCA9IDE7CglpZiAoIW8tPnNraXBfc3BhcnNlX2NoZWNrb3V0KSB7CgkJaWYgKGFkZF9leGNsdWRlc19mcm9tX2ZpbGVfdG9fbGlzdChnaXRfcGF0aCgiaW5mby9zcGFyc2UtY2hlY2tvdXQiKSwgIiIsIDAsIE5VTEwsICZlbCwgMCkgPCAwKQoJCQlvLT5za2lwX3NwYXJzZV9jaGVja291dCA9IDE7CgkJZWxzZQoJCQlvLT5lbCA9ICZlbDsKCX0KCglpZiAoby0+ZGlyKSB7CgkJby0+cGF0aF9leGNsdWRlX2NoZWNrID0geG1hbGxvYyhzaXplb2Yoc3RydWN0IHBhdGhfZXhjbHVkZV9jaGVjaykpOwoJCXBhdGhfZXhjbHVkZV9jaGVja19pbml0KG8tPnBhdGhfZXhjbHVkZV9jaGVjaywgby0+ZGlyKTsKCX0KCW1lbXNldCgmby0+cmVzdWx0LCAwLCBzaXplb2Yoby0+cmVzdWx0KSk7CglvLT5yZXN1bHQuaW5pdGlhbGl6ZWQgPSAxOwoJby0+cmVzdWx0LnRpbWVzdGFtcC5zZWMgPSBvLT5zcmNfaW5kZXgtPnRpbWVzdGFtcC5zZWM7CglvLT5yZXN1bHQudGltZXN0YW1wLm5zZWMgPSBvLT5zcmNfaW5kZXgtPnRpbWVzdGFtcC5uc2VjOwoJby0+cmVzdWx0LnZlcnNpb24gPSBvLT5zcmNfaW5kZXgtPnZlcnNpb247CglvLT5tZXJnZV9zaXplID0gbGVuOwoJbWFya19hbGxfY2VfdW51c2VkKG8tPnNyY19pbmRleCk7CgoJLyoKCSAqIFNwYXJzZSBjaGVja291dCBsb29wICMxOiBzZXQgTkVXX1NLSVBfV09SS1RSRUUgb24gZXhpc3RpbmcgZW50cmllcwoJICovCglpZiAoIW8tPnNraXBfc3BhcnNlX2NoZWNrb3V0KQoJCW1hcmtfbmV3X3NraXBfd29ya3RyZWUoby0+ZWwsIG8tPnNyY19pbmRleCwgMCwgQ0VfTkVXX1NLSVBfV09SS1RSRUUpOwoKCWlmICghZGZjKQoJCWRmYyA9IHhjYWxsb2MoMSwgY2FjaGVfZW50cnlfc2l6ZSgwKSk7CglvLT5kZl9jb25mbGljdF9lbnRyeSA9IGRmYzsKCglpZiAobGVuKSB7CgkJY29uc3QgY2hhciAqcHJlZml4ID0gby0+cHJlZml4ID8gby0+cHJlZml4IDogIiI7CgkJc3RydWN0IHRyYXZlcnNlX2luZm8gaW5mbzsKCgkJc2V0dXBfdHJhdmVyc2VfaW5mbygmaW5mbywgcHJlZml4KTsKCQlpbmZvLmZuID0gdW5wYWNrX2NhbGxiYWNrOwoJCWluZm8uZGF0YSA9IG87CgkJaW5mby5zaG93X2FsbF9lcnJvcnMgPSBvLT5zaG93X2FsbF9lcnJvcnM7CgkJaW5mby5wYXRoc3BlYyA9IG8tPnBhdGhzcGVjOwoKCQlpZiAoby0+cHJlZml4KSB7CgkJCS8qCgkJCSAqIFVucGFjayBleGlzdGluZyBpbmRleCBlbnRyaWVzIHRoYXQgc29ydCBiZWZvcmUgdGhlCgkJCSAqIHByZWZpeCB0aGUgdHJlZSBpcyBzcGxpY2VkIGludG8uICBOb3RlIHRoYXQgby0+bWVyZ2UKCQkJICogaXMgYWx3YXlzIHRydWUgaW4gdGhpcyBjYXNlLgoJCQkgKi8KCQkJd2hpbGUgKDEpIHsKCQkJCXN0cnVjdCBjYWNoZV9lbnRyeSAqY2UgPSBuZXh0X2NhY2hlX2VudHJ5KG8pOwoJCQkJaWYgKCFjZSkKCQkJCQlicmVhazsKCQkJCWlmIChjZV9pbl90cmF2ZXJzZV9wYXRoKGNlLCAmaW5mbykpCgkJCQkJYnJlYWs7CgkJCQlpZiAodW5wYWNrX2luZGV4X2VudHJ5KGNlLCBvKSA8IDApCgkJCQkJZ290byByZXR1cm5fZmFpbGVkOwoJCQl9CgkJfQoKCQlpZiAodHJhdmVyc2VfdHJlZXMobGVuLCB0LCAmaW5mbykgPCAwKQoJCQlnb3RvIHJldHVybl9mYWlsZWQ7Cgl9CgoJLyogQW55IGxlZnQtb3ZlciBlbnRyaWVzIGluIHRoZSBpbmRleD8gKi8KCWlmIChvLT5tZXJnZSkgewoJCXdoaWxlICgxKSB7CgkJCXN0cnVjdCBjYWNoZV9lbnRyeSAqY2UgPSBuZXh0X2NhY2hlX2VudHJ5KG8pOwoJCQlpZiAoIWNlKQoJCQkJYnJlYWs7CgkJCWlmICh1bnBhY2tfaW5kZXhfZW50cnkoY2UsIG8pIDwgMCkKCQkJCWdvdG8gcmV0dXJuX2ZhaWxlZDsKCQl9Cgl9CgltYXJrX2FsbF9jZV91bnVzZWQoby0+c3JjX2luZGV4KTsKCglpZiAoby0+dHJpdmlhbF9tZXJnZXNfb25seSAmJiBvLT5ub250cml2aWFsX21lcmdlKSB7CgkJcmV0ID0gdW5wYWNrX2ZhaWxlZChvLCAiTWVyZ2UgcmVxdWlyZXMgZmlsZS1sZXZlbCBtZXJnaW5nIik7CgkJZ290byBkb25lOwoJfQoKCWlmICghby0+c2tpcF9zcGFyc2VfY2hlY2tvdXQpIHsKCQlpbnQgZW1wdHlfd29ya3RyZWUgPSAxOwoKCQkvKgoJCSAqIFNwYXJzZSBjaGVja291dCBsb29wICMyOiBzZXQgTkVXX1NLSVBfV09SS1RSRUUgb24gZW50cmllcyBub3QgaW4gbG9vcCAjMQoJCSAqIElmIHRoZSB3aWxsIGhhdmUgTkVXX1NLSVBfV09SS1RSRUUsIGFsc28gc2V0IENFX1NLSVBfV09SS1RSRUUKCQkgKiBzbyBhcHBseV9zcGFyc2VfY2hlY2tvdXQoKSB3b24ndCBhdHRlbXB0IHRvIHJlbW92ZSBpdCBmcm9tIHdvcmt0cmVlCgkJICovCgkJbWFya19uZXdfc2tpcF93b3JrdHJlZShvLT5lbCwgJm8tPnJlc3VsdCwgQ0VfQURERUQsIENFX1NLSVBfV09SS1RSRUUgfCBDRV9ORVdfU0tJUF9XT1JLVFJFRSk7CgoJCXJldCA9IDA7CgkJZm9yIChpID0gMDsgaSA8IG8tPnJlc3VsdC5jYWNoZV9ucjsgaSsrKSB7CgkJCXN0cnVjdCBjYWNoZV9lbnRyeSAqY2UgPSBvLT5yZXN1bHQuY2FjaGVbaV07CgoJCQkvKgoJCQkgKiBFbnRyaWVzIG1hcmtlZCB3aXRoIENFX0FEREVEIGluIG1lcmdlZF9lbnRyeSgpIGRvIG5vdCBoYXZlCgkJCSAqIHZlcmlmeV9hYnNlbnQoKSBjaGVjayAodGhlIGNoZWNrIGlzIGVmZmVjdGl2ZWx5IGRpc2FibGVkCgkJCSAqIGJlY2F1c2UgQ0VfTkVXX1NLSVBfV09SS1RSRUUgaXMgc2V0IHVuY29uZGl0aW9uYWxseSkuCgkJCSAqCgkJCSAqIERvIHRoZSByZWFsIGNoZWNrIG5vdyBiZWNhdXNlIHdlIGhhdmUgaGFkCgkJCSAqIGNvcnJlY3QgQ0VfTkVXX1NLSVBfV09SS1RSRUUKCQkJICovCgkJCWlmIChjZS0+Y2VfZmxhZ3MgJiBDRV9BRERFRCAmJgoJCQkgICAgdmVyaWZ5X2Fic2VudChjZSwgRVJST1JfV09VTERfTE9TRV9VTlRSQUNLRURfT1ZFUldSSVRURU4sIG8pKSB7CgkJCQlpZiAoIW8tPnNob3dfYWxsX2Vycm9ycykKCQkJCQlnb3RvIHJldHVybl9mYWlsZWQ7CgkJCQlyZXQgPSAtMTsKCQkJfQoKCQkJaWYgKGFwcGx5X3NwYXJzZV9jaGVja291dChjZSwgbykpIHsKCQkJCWlmICghby0+c2hvd19hbGxfZXJyb3JzKQoJCQkJCWdvdG8gcmV0dXJuX2ZhaWxlZDsKCQkJCXJldCA9IC0xOwoJCQl9CgkJCWlmICghY2Vfc2tpcF93b3JrdHJlZShjZSkpCgkJCQllbXB0eV93b3JrdHJlZSA9IDA7CgoJCX0KCQlpZiAocmV0IDwgMCkKCQkJZ290byByZXR1cm5fZmFpbGVkOwoJCS8qCgkJICogU3BhcnNlIGNoZWNrb3V0IGlzIG1lYW50IHRvIG5hcnJvdyBkb3duIGNoZWNrb3V0IGFyZWEKCQkgKiBidXQgaXQgZG9lcyBub3QgbWFrZSBzZW5zZSB0byBuYXJyb3cgZG93biB0byBlbXB0eSB3b3JraW5nCgkJICogdHJlZS4gVGhpcyBpcyB1c3VhbGx5IGEgbWlzdGFrZSBpbiBzcGFyc2UgY2hlY2tvdXQgcnVsZXMuCgkJICogRG8gbm90IGFsbG93IHVzZXJzIHRvIGRvIHRoYXQuCgkJICovCgkJaWYgKG8tPnJlc3VsdC5jYWNoZV9uciAmJiBlbXB0eV93b3JrdHJlZSkgewoJCQlyZXQgPSB1bnBhY2tfZmFpbGVkKG8sICJTcGFyc2UgY2hlY2tvdXQgbGVhdmVzIG5vIGVudHJ5IG9uIHdvcmtpbmcgZGlyZWN0b3J5Iik7CgkJCWdvdG8gZG9uZTsKCQl9Cgl9CgoJby0+c3JjX2luZGV4ID0gTlVMTDsKCXJldCA9IGNoZWNrX3VwZGF0ZXMobykgPyAoLTIpIDogMDsKCWlmIChvLT5kc3RfaW5kZXgpCgkJKm8tPmRzdF9pbmRleCA9IG8tPnJlc3VsdDsKCmRvbmU6CglmcmVlX2V4Y2x1ZGVzKCZlbCk7CglpZiAoby0+cGF0aF9leGNsdWRlX2NoZWNrKSB7CgkJcGF0aF9leGNsdWRlX2NoZWNrX2NsZWFyKG8tPnBhdGhfZXhjbHVkZV9jaGVjayk7CgkJZnJlZShvLT5wYXRoX2V4Y2x1ZGVfY2hlY2spOwoJfQoJcmV0dXJuIHJldDsKCnJldHVybl9mYWlsZWQ6CglpZiAoby0+c2hvd19hbGxfZXJyb3JzKQoJCWRpc3BsYXlfZXJyb3JfbXNncyhvKTsKCW1hcmtfYWxsX2NlX3VudXNlZChvLT5zcmNfaW5kZXgpOwoJcmV0ID0gdW5wYWNrX2ZhaWxlZChvLCBOVUxMKTsKCWlmIChvLT5leGl0aW5nX2Vhcmx5KQoJCXJldCA9IDA7Cglnb3RvIGRvbmU7Cn0KCi8qIEhlcmUgY29tZSB0aGUgbWVyZ2UgZnVuY3Rpb25zICovCgpzdGF0aWMgaW50IHJlamVjdF9tZXJnZShzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlLCBzdHJ1Y3QgdW5wYWNrX3RyZWVzX29wdGlvbnMgKm8pCnsKCXJldHVybiBhZGRfcmVqZWN0ZWRfcGF0aChvLCBFUlJPUl9XT1VMRF9PVkVSV1JJVEUsIGNlLT5uYW1lKTsKfQoKc3RhdGljIGludCBzYW1lKHN0cnVjdCBjYWNoZV9lbnRyeSAqYSwgc3RydWN0IGNhY2hlX2VudHJ5ICpiKQp7CglpZiAoISFhICE9ICEhYikKCQlyZXR1cm4gMDsKCWlmICghYSAmJiAhYikKCQlyZXR1cm4gMTsKCWlmICgoYS0+Y2VfZmxhZ3MgfCBiLT5jZV9mbGFncykgJiBDRV9DT05GTElDVEVEKQoJCXJldHVybiAwOwoJcmV0dXJuIGEtPmNlX21vZGUgPT0gYi0+Y2VfbW9kZSAmJgoJICAgICAgICFoYXNoY21wKGEtPnNoYTEsIGItPnNoYTEpOwp9CgoKLyoKICogV2hlbiBhIENFIGdldHMgdHVybmVkIGludG8gYW4gdW5tZXJnZWQgZW50cnksIHdlCiAqIHdhbnQgaXQgdG8gYmUgdXAtdG8tZGF0ZQogKi8Kc3RhdGljIGludCB2ZXJpZnlfdXB0b2RhdGVfMShzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlLAoJCQkJICAgc3RydWN0IHVucGFja190cmVlc19vcHRpb25zICpvLAoJCQkJICAgZW51bSB1bnBhY2tfdHJlZXNfZXJyb3JfdHlwZXMgZXJyb3JfdHlwZSkKewoJc3RydWN0IHN0YXQgc3Q7CgoJaWYgKG8tPmluZGV4X29ubHkpCgkJcmV0dXJuIDA7CgoJLyoKCSAqIENFX1ZBTElEIGFuZCBDRV9TS0lQX1dPUktUUkVFIGNoZWF0LCB3ZSBiZXR0ZXIgY2hlY2sgYWdhaW4KCSAqIGlmIHRoaXMgZW50cnkgaXMgdHJ1bHkgdXAtdG8tZGF0ZSBiZWNhdXNlIHRoaXMgZmlsZSBtYXkgYmUKCSAqIG92ZXJ3cml0dGVuLgoJICovCglpZiAoKGNlLT5jZV9mbGFncyAmIENFX1ZBTElEKSB8fCBjZV9za2lwX3dvcmt0cmVlKGNlKSkKCQk7IC8qIGtlZXAgY2hlY2tpbmcgKi8KCWVsc2UgaWYgKG8tPnJlc2V0IHx8IGNlX3VwdG9kYXRlKGNlKSkKCQlyZXR1cm4gMDsKCglpZiAoIWxzdGF0KGNlLT5uYW1lLCAmc3QpKSB7CgkJaW50IGZsYWdzID0gQ0VfTUFUQ0hfSUdOT1JFX1ZBTElEfENFX01BVENIX0lHTk9SRV9TS0lQX1dPUktUUkVFOwoJCXVuc2lnbmVkIGNoYW5nZWQgPSBpZV9tYXRjaF9zdGF0KG8tPnNyY19pbmRleCwgY2UsICZzdCwgZmxhZ3MpOwoJCWlmICghY2hhbmdlZCkKCQkJcmV0dXJuIDA7CgkJLyoKCQkgKiBORUVEU1dPUks6IHRoZSBjdXJyZW50IGRlZmF1bHQgcG9saWN5IGlzIHRvIGFsbG93CgkJICogc3VibW9kdWxlIHRvIGJlIG91dCBvZiBzeW5jIHdydCB0aGUgc3VwZXJwcm9qZWN0CgkJICogaW5kZXguICBUaGlzIG5lZWRzIHRvIGJlIHRpZ2h0ZW5lZCBsYXRlciBmb3IKCQkgKiBzdWJtb2R1bGVzIHRoYXQgYXJlIG1hcmtlZCB0byBiZSBhdXRvbWF0aWNhbGx5CgkJICogY2hlY2tlZCBvdXQuCgkJICovCgkJaWYgKFNfSVNHSVRMSU5LKGNlLT5jZV9tb2RlKSkKCQkJcmV0dXJuIDA7CgkJZXJybm8gPSAwOwoJfQoJaWYgKGVycm5vID09IEVOT0VOVCkKCQlyZXR1cm4gMDsKCXJldHVybiBvLT5nZW50bHkgPyAtMSA6CgkJYWRkX3JlamVjdGVkX3BhdGgobywgZXJyb3JfdHlwZSwgY2UtPm5hbWUpOwp9CgpzdGF0aWMgaW50IHZlcmlmeV91cHRvZGF0ZShzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlLAoJCQkgICBzdHJ1Y3QgdW5wYWNrX3RyZWVzX29wdGlvbnMgKm8pCnsKCWlmICghby0+c2tpcF9zcGFyc2VfY2hlY2tvdXQgJiYgKGNlLT5jZV9mbGFncyAmIENFX05FV19TS0lQX1dPUktUUkVFKSkKCQlyZXR1cm4gMDsKCXJldHVybiB2ZXJpZnlfdXB0b2RhdGVfMShjZSwgbywgRVJST1JfTk9UX1VQVE9EQVRFX0ZJTEUpOwp9CgpzdGF0aWMgaW50IHZlcmlmeV91cHRvZGF0ZV9zcGFyc2Uoc3RydWN0IGNhY2hlX2VudHJ5ICpjZSwKCQkJCSAgc3RydWN0IHVucGFja190cmVlc19vcHRpb25zICpvKQp7CglyZXR1cm4gdmVyaWZ5X3VwdG9kYXRlXzEoY2UsIG8sIEVSUk9SX1NQQVJTRV9OT1RfVVBUT0RBVEVfRklMRSk7Cn0KCnN0YXRpYyB2b2lkIGludmFsaWRhdGVfY2VfcGF0aChzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlLCBzdHJ1Y3QgdW5wYWNrX3RyZWVzX29wdGlvbnMgKm8pCnsKCWlmIChjZSkKCQljYWNoZV90cmVlX2ludmFsaWRhdGVfcGF0aChvLT5zcmNfaW5kZXgtPmNhY2hlX3RyZWUsIGNlLT5uYW1lKTsKfQoKLyoKICogQ2hlY2sgdGhhdCBjaGVja2luZyBvdXQgY2UtPnNoYTEgaW4gc3ViZGlyIGNlLT5uYW1lIGlzIG5vdAogKiBnb2luZyB0byBvdmVyd3JpdGUgYW55IHdvcmtpbmcgZmlsZXMuCiAqCiAqIEN1cnJlbnRseSwgZ2l0IGRvZXMgbm90IGNoZWNrb3V0IHN1YnByb2plY3RzIGR1cmluZyBhIHN1cGVycHJvamVjdAogKiBjaGVja291dCwgc28gaXQgaXMgbm90IGdvaW5nIHRvIG92ZXJ3cml0ZSBhbnl0aGluZy4KICovCnN0YXRpYyBpbnQgdmVyaWZ5X2NsZWFuX3N1Ym1vZHVsZShzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlLAoJCQkJICAgICAgZW51bSB1bnBhY2tfdHJlZXNfZXJyb3JfdHlwZXMgZXJyb3JfdHlwZSwKCQkJCSAgICAgIHN0cnVjdCB1bnBhY2tfdHJlZXNfb3B0aW9ucyAqbykKewoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgdmVyaWZ5X2NsZWFuX3N1YmRpcmVjdG9yeShzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlLAoJCQkJICAgICAgZW51bSB1bnBhY2tfdHJlZXNfZXJyb3JfdHlwZXMgZXJyb3JfdHlwZSwKCQkJCSAgICAgIHN0cnVjdCB1bnBhY2tfdHJlZXNfb3B0aW9ucyAqbykKewoJLyoKCSAqIHdlIGFyZSBhYm91dCB0byBleHRyYWN0ICJjZS0+bmFtZSI7IHdlIHdvdWxkIG5vdCB3YW50IHRvIGxvc2UKCSAqIGFueXRoaW5nIGluIHRoZSBleGlzdGluZyBkaXJlY3RvcnkgdGhlcmUuCgkgKi8KCWludCBuYW1lbGVuOwoJaW50IGk7CglzdHJ1Y3QgZGlyX3N0cnVjdCBkOwoJY2hhciAqcGF0aGJ1ZjsKCWludCBjbnQgPSAwOwoJdW5zaWduZWQgY2hhciBzaGExWzIwXTsKCglpZiAoU19JU0dJVExJTksoY2UtPmNlX21vZGUpICYmCgkgICAgcmVzb2x2ZV9naXRsaW5rX3JlZihjZS0+bmFtZSwgIkhFQUQiLCBzaGExKSA9PSAwKSB7CgkJLyogSWYgd2UgYXJlIG5vdCBnb2luZyB0byB1cGRhdGUgdGhlIHN1Ym1vZHVsZSwgdGhlbgoJCSAqIHdlIGRvbid0IGNhcmUuCgkJICovCgkJaWYgKCFoYXNoY21wKHNoYTEsIGNlLT5zaGExKSkKCQkJcmV0dXJuIDA7CgkJcmV0dXJuIHZlcmlmeV9jbGVhbl9zdWJtb2R1bGUoY2UsIGVycm9yX3R5cGUsIG8pOwoJfQoKCS8qCgkgKiBGaXJzdCBsZXQncyBtYWtlIHN1cmUgd2UgZG8gbm90IGhhdmUgYSBsb2NhbCBtb2RpZmljYXRpb24KCSAqIGluIHRoYXQgZGlyZWN0b3J5LgoJICovCgluYW1lbGVuID0gc3RybGVuKGNlLT5uYW1lKTsKCWZvciAoaSA9IGxvY2F0ZV9pbl9zcmNfaW5kZXgoY2UsIG8pOwoJICAgICBpIDwgby0+c3JjX2luZGV4LT5jYWNoZV9ucjsKCSAgICAgaSsrKSB7CgkJc3RydWN0IGNhY2hlX2VudHJ5ICpjZTIgPSBvLT5zcmNfaW5kZXgtPmNhY2hlW2ldOwoJCWludCBsZW4gPSBjZV9uYW1lbGVuKGNlMik7CgkJaWYgKGxlbiA8IG5hbWVsZW4gfHwKCQkgICAgc3RybmNtcChjZS0+bmFtZSwgY2UyLT5uYW1lLCBuYW1lbGVuKSB8fAoJCSAgICBjZTItPm5hbWVbbmFtZWxlbl0gIT0gJy8nKQoJCQlicmVhazsKCQkvKgoJCSAqIGNlMi0+bmFtZSBpcyBhbiBlbnRyeSBpbiB0aGUgc3ViZGlyZWN0b3J5IHRvIGJlCgkJICogcmVtb3ZlZC4KCQkgKi8KCQlpZiAoIWNlX3N0YWdlKGNlMikpIHsKCQkJaWYgKHZlcmlmeV91cHRvZGF0ZShjZTIsIG8pKQoJCQkJcmV0dXJuIC0xOwoJCQlhZGRfZW50cnkobywgY2UyLCBDRV9SRU1PVkUsIDApOwoJCQltYXJrX2NlX3VzZWQoY2UyLCBvKTsKCQl9CgkJY250Kys7Cgl9CgoJLyoKCSAqIFRoZW4gd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhhdCB3ZSBkbyBub3QgbG9zZSBhIGxvY2FsbHkKCSAqIHByZXNlbnQgZmlsZSB0aGF0IGlzIG5vdCBpZ25vcmVkLgoJICovCglwYXRoYnVmID0geG1hbGxvYyhuYW1lbGVuICsgMik7CgltZW1jcHkocGF0aGJ1ZiwgY2UtPm5hbWUsIG5hbWVsZW4pOwoJc3RyY3B5KHBhdGhidWYrbmFtZWxlbiwgIi8iKTsKCgltZW1zZXQoJmQsIDAsIHNpemVvZihkKSk7CglpZiAoby0+ZGlyKQoJCWQuZXhjbHVkZV9wZXJfZGlyID0gby0+ZGlyLT5leGNsdWRlX3Blcl9kaXI7CglpID0gcmVhZF9kaXJlY3RvcnkoJmQsIHBhdGhidWYsIG5hbWVsZW4rMSwgTlVMTCk7CglpZiAoaSkKCQlyZXR1cm4gby0+Z2VudGx5ID8gLTEgOgoJCQlhZGRfcmVqZWN0ZWRfcGF0aChvLCBFUlJPUl9OT1RfVVBUT0RBVEVfRElSLCBjZS0+bmFtZSk7CglmcmVlKHBhdGhidWYpOwoJcmV0dXJuIGNudDsKfQoKLyoKICogVGhpcyBnZXRzIGNhbGxlZCB3aGVuIHRoZXJlIHdhcyBubyBpbmRleCBlbnRyeSBmb3IgdGhlIHRyZWUgZW50cnkgJ2RzdCcsCiAqIGJ1dCB3ZSBmb3VuZCBhIGZpbGUgaW4gdGhlIHdvcmtpbmcgdHJlZSB0aGF0ICdsc3RhdCgpJyBzYWlkIHdhcyBmaW5lLAogKiBhbmQgd2UncmUgb24gYSBjYXNlLWluc2Vuc2l0aXZlIGZpbGVzeXN0ZW0uCiAqCiAqIFNlZSBpZiB3ZSBjYW4gZmluZCBhIGNhc2UtaW5zZW5zaXRpdmUgbWF0Y2ggaW4gdGhlIGluZGV4IHRoYXQgYWxzbwogKiBtYXRjaGVzIHRoZSBzdGF0IGluZm9ybWF0aW9uLCBhbmQgYXNzdW1lIGl0J3MgdGhhdCBvdGhlciBmaWxlIQogKi8Kc3RhdGljIGludCBpY2FzZV9leGlzdHMoc3RydWN0IHVucGFja190cmVlc19vcHRpb25zICpvLCBjb25zdCBjaGFyICpuYW1lLCBpbnQgbGVuLCBzdHJ1Y3Qgc3RhdCAqc3QpCnsKCXN0cnVjdCBjYWNoZV9lbnRyeSAqc3JjOwoKCXNyYyA9IGluZGV4X25hbWVfZXhpc3RzKG8tPnNyY19pbmRleCwgbmFtZSwgbGVuLCAxKTsKCXJldHVybiBzcmMgJiYgIWllX21hdGNoX3N0YXQoby0+c3JjX2luZGV4LCBzcmMsIHN0LCBDRV9NQVRDSF9JR05PUkVfVkFMSUR8Q0VfTUFUQ0hfSUdOT1JFX1NLSVBfV09SS1RSRUUpOwp9CgpzdGF0aWMgaW50IGNoZWNrX29rX3RvX3JlbW92ZShjb25zdCBjaGFyICpuYW1lLCBpbnQgbGVuLCBpbnQgZHR5cGUsCgkJCSAgICAgIHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UsIHN0cnVjdCBzdGF0ICpzdCwKCQkJICAgICAgZW51bSB1bnBhY2tfdHJlZXNfZXJyb3JfdHlwZXMgZXJyb3JfdHlwZSwKCQkJICAgICAgc3RydWN0IHVucGFja190cmVlc19vcHRpb25zICpvKQp7CglzdHJ1Y3QgY2FjaGVfZW50cnkgKnJlc3VsdDsKCgkvKgoJICogSXQgbWF5IGJlIHRoYXQgdGhlICdsc3RhdCgpJyBzdWNjZWVkZWQgZXZlbiB0aG91Z2gKCSAqIHRhcmdldCAnY2UnIHdhcyBhYnNlbnQsIGJlY2F1c2UgdGhlcmUgaXMgYW4gb2xkCgkgKiBlbnRyeSB0aGF0IGlzIGRpZmZlcmVudCBvbmx5IGluIGNhc2UuLgoJICoKCSAqIElnbm9yZSB0aGF0IGxzdGF0KCkgaWYgaXQgbWF0Y2hlcy4KCSAqLwoJaWYgKGlnbm9yZV9jYXNlICYmIGljYXNlX2V4aXN0cyhvLCBuYW1lLCBsZW4sIHN0KSkKCQlyZXR1cm4gMDsKCglpZiAoby0+ZGlyICYmCgkgICAgcGF0aF9leGNsdWRlZChvLT5wYXRoX2V4Y2x1ZGVfY2hlY2ssIG5hbWUsIC0xLCAmZHR5cGUpKQoJCS8qCgkJICogY2UtPm5hbWUgaXMgZXhwbGljaXRseSBleGNsdWRlZCwgc28gaXQgaXMgT2sgdG8KCQkgKiBvdmVyd3JpdGUgaXQuCgkJICovCgkJcmV0dXJuIDA7CglpZiAoU19JU0RJUihzdC0+c3RfbW9kZSkpIHsKCQkvKgoJCSAqIFdlIGFyZSBjaGVja2luZyBvdXQgcGF0aCAiZm9vIiBhbmQKCQkgKiBmb3VuZCAiZm9vLy4iIGluIHRoZSB3b3JraW5nIHRyZWUuCgkJICogVGhpcyBpcyB0cmlja3kgLS0gaWYgd2UgaGF2ZSBtb2RpZmllZAoJCSAqIGZpbGVzIHRoYXQgYXJlIGluICJmb28vIiB3ZSB3b3VsZCBsb3NlCgkJICogdGhlbS4KCQkgKi8KCQlpZiAodmVyaWZ5X2NsZWFuX3N1YmRpcmVjdG9yeShjZSwgZXJyb3JfdHlwZSwgbykgPCAwKQoJCQlyZXR1cm4gLTE7CgkJcmV0dXJuIDA7Cgl9CgoJLyoKCSAqIFRoZSBwcmV2aW91cyByb3VuZCBtYXkgYWxyZWFkeSBoYXZlIGRlY2lkZWQgdG8KCSAqIGRlbGV0ZSB0aGlzIHBhdGgsIHdoaWNoIGlzIGluIGEgc3ViZGlyZWN0b3J5IHRoYXQKCSAqIGlzIGJlaW5nIHJlcGxhY2VkIHdpdGggYSBibG9iLgoJICovCglyZXN1bHQgPSBpbmRleF9uYW1lX2V4aXN0cygmby0+cmVzdWx0LCBuYW1lLCBsZW4sIDApOwoJaWYgKHJlc3VsdCkgewoJCWlmIChyZXN1bHQtPmNlX2ZsYWdzICYgQ0VfUkVNT1ZFKQoJCQlyZXR1cm4gMDsKCX0KCglyZXR1cm4gby0+Z2VudGx5ID8gLTEgOgoJCWFkZF9yZWplY3RlZF9wYXRoKG8sIGVycm9yX3R5cGUsIG5hbWUpOwp9CgovKgogKiBXZSBkbyBub3Qgd2FudCB0byByZW1vdmUgb3Igb3ZlcndyaXRlIGEgd29ya2luZyB0cmVlIGZpbGUgdGhhdAogKiBpcyBub3QgdHJhY2tlZCwgdW5sZXNzIGl0IGlzIGlnbm9yZWQuCiAqLwpzdGF0aWMgaW50IHZlcmlmeV9hYnNlbnRfMShzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlLAoJCQkJIGVudW0gdW5wYWNrX3RyZWVzX2Vycm9yX3R5cGVzIGVycm9yX3R5cGUsCgkJCQkgc3RydWN0IHVucGFja190cmVlc19vcHRpb25zICpvKQp7CglpbnQgbGVuOwoJc3RydWN0IHN0YXQgc3Q7CgoJaWYgKG8tPmluZGV4X29ubHkgfHwgby0+cmVzZXQgfHwgIW8tPnVwZGF0ZSkKCQlyZXR1cm4gMDsKCglsZW4gPSBjaGVja19sZWFkaW5nX3BhdGgoY2UtPm5hbWUsIGNlX25hbWVsZW4oY2UpKTsKCWlmICghbGVuKQoJCXJldHVybiAwOwoJZWxzZSBpZiAobGVuID4gMCkgewoJCWNoYXIgcGF0aFtQQVRIX01BWCArIDFdOwoJCW1lbWNweShwYXRoLCBjZS0+bmFtZSwgbGVuKTsKCQlwYXRoW2xlbl0gPSAwOwoJCWlmIChsc3RhdChwYXRoLCAmc3QpKQoJCQlyZXR1cm4gZXJyb3IoImNhbm5vdCBzdGF0ICclcyc6ICVzIiwgcGF0aCwKCQkJCQlzdHJlcnJvcihlcnJubykpOwoKCQlyZXR1cm4gY2hlY2tfb2tfdG9fcmVtb3ZlKHBhdGgsIGxlbiwgRFRfVU5LTk9XTiwgTlVMTCwgJnN0LAoJCQkJZXJyb3JfdHlwZSwgbyk7Cgl9IGVsc2UgaWYgKGxzdGF0KGNlLT5uYW1lLCAmc3QpKSB7CgkJaWYgKGVycm5vICE9IEVOT0VOVCkKCQkJcmV0dXJuIGVycm9yKCJjYW5ub3Qgc3RhdCAnJXMnOiAlcyIsIGNlLT5uYW1lLAoJCQkJICAgICBzdHJlcnJvcihlcnJubykpOwoJCXJldHVybiAwOwoJfSBlbHNlIHsKCQlyZXR1cm4gY2hlY2tfb2tfdG9fcmVtb3ZlKGNlLT5uYW1lLCBjZV9uYW1lbGVuKGNlKSwKCQkJCQkgIGNlX3RvX2R0eXBlKGNlKSwgY2UsICZzdCwKCQkJCQkgIGVycm9yX3R5cGUsIG8pOwoJfQp9CgpzdGF0aWMgaW50IHZlcmlmeV9hYnNlbnQoc3RydWN0IGNhY2hlX2VudHJ5ICpjZSwKCQkJIGVudW0gdW5wYWNrX3RyZWVzX2Vycm9yX3R5cGVzIGVycm9yX3R5cGUsCgkJCSBzdHJ1Y3QgdW5wYWNrX3RyZWVzX29wdGlvbnMgKm8pCnsKCWlmICghby0+c2tpcF9zcGFyc2VfY2hlY2tvdXQgJiYgKGNlLT5jZV9mbGFncyAmIENFX05FV19TS0lQX1dPUktUUkVFKSkKCQlyZXR1cm4gMDsKCXJldHVybiB2ZXJpZnlfYWJzZW50XzEoY2UsIGVycm9yX3R5cGUsIG8pOwp9CgpzdGF0aWMgaW50IHZlcmlmeV9hYnNlbnRfc3BhcnNlKHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UsCgkJCSBlbnVtIHVucGFja190cmVlc19lcnJvcl90eXBlcyBlcnJvcl90eXBlLAoJCQkgc3RydWN0IHVucGFja190cmVlc19vcHRpb25zICpvKQp7CgllbnVtIHVucGFja190cmVlc19lcnJvcl90eXBlcyBvcnBoYW5lZF9lcnJvciA9IGVycm9yX3R5cGU7CglpZiAob3JwaGFuZWRfZXJyb3IgPT0gRVJST1JfV09VTERfTE9TRV9VTlRSQUNLRURfT1ZFUldSSVRURU4pCgkJb3JwaGFuZWRfZXJyb3IgPSBFUlJPUl9XT1VMRF9MT1NFX09SUEhBTkVEX09WRVJXUklUVEVOOwoKCXJldHVybiB2ZXJpZnlfYWJzZW50XzEoY2UsIG9ycGhhbmVkX2Vycm9yLCBvKTsKfQoKc3RhdGljIGludCBtZXJnZWRfZW50cnkoc3RydWN0IGNhY2hlX2VudHJ5ICptZXJnZSwgc3RydWN0IGNhY2hlX2VudHJ5ICpvbGQsCgkJc3RydWN0IHVucGFja190cmVlc19vcHRpb25zICpvKQp7CglpbnQgdXBkYXRlID0gQ0VfVVBEQVRFOwoKCWlmICghb2xkKSB7CgkJLyoKCQkgKiBOZXcgaW5kZXggZW50cmllcy4gSW4gc3BhcnNlIGNoZWNrb3V0LCB0aGUgZm9sbG93aW5nCgkJICogdmVyaWZ5X2Fic2VudCgpIHdpbGwgYmUgZGVsYXllZCB1bnRpbCBhZnRlcgoJCSAqIHRyYXZlcnNlX3RyZWVzKCkgZmluaXNoZXMgaW4gdW5wYWNrX3RyZWVzKCksIHRoZW46CgkJICoKCQkgKiAgLSBDRV9ORVdfU0tJUF9XT1JLVFJFRSB3aWxsIGJlIGNvbXB1dGVkIGNvcnJlY3RseQoJCSAqICAtIHZlcmlmeV9hYnNlbnQoKSBiZSBjYWxsZWQgYWdhaW4sIHRoaXMgdGltZSB3aXRoCgkJICogICAgY29ycmVjdCBDRV9ORVdfU0tJUF9XT1JLVFJFRQoJCSAqCgkJICogdmVyaWZ5X2Fic2VudCgpIGNhbGwgaGVyZSBkb2VzIG5vdGhpbmcgaW4gc3BhcnNlCgkJICogY2hlY2tvdXQgKGkuZS4gby0+c2tpcF9zcGFyc2VfY2hlY2tvdXQgPT0gMCkKCQkgKi8KCQl1cGRhdGUgfD0gQ0VfQURERUQ7CgkJbWVyZ2UtPmNlX2ZsYWdzIHw9IENFX05FV19TS0lQX1dPUktUUkVFOwoKCQlpZiAodmVyaWZ5X2Fic2VudChtZXJnZSwgRVJST1JfV09VTERfTE9TRV9VTlRSQUNLRURfT1ZFUldSSVRURU4sIG8pKQoJCQlyZXR1cm4gLTE7CgkJaW52YWxpZGF0ZV9jZV9wYXRoKG1lcmdlLCBvKTsKCX0gZWxzZSBpZiAoIShvbGQtPmNlX2ZsYWdzICYgQ0VfQ09ORkxJQ1RFRCkpIHsKCQkvKgoJCSAqIFNlZSBpZiB3ZSBjYW4gcmUtdXNlIHRoZSBvbGQgQ0UgZGlyZWN0bHk/CgkJICogVGhhdCB3YXkgd2UgZ2V0IHRoZSB1cHRvZGF0ZSBzdGF0IGluZm8uCgkJICoKCQkgKiBUaGlzIGFsc28gcmVtb3ZlcyB0aGUgVVBEQVRFIGZsYWcgb24gYSBtYXRjaDsgb3RoZXJ3aXNlCgkJICogd2Ugd2lsbCBlbmQgdXAgb3ZlcndyaXRpbmcgbG9jYWwgY2hhbmdlcyBpbiB0aGUgd29yayB0cmVlLgoJCSAqLwoJCWlmIChzYW1lKG9sZCwgbWVyZ2UpKSB7CgkJCWNvcHlfY2FjaGVfZW50cnkobWVyZ2UsIG9sZCk7CgkJCXVwZGF0ZSA9IDA7CgkJfSBlbHNlIHsKCQkJaWYgKHZlcmlmeV91cHRvZGF0ZShvbGQsIG8pKQoJCQkJcmV0dXJuIC0xOwoJCQkvKiBNaWdyYXRlIG9sZCBmbGFncyBvdmVyICovCgkJCXVwZGF0ZSB8PSBvbGQtPmNlX2ZsYWdzICYgKENFX1NLSVBfV09SS1RSRUUgfCBDRV9ORVdfU0tJUF9XT1JLVFJFRSk7CgkJCWludmFsaWRhdGVfY2VfcGF0aChvbGQsIG8pOwoJCX0KCX0gZWxzZSB7CgkJLyoKCQkgKiBQcmV2aW91c2x5IHVubWVyZ2VkIGVudHJ5IGxlZnQgYXMgYW4gZXhpc3RlbmNlCgkJICogbWFya2VyIGJ5IHJlYWRfaW5kZXhfdW5tZXJnZWQoKTsKCQkgKi8KCQlpbnZhbGlkYXRlX2NlX3BhdGgob2xkLCBvKTsKCX0KCglhZGRfZW50cnkobywgbWVyZ2UsIHVwZGF0ZSwgQ0VfU1RBR0VNQVNLKTsKCXJldHVybiAxOwp9CgpzdGF0aWMgaW50IGRlbGV0ZWRfZW50cnkoc3RydWN0IGNhY2hlX2VudHJ5ICpjZSwgc3RydWN0IGNhY2hlX2VudHJ5ICpvbGQsCgkJc3RydWN0IHVucGFja190cmVlc19vcHRpb25zICpvKQp7CgkvKiBEaWQgaXQgZXhpc3QgaW4gdGhlIGluZGV4PyAqLwoJaWYgKCFvbGQpIHsKCQlpZiAodmVyaWZ5X2Fic2VudChjZSwgRVJST1JfV09VTERfTE9TRV9VTlRSQUNLRURfUkVNT1ZFRCwgbykpCgkJCXJldHVybiAtMTsKCQlyZXR1cm4gMDsKCX0KCWlmICghKG9sZC0+Y2VfZmxhZ3MgJiBDRV9DT05GTElDVEVEKSAmJiB2ZXJpZnlfdXB0b2RhdGUob2xkLCBvKSkKCQlyZXR1cm4gLTE7CglhZGRfZW50cnkobywgY2UsIENFX1JFTU9WRSwgMCk7CglpbnZhbGlkYXRlX2NlX3BhdGgoY2UsIG8pOwoJcmV0dXJuIDE7Cn0KCnN0YXRpYyBpbnQga2VlcF9lbnRyeShzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlLCBzdHJ1Y3QgdW5wYWNrX3RyZWVzX29wdGlvbnMgKm8pCnsKCWFkZF9lbnRyeShvLCBjZSwgMCwgMCk7CglyZXR1cm4gMTsKfQoKI2lmIERCUlRfREVCVUcKc3RhdGljIHZvaWQgc2hvd19zdGFnZV9lbnRyeShGSUxFICpvLAoJCQkgICAgIGNvbnN0IGNoYXIgKmxhYmVsLCBjb25zdCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlKQp7CglpZiAoIWNlKQoJCWZwcmludGYobywgIiVzIChtaXNzaW5nKVxuIiwgbGFiZWwpOwoJZWxzZQoJCWZwcmludGYobywgIiVzJTA2byAlcyAlZFx0JXNcbiIsCgkJCWxhYmVsLAoJCQljZS0+Y2VfbW9kZSwKCQkJc2hhMV90b19oZXgoY2UtPnNoYTEpLAoJCQljZV9zdGFnZShjZSksCgkJCWNlLT5uYW1lKTsKfQojZW5kaWYKCmludCB0aHJlZXdheV9tZXJnZShzdHJ1Y3QgY2FjaGVfZW50cnkgKipzdGFnZXMsIHN0cnVjdCB1bnBhY2tfdHJlZXNfb3B0aW9ucyAqbykKewoJc3RydWN0IGNhY2hlX2VudHJ5ICppbmRleDsKCXN0cnVjdCBjYWNoZV9lbnRyeSAqaGVhZDsKCXN0cnVjdCBjYWNoZV9lbnRyeSAqcmVtb3RlID0gc3RhZ2VzW28tPmhlYWRfaWR4ICsgMV07CglpbnQgY291bnQ7CglpbnQgaGVhZF9tYXRjaCA9IDA7CglpbnQgcmVtb3RlX21hdGNoID0gMDsKCglpbnQgZGZfY29uZmxpY3RfaGVhZCA9IDA7CglpbnQgZGZfY29uZmxpY3RfcmVtb3RlID0gMDsKCglpbnQgYW55X2FuY19taXNzaW5nID0gMDsKCWludCBub19hbmNfZXhpc3RzID0gMTsKCWludCBpOwoKCWZvciAoaSA9IDE7IGkgPCBvLT5oZWFkX2lkeDsgaSsrKSB7CgkJaWYgKCFzdGFnZXNbaV0gfHwgc3RhZ2VzW2ldID09IG8tPmRmX2NvbmZsaWN0X2VudHJ5KQoJCQlhbnlfYW5jX21pc3NpbmcgPSAxOwoJCWVsc2UKCQkJbm9fYW5jX2V4aXN0cyA9IDA7Cgl9CgoJaW5kZXggPSBzdGFnZXNbMF07CgloZWFkID0gc3RhZ2VzW28tPmhlYWRfaWR4XTsKCglpZiAoaGVhZCA9PSBvLT5kZl9jb25mbGljdF9lbnRyeSkgewoJCWRmX2NvbmZsaWN0X2hlYWQgPSAxOwoJCWhlYWQgPSBOVUxMOwoJfQoKCWlmIChyZW1vdGUgPT0gby0+ZGZfY29uZmxpY3RfZW50cnkpIHsKCQlkZl9jb25mbGljdF9yZW1vdGUgPSAxOwoJCXJlbW90ZSA9IE5VTEw7Cgl9CgoJLyoKCSAqIEZpcnN0LCBpZiB0aGVyZSdzIGEgIzE2IHNpdHVhdGlvbiwgbm90ZSB0aGF0IHRvIHByZXZlbnQgIzEzCgkgKiBhbmQgIzE0LgoJICovCglpZiAoIXNhbWUocmVtb3RlLCBoZWFkKSkgewoJCWZvciAoaSA9IDE7IGkgPCBvLT5oZWFkX2lkeDsgaSsrKSB7CgkJCWlmIChzYW1lKHN0YWdlc1tpXSwgaGVhZCkpIHsKCQkJCWhlYWRfbWF0Y2ggPSBpOwoJCQl9CgkJCWlmIChzYW1lKHN0YWdlc1tpXSwgcmVtb3RlKSkgewoJCQkJcmVtb3RlX21hdGNoID0gaTsKCQkJfQoJCX0KCX0KCgkvKgoJICogV2Ugc3RhcnQgd2l0aCBjYXNlcyB3aGVyZSB0aGUgaW5kZXggaXMgYWxsb3dlZCB0byBtYXRjaAoJICogc29tZXRoaW5nIG90aGVyIHRoYW4gdGhlIGhlYWQ6ICMxNChBTFQpIGFuZCAjMkFMVCwgd2hlcmUgaXQKCSAqIGlzIHBlcm1pdHRlZCB0byBtYXRjaCB0aGUgcmVzdWx0IGluc3RlYWQuCgkgKi8KCS8qICMxNCwgIzE0QUxULCAjMkFMVCAqLwoJaWYgKHJlbW90ZSAmJiAhZGZfY29uZmxpY3RfaGVhZCAmJiBoZWFkX21hdGNoICYmICFyZW1vdGVfbWF0Y2gpIHsKCQlpZiAoaW5kZXggJiYgIXNhbWUoaW5kZXgsIHJlbW90ZSkgJiYgIXNhbWUoaW5kZXgsIGhlYWQpKQoJCQlyZXR1cm4gby0+Z2VudGx5ID8gLTEgOiByZWplY3RfbWVyZ2UoaW5kZXgsIG8pOwoJCXJldHVybiBtZXJnZWRfZW50cnkocmVtb3RlLCBpbmRleCwgbyk7Cgl9CgkvKgoJICogSWYgd2UgaGF2ZSBhbiBlbnRyeSBpbiB0aGUgaW5kZXggY2FjaGUsIHRoZW4gd2Ugd2FudCB0bwoJICogbWFrZSBzdXJlIHRoYXQgaXQgbWF0Y2hlcyBoZWFkLgoJICovCglpZiAoaW5kZXggJiYgIXNhbWUoaW5kZXgsIGhlYWQpKQoJCXJldHVybiBvLT5nZW50bHkgPyAtMSA6IHJlamVjdF9tZXJnZShpbmRleCwgbyk7CgoJaWYgKGhlYWQpIHsKCQkvKiAjNUFMVCwgIzE1ICovCgkJaWYgKHNhbWUoaGVhZCwgcmVtb3RlKSkKCQkJcmV0dXJuIG1lcmdlZF9lbnRyeShoZWFkLCBpbmRleCwgbyk7CgkJLyogIzEzLCAjM0FMVCAqLwoJCWlmICghZGZfY29uZmxpY3RfcmVtb3RlICYmIHJlbW90ZV9tYXRjaCAmJiAhaGVhZF9tYXRjaCkKCQkJcmV0dXJuIG1lcmdlZF9lbnRyeShoZWFkLCBpbmRleCwgbyk7Cgl9CgoJLyogIzEgKi8KCWlmICghaGVhZCAmJiAhcmVtb3RlICYmIGFueV9hbmNfbWlzc2luZykKCQlyZXR1cm4gMDsKCgkvKgoJICogVW5kZXIgdGhlICJhZ2dyZXNzaXZlIiBydWxlLCB3ZSByZXNvbHZlIG1vc3RseSB0cml2aWFsCgkgKiBjYXNlcyB0aGF0IHdlIGhpc3RvcmljYWxseSBoYWQgZ2l0LW1lcmdlLW9uZS1maWxlIHJlc29sdmUuCgkgKi8KCWlmIChvLT5hZ2dyZXNzaXZlKSB7CgkJaW50IGhlYWRfZGVsZXRlZCA9ICFoZWFkOwoJCWludCByZW1vdGVfZGVsZXRlZCA9ICFyZW1vdGU7CgkJc3RydWN0IGNhY2hlX2VudHJ5ICpjZSA9IE5VTEw7CgoJCWlmIChpbmRleCkKCQkJY2UgPSBpbmRleDsKCQllbHNlIGlmIChoZWFkKQoJCQljZSA9IGhlYWQ7CgkJZWxzZSBpZiAocmVtb3RlKQoJCQljZSA9IHJlbW90ZTsKCQllbHNlIHsKCQkJZm9yIChpID0gMTsgaSA8IG8tPmhlYWRfaWR4OyBpKyspIHsKCQkJCWlmIChzdGFnZXNbaV0gJiYgc3RhZ2VzW2ldICE9IG8tPmRmX2NvbmZsaWN0X2VudHJ5KSB7CgkJCQkJY2UgPSBzdGFnZXNbaV07CgkJCQkJYnJlYWs7CgkJCQl9CgkJCX0KCQl9CgoJCS8qCgkJICogRGVsZXRlZCBpbiBib3RoLgoJCSAqIERlbGV0ZWQgaW4gb25lIGFuZCB1bmNoYW5nZWQgaW4gdGhlIG90aGVyLgoJCSAqLwoJCWlmICgoaGVhZF9kZWxldGVkICYmIHJlbW90ZV9kZWxldGVkKSB8fAoJCSAgICAoaGVhZF9kZWxldGVkICYmIHJlbW90ZSAmJiByZW1vdGVfbWF0Y2gpIHx8CgkJICAgIChyZW1vdGVfZGVsZXRlZCAmJiBoZWFkICYmIGhlYWRfbWF0Y2gpKSB7CgkJCWlmIChpbmRleCkKCQkJCXJldHVybiBkZWxldGVkX2VudHJ5KGluZGV4LCBpbmRleCwgbyk7CgkJCWlmIChjZSAmJiAhaGVhZF9kZWxldGVkKSB7CgkJCQlpZiAodmVyaWZ5X2Fic2VudChjZSwgRVJST1JfV09VTERfTE9TRV9VTlRSQUNLRURfUkVNT1ZFRCwgbykpCgkJCQkJcmV0dXJuIC0xOwoJCQl9CgkJCXJldHVybiAwOwoJCX0KCQkvKgoJCSAqIEFkZGVkIGluIGJvdGgsIGlkZW50aWNhbGx5LgoJCSAqLwoJCWlmIChub19hbmNfZXhpc3RzICYmIGhlYWQgJiYgcmVtb3RlICYmIHNhbWUoaGVhZCwgcmVtb3RlKSkKCQkJcmV0dXJuIG1lcmdlZF9lbnRyeShoZWFkLCBpbmRleCwgbyk7CgoJfQoKCS8qIEJlbG93IGFyZSAibm8gbWVyZ2UiIGNhc2VzLCB3aGljaCByZXF1aXJlIHRoYXQgdGhlIGluZGV4IGJlCgkgKiB1cC10by1kYXRlIHRvIGF2b2lkIHRoZSBmaWxlcyBnZXR0aW5nIG92ZXJ3cml0dGVuIHdpdGgKCSAqIGNvbmZsaWN0IHJlc29sdXRpb24gZmlsZXMuCgkgKi8KCWlmIChpbmRleCkgewoJCWlmICh2ZXJpZnlfdXB0b2RhdGUoaW5kZXgsIG8pKQoJCQlyZXR1cm4gLTE7Cgl9CgoJby0+bm9udHJpdmlhbF9tZXJnZSA9IDE7CgoJLyogIzIsICMzLCAjNCwgIzYsICM3LCAjOSwgIzEwLCAjMTEuICovCgljb3VudCA9IDA7CglpZiAoIWhlYWRfbWF0Y2ggfHwgIXJlbW90ZV9tYXRjaCkgewoJCWZvciAoaSA9IDE7IGkgPCBvLT5oZWFkX2lkeDsgaSsrKSB7CgkJCWlmIChzdGFnZXNbaV0gJiYgc3RhZ2VzW2ldICE9IG8tPmRmX2NvbmZsaWN0X2VudHJ5KSB7CgkJCQlrZWVwX2VudHJ5KHN0YWdlc1tpXSwgbyk7CgkJCQljb3VudCsrOwoJCQkJYnJlYWs7CgkJCX0KCQl9Cgl9CiNpZiBEQlJUX0RFQlVHCgllbHNlIHsKCQlmcHJpbnRmKHN0ZGVyciwgInJlYWQtdHJlZTogd2FybmluZyAjMTYgZGV0ZWN0ZWRcbiIpOwoJCXNob3dfc3RhZ2VfZW50cnkoc3RkZXJyLCAiaGVhZCAgICIsIHN0YWdlc1toZWFkX21hdGNoXSk7CgkJc2hvd19zdGFnZV9lbnRyeShzdGRlcnIsICJyZW1vdGUgIiwgc3RhZ2VzW3JlbW90ZV9tYXRjaF0pOwoJfQojZW5kaWYKCWlmIChoZWFkKSB7IGNvdW50ICs9IGtlZXBfZW50cnkoaGVhZCwgbyk7IH0KCWlmIChyZW1vdGUpIHsgY291bnQgKz0ga2VlcF9lbnRyeShyZW1vdGUsIG8pOyB9CglyZXR1cm4gY291bnQ7Cn0KCi8qCiAqIFR3by13YXkgbWVyZ2UuCiAqCiAqIFRoZSBydWxlIGlzIHRvICJjYXJyeSBmb3J3YXJkIiB3aGF0IGlzIGluIHRoZSBpbmRleCB3aXRob3V0IGxvc2luZwogKiBpbmZvcm1hdGlvbiBhY3Jvc3MgYSAiZmFzdC1mb3J3YXJkIiwgZmF2b3JpbmcgYSBzdWNjZXNzZnVsIG1lcmdlCiAqIG92ZXIgYSBtZXJnZSBmYWlsdXJlIHdoZW4gaXQgbWFrZXMgc2Vuc2UuICBGb3IgZGV0YWlscyBvZiB0aGUKICogImNhcnJ5IGZvcndhcmQiIHJ1bGUsIHBsZWFzZSBzZWUgPERvY3VtZW50YXRpb24vZ2l0LXJlYWQtdHJlZS50eHQ+LgogKgogKi8KaW50IHR3b3dheV9tZXJnZShzdHJ1Y3QgY2FjaGVfZW50cnkgKipzcmMsIHN0cnVjdCB1bnBhY2tfdHJlZXNfb3B0aW9ucyAqbykKewoJc3RydWN0IGNhY2hlX2VudHJ5ICpjdXJyZW50ID0gc3JjWzBdOwoJc3RydWN0IGNhY2hlX2VudHJ5ICpvbGR0cmVlID0gc3JjWzFdOwoJc3RydWN0IGNhY2hlX2VudHJ5ICpuZXd0cmVlID0gc3JjWzJdOwoKCWlmIChvLT5tZXJnZV9zaXplICE9IDIpCgkJcmV0dXJuIGVycm9yKCJDYW5ub3QgZG8gYSB0d293YXkgbWVyZ2Ugb2YgJWQgdHJlZXMiLAoJCQkgICAgIG8tPm1lcmdlX3NpemUpOwoKCWlmIChvbGR0cmVlID09IG8tPmRmX2NvbmZsaWN0X2VudHJ5KQoJCW9sZHRyZWUgPSBOVUxMOwoJaWYgKG5ld3RyZWUgPT0gby0+ZGZfY29uZmxpY3RfZW50cnkpCgkJbmV3dHJlZSA9IE5VTEw7CgoJaWYgKGN1cnJlbnQpIHsKCQlpZiAoKCFvbGR0cmVlICYmICFuZXd0cmVlKSB8fCAvKiA0IGFuZCA1ICovCgkJICAgICghb2xkdHJlZSAmJiBuZXd0cmVlICYmCgkJICAgICBzYW1lKGN1cnJlbnQsIG5ld3RyZWUpKSB8fCAvKiA2IGFuZCA3ICovCgkJICAgIChvbGR0cmVlICYmIG5ld3RyZWUgJiYKCQkgICAgIHNhbWUob2xkdHJlZSwgbmV3dHJlZSkpIHx8IC8qIDE0IGFuZCAxNSAqLwoJCSAgICAob2xkdHJlZSAmJiBuZXd0cmVlICYmCgkJICAgICAhc2FtZShvbGR0cmVlLCBuZXd0cmVlKSAmJiAvKiAxOCBhbmQgMTkgKi8KCQkgICAgIHNhbWUoY3VycmVudCwgbmV3dHJlZSkpKSB7CgkJCXJldHVybiBrZWVwX2VudHJ5KGN1cnJlbnQsIG8pOwoJCX0KCQllbHNlIGlmIChvbGR0cmVlICYmICFuZXd0cmVlICYmIHNhbWUoY3VycmVudCwgb2xkdHJlZSkpIHsKCQkJLyogMTAgb3IgMTEgKi8KCQkJcmV0dXJuIGRlbGV0ZWRfZW50cnkob2xkdHJlZSwgY3VycmVudCwgbyk7CgkJfQoJCWVsc2UgaWYgKG9sZHRyZWUgJiYgbmV3dHJlZSAmJgoJCQkgc2FtZShjdXJyZW50LCBvbGR0cmVlKSAmJiAhc2FtZShjdXJyZW50LCBuZXd0cmVlKSkgewoJCQkvKiAyMCBvciAyMSAqLwoJCQlyZXR1cm4gbWVyZ2VkX2VudHJ5KG5ld3RyZWUsIGN1cnJlbnQsIG8pOwoJCX0KCQllbHNlIHsKCQkJLyogYWxsIG90aGVyIGZhaWx1cmVzICovCgkJCWlmIChvbGR0cmVlKQoJCQkJcmV0dXJuIG8tPmdlbnRseSA/IC0xIDogcmVqZWN0X21lcmdlKG9sZHRyZWUsIG8pOwoJCQlpZiAoY3VycmVudCkKCQkJCXJldHVybiBvLT5nZW50bHkgPyAtMSA6IHJlamVjdF9tZXJnZShjdXJyZW50LCBvKTsKCQkJaWYgKG5ld3RyZWUpCgkJCQlyZXR1cm4gby0+Z2VudGx5ID8gLTEgOiByZWplY3RfbWVyZ2UobmV3dHJlZSwgbyk7CgkJCXJldHVybiAtMTsKCQl9Cgl9CgllbHNlIGlmIChuZXd0cmVlKSB7CgkJaWYgKG9sZHRyZWUgJiYgIW8tPmluaXRpYWxfY2hlY2tvdXQpIHsKCQkJLyoKCQkJICogZGVsZXRpb24gb2YgdGhlIHBhdGggd2FzIHN0YWdlZDsKCQkJICovCgkJCWlmIChzYW1lKG9sZHRyZWUsIG5ld3RyZWUpKQoJCQkJcmV0dXJuIDE7CgkJCXJldHVybiByZWplY3RfbWVyZ2Uob2xkdHJlZSwgbyk7CgkJfQoJCXJldHVybiBtZXJnZWRfZW50cnkobmV3dHJlZSwgY3VycmVudCwgbyk7Cgl9CglyZXR1cm4gZGVsZXRlZF9lbnRyeShvbGR0cmVlLCBjdXJyZW50LCBvKTsKfQoKLyoKICogQmluZCBtZXJnZS4KICoKICogS2VlcCB0aGUgaW5kZXggZW50cmllcyBhdCBzdGFnZTAsIGNvbGxhcHNlIHN0YWdlMSBidXQgbWFrZSBzdXJlCiAqIHN0YWdlMCBkb2VzIG5vdCBoYXZlIGFueXRoaW5nIHRoZXJlLgogKi8KaW50IGJpbmRfbWVyZ2Uoc3RydWN0IGNhY2hlX2VudHJ5ICoqc3JjLAoJCXN0cnVjdCB1bnBhY2tfdHJlZXNfb3B0aW9ucyAqbykKewoJc3RydWN0IGNhY2hlX2VudHJ5ICpvbGQgPSBzcmNbMF07CglzdHJ1Y3QgY2FjaGVfZW50cnkgKmEgPSBzcmNbMV07CgoJaWYgKG8tPm1lcmdlX3NpemUgIT0gMSkKCQlyZXR1cm4gZXJyb3IoIkNhbm5vdCBkbyBhIGJpbmQgbWVyZ2Ugb2YgJWQgdHJlZXMiLAoJCQkgICAgIG8tPm1lcmdlX3NpemUpOwoJaWYgKGEgJiYgb2xkKQoJCXJldHVybiBvLT5nZW50bHkgPyAtMSA6CgkJCWVycm9yKEVSUk9STVNHKG8sIEVSUk9SX0JJTkRfT1ZFUkxBUCksIGEtPm5hbWUsIG9sZC0+bmFtZSk7CglpZiAoIWEpCgkJcmV0dXJuIGtlZXBfZW50cnkob2xkLCBvKTsKCWVsc2UKCQlyZXR1cm4gbWVyZ2VkX2VudHJ5KGEsIE5VTEwsIG8pOwp9CgovKgogKiBPbmUtd2F5IG1lcmdlLgogKgogKiBUaGUgcnVsZSBpczoKICogLSB0YWtlIHRoZSBzdGF0IGluZm9ybWF0aW9uIGZyb20gc3RhZ2UwLCB0YWtlIHRoZSBkYXRhIGZyb20gc3RhZ2UxCiAqLwppbnQgb25ld2F5X21lcmdlKHN0cnVjdCBjYWNoZV9lbnRyeSAqKnNyYywgc3RydWN0IHVucGFja190cmVlc19vcHRpb25zICpvKQp7CglzdHJ1Y3QgY2FjaGVfZW50cnkgKm9sZCA9IHNyY1swXTsKCXN0cnVjdCBjYWNoZV9lbnRyeSAqYSA9IHNyY1sxXTsKCglpZiAoby0+bWVyZ2Vfc2l6ZSAhPSAxKQoJCXJldHVybiBlcnJvcigiQ2Fubm90IGRvIGEgb25ld2F5IG1lcmdlIG9mICVkIHRyZWVzIiwKCQkJICAgICBvLT5tZXJnZV9zaXplKTsKCglpZiAoIWEgfHwgYSA9PSBvLT5kZl9jb25mbGljdF9lbnRyeSkKCQlyZXR1cm4gZGVsZXRlZF9lbnRyeShvbGQsIG9sZCwgbyk7CgoJaWYgKG9sZCAmJiBzYW1lKG9sZCwgYSkpIHsKCQlpbnQgdXBkYXRlID0gMDsKCQlpZiAoby0+cmVzZXQgJiYgIWNlX3VwdG9kYXRlKG9sZCkgJiYgIWNlX3NraXBfd29ya3RyZWUob2xkKSkgewoJCQlzdHJ1Y3Qgc3RhdCBzdDsKCQkJaWYgKGxzdGF0KG9sZC0+bmFtZSwgJnN0KSB8fAoJCQkgICAgaWVfbWF0Y2hfc3RhdChvLT5zcmNfaW5kZXgsIG9sZCwgJnN0LCBDRV9NQVRDSF9JR05PUkVfVkFMSUR8Q0VfTUFUQ0hfSUdOT1JFX1NLSVBfV09SS1RSRUUpKQoJCQkJdXBkYXRlIHw9IENFX1VQREFURTsKCQl9CgkJYWRkX2VudHJ5KG8sIG9sZCwgdXBkYXRlLCAwKTsKCQlyZXR1cm4gMDsKCX0KCXJldHVybiBtZXJnZWRfZW50cnkoYSwgb2xkLCBvKTsKfQo=",
    "text": "#define NO_THE_INDEX_COMPATIBILITY_MACROS\n#include \"cache.h\"\n#include \"dir.h\"\n#include \"tree.h\"\n#include \"tree-walk.h\"\n#include \"cache-tree.h\"\n#include \"unpack-trees.h\"\n#include \"progress.h\"\n#include \"refs.h\"\n#include \"attr.h\"\n\n/*\n * Error messages expected by scripts out of plumbing commands such as\n * read-tree.  Non-scripted Porcelain is not required to use these messages\n * and in fact are encouraged to reword them to better suit their particular\n * situation better.  See how \"git checkout\" and \"git merge\" replaces\n * them using setup_unpack_trees_porcelain(), for example.\n */\nstatic const char *unpack_plumbing_errors[NB_UNPACK_TREES_ERROR_TYPES] = {\n\t/* ERROR_WOULD_OVERWRITE */\n\t\"Entry '%s' would be overwritten by merge. Cannot merge.\",\n\n\t/* ERROR_NOT_UPTODATE_FILE */\n\t\"Entry '%s' not uptodate. Cannot merge.\",\n\n\t/* ERROR_NOT_UPTODATE_DIR */\n\t\"Updating '%s' would lose untracked files in it\",\n\n\t/* ERROR_WOULD_LOSE_UNTRACKED_OVERWRITTEN */\n\t\"Untracked working tree file '%s' would be overwritten by merge.\",\n\n\t/* ERROR_WOULD_LOSE_UNTRACKED_REMOVED */\n\t\"Untracked working tree file '%s' would be removed by merge.\",\n\n\t/* ERROR_BIND_OVERLAP */\n\t\"Entry '%s' overlaps with '%s'.  Cannot bind.\",\n\n\t/* ERROR_SPARSE_NOT_UPTODATE_FILE */\n\t\"Entry '%s' not uptodate. Cannot update sparse checkout.\",\n\n\t/* ERROR_WOULD_LOSE_ORPHANED_OVERWRITTEN */\n\t\"Working tree file '%s' would be overwritten by sparse checkout update.\",\n\n\t/* ERROR_WOULD_LOSE_ORPHANED_REMOVED */\n\t\"Working tree file '%s' would be removed by sparse checkout update.\",\n};\n\n#define ERRORMSG(o,type) \\\n\t( ((o) && (o)->msgs[(type)]) \\\n\t  ? ((o)->msgs[(type)])      \\\n\t  : (unpack_plumbing_errors[(type)]) )\n\nvoid setup_unpack_trees_porcelain(struct unpack_trees_options *opts,\n\t\t\t\t  const char *cmd)\n{\n\tint i;\n\tconst char **msgs = opts->msgs;\n\tconst char *msg;\n\tchar *tmp;\n\tconst char *cmd2 = strcmp(cmd, \"checkout\") ? cmd : \"switch branches\";\n\tif (advice_commit_before_merge)\n\t\tmsg = \"Your local changes to the following files would be overwritten by %s:\\n%%s\"\n\t\t\t\"Please, commit your changes or stash them before you can %s.\";\n\telse\n\t\tmsg = \"Your local changes to the following files would be overwritten by %s:\\n%%s\";\n\ttmp = xmalloc(strlen(msg) + strlen(cmd) + strlen(cmd2) - 2);\n\tsprintf(tmp, msg, cmd, cmd2);\n\tmsgs[ERROR_WOULD_OVERWRITE] = tmp;\n\tmsgs[ERROR_NOT_UPTODATE_FILE] = tmp;\n\n\tmsgs[ERROR_NOT_UPTODATE_DIR] =\n\t\t\"Updating the following directories would lose untracked files in it:\\n%s\";\n\n\tif (advice_commit_before_merge)\n\t\tmsg = \"The following untracked working tree files would be %s by %s:\\n%%s\"\n\t\t\t\"Please move or remove them before you can %s.\";\n\telse\n\t\tmsg = \"The following untracked working tree files would be %s by %s:\\n%%s\";\n\ttmp = xmalloc(strlen(msg) + strlen(cmd) + strlen(\"removed\") + strlen(cmd2) - 4);\n\tsprintf(tmp, msg, \"removed\", cmd, cmd2);\n\tmsgs[ERROR_WOULD_LOSE_UNTRACKED_REMOVED] = tmp;\n\ttmp = xmalloc(strlen(msg) + strlen(cmd) + strlen(\"overwritten\") + strlen(cmd2) - 4);\n\tsprintf(tmp, msg, \"overwritten\", cmd, cmd2);\n\tmsgs[ERROR_WOULD_LOSE_UNTRACKED_OVERWRITTEN] = tmp;\n\n\t/*\n\t * Special case: ERROR_BIND_OVERLAP refers to a pair of paths, we\n\t * cannot easily display it as a list.\n\t */\n\tmsgs[ERROR_BIND_OVERLAP] = \"Entry '%s' overlaps with '%s'.  Cannot bind.\";\n\n\tmsgs[ERROR_SPARSE_NOT_UPTODATE_FILE] =\n\t\t\"Cannot update sparse checkout: the following entries are not up-to-date:\\n%s\";\n\tmsgs[ERROR_WOULD_LOSE_ORPHANED_OVERWRITTEN] =\n\t\t\"The following Working tree files would be overwritten by sparse checkout update:\\n%s\";\n\tmsgs[ERROR_WOULD_LOSE_ORPHANED_REMOVED] =\n\t\t\"The following Working tree files would be removed by sparse checkout update:\\n%s\";\n\n\topts->show_all_errors = 1;\n\t/* rejected paths may not have a static buffer */\n\tfor (i = 0; i < ARRAY_SIZE(opts->unpack_rejects); i++)\n\t\topts->unpack_rejects[i].strdup_strings = 1;\n}\n\nstatic void do_add_entry(struct unpack_trees_options *o, struct cache_entry *ce,\n\t\t\t unsigned int set, unsigned int clear)\n{\n\tclear |= CE_HASHED | CE_UNHASHED;\n\n\tif (set & CE_REMOVE)\n\t\tset |= CE_WT_REMOVE;\n\n\tce->next = NULL;\n\tce->ce_flags = (ce->ce_flags & ~clear) | set;\n\tadd_index_entry(&o->result, ce,\n\t\t\tADD_CACHE_OK_TO_ADD | ADD_CACHE_OK_TO_REPLACE);\n}\n\nstatic void add_entry(struct unpack_trees_options *o, struct cache_entry *ce,\n\tunsigned int set, unsigned int clear)\n{\n\tunsigned int size = ce_size(ce);\n\tstruct cache_entry *new = xmalloc(size);\n\n\tmemcpy(new, ce, size);\n\tdo_add_entry(o, new, set, clear);\n}\n\n/*\n * add error messages on path <path>\n * corresponding to the type <e> with the message <msg>\n * indicating if it should be display in porcelain or not\n */\nstatic int add_rejected_path(struct unpack_trees_options *o,\n\t\t\t     enum unpack_trees_error_types e,\n\t\t\t     const char *path)\n{\n\tif (!o->show_all_errors)\n\t\treturn error(ERRORMSG(o, e), path);\n\n\t/*\n\t * Otherwise, insert in a list for future display by\n\t * display_error_msgs()\n\t */\n\tstring_list_append(&o->unpack_rejects[e], path);\n\treturn -1;\n}\n\n/*\n * display all the error messages stored in a nice way\n */\nstatic void display_error_msgs(struct unpack_trees_options *o)\n{\n\tint e, i;\n\tint something_displayed = 0;\n\tfor (e = 0; e < NB_UNPACK_TREES_ERROR_TYPES; e++) {\n\t\tstruct string_list *rejects = &o->unpack_rejects[e];\n\t\tif (rejects->nr > 0) {\n\t\t\tstruct strbuf path = STRBUF_INIT;\n\t\t\tsomething_displayed = 1;\n\t\t\tfor (i = 0; i < rejects->nr; i++)\n\t\t\t\tstrbuf_addf(&path, \"\\t%s\\n\", rejects->items[i].string);\n\t\t\terror(ERRORMSG(o, e), path.buf);\n\t\t\tstrbuf_release(&path);\n\t\t}\n\t\tstring_list_clear(rejects, 0);\n\t}\n\tif (something_displayed)\n\t\tfprintf(stderr, \"Aborting\\n\");\n}\n\n/*\n * Unlink the last component and schedule the leading directories for\n * removal, such that empty directories get removed.\n */\nstatic void unlink_entry(struct cache_entry *ce)\n{\n\tif (!check_leading_path(ce->name, ce_namelen(ce)))\n\t\treturn;\n\tif (remove_or_warn(ce->ce_mode, ce->name))\n\t\treturn;\n\tschedule_dir_for_removal(ce->name, ce_namelen(ce));\n}\n\nstatic struct checkout state;\nstatic int check_updates(struct unpack_trees_options *o)\n{\n\tunsigned cnt = 0, total = 0;\n\tstruct progress *progress = NULL;\n\tstruct index_state *index = &o->result;\n\tint i;\n\tint errs = 0;\n\n\tif (o->update && o->verbose_update) {\n\t\tfor (total = cnt = 0; cnt < index->cache_nr; cnt++) {\n\t\t\tstruct cache_entry *ce = index->cache[cnt];\n\t\t\tif (ce->ce_flags & (CE_UPDATE | CE_WT_REMOVE))\n\t\t\t\ttotal++;\n\t\t}\n\n\t\tprogress = start_progress_delay(\"Checking out files\",\n\t\t\t\t\t\ttotal, 50, 1);\n\t\tcnt = 0;\n\t}\n\n\tif (o->update)\n\t\tgit_attr_set_direction(GIT_ATTR_CHECKOUT, &o->result);\n\tfor (i = 0; i < index->cache_nr; i++) {\n\t\tstruct cache_entry *ce = index->cache[i];\n\n\t\tif (ce->ce_flags & CE_WT_REMOVE) {\n\t\t\tdisplay_progress(progress, ++cnt);\n\t\t\tif (o->update && !o->dry_run)\n\t\t\t\tunlink_entry(ce);\n\t\t\tcontinue;\n\t\t}\n\t}\n\tremove_marked_cache_entries(&o->result);\n\tremove_scheduled_dirs();\n\n\tfor (i = 0; i < index->cache_nr; i++) {\n\t\tstruct cache_entry *ce = index->cache[i];\n\n\t\tif (ce->ce_flags & CE_UPDATE) {\n\t\t\tdisplay_progress(progress, ++cnt);\n\t\t\tce->ce_flags &= ~CE_UPDATE;\n\t\t\tif (o->update && !o->dry_run) {\n\t\t\t\terrs |= checkout_entry(ce, &state, NULL);\n\t\t\t}\n\t\t}\n\t}\n\tstop_progress(&progress);\n\tif (o->update)\n\t\tgit_attr_set_direction(GIT_ATTR_CHECKIN, NULL);\n\treturn errs != 0;\n}\n\nstatic int verify_uptodate_sparse(struct cache_entry *ce, struct unpack_trees_options *o);\nstatic int verify_absent_sparse(struct cache_entry *ce, enum unpack_trees_error_types, struct unpack_trees_options *o);\n\nstatic int apply_sparse_checkout(struct cache_entry *ce, struct unpack_trees_options *o)\n{\n\tint was_skip_worktree = ce_skip_worktree(ce);\n\n\tif (ce->ce_flags & CE_NEW_SKIP_WORKTREE)\n\t\tce->ce_flags |= CE_SKIP_WORKTREE;\n\telse\n\t\tce->ce_flags &= ~CE_SKIP_WORKTREE;\n\n\t/*\n\t * if (!was_skip_worktree && !ce_skip_worktree()) {\n\t *\tThis is perfectly normal. Move on;\n\t * }\n\t */\n\n\t/*\n\t * Merge strategies may set CE_UPDATE|CE_REMOVE outside checkout\n\t * area as a result of ce_skip_worktree() shortcuts in\n\t * verify_absent() and verify_uptodate().\n\t * Make sure they don't modify worktree if they are already\n\t * outside checkout area\n\t */\n\tif (was_skip_worktree && ce_skip_worktree(ce)) {\n\t\tce->ce_flags &= ~CE_UPDATE;\n\n\t\t/*\n\t\t * By default, when CE_REMOVE is on, CE_WT_REMOVE is also\n\t\t * on to get that file removed from both index and worktree.\n\t\t * If that file is already outside worktree area, don't\n\t\t * bother remove it.\n\t\t */\n\t\tif (ce->ce_flags & CE_REMOVE)\n\t\t\tce->ce_flags &= ~CE_WT_REMOVE;\n\t}\n\n\tif (!was_skip_worktree && ce_skip_worktree(ce)) {\n\t\t/*\n\t\t * If CE_UPDATE is set, verify_uptodate() must be called already\n\t\t * also stat info may have lost after merged_entry() so calling\n\t\t * verify_uptodate() again may fail\n\t\t */\n\t\tif (!(ce->ce_flags & CE_UPDATE) && verify_uptodate_sparse(ce, o))\n\t\t\treturn -1;\n\t\tce->ce_flags |= CE_WT_REMOVE;\n\t}\n\tif (was_skip_worktree && !ce_skip_worktree(ce)) {\n\t\tif (verify_absent_sparse(ce, ERROR_WOULD_LOSE_UNTRACKED_OVERWRITTEN, o))\n\t\t\treturn -1;\n\t\tce->ce_flags |= CE_UPDATE;\n\t}\n\treturn 0;\n}\n\nstatic inline int call_unpack_fn(struct cache_entry **src, struct unpack_trees_options *o)\n{\n\tint ret = o->fn(src, o);\n\tif (ret > 0)\n\t\tret = 0;\n\treturn ret;\n}\n\nstatic void mark_ce_used(struct cache_entry *ce, struct unpack_trees_options *o)\n{\n\tce->ce_flags |= CE_UNPACKED;\n\n\tif (o->cache_bottom < o->src_index->cache_nr &&\n\t    o->src_index->cache[o->cache_bottom] == ce) {\n\t\tint bottom = o->cache_bottom;\n\t\twhile (bottom < o->src_index->cache_nr &&\n\t\t       o->src_index->cache[bottom]->ce_flags & CE_UNPACKED)\n\t\t\tbottom++;\n\t\to->cache_bottom = bottom;\n\t}\n}\n\nstatic void mark_all_ce_unused(struct index_state *index)\n{\n\tint i;\n\tfor (i = 0; i < index->cache_nr; i++)\n\t\tindex->cache[i]->ce_flags &= ~(CE_UNPACKED | CE_ADDED | CE_NEW_SKIP_WORKTREE);\n}\n\nstatic int locate_in_src_index(struct cache_entry *ce,\n\t\t\t       struct unpack_trees_options *o)\n{\n\tstruct index_state *index = o->src_index;\n\tint len = ce_namelen(ce);\n\tint pos = index_name_pos(index, ce->name, len);\n\tif (pos < 0)\n\t\tpos = -1 - pos;\n\treturn pos;\n}\n\n/*\n * We call unpack_index_entry() with an unmerged cache entry\n * only in diff-index, and it wants a single callback.  Skip\n * the other unmerged entry with the same name.\n */\nstatic void mark_ce_used_same_name(struct cache_entry *ce,\n\t\t\t\t   struct unpack_trees_options *o)\n{\n\tstruct index_state *index = o->src_index;\n\tint len = ce_namelen(ce);\n\tint pos;\n\n\tfor (pos = locate_in_src_index(ce, o); pos < index->cache_nr; pos++) {\n\t\tstruct cache_entry *next = index->cache[pos];\n\t\tif (len != ce_namelen(next) ||\n\t\t    memcmp(ce->name, next->name, len))\n\t\t\tbreak;\n\t\tmark_ce_used(next, o);\n\t}\n}\n\nstatic struct cache_entry *next_cache_entry(struct unpack_trees_options *o)\n{\n\tconst struct index_state *index = o->src_index;\n\tint pos = o->cache_bottom;\n\n\twhile (pos < index->cache_nr) {\n\t\tstruct cache_entry *ce = index->cache[pos];\n\t\tif (!(ce->ce_flags & CE_UNPACKED))\n\t\t\treturn ce;\n\t\tpos++;\n\t}\n\treturn NULL;\n}\n\nstatic void add_same_unmerged(struct cache_entry *ce,\n\t\t\t      struct unpack_trees_options *o)\n{\n\tstruct index_state *index = o->src_index;\n\tint len = ce_namelen(ce);\n\tint pos = index_name_pos(index, ce->name, len);\n\n\tif (0 <= pos)\n\t\tdie(\"programming error in a caller of mark_ce_used_same_name\");\n\tfor (pos = -pos - 1; pos < index->cache_nr; pos++) {\n\t\tstruct cache_entry *next = index->cache[pos];\n\t\tif (len != ce_namelen(next) ||\n\t\t    memcmp(ce->name, next->name, len))\n\t\t\tbreak;\n\t\tadd_entry(o, next, 0, 0);\n\t\tmark_ce_used(next, o);\n\t}\n}\n\nstatic int unpack_index_entry(struct cache_entry *ce,\n\t\t\t      struct unpack_trees_options *o)\n{\n\tstruct cache_entry *src[MAX_UNPACK_TREES + 1] = { NULL, };\n\tint ret;\n\n\tsrc[0] = ce;\n\n\tmark_ce_used(ce, o);\n\tif (ce_stage(ce)) {\n\t\tif (o->skip_unmerged) {\n\t\t\tadd_entry(o, ce, 0, 0);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tret = call_unpack_fn(src, o);\n\tif (ce_stage(ce))\n\t\tmark_ce_used_same_name(ce, o);\n\treturn ret;\n}\n\nstatic int find_cache_pos(struct traverse_info *, const struct name_entry *);\n\nstatic void restore_cache_bottom(struct traverse_info *info, int bottom)\n{\n\tstruct unpack_trees_options *o = info->data;\n\n\tif (o->diff_index_cached)\n\t\treturn;\n\to->cache_bottom = bottom;\n}\n\nstatic int switch_cache_bottom(struct traverse_info *info)\n{\n\tstruct unpack_trees_options *o = info->data;\n\tint ret, pos;\n\n\tif (o->diff_index_cached)\n\t\treturn 0;\n\tret = o->cache_bottom;\n\tpos = find_cache_pos(info->prev, &info->name);\n\n\tif (pos < -1)\n\t\to->cache_bottom = -2 - pos;\n\telse if (pos < 0)\n\t\to->cache_bottom = o->src_index->cache_nr;\n\treturn ret;\n}\n\nstatic int traverse_trees_recursive(int n, unsigned long dirmask,\n\t\t\t\t    unsigned long df_conflicts,\n\t\t\t\t    struct name_entry *names,\n\t\t\t\t    struct traverse_info *info)\n{\n\tint i, ret, bottom;\n\tstruct tree_desc t[MAX_UNPACK_TREES];\n\tvoid *buf[MAX_UNPACK_TREES];\n\tstruct traverse_info newinfo;\n\tstruct name_entry *p;\n\n\tp = names;\n\twhile (!p->mode)\n\t\tp++;\n\n\tnewinfo = *info;\n\tnewinfo.prev = info;\n\tnewinfo.pathspec = info->pathspec;\n\tnewinfo.name = *p;\n\tnewinfo.pathlen += tree_entry_len(p) + 1;\n\tnewinfo.conflicts |= df_conflicts;\n\n\tfor (i = 0; i < n; i++, dirmask >>= 1) {\n\t\tconst unsigned char *sha1 = NULL;\n\t\tif (dirmask & 1)\n\t\t\tsha1 = names[i].sha1;\n\t\tbuf[i] = fill_tree_descriptor(t+i, sha1);\n\t}\n\n\tbottom = switch_cache_bottom(&newinfo);\n\tret = traverse_trees(n, t, &newinfo);\n\trestore_cache_bottom(&newinfo, bottom);\n\n\tfor (i = 0; i < n; i++)\n\t\tfree(buf[i]);\n\n\treturn ret;\n}\n\n/*\n * Compare the traverse-path to the cache entry without actually\n * having to generate the textual representation of the traverse\n * path.\n *\n * NOTE! This *only* compares up to the size of the traverse path\n * itself - the caller needs to do the final check for the cache\n * entry having more data at the end!\n */\nstatic int do_compare_entry(const struct cache_entry *ce, const struct traverse_info *info, const struct name_entry *n)\n{\n\tint len, pathlen, ce_len;\n\tconst char *ce_name;\n\n\tif (info->prev) {\n\t\tint cmp = do_compare_entry(ce, info->prev, &info->name);\n\t\tif (cmp)\n\t\t\treturn cmp;\n\t}\n\tpathlen = info->pathlen;\n\tce_len = ce_namelen(ce);\n\n\t/* If ce_len < pathlen then we must have previously hit \"name == directory\" entry */\n\tif (ce_len < pathlen)\n\t\treturn -1;\n\n\tce_len -= pathlen;\n\tce_name = ce->name + pathlen;\n\n\tlen = tree_entry_len(n);\n\treturn df_name_compare(ce_name, ce_len, S_IFREG, n->path, len, n->mode);\n}\n\nstatic int compare_entry(const struct cache_entry *ce, const struct traverse_info *info, const struct name_entry *n)\n{\n\tint cmp = do_compare_entry(ce, info, n);\n\tif (cmp)\n\t\treturn cmp;\n\n\t/*\n\t * Even if the beginning compared identically, the ce should\n\t * compare as bigger than a directory leading up to it!\n\t */\n\treturn ce_namelen(ce) > traverse_path_len(info, n);\n}\n\nstatic int ce_in_traverse_path(const struct cache_entry *ce,\n\t\t\t       const struct traverse_info *info)\n{\n\tif (!info->prev)\n\t\treturn 1;\n\tif (do_compare_entry(ce, info->prev, &info->name))\n\t\treturn 0;\n\t/*\n\t * If ce (blob) is the same name as the path (which is a tree\n\t * we will be descending into), it won't be inside it.\n\t */\n\treturn (info->pathlen < ce_namelen(ce));\n}\n\nstatic struct cache_entry *create_ce_entry(const struct traverse_info *info, const struct name_entry *n, int stage)\n{\n\tint len = traverse_path_len(info, n);\n\tstruct cache_entry *ce = xcalloc(1, cache_entry_size(len));\n\n\tce->ce_mode = create_ce_mode(n->mode);\n\tce->ce_flags = create_ce_flags(stage);\n\tce->ce_namelen = len;\n\thashcpy(ce->sha1, n->sha1);\n\tmake_traverse_path(ce->name, info, n);\n\n\treturn ce;\n}\n\nstatic int unpack_nondirectories(int n, unsigned long mask,\n\t\t\t\t unsigned long dirmask,\n\t\t\t\t struct cache_entry **src,\n\t\t\t\t const struct name_entry *names,\n\t\t\t\t const struct traverse_info *info)\n{\n\tint i;\n\tstruct unpack_trees_options *o = info->data;\n\tunsigned long conflicts;\n\n\t/* Do we have *only* directories? Nothing to do */\n\tif (mask == dirmask && !src[0])\n\t\treturn 0;\n\n\tconflicts = info->conflicts;\n\tif (o->merge)\n\t\tconflicts >>= 1;\n\tconflicts |= dirmask;\n\n\t/*\n\t * Ok, we've filled in up to any potential index entry in src[0],\n\t * now do the rest.\n\t */\n\tfor (i = 0; i < n; i++) {\n\t\tint stage;\n\t\tunsigned int bit = 1ul << i;\n\t\tif (conflicts & bit) {\n\t\t\tsrc[i + o->merge] = o->df_conflict_entry;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!(mask & bit))\n\t\t\tcontinue;\n\t\tif (!o->merge)\n\t\t\tstage = 0;\n\t\telse if (i + 1 < o->head_idx)\n\t\t\tstage = 1;\n\t\telse if (i + 1 > o->head_idx)\n\t\t\tstage = 3;\n\t\telse\n\t\t\tstage = 2;\n\t\tsrc[i + o->merge] = create_ce_entry(info, names + i, stage);\n\t}\n\n\tif (o->merge)\n\t\treturn call_unpack_fn(src, o);\n\n\tfor (i = 0; i < n; i++)\n\t\tif (src[i] && src[i] != o->df_conflict_entry)\n\t\t\tdo_add_entry(o, src[i], 0, 0);\n\treturn 0;\n}\n\nstatic int unpack_failed(struct unpack_trees_options *o, const char *message)\n{\n\tdiscard_index(&o->result);\n\tif (!o->gently && !o->exiting_early) {\n\t\tif (message)\n\t\t\treturn error(\"%s\", message);\n\t\treturn -1;\n\t}\n\treturn -1;\n}\n\n/* NEEDSWORK: give this a better name and share with tree-walk.c */\nstatic int name_compare(const char *a, int a_len,\n\t\t\tconst char *b, int b_len)\n{\n\tint len = (a_len < b_len) ? a_len : b_len;\n\tint cmp = memcmp(a, b, len);\n\tif (cmp)\n\t\treturn cmp;\n\treturn (a_len - b_len);\n}\n\n/*\n * The tree traversal is looking at name p.  If we have a matching entry,\n * return it.  If name p is a directory in the index, do not return\n * anything, as we will want to match it when the traversal descends into\n * the directory.\n */\nstatic int find_cache_pos(struct traverse_info *info,\n\t\t\t  const struct name_entry *p)\n{\n\tint pos;\n\tstruct unpack_trees_options *o = info->data;\n\tstruct index_state *index = o->src_index;\n\tint pfxlen = info->pathlen;\n\tint p_len = tree_entry_len(p);\n\n\tfor (pos = o->cache_bottom; pos < index->cache_nr; pos++) {\n\t\tstruct cache_entry *ce = index->cache[pos];\n\t\tconst char *ce_name, *ce_slash;\n\t\tint cmp, ce_len;\n\n\t\tif (ce->ce_flags & CE_UNPACKED) {\n\t\t\t/*\n\t\t\t * cache_bottom entry is already unpacked, so\n\t\t\t * we can never match it; don't check it\n\t\t\t * again.\n\t\t\t */\n\t\t\tif (pos == o->cache_bottom)\n\t\t\t\t++o->cache_bottom;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!ce_in_traverse_path(ce, info))\n\t\t\tcontinue;\n\t\tce_name = ce->name + pfxlen;\n\t\tce_slash = strchr(ce_name, '/');\n\t\tif (ce_slash)\n\t\t\tce_len = ce_slash - ce_name;\n\t\telse\n\t\t\tce_len = ce_namelen(ce) - pfxlen;\n\t\tcmp = name_compare(p->path, p_len, ce_name, ce_len);\n\t\t/*\n\t\t * Exact match; if we have a directory we need to\n\t\t * delay returning it.\n\t\t */\n\t\tif (!cmp)\n\t\t\treturn ce_slash ? -2 - pos : pos;\n\t\tif (0 < cmp)\n\t\t\tcontinue; /* keep looking */\n\t\t/*\n\t\t * ce_name sorts after p->path; could it be that we\n\t\t * have files under p->path directory in the index?\n\t\t * E.g.  ce_name == \"t-i\", and p->path == \"t\"; we may\n\t\t * have \"t/a\" in the index.\n\t\t */\n\t\tif (p_len < ce_len && !memcmp(ce_name, p->path, p_len) &&\n\t\t    ce_name[p_len] < '/')\n\t\t\tcontinue; /* keep looking */\n\t\tbreak;\n\t}\n\treturn -1;\n}\n\nstatic struct cache_entry *find_cache_entry(struct traverse_info *info,\n\t\t\t\t\t    const struct name_entry *p)\n{\n\tint pos = find_cache_pos(info, p);\n\tstruct unpack_trees_options *o = info->data;\n\n\tif (0 <= pos)\n\t\treturn o->src_index->cache[pos];\n\telse\n\t\treturn NULL;\n}\n\nstatic void debug_path(struct traverse_info *info)\n{\n\tif (info->prev) {\n\t\tdebug_path(info->prev);\n\t\tif (*info->prev->name.path)\n\t\t\tputchar('/');\n\t}\n\tprintf(\"%s\", info->name.path);\n}\n\nstatic void debug_name_entry(int i, struct name_entry *n)\n{\n\tprintf(\"ent#%d %06o %s\\n\", i,\n\t       n->path ? n->mode : 0,\n\t       n->path ? n->path : \"(missing)\");\n}\n\nstatic void debug_unpack_callback(int n,\n\t\t\t\t  unsigned long mask,\n\t\t\t\t  unsigned long dirmask,\n\t\t\t\t  struct name_entry *names,\n\t\t\t\t  struct traverse_info *info)\n{\n\tint i;\n\tprintf(\"* unpack mask %lu, dirmask %lu, cnt %d \",\n\t       mask, dirmask, n);\n\tdebug_path(info);\n\tputchar('\\n');\n\tfor (i = 0; i < n; i++)\n\t\tdebug_name_entry(i, names + i);\n}\n\nstatic int unpack_callback(int n, unsigned long mask, unsigned long dirmask, struct name_entry *names, struct traverse_info *info)\n{\n\tstruct cache_entry *src[MAX_UNPACK_TREES + 1] = { NULL, };\n\tstruct unpack_trees_options *o = info->data;\n\tconst struct name_entry *p = names;\n\n\t/* Find first entry with a real name (we could use \"mask\" too) */\n\twhile (!p->mode)\n\t\tp++;\n\n\tif (o->debug_unpack)\n\t\tdebug_unpack_callback(n, mask, dirmask, names, info);\n\n\t/* Are we supposed to look at the index too? */\n\tif (o->merge) {\n\t\twhile (1) {\n\t\t\tint cmp;\n\t\t\tstruct cache_entry *ce;\n\n\t\t\tif (o->diff_index_cached)\n\t\t\t\tce = next_cache_entry(o);\n\t\t\telse\n\t\t\t\tce = find_cache_entry(info, p);\n\n\t\t\tif (!ce)\n\t\t\t\tbreak;\n\t\t\tcmp = compare_entry(ce, info, p);\n\t\t\tif (cmp < 0) {\n\t\t\t\tif (unpack_index_entry(ce, o) < 0)\n\t\t\t\t\treturn unpack_failed(o, NULL);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!cmp) {\n\t\t\t\tif (ce_stage(ce)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * If we skip unmerged index\n\t\t\t\t\t * entries, we'll skip this\n\t\t\t\t\t * entry *and* the tree\n\t\t\t\t\t * entries associated with it!\n\t\t\t\t\t */\n\t\t\t\t\tif (o->skip_unmerged) {\n\t\t\t\t\t\tadd_same_unmerged(ce, o);\n\t\t\t\t\t\treturn mask;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsrc[0] = ce;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (unpack_nondirectories(n, mask, dirmask, src, names, info) < 0)\n\t\treturn -1;\n\n\tif (o->merge && src[0]) {\n\t\tif (ce_stage(src[0]))\n\t\t\tmark_ce_used_same_name(src[0], o);\n\t\telse\n\t\t\tmark_ce_used(src[0], o);\n\t}\n\n\t/* Now handle any directories.. */\n\tif (dirmask) {\n\t\tunsigned long conflicts = mask & ~dirmask;\n\t\tif (o->merge) {\n\t\t\tconflicts <<= 1;\n\t\t\tif (src[0])\n\t\t\t\tconflicts |= 1;\n\t\t}\n\n\t\t/* special case: \"diff-index --cached\" looking at a tree */\n\t\tif (o->diff_index_cached &&\n\t\t    n == 1 && dirmask == 1 && S_ISDIR(names->mode)) {\n\t\t\tint matches;\n\t\t\tmatches = cache_tree_matches_traversal(o->src_index->cache_tree,\n\t\t\t\t\t\t\t       names, info);\n\t\t\t/*\n\t\t\t * Everything under the name matches; skip the\n\t\t\t * entire hierarchy.  diff_index_cached codepath\n\t\t\t * special cases D/F conflicts in such a way that\n\t\t\t * it does not do any look-ahead, so this is safe.\n\t\t\t */\n\t\t\tif (matches) {\n\t\t\t\to->cache_bottom += matches;\n\t\t\t\treturn mask;\n\t\t\t}\n\t\t}\n\n\t\tif (traverse_trees_recursive(n, dirmask, conflicts,\n\t\t\t\t\t     names, info) < 0)\n\t\t\treturn -1;\n\t\treturn mask;\n\t}\n\n\treturn mask;\n}\n\nstatic int clear_ce_flags_1(struct cache_entry **cache, int nr,\n\t\t\t    char *prefix, int prefix_len,\n\t\t\t    int select_mask, int clear_mask,\n\t\t\t    struct exclude_list *el, int defval);\n\n/* Whole directory matching */\nstatic int clear_ce_flags_dir(struct cache_entry **cache, int nr,\n\t\t\t      char *prefix, int prefix_len,\n\t\t\t      char *basename,\n\t\t\t      int select_mask, int clear_mask,\n\t\t\t      struct exclude_list *el, int defval)\n{\n\tstruct cache_entry **cache_end;\n\tint dtype = DT_DIR;\n\tint ret = excluded_from_list(prefix, prefix_len, basename, &dtype, el);\n\n\tprefix[prefix_len++] = '/';\n\n\t/* If undecided, use matching result of parent dir in defval */\n\tif (ret < 0)\n\t\tret = defval;\n\n\tfor (cache_end = cache; cache_end != cache + nr; cache_end++) {\n\t\tstruct cache_entry *ce = *cache_end;\n\t\tif (strncmp(ce->name, prefix, prefix_len))\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * TODO: check el, if there are no patterns that may conflict\n\t * with ret (iow, we know in advance the incl/excl\n\t * decision for the entire directory), clear flag here without\n\t * calling clear_ce_flags_1(). That function will call\n\t * the expensive excluded_from_list() on every entry.\n\t */\n\treturn clear_ce_flags_1(cache, cache_end - cache,\n\t\t\t\tprefix, prefix_len,\n\t\t\t\tselect_mask, clear_mask,\n\t\t\t\tel, ret);\n}\n\n/*\n * Traverse the index, find every entry that matches according to\n * o->el. Do \"ce_flags &= ~clear_mask\" on those entries. Return the\n * number of traversed entries.\n *\n * If select_mask is non-zero, only entries whose ce_flags has on of\n * those bits enabled are traversed.\n *\n * cache\t: pointer to an index entry\n * prefix_len\t: an offset to its path\n *\n * The current path (\"prefix\") including the trailing '/' is\n *   cache[0]->name[0..(prefix_len-1)]\n * Top level path has prefix_len zero.\n */\nstatic int clear_ce_flags_1(struct cache_entry **cache, int nr,\n\t\t\t    char *prefix, int prefix_len,\n\t\t\t    int select_mask, int clear_mask,\n\t\t\t    struct exclude_list *el, int defval)\n{\n\tstruct cache_entry **cache_end = cache + nr;\n\n\t/*\n\t * Process all entries that have the given prefix and meet\n\t * select_mask condition\n\t */\n\twhile(cache != cache_end) {\n\t\tstruct cache_entry *ce = *cache;\n\t\tconst char *name, *slash;\n\t\tint len, dtype, ret;\n\n\t\tif (select_mask && !(ce->ce_flags & select_mask)) {\n\t\t\tcache++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (prefix_len && strncmp(ce->name, prefix, prefix_len))\n\t\t\tbreak;\n\n\t\tname = ce->name + prefix_len;\n\t\tslash = strchr(name, '/');\n\n\t\t/* If it's a directory, try whole directory match first */\n\t\tif (slash) {\n\t\t\tint processed;\n\n\t\t\tlen = slash - name;\n\t\t\tmemcpy(prefix + prefix_len, name, len);\n\n\t\t\t/*\n\t\t\t * terminate the string (no trailing slash),\n\t\t\t * clear_c_f_dir needs it\n\t\t\t */\n\t\t\tprefix[prefix_len + len] = '\\0';\n\t\t\tprocessed = clear_ce_flags_dir(cache, cache_end - cache,\n\t\t\t\t\t\t       prefix, prefix_len + len,\n\t\t\t\t\t\t       prefix + prefix_len,\n\t\t\t\t\t\t       select_mask, clear_mask,\n\t\t\t\t\t\t       el, defval);\n\n\t\t\t/* clear_c_f_dir eats a whole dir already? */\n\t\t\tif (processed) {\n\t\t\t\tcache += processed;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tprefix[prefix_len + len++] = '/';\n\t\t\tcache += clear_ce_flags_1(cache, cache_end - cache,\n\t\t\t\t\t\t  prefix, prefix_len + len,\n\t\t\t\t\t\t  select_mask, clear_mask, el, defval);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Non-directory */\n\t\tdtype = ce_to_dtype(ce);\n\t\tret = excluded_from_list(ce->name, ce_namelen(ce), name, &dtype, el);\n\t\tif (ret < 0)\n\t\t\tret = defval;\n\t\tif (ret > 0)\n\t\t\tce->ce_flags &= ~clear_mask;\n\t\tcache++;\n\t}\n\treturn nr - (cache_end - cache);\n}\n\nstatic int clear_ce_flags(struct cache_entry **cache, int nr,\n\t\t\t    int select_mask, int clear_mask,\n\t\t\t    struct exclude_list *el)\n{\n\tchar prefix[PATH_MAX];\n\treturn clear_ce_flags_1(cache, nr,\n\t\t\t\tprefix, 0,\n\t\t\t\tselect_mask, clear_mask,\n\t\t\t\tel, 0);\n}\n\n/*\n * Set/Clear CE_NEW_SKIP_WORKTREE according to $GIT_DIR/info/sparse-checkout\n */\nstatic void mark_new_skip_worktree(struct exclude_list *el,\n\t\t\t\t   struct index_state *the_index,\n\t\t\t\t   int select_flag, int skip_wt_flag)\n{\n\tint i;\n\n\t/*\n\t * 1. Pretend the narrowest worktree: only unmerged entries\n\t * are checked out\n\t */\n\tfor (i = 0; i < the_index->cache_nr; i++) {\n\t\tstruct cache_entry *ce = the_index->cache[i];\n\n\t\tif (select_flag && !(ce->ce_flags & select_flag))\n\t\t\tcontinue;\n\n\t\tif (!ce_stage(ce))\n\t\t\tce->ce_flags |= skip_wt_flag;\n\t\telse\n\t\t\tce->ce_flags &= ~skip_wt_flag;\n\t}\n\n\t/*\n\t * 2. Widen worktree according to sparse-checkout file.\n\t * Matched entries will have skip_wt_flag cleared (i.e. \"in\")\n\t */\n\tclear_ce_flags(the_index->cache, the_index->cache_nr,\n\t\t       select_flag, skip_wt_flag, el);\n}\n\nstatic int verify_absent(struct cache_entry *, enum unpack_trees_error_types, struct unpack_trees_options *);\n/*\n * N-way merge \"len\" trees.  Returns 0 on success, -1 on failure to manipulate the\n * resulting index, -2 on failure to reflect the changes to the work tree.\n *\n * CE_ADDED, CE_UNPACKED and CE_NEW_SKIP_WORKTREE are used internally\n */\nint unpack_trees(unsigned len, struct tree_desc *t, struct unpack_trees_options *o)\n{\n\tint i, ret;\n\tstatic struct cache_entry *dfc;\n\tstruct exclude_list el;\n\n\tif (len > MAX_UNPACK_TREES)\n\t\tdie(\"unpack_trees takes at most %d trees\", MAX_UNPACK_TREES);\n\tmemset(&state, 0, sizeof(state));\n\tstate.base_dir = \"\";\n\tstate.force = 1;\n\tstate.quiet = 1;\n\tstate.refresh_cache = 1;\n\n\tmemset(&el, 0, sizeof(el));\n\tif (!core_apply_sparse_checkout || !o->update)\n\t\to->skip_sparse_checkout = 1;\n\tif (!o->skip_sparse_checkout) {\n\t\tif (add_excludes_from_file_to_list(git_path(\"info/sparse-checkout\"), \"\", 0, NULL, &el, 0) < 0)\n\t\t\to->skip_sparse_checkout = 1;\n\t\telse\n\t\t\to->el = &el;\n\t}\n\n\tif (o->dir) {\n\t\to->path_exclude_check = xmalloc(sizeof(struct path_exclude_check));\n\t\tpath_exclude_check_init(o->path_exclude_check, o->dir);\n\t}\n\tmemset(&o->result, 0, sizeof(o->result));\n\to->result.initialized = 1;\n\to->result.timestamp.sec = o->src_index->timestamp.sec;\n\to->result.timestamp.nsec = o->src_index->timestamp.nsec;\n\to->result.version = o->src_index->version;\n\to->merge_size = len;\n\tmark_all_ce_unused(o->src_index);\n\n\t/*\n\t * Sparse checkout loop #1: set NEW_SKIP_WORKTREE on existing entries\n\t */\n\tif (!o->skip_sparse_checkout)\n\t\tmark_new_skip_worktree(o->el, o->src_index, 0, CE_NEW_SKIP_WORKTREE);\n\n\tif (!dfc)\n\t\tdfc = xcalloc(1, cache_entry_size(0));\n\to->df_conflict_entry = dfc;\n\n\tif (len) {\n\t\tconst char *prefix = o->prefix ? o->prefix : \"\";\n\t\tstruct traverse_info info;\n\n\t\tsetup_traverse_info(&info, prefix);\n\t\tinfo.fn = unpack_callback;\n\t\tinfo.data = o;\n\t\tinfo.show_all_errors = o->show_all_errors;\n\t\tinfo.pathspec = o->pathspec;\n\n\t\tif (o->prefix) {\n\t\t\t/*\n\t\t\t * Unpack existing index entries that sort before the\n\t\t\t * prefix the tree is spliced into.  Note that o->merge\n\t\t\t * is always true in this case.\n\t\t\t */\n\t\t\twhile (1) {\n\t\t\t\tstruct cache_entry *ce = next_cache_entry(o);\n\t\t\t\tif (!ce)\n\t\t\t\t\tbreak;\n\t\t\t\tif (ce_in_traverse_path(ce, &info))\n\t\t\t\t\tbreak;\n\t\t\t\tif (unpack_index_entry(ce, o) < 0)\n\t\t\t\t\tgoto return_failed;\n\t\t\t}\n\t\t}\n\n\t\tif (traverse_trees(len, t, &info) < 0)\n\t\t\tgoto return_failed;\n\t}\n\n\t/* Any left-over entries in the index? */\n\tif (o->merge) {\n\t\twhile (1) {\n\t\t\tstruct cache_entry *ce = next_cache_entry(o);\n\t\t\tif (!ce)\n\t\t\t\tbreak;\n\t\t\tif (unpack_index_entry(ce, o) < 0)\n\t\t\t\tgoto return_failed;\n\t\t}\n\t}\n\tmark_all_ce_unused(o->src_index);\n\n\tif (o->trivial_merges_only && o->nontrivial_merge) {\n\t\tret = unpack_failed(o, \"Merge requires file-level merging\");\n\t\tgoto done;\n\t}\n\n\tif (!o->skip_sparse_checkout) {\n\t\tint empty_worktree = 1;\n\n\t\t/*\n\t\t * Sparse checkout loop #2: set NEW_SKIP_WORKTREE on entries not in loop #1\n\t\t * If the will have NEW_SKIP_WORKTREE, also set CE_SKIP_WORKTREE\n\t\t * so apply_sparse_checkout() won't attempt to remove it from worktree\n\t\t */\n\t\tmark_new_skip_worktree(o->el, &o->result, CE_ADDED, CE_SKIP_WORKTREE | CE_NEW_SKIP_WORKTREE);\n\n\t\tret = 0;\n\t\tfor (i = 0; i < o->result.cache_nr; i++) {\n\t\t\tstruct cache_entry *ce = o->result.cache[i];\n\n\t\t\t/*\n\t\t\t * Entries marked with CE_ADDED in merged_entry() do not have\n\t\t\t * verify_absent() check (the check is effectively disabled\n\t\t\t * because CE_NEW_SKIP_WORKTREE is set unconditionally).\n\t\t\t *\n\t\t\t * Do the real check now because we have had\n\t\t\t * correct CE_NEW_SKIP_WORKTREE\n\t\t\t */\n\t\t\tif (ce->ce_flags & CE_ADDED &&\n\t\t\t    verify_absent(ce, ERROR_WOULD_LOSE_UNTRACKED_OVERWRITTEN, o)) {\n\t\t\t\tif (!o->show_all_errors)\n\t\t\t\t\tgoto return_failed;\n\t\t\t\tret = -1;\n\t\t\t}\n\n\t\t\tif (apply_sparse_checkout(ce, o)) {\n\t\t\t\tif (!o->show_all_errors)\n\t\t\t\t\tgoto return_failed;\n\t\t\t\tret = -1;\n\t\t\t}\n\t\t\tif (!ce_skip_worktree(ce))\n\t\t\t\tempty_worktree = 0;\n\n\t\t}\n\t\tif (ret < 0)\n\t\t\tgoto return_failed;\n\t\t/*\n\t\t * Sparse checkout is meant to narrow down checkout area\n\t\t * but it does not make sense to narrow down to empty working\n\t\t * tree. This is usually a mistake in sparse checkout rules.\n\t\t * Do not allow users to do that.\n\t\t */\n\t\tif (o->result.cache_nr && empty_worktree) {\n\t\t\tret = unpack_failed(o, \"Sparse checkout leaves no entry on working directory\");\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\to->src_index = NULL;\n\tret = check_updates(o) ? (-2) : 0;\n\tif (o->dst_index)\n\t\t*o->dst_index = o->result;\n\ndone:\n\tfree_excludes(&el);\n\tif (o->path_exclude_check) {\n\t\tpath_exclude_check_clear(o->path_exclude_check);\n\t\tfree(o->path_exclude_check);\n\t}\n\treturn ret;\n\nreturn_failed:\n\tif (o->show_all_errors)\n\t\tdisplay_error_msgs(o);\n\tmark_all_ce_unused(o->src_index);\n\tret = unpack_failed(o, NULL);\n\tif (o->exiting_early)\n\t\tret = 0;\n\tgoto done;\n}\n\n/* Here come the merge functions */\n\nstatic int reject_merge(struct cache_entry *ce, struct unpack_trees_options *o)\n{\n\treturn add_rejected_path(o, ERROR_WOULD_OVERWRITE, ce->name);\n}\n\nstatic int same(struct cache_entry *a, struct cache_entry *b)\n{\n\tif (!!a != !!b)\n\t\treturn 0;\n\tif (!a && !b)\n\t\treturn 1;\n\tif ((a->ce_flags | b->ce_flags) & CE_CONFLICTED)\n\t\treturn 0;\n\treturn a->ce_mode == b->ce_mode &&\n\t       !hashcmp(a->sha1, b->sha1);\n}\n\n\n/*\n * When a CE gets turned into an unmerged entry, we\n * want it to be up-to-date\n */\nstatic int verify_uptodate_1(struct cache_entry *ce,\n\t\t\t\t   struct unpack_trees_options *o,\n\t\t\t\t   enum unpack_trees_error_types error_type)\n{\n\tstruct stat st;\n\n\tif (o->index_only)\n\t\treturn 0;\n\n\t/*\n\t * CE_VALID and CE_SKIP_WORKTREE cheat, we better check again\n\t * if this entry is truly up-to-date because this file may be\n\t * overwritten.\n\t */\n\tif ((ce->ce_flags & CE_VALID) || ce_skip_worktree(ce))\n\t\t; /* keep checking */\n\telse if (o->reset || ce_uptodate(ce))\n\t\treturn 0;\n\n\tif (!lstat(ce->name, &st)) {\n\t\tint flags = CE_MATCH_IGNORE_VALID|CE_MATCH_IGNORE_SKIP_WORKTREE;\n\t\tunsigned changed = ie_match_stat(o->src_index, ce, &st, flags);\n\t\tif (!changed)\n\t\t\treturn 0;\n\t\t/*\n\t\t * NEEDSWORK: the current default policy is to allow\n\t\t * submodule to be out of sync wrt the superproject\n\t\t * index.  This needs to be tightened later for\n\t\t * submodules that are marked to be automatically\n\t\t * checked out.\n\t\t */\n\t\tif (S_ISGITLINK(ce->ce_mode))\n\t\t\treturn 0;\n\t\terrno = 0;\n\t}\n\tif (errno == ENOENT)\n\t\treturn 0;\n\treturn o->gently ? -1 :\n\t\tadd_rejected_path(o, error_type, ce->name);\n}\n\nstatic int verify_uptodate(struct cache_entry *ce,\n\t\t\t   struct unpack_trees_options *o)\n{\n\tif (!o->skip_sparse_checkout && (ce->ce_flags & CE_NEW_SKIP_WORKTREE))\n\t\treturn 0;\n\treturn verify_uptodate_1(ce, o, ERROR_NOT_UPTODATE_FILE);\n}\n\nstatic int verify_uptodate_sparse(struct cache_entry *ce,\n\t\t\t\t  struct unpack_trees_options *o)\n{\n\treturn verify_uptodate_1(ce, o, ERROR_SPARSE_NOT_UPTODATE_FILE);\n}\n\nstatic void invalidate_ce_path(struct cache_entry *ce, struct unpack_trees_options *o)\n{\n\tif (ce)\n\t\tcache_tree_invalidate_path(o->src_index->cache_tree, ce->name);\n}\n\n/*\n * Check that checking out ce->sha1 in subdir ce->name is not\n * going to overwrite any working files.\n *\n * Currently, git does not checkout subprojects during a superproject\n * checkout, so it is not going to overwrite anything.\n */\nstatic int verify_clean_submodule(struct cache_entry *ce,\n\t\t\t\t      enum unpack_trees_error_types error_type,\n\t\t\t\t      struct unpack_trees_options *o)\n{\n\treturn 0;\n}\n\nstatic int verify_clean_subdirectory(struct cache_entry *ce,\n\t\t\t\t      enum unpack_trees_error_types error_type,\n\t\t\t\t      struct unpack_trees_options *o)\n{\n\t/*\n\t * we are about to extract \"ce->name\"; we would not want to lose\n\t * anything in the existing directory there.\n\t */\n\tint namelen;\n\tint i;\n\tstruct dir_struct d;\n\tchar *pathbuf;\n\tint cnt = 0;\n\tunsigned char sha1[20];\n\n\tif (S_ISGITLINK(ce->ce_mode) &&\n\t    resolve_gitlink_ref(ce->name, \"HEAD\", sha1) == 0) {\n\t\t/* If we are not going to update the submodule, then\n\t\t * we don't care.\n\t\t */\n\t\tif (!hashcmp(sha1, ce->sha1))\n\t\t\treturn 0;\n\t\treturn verify_clean_submodule(ce, error_type, o);\n\t}\n\n\t/*\n\t * First let's make sure we do not have a local modification\n\t * in that directory.\n\t */\n\tnamelen = strlen(ce->name);\n\tfor (i = locate_in_src_index(ce, o);\n\t     i < o->src_index->cache_nr;\n\t     i++) {\n\t\tstruct cache_entry *ce2 = o->src_index->cache[i];\n\t\tint len = ce_namelen(ce2);\n\t\tif (len < namelen ||\n\t\t    strncmp(ce->name, ce2->name, namelen) ||\n\t\t    ce2->name[namelen] != '/')\n\t\t\tbreak;\n\t\t/*\n\t\t * ce2->name is an entry in the subdirectory to be\n\t\t * removed.\n\t\t */\n\t\tif (!ce_stage(ce2)) {\n\t\t\tif (verify_uptodate(ce2, o))\n\t\t\t\treturn -1;\n\t\t\tadd_entry(o, ce2, CE_REMOVE, 0);\n\t\t\tmark_ce_used(ce2, o);\n\t\t}\n\t\tcnt++;\n\t}\n\n\t/*\n\t * Then we need to make sure that we do not lose a locally\n\t * present file that is not ignored.\n\t */\n\tpathbuf = xmalloc(namelen + 2);\n\tmemcpy(pathbuf, ce->name, namelen);\n\tstrcpy(pathbuf+namelen, \"/\");\n\n\tmemset(&d, 0, sizeof(d));\n\tif (o->dir)\n\t\td.exclude_per_dir = o->dir->exclude_per_dir;\n\ti = read_directory(&d, pathbuf, namelen+1, NULL);\n\tif (i)\n\t\treturn o->gently ? -1 :\n\t\t\tadd_rejected_path(o, ERROR_NOT_UPTODATE_DIR, ce->name);\n\tfree(pathbuf);\n\treturn cnt;\n}\n\n/*\n * This gets called when there was no index entry for the tree entry 'dst',\n * but we found a file in the working tree that 'lstat()' said was fine,\n * and we're on a case-insensitive filesystem.\n *\n * See if we can find a case-insensitive match in the index that also\n * matches the stat information, and assume it's that other file!\n */\nstatic int icase_exists(struct unpack_trees_options *o, const char *name, int len, struct stat *st)\n{\n\tstruct cache_entry *src;\n\n\tsrc = index_name_exists(o->src_index, name, len, 1);\n\treturn src && !ie_match_stat(o->src_index, src, st, CE_MATCH_IGNORE_VALID|CE_MATCH_IGNORE_SKIP_WORKTREE);\n}\n\nstatic int check_ok_to_remove(const char *name, int len, int dtype,\n\t\t\t      struct cache_entry *ce, struct stat *st,\n\t\t\t      enum unpack_trees_error_types error_type,\n\t\t\t      struct unpack_trees_options *o)\n{\n\tstruct cache_entry *result;\n\n\t/*\n\t * It may be that the 'lstat()' succeeded even though\n\t * target 'ce' was absent, because there is an old\n\t * entry that is different only in case..\n\t *\n\t * Ignore that lstat() if it matches.\n\t */\n\tif (ignore_case && icase_exists(o, name, len, st))\n\t\treturn 0;\n\n\tif (o->dir &&\n\t    path_excluded(o->path_exclude_check, name, -1, &dtype))\n\t\t/*\n\t\t * ce->name is explicitly excluded, so it is Ok to\n\t\t * overwrite it.\n\t\t */\n\t\treturn 0;\n\tif (S_ISDIR(st->st_mode)) {\n\t\t/*\n\t\t * We are checking out path \"foo\" and\n\t\t * found \"foo/.\" in the working tree.\n\t\t * This is tricky -- if we have modified\n\t\t * files that are in \"foo/\" we would lose\n\t\t * them.\n\t\t */\n\t\tif (verify_clean_subdirectory(ce, error_type, o) < 0)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * The previous round may already have decided to\n\t * delete this path, which is in a subdirectory that\n\t * is being replaced with a blob.\n\t */\n\tresult = index_name_exists(&o->result, name, len, 0);\n\tif (result) {\n\t\tif (result->ce_flags & CE_REMOVE)\n\t\t\treturn 0;\n\t}\n\n\treturn o->gently ? -1 :\n\t\tadd_rejected_path(o, error_type, name);\n}\n\n/*\n * We do not want to remove or overwrite a working tree file that\n * is not tracked, unless it is ignored.\n */\nstatic int verify_absent_1(struct cache_entry *ce,\n\t\t\t\t enum unpack_trees_error_types error_type,\n\t\t\t\t struct unpack_trees_options *o)\n{\n\tint len;\n\tstruct stat st;\n\n\tif (o->index_only || o->reset || !o->update)\n\t\treturn 0;\n\n\tlen = check_leading_path(ce->name, ce_namelen(ce));\n\tif (!len)\n\t\treturn 0;\n\telse if (len > 0) {\n\t\tchar path[PATH_MAX + 1];\n\t\tmemcpy(path, ce->name, len);\n\t\tpath[len] = 0;\n\t\tif (lstat(path, &st))\n\t\t\treturn error(\"cannot stat '%s': %s\", path,\n\t\t\t\t\tstrerror(errno));\n\n\t\treturn check_ok_to_remove(path, len, DT_UNKNOWN, NULL, &st,\n\t\t\t\terror_type, o);\n\t} else if (lstat(ce->name, &st)) {\n\t\tif (errno != ENOENT)\n\t\t\treturn error(\"cannot stat '%s': %s\", ce->name,\n\t\t\t\t     strerror(errno));\n\t\treturn 0;\n\t} else {\n\t\treturn check_ok_to_remove(ce->name, ce_namelen(ce),\n\t\t\t\t\t  ce_to_dtype(ce), ce, &st,\n\t\t\t\t\t  error_type, o);\n\t}\n}\n\nstatic int verify_absent(struct cache_entry *ce,\n\t\t\t enum unpack_trees_error_types error_type,\n\t\t\t struct unpack_trees_options *o)\n{\n\tif (!o->skip_sparse_checkout && (ce->ce_flags & CE_NEW_SKIP_WORKTREE))\n\t\treturn 0;\n\treturn verify_absent_1(ce, error_type, o);\n}\n\nstatic int verify_absent_sparse(struct cache_entry *ce,\n\t\t\t enum unpack_trees_error_types error_type,\n\t\t\t struct unpack_trees_options *o)\n{\n\tenum unpack_trees_error_types orphaned_error = error_type;\n\tif (orphaned_error == ERROR_WOULD_LOSE_UNTRACKED_OVERWRITTEN)\n\t\torphaned_error = ERROR_WOULD_LOSE_ORPHANED_OVERWRITTEN;\n\n\treturn verify_absent_1(ce, orphaned_error, o);\n}\n\nstatic int merged_entry(struct cache_entry *merge, struct cache_entry *old,\n\t\tstruct unpack_trees_options *o)\n{\n\tint update = CE_UPDATE;\n\n\tif (!old) {\n\t\t/*\n\t\t * New index entries. In sparse checkout, the following\n\t\t * verify_absent() will be delayed until after\n\t\t * traverse_trees() finishes in unpack_trees(), then:\n\t\t *\n\t\t *  - CE_NEW_SKIP_WORKTREE will be computed correctly\n\t\t *  - verify_absent() be called again, this time with\n\t\t *    correct CE_NEW_SKIP_WORKTREE\n\t\t *\n\t\t * verify_absent() call here does nothing in sparse\n\t\t * checkout (i.e. o->skip_sparse_checkout == 0)\n\t\t */\n\t\tupdate |= CE_ADDED;\n\t\tmerge->ce_flags |= CE_NEW_SKIP_WORKTREE;\n\n\t\tif (verify_absent(merge, ERROR_WOULD_LOSE_UNTRACKED_OVERWRITTEN, o))\n\t\t\treturn -1;\n\t\tinvalidate_ce_path(merge, o);\n\t} else if (!(old->ce_flags & CE_CONFLICTED)) {\n\t\t/*\n\t\t * See if we can re-use the old CE directly?\n\t\t * That way we get the uptodate stat info.\n\t\t *\n\t\t * This also removes the UPDATE flag on a match; otherwise\n\t\t * we will end up overwriting local changes in the work tree.\n\t\t */\n\t\tif (same(old, merge)) {\n\t\t\tcopy_cache_entry(merge, old);\n\t\t\tupdate = 0;\n\t\t} else {\n\t\t\tif (verify_uptodate(old, o))\n\t\t\t\treturn -1;\n\t\t\t/* Migrate old flags over */\n\t\t\tupdate |= old->ce_flags & (CE_SKIP_WORKTREE | CE_NEW_SKIP_WORKTREE);\n\t\t\tinvalidate_ce_path(old, o);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Previously unmerged entry left as an existence\n\t\t * marker by read_index_unmerged();\n\t\t */\n\t\tinvalidate_ce_path(old, o);\n\t}\n\n\tadd_entry(o, merge, update, CE_STAGEMASK);\n\treturn 1;\n}\n\nstatic int deleted_entry(struct cache_entry *ce, struct cache_entry *old,\n\t\tstruct unpack_trees_options *o)\n{\n\t/* Did it exist in the index? */\n\tif (!old) {\n\t\tif (verify_absent(ce, ERROR_WOULD_LOSE_UNTRACKED_REMOVED, o))\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\tif (!(old->ce_flags & CE_CONFLICTED) && verify_uptodate(old, o))\n\t\treturn -1;\n\tadd_entry(o, ce, CE_REMOVE, 0);\n\tinvalidate_ce_path(ce, o);\n\treturn 1;\n}\n\nstatic int keep_entry(struct cache_entry *ce, struct unpack_trees_options *o)\n{\n\tadd_entry(o, ce, 0, 0);\n\treturn 1;\n}\n\n#if DBRT_DEBUG\nstatic void show_stage_entry(FILE *o,\n\t\t\t     const char *label, const struct cache_entry *ce)\n{\n\tif (!ce)\n\t\tfprintf(o, \"%s (missing)\\n\", label);\n\telse\n\t\tfprintf(o, \"%s%06o %s %d\\t%s\\n\",\n\t\t\tlabel,\n\t\t\tce->ce_mode,\n\t\t\tsha1_to_hex(ce->sha1),\n\t\t\tce_stage(ce),\n\t\t\tce->name);\n}\n#endif\n\nint threeway_merge(struct cache_entry **stages, struct unpack_trees_options *o)\n{\n\tstruct cache_entry *index;\n\tstruct cache_entry *head;\n\tstruct cache_entry *remote = stages[o->head_idx + 1];\n\tint count;\n\tint head_match = 0;\n\tint remote_match = 0;\n\n\tint df_conflict_head = 0;\n\tint df_conflict_remote = 0;\n\n\tint any_anc_missing = 0;\n\tint no_anc_exists = 1;\n\tint i;\n\n\tfor (i = 1; i < o->head_idx; i++) {\n\t\tif (!stages[i] || stages[i] == o->df_conflict_entry)\n\t\t\tany_anc_missing = 1;\n\t\telse\n\t\t\tno_anc_exists = 0;\n\t}\n\n\tindex = stages[0];\n\thead = stages[o->head_idx];\n\n\tif (head == o->df_conflict_entry) {\n\t\tdf_conflict_head = 1;\n\t\thead = NULL;\n\t}\n\n\tif (remote == o->df_conflict_entry) {\n\t\tdf_conflict_remote = 1;\n\t\tremote = NULL;\n\t}\n\n\t/*\n\t * First, if there's a #16 situation, note that to prevent #13\n\t * and #14.\n\t */\n\tif (!same(remote, head)) {\n\t\tfor (i = 1; i < o->head_idx; i++) {\n\t\t\tif (same(stages[i], head)) {\n\t\t\t\thead_match = i;\n\t\t\t}\n\t\t\tif (same(stages[i], remote)) {\n\t\t\t\tremote_match = i;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * We start with cases where the index is allowed to match\n\t * something other than the head: #14(ALT) and #2ALT, where it\n\t * is permitted to match the result instead.\n\t */\n\t/* #14, #14ALT, #2ALT */\n\tif (remote && !df_conflict_head && head_match && !remote_match) {\n\t\tif (index && !same(index, remote) && !same(index, head))\n\t\t\treturn o->gently ? -1 : reject_merge(index, o);\n\t\treturn merged_entry(remote, index, o);\n\t}\n\t/*\n\t * If we have an entry in the index cache, then we want to\n\t * make sure that it matches head.\n\t */\n\tif (index && !same(index, head))\n\t\treturn o->gently ? -1 : reject_merge(index, o);\n\n\tif (head) {\n\t\t/* #5ALT, #15 */\n\t\tif (same(head, remote))\n\t\t\treturn merged_entry(head, index, o);\n\t\t/* #13, #3ALT */\n\t\tif (!df_conflict_remote && remote_match && !head_match)\n\t\t\treturn merged_entry(head, index, o);\n\t}\n\n\t/* #1 */\n\tif (!head && !remote && any_anc_missing)\n\t\treturn 0;\n\n\t/*\n\t * Under the \"aggressive\" rule, we resolve mostly trivial\n\t * cases that we historically had git-merge-one-file resolve.\n\t */\n\tif (o->aggressive) {\n\t\tint head_deleted = !head;\n\t\tint remote_deleted = !remote;\n\t\tstruct cache_entry *ce = NULL;\n\n\t\tif (index)\n\t\t\tce = index;\n\t\telse if (head)\n\t\t\tce = head;\n\t\telse if (remote)\n\t\t\tce = remote;\n\t\telse {\n\t\t\tfor (i = 1; i < o->head_idx; i++) {\n\t\t\t\tif (stages[i] && stages[i] != o->df_conflict_entry) {\n\t\t\t\t\tce = stages[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Deleted in both.\n\t\t * Deleted in one and unchanged in the other.\n\t\t */\n\t\tif ((head_deleted && remote_deleted) ||\n\t\t    (head_deleted && remote && remote_match) ||\n\t\t    (remote_deleted && head && head_match)) {\n\t\t\tif (index)\n\t\t\t\treturn deleted_entry(index, index, o);\n\t\t\tif (ce && !head_deleted) {\n\t\t\t\tif (verify_absent(ce, ERROR_WOULD_LOSE_UNTRACKED_REMOVED, o))\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * Added in both, identically.\n\t\t */\n\t\tif (no_anc_exists && head && remote && same(head, remote))\n\t\t\treturn merged_entry(head, index, o);\n\n\t}\n\n\t/* Below are \"no merge\" cases, which require that the index be\n\t * up-to-date to avoid the files getting overwritten with\n\t * conflict resolution files.\n\t */\n\tif (index) {\n\t\tif (verify_uptodate(index, o))\n\t\t\treturn -1;\n\t}\n\n\to->nontrivial_merge = 1;\n\n\t/* #2, #3, #4, #6, #7, #9, #10, #11. */\n\tcount = 0;\n\tif (!head_match || !remote_match) {\n\t\tfor (i = 1; i < o->head_idx; i++) {\n\t\t\tif (stages[i] && stages[i] != o->df_conflict_entry) {\n\t\t\t\tkeep_entry(stages[i], o);\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#if DBRT_DEBUG\n\telse {\n\t\tfprintf(stderr, \"read-tree: warning #16 detected\\n\");\n\t\tshow_stage_entry(stderr, \"head   \", stages[head_match]);\n\t\tshow_stage_entry(stderr, \"remote \", stages[remote_match]);\n\t}\n#endif\n\tif (head) { count += keep_entry(head, o); }\n\tif (remote) { count += keep_entry(remote, o); }\n\treturn count;\n}\n\n/*\n * Two-way merge.\n *\n * The rule is to \"carry forward\" what is in the index without losing\n * information across a \"fast-forward\", favoring a successful merge\n * over a merge failure when it makes sense.  For details of the\n * \"carry forward\" rule, please see <Documentation/git-read-tree.txt>.\n *\n */\nint twoway_merge(struct cache_entry **src, struct unpack_trees_options *o)\n{\n\tstruct cache_entry *current = src[0];\n\tstruct cache_entry *oldtree = src[1];\n\tstruct cache_entry *newtree = src[2];\n\n\tif (o->merge_size != 2)\n\t\treturn error(\"Cannot do a twoway merge of %d trees\",\n\t\t\t     o->merge_size);\n\n\tif (oldtree == o->df_conflict_entry)\n\t\toldtree = NULL;\n\tif (newtree == o->df_conflict_entry)\n\t\tnewtree = NULL;\n\n\tif (current) {\n\t\tif ((!oldtree && !newtree) || /* 4 and 5 */\n\t\t    (!oldtree && newtree &&\n\t\t     same(current, newtree)) || /* 6 and 7 */\n\t\t    (oldtree && newtree &&\n\t\t     same(oldtree, newtree)) || /* 14 and 15 */\n\t\t    (oldtree && newtree &&\n\t\t     !same(oldtree, newtree) && /* 18 and 19 */\n\t\t     same(current, newtree))) {\n\t\t\treturn keep_entry(current, o);\n\t\t}\n\t\telse if (oldtree && !newtree && same(current, oldtree)) {\n\t\t\t/* 10 or 11 */\n\t\t\treturn deleted_entry(oldtree, current, o);\n\t\t}\n\t\telse if (oldtree && newtree &&\n\t\t\t same(current, oldtree) && !same(current, newtree)) {\n\t\t\t/* 20 or 21 */\n\t\t\treturn merged_entry(newtree, current, o);\n\t\t}\n\t\telse {\n\t\t\t/* all other failures */\n\t\t\tif (oldtree)\n\t\t\t\treturn o->gently ? -1 : reject_merge(oldtree, o);\n\t\t\tif (current)\n\t\t\t\treturn o->gently ? -1 : reject_merge(current, o);\n\t\t\tif (newtree)\n\t\t\t\treturn o->gently ? -1 : reject_merge(newtree, o);\n\t\t\treturn -1;\n\t\t}\n\t}\n\telse if (newtree) {\n\t\tif (oldtree && !o->initial_checkout) {\n\t\t\t/*\n\t\t\t * deletion of the path was staged;\n\t\t\t */\n\t\t\tif (same(oldtree, newtree))\n\t\t\t\treturn 1;\n\t\t\treturn reject_merge(oldtree, o);\n\t\t}\n\t\treturn merged_entry(newtree, current, o);\n\t}\n\treturn deleted_entry(oldtree, current, o);\n}\n\n/*\n * Bind merge.\n *\n * Keep the index entries at stage0, collapse stage1 but make sure\n * stage0 does not have anything there.\n */\nint bind_merge(struct cache_entry **src,\n\t\tstruct unpack_trees_options *o)\n{\n\tstruct cache_entry *old = src[0];\n\tstruct cache_entry *a = src[1];\n\n\tif (o->merge_size != 1)\n\t\treturn error(\"Cannot do a bind merge of %d trees\",\n\t\t\t     o->merge_size);\n\tif (a && old)\n\t\treturn o->gently ? -1 :\n\t\t\terror(ERRORMSG(o, ERROR_BIND_OVERLAP), a->name, old->name);\n\tif (!a)\n\t\treturn keep_entry(old, o);\n\telse\n\t\treturn merged_entry(a, NULL, o);\n}\n\n/*\n * One-way merge.\n *\n * The rule is:\n * - take the stat information from stage0, take the data from stage1\n */\nint oneway_merge(struct cache_entry **src, struct unpack_trees_options *o)\n{\n\tstruct cache_entry *old = src[0];\n\tstruct cache_entry *a = src[1];\n\n\tif (o->merge_size != 1)\n\t\treturn error(\"Cannot do a oneway merge of %d trees\",\n\t\t\t     o->merge_size);\n\n\tif (!a || a == o->df_conflict_entry)\n\t\treturn deleted_entry(old, old, o);\n\n\tif (old && same(old, a)) {\n\t\tint update = 0;\n\t\tif (o->reset && !ce_uptodate(old) && !ce_skip_worktree(old)) {\n\t\t\tstruct stat st;\n\t\t\tif (lstat(old->name, &st) ||\n\t\t\t    ie_match_stat(o->src_index, old, &st, CE_MATCH_IGNORE_VALID|CE_MATCH_IGNORE_SKIP_WORKTREE))\n\t\t\t\tupdate |= CE_UPDATE;\n\t\t}\n\t\tadd_entry(o, old, update, 0);\n\t\treturn 0;\n\t}\n\treturn merged_entry(a, old, o);\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00710b97812b033db91c1e76c8b441936d92a7d1",
  "sha1_ok": true,
  "size": 48659
}
