{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJyZWZzLmgiCiNpbmNsdWRlICJzdHJpbmctbGlzdC5oIgojaW5jbHVkZSAidXRmOC5oIgojaW5jbHVkZSAiZGF0ZS5oIgoKaW50IHN0YXJ0c193aXRoKGNvbnN0IGNoYXIgKnN0ciwgY29uc3QgY2hhciAqcHJlZml4KQp7Cglmb3IgKDsgOyBzdHIrKywgcHJlZml4KyspCgkJaWYgKCEqcHJlZml4KQoJCQlyZXR1cm4gMTsKCQllbHNlIGlmICgqc3RyICE9ICpwcmVmaXgpCgkJCXJldHVybiAwOwp9CgppbnQgaXN0YXJ0c193aXRoKGNvbnN0IGNoYXIgKnN0ciwgY29uc3QgY2hhciAqcHJlZml4KQp7Cglmb3IgKDsgOyBzdHIrKywgcHJlZml4KyspCgkJaWYgKCEqcHJlZml4KQoJCQlyZXR1cm4gMTsKCQllbHNlIGlmICh0b2xvd2VyKCpzdHIpICE9IHRvbG93ZXIoKnByZWZpeCkpCgkJCXJldHVybiAwOwp9CgppbnQgc2tpcF90b19vcHRpb25hbF9hcmdfZGVmYXVsdChjb25zdCBjaGFyICpzdHIsIGNvbnN0IGNoYXIgKnByZWZpeCwKCQkJCSBjb25zdCBjaGFyICoqYXJnLCBjb25zdCBjaGFyICpkZWYpCnsKCWNvbnN0IGNoYXIgKnA7CgoJaWYgKCFza2lwX3ByZWZpeChzdHIsIHByZWZpeCwgJnApKQoJCXJldHVybiAwOwoKCWlmICghKnApIHsKCQlpZiAoYXJnKQoJCQkqYXJnID0gZGVmOwoJCXJldHVybiAxOwoJfQoKCWlmICgqcCAhPSAnPScpCgkJcmV0dXJuIDA7CgoJaWYgKGFyZykKCQkqYXJnID0gcCArIDE7CglyZXR1cm4gMTsKfQoKLyoKICogVXNlZCBhcyB0aGUgZGVmYXVsdCAtPmJ1ZiB2YWx1ZSwgc28gdGhhdCBwZW9wbGUgY2FuIGFsd2F5cyBhc3N1bWUKICogYnVmIGlzIG5vbiBOVUxMIGFuZCAtPmJ1ZiBpcyBOVUwgdGVybWluYXRlZCBldmVuIGZvciBhIGZyZXNobHkKICogaW5pdGlhbGl6ZWQgc3RyYnVmLgogKi8KY2hhciBzdHJidWZfc2xvcGJ1ZlsxXTsKCnZvaWQgc3RyYnVmX2luaXQoc3RydWN0IHN0cmJ1ZiAqc2IsIHNpemVfdCBoaW50KQp7CglzdHJ1Y3Qgc3RyYnVmIGJsYW5rID0gU1RSQlVGX0lOSVQ7CgltZW1jcHkoc2IsICZibGFuaywgc2l6ZW9mKCpzYikpOwoJaWYgKGhpbnQpCgkJc3RyYnVmX2dyb3coc2IsIGhpbnQpOwp9Cgp2b2lkIHN0cmJ1Zl9yZWxlYXNlKHN0cnVjdCBzdHJidWYgKnNiKQp7CglpZiAoc2ItPmFsbG9jKSB7CgkJZnJlZShzYi0+YnVmKTsKCQlzdHJidWZfaW5pdChzYiwgMCk7Cgl9Cn0KCmNoYXIgKnN0cmJ1Zl9kZXRhY2goc3RydWN0IHN0cmJ1ZiAqc2IsIHNpemVfdCAqc3opCnsKCWNoYXIgKnJlczsKCXN0cmJ1Zl9ncm93KHNiLCAwKTsKCXJlcyA9IHNiLT5idWY7CglpZiAoc3opCgkJKnN6ID0gc2ItPmxlbjsKCXN0cmJ1Zl9pbml0KHNiLCAwKTsKCXJldHVybiByZXM7Cn0KCnZvaWQgc3RyYnVmX2F0dGFjaChzdHJ1Y3Qgc3RyYnVmICpzYiwgdm9pZCAqYnVmLCBzaXplX3QgbGVuLCBzaXplX3QgYWxsb2MpCnsKCXN0cmJ1Zl9yZWxlYXNlKHNiKTsKCXNiLT5idWYgICA9IGJ1ZjsKCXNiLT5sZW4gICA9IGxlbjsKCXNiLT5hbGxvYyA9IGFsbG9jOwoJc3RyYnVmX2dyb3coc2IsIDApOwoJc2ItPmJ1ZltzYi0+bGVuXSA9ICdcMCc7Cn0KCnZvaWQgc3RyYnVmX2dyb3coc3RydWN0IHN0cmJ1ZiAqc2IsIHNpemVfdCBleHRyYSkKewoJaW50IG5ld19idWYgPSAhc2ItPmFsbG9jOwoJaWYgKHVuc2lnbmVkX2FkZF9vdmVyZmxvd3MoZXh0cmEsIDEpIHx8CgkgICAgdW5zaWduZWRfYWRkX292ZXJmbG93cyhzYi0+bGVuLCBleHRyYSArIDEpKQoJCWRpZSgieW91IHdhbnQgdG8gdXNlIHdheSB0b28gbXVjaCBtZW1vcnkiKTsKCWlmIChuZXdfYnVmKQoJCXNiLT5idWYgPSBOVUxMOwoJQUxMT0NfR1JPVyhzYi0+YnVmLCBzYi0+bGVuICsgZXh0cmEgKyAxLCBzYi0+YWxsb2MpOwoJaWYgKG5ld19idWYpCgkJc2ItPmJ1ZlswXSA9ICdcMCc7Cn0KCnZvaWQgc3RyYnVmX3RyaW0oc3RydWN0IHN0cmJ1ZiAqc2IpCnsKCXN0cmJ1Zl9ydHJpbShzYik7CglzdHJidWZfbHRyaW0oc2IpOwp9Cgp2b2lkIHN0cmJ1Zl9ydHJpbShzdHJ1Y3Qgc3RyYnVmICpzYikKewoJd2hpbGUgKHNiLT5sZW4gPiAwICYmIGlzc3BhY2UoKHVuc2lnbmVkIGNoYXIpc2ItPmJ1ZltzYi0+bGVuIC0gMV0pKQoJCXNiLT5sZW4tLTsKCXNiLT5idWZbc2ItPmxlbl0gPSAnXDAnOwp9Cgp2b2lkIHN0cmJ1Zl90cmltX3RyYWlsaW5nX2Rpcl9zZXAoc3RydWN0IHN0cmJ1ZiAqc2IpCnsKCXdoaWxlIChzYi0+bGVuID4gMCAmJiBpc19kaXJfc2VwKCh1bnNpZ25lZCBjaGFyKXNiLT5idWZbc2ItPmxlbiAtIDFdKSkKCQlzYi0+bGVuLS07CglzYi0+YnVmW3NiLT5sZW5dID0gJ1wwJzsKfQoKdm9pZCBzdHJidWZfdHJpbV90cmFpbGluZ19uZXdsaW5lKHN0cnVjdCBzdHJidWYgKnNiKQp7CglpZiAoc2ItPmxlbiA+IDAgJiYgc2ItPmJ1ZltzYi0+bGVuIC0gMV0gPT0gJ1xuJykgewoJCWlmICgtLXNiLT5sZW4gPiAwICYmIHNiLT5idWZbc2ItPmxlbiAtIDFdID09ICdccicpCgkJCS0tc2ItPmxlbjsKCQlzYi0+YnVmW3NiLT5sZW5dID0gJ1wwJzsKCX0KfQoKdm9pZCBzdHJidWZfbHRyaW0oc3RydWN0IHN0cmJ1ZiAqc2IpCnsKCWNoYXIgKmIgPSBzYi0+YnVmOwoJd2hpbGUgKHNiLT5sZW4gPiAwICYmIGlzc3BhY2UoKmIpKSB7CgkJYisrOwoJCXNiLT5sZW4tLTsKCX0KCW1lbW1vdmUoc2ItPmJ1ZiwgYiwgc2ItPmxlbik7CglzYi0+YnVmW3NiLT5sZW5dID0gJ1wwJzsKfQoKaW50IHN0cmJ1Zl9yZWVuY29kZShzdHJ1Y3Qgc3RyYnVmICpzYiwgY29uc3QgY2hhciAqZnJvbSwgY29uc3QgY2hhciAqdG8pCnsKCWNoYXIgKm91dDsKCXNpemVfdCBsZW47CgoJaWYgKHNhbWVfZW5jb2RpbmcoZnJvbSwgdG8pKQoJCXJldHVybiAwOwoKCW91dCA9IHJlZW5jb2RlX3N0cmluZ19sZW4oc2ItPmJ1Ziwgc2ItPmxlbiwgdG8sIGZyb20sICZsZW4pOwoJaWYgKCFvdXQpCgkJcmV0dXJuIC0xOwoKCXN0cmJ1Zl9hdHRhY2goc2IsIG91dCwgbGVuLCBsZW4pOwoJcmV0dXJuIDA7Cn0KCnZvaWQgc3RyYnVmX3RvbG93ZXIoc3RydWN0IHN0cmJ1ZiAqc2IpCnsKCWNoYXIgKnAgPSBzYi0+YnVmLCAqZW5kID0gc2ItPmJ1ZiArIHNiLT5sZW47Cglmb3IgKDsgcCA8IGVuZDsgcCsrKQoJCSpwID0gdG9sb3dlcigqcCk7Cn0KCnN0cnVjdCBzdHJidWYgKipzdHJidWZfc3BsaXRfYnVmKGNvbnN0IGNoYXIgKnN0ciwgc2l6ZV90IHNsZW4sCgkJCQkgaW50IHRlcm1pbmF0b3IsIGludCBtYXgpCnsKCXN0cnVjdCBzdHJidWYgKipyZXQgPSBOVUxMOwoJc2l6ZV90IG5yID0gMCwgYWxsb2MgPSAwOwoJc3RydWN0IHN0cmJ1ZiAqdDsKCgl3aGlsZSAoc2xlbikgewoJCWludCBsZW4gPSBzbGVuOwoJCWlmIChtYXggPD0gMCB8fCBuciArIDEgPCBtYXgpIHsKCQkJY29uc3QgY2hhciAqZW5kID0gbWVtY2hyKHN0ciwgdGVybWluYXRvciwgc2xlbik7CgkJCWlmIChlbmQpCgkJCQlsZW4gPSBlbmQgLSBzdHIgKyAxOwoJCX0KCQl0ID0geG1hbGxvYyhzaXplb2Yoc3RydWN0IHN0cmJ1ZikpOwoJCXN0cmJ1Zl9pbml0KHQsIGxlbik7CgkJc3RyYnVmX2FkZCh0LCBzdHIsIGxlbik7CgkJQUxMT0NfR1JPVyhyZXQsIG5yICsgMiwgYWxsb2MpOwoJCXJldFtucisrXSA9IHQ7CgkJc3RyICs9IGxlbjsKCQlzbGVuIC09IGxlbjsKCX0KCUFMTE9DX0dST1cocmV0LCBuciArIDEsIGFsbG9jKTsgLyogSW4gY2FzZSBzdHJpbmcgd2FzIGVtcHR5ICovCglyZXRbbnJdID0gTlVMTDsKCXJldHVybiByZXQ7Cn0KCnZvaWQgc3RyYnVmX2FkZF9zZXBhcmF0ZWRfc3RyaW5nX2xpc3Qoc3RydWN0IHN0cmJ1ZiAqc3RyLAoJCQkJICAgICAgY29uc3QgY2hhciAqc2VwLAoJCQkJICAgICAgc3RydWN0IHN0cmluZ19saXN0ICpzbGlzdCkKewoJc3RydWN0IHN0cmluZ19saXN0X2l0ZW0gKml0ZW07CglpbnQgc2VwX25lZWRlZCA9IDA7CgoJZm9yX2VhY2hfc3RyaW5nX2xpc3RfaXRlbShpdGVtLCBzbGlzdCkgewoJCWlmIChzZXBfbmVlZGVkKQoJCQlzdHJidWZfYWRkc3RyKHN0ciwgc2VwKTsKCQlzdHJidWZfYWRkc3RyKHN0ciwgaXRlbS0+c3RyaW5nKTsKCQlzZXBfbmVlZGVkID0gMTsKCX0KfQoKdm9pZCBzdHJidWZfbGlzdF9mcmVlKHN0cnVjdCBzdHJidWYgKipzYnMpCnsKCXN0cnVjdCBzdHJidWYgKipzID0gc2JzOwoKCWlmICghcykKCQlyZXR1cm47Cgl3aGlsZSAoKnMpIHsKCQlzdHJidWZfcmVsZWFzZSgqcyk7CgkJZnJlZSgqcysrKTsKCX0KCWZyZWUoc2JzKTsKfQoKaW50IHN0cmJ1Zl9jbXAoY29uc3Qgc3RydWN0IHN0cmJ1ZiAqYSwgY29uc3Qgc3RydWN0IHN0cmJ1ZiAqYikKewoJc2l6ZV90IGxlbiA9IGEtPmxlbiA8IGItPmxlbiA/IGEtPmxlbjogYi0+bGVuOwoJaW50IGNtcCA9IG1lbWNtcChhLT5idWYsIGItPmJ1ZiwgbGVuKTsKCWlmIChjbXApCgkJcmV0dXJuIGNtcDsKCXJldHVybiBhLT5sZW4gPCBiLT5sZW4gPyAtMTogYS0+bGVuICE9IGItPmxlbjsKfQoKdm9pZCBzdHJidWZfc3BsaWNlKHN0cnVjdCBzdHJidWYgKnNiLCBzaXplX3QgcG9zLCBzaXplX3QgbGVuLAoJCQkJICAgY29uc3Qgdm9pZCAqZGF0YSwgc2l6ZV90IGRsZW4pCnsKCWlmICh1bnNpZ25lZF9hZGRfb3ZlcmZsb3dzKHBvcywgbGVuKSkKCQlkaWUoInlvdSB3YW50IHRvIHVzZSB3YXkgdG9vIG11Y2ggbWVtb3J5Iik7CglpZiAocG9zID4gc2ItPmxlbikKCQlkaWUoImBwb3MnIGlzIHRvbyBmYXIgYWZ0ZXIgdGhlIGVuZCBvZiB0aGUgYnVmZmVyIik7CglpZiAocG9zICsgbGVuID4gc2ItPmxlbikKCQlkaWUoImBwb3MgKyBsZW4nIGlzIHRvbyBmYXIgYWZ0ZXIgdGhlIGVuZCBvZiB0aGUgYnVmZmVyIik7CgoJaWYgKGRsZW4gPj0gbGVuKQoJCXN0cmJ1Zl9ncm93KHNiLCBkbGVuIC0gbGVuKTsKCW1lbW1vdmUoc2ItPmJ1ZiArIHBvcyArIGRsZW4sCgkJCXNiLT5idWYgKyBwb3MgKyBsZW4sCgkJCXNiLT5sZW4gLSBwb3MgLSBsZW4pOwoJbWVtY3B5KHNiLT5idWYgKyBwb3MsIGRhdGEsIGRsZW4pOwoJc3RyYnVmX3NldGxlbihzYiwgc2ItPmxlbiArIGRsZW4gLSBsZW4pOwp9Cgp2b2lkIHN0cmJ1Zl9pbnNlcnQoc3RydWN0IHN0cmJ1ZiAqc2IsIHNpemVfdCBwb3MsIGNvbnN0IHZvaWQgKmRhdGEsIHNpemVfdCBsZW4pCnsKCXN0cmJ1Zl9zcGxpY2Uoc2IsIHBvcywgMCwgZGF0YSwgbGVuKTsKfQoKdm9pZCBzdHJidWZfdmluc2VydGYoc3RydWN0IHN0cmJ1ZiAqc2IsIHNpemVfdCBwb3MsIGNvbnN0IGNoYXIgKmZtdCwgdmFfbGlzdCBhcCkKewoJaW50IGxlbiwgbGVuMjsKCWNoYXIgc2F2ZTsKCXZhX2xpc3QgY3A7CgoJaWYgKHBvcyA+IHNiLT5sZW4pCgkJZGllKCJgcG9zJyBpcyB0b28gZmFyIGFmdGVyIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciIpOwoJdmFfY29weShjcCwgYXApOwoJbGVuID0gdnNucHJpbnRmKHNiLT5idWYgKyBzYi0+bGVuLCAwLCBmbXQsIGNwKTsKCXZhX2VuZChjcCk7CglpZiAobGVuIDwgMCkKCQlCVUcoInlvdXIgdnNucHJpbnRmIGlzIGJyb2tlbiAocmV0dXJuZWQgJWQpIiwgbGVuKTsKCWlmICghbGVuKQoJCXJldHVybjsgLyogbm90aGluZyB0byBkbyAqLwoJaWYgKHVuc2lnbmVkX2FkZF9vdmVyZmxvd3Moc2ItPmxlbiwgbGVuKSkKCQlkaWUoInlvdSB3YW50IHRvIHVzZSB3YXkgdG9vIG11Y2ggbWVtb3J5Iik7CglzdHJidWZfZ3JvdyhzYiwgbGVuKTsKCW1lbW1vdmUoc2ItPmJ1ZiArIHBvcyArIGxlbiwgc2ItPmJ1ZiArIHBvcywgc2ItPmxlbiAtIHBvcyk7CgkvKiB2c25wcmludGYoKSB3aWxsIGFwcGVuZCBhIE5VTCwgb3ZlcndyaXRpbmcgb25lIG9mIG91ciBjaGFyYWN0ZXJzICovCglzYXZlID0gc2ItPmJ1Zltwb3MgKyBsZW5dOwoJbGVuMiA9IHZzbnByaW50ZihzYi0+YnVmICsgcG9zLCBsZW4gKyAxLCBmbXQsIGFwKTsKCXNiLT5idWZbcG9zICsgbGVuXSA9IHNhdmU7CglpZiAobGVuMiAhPSBsZW4pCgkJQlVHKCJ5b3VyIHZzbnByaW50ZiBpcyBicm9rZW4gKHJldHVybnMgaW5jb25zaXN0ZW50IGxlbmd0aHMpIik7CglzdHJidWZfc2V0bGVuKHNiLCBzYi0+bGVuICsgbGVuKTsKfQoKdm9pZCBzdHJidWZfaW5zZXJ0ZihzdHJ1Y3Qgc3RyYnVmICpzYiwgc2l6ZV90IHBvcywgY29uc3QgY2hhciAqZm10LCAuLi4pCnsKCXZhX2xpc3QgYXA7Cgl2YV9zdGFydChhcCwgZm10KTsKCXN0cmJ1Zl92aW5zZXJ0ZihzYiwgcG9zLCBmbXQsIGFwKTsKCXZhX2VuZChhcCk7Cn0KCnZvaWQgc3RyYnVmX3JlbW92ZShzdHJ1Y3Qgc3RyYnVmICpzYiwgc2l6ZV90IHBvcywgc2l6ZV90IGxlbikKewoJc3RyYnVmX3NwbGljZShzYiwgcG9zLCBsZW4sICIiLCAwKTsKfQoKdm9pZCBzdHJidWZfYWRkKHN0cnVjdCBzdHJidWYgKnNiLCBjb25zdCB2b2lkICpkYXRhLCBzaXplX3QgbGVuKQp7CglzdHJidWZfZ3JvdyhzYiwgbGVuKTsKCW1lbWNweShzYi0+YnVmICsgc2ItPmxlbiwgZGF0YSwgbGVuKTsKCXN0cmJ1Zl9zZXRsZW4oc2IsIHNiLT5sZW4gKyBsZW4pOwp9Cgp2b2lkIHN0cmJ1Zl9hZGRidWYoc3RydWN0IHN0cmJ1ZiAqc2IsIGNvbnN0IHN0cnVjdCBzdHJidWYgKnNiMikKewoJc3RyYnVmX2dyb3coc2IsIHNiMi0+bGVuKTsKCW1lbWNweShzYi0+YnVmICsgc2ItPmxlbiwgc2IyLT5idWYsIHNiMi0+bGVuKTsKCXN0cmJ1Zl9zZXRsZW4oc2IsIHNiLT5sZW4gKyBzYjItPmxlbik7Cn0KCmNvbnN0IGNoYXIgKnN0cmJ1Zl9qb2luX2FyZ3Yoc3RydWN0IHN0cmJ1ZiAqYnVmLAoJCQkgICAgIGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndiwgY2hhciBkZWxpbSkKewoJaWYgKCFhcmdjKQoJCXJldHVybiBidWYtPmJ1ZjsKCglzdHJidWZfYWRkc3RyKGJ1ZiwgKmFyZ3YpOwoJd2hpbGUgKC0tYXJnYykgewoJCXN0cmJ1Zl9hZGRjaChidWYsIGRlbGltKTsKCQlzdHJidWZfYWRkc3RyKGJ1ZiwgKigrK2FyZ3YpKTsKCX0KCglyZXR1cm4gYnVmLT5idWY7Cn0KCnZvaWQgc3RyYnVmX2FkZGNoYXJzKHN0cnVjdCBzdHJidWYgKnNiLCBpbnQgYywgc2l6ZV90IG4pCnsKCXN0cmJ1Zl9ncm93KHNiLCBuKTsKCW1lbXNldChzYi0+YnVmICsgc2ItPmxlbiwgYywgbik7CglzdHJidWZfc2V0bGVuKHNiLCBzYi0+bGVuICsgbik7Cn0KCnZvaWQgc3RyYnVmX2FkZGYoc3RydWN0IHN0cmJ1ZiAqc2IsIGNvbnN0IGNoYXIgKmZtdCwgLi4uKQp7Cgl2YV9saXN0IGFwOwoJdmFfc3RhcnQoYXAsIGZtdCk7CglzdHJidWZfdmFkZGYoc2IsIGZtdCwgYXApOwoJdmFfZW5kKGFwKTsKfQoKc3RhdGljIHZvaWQgYWRkX2xpbmVzKHN0cnVjdCBzdHJidWYgKm91dCwKCQkJY29uc3QgY2hhciAqcHJlZml4MSwKCQkJY29uc3QgY2hhciAqcHJlZml4MiwKCQkJY29uc3QgY2hhciAqYnVmLCBzaXplX3Qgc2l6ZSkKewoJd2hpbGUgKHNpemUpIHsKCQljb25zdCBjaGFyICpwcmVmaXg7CgkJY29uc3QgY2hhciAqbmV4dCA9IG1lbWNocihidWYsICdcbicsIHNpemUpOwoJCW5leHQgPSBuZXh0ID8gKG5leHQgKyAxKSA6IChidWYgKyBzaXplKTsKCgkJcHJlZml4ID0gKChwcmVmaXgyICYmIChidWZbMF0gPT0gJ1xuJyB8fCBidWZbMF0gPT0gJ1x0JykpCgkJCSAgPyBwcmVmaXgyIDogcHJlZml4MSk7CgkJc3RyYnVmX2FkZHN0cihvdXQsIHByZWZpeCk7CgkJc3RyYnVmX2FkZChvdXQsIGJ1ZiwgbmV4dCAtIGJ1Zik7CgkJc2l6ZSAtPSBuZXh0IC0gYnVmOwoJCWJ1ZiA9IG5leHQ7Cgl9CglzdHJidWZfY29tcGxldGVfbGluZShvdXQpOwp9Cgp2b2lkIHN0cmJ1Zl9hZGRfY29tbWVudGVkX2xpbmVzKHN0cnVjdCBzdHJidWYgKm91dCwgY29uc3QgY2hhciAqYnVmLCBzaXplX3Qgc2l6ZSkKewoJc3RhdGljIGNoYXIgcHJlZml4MVszXTsKCXN0YXRpYyBjaGFyIHByZWZpeDJbMl07CgoJaWYgKHByZWZpeDFbMF0gIT0gY29tbWVudF9saW5lX2NoYXIpIHsKCQl4c25wcmludGYocHJlZml4MSwgc2l6ZW9mKHByZWZpeDEpLCAiJWMgIiwgY29tbWVudF9saW5lX2NoYXIpOwoJCXhzbnByaW50ZihwcmVmaXgyLCBzaXplb2YocHJlZml4MiksICIlYyIsIGNvbW1lbnRfbGluZV9jaGFyKTsKCX0KCWFkZF9saW5lcyhvdXQsIHByZWZpeDEsIHByZWZpeDIsIGJ1Ziwgc2l6ZSk7Cn0KCnZvaWQgc3RyYnVmX2NvbW1lbnRlZF9hZGRmKHN0cnVjdCBzdHJidWYgKnNiLCBjb25zdCBjaGFyICpmbXQsIC4uLikKewoJdmFfbGlzdCBwYXJhbXM7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoJaW50IGluY29tcGxldGVfbGluZSA9IHNiLT5sZW4gJiYgc2ItPmJ1ZltzYi0+bGVuIC0gMV0gIT0gJ1xuJzsKCgl2YV9zdGFydChwYXJhbXMsIGZtdCk7CglzdHJidWZfdmFkZGYoJmJ1ZiwgZm10LCBwYXJhbXMpOwoJdmFfZW5kKHBhcmFtcyk7CgoJc3RyYnVmX2FkZF9jb21tZW50ZWRfbGluZXMoc2IsIGJ1Zi5idWYsIGJ1Zi5sZW4pOwoJaWYgKGluY29tcGxldGVfbGluZSkKCQlzYi0+YnVmWy0tc2ItPmxlbl0gPSAnXDAnOwoKCXN0cmJ1Zl9yZWxlYXNlKCZidWYpOwp9Cgp2b2lkIHN0cmJ1Zl92YWRkZihzdHJ1Y3Qgc3RyYnVmICpzYiwgY29uc3QgY2hhciAqZm10LCB2YV9saXN0IGFwKQp7CglpbnQgbGVuOwoJdmFfbGlzdCBjcDsKCglpZiAoIXN0cmJ1Zl9hdmFpbChzYikpCgkJc3RyYnVmX2dyb3coc2IsIDY0KTsKCXZhX2NvcHkoY3AsIGFwKTsKCWxlbiA9IHZzbnByaW50ZihzYi0+YnVmICsgc2ItPmxlbiwgc2ItPmFsbG9jIC0gc2ItPmxlbiwgZm10LCBjcCk7Cgl2YV9lbmQoY3ApOwoJaWYgKGxlbiA8IDApCgkJQlVHKCJ5b3VyIHZzbnByaW50ZiBpcyBicm9rZW4gKHJldHVybmVkICVkKSIsIGxlbik7CglpZiAobGVuID4gc3RyYnVmX2F2YWlsKHNiKSkgewoJCXN0cmJ1Zl9ncm93KHNiLCBsZW4pOwoJCWxlbiA9IHZzbnByaW50ZihzYi0+YnVmICsgc2ItPmxlbiwgc2ItPmFsbG9jIC0gc2ItPmxlbiwgZm10LCBhcCk7CgkJaWYgKGxlbiA+IHN0cmJ1Zl9hdmFpbChzYikpCgkJCUJVRygieW91ciB2c25wcmludGYgaXMgYnJva2VuIChpbnNhdGlhYmxlKSIpOwoJfQoJc3RyYnVmX3NldGxlbihzYiwgc2ItPmxlbiArIGxlbik7Cn0KCnZvaWQgc3RyYnVmX2V4cGFuZChzdHJ1Y3Qgc3RyYnVmICpzYiwgY29uc3QgY2hhciAqZm9ybWF0LCBleHBhbmRfZm5fdCBmbiwKCQkgICB2b2lkICpjb250ZXh0KQp7Cglmb3IgKDs7KSB7CgkJY29uc3QgY2hhciAqcGVyY2VudDsKCQlzaXplX3QgY29uc3VtZWQ7CgoJCXBlcmNlbnQgPSBzdHJjaHJudWwoZm9ybWF0LCAnJScpOwoJCXN0cmJ1Zl9hZGQoc2IsIGZvcm1hdCwgcGVyY2VudCAtIGZvcm1hdCk7CgkJaWYgKCEqcGVyY2VudCkKCQkJYnJlYWs7CgkJZm9ybWF0ID0gcGVyY2VudCArIDE7CgoJCWlmICgqZm9ybWF0ID09ICclJykgewoJCQlzdHJidWZfYWRkY2goc2IsICclJyk7CgkJCWZvcm1hdCsrOwoJCQljb250aW51ZTsKCQl9CgoJCWNvbnN1bWVkID0gZm4oc2IsIGZvcm1hdCwgY29udGV4dCk7CgkJaWYgKGNvbnN1bWVkKQoJCQlmb3JtYXQgKz0gY29uc3VtZWQ7CgkJZWxzZQoJCQlzdHJidWZfYWRkY2goc2IsICclJyk7Cgl9Cn0KCnNpemVfdCBzdHJidWZfZXhwYW5kX2xpdGVyYWxfY2Ioc3RydWN0IHN0cmJ1ZiAqc2IsCgkJCQljb25zdCBjaGFyICpwbGFjZWhvbGRlciwKCQkJCXZvaWQgKmNvbnRleHQpCnsKCWludCBjaDsKCglzd2l0Y2ggKHBsYWNlaG9sZGVyWzBdKSB7CgljYXNlICduJzoJCS8qIG5ld2xpbmUgKi8KCQlzdHJidWZfYWRkY2goc2IsICdcbicpOwoJCXJldHVybiAxOwoJY2FzZSAneCc6CgkJLyogJXgwMCA9PSBOVUwsICV4MGEgPT0gTEYsIGV0Yy4gKi8KCQljaCA9IGhleDJjaHIocGxhY2Vob2xkZXIgKyAxKTsKCQlpZiAoY2ggPCAwKQoJCQlyZXR1cm4gMDsKCQlzdHJidWZfYWRkY2goc2IsIGNoKTsKCQlyZXR1cm4gMzsKCX0KCXJldHVybiAwOwp9CgpzaXplX3Qgc3RyYnVmX2V4cGFuZF9kaWN0X2NiKHN0cnVjdCBzdHJidWYgKnNiLCBjb25zdCBjaGFyICpwbGFjZWhvbGRlciwKCQl2b2lkICpjb250ZXh0KQp7CglzdHJ1Y3Qgc3RyYnVmX2V4cGFuZF9kaWN0X2VudHJ5ICplID0gY29udGV4dDsKCXNpemVfdCBsZW47CgoJZm9yICg7IGUtPnBsYWNlaG9sZGVyICYmIChsZW4gPSBzdHJsZW4oZS0+cGxhY2Vob2xkZXIpKTsgZSsrKSB7CgkJaWYgKCFzdHJuY21wKHBsYWNlaG9sZGVyLCBlLT5wbGFjZWhvbGRlciwgbGVuKSkgewoJCQlpZiAoZS0+dmFsdWUpCgkJCQlzdHJidWZfYWRkc3RyKHNiLCBlLT52YWx1ZSk7CgkJCXJldHVybiBsZW47CgkJfQoJfQoJcmV0dXJuIDA7Cn0KCnZvaWQgc3RyYnVmX2FkZGJ1Zl9wZXJjZW50cXVvdGUoc3RydWN0IHN0cmJ1ZiAqZHN0LCBjb25zdCBzdHJ1Y3Qgc3RyYnVmICpzcmMpCnsKCXNpemVfdCBpLCBsZW4gPSBzcmMtPmxlbjsKCglmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHsKCQlpZiAoc3JjLT5idWZbaV0gPT0gJyUnKQoJCQlzdHJidWZfYWRkY2goZHN0LCAnJScpOwoJCXN0cmJ1Zl9hZGRjaChkc3QsIHNyYy0+YnVmW2ldKTsKCX0KfQoKI2RlZmluZSBVUkxfVU5TQUZFX0NIQVJTICIgPD5cIiV7fXxcXF5gOj8jW11AISQmJygpKissOz0iCgp2b2lkIHN0cmJ1Zl9hZGRfcGVyY2VudGVuY29kZShzdHJ1Y3Qgc3RyYnVmICpkc3QsIGNvbnN0IGNoYXIgKnNyYywgaW50IGZsYWdzKQp7CglzaXplX3QgaSwgbGVuID0gc3RybGVuKHNyYyk7CgoJZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7CgkJdW5zaWduZWQgY2hhciBjaCA9IHNyY1tpXTsKCQlpZiAoY2ggPD0gMHgxRiB8fCBjaCA+PSAweDdGIHx8CgkJICAgIChjaCA9PSAnLycgJiYgKGZsYWdzICYgU1RSQlVGX0VOQ09ERV9TTEFTSCkpIHx8CgkJICAgIHN0cmNocihVUkxfVU5TQUZFX0NIQVJTLCBjaCkpCgkJCXN0cmJ1Zl9hZGRmKGRzdCwgIiUlJTAyWCIsICh1bnNpZ25lZCBjaGFyKWNoKTsKCQllbHNlCgkJCXN0cmJ1Zl9hZGRjaChkc3QsIGNoKTsKCX0KfQoKc2l6ZV90IHN0cmJ1Zl9mcmVhZChzdHJ1Y3Qgc3RyYnVmICpzYiwgc2l6ZV90IHNpemUsIEZJTEUgKmYpCnsKCXNpemVfdCByZXM7CglzaXplX3Qgb2xkYWxsb2MgPSBzYi0+YWxsb2M7CgoJc3RyYnVmX2dyb3coc2IsIHNpemUpOwoJcmVzID0gZnJlYWQoc2ItPmJ1ZiArIHNiLT5sZW4sIDEsIHNpemUsIGYpOwoJaWYgKHJlcyA+IDApCgkJc3RyYnVmX3NldGxlbihzYiwgc2ItPmxlbiArIHJlcyk7CgllbHNlIGlmIChvbGRhbGxvYyA9PSAwKQoJCXN0cmJ1Zl9yZWxlYXNlKHNiKTsKCXJldHVybiByZXM7Cn0KCnNzaXplX3Qgc3RyYnVmX3JlYWQoc3RydWN0IHN0cmJ1ZiAqc2IsIGludCBmZCwgc2l6ZV90IGhpbnQpCnsKCXNpemVfdCBvbGRsZW4gPSBzYi0+bGVuOwoJc2l6ZV90IG9sZGFsbG9jID0gc2ItPmFsbG9jOwoKCXN0cmJ1Zl9ncm93KHNiLCBoaW50ID8gaGludCA6IDgxOTIpOwoJZm9yICg7OykgewoJCXNzaXplX3Qgd2FudCA9IHNiLT5hbGxvYyAtIHNiLT5sZW4gLSAxOwoJCXNzaXplX3QgZ290ID0gcmVhZF9pbl9mdWxsKGZkLCBzYi0+YnVmICsgc2ItPmxlbiwgd2FudCk7CgoJCWlmIChnb3QgPCAwKSB7CgkJCWlmIChvbGRhbGxvYyA9PSAwKQoJCQkJc3RyYnVmX3JlbGVhc2Uoc2IpOwoJCQllbHNlCgkJCQlzdHJidWZfc2V0bGVuKHNiLCBvbGRsZW4pOwoJCQlyZXR1cm4gLTE7CgkJfQoJCXNiLT5sZW4gKz0gZ290OwoJCWlmIChnb3QgPCB3YW50KQoJCQlicmVhazsKCQlzdHJidWZfZ3JvdyhzYiwgODE5Mik7Cgl9CgoJc2ItPmJ1ZltzYi0+bGVuXSA9ICdcMCc7CglyZXR1cm4gc2ItPmxlbiAtIG9sZGxlbjsKfQoKc3NpemVfdCBzdHJidWZfcmVhZF9vbmNlKHN0cnVjdCBzdHJidWYgKnNiLCBpbnQgZmQsIHNpemVfdCBoaW50KQp7CglzaXplX3Qgb2xkYWxsb2MgPSBzYi0+YWxsb2M7Cglzc2l6ZV90IGNudDsKCglzdHJidWZfZ3JvdyhzYiwgaGludCA/IGhpbnQgOiA4MTkyKTsKCWNudCA9IHhyZWFkKGZkLCBzYi0+YnVmICsgc2ItPmxlbiwgc2ItPmFsbG9jIC0gc2ItPmxlbiAtIDEpOwoJaWYgKGNudCA+IDApCgkJc3RyYnVmX3NldGxlbihzYiwgc2ItPmxlbiArIGNudCk7CgllbHNlIGlmIChvbGRhbGxvYyA9PSAwKQoJCXN0cmJ1Zl9yZWxlYXNlKHNiKTsKCXJldHVybiBjbnQ7Cn0KCnNzaXplX3Qgc3RyYnVmX3dyaXRlKHN0cnVjdCBzdHJidWYgKnNiLCBGSUxFICpmKQp7CglyZXR1cm4gc2ItPmxlbiA/IGZ3cml0ZShzYi0+YnVmLCAxLCBzYi0+bGVuLCBmKSA6IDA7Cn0KCiNkZWZpbmUgU1RSQlVGX01BWExJTksgKDIqUEFUSF9NQVgpCgppbnQgc3RyYnVmX3JlYWRsaW5rKHN0cnVjdCBzdHJidWYgKnNiLCBjb25zdCBjaGFyICpwYXRoLCBzaXplX3QgaGludCkKewoJc2l6ZV90IG9sZGFsbG9jID0gc2ItPmFsbG9jOwoKCWlmIChoaW50IDwgMzIpCgkJaGludCA9IDMyOwoKCXdoaWxlIChoaW50IDwgU1RSQlVGX01BWExJTkspIHsKCQlzc2l6ZV90IGxlbjsKCgkJc3RyYnVmX2dyb3coc2IsIGhpbnQpOwoJCWxlbiA9IHJlYWRsaW5rKHBhdGgsIHNiLT5idWYsIGhpbnQpOwoJCWlmIChsZW4gPCAwKSB7CgkJCWlmIChlcnJubyAhPSBFUkFOR0UpCgkJCQlicmVhazsKCQl9IGVsc2UgaWYgKGxlbiA8IGhpbnQpIHsKCQkJc3RyYnVmX3NldGxlbihzYiwgbGVuKTsKCQkJcmV0dXJuIDA7CgkJfQoKCQkvKiAuLiB0aGUgYnVmZmVyIHdhcyB0b28gc21hbGwgLSB0cnkgYWdhaW4gKi8KCQloaW50ICo9IDI7Cgl9CglpZiAob2xkYWxsb2MgPT0gMCkKCQlzdHJidWZfcmVsZWFzZShzYik7CglyZXR1cm4gLTE7Cn0KCmludCBzdHJidWZfZ2V0Y3dkKHN0cnVjdCBzdHJidWYgKnNiKQp7CglzaXplX3Qgb2xkYWxsb2MgPSBzYi0+YWxsb2M7CglzaXplX3QgZ3Vlc3NlZF9sZW4gPSAxMjg7CgoJZm9yICg7OyBndWVzc2VkX2xlbiAqPSAyKSB7CgkJc3RyYnVmX2dyb3coc2IsIGd1ZXNzZWRfbGVuKTsKCQlpZiAoZ2V0Y3dkKHNiLT5idWYsIHNiLT5hbGxvYykpIHsKCQkJc3RyYnVmX3NldGxlbihzYiwgc3RybGVuKHNiLT5idWYpKTsKCQkJcmV0dXJuIDA7CgkJfQoKCQkvKgoJCSAqIElmIGdldGN3ZCgzKSBpcyBpbXBsZW1lbnRlZCBhcyBhIHN5c2NhbGwgdGhhdCBmYWxscwoJCSAqIGJhY2sgdG8gYSByZWd1bGFyIGxvb2t1cCB1c2luZyByZWFkZGlyKDMpIGV0Yy4gdGhlbgoJCSAqIHdlIG1heSBiZSBhYmxlIHRvIGF2b2lkIEVBQ0NFUyBieSBwcm92aWRpbmcgZW5vdWdoCgkJICogc3BhY2UgdG8gdGhlIHN5c2NhbGwgYXMgaXQncyBub3QgbmVjZXNzYXJpbHkgYm91bmQKCQkgKiB0byB0aGUgc2FtZSByZXN0cmljdGlvbnMgYXMgdGhlIGZhbGxiYWNrLgoJCSAqLwoJCWlmIChlcnJubyA9PSBFQUNDRVMgJiYgZ3Vlc3NlZF9sZW4gPCBQQVRIX01BWCkKCQkJY29udGludWU7CgoJCWlmIChlcnJubyAhPSBFUkFOR0UpCgkJCWJyZWFrOwoJfQoJaWYgKG9sZGFsbG9jID09IDApCgkJc3RyYnVmX3JlbGVhc2Uoc2IpOwoJZWxzZQoJCXN0cmJ1Zl9yZXNldChzYik7CglyZXR1cm4gLTE7Cn0KCiNpZmRlZiBIQVZFX0dFVERFTElNCmludCBzdHJidWZfZ2V0d2hvbGVsaW5lKHN0cnVjdCBzdHJidWYgKnNiLCBGSUxFICpmcCwgaW50IHRlcm0pCnsKCXNzaXplX3QgcjsKCglpZiAoZmVvZihmcCkpCgkJcmV0dXJuIEVPRjsKCglzdHJidWZfcmVzZXQoc2IpOwoKCS8qIFRyYW5zbGF0ZSBzbG9wYnVmIHRvIE5VTEwsIGFzIHdlIGNhbm5vdCBjYWxsIHJlYWxsb2Mgb24gaXQgKi8KCWlmICghc2ItPmFsbG9jKQoJCXNiLT5idWYgPSBOVUxMOwoJZXJybm8gPSAwOwoJciA9IGdldGRlbGltKCZzYi0+YnVmLCAmc2ItPmFsbG9jLCB0ZXJtLCBmcCk7CgoJaWYgKHIgPiAwKSB7CgkJc2ItPmxlbiA9IHI7CgkJcmV0dXJuIDA7Cgl9Cglhc3NlcnQociA9PSAtMSk7CgoJLyoKCSAqIE5vcm1hbGx5IHdlIHdvdWxkIGhhdmUgY2FsbGVkIHhyZWFsbG9jLCB3aGljaCB3aWxsIHRyeSB0byBmcmVlCgkgKiBtZW1vcnkgYW5kIHJlY292ZXIuIEJ1dCB3ZSBoYXZlIG5vIHdheSB0byB0ZWxsIGdldGRlbGltKCkgdG8gZG8gc28uCgkgKiBXb3JzZSwgd2UgY2Fubm90IHRyeSB0byByZWNvdmVyIEVOT01FTSBvdXJzZWx2ZXMsIGJlY2F1c2Ugd2UgaGF2ZQoJICogbm8gaWRlYSBob3cgbWFueSBieXRlcyB3ZXJlIHJlYWQgYnkgZ2V0ZGVsaW0uCgkgKgoJICogRHlpbmcgaGVyZSBpcyByZWFzb25hYmxlLiBJdCBtaXJyb3JzIHdoYXQgeHJlYWxsb2Mgd291bGQgZG8gb24KCSAqIGNhdGFzdHJvcGhpYyBtZW1vcnkgZmFpbHVyZS4gV2Ugc2tpcCB0aGUgb3Bwb3J0dW5pdHkgdG8gZnJlZSBwYWNrCgkgKiBtZW1vcnkgYW5kIHJldHJ5LCBidXQgdGhhdCdzIHVubGlrZWx5IHRvIGhlbHAgZm9yIGEgbWFsbG9jIHNtYWxsCgkgKiBlbm91Z2ggdG8gaG9sZCBhIHNpbmdsZSBsaW5lIG9mIGlucHV0LCBhbnl3YXkuCgkgKi8KCWlmIChlcnJubyA9PSBFTk9NRU0pCgkJZGllKCJPdXQgb2YgbWVtb3J5LCBnZXRkZWxpbSBmYWlsZWQiKTsKCgkvKgoJICogUmVzdG9yZSBzdHJidWYgaW52YXJpYW50czsgaWYgZ2V0ZGVsaW0gbGVmdCB1cyB3aXRoIGEgTlVMTCBwb2ludGVyLAoJICogd2UgY2FuIGp1c3QgcmUtaW5pdCwgYnV0IG90aGVyd2lzZSB3ZSBzaG91bGQgbWFrZSBzdXJlIHRoYXQgb3VyCgkgKiBsZW5ndGggaXMgZW1wdHksIGFuZCB0aGF0IHRoZSByZXN1bHQgaXMgTlVMLXRlcm1pbmF0ZWQuCgkgKi8KCWlmICghc2ItPmJ1ZikKCQlzdHJidWZfaW5pdChzYiwgMCk7CgllbHNlCgkJc3RyYnVmX3Jlc2V0KHNiKTsKCXJldHVybiBFT0Y7Cn0KI2Vsc2UKaW50IHN0cmJ1Zl9nZXR3aG9sZWxpbmUoc3RydWN0IHN0cmJ1ZiAqc2IsIEZJTEUgKmZwLCBpbnQgdGVybSkKewoJaW50IGNoOwoKCWlmIChmZW9mKGZwKSkKCQlyZXR1cm4gRU9GOwoKCXN0cmJ1Zl9yZXNldChzYik7CglmbG9ja2ZpbGUoZnApOwoJd2hpbGUgKChjaCA9IGdldGNfdW5sb2NrZWQoZnApKSAhPSBFT0YpIHsKCQlpZiAoIXN0cmJ1Zl9hdmFpbChzYikpCgkJCXN0cmJ1Zl9ncm93KHNiLCAxKTsKCQlzYi0+YnVmW3NiLT5sZW4rK10gPSBjaDsKCQlpZiAoY2ggPT0gdGVybSkKCQkJYnJlYWs7Cgl9CglmdW5sb2NrZmlsZShmcCk7CglpZiAoY2ggPT0gRU9GICYmIHNiLT5sZW4gPT0gMCkKCQlyZXR1cm4gRU9GOwoKCXNiLT5idWZbc2ItPmxlbl0gPSAnXDAnOwoJcmV0dXJuIDA7Cn0KI2VuZGlmCgppbnQgc3RyYnVmX2FwcGVuZHdob2xlbGluZShzdHJ1Y3Qgc3RyYnVmICpzYiwgRklMRSAqZnAsIGludCB0ZXJtKQp7CglzdHJ1Y3Qgc3RyYnVmIGxpbmUgPSBTVFJCVUZfSU5JVDsKCWlmIChzdHJidWZfZ2V0d2hvbGVsaW5lKCZsaW5lLCBmcCwgdGVybSkpCgkJcmV0dXJuIEVPRjsKCXN0cmJ1Zl9hZGRidWYoc2IsICZsaW5lKTsKCXN0cmJ1Zl9yZWxlYXNlKCZsaW5lKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IHN0cmJ1Zl9nZXRkZWxpbShzdHJ1Y3Qgc3RyYnVmICpzYiwgRklMRSAqZnAsIGludCB0ZXJtKQp7CglpZiAoc3RyYnVmX2dldHdob2xlbGluZShzYiwgZnAsIHRlcm0pKQoJCXJldHVybiBFT0Y7CglpZiAoc2ItPmJ1ZltzYi0+bGVuIC0gMV0gPT0gdGVybSkKCQlzdHJidWZfc2V0bGVuKHNiLCBzYi0+bGVuIC0gMSk7CglyZXR1cm4gMDsKfQoKaW50IHN0cmJ1Zl9nZXRsaW5lKHN0cnVjdCBzdHJidWYgKnNiLCBGSUxFICpmcCkKewoJaWYgKHN0cmJ1Zl9nZXR3aG9sZWxpbmUoc2IsIGZwLCAnXG4nKSkKCQlyZXR1cm4gRU9GOwoJaWYgKHNiLT5idWZbc2ItPmxlbiAtIDFdID09ICdcbicpIHsKCQlzdHJidWZfc2V0bGVuKHNiLCBzYi0+bGVuIC0gMSk7CgkJaWYgKHNiLT5sZW4gJiYgc2ItPmJ1ZltzYi0+bGVuIC0gMV0gPT0gJ1xyJykKCQkJc3RyYnVmX3NldGxlbihzYiwgc2ItPmxlbiAtIDEpOwoJfQoJcmV0dXJuIDA7Cn0KCmludCBzdHJidWZfZ2V0bGluZV9sZihzdHJ1Y3Qgc3RyYnVmICpzYiwgRklMRSAqZnApCnsKCXJldHVybiBzdHJidWZfZ2V0ZGVsaW0oc2IsIGZwLCAnXG4nKTsKfQoKaW50IHN0cmJ1Zl9nZXRsaW5lX251bChzdHJ1Y3Qgc3RyYnVmICpzYiwgRklMRSAqZnApCnsKCXJldHVybiBzdHJidWZfZ2V0ZGVsaW0oc2IsIGZwLCAnXDAnKTsKfQoKaW50IHN0cmJ1Zl9nZXR3aG9sZWxpbmVfZmQoc3RydWN0IHN0cmJ1ZiAqc2IsIGludCBmZCwgaW50IHRlcm0pCnsKCXN0cmJ1Zl9yZXNldChzYik7CgoJd2hpbGUgKDEpIHsKCQljaGFyIGNoOwoJCXNzaXplX3QgbGVuID0geHJlYWQoZmQsICZjaCwgMSk7CgkJaWYgKGxlbiA8PSAwKQoJCQlyZXR1cm4gRU9GOwoJCXN0cmJ1Zl9hZGRjaChzYiwgY2gpOwoJCWlmIChjaCA9PSB0ZXJtKQoJCQlicmVhazsKCX0KCXJldHVybiAwOwp9Cgpzc2l6ZV90IHN0cmJ1Zl9yZWFkX2ZpbGUoc3RydWN0IHN0cmJ1ZiAqc2IsIGNvbnN0IGNoYXIgKnBhdGgsIHNpemVfdCBoaW50KQp7CglpbnQgZmQ7Cglzc2l6ZV90IGxlbjsKCWludCBzYXZlZF9lcnJubzsKCglmZCA9IG9wZW4ocGF0aCwgT19SRE9OTFkpOwoJaWYgKGZkIDwgMCkKCQlyZXR1cm4gLTE7CglsZW4gPSBzdHJidWZfcmVhZChzYiwgZmQsIGhpbnQpOwoJc2F2ZWRfZXJybm8gPSBlcnJubzsKCWNsb3NlKGZkKTsKCWlmIChsZW4gPCAwKSB7CgkJZXJybm8gPSBzYXZlZF9lcnJubzsKCQlyZXR1cm4gLTE7Cgl9CgoJcmV0dXJuIGxlbjsKfQoKdm9pZCBzdHJidWZfYWRkX2xpbmVzKHN0cnVjdCBzdHJidWYgKm91dCwgY29uc3QgY2hhciAqcHJlZml4LAoJCSAgICAgIGNvbnN0IGNoYXIgKmJ1Ziwgc2l6ZV90IHNpemUpCnsKCWFkZF9saW5lcyhvdXQsIHByZWZpeCwgTlVMTCwgYnVmLCBzaXplKTsKfQoKdm9pZCBzdHJidWZfYWRkc3RyX3htbF9xdW90ZWQoc3RydWN0IHN0cmJ1ZiAqYnVmLCBjb25zdCBjaGFyICpzKQp7Cgl3aGlsZSAoKnMpIHsKCQlzaXplX3QgbGVuID0gc3RyY3NwbihzLCAiXCI8PiYiKTsKCQlzdHJidWZfYWRkKGJ1ZiwgcywgbGVuKTsKCQlzICs9IGxlbjsKCQlzd2l0Y2ggKCpzKSB7CgkJY2FzZSAnIic6CgkJCXN0cmJ1Zl9hZGRzdHIoYnVmLCAiJnF1b3Q7Iik7CgkJCWJyZWFrOwoJCWNhc2UgJzwnOgoJCQlzdHJidWZfYWRkc3RyKGJ1ZiwgIiZsdDsiKTsKCQkJYnJlYWs7CgkJY2FzZSAnPic6CgkJCXN0cmJ1Zl9hZGRzdHIoYnVmLCAiJmd0OyIpOwoJCQlicmVhazsKCQljYXNlICcmJzoKCQkJc3RyYnVmX2FkZHN0cihidWYsICImYW1wOyIpOwoJCQlicmVhazsKCQljYXNlIDA6CgkJCXJldHVybjsKCQl9CgkJcysrOwoJfQp9CgppbnQgaXNfcmZjMzk4Nl9yZXNlcnZlZF9vcl91bnJlc2VydmVkKGNoYXIgY2gpCnsKCWlmIChpc19yZmMzOTg2X3VucmVzZXJ2ZWQoY2gpKQoJCXJldHVybiAxOwoJc3dpdGNoIChjaCkgewoJCWNhc2UgJyEnOiBjYXNlICcqJzogY2FzZSAnXCcnOiBjYXNlICcoJzogY2FzZSAnKSc6IGNhc2UgJzsnOgoJCWNhc2UgJzonOiBjYXNlICdAJzogY2FzZSAnJic6IGNhc2UgJz0nOiBjYXNlICcrJzogY2FzZSAnJCc6CgkJY2FzZSAnLCc6IGNhc2UgJy8nOiBjYXNlICc/JzogY2FzZSAnIyc6IGNhc2UgJ1snOiBjYXNlICddJzoKCQkJcmV0dXJuIDE7Cgl9CglyZXR1cm4gMDsKfQoKaW50IGlzX3JmYzM5ODZfdW5yZXNlcnZlZChjaGFyIGNoKQp7CglyZXR1cm4gaXNhbG51bShjaCkgfHwKCQljaCA9PSAnLScgfHwgY2ggPT0gJ18nIHx8IGNoID09ICcuJyB8fCBjaCA9PSAnfic7Cn0KCnN0YXRpYyB2b2lkIHN0cmJ1Zl9hZGRfdXJsZW5jb2RlKHN0cnVjdCBzdHJidWYgKnNiLCBjb25zdCBjaGFyICpzLCBzaXplX3QgbGVuLAoJCQkJIGNoYXJfcHJlZGljYXRlIGFsbG93X3VuZW5jb2RlZF9mbikKewoJc3RyYnVmX2dyb3coc2IsIGxlbik7Cgl3aGlsZSAobGVuLS0pIHsKCQljaGFyIGNoID0gKnMrKzsKCQlpZiAoYWxsb3dfdW5lbmNvZGVkX2ZuKGNoKSkKCQkJc3RyYnVmX2FkZGNoKHNiLCBjaCk7CgkJZWxzZQoJCQlzdHJidWZfYWRkZihzYiwgIiUlJTAyeCIsICh1bnNpZ25lZCBjaGFyKWNoKTsKCX0KfQoKdm9pZCBzdHJidWZfYWRkc3RyX3VybGVuY29kZShzdHJ1Y3Qgc3RyYnVmICpzYiwgY29uc3QgY2hhciAqcywKCQkJICAgICBjaGFyX3ByZWRpY2F0ZSBhbGxvd191bmVuY29kZWRfZm4pCnsKCXN0cmJ1Zl9hZGRfdXJsZW5jb2RlKHNiLCBzLCBzdHJsZW4ocyksIGFsbG93X3VuZW5jb2RlZF9mbik7Cn0KCnN0YXRpYyB2b2lkIHN0cmJ1Zl9odW1hbmlzZShzdHJ1Y3Qgc3RyYnVmICpidWYsIG9mZl90IGJ5dGVzLAoJCQkJIGludCBodW1hbmlzZV9yYXRlKQp7CglpZiAoYnl0ZXMgPiAxIDw8IDMwKSB7CgkJc3RyYnVmX2FkZGYoYnVmLAoJCQkJaHVtYW5pc2VfcmF0ZSA9PSAwID8KCQkJCQkvKiBUUkFOU0xBVE9SUzogSUVDIDgwMDAwLTEzOjIwMDggZ2liaWJ5dGUgKi8KCQkJCQlfKCIldS4lMi4ydSBHaUIiKSA6CgkJCQkJLyogVFJBTlNMQVRPUlM6IElFQyA4MDAwMC0xMzoyMDA4IGdpYmlieXRlL3NlY29uZCAqLwoJCQkJCV8oIiV1LiUyLjJ1IEdpQi9zIiksCgkJCSAgICAodW5zaWduZWQpKGJ5dGVzID4+IDMwKSwKCQkJICAgICh1bnNpZ25lZCkoYnl0ZXMgJiAoKDEgPDwgMzApIC0gMSkpIC8gMTA3Mzc0MTkpOwoJfSBlbHNlIGlmIChieXRlcyA+IDEgPDwgMjApIHsKCQl1bnNpZ25lZCB4ID0gYnl0ZXMgKyA1MjQzOyAgLyogZm9yIHJvdW5kaW5nICovCgkJc3RyYnVmX2FkZGYoYnVmLAoJCQkJaHVtYW5pc2VfcmF0ZSA9PSAwID8KCQkJCQkvKiBUUkFOU0xBVE9SUzogSUVDIDgwMDAwLTEzOjIwMDggbWViaWJ5dGUgKi8KCQkJCQlfKCIldS4lMi4ydSBNaUIiKSA6CgkJCQkJLyogVFJBTlNMQVRPUlM6IElFQyA4MDAwMC0xMzoyMDA4IG1lYmlieXRlL3NlY29uZCAqLwoJCQkJCV8oIiV1LiUyLjJ1IE1pQi9zIiksCgkJCSAgICB4ID4+IDIwLCAoKHggJiAoKDEgPDwgMjApIC0gMSkpICogMTAwKSA+PiAyMCk7Cgl9IGVsc2UgaWYgKGJ5dGVzID4gMSA8PCAxMCkgewoJCXVuc2lnbmVkIHggPSBieXRlcyArIDU7ICAvKiBmb3Igcm91bmRpbmcgKi8KCQlzdHJidWZfYWRkZihidWYsCgkJCQlodW1hbmlzZV9yYXRlID09IDAgPwoJCQkJCS8qIFRSQU5TTEFUT1JTOiBJRUMgODAwMDAtMTM6MjAwOCBraWJpYnl0ZSAqLwoJCQkJCV8oIiV1LiUyLjJ1IEtpQiIpIDoKCQkJCQkvKiBUUkFOU0xBVE9SUzogSUVDIDgwMDAwLTEzOjIwMDgga2liaWJ5dGUvc2Vjb25kICovCgkJCQkJXygiJXUuJTIuMnUgS2lCL3MiKSwKCQkJICAgIHggPj4gMTAsICgoeCAmICgoMSA8PCAxMCkgLSAxKSkgKiAxMDApID4+IDEwKTsKCX0gZWxzZSB7CgkJc3RyYnVmX2FkZGYoYnVmLAoJCQkJaHVtYW5pc2VfcmF0ZSA9PSAwID8KCQkJCQkvKiBUUkFOU0xBVE9SUzogSUVDIDgwMDAwLTEzOjIwMDggYnl0ZSAqLwoJCQkJCVFfKCIldSBieXRlIiwgIiV1IGJ5dGVzIiwgKHVuc2lnbmVkKWJ5dGVzKSA6CgkJCQkJLyogVFJBTlNMQVRPUlM6IElFQyA4MDAwMC0xMzoyMDA4IGJ5dGUvc2Vjb25kICovCgkJCQkJUV8oIiV1IGJ5dGUvcyIsICIldSBieXRlcy9zIiwgKHVuc2lnbmVkKWJ5dGVzKSwKCQkJCSh1bnNpZ25lZClieXRlcyk7Cgl9Cn0KCnZvaWQgc3RyYnVmX2h1bWFuaXNlX2J5dGVzKHN0cnVjdCBzdHJidWYgKmJ1Ziwgb2ZmX3QgYnl0ZXMpCnsKCXN0cmJ1Zl9odW1hbmlzZShidWYsIGJ5dGVzLCAwKTsKfQoKdm9pZCBzdHJidWZfaHVtYW5pc2VfcmF0ZShzdHJ1Y3Qgc3RyYnVmICpidWYsIG9mZl90IGJ5dGVzKQp7CglzdHJidWZfaHVtYW5pc2UoYnVmLCBieXRlcywgMSk7Cn0KCnZvaWQgc3RyYnVmX2FkZF9hYnNvbHV0ZV9wYXRoKHN0cnVjdCBzdHJidWYgKnNiLCBjb25zdCBjaGFyICpwYXRoKQp7CglpZiAoISpwYXRoKQoJCWRpZSgiVGhlIGVtcHR5IHN0cmluZyBpcyBub3QgYSB2YWxpZCBwYXRoIik7CglpZiAoIWlzX2Fic29sdXRlX3BhdGgocGF0aCkpIHsKCQlzdHJ1Y3Qgc3RhdCBjd2Rfc3RhdCwgcHdkX3N0YXQ7CgkJc2l6ZV90IG9yaWdfbGVuID0gc2ItPmxlbjsKCQljaGFyICpjd2QgPSB4Z2V0Y3dkKCk7CgkJY2hhciAqcHdkID0gZ2V0ZW52KCJQV0QiKTsKCQlpZiAocHdkICYmIHN0cmNtcChwd2QsIGN3ZCkgJiYKCQkgICAgIXN0YXQoY3dkLCAmY3dkX3N0YXQpICYmCgkJICAgIChjd2Rfc3RhdC5zdF9kZXYgfHwgY3dkX3N0YXQuc3RfaW5vKSAmJgoJCSAgICAhc3RhdChwd2QsICZwd2Rfc3RhdCkgJiYKCQkgICAgcHdkX3N0YXQuc3RfZGV2ID09IGN3ZF9zdGF0LnN0X2RldiAmJgoJCSAgICBwd2Rfc3RhdC5zdF9pbm8gPT0gY3dkX3N0YXQuc3RfaW5vKQoJCQlzdHJidWZfYWRkc3RyKHNiLCBwd2QpOwoJCWVsc2UKCQkJc3RyYnVmX2FkZHN0cihzYiwgY3dkKTsKCQlpZiAoc2ItPmxlbiA+IG9yaWdfbGVuICYmICFpc19kaXJfc2VwKHNiLT5idWZbc2ItPmxlbiAtIDFdKSkKCQkJc3RyYnVmX2FkZGNoKHNiLCAnLycpOwoJCWZyZWUoY3dkKTsKCX0KCXN0cmJ1Zl9hZGRzdHIoc2IsIHBhdGgpOwp9Cgp2b2lkIHN0cmJ1Zl9hZGRfcmVhbF9wYXRoKHN0cnVjdCBzdHJidWYgKnNiLCBjb25zdCBjaGFyICpwYXRoKQp7CglpZiAoc2ItPmxlbikgewoJCXN0cnVjdCBzdHJidWYgcmVzb2x2ZWQgPSBTVFJCVUZfSU5JVDsKCQlzdHJidWZfcmVhbHBhdGgoJnJlc29sdmVkLCBwYXRoLCAxKTsKCQlzdHJidWZfYWRkYnVmKHNiLCAmcmVzb2x2ZWQpOwoJCXN0cmJ1Zl9yZWxlYXNlKCZyZXNvbHZlZCk7Cgl9IGVsc2UKCQlzdHJidWZfcmVhbHBhdGgoc2IsIHBhdGgsIDEpOwp9CgppbnQgcHJpbnRmX2xuKGNvbnN0IGNoYXIgKmZtdCwgLi4uKQp7CglpbnQgcmV0OwoJdmFfbGlzdCBhcDsKCXZhX3N0YXJ0KGFwLCBmbXQpOwoJcmV0ID0gdnByaW50ZihmbXQsIGFwKTsKCXZhX2VuZChhcCk7CglpZiAocmV0IDwgMCB8fCBwdXRjaGFyKCdcbicpID09IEVPRikKCQlyZXR1cm4gLTE7CglyZXR1cm4gcmV0ICsgMTsKfQoKaW50IGZwcmludGZfbG4oRklMRSAqZnAsIGNvbnN0IGNoYXIgKmZtdCwgLi4uKQp7CglpbnQgcmV0OwoJdmFfbGlzdCBhcDsKCXZhX3N0YXJ0KGFwLCBmbXQpOwoJcmV0ID0gdmZwcmludGYoZnAsIGZtdCwgYXApOwoJdmFfZW5kKGFwKTsKCWlmIChyZXQgPCAwIHx8IHB1dGMoJ1xuJywgZnApID09IEVPRikKCQlyZXR1cm4gLTE7CglyZXR1cm4gcmV0ICsgMTsKfQoKY2hhciAqeHN0cmR1cF90b2xvd2VyKGNvbnN0IGNoYXIgKnN0cmluZykKewoJY2hhciAqcmVzdWx0OwoJc2l6ZV90IGxlbiwgaTsKCglsZW4gPSBzdHJsZW4oc3RyaW5nKTsKCXJlc3VsdCA9IHhtYWxsb2N6KGxlbik7Cglmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspCgkJcmVzdWx0W2ldID0gdG9sb3dlcihzdHJpbmdbaV0pOwoJcmV0dXJuIHJlc3VsdDsKfQoKY2hhciAqeHN0cmR1cF90b3VwcGVyKGNvbnN0IGNoYXIgKnN0cmluZykKewoJY2hhciAqcmVzdWx0OwoJc2l6ZV90IGxlbiwgaTsKCglsZW4gPSBzdHJsZW4oc3RyaW5nKTsKCXJlc3VsdCA9IHhtYWxsb2N6KGxlbik7Cglmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspCgkJcmVzdWx0W2ldID0gdG91cHBlcihzdHJpbmdbaV0pOwoJcmV0dXJuIHJlc3VsdDsKfQoKY2hhciAqeHN0cnZmbXQoY29uc3QgY2hhciAqZm10LCB2YV9saXN0IGFwKQp7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoJc3RyYnVmX3ZhZGRmKCZidWYsIGZtdCwgYXApOwoJcmV0dXJuIHN0cmJ1Zl9kZXRhY2goJmJ1ZiwgTlVMTCk7Cn0KCmNoYXIgKnhzdHJmbXQoY29uc3QgY2hhciAqZm10LCAuLi4pCnsKCXZhX2xpc3QgYXA7CgljaGFyICpyZXQ7CgoJdmFfc3RhcnQoYXAsIGZtdCk7CglyZXQgPSB4c3RydmZtdChmbXQsIGFwKTsKCXZhX2VuZChhcCk7CgoJcmV0dXJuIHJldDsKfQoKdm9pZCBzdHJidWZfYWRkZnRpbWUoc3RydWN0IHN0cmJ1ZiAqc2IsIGNvbnN0IGNoYXIgKmZtdCwgY29uc3Qgc3RydWN0IHRtICp0bSwKCQkgICAgIGludCB0el9vZmZzZXQsIGludCBzdXBwcmVzc190el9uYW1lKQp7CglzdHJ1Y3Qgc3RyYnVmIG11bmdlZF9mbXQgPSBTVFJCVUZfSU5JVDsKCXNpemVfdCBoaW50ID0gMTI4OwoJc2l6ZV90IGxlbjsKCglpZiAoISpmbXQpCgkJcmV0dXJuOwoKCS8qCgkgKiBUaGVyZSBpcyBubyBwb3J0YWJsZSB3YXkgdG8gcGFzcyB0aW1lem9uZSBpbmZvcm1hdGlvbiB0bwoJICogc3RyZnRpbWUsIHNvIHdlIGhhbmRsZSAleiBhbmQgJVogaGVyZS4gTGlrZXdpc2UgJyVzJywgYmVjYXVzZQoJICogZ29pbmcgYmFjayB0byBhbiBlcG9jaCB0aW1lIHJlcXVpcmVzIGtub3dpbmcgdGhlIHpvbmUuCgkgKgoJICogTm90ZSB0aGF0IHR6X29mZnNldCBpcyBpbiB0aGUgIlstK11ISE1NIiBkZWNpbWFsIGZvcm07IHRoaXMgaXMgd2hhdAoJICogd2Ugd2FudCBmb3IgJXosIGJ1dCB0aGUgY29tcHV0YXRpb24gZm9yICVzIGhhcyB0byBjb252ZXJ0IHRvIG51bWJlcgoJICogb2Ygc2Vjb25kcy4KCSAqLwoJZm9yICg7OykgewoJCWNvbnN0IGNoYXIgKnBlcmNlbnQgPSBzdHJjaHJudWwoZm10LCAnJScpOwoJCXN0cmJ1Zl9hZGQoJm11bmdlZF9mbXQsIGZtdCwgcGVyY2VudCAtIGZtdCk7CgkJaWYgKCEqcGVyY2VudCkKCQkJYnJlYWs7CgkJZm10ID0gcGVyY2VudCArIDE7CgkJc3dpdGNoICgqZm10KSB7CgkJY2FzZSAnJSc6CgkJCXN0cmJ1Zl9hZGRzdHIoJm11bmdlZF9mbXQsICIlJSIpOwoJCQlmbXQrKzsKCQkJYnJlYWs7CgkJY2FzZSAncyc6CgkJCXN0cmJ1Zl9hZGRmKCZtdW5nZWRfZm10LCAiJSJQUkl0aW1lLAoJCQkJICAgICh0aW1lc3RhbXBfdCl0bV90b190aW1lX3QodG0pIC0KCQkJCSAgICAzNjAwICogKHR6X29mZnNldCAvIDEwMCkgLQoJCQkJICAgIDYwICogKHR6X29mZnNldCAlIDEwMCkpOwoJCQlmbXQrKzsKCQkJYnJlYWs7CgkJY2FzZSAneic6CgkJCXN0cmJ1Zl9hZGRmKCZtdW5nZWRfZm10LCAiJSswNWQiLCB0el9vZmZzZXQpOwoJCQlmbXQrKzsKCQkJYnJlYWs7CgkJY2FzZSAnWic6CgkJCWlmIChzdXBwcmVzc190el9uYW1lKSB7CgkJCQlmbXQrKzsKCQkJCWJyZWFrOwoJCQl9CgkJCS8qIEZBTExUSFJPVUdIICovCgkJZGVmYXVsdDoKCQkJc3RyYnVmX2FkZGNoKCZtdW5nZWRfZm10LCAnJScpOwoJCX0KCX0KCWZtdCA9IG11bmdlZF9mbXQuYnVmOwoKCXN0cmJ1Zl9ncm93KHNiLCBoaW50KTsKCWxlbiA9IHN0cmZ0aW1lKHNiLT5idWYgKyBzYi0+bGVuLCBzYi0+YWxsb2MgLSBzYi0+bGVuLCBmbXQsIHRtKTsKCglpZiAoIWxlbikgewoJCS8qCgkJICogc3RyZnRpbWUgcmVwb3J0cyAiMCIgaWYgaXQgY291bGQgbm90IGZpdCB0aGUgcmVzdWx0IGluIHRoZSBidWZmZXIuCgkJICogVW5mb3J0dW5hdGVseSwgaXQgYWxzbyByZXBvcnRzICIwIiBpZiB0aGUgcmVxdWVzdGVkIHRpbWUgc3RyaW5nCgkJICogdGFrZXMgMCBieXRlcy4gU28gb3VyIHN0cmF0ZWd5IGlzIHRvIG11bmdlIHRoZSBmb3JtYXQgc28gdGhhdCB0aGUKCQkgKiBvdXRwdXQgY29udGFpbnMgYXQgbGVhc3Qgb25lIGNoYXJhY3RlciwgYW5kIHRoZW4gZHJvcCB0aGUgZXh0cmEKCQkgKiBjaGFyYWN0ZXIgYmVmb3JlIHJldHVybmluZy4KCQkgKi8KCQlzdHJidWZfYWRkY2goJm11bmdlZF9mbXQsICcgJyk7CgkJd2hpbGUgKCFsZW4pIHsKCQkJaGludCAqPSAyOwoJCQlzdHJidWZfZ3JvdyhzYiwgaGludCk7CgkJCWxlbiA9IHN0cmZ0aW1lKHNiLT5idWYgKyBzYi0+bGVuLCBzYi0+YWxsb2MgLSBzYi0+bGVuLAoJCQkJICAgICAgIG11bmdlZF9mbXQuYnVmLCB0bSk7CgkJfQoJCWxlbi0tOyAvKiBkcm9wIG11bmdlZCBzcGFjZSAqLwoJfQoJc3RyYnVmX3JlbGVhc2UoJm11bmdlZF9mbXQpOwoJc3RyYnVmX3NldGxlbihzYiwgc2ItPmxlbiArIGxlbik7Cn0KCnZvaWQgc3RyYnVmX3JlcG9fYWRkX3VuaXF1ZV9hYmJyZXYoc3RydWN0IHN0cmJ1ZiAqc2IsIHN0cnVjdCByZXBvc2l0b3J5ICpyZXBvLAoJCQkJICAgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLCBpbnQgYWJicmV2X2xlbikKewoJaW50IHI7CglzdHJidWZfZ3JvdyhzYiwgR0lUX01BWF9IRVhTWiArIDEpOwoJciA9IHJlcG9fZmluZF91bmlxdWVfYWJicmV2X3IocmVwbywgc2ItPmJ1ZiArIHNiLT5sZW4sIG9pZCwgYWJicmV2X2xlbik7CglzdHJidWZfc2V0bGVuKHNiLCBzYi0+bGVuICsgcik7Cn0KCnZvaWQgc3RyYnVmX2FkZF91bmlxdWVfYWJicmV2KHN0cnVjdCBzdHJidWYgKnNiLCBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsCgkJCSAgICAgIGludCBhYmJyZXZfbGVuKQp7CglzdHJidWZfcmVwb19hZGRfdW5pcXVlX2FiYnJldihzYiwgdGhlX3JlcG9zaXRvcnksIG9pZCwgYWJicmV2X2xlbik7Cn0KCi8qCiAqIFJldHVybnMgdGhlIGxlbmd0aCBvZiBhIGxpbmUsIHdpdGhvdXQgdHJhaWxpbmcgc3BhY2VzLgogKgogKiBJZiB0aGUgbGluZSBlbmRzIHdpdGggbmV3bGluZSwgaXQgd2lsbCBiZSByZW1vdmVkIHRvby4KICovCnN0YXRpYyBzaXplX3QgY2xlYW51cChjaGFyICpsaW5lLCBzaXplX3QgbGVuKQp7Cgl3aGlsZSAobGVuKSB7CgkJdW5zaWduZWQgY2hhciBjID0gbGluZVtsZW4gLSAxXTsKCQlpZiAoIWlzc3BhY2UoYykpCgkJCWJyZWFrOwoJCWxlbi0tOwoJfQoKCXJldHVybiBsZW47Cn0KCi8qCiAqIFJlbW92ZSBlbXB0eSBsaW5lcyBmcm9tIHRoZSBiZWdpbm5pbmcgYW5kIGVuZAogKiBhbmQgYWxzbyB0cmFpbGluZyBzcGFjZXMgZnJvbSBldmVyeSBsaW5lLgogKgogKiBUdXJuIG11bHRpcGxlIGNvbnNlY3V0aXZlIGVtcHR5IGxpbmVzIGJldHdlZW4gcGFyYWdyYXBocwogKiBpbnRvIGp1c3Qgb25lIGVtcHR5IGxpbmUuCiAqCiAqIElmIHRoZSBpbnB1dCBoYXMgb25seSBlbXB0eSBsaW5lcyBhbmQgc3BhY2VzLAogKiBubyBvdXRwdXQgd2lsbCBiZSBwcm9kdWNlZC4KICoKICogSWYgbGFzdCBsaW5lIGRvZXMgbm90IGhhdmUgYSBuZXdsaW5lIGF0IHRoZSBlbmQsIG9uZSBpcyBhZGRlZC4KICoKICogRW5hYmxlIHNraXBfY29tbWVudHMgdG8gc2tpcCBldmVyeSBsaW5lIHN0YXJ0aW5nIHdpdGggY29tbWVudAogKiBjaGFyYWN0ZXIuCiAqLwp2b2lkIHN0cmJ1Zl9zdHJpcHNwYWNlKHN0cnVjdCBzdHJidWYgKnNiLCBpbnQgc2tpcF9jb21tZW50cykKewoJc2l6ZV90IGVtcHRpZXMgPSAwOwoJc2l6ZV90IGksIGosIGxlbiwgbmV3bGVuOwoJY2hhciAqZW9sOwoKCS8qIFdlIG1heSBoYXZlIHRvIGFkZCBhIG5ld2xpbmUuICovCglzdHJidWZfZ3JvdyhzYiwgMSk7CgoJZm9yIChpID0gaiA9IDA7IGkgPCBzYi0+bGVuOyBpICs9IGxlbiwgaiArPSBuZXdsZW4pIHsKCQllb2wgPSBtZW1jaHIoc2ItPmJ1ZiArIGksICdcbicsIHNiLT5sZW4gLSBpKTsKCQlsZW4gPSBlb2wgPyBlb2wgLSAoc2ItPmJ1ZiArIGkpICsgMSA6IHNiLT5sZW4gLSBpOwoKCQlpZiAoc2tpcF9jb21tZW50cyAmJiBsZW4gJiYgc2ItPmJ1ZltpXSA9PSBjb21tZW50X2xpbmVfY2hhcikgewoJCQluZXdsZW4gPSAwOwoJCQljb250aW51ZTsKCQl9CgkJbmV3bGVuID0gY2xlYW51cChzYi0+YnVmICsgaSwgbGVuKTsKCgkJLyogTm90IGp1c3QgYW4gZW1wdHkgbGluZT8gKi8KCQlpZiAobmV3bGVuKSB7CgkJCWlmIChlbXB0aWVzID4gMCAmJiBqID4gMCkKCQkJCXNiLT5idWZbaisrXSA9ICdcbic7CgkJCWVtcHRpZXMgPSAwOwoJCQltZW1tb3ZlKHNiLT5idWYgKyBqLCBzYi0+YnVmICsgaSwgbmV3bGVuKTsKCQkJc2ItPmJ1ZltuZXdsZW4gKyBqKytdID0gJ1xuJzsKCQl9IGVsc2UgewoJCQllbXB0aWVzKys7CgkJfQoJfQoKCXN0cmJ1Zl9zZXRsZW4oc2IsIGopOwp9CgppbnQgc3RyYnVmX25vcm1hbGl6ZV9wYXRoKHN0cnVjdCBzdHJidWYgKnNyYykKewoJc3RydWN0IHN0cmJ1ZiBkc3QgPSBTVFJCVUZfSU5JVDsKCglzdHJidWZfZ3JvdygmZHN0LCBzcmMtPmxlbik7CglpZiAobm9ybWFsaXplX3BhdGhfY29weShkc3QuYnVmLCBzcmMtPmJ1ZikgPCAwKSB7CgkJc3RyYnVmX3JlbGVhc2UoJmRzdCk7CgkJcmV0dXJuIC0xOwoJfQoKCS8qCgkgKiBub3JtYWxpemVfcGF0aCBkb2VzIG5vdCB0ZWxsIHVzIHRoZSBuZXcgbGVuZ3RoLCBzbyB3ZSBoYXZlIHRvCgkgKiBjb21wdXRlIGl0IGJ5IGxvb2tpbmcgZm9yIHRoZSBuZXcgTlVMIGl0IHBsYWNlZAoJICovCglzdHJidWZfc2V0bGVuKCZkc3QsIHN0cmxlbihkc3QuYnVmKSk7CglzdHJidWZfc3dhcChzcmMsICZkc3QpOwoJc3RyYnVmX3JlbGVhc2UoJmRzdCk7CglyZXR1cm4gMDsKfQoKaW50IHN0cmJ1Zl9lZGl0X2ludGVyYWN0aXZlbHkoc3RydWN0IHN0cmJ1ZiAqYnVmZmVyLCBjb25zdCBjaGFyICpwYXRoLAoJCQkgICAgICBjb25zdCBjaGFyICpjb25zdCAqZW52KQp7CgljaGFyICpwYXRoMiA9IE5VTEw7CglpbnQgZmQsIHJlcyA9IDA7CgoJaWYgKCFpc19hYnNvbHV0ZV9wYXRoKHBhdGgpKQoJCXBhdGggPSBwYXRoMiA9IHhzdHJkdXAoZ2l0X3BhdGgoIiVzIiwgcGF0aCkpOwoKCWZkID0gb3BlbihwYXRoLCBPX1dST05MWSB8IE9fQ1JFQVQgfCBPX1RSVU5DLCAwNjY2KTsKCWlmIChmZCA8IDApCgkJcmVzID0gZXJyb3JfZXJybm8oXygiY291bGQgbm90IG9wZW4gJyVzJyBmb3Igd3JpdGluZyIpLCBwYXRoKTsKCWVsc2UgaWYgKHdyaXRlX2luX2Z1bGwoZmQsIGJ1ZmZlci0+YnVmLCBidWZmZXItPmxlbikgPCAwKSB7CgkJcmVzID0gZXJyb3JfZXJybm8oXygiY291bGQgbm90IHdyaXRlIHRvICclcyciKSwgcGF0aCk7CgkJY2xvc2UoZmQpOwoJfSBlbHNlIGlmIChjbG9zZShmZCkgPCAwKQoJCXJlcyA9IGVycm9yX2Vycm5vKF8oImNvdWxkIG5vdCBjbG9zZSAnJXMnIiksIHBhdGgpOwoJZWxzZSB7CgkJc3RyYnVmX3Jlc2V0KGJ1ZmZlcik7CgkJaWYgKGxhdW5jaF9lZGl0b3IocGF0aCwgYnVmZmVyLCBlbnYpIDwgMCkKCQkJcmVzID0gZXJyb3JfZXJybm8oXygiY291bGQgbm90IGVkaXQgJyVzJyIpLCBwYXRoKTsKCQl1bmxpbmsocGF0aCk7Cgl9CgoJZnJlZShwYXRoMik7CglyZXR1cm4gcmVzOwp9Cg==",
    "text": "#include \"cache.h\"\n#include \"refs.h\"\n#include \"string-list.h\"\n#include \"utf8.h\"\n#include \"date.h\"\n\nint starts_with(const char *str, const char *prefix)\n{\n\tfor (; ; str++, prefix++)\n\t\tif (!*prefix)\n\t\t\treturn 1;\n\t\telse if (*str != *prefix)\n\t\t\treturn 0;\n}\n\nint istarts_with(const char *str, const char *prefix)\n{\n\tfor (; ; str++, prefix++)\n\t\tif (!*prefix)\n\t\t\treturn 1;\n\t\telse if (tolower(*str) != tolower(*prefix))\n\t\t\treturn 0;\n}\n\nint skip_to_optional_arg_default(const char *str, const char *prefix,\n\t\t\t\t const char **arg, const char *def)\n{\n\tconst char *p;\n\n\tif (!skip_prefix(str, prefix, &p))\n\t\treturn 0;\n\n\tif (!*p) {\n\t\tif (arg)\n\t\t\t*arg = def;\n\t\treturn 1;\n\t}\n\n\tif (*p != '=')\n\t\treturn 0;\n\n\tif (arg)\n\t\t*arg = p + 1;\n\treturn 1;\n}\n\n/*\n * Used as the default ->buf value, so that people can always assume\n * buf is non NULL and ->buf is NUL terminated even for a freshly\n * initialized strbuf.\n */\nchar strbuf_slopbuf[1];\n\nvoid strbuf_init(struct strbuf *sb, size_t hint)\n{\n\tstruct strbuf blank = STRBUF_INIT;\n\tmemcpy(sb, &blank, sizeof(*sb));\n\tif (hint)\n\t\tstrbuf_grow(sb, hint);\n}\n\nvoid strbuf_release(struct strbuf *sb)\n{\n\tif (sb->alloc) {\n\t\tfree(sb->buf);\n\t\tstrbuf_init(sb, 0);\n\t}\n}\n\nchar *strbuf_detach(struct strbuf *sb, size_t *sz)\n{\n\tchar *res;\n\tstrbuf_grow(sb, 0);\n\tres = sb->buf;\n\tif (sz)\n\t\t*sz = sb->len;\n\tstrbuf_init(sb, 0);\n\treturn res;\n}\n\nvoid strbuf_attach(struct strbuf *sb, void *buf, size_t len, size_t alloc)\n{\n\tstrbuf_release(sb);\n\tsb->buf   = buf;\n\tsb->len   = len;\n\tsb->alloc = alloc;\n\tstrbuf_grow(sb, 0);\n\tsb->buf[sb->len] = '\\0';\n}\n\nvoid strbuf_grow(struct strbuf *sb, size_t extra)\n{\n\tint new_buf = !sb->alloc;\n\tif (unsigned_add_overflows(extra, 1) ||\n\t    unsigned_add_overflows(sb->len, extra + 1))\n\t\tdie(\"you want to use way too much memory\");\n\tif (new_buf)\n\t\tsb->buf = NULL;\n\tALLOC_GROW(sb->buf, sb->len + extra + 1, sb->alloc);\n\tif (new_buf)\n\t\tsb->buf[0] = '\\0';\n}\n\nvoid strbuf_trim(struct strbuf *sb)\n{\n\tstrbuf_rtrim(sb);\n\tstrbuf_ltrim(sb);\n}\n\nvoid strbuf_rtrim(struct strbuf *sb)\n{\n\twhile (sb->len > 0 && isspace((unsigned char)sb->buf[sb->len - 1]))\n\t\tsb->len--;\n\tsb->buf[sb->len] = '\\0';\n}\n\nvoid strbuf_trim_trailing_dir_sep(struct strbuf *sb)\n{\n\twhile (sb->len > 0 && is_dir_sep((unsigned char)sb->buf[sb->len - 1]))\n\t\tsb->len--;\n\tsb->buf[sb->len] = '\\0';\n}\n\nvoid strbuf_trim_trailing_newline(struct strbuf *sb)\n{\n\tif (sb->len > 0 && sb->buf[sb->len - 1] == '\\n') {\n\t\tif (--sb->len > 0 && sb->buf[sb->len - 1] == '\\r')\n\t\t\t--sb->len;\n\t\tsb->buf[sb->len] = '\\0';\n\t}\n}\n\nvoid strbuf_ltrim(struct strbuf *sb)\n{\n\tchar *b = sb->buf;\n\twhile (sb->len > 0 && isspace(*b)) {\n\t\tb++;\n\t\tsb->len--;\n\t}\n\tmemmove(sb->buf, b, sb->len);\n\tsb->buf[sb->len] = '\\0';\n}\n\nint strbuf_reencode(struct strbuf *sb, const char *from, const char *to)\n{\n\tchar *out;\n\tsize_t len;\n\n\tif (same_encoding(from, to))\n\t\treturn 0;\n\n\tout = reencode_string_len(sb->buf, sb->len, to, from, &len);\n\tif (!out)\n\t\treturn -1;\n\n\tstrbuf_attach(sb, out, len, len);\n\treturn 0;\n}\n\nvoid strbuf_tolower(struct strbuf *sb)\n{\n\tchar *p = sb->buf, *end = sb->buf + sb->len;\n\tfor (; p < end; p++)\n\t\t*p = tolower(*p);\n}\n\nstruct strbuf **strbuf_split_buf(const char *str, size_t slen,\n\t\t\t\t int terminator, int max)\n{\n\tstruct strbuf **ret = NULL;\n\tsize_t nr = 0, alloc = 0;\n\tstruct strbuf *t;\n\n\twhile (slen) {\n\t\tint len = slen;\n\t\tif (max <= 0 || nr + 1 < max) {\n\t\t\tconst char *end = memchr(str, terminator, slen);\n\t\t\tif (end)\n\t\t\t\tlen = end - str + 1;\n\t\t}\n\t\tt = xmalloc(sizeof(struct strbuf));\n\t\tstrbuf_init(t, len);\n\t\tstrbuf_add(t, str, len);\n\t\tALLOC_GROW(ret, nr + 2, alloc);\n\t\tret[nr++] = t;\n\t\tstr += len;\n\t\tslen -= len;\n\t}\n\tALLOC_GROW(ret, nr + 1, alloc); /* In case string was empty */\n\tret[nr] = NULL;\n\treturn ret;\n}\n\nvoid strbuf_add_separated_string_list(struct strbuf *str,\n\t\t\t\t      const char *sep,\n\t\t\t\t      struct string_list *slist)\n{\n\tstruct string_list_item *item;\n\tint sep_needed = 0;\n\n\tfor_each_string_list_item(item, slist) {\n\t\tif (sep_needed)\n\t\t\tstrbuf_addstr(str, sep);\n\t\tstrbuf_addstr(str, item->string);\n\t\tsep_needed = 1;\n\t}\n}\n\nvoid strbuf_list_free(struct strbuf **sbs)\n{\n\tstruct strbuf **s = sbs;\n\n\tif (!s)\n\t\treturn;\n\twhile (*s) {\n\t\tstrbuf_release(*s);\n\t\tfree(*s++);\n\t}\n\tfree(sbs);\n}\n\nint strbuf_cmp(const struct strbuf *a, const struct strbuf *b)\n{\n\tsize_t len = a->len < b->len ? a->len: b->len;\n\tint cmp = memcmp(a->buf, b->buf, len);\n\tif (cmp)\n\t\treturn cmp;\n\treturn a->len < b->len ? -1: a->len != b->len;\n}\n\nvoid strbuf_splice(struct strbuf *sb, size_t pos, size_t len,\n\t\t\t\t   const void *data, size_t dlen)\n{\n\tif (unsigned_add_overflows(pos, len))\n\t\tdie(\"you want to use way too much memory\");\n\tif (pos > sb->len)\n\t\tdie(\"`pos' is too far after the end of the buffer\");\n\tif (pos + len > sb->len)\n\t\tdie(\"`pos + len' is too far after the end of the buffer\");\n\n\tif (dlen >= len)\n\t\tstrbuf_grow(sb, dlen - len);\n\tmemmove(sb->buf + pos + dlen,\n\t\t\tsb->buf + pos + len,\n\t\t\tsb->len - pos - len);\n\tmemcpy(sb->buf + pos, data, dlen);\n\tstrbuf_setlen(sb, sb->len + dlen - len);\n}\n\nvoid strbuf_insert(struct strbuf *sb, size_t pos, const void *data, size_t len)\n{\n\tstrbuf_splice(sb, pos, 0, data, len);\n}\n\nvoid strbuf_vinsertf(struct strbuf *sb, size_t pos, const char *fmt, va_list ap)\n{\n\tint len, len2;\n\tchar save;\n\tva_list cp;\n\n\tif (pos > sb->len)\n\t\tdie(\"`pos' is too far after the end of the buffer\");\n\tva_copy(cp, ap);\n\tlen = vsnprintf(sb->buf + sb->len, 0, fmt, cp);\n\tva_end(cp);\n\tif (len < 0)\n\t\tBUG(\"your vsnprintf is broken (returned %d)\", len);\n\tif (!len)\n\t\treturn; /* nothing to do */\n\tif (unsigned_add_overflows(sb->len, len))\n\t\tdie(\"you want to use way too much memory\");\n\tstrbuf_grow(sb, len);\n\tmemmove(sb->buf + pos + len, sb->buf + pos, sb->len - pos);\n\t/* vsnprintf() will append a NUL, overwriting one of our characters */\n\tsave = sb->buf[pos + len];\n\tlen2 = vsnprintf(sb->buf + pos, len + 1, fmt, ap);\n\tsb->buf[pos + len] = save;\n\tif (len2 != len)\n\t\tBUG(\"your vsnprintf is broken (returns inconsistent lengths)\");\n\tstrbuf_setlen(sb, sb->len + len);\n}\n\nvoid strbuf_insertf(struct strbuf *sb, size_t pos, const char *fmt, ...)\n{\n\tva_list ap;\n\tva_start(ap, fmt);\n\tstrbuf_vinsertf(sb, pos, fmt, ap);\n\tva_end(ap);\n}\n\nvoid strbuf_remove(struct strbuf *sb, size_t pos, size_t len)\n{\n\tstrbuf_splice(sb, pos, len, \"\", 0);\n}\n\nvoid strbuf_add(struct strbuf *sb, const void *data, size_t len)\n{\n\tstrbuf_grow(sb, len);\n\tmemcpy(sb->buf + sb->len, data, len);\n\tstrbuf_setlen(sb, sb->len + len);\n}\n\nvoid strbuf_addbuf(struct strbuf *sb, const struct strbuf *sb2)\n{\n\tstrbuf_grow(sb, sb2->len);\n\tmemcpy(sb->buf + sb->len, sb2->buf, sb2->len);\n\tstrbuf_setlen(sb, sb->len + sb2->len);\n}\n\nconst char *strbuf_join_argv(struct strbuf *buf,\n\t\t\t     int argc, const char **argv, char delim)\n{\n\tif (!argc)\n\t\treturn buf->buf;\n\n\tstrbuf_addstr(buf, *argv);\n\twhile (--argc) {\n\t\tstrbuf_addch(buf, delim);\n\t\tstrbuf_addstr(buf, *(++argv));\n\t}\n\n\treturn buf->buf;\n}\n\nvoid strbuf_addchars(struct strbuf *sb, int c, size_t n)\n{\n\tstrbuf_grow(sb, n);\n\tmemset(sb->buf + sb->len, c, n);\n\tstrbuf_setlen(sb, sb->len + n);\n}\n\nvoid strbuf_addf(struct strbuf *sb, const char *fmt, ...)\n{\n\tva_list ap;\n\tva_start(ap, fmt);\n\tstrbuf_vaddf(sb, fmt, ap);\n\tva_end(ap);\n}\n\nstatic void add_lines(struct strbuf *out,\n\t\t\tconst char *prefix1,\n\t\t\tconst char *prefix2,\n\t\t\tconst char *buf, size_t size)\n{\n\twhile (size) {\n\t\tconst char *prefix;\n\t\tconst char *next = memchr(buf, '\\n', size);\n\t\tnext = next ? (next + 1) : (buf + size);\n\n\t\tprefix = ((prefix2 && (buf[0] == '\\n' || buf[0] == '\\t'))\n\t\t\t  ? prefix2 : prefix1);\n\t\tstrbuf_addstr(out, prefix);\n\t\tstrbuf_add(out, buf, next - buf);\n\t\tsize -= next - buf;\n\t\tbuf = next;\n\t}\n\tstrbuf_complete_line(out);\n}\n\nvoid strbuf_add_commented_lines(struct strbuf *out, const char *buf, size_t size)\n{\n\tstatic char prefix1[3];\n\tstatic char prefix2[2];\n\n\tif (prefix1[0] != comment_line_char) {\n\t\txsnprintf(prefix1, sizeof(prefix1), \"%c \", comment_line_char);\n\t\txsnprintf(prefix2, sizeof(prefix2), \"%c\", comment_line_char);\n\t}\n\tadd_lines(out, prefix1, prefix2, buf, size);\n}\n\nvoid strbuf_commented_addf(struct strbuf *sb, const char *fmt, ...)\n{\n\tva_list params;\n\tstruct strbuf buf = STRBUF_INIT;\n\tint incomplete_line = sb->len && sb->buf[sb->len - 1] != '\\n';\n\n\tva_start(params, fmt);\n\tstrbuf_vaddf(&buf, fmt, params);\n\tva_end(params);\n\n\tstrbuf_add_commented_lines(sb, buf.buf, buf.len);\n\tif (incomplete_line)\n\t\tsb->buf[--sb->len] = '\\0';\n\n\tstrbuf_release(&buf);\n}\n\nvoid strbuf_vaddf(struct strbuf *sb, const char *fmt, va_list ap)\n{\n\tint len;\n\tva_list cp;\n\n\tif (!strbuf_avail(sb))\n\t\tstrbuf_grow(sb, 64);\n\tva_copy(cp, ap);\n\tlen = vsnprintf(sb->buf + sb->len, sb->alloc - sb->len, fmt, cp);\n\tva_end(cp);\n\tif (len < 0)\n\t\tBUG(\"your vsnprintf is broken (returned %d)\", len);\n\tif (len > strbuf_avail(sb)) {\n\t\tstrbuf_grow(sb, len);\n\t\tlen = vsnprintf(sb->buf + sb->len, sb->alloc - sb->len, fmt, ap);\n\t\tif (len > strbuf_avail(sb))\n\t\t\tBUG(\"your vsnprintf is broken (insatiable)\");\n\t}\n\tstrbuf_setlen(sb, sb->len + len);\n}\n\nvoid strbuf_expand(struct strbuf *sb, const char *format, expand_fn_t fn,\n\t\t   void *context)\n{\n\tfor (;;) {\n\t\tconst char *percent;\n\t\tsize_t consumed;\n\n\t\tpercent = strchrnul(format, '%');\n\t\tstrbuf_add(sb, format, percent - format);\n\t\tif (!*percent)\n\t\t\tbreak;\n\t\tformat = percent + 1;\n\n\t\tif (*format == '%') {\n\t\t\tstrbuf_addch(sb, '%');\n\t\t\tformat++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tconsumed = fn(sb, format, context);\n\t\tif (consumed)\n\t\t\tformat += consumed;\n\t\telse\n\t\t\tstrbuf_addch(sb, '%');\n\t}\n}\n\nsize_t strbuf_expand_literal_cb(struct strbuf *sb,\n\t\t\t\tconst char *placeholder,\n\t\t\t\tvoid *context)\n{\n\tint ch;\n\n\tswitch (placeholder[0]) {\n\tcase 'n':\t\t/* newline */\n\t\tstrbuf_addch(sb, '\\n');\n\t\treturn 1;\n\tcase 'x':\n\t\t/* %x00 == NUL, %x0a == LF, etc. */\n\t\tch = hex2chr(placeholder + 1);\n\t\tif (ch < 0)\n\t\t\treturn 0;\n\t\tstrbuf_addch(sb, ch);\n\t\treturn 3;\n\t}\n\treturn 0;\n}\n\nsize_t strbuf_expand_dict_cb(struct strbuf *sb, const char *placeholder,\n\t\tvoid *context)\n{\n\tstruct strbuf_expand_dict_entry *e = context;\n\tsize_t len;\n\n\tfor (; e->placeholder && (len = strlen(e->placeholder)); e++) {\n\t\tif (!strncmp(placeholder, e->placeholder, len)) {\n\t\t\tif (e->value)\n\t\t\t\tstrbuf_addstr(sb, e->value);\n\t\t\treturn len;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid strbuf_addbuf_percentquote(struct strbuf *dst, const struct strbuf *src)\n{\n\tsize_t i, len = src->len;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (src->buf[i] == '%')\n\t\t\tstrbuf_addch(dst, '%');\n\t\tstrbuf_addch(dst, src->buf[i]);\n\t}\n}\n\n#define URL_UNSAFE_CHARS \" <>\\\"%{}|\\\\^`:?#[]@!$&'()*+,;=\"\n\nvoid strbuf_add_percentencode(struct strbuf *dst, const char *src, int flags)\n{\n\tsize_t i, len = strlen(src);\n\n\tfor (i = 0; i < len; i++) {\n\t\tunsigned char ch = src[i];\n\t\tif (ch <= 0x1F || ch >= 0x7F ||\n\t\t    (ch == '/' && (flags & STRBUF_ENCODE_SLASH)) ||\n\t\t    strchr(URL_UNSAFE_CHARS, ch))\n\t\t\tstrbuf_addf(dst, \"%%%02X\", (unsigned char)ch);\n\t\telse\n\t\t\tstrbuf_addch(dst, ch);\n\t}\n}\n\nsize_t strbuf_fread(struct strbuf *sb, size_t size, FILE *f)\n{\n\tsize_t res;\n\tsize_t oldalloc = sb->alloc;\n\n\tstrbuf_grow(sb, size);\n\tres = fread(sb->buf + sb->len, 1, size, f);\n\tif (res > 0)\n\t\tstrbuf_setlen(sb, sb->len + res);\n\telse if (oldalloc == 0)\n\t\tstrbuf_release(sb);\n\treturn res;\n}\n\nssize_t strbuf_read(struct strbuf *sb, int fd, size_t hint)\n{\n\tsize_t oldlen = sb->len;\n\tsize_t oldalloc = sb->alloc;\n\n\tstrbuf_grow(sb, hint ? hint : 8192);\n\tfor (;;) {\n\t\tssize_t want = sb->alloc - sb->len - 1;\n\t\tssize_t got = read_in_full(fd, sb->buf + sb->len, want);\n\n\t\tif (got < 0) {\n\t\t\tif (oldalloc == 0)\n\t\t\t\tstrbuf_release(sb);\n\t\t\telse\n\t\t\t\tstrbuf_setlen(sb, oldlen);\n\t\t\treturn -1;\n\t\t}\n\t\tsb->len += got;\n\t\tif (got < want)\n\t\t\tbreak;\n\t\tstrbuf_grow(sb, 8192);\n\t}\n\n\tsb->buf[sb->len] = '\\0';\n\treturn sb->len - oldlen;\n}\n\nssize_t strbuf_read_once(struct strbuf *sb, int fd, size_t hint)\n{\n\tsize_t oldalloc = sb->alloc;\n\tssize_t cnt;\n\n\tstrbuf_grow(sb, hint ? hint : 8192);\n\tcnt = xread(fd, sb->buf + sb->len, sb->alloc - sb->len - 1);\n\tif (cnt > 0)\n\t\tstrbuf_setlen(sb, sb->len + cnt);\n\telse if (oldalloc == 0)\n\t\tstrbuf_release(sb);\n\treturn cnt;\n}\n\nssize_t strbuf_write(struct strbuf *sb, FILE *f)\n{\n\treturn sb->len ? fwrite(sb->buf, 1, sb->len, f) : 0;\n}\n\n#define STRBUF_MAXLINK (2*PATH_MAX)\n\nint strbuf_readlink(struct strbuf *sb, const char *path, size_t hint)\n{\n\tsize_t oldalloc = sb->alloc;\n\n\tif (hint < 32)\n\t\thint = 32;\n\n\twhile (hint < STRBUF_MAXLINK) {\n\t\tssize_t len;\n\n\t\tstrbuf_grow(sb, hint);\n\t\tlen = readlink(path, sb->buf, hint);\n\t\tif (len < 0) {\n\t\t\tif (errno != ERANGE)\n\t\t\t\tbreak;\n\t\t} else if (len < hint) {\n\t\t\tstrbuf_setlen(sb, len);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* .. the buffer was too small - try again */\n\t\thint *= 2;\n\t}\n\tif (oldalloc == 0)\n\t\tstrbuf_release(sb);\n\treturn -1;\n}\n\nint strbuf_getcwd(struct strbuf *sb)\n{\n\tsize_t oldalloc = sb->alloc;\n\tsize_t guessed_len = 128;\n\n\tfor (;; guessed_len *= 2) {\n\t\tstrbuf_grow(sb, guessed_len);\n\t\tif (getcwd(sb->buf, sb->alloc)) {\n\t\t\tstrbuf_setlen(sb, strlen(sb->buf));\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * If getcwd(3) is implemented as a syscall that falls\n\t\t * back to a regular lookup using readdir(3) etc. then\n\t\t * we may be able to avoid EACCES by providing enough\n\t\t * space to the syscall as it's not necessarily bound\n\t\t * to the same restrictions as the fallback.\n\t\t */\n\t\tif (errno == EACCES && guessed_len < PATH_MAX)\n\t\t\tcontinue;\n\n\t\tif (errno != ERANGE)\n\t\t\tbreak;\n\t}\n\tif (oldalloc == 0)\n\t\tstrbuf_release(sb);\n\telse\n\t\tstrbuf_reset(sb);\n\treturn -1;\n}\n\n#ifdef HAVE_GETDELIM\nint strbuf_getwholeline(struct strbuf *sb, FILE *fp, int term)\n{\n\tssize_t r;\n\n\tif (feof(fp))\n\t\treturn EOF;\n\n\tstrbuf_reset(sb);\n\n\t/* Translate slopbuf to NULL, as we cannot call realloc on it */\n\tif (!sb->alloc)\n\t\tsb->buf = NULL;\n\terrno = 0;\n\tr = getdelim(&sb->buf, &sb->alloc, term, fp);\n\n\tif (r > 0) {\n\t\tsb->len = r;\n\t\treturn 0;\n\t}\n\tassert(r == -1);\n\n\t/*\n\t * Normally we would have called xrealloc, which will try to free\n\t * memory and recover. But we have no way to tell getdelim() to do so.\n\t * Worse, we cannot try to recover ENOMEM ourselves, because we have\n\t * no idea how many bytes were read by getdelim.\n\t *\n\t * Dying here is reasonable. It mirrors what xrealloc would do on\n\t * catastrophic memory failure. We skip the opportunity to free pack\n\t * memory and retry, but that's unlikely to help for a malloc small\n\t * enough to hold a single line of input, anyway.\n\t */\n\tif (errno == ENOMEM)\n\t\tdie(\"Out of memory, getdelim failed\");\n\n\t/*\n\t * Restore strbuf invariants; if getdelim left us with a NULL pointer,\n\t * we can just re-init, but otherwise we should make sure that our\n\t * length is empty, and that the result is NUL-terminated.\n\t */\n\tif (!sb->buf)\n\t\tstrbuf_init(sb, 0);\n\telse\n\t\tstrbuf_reset(sb);\n\treturn EOF;\n}\n#else\nint strbuf_getwholeline(struct strbuf *sb, FILE *fp, int term)\n{\n\tint ch;\n\n\tif (feof(fp))\n\t\treturn EOF;\n\n\tstrbuf_reset(sb);\n\tflockfile(fp);\n\twhile ((ch = getc_unlocked(fp)) != EOF) {\n\t\tif (!strbuf_avail(sb))\n\t\t\tstrbuf_grow(sb, 1);\n\t\tsb->buf[sb->len++] = ch;\n\t\tif (ch == term)\n\t\t\tbreak;\n\t}\n\tfunlockfile(fp);\n\tif (ch == EOF && sb->len == 0)\n\t\treturn EOF;\n\n\tsb->buf[sb->len] = '\\0';\n\treturn 0;\n}\n#endif\n\nint strbuf_appendwholeline(struct strbuf *sb, FILE *fp, int term)\n{\n\tstruct strbuf line = STRBUF_INIT;\n\tif (strbuf_getwholeline(&line, fp, term))\n\t\treturn EOF;\n\tstrbuf_addbuf(sb, &line);\n\tstrbuf_release(&line);\n\treturn 0;\n}\n\nstatic int strbuf_getdelim(struct strbuf *sb, FILE *fp, int term)\n{\n\tif (strbuf_getwholeline(sb, fp, term))\n\t\treturn EOF;\n\tif (sb->buf[sb->len - 1] == term)\n\t\tstrbuf_setlen(sb, sb->len - 1);\n\treturn 0;\n}\n\nint strbuf_getline(struct strbuf *sb, FILE *fp)\n{\n\tif (strbuf_getwholeline(sb, fp, '\\n'))\n\t\treturn EOF;\n\tif (sb->buf[sb->len - 1] == '\\n') {\n\t\tstrbuf_setlen(sb, sb->len - 1);\n\t\tif (sb->len && sb->buf[sb->len - 1] == '\\r')\n\t\t\tstrbuf_setlen(sb, sb->len - 1);\n\t}\n\treturn 0;\n}\n\nint strbuf_getline_lf(struct strbuf *sb, FILE *fp)\n{\n\treturn strbuf_getdelim(sb, fp, '\\n');\n}\n\nint strbuf_getline_nul(struct strbuf *sb, FILE *fp)\n{\n\treturn strbuf_getdelim(sb, fp, '\\0');\n}\n\nint strbuf_getwholeline_fd(struct strbuf *sb, int fd, int term)\n{\n\tstrbuf_reset(sb);\n\n\twhile (1) {\n\t\tchar ch;\n\t\tssize_t len = xread(fd, &ch, 1);\n\t\tif (len <= 0)\n\t\t\treturn EOF;\n\t\tstrbuf_addch(sb, ch);\n\t\tif (ch == term)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}\n\nssize_t strbuf_read_file(struct strbuf *sb, const char *path, size_t hint)\n{\n\tint fd;\n\tssize_t len;\n\tint saved_errno;\n\n\tfd = open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn -1;\n\tlen = strbuf_read(sb, fd, hint);\n\tsaved_errno = errno;\n\tclose(fd);\n\tif (len < 0) {\n\t\terrno = saved_errno;\n\t\treturn -1;\n\t}\n\n\treturn len;\n}\n\nvoid strbuf_add_lines(struct strbuf *out, const char *prefix,\n\t\t      const char *buf, size_t size)\n{\n\tadd_lines(out, prefix, NULL, buf, size);\n}\n\nvoid strbuf_addstr_xml_quoted(struct strbuf *buf, const char *s)\n{\n\twhile (*s) {\n\t\tsize_t len = strcspn(s, \"\\\"<>&\");\n\t\tstrbuf_add(buf, s, len);\n\t\ts += len;\n\t\tswitch (*s) {\n\t\tcase '\"':\n\t\t\tstrbuf_addstr(buf, \"&quot;\");\n\t\t\tbreak;\n\t\tcase '<':\n\t\t\tstrbuf_addstr(buf, \"&lt;\");\n\t\t\tbreak;\n\t\tcase '>':\n\t\t\tstrbuf_addstr(buf, \"&gt;\");\n\t\t\tbreak;\n\t\tcase '&':\n\t\t\tstrbuf_addstr(buf, \"&amp;\");\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\treturn;\n\t\t}\n\t\ts++;\n\t}\n}\n\nint is_rfc3986_reserved_or_unreserved(char ch)\n{\n\tif (is_rfc3986_unreserved(ch))\n\t\treturn 1;\n\tswitch (ch) {\n\t\tcase '!': case '*': case '\\'': case '(': case ')': case ';':\n\t\tcase ':': case '@': case '&': case '=': case '+': case '$':\n\t\tcase ',': case '/': case '?': case '#': case '[': case ']':\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint is_rfc3986_unreserved(char ch)\n{\n\treturn isalnum(ch) ||\n\t\tch == '-' || ch == '_' || ch == '.' || ch == '~';\n}\n\nstatic void strbuf_add_urlencode(struct strbuf *sb, const char *s, size_t len,\n\t\t\t\t char_predicate allow_unencoded_fn)\n{\n\tstrbuf_grow(sb, len);\n\twhile (len--) {\n\t\tchar ch = *s++;\n\t\tif (allow_unencoded_fn(ch))\n\t\t\tstrbuf_addch(sb, ch);\n\t\telse\n\t\t\tstrbuf_addf(sb, \"%%%02x\", (unsigned char)ch);\n\t}\n}\n\nvoid strbuf_addstr_urlencode(struct strbuf *sb, const char *s,\n\t\t\t     char_predicate allow_unencoded_fn)\n{\n\tstrbuf_add_urlencode(sb, s, strlen(s), allow_unencoded_fn);\n}\n\nstatic void strbuf_humanise(struct strbuf *buf, off_t bytes,\n\t\t\t\t int humanise_rate)\n{\n\tif (bytes > 1 << 30) {\n\t\tstrbuf_addf(buf,\n\t\t\t\thumanise_rate == 0 ?\n\t\t\t\t\t/* TRANSLATORS: IEC 80000-13:2008 gibibyte */\n\t\t\t\t\t_(\"%u.%2.2u GiB\") :\n\t\t\t\t\t/* TRANSLATORS: IEC 80000-13:2008 gibibyte/second */\n\t\t\t\t\t_(\"%u.%2.2u GiB/s\"),\n\t\t\t    (unsigned)(bytes >> 30),\n\t\t\t    (unsigned)(bytes & ((1 << 30) - 1)) / 10737419);\n\t} else if (bytes > 1 << 20) {\n\t\tunsigned x = bytes + 5243;  /* for rounding */\n\t\tstrbuf_addf(buf,\n\t\t\t\thumanise_rate == 0 ?\n\t\t\t\t\t/* TRANSLATORS: IEC 80000-13:2008 mebibyte */\n\t\t\t\t\t_(\"%u.%2.2u MiB\") :\n\t\t\t\t\t/* TRANSLATORS: IEC 80000-13:2008 mebibyte/second */\n\t\t\t\t\t_(\"%u.%2.2u MiB/s\"),\n\t\t\t    x >> 20, ((x & ((1 << 20) - 1)) * 100) >> 20);\n\t} else if (bytes > 1 << 10) {\n\t\tunsigned x = bytes + 5;  /* for rounding */\n\t\tstrbuf_addf(buf,\n\t\t\t\thumanise_rate == 0 ?\n\t\t\t\t\t/* TRANSLATORS: IEC 80000-13:2008 kibibyte */\n\t\t\t\t\t_(\"%u.%2.2u KiB\") :\n\t\t\t\t\t/* TRANSLATORS: IEC 80000-13:2008 kibibyte/second */\n\t\t\t\t\t_(\"%u.%2.2u KiB/s\"),\n\t\t\t    x >> 10, ((x & ((1 << 10) - 1)) * 100) >> 10);\n\t} else {\n\t\tstrbuf_addf(buf,\n\t\t\t\thumanise_rate == 0 ?\n\t\t\t\t\t/* TRANSLATORS: IEC 80000-13:2008 byte */\n\t\t\t\t\tQ_(\"%u byte\", \"%u bytes\", (unsigned)bytes) :\n\t\t\t\t\t/* TRANSLATORS: IEC 80000-13:2008 byte/second */\n\t\t\t\t\tQ_(\"%u byte/s\", \"%u bytes/s\", (unsigned)bytes),\n\t\t\t\t(unsigned)bytes);\n\t}\n}\n\nvoid strbuf_humanise_bytes(struct strbuf *buf, off_t bytes)\n{\n\tstrbuf_humanise(buf, bytes, 0);\n}\n\nvoid strbuf_humanise_rate(struct strbuf *buf, off_t bytes)\n{\n\tstrbuf_humanise(buf, bytes, 1);\n}\n\nvoid strbuf_add_absolute_path(struct strbuf *sb, const char *path)\n{\n\tif (!*path)\n\t\tdie(\"The empty string is not a valid path\");\n\tif (!is_absolute_path(path)) {\n\t\tstruct stat cwd_stat, pwd_stat;\n\t\tsize_t orig_len = sb->len;\n\t\tchar *cwd = xgetcwd();\n\t\tchar *pwd = getenv(\"PWD\");\n\t\tif (pwd && strcmp(pwd, cwd) &&\n\t\t    !stat(cwd, &cwd_stat) &&\n\t\t    (cwd_stat.st_dev || cwd_stat.st_ino) &&\n\t\t    !stat(pwd, &pwd_stat) &&\n\t\t    pwd_stat.st_dev == cwd_stat.st_dev &&\n\t\t    pwd_stat.st_ino == cwd_stat.st_ino)\n\t\t\tstrbuf_addstr(sb, pwd);\n\t\telse\n\t\t\tstrbuf_addstr(sb, cwd);\n\t\tif (sb->len > orig_len && !is_dir_sep(sb->buf[sb->len - 1]))\n\t\t\tstrbuf_addch(sb, '/');\n\t\tfree(cwd);\n\t}\n\tstrbuf_addstr(sb, path);\n}\n\nvoid strbuf_add_real_path(struct strbuf *sb, const char *path)\n{\n\tif (sb->len) {\n\t\tstruct strbuf resolved = STRBUF_INIT;\n\t\tstrbuf_realpath(&resolved, path, 1);\n\t\tstrbuf_addbuf(sb, &resolved);\n\t\tstrbuf_release(&resolved);\n\t} else\n\t\tstrbuf_realpath(sb, path, 1);\n}\n\nint printf_ln(const char *fmt, ...)\n{\n\tint ret;\n\tva_list ap;\n\tva_start(ap, fmt);\n\tret = vprintf(fmt, ap);\n\tva_end(ap);\n\tif (ret < 0 || putchar('\\n') == EOF)\n\t\treturn -1;\n\treturn ret + 1;\n}\n\nint fprintf_ln(FILE *fp, const char *fmt, ...)\n{\n\tint ret;\n\tva_list ap;\n\tva_start(ap, fmt);\n\tret = vfprintf(fp, fmt, ap);\n\tva_end(ap);\n\tif (ret < 0 || putc('\\n', fp) == EOF)\n\t\treturn -1;\n\treturn ret + 1;\n}\n\nchar *xstrdup_tolower(const char *string)\n{\n\tchar *result;\n\tsize_t len, i;\n\n\tlen = strlen(string);\n\tresult = xmallocz(len);\n\tfor (i = 0; i < len; i++)\n\t\tresult[i] = tolower(string[i]);\n\treturn result;\n}\n\nchar *xstrdup_toupper(const char *string)\n{\n\tchar *result;\n\tsize_t len, i;\n\n\tlen = strlen(string);\n\tresult = xmallocz(len);\n\tfor (i = 0; i < len; i++)\n\t\tresult[i] = toupper(string[i]);\n\treturn result;\n}\n\nchar *xstrvfmt(const char *fmt, va_list ap)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tstrbuf_vaddf(&buf, fmt, ap);\n\treturn strbuf_detach(&buf, NULL);\n}\n\nchar *xstrfmt(const char *fmt, ...)\n{\n\tva_list ap;\n\tchar *ret;\n\n\tva_start(ap, fmt);\n\tret = xstrvfmt(fmt, ap);\n\tva_end(ap);\n\n\treturn ret;\n}\n\nvoid strbuf_addftime(struct strbuf *sb, const char *fmt, const struct tm *tm,\n\t\t     int tz_offset, int suppress_tz_name)\n{\n\tstruct strbuf munged_fmt = STRBUF_INIT;\n\tsize_t hint = 128;\n\tsize_t len;\n\n\tif (!*fmt)\n\t\treturn;\n\n\t/*\n\t * There is no portable way to pass timezone information to\n\t * strftime, so we handle %z and %Z here. Likewise '%s', because\n\t * going back to an epoch time requires knowing the zone.\n\t *\n\t * Note that tz_offset is in the \"[-+]HHMM\" decimal form; this is what\n\t * we want for %z, but the computation for %s has to convert to number\n\t * of seconds.\n\t */\n\tfor (;;) {\n\t\tconst char *percent = strchrnul(fmt, '%');\n\t\tstrbuf_add(&munged_fmt, fmt, percent - fmt);\n\t\tif (!*percent)\n\t\t\tbreak;\n\t\tfmt = percent + 1;\n\t\tswitch (*fmt) {\n\t\tcase '%':\n\t\t\tstrbuf_addstr(&munged_fmt, \"%%\");\n\t\t\tfmt++;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tstrbuf_addf(&munged_fmt, \"%\"PRItime,\n\t\t\t\t    (timestamp_t)tm_to_time_t(tm) -\n\t\t\t\t    3600 * (tz_offset / 100) -\n\t\t\t\t    60 * (tz_offset % 100));\n\t\t\tfmt++;\n\t\t\tbreak;\n\t\tcase 'z':\n\t\t\tstrbuf_addf(&munged_fmt, \"%+05d\", tz_offset);\n\t\t\tfmt++;\n\t\t\tbreak;\n\t\tcase 'Z':\n\t\t\tif (suppress_tz_name) {\n\t\t\t\tfmt++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* FALLTHROUGH */\n\t\tdefault:\n\t\t\tstrbuf_addch(&munged_fmt, '%');\n\t\t}\n\t}\n\tfmt = munged_fmt.buf;\n\n\tstrbuf_grow(sb, hint);\n\tlen = strftime(sb->buf + sb->len, sb->alloc - sb->len, fmt, tm);\n\n\tif (!len) {\n\t\t/*\n\t\t * strftime reports \"0\" if it could not fit the result in the buffer.\n\t\t * Unfortunately, it also reports \"0\" if the requested time string\n\t\t * takes 0 bytes. So our strategy is to munge the format so that the\n\t\t * output contains at least one character, and then drop the extra\n\t\t * character before returning.\n\t\t */\n\t\tstrbuf_addch(&munged_fmt, ' ');\n\t\twhile (!len) {\n\t\t\thint *= 2;\n\t\t\tstrbuf_grow(sb, hint);\n\t\t\tlen = strftime(sb->buf + sb->len, sb->alloc - sb->len,\n\t\t\t\t       munged_fmt.buf, tm);\n\t\t}\n\t\tlen--; /* drop munged space */\n\t}\n\tstrbuf_release(&munged_fmt);\n\tstrbuf_setlen(sb, sb->len + len);\n}\n\nvoid strbuf_repo_add_unique_abbrev(struct strbuf *sb, struct repository *repo,\n\t\t\t\t   const struct object_id *oid, int abbrev_len)\n{\n\tint r;\n\tstrbuf_grow(sb, GIT_MAX_HEXSZ + 1);\n\tr = repo_find_unique_abbrev_r(repo, sb->buf + sb->len, oid, abbrev_len);\n\tstrbuf_setlen(sb, sb->len + r);\n}\n\nvoid strbuf_add_unique_abbrev(struct strbuf *sb, const struct object_id *oid,\n\t\t\t      int abbrev_len)\n{\n\tstrbuf_repo_add_unique_abbrev(sb, the_repository, oid, abbrev_len);\n}\n\n/*\n * Returns the length of a line, without trailing spaces.\n *\n * If the line ends with newline, it will be removed too.\n */\nstatic size_t cleanup(char *line, size_t len)\n{\n\twhile (len) {\n\t\tunsigned char c = line[len - 1];\n\t\tif (!isspace(c))\n\t\t\tbreak;\n\t\tlen--;\n\t}\n\n\treturn len;\n}\n\n/*\n * Remove empty lines from the beginning and end\n * and also trailing spaces from every line.\n *\n * Turn multiple consecutive empty lines between paragraphs\n * into just one empty line.\n *\n * If the input has only empty lines and spaces,\n * no output will be produced.\n *\n * If last line does not have a newline at the end, one is added.\n *\n * Enable skip_comments to skip every line starting with comment\n * character.\n */\nvoid strbuf_stripspace(struct strbuf *sb, int skip_comments)\n{\n\tsize_t empties = 0;\n\tsize_t i, j, len, newlen;\n\tchar *eol;\n\n\t/* We may have to add a newline. */\n\tstrbuf_grow(sb, 1);\n\n\tfor (i = j = 0; i < sb->len; i += len, j += newlen) {\n\t\teol = memchr(sb->buf + i, '\\n', sb->len - i);\n\t\tlen = eol ? eol - (sb->buf + i) + 1 : sb->len - i;\n\n\t\tif (skip_comments && len && sb->buf[i] == comment_line_char) {\n\t\t\tnewlen = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tnewlen = cleanup(sb->buf + i, len);\n\n\t\t/* Not just an empty line? */\n\t\tif (newlen) {\n\t\t\tif (empties > 0 && j > 0)\n\t\t\t\tsb->buf[j++] = '\\n';\n\t\t\tempties = 0;\n\t\t\tmemmove(sb->buf + j, sb->buf + i, newlen);\n\t\t\tsb->buf[newlen + j++] = '\\n';\n\t\t} else {\n\t\t\tempties++;\n\t\t}\n\t}\n\n\tstrbuf_setlen(sb, j);\n}\n\nint strbuf_normalize_path(struct strbuf *src)\n{\n\tstruct strbuf dst = STRBUF_INIT;\n\n\tstrbuf_grow(&dst, src->len);\n\tif (normalize_path_copy(dst.buf, src->buf) < 0) {\n\t\tstrbuf_release(&dst);\n\t\treturn -1;\n\t}\n\n\t/*\n\t * normalize_path does not tell us the new length, so we have to\n\t * compute it by looking for the new NUL it placed\n\t */\n\tstrbuf_setlen(&dst, strlen(dst.buf));\n\tstrbuf_swap(src, &dst);\n\tstrbuf_release(&dst);\n\treturn 0;\n}\n\nint strbuf_edit_interactively(struct strbuf *buffer, const char *path,\n\t\t\t      const char *const *env)\n{\n\tchar *path2 = NULL;\n\tint fd, res = 0;\n\n\tif (!is_absolute_path(path))\n\t\tpath = path2 = xstrdup(git_path(\"%s\", path));\n\n\tfd = open(path, O_WRONLY | O_CREAT | O_TRUNC, 0666);\n\tif (fd < 0)\n\t\tres = error_errno(_(\"could not open '%s' for writing\"), path);\n\telse if (write_in_full(fd, buffer->buf, buffer->len) < 0) {\n\t\tres = error_errno(_(\"could not write to '%s'\"), path);\n\t\tclose(fd);\n\t} else if (close(fd) < 0)\n\t\tres = error_errno(_(\"could not close '%s'\"), path);\n\telse {\n\t\tstrbuf_reset(buffer);\n\t\tif (launch_editor(path, buffer, env) < 0)\n\t\t\tres = error_errno(_(\"could not edit '%s'\"), path);\n\t\tunlink(path);\n\t}\n\n\tfree(path2);\n\treturn res;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00abeb55afdd68089676d2007fbfd248b5a45e79",
  "sha1_ok": true,
  "size": 26503
}
