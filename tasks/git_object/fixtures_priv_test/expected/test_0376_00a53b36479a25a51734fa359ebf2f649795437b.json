{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJyZWZzLmgiCiNpbmNsdWRlICJ0YWcuaCIKI2luY2x1ZGUgImNvbW1pdC5oIgojaW5jbHVkZSAidHJlZS5oIgojaW5jbHVkZSAiYmxvYi5oIgojaW5jbHVkZSAidHJlZS13YWxrLmgiCiNpbmNsdWRlICJkaWZmLmgiCiNpbmNsdWRlICJyZXZpc2lvbi5oIgojaW5jbHVkZSAiYnVpbHRpbi5oIgojaW5jbHVkZSAiY2FjaGUtdHJlZS5oIgoKc3RhdGljIGNvbnN0IGNoYXIgcHJ1bmVfdXNhZ2VbXSA9ICJnaXQtcHJ1bmUgWy1uXSI7CnN0YXRpYyBpbnQgc2hvd19vbmx5OwpzdGF0aWMgc3RydWN0IHJldl9pbmZvIHJldnM7CgpzdGF0aWMgaW50IHBydW5lX29iamVjdChjaGFyICpwYXRoLCBjb25zdCBjaGFyICpmaWxlbmFtZSwgY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSkKewoJY2hhciBidWZbMjBdOwoJY29uc3QgY2hhciAqdHlwZTsKCglpZiAoc2hvd19vbmx5KSB7CgkJaWYgKHNoYTFfb2JqZWN0X2luZm8oc2hhMSwgYnVmLCBOVUxMKSkKCQkJdHlwZSA9ICJ1bmtub3duIjsKCQllbHNlCgkJCXR5cGUgPSBidWY7CgkJcHJpbnRmKCIlcyAlc1xuIiwgc2hhMV90b19oZXgoc2hhMSksIHR5cGUpOwoJCXJldHVybiAwOwoJfQoJdW5saW5rKG1rcGF0aCgiJXMvJXMiLCBwYXRoLCBmaWxlbmFtZSkpOwoJcm1kaXIocGF0aCk7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBwcnVuZV9kaXIoaW50IGksIGNoYXIgKnBhdGgpCnsKCURJUiAqZGlyID0gb3BlbmRpcihwYXRoKTsKCXN0cnVjdCBkaXJlbnQgKmRlOwoKCWlmICghZGlyKQoJCXJldHVybiAwOwoKCXdoaWxlICgoZGUgPSByZWFkZGlyKGRpcikpICE9IE5VTEwpIHsKCQljaGFyIG5hbWVbMTAwXTsKCQl1bnNpZ25lZCBjaGFyIHNoYTFbMjBdOwoJCWludCBsZW4gPSBzdHJsZW4oZGUtPmRfbmFtZSk7CgoJCXN3aXRjaCAobGVuKSB7CgkJY2FzZSAyOgoJCQlpZiAoZGUtPmRfbmFtZVsxXSAhPSAnLicpCgkJCQlicmVhazsKCQljYXNlIDE6CgkJCWlmIChkZS0+ZF9uYW1lWzBdICE9ICcuJykKCQkJCWJyZWFrOwoJCQljb250aW51ZTsKCQljYXNlIDM4OgoJCQlzcHJpbnRmKG5hbWUsICIlMDJ4IiwgaSk7CgkJCW1lbWNweShuYW1lKzIsIGRlLT5kX25hbWUsIGxlbisxKTsKCQkJaWYgKGdldF9zaGExX2hleChuYW1lLCBzaGExKSA8IDApCgkJCQlicmVhazsKCgkJCS8qCgkJCSAqIERvIHdlIGtub3cgYWJvdXQgdGhpcyBvYmplY3Q/CgkJCSAqIEl0IG11c3QgaGF2ZSBiZWVuIHJlYWNoYWJsZQoJCQkgKi8KCQkJaWYgKGxvb2t1cF9vYmplY3Qoc2hhMSkpCgkJCQljb250aW51ZTsKCgkJCXBydW5lX29iamVjdChwYXRoLCBkZS0+ZF9uYW1lLCBzaGExKTsKCQkJY29udGludWU7CgkJfQoJCWZwcmludGYoc3RkZXJyLCAiYmFkIHNoYTEgZmlsZTogJXMvJXNcbiIsIHBhdGgsIGRlLT5kX25hbWUpOwoJfQoJY2xvc2VkaXIoZGlyKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgdm9pZCBwcnVuZV9vYmplY3RfZGlyKGNvbnN0IGNoYXIgKnBhdGgpCnsKCWludCBpOwoJZm9yIChpID0gMDsgaSA8IDI1NjsgaSsrKSB7CgkJc3RhdGljIGNoYXIgZGlyWzQwOTZdOwoJCXNwcmludGYoZGlyLCAiJXMvJTAyeCIsIHBhdGgsIGkpOwoJCXBydW5lX2RpcihpLCBkaXIpOwoJfQp9CgpzdGF0aWMgdm9pZCBwcm9jZXNzX2Jsb2Ioc3RydWN0IGJsb2IgKmJsb2IsCgkJCSBzdHJ1Y3Qgb2JqZWN0X2FycmF5ICpwLAoJCQkgc3RydWN0IG5hbWVfcGF0aCAqcGF0aCwKCQkJIGNvbnN0IGNoYXIgKm5hbWUpCnsKCXN0cnVjdCBvYmplY3QgKm9iaiA9ICZibG9iLT5vYmplY3Q7CgoJaWYgKG9iai0+ZmxhZ3MgJiBTRUVOKQoJCXJldHVybjsKCW9iai0+ZmxhZ3MgfD0gU0VFTjsKCS8qIE5vdGhpbmcgdG8gZG8sIHJlYWxseSAuLiBUaGUgYmxvYiBsb29rdXAgd2FzIHRoZSBpbXBvcnRhbnQgcGFydCAqLwp9CgpzdGF0aWMgdm9pZCBwcm9jZXNzX3RyZWUoc3RydWN0IHRyZWUgKnRyZWUsCgkJCSBzdHJ1Y3Qgb2JqZWN0X2FycmF5ICpwLAoJCQkgc3RydWN0IG5hbWVfcGF0aCAqcGF0aCwKCQkJIGNvbnN0IGNoYXIgKm5hbWUpCnsKCXN0cnVjdCBvYmplY3QgKm9iaiA9ICZ0cmVlLT5vYmplY3Q7CglzdHJ1Y3QgdHJlZV9kZXNjIGRlc2M7CglzdHJ1Y3QgbmFtZV9lbnRyeSBlbnRyeTsKCXN0cnVjdCBuYW1lX3BhdGggbWU7CgoJaWYgKG9iai0+ZmxhZ3MgJiBTRUVOKQoJCXJldHVybjsKCW9iai0+ZmxhZ3MgfD0gU0VFTjsKCWlmIChwYXJzZV90cmVlKHRyZWUpIDwgMCkKCQlkaWUoImJhZCB0cmVlIG9iamVjdCAlcyIsIHNoYTFfdG9faGV4KG9iai0+c2hhMSkpOwoJbmFtZSA9IHhzdHJkdXAobmFtZSk7CglhZGRfb2JqZWN0KG9iaiwgcCwgcGF0aCwgbmFtZSk7CgltZS51cCA9IHBhdGg7CgltZS5lbGVtID0gbmFtZTsKCW1lLmVsZW1fbGVuID0gc3RybGVuKG5hbWUpOwoKCWRlc2MuYnVmID0gdHJlZS0+YnVmZmVyOwoJZGVzYy5zaXplID0gdHJlZS0+c2l6ZTsKCgl3aGlsZSAodHJlZV9lbnRyeSgmZGVzYywgJmVudHJ5KSkgewoJCWlmIChTX0lTRElSKGVudHJ5Lm1vZGUpKQoJCQlwcm9jZXNzX3RyZWUobG9va3VwX3RyZWUoZW50cnkuc2hhMSksIHAsICZtZSwgZW50cnkucGF0aCk7CgkJZWxzZQoJCQlwcm9jZXNzX2Jsb2IobG9va3VwX2Jsb2IoZW50cnkuc2hhMSksIHAsICZtZSwgZW50cnkucGF0aCk7Cgl9CglmcmVlKHRyZWUtPmJ1ZmZlcik7Cgl0cmVlLT5idWZmZXIgPSBOVUxMOwp9CgpzdGF0aWMgdm9pZCBwcm9jZXNzX3RhZyhzdHJ1Y3QgdGFnICp0YWcsIHN0cnVjdCBvYmplY3RfYXJyYXkgKnAsIGNvbnN0IGNoYXIgKm5hbWUpCnsKCXN0cnVjdCBvYmplY3QgKm9iaiA9ICZ0YWctPm9iamVjdDsKCXN0cnVjdCBuYW1lX3BhdGggbWU7CgoJaWYgKG9iai0+ZmxhZ3MgJiBTRUVOKQoJCXJldHVybjsKCW9iai0+ZmxhZ3MgfD0gU0VFTjsKCgltZS51cCA9IE5VTEw7CgltZS5lbGVtID0gInRhZzovIjsKCW1lLmVsZW1fbGVuID0gNTsKCglpZiAocGFyc2VfdGFnKHRhZykgPCAwKQoJCWRpZSgiYmFkIHRhZyBvYmplY3QgJXMiLCBzaGExX3RvX2hleChvYmotPnNoYTEpKTsKCWFkZF9vYmplY3QodGFnLT50YWdnZWQsIHAsIE5VTEwsIG5hbWUpOwp9CgpzdGF0aWMgdm9pZCB3YWxrX2NvbW1pdF9saXN0KHN0cnVjdCByZXZfaW5mbyAqcmV2cykKewoJaW50IGk7CglzdHJ1Y3QgY29tbWl0ICpjb21taXQ7CglzdHJ1Y3Qgb2JqZWN0X2FycmF5IG9iamVjdHMgPSB7IDAsIDAsIE5VTEwgfTsKCgkvKiBXYWxrIGFsbCBjb21taXRzLCBwcm9jZXNzIHRoZWlyIHRyZWVzICovCgl3aGlsZSAoKGNvbW1pdCA9IGdldF9yZXZpc2lvbihyZXZzKSkgIT0gTlVMTCkKCQlwcm9jZXNzX3RyZWUoY29tbWl0LT50cmVlLCAmb2JqZWN0cywgTlVMTCwgIiIpOwoKCS8qIFRoZW4gd2FsayBhbGwgdGhlIHBlbmRpbmcgb2JqZWN0cywgcmVjdXJzaXZlbHkgcHJvY2Vzc2luZyB0aGVtIHRvbyAqLwoJZm9yIChpID0gMDsgaSA8IHJldnMtPnBlbmRpbmcubnI7IGkrKykgewoJCXN0cnVjdCBvYmplY3RfYXJyYXlfZW50cnkgKnBlbmRpbmcgPSByZXZzLT5wZW5kaW5nLm9iamVjdHMgKyBpOwoJCXN0cnVjdCBvYmplY3QgKm9iaiA9IHBlbmRpbmctPml0ZW07CgkJY29uc3QgY2hhciAqbmFtZSA9IHBlbmRpbmctPm5hbWU7CgkJaWYgKG9iai0+dHlwZSA9PSBPQkpfVEFHKSB7CgkJCXByb2Nlc3NfdGFnKChzdHJ1Y3QgdGFnICopIG9iaiwgJm9iamVjdHMsIG5hbWUpOwoJCQljb250aW51ZTsKCQl9CgkJaWYgKG9iai0+dHlwZSA9PSBPQkpfVFJFRSkgewoJCQlwcm9jZXNzX3RyZWUoKHN0cnVjdCB0cmVlICopb2JqLCAmb2JqZWN0cywgTlVMTCwgbmFtZSk7CgkJCWNvbnRpbnVlOwoJCX0KCQlpZiAob2JqLT50eXBlID09IE9CSl9CTE9CKSB7CgkJCXByb2Nlc3NfYmxvYigoc3RydWN0IGJsb2IgKilvYmosICZvYmplY3RzLCBOVUxMLCBuYW1lKTsKCQkJY29udGludWU7CgkJfQoJCWRpZSgidW5rbm93biBwZW5kaW5nIG9iamVjdCAlcyAoJXMpIiwgc2hhMV90b19oZXgob2JqLT5zaGExKSwgbmFtZSk7Cgl9Cn0KCnN0YXRpYyBpbnQgYWRkX29uZV9yZWZsb2dfZW50KHVuc2lnbmVkIGNoYXIgKm9zaGExLCB1bnNpZ25lZCBjaGFyICpuc2hhMSwgY2hhciAqZGF0YWlsLCB2b2lkICpjYl9kYXRhKQp7CglzdHJ1Y3Qgb2JqZWN0ICpvYmplY3Q7CgoJb2JqZWN0ID0gcGFyc2Vfb2JqZWN0KG9zaGExKTsKCWlmIChvYmplY3QpCgkJYWRkX3BlbmRpbmdfb2JqZWN0KCZyZXZzLCBvYmplY3QsICIiKTsKCW9iamVjdCA9IHBhcnNlX29iamVjdChuc2hhMSk7CglpZiAob2JqZWN0KQoJCWFkZF9wZW5kaW5nX29iamVjdCgmcmV2cywgb2JqZWN0LCAiIik7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBhZGRfb25lX3JlZihjb25zdCBjaGFyICpwYXRoLCBjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExLCBpbnQgZmxhZywgdm9pZCAqY2JfZGF0YSkKewoJc3RydWN0IG9iamVjdCAqb2JqZWN0ID0gcGFyc2Vfb2JqZWN0KHNoYTEpOwoJaWYgKCFvYmplY3QpCgkJZGllKCJiYWQgb2JqZWN0IHJlZjogJXM6JXMiLCBwYXRoLCBzaGExX3RvX2hleChzaGExKSk7CglhZGRfcGVuZGluZ19vYmplY3QoJnJldnMsIG9iamVjdCwgIiIpOwoKCWZvcl9lYWNoX3JlZmxvZ19lbnQocGF0aCwgYWRkX29uZV9yZWZsb2dfZW50LCBOVUxMKTsKCglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgYWRkX29uZV90cmVlKGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEpCnsKCXN0cnVjdCB0cmVlICp0cmVlID0gbG9va3VwX3RyZWUoc2hhMSk7CglhZGRfcGVuZGluZ19vYmplY3QoJnJldnMsICZ0cmVlLT5vYmplY3QsICIiKTsKfQoKc3RhdGljIHZvaWQgYWRkX2NhY2hlX3RyZWUoc3RydWN0IGNhY2hlX3RyZWUgKml0KQp7CglpbnQgaTsKCglpZiAoaXQtPmVudHJ5X2NvdW50ID49IDApCgkJYWRkX29uZV90cmVlKGl0LT5zaGExKTsKCWZvciAoaSA9IDA7IGkgPCBpdC0+c3VidHJlZV9ucjsgaSsrKQoJCWFkZF9jYWNoZV90cmVlKGl0LT5kb3duW2ldLT5jYWNoZV90cmVlKTsKfQoKc3RhdGljIHZvaWQgYWRkX2NhY2hlX3JlZnModm9pZCkKewoJaW50IGk7CgoJcmVhZF9jYWNoZSgpOwoJZm9yIChpID0gMDsgaSA8IGFjdGl2ZV9ucjsgaSsrKSB7CgkJbG9va3VwX2Jsb2IoYWN0aXZlX2NhY2hlW2ldLT5zaGExKTsKCQkvKgoJCSAqIFdlIGNvdWxkIGFkZCB0aGUgYmxvYnMgdG8gdGhlIHBlbmRpbmcgbGlzdCwgYnV0IHF1aXRlCgkJICogZnJhbmtseSwgd2UgZG9uJ3QgY2FyZS4gT25jZSB3ZSd2ZSBsb29rZWQgdGhlbSB1cCwgYW5kCgkJICogYWRkZWQgdGhlbSBhcyBvYmplY3RzLCB3ZSd2ZSByZWFsbHkgZG9uZSBldmVyeXRoaW5nCgkJICogdGhlcmUgaXMgdG8gZG8gZm9yIGEgYmxvYgoJCSAqLwoJfQoJaWYgKGFjdGl2ZV9jYWNoZV90cmVlKQoJCWFkZF9jYWNoZV90cmVlKGFjdGl2ZV9jYWNoZV90cmVlKTsKfQoKaW50IGNtZF9wcnVuZShpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsIGNvbnN0IGNoYXIgKnByZWZpeCkKewoJaW50IGk7CgoJZm9yIChpID0gMTsgaSA8IGFyZ2M7IGkrKykgewoJCWNvbnN0IGNoYXIgKmFyZyA9IGFyZ3ZbaV07CgkJaWYgKCFzdHJjbXAoYXJnLCAiLW4iKSkgewoJCQlzaG93X29ubHkgPSAxOwoJCQljb250aW51ZTsKCQl9CgkJdXNhZ2UocHJ1bmVfdXNhZ2UpOwoJfQoKCS8qCgkgKiBTZXQgdXAgcmV2aXNpb24gcGFyc2luZywgYW5kIG1hcmsgdXMgYXMgYmVpbmcgaW50ZXJlc3RlZAoJICogaW4gYWxsIG9iamVjdCB0eXBlcywgbm90IGp1c3QgY29tbWl0cy4KCSAqLwoJaW5pdF9yZXZpc2lvbnMoJnJldnMsIHByZWZpeCk7CglyZXZzLnRhZ19vYmplY3RzID0gMTsKCXJldnMuYmxvYl9vYmplY3RzID0gMTsKCXJldnMudHJlZV9vYmplY3RzID0gMTsKCgkvKiBBZGQgYWxsIGV4dGVybmFsIHJlZnMgKi8KCWZvcl9lYWNoX3JlZihhZGRfb25lX3JlZiwgTlVMTCk7CgoJLyogQWRkIGFsbCByZWZzIGZyb20gdGhlIGluZGV4IGZpbGUgKi8KCWFkZF9jYWNoZV9yZWZzKCk7CgoJLyoKCSAqIFNldCB1cCB0aGUgcmV2aXNpb24gd2FsayAtIHRoaXMgd2lsbCBtb3ZlIGFsbCBjb21taXRzCgkgKiBmcm9tIHRoZSBwZW5kaW5nIGxpc3QgdG8gdGhlIGNvbW1pdCB3YWxraW5nIGxpc3QuCgkgKi8KCXByZXBhcmVfcmV2aXNpb25fd2FsaygmcmV2cyk7CgoJd2Fsa19jb21taXRfbGlzdCgmcmV2cyk7CgoJcHJ1bmVfb2JqZWN0X2RpcihnZXRfb2JqZWN0X2RpcmVjdG9yeSgpKTsKCglzeW5jKCk7CglwcnVuZV9wYWNrZWRfb2JqZWN0cyhzaG93X29ubHkpOwoJcmV0dXJuIDA7Cn0K",
    "text": "#include \"cache.h\"\n#include \"refs.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"tree.h\"\n#include \"blob.h\"\n#include \"tree-walk.h\"\n#include \"diff.h\"\n#include \"revision.h\"\n#include \"builtin.h\"\n#include \"cache-tree.h\"\n\nstatic const char prune_usage[] = \"git-prune [-n]\";\nstatic int show_only;\nstatic struct rev_info revs;\n\nstatic int prune_object(char *path, const char *filename, const unsigned char *sha1)\n{\n\tchar buf[20];\n\tconst char *type;\n\n\tif (show_only) {\n\t\tif (sha1_object_info(sha1, buf, NULL))\n\t\t\ttype = \"unknown\";\n\t\telse\n\t\t\ttype = buf;\n\t\tprintf(\"%s %s\\n\", sha1_to_hex(sha1), type);\n\t\treturn 0;\n\t}\n\tunlink(mkpath(\"%s/%s\", path, filename));\n\trmdir(path);\n\treturn 0;\n}\n\nstatic int prune_dir(int i, char *path)\n{\n\tDIR *dir = opendir(path);\n\tstruct dirent *de;\n\n\tif (!dir)\n\t\treturn 0;\n\n\twhile ((de = readdir(dir)) != NULL) {\n\t\tchar name[100];\n\t\tunsigned char sha1[20];\n\t\tint len = strlen(de->d_name);\n\n\t\tswitch (len) {\n\t\tcase 2:\n\t\t\tif (de->d_name[1] != '.')\n\t\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (de->d_name[0] != '.')\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\tcase 38:\n\t\t\tsprintf(name, \"%02x\", i);\n\t\t\tmemcpy(name+2, de->d_name, len+1);\n\t\t\tif (get_sha1_hex(name, sha1) < 0)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * Do we know about this object?\n\t\t\t * It must have been reachable\n\t\t\t */\n\t\t\tif (lookup_object(sha1))\n\t\t\t\tcontinue;\n\n\t\t\tprune_object(path, de->d_name, sha1);\n\t\t\tcontinue;\n\t\t}\n\t\tfprintf(stderr, \"bad sha1 file: %s/%s\\n\", path, de->d_name);\n\t}\n\tclosedir(dir);\n\treturn 0;\n}\n\nstatic void prune_object_dir(const char *path)\n{\n\tint i;\n\tfor (i = 0; i < 256; i++) {\n\t\tstatic char dir[4096];\n\t\tsprintf(dir, \"%s/%02x\", path, i);\n\t\tprune_dir(i, dir);\n\t}\n}\n\nstatic void process_blob(struct blob *blob,\n\t\t\t struct object_array *p,\n\t\t\t struct name_path *path,\n\t\t\t const char *name)\n{\n\tstruct object *obj = &blob->object;\n\n\tif (obj->flags & SEEN)\n\t\treturn;\n\tobj->flags |= SEEN;\n\t/* Nothing to do, really .. The blob lookup was the important part */\n}\n\nstatic void process_tree(struct tree *tree,\n\t\t\t struct object_array *p,\n\t\t\t struct name_path *path,\n\t\t\t const char *name)\n{\n\tstruct object *obj = &tree->object;\n\tstruct tree_desc desc;\n\tstruct name_entry entry;\n\tstruct name_path me;\n\n\tif (obj->flags & SEEN)\n\t\treturn;\n\tobj->flags |= SEEN;\n\tif (parse_tree(tree) < 0)\n\t\tdie(\"bad tree object %s\", sha1_to_hex(obj->sha1));\n\tname = xstrdup(name);\n\tadd_object(obj, p, path, name);\n\tme.up = path;\n\tme.elem = name;\n\tme.elem_len = strlen(name);\n\n\tdesc.buf = tree->buffer;\n\tdesc.size = tree->size;\n\n\twhile (tree_entry(&desc, &entry)) {\n\t\tif (S_ISDIR(entry.mode))\n\t\t\tprocess_tree(lookup_tree(entry.sha1), p, &me, entry.path);\n\t\telse\n\t\t\tprocess_blob(lookup_blob(entry.sha1), p, &me, entry.path);\n\t}\n\tfree(tree->buffer);\n\ttree->buffer = NULL;\n}\n\nstatic void process_tag(struct tag *tag, struct object_array *p, const char *name)\n{\n\tstruct object *obj = &tag->object;\n\tstruct name_path me;\n\n\tif (obj->flags & SEEN)\n\t\treturn;\n\tobj->flags |= SEEN;\n\n\tme.up = NULL;\n\tme.elem = \"tag:/\";\n\tme.elem_len = 5;\n\n\tif (parse_tag(tag) < 0)\n\t\tdie(\"bad tag object %s\", sha1_to_hex(obj->sha1));\n\tadd_object(tag->tagged, p, NULL, name);\n}\n\nstatic void walk_commit_list(struct rev_info *revs)\n{\n\tint i;\n\tstruct commit *commit;\n\tstruct object_array objects = { 0, 0, NULL };\n\n\t/* Walk all commits, process their trees */\n\twhile ((commit = get_revision(revs)) != NULL)\n\t\tprocess_tree(commit->tree, &objects, NULL, \"\");\n\n\t/* Then walk all the pending objects, recursively processing them too */\n\tfor (i = 0; i < revs->pending.nr; i++) {\n\t\tstruct object_array_entry *pending = revs->pending.objects + i;\n\t\tstruct object *obj = pending->item;\n\t\tconst char *name = pending->name;\n\t\tif (obj->type == OBJ_TAG) {\n\t\t\tprocess_tag((struct tag *) obj, &objects, name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (obj->type == OBJ_TREE) {\n\t\t\tprocess_tree((struct tree *)obj, &objects, NULL, name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (obj->type == OBJ_BLOB) {\n\t\t\tprocess_blob((struct blob *)obj, &objects, NULL, name);\n\t\t\tcontinue;\n\t\t}\n\t\tdie(\"unknown pending object %s (%s)\", sha1_to_hex(obj->sha1), name);\n\t}\n}\n\nstatic int add_one_reflog_ent(unsigned char *osha1, unsigned char *nsha1, char *datail, void *cb_data)\n{\n\tstruct object *object;\n\n\tobject = parse_object(osha1);\n\tif (object)\n\t\tadd_pending_object(&revs, object, \"\");\n\tobject = parse_object(nsha1);\n\tif (object)\n\t\tadd_pending_object(&revs, object, \"\");\n\treturn 0;\n}\n\nstatic int add_one_ref(const char *path, const unsigned char *sha1, int flag, void *cb_data)\n{\n\tstruct object *object = parse_object(sha1);\n\tif (!object)\n\t\tdie(\"bad object ref: %s:%s\", path, sha1_to_hex(sha1));\n\tadd_pending_object(&revs, object, \"\");\n\n\tfor_each_reflog_ent(path, add_one_reflog_ent, NULL);\n\n\treturn 0;\n}\n\nstatic void add_one_tree(const unsigned char *sha1)\n{\n\tstruct tree *tree = lookup_tree(sha1);\n\tadd_pending_object(&revs, &tree->object, \"\");\n}\n\nstatic void add_cache_tree(struct cache_tree *it)\n{\n\tint i;\n\n\tif (it->entry_count >= 0)\n\t\tadd_one_tree(it->sha1);\n\tfor (i = 0; i < it->subtree_nr; i++)\n\t\tadd_cache_tree(it->down[i]->cache_tree);\n}\n\nstatic void add_cache_refs(void)\n{\n\tint i;\n\n\tread_cache();\n\tfor (i = 0; i < active_nr; i++) {\n\t\tlookup_blob(active_cache[i]->sha1);\n\t\t/*\n\t\t * We could add the blobs to the pending list, but quite\n\t\t * frankly, we don't care. Once we've looked them up, and\n\t\t * added them as objects, we've really done everything\n\t\t * there is to do for a blob\n\t\t */\n\t}\n\tif (active_cache_tree)\n\t\tadd_cache_tree(active_cache_tree);\n}\n\nint cmd_prune(int argc, const char **argv, const char *prefix)\n{\n\tint i;\n\n\tfor (i = 1; i < argc; i++) {\n\t\tconst char *arg = argv[i];\n\t\tif (!strcmp(arg, \"-n\")) {\n\t\t\tshow_only = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tusage(prune_usage);\n\t}\n\n\t/*\n\t * Set up revision parsing, and mark us as being interested\n\t * in all object types, not just commits.\n\t */\n\tinit_revisions(&revs, prefix);\n\trevs.tag_objects = 1;\n\trevs.blob_objects = 1;\n\trevs.tree_objects = 1;\n\n\t/* Add all external refs */\n\tfor_each_ref(add_one_ref, NULL);\n\n\t/* Add all refs from the index file */\n\tadd_cache_refs();\n\n\t/*\n\t * Set up the revision walk - this will move all commits\n\t * from the pending list to the commit walking list.\n\t */\n\tprepare_revision_walk(&revs);\n\n\twalk_commit_list(&revs);\n\n\tprune_object_dir(get_object_directory());\n\n\tsync();\n\tprune_packed_objects(show_only);\n\treturn 0;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00a53b36479a25a51734fa359ebf2f649795437b",
  "sha1_ok": true,
  "size": 6228
}
