{
  "content": {
    "base64": "I2luY2x1ZGUgImJ1aWx0aW4uaCIKI2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJyZWZzLmgiCiNpbmNsdWRlICJvYmplY3QuaCIKI2luY2x1ZGUgInRhZy5oIgojaW5jbHVkZSAiY29tbWl0LmgiCiNpbmNsdWRlICJ0cmVlLmgiCiNpbmNsdWRlICJibG9iLmgiCiNpbmNsdWRlICJxdW90ZS5oIgojaW5jbHVkZSAicGFyc2Utb3B0aW9ucy5oIgojaW5jbHVkZSAicmVtb3RlLmgiCiNpbmNsdWRlICJjb2xvci5oIgoKLyogUXVvdGluZyBzdHlsZXMgKi8KI2RlZmluZSBRVU9URV9OT05FIDAKI2RlZmluZSBRVU9URV9TSEVMTCAxCiNkZWZpbmUgUVVPVEVfUEVSTCAyCiNkZWZpbmUgUVVPVEVfUFlUSE9OIDQKI2RlZmluZSBRVU9URV9UQ0wgOAoKdHlwZWRlZiBlbnVtIHsgRklFTERfU1RSLCBGSUVMRF9VTE9ORywgRklFTERfVElNRSB9IGNtcF90eXBlOwoKc3RydWN0IGF0b21fdmFsdWUgewoJY29uc3QgY2hhciAqczsKCXVuc2lnbmVkIGxvbmcgdWw7IC8qIHVzZWQgZm9yIHNvcnRpbmcgd2hlbiBub3QgRklFTERfU1RSICovCn07CgpzdHJ1Y3QgcmVmX3NvcnQgewoJc3RydWN0IHJlZl9zb3J0ICpuZXh0OwoJaW50IGF0b207IC8qIGluZGV4IGludG8gdXNlZF9hdG9tIGFycmF5ICovCgl1bnNpZ25lZCByZXZlcnNlIDogMTsKfTsKCnN0cnVjdCByZWZpbmZvIHsKCWNoYXIgKnJlZm5hbWU7Cgl1bnNpZ25lZCBjaGFyIG9iamVjdG5hbWVbMjBdOwoJaW50IGZsYWc7Cgljb25zdCBjaGFyICpzeW1yZWY7CglzdHJ1Y3QgYXRvbV92YWx1ZSAqdmFsdWU7Cn07CgpzdGF0aWMgc3RydWN0IHsKCWNvbnN0IGNoYXIgKm5hbWU7CgljbXBfdHlwZSBjbXBfdHlwZTsKfSB2YWxpZF9hdG9tW10gPSB7Cgl7ICJyZWZuYW1lIiB9LAoJeyAib2JqZWN0dHlwZSIgfSwKCXsgIm9iamVjdHNpemUiLCBGSUVMRF9VTE9ORyB9LAoJeyAib2JqZWN0bmFtZSIgfSwKCXsgInRyZWUiIH0sCgl7ICJwYXJlbnQiIH0sCgl7ICJudW1wYXJlbnQiLCBGSUVMRF9VTE9ORyB9LAoJeyAib2JqZWN0IiB9LAoJeyAidHlwZSIgfSwKCXsgInRhZyIgfSwKCXsgImF1dGhvciIgfSwKCXsgImF1dGhvcm5hbWUiIH0sCgl7ICJhdXRob3JlbWFpbCIgfSwKCXsgImF1dGhvcmRhdGUiLCBGSUVMRF9USU1FIH0sCgl7ICJjb21taXR0ZXIiIH0sCgl7ICJjb21taXR0ZXJuYW1lIiB9LAoJeyAiY29tbWl0dGVyZW1haWwiIH0sCgl7ICJjb21taXR0ZXJkYXRlIiwgRklFTERfVElNRSB9LAoJeyAidGFnZ2VyIiB9LAoJeyAidGFnZ2VybmFtZSIgfSwKCXsgInRhZ2dlcmVtYWlsIiB9LAoJeyAidGFnZ2VyZGF0ZSIsIEZJRUxEX1RJTUUgfSwKCXsgImNyZWF0b3IiIH0sCgl7ICJjcmVhdG9yZGF0ZSIsIEZJRUxEX1RJTUUgfSwKCXsgInN1YmplY3QiIH0sCgl7ICJib2R5IiB9LAoJeyAiY29udGVudHMiIH0sCgl7ICJjb250ZW50czpzdWJqZWN0IiB9LAoJeyAiY29udGVudHM6Ym9keSIgfSwKCXsgImNvbnRlbnRzOnNpZ25hdHVyZSIgfSwKCXsgInVwc3RyZWFtIiB9LAoJeyAic3ltcmVmIiB9LAoJeyAiZmxhZyIgfSwKCXsgIkhFQUQiIH0sCgl7ICJjb2xvciIgfSwKfTsKCi8qCiAqIEFuIGF0b20gaXMgYSB2YWxpZCBmaWVsZCBhdG9tIGxpc3RlZCBhYm92ZSwgcG9zc2libHkgcHJlZml4ZWQgd2l0aAogKiBhICIqIiB0byBkZW5vdGUgZGVyZWZfdGFnKCkuCiAqCiAqIFdlIHBhcnNlIGdpdmVuIGZvcm1hdCBzdHJpbmcgYW5kIHNvcnQgc3BlY2lmaWVycywgYW5kIG1ha2UgYSBsaXN0CiAqIG9mIHByb3BlcnRpZXMgdGhhdCB3ZSBuZWVkIHRvIGV4dHJhY3Qgb3V0IG9mIG9iamVjdHMuICByZWZpbmZvCiAqIHN0cnVjdHVyZSB3aWxsIGhvbGQgYW4gYXJyYXkgb2YgdmFsdWVzIGV4dHJhY3RlZCB0aGF0IGNhbiBiZQogKiBpbmRleGVkIHdpdGggdGhlICJhdG9tIG51bWJlciIsIHdoaWNoIGlzIGFuIGluZGV4IGludG8gdGhpcwogKiBhcnJheS4KICovCnN0YXRpYyBjb25zdCBjaGFyICoqdXNlZF9hdG9tOwpzdGF0aWMgY21wX3R5cGUgKnVzZWRfYXRvbV90eXBlOwpzdGF0aWMgaW50IHVzZWRfYXRvbV9jbnQsIG5lZWRfdGFnZ2VkLCBuZWVkX3N5bXJlZjsKc3RhdGljIGludCBuZWVkX2NvbG9yX3Jlc2V0X2F0X2VvbDsKCi8qCiAqIFVzZWQgdG8gcGFyc2UgZm9ybWF0IHN0cmluZyBhbmQgc29ydCBzcGVjaWZpZXJzCiAqLwpzdGF0aWMgaW50IHBhcnNlX2F0b20oY29uc3QgY2hhciAqYXRvbSwgY29uc3QgY2hhciAqZXApCnsKCWNvbnN0IGNoYXIgKnNwOwoJaW50IGksIGF0OwoKCXNwID0gYXRvbTsKCWlmICgqc3AgPT0gJyonICYmIHNwIDwgZXApCgkJc3ArKzsgLyogZGVyZWYgKi8KCWlmIChlcCA8PSBzcCkKCQlkaWUoIm1hbGZvcm1lZCBmaWVsZCBuYW1lOiAlLipzIiwgKGludCkoZXAtYXRvbSksIGF0b20pOwoKCS8qIERvIHdlIGhhdmUgdGhlIGF0b20gYWxyZWFkeSB1c2VkIGVsc2V3aGVyZT8gKi8KCWZvciAoaSA9IDA7IGkgPCB1c2VkX2F0b21fY250OyBpKyspIHsKCQlpbnQgbGVuID0gc3RybGVuKHVzZWRfYXRvbVtpXSk7CgkJaWYgKGxlbiA9PSBlcCAtIGF0b20gJiYgIW1lbWNtcCh1c2VkX2F0b21baV0sIGF0b20sIGxlbikpCgkJCXJldHVybiBpOwoJfQoKCS8qIElzIHRoZSBhdG9tIGEgdmFsaWQgb25lPyAqLwoJZm9yIChpID0gMDsgaSA8IEFSUkFZX1NJWkUodmFsaWRfYXRvbSk7IGkrKykgewoJCWludCBsZW4gPSBzdHJsZW4odmFsaWRfYXRvbVtpXS5uYW1lKTsKCQkvKgoJCSAqIElmIHRoZSBhdG9tIG5hbWUgaGFzIGEgY29sb24sIHN0cmlwIGl0IGFuZCBldmVyeXRoaW5nIGFmdGVyCgkJICogaXQgb2ZmIC0gaXQgc3BlY2lmaWVzIHRoZSBmb3JtYXQgZm9yIHRoaXMgZW50cnksIGFuZAoJCSAqIHNob3VsZG4ndCBiZSB1c2VkIGZvciBjaGVja2luZyBhZ2FpbnN0IHRoZSB2YWxpZF9hdG9tCgkJICogdGFibGUuCgkJICovCgkJY29uc3QgY2hhciAqZm9ybWF0cCA9IHN0cmNocihzcCwgJzonKTsKCQlpZiAoIWZvcm1hdHAgfHwgZXAgPCBmb3JtYXRwKQoJCQlmb3JtYXRwID0gZXA7CgkJaWYgKGxlbiA9PSBmb3JtYXRwIC0gc3AgJiYgIW1lbWNtcCh2YWxpZF9hdG9tW2ldLm5hbWUsIHNwLCBsZW4pKQoJCQlicmVhazsKCX0KCglpZiAoQVJSQVlfU0laRSh2YWxpZF9hdG9tKSA8PSBpKQoJCWRpZSgidW5rbm93biBmaWVsZCBuYW1lOiAlLipzIiwgKGludCkoZXAtYXRvbSksIGF0b20pOwoKCS8qIEFkZCBpdCBpbiwgaW5jbHVkaW5nIHRoZSBkZXJlZiBwcmVmaXggKi8KCWF0ID0gdXNlZF9hdG9tX2NudDsKCXVzZWRfYXRvbV9jbnQrKzsKCVJFQUxMT0NfQVJSQVkodXNlZF9hdG9tLCB1c2VkX2F0b21fY250KTsKCVJFQUxMT0NfQVJSQVkodXNlZF9hdG9tX3R5cGUsIHVzZWRfYXRvbV9jbnQpOwoJdXNlZF9hdG9tW2F0XSA9IHhtZW1kdXB6KGF0b20sIGVwIC0gYXRvbSk7Cgl1c2VkX2F0b21fdHlwZVthdF0gPSB2YWxpZF9hdG9tW2ldLmNtcF90eXBlOwoJaWYgKCphdG9tID09ICcqJykKCQluZWVkX3RhZ2dlZCA9IDE7CglpZiAoIXN0cmNtcCh1c2VkX2F0b21bYXRdLCAic3ltcmVmIikpCgkJbmVlZF9zeW1yZWYgPSAxOwoJcmV0dXJuIGF0Owp9CgovKgogKiBJbiBhIGZvcm1hdCBzdHJpbmcsIGZpbmQgdGhlIG5leHQgb2NjdXJyZW5jZSBvZiAlKGF0b20pLgogKi8Kc3RhdGljIGNvbnN0IGNoYXIgKmZpbmRfbmV4dChjb25zdCBjaGFyICpjcCkKewoJd2hpbGUgKCpjcCkgewoJCWlmICgqY3AgPT0gJyUnKSB7CgkJCS8qCgkJCSAqICUoIGlzIHRoZSBzdGFydCBvZiBhbiBhdG9tOwoJCQkgKiAlJSBpcyBhIHF1b3RlZCBwZXItY2VudC4KCQkJICovCgkJCWlmIChjcFsxXSA9PSAnKCcpCgkJCQlyZXR1cm4gY3A7CgkJCWVsc2UgaWYgKGNwWzFdID09ICclJykKCQkJCWNwKys7IC8qIHNraXAgb3ZlciB0d28gJSAqLwoJCQkvKiBvdGhlcndpc2UgdGhpcyBpcyBhIHNpbmdsZXRvbiwgbGl0ZXJhbCAlICovCgkJfQoJCWNwKys7Cgl9CglyZXR1cm4gTlVMTDsKfQoKLyoKICogTWFrZSBzdXJlIHRoZSBmb3JtYXQgc3RyaW5nIGlzIHdlbGwgZm9ybWVkLCBhbmQgcGFyc2Ugb3V0CiAqIHRoZSB1c2VkIGF0b21zLgogKi8Kc3RhdGljIGludCB2ZXJpZnlfZm9ybWF0KGNvbnN0IGNoYXIgKmZvcm1hdCkKewoJY29uc3QgY2hhciAqY3AsICpzcDsKCgluZWVkX2NvbG9yX3Jlc2V0X2F0X2VvbCA9IDA7Cglmb3IgKGNwID0gZm9ybWF0OyAqY3AgJiYgKHNwID0gZmluZF9uZXh0KGNwKSk7ICkgewoJCWNvbnN0IGNoYXIgKmNvbG9yLCAqZXAgPSBzdHJjaHIoc3AsICcpJyk7CgkJaW50IGF0OwoKCQlpZiAoIWVwKQoJCQlyZXR1cm4gZXJyb3IoIm1hbGZvcm1lZCBmb3JtYXQgc3RyaW5nICVzIiwgc3ApOwoJCS8qIHNwIHBvaW50cyBhdCAiJSgiIGFuZCBlcCBwb2ludHMgYXQgdGhlIGNsb3NpbmcgIikiICovCgkJYXQgPSBwYXJzZV9hdG9tKHNwICsgMiwgZXApOwoJCWNwID0gZXAgKyAxOwoKCQlpZiAoc2tpcF9wcmVmaXgodXNlZF9hdG9tW2F0XSwgImNvbG9yOiIsICZjb2xvcikpCgkJCW5lZWRfY29sb3JfcmVzZXRfYXRfZW9sID0gISFzdHJjbXAoY29sb3IsICJyZXNldCIpOwoJfQoJcmV0dXJuIDA7Cn0KCi8qCiAqIEdpdmVuIGFuIG9iamVjdCBuYW1lLCByZWFkIHRoZSBvYmplY3QgZGF0YSBhbmQgc2l6ZSwgYW5kIHJldHVybiBhCiAqICJzdHJ1Y3Qgb2JqZWN0Ii4gIElmIHRoZSBvYmplY3QgZGF0YSB3ZSBhcmUgcmV0dXJuaW5nIGlzIGFsc28gYm9ycm93ZWQKICogYnkgdGhlICJzdHJ1Y3Qgb2JqZWN0IiByZXByZXNlbnRhdGlvbiwgc2V0ICplYXRlbiBhcyB3ZWxsLS0taXQgaXMgYQogKiBzaWduYWwgZnJvbSBwYXJzZV9vYmplY3RfYnVmZmVyIHRvIHVzIG5vdCB0byBmcmVlIHRoZSBidWZmZXIuCiAqLwpzdGF0aWMgdm9pZCAqZ2V0X29iaihjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExLCBzdHJ1Y3Qgb2JqZWN0ICoqb2JqLCB1bnNpZ25lZCBsb25nICpzeiwgaW50ICplYXRlbikKewoJZW51bSBvYmplY3RfdHlwZSB0eXBlOwoJdm9pZCAqYnVmID0gcmVhZF9zaGExX2ZpbGUoc2hhMSwgJnR5cGUsIHN6KTsKCglpZiAoYnVmKQoJCSpvYmogPSBwYXJzZV9vYmplY3RfYnVmZmVyKHNoYTEsIHR5cGUsICpzeiwgYnVmLCBlYXRlbik7CgllbHNlCgkJKm9iaiA9IE5VTEw7CglyZXR1cm4gYnVmOwp9CgpzdGF0aWMgaW50IGdyYWJfb2JqZWN0bmFtZShjb25zdCBjaGFyICpuYW1lLCBjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExLAoJCQkgICAgc3RydWN0IGF0b21fdmFsdWUgKnYpCnsKCWlmICghc3RyY21wKG5hbWUsICJvYmplY3RuYW1lIikpIHsKCQljaGFyICpzID0geG1hbGxvYyg0MSk7CgkJc3RyY3B5KHMsIHNoYTFfdG9faGV4KHNoYTEpKTsKCQl2LT5zID0gczsKCQlyZXR1cm4gMTsKCX0KCWlmICghc3RyY21wKG5hbWUsICJvYmplY3RuYW1lOnNob3J0IikpIHsKCQl2LT5zID0geHN0cmR1cChmaW5kX3VuaXF1ZV9hYmJyZXYoc2hhMSwgREVGQVVMVF9BQkJSRVYpKTsKCQlyZXR1cm4gMTsKCX0KCXJldHVybiAwOwp9CgovKiBTZWUgZ3JhYl92YWx1ZXMgKi8Kc3RhdGljIHZvaWQgZ3JhYl9jb21tb25fdmFsdWVzKHN0cnVjdCBhdG9tX3ZhbHVlICp2YWwsIGludCBkZXJlZiwgc3RydWN0IG9iamVjdCAqb2JqLCB2b2lkICpidWYsIHVuc2lnbmVkIGxvbmcgc3opCnsKCWludCBpOwoKCWZvciAoaSA9IDA7IGkgPCB1c2VkX2F0b21fY250OyBpKyspIHsKCQljb25zdCBjaGFyICpuYW1lID0gdXNlZF9hdG9tW2ldOwoJCXN0cnVjdCBhdG9tX3ZhbHVlICp2ID0gJnZhbFtpXTsKCQlpZiAoISFkZXJlZiAhPSAoKm5hbWUgPT0gJyonKSkKCQkJY29udGludWU7CgkJaWYgKGRlcmVmKQoJCQluYW1lKys7CgkJaWYgKCFzdHJjbXAobmFtZSwgIm9iamVjdHR5cGUiKSkKCQkJdi0+cyA9IHR5cGVuYW1lKG9iai0+dHlwZSk7CgkJZWxzZSBpZiAoIXN0cmNtcChuYW1lLCAib2JqZWN0c2l6ZSIpKSB7CgkJCWNoYXIgKnMgPSB4bWFsbG9jKDQwKTsKCQkJc3ByaW50ZihzLCAiJWx1Iiwgc3opOwoJCQl2LT51bCA9IHN6OwoJCQl2LT5zID0gczsKCQl9CgkJZWxzZSBpZiAoZGVyZWYpCgkJCWdyYWJfb2JqZWN0bmFtZShuYW1lLCBvYmotPnNoYTEsIHYpOwoJfQp9CgovKiBTZWUgZ3JhYl92YWx1ZXMgKi8Kc3RhdGljIHZvaWQgZ3JhYl90YWdfdmFsdWVzKHN0cnVjdCBhdG9tX3ZhbHVlICp2YWwsIGludCBkZXJlZiwgc3RydWN0IG9iamVjdCAqb2JqLCB2b2lkICpidWYsIHVuc2lnbmVkIGxvbmcgc3opCnsKCWludCBpOwoJc3RydWN0IHRhZyAqdGFnID0gKHN0cnVjdCB0YWcgKikgb2JqOwoKCWZvciAoaSA9IDA7IGkgPCB1c2VkX2F0b21fY250OyBpKyspIHsKCQljb25zdCBjaGFyICpuYW1lID0gdXNlZF9hdG9tW2ldOwoJCXN0cnVjdCBhdG9tX3ZhbHVlICp2ID0gJnZhbFtpXTsKCQlpZiAoISFkZXJlZiAhPSAoKm5hbWUgPT0gJyonKSkKCQkJY29udGludWU7CgkJaWYgKGRlcmVmKQoJCQluYW1lKys7CgkJaWYgKCFzdHJjbXAobmFtZSwgInRhZyIpKQoJCQl2LT5zID0gdGFnLT50YWc7CgkJZWxzZSBpZiAoIXN0cmNtcChuYW1lLCAidHlwZSIpICYmIHRhZy0+dGFnZ2VkKQoJCQl2LT5zID0gdHlwZW5hbWUodGFnLT50YWdnZWQtPnR5cGUpOwoJCWVsc2UgaWYgKCFzdHJjbXAobmFtZSwgIm9iamVjdCIpICYmIHRhZy0+dGFnZ2VkKSB7CgkJCWNoYXIgKnMgPSB4bWFsbG9jKDQxKTsKCQkJc3RyY3B5KHMsIHNoYTFfdG9faGV4KHRhZy0+dGFnZ2VkLT5zaGExKSk7CgkJCXYtPnMgPSBzOwoJCX0KCX0KfQoKLyogU2VlIGdyYWJfdmFsdWVzICovCnN0YXRpYyB2b2lkIGdyYWJfY29tbWl0X3ZhbHVlcyhzdHJ1Y3QgYXRvbV92YWx1ZSAqdmFsLCBpbnQgZGVyZWYsIHN0cnVjdCBvYmplY3QgKm9iaiwgdm9pZCAqYnVmLCB1bnNpZ25lZCBsb25nIHN6KQp7CglpbnQgaTsKCXN0cnVjdCBjb21taXQgKmNvbW1pdCA9IChzdHJ1Y3QgY29tbWl0ICopIG9iajsKCglmb3IgKGkgPSAwOyBpIDwgdXNlZF9hdG9tX2NudDsgaSsrKSB7CgkJY29uc3QgY2hhciAqbmFtZSA9IHVzZWRfYXRvbVtpXTsKCQlzdHJ1Y3QgYXRvbV92YWx1ZSAqdiA9ICZ2YWxbaV07CgkJaWYgKCEhZGVyZWYgIT0gKCpuYW1lID09ICcqJykpCgkJCWNvbnRpbnVlOwoJCWlmIChkZXJlZikKCQkJbmFtZSsrOwoJCWlmICghc3RyY21wKG5hbWUsICJ0cmVlIikpIHsKCQkJY2hhciAqcyA9IHhtYWxsb2MoNDEpOwoJCQlzdHJjcHkocywgc2hhMV90b19oZXgoY29tbWl0LT50cmVlLT5vYmplY3Quc2hhMSkpOwoJCQl2LT5zID0gczsKCQl9CgkJaWYgKCFzdHJjbXAobmFtZSwgIm51bXBhcmVudCIpKSB7CgkJCWNoYXIgKnMgPSB4bWFsbG9jKDQwKTsKCQkJdi0+dWwgPSBjb21taXRfbGlzdF9jb3VudChjb21taXQtPnBhcmVudHMpOwoJCQlzcHJpbnRmKHMsICIlbHUiLCB2LT51bCk7CgkJCXYtPnMgPSBzOwoJCX0KCQllbHNlIGlmICghc3RyY21wKG5hbWUsICJwYXJlbnQiKSkgewoJCQlpbnQgbnVtID0gY29tbWl0X2xpc3RfY291bnQoY29tbWl0LT5wYXJlbnRzKTsKCQkJaW50IGk7CgkJCXN0cnVjdCBjb21taXRfbGlzdCAqcGFyZW50czsKCQkJY2hhciAqcyA9IHhtYWxsb2MoNDEgKiBudW0gKyAxKTsKCQkJdi0+cyA9IHM7CgkJCWZvciAoaSA9IDAsIHBhcmVudHMgPSBjb21taXQtPnBhcmVudHM7CgkJCSAgICAgcGFyZW50czsKCQkJICAgICBwYXJlbnRzID0gcGFyZW50cy0+bmV4dCwgaSA9IGkgKyA0MSkgewoJCQkJc3RydWN0IGNvbW1pdCAqcGFyZW50ID0gcGFyZW50cy0+aXRlbTsKCQkJCXN0cmNweShzK2ksIHNoYTFfdG9faGV4KHBhcmVudC0+b2JqZWN0LnNoYTEpKTsKCQkJCWlmIChwYXJlbnRzLT5uZXh0KQoJCQkJCXNbaSs0MF0gPSAnICc7CgkJCX0KCQkJaWYgKCFpKQoJCQkJKnMgPSAnXDAnOwoJCX0KCX0KfQoKc3RhdGljIGNvbnN0IGNoYXIgKmZpbmRfd2hvbGluZShjb25zdCBjaGFyICp3aG8sIGludCB3aG9sZW4sIGNvbnN0IGNoYXIgKmJ1ZiwgdW5zaWduZWQgbG9uZyBzeikKewoJY29uc3QgY2hhciAqZW9sOwoJd2hpbGUgKCpidWYpIHsKCQlpZiAoIXN0cm5jbXAoYnVmLCB3aG8sIHdob2xlbikgJiYKCQkgICAgYnVmW3dob2xlbl0gPT0gJyAnKQoJCQlyZXR1cm4gYnVmICsgd2hvbGVuICsgMTsKCQllb2wgPSBzdHJjaHIoYnVmLCAnXG4nKTsKCQlpZiAoIWVvbCkKCQkJcmV0dXJuICIiOwoJCWVvbCsrOwoJCWlmICgqZW9sID09ICdcbicpCgkJCXJldHVybiAiIjsgLyogZW5kIG9mIGhlYWRlciAqLwoJCWJ1ZiA9IGVvbDsKCX0KCXJldHVybiAiIjsKfQoKc3RhdGljIGNvbnN0IGNoYXIgKmNvcHlfbGluZShjb25zdCBjaGFyICpidWYpCnsKCWNvbnN0IGNoYXIgKmVvbCA9IHN0cmNocm51bChidWYsICdcbicpOwoJcmV0dXJuIHhtZW1kdXB6KGJ1ZiwgZW9sIC0gYnVmKTsKfQoKc3RhdGljIGNvbnN0IGNoYXIgKmNvcHlfbmFtZShjb25zdCBjaGFyICpidWYpCnsKCWNvbnN0IGNoYXIgKmNwOwoJZm9yIChjcCA9IGJ1ZjsgKmNwICYmICpjcCAhPSAnXG4nOyBjcCsrKSB7CgkJaWYgKCFzdHJuY21wKGNwLCAiIDwiLCAyKSkKCQkJcmV0dXJuIHhtZW1kdXB6KGJ1ZiwgY3AgLSBidWYpOwoJfQoJcmV0dXJuICIiOwp9CgpzdGF0aWMgY29uc3QgY2hhciAqY29weV9lbWFpbChjb25zdCBjaGFyICpidWYpCnsKCWNvbnN0IGNoYXIgKmVtYWlsID0gc3RyY2hyKGJ1ZiwgJzwnKTsKCWNvbnN0IGNoYXIgKmVvZW1haWw7CglpZiAoIWVtYWlsKQoJCXJldHVybiAiIjsKCWVvZW1haWwgPSBzdHJjaHIoZW1haWwsICc+Jyk7CglpZiAoIWVvZW1haWwpCgkJcmV0dXJuICIiOwoJcmV0dXJuIHhtZW1kdXB6KGVtYWlsLCBlb2VtYWlsICsgMSAtIGVtYWlsKTsKfQoKc3RhdGljIGNoYXIgKmNvcHlfc3ViamVjdChjb25zdCBjaGFyICpidWYsIHVuc2lnbmVkIGxvbmcgbGVuKQp7CgljaGFyICpyID0geG1lbWR1cHooYnVmLCBsZW4pOwoJaW50IGk7CgoJZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKQoJCWlmIChyW2ldID09ICdcbicpCgkJCXJbaV0gPSAnICc7CgoJcmV0dXJuIHI7Cn0KCnN0YXRpYyB2b2lkIGdyYWJfZGF0ZShjb25zdCBjaGFyICpidWYsIHN0cnVjdCBhdG9tX3ZhbHVlICp2LCBjb25zdCBjaGFyICphdG9tbmFtZSkKewoJY29uc3QgY2hhciAqZW9lbWFpbCA9IHN0cnN0cihidWYsICI+ICIpOwoJY2hhciAqem9uZTsKCXVuc2lnbmVkIGxvbmcgdGltZXN0YW1wOwoJbG9uZyB0ejsKCWVudW0gZGF0ZV9tb2RlIGRhdGVfbW9kZSA9IERBVEVfTk9STUFMOwoJY29uc3QgY2hhciAqZm9ybWF0cDsKCgkvKgoJICogV2UgZ290IGhlcmUgYmVjYXVzZSBhdG9tbmFtZSBlbmRzIGluICJkYXRlIiBvciAiZGF0ZTxzb21ldGhpbmc+IjsKCSAqIGl0J3Mgbm90IHBvc3NpYmxlIHRoYXQgPHNvbWV0aGluZz4gaXMgbm90ICI6PGZvcm1hdD4iIGJlY2F1c2UKCSAqIHBhcnNlX2F0b20oKSB3b3VsZG4ndCBoYXZlIGFsbG93ZWQgaXQsIHNvIHdlIGNhbiBhc3N1bWUgdGhhdCBubwoJICogIjoiIG1lYW5zIG5vIGZvcm1hdCBpcyBzcGVjaWZpZWQsIGFuZCB1c2UgdGhlIGRlZmF1bHQuCgkgKi8KCWZvcm1hdHAgPSBzdHJjaHIoYXRvbW5hbWUsICc6Jyk7CglpZiAoZm9ybWF0cCAhPSBOVUxMKSB7CgkJZm9ybWF0cCsrOwoJCWRhdGVfbW9kZSA9IHBhcnNlX2RhdGVfZm9ybWF0KGZvcm1hdHApOwoJfQoKCWlmICghZW9lbWFpbCkKCQlnb3RvIGJhZDsKCXRpbWVzdGFtcCA9IHN0cnRvdWwoZW9lbWFpbCArIDIsICZ6b25lLCAxMCk7CglpZiAodGltZXN0YW1wID09IFVMT05HX01BWCkKCQlnb3RvIGJhZDsKCXR6ID0gc3RydG9sKHpvbmUsIE5VTEwsIDEwKTsKCWlmICgodHogPT0gTE9OR19NSU4gfHwgdHogPT0gTE9OR19NQVgpICYmIGVycm5vID09IEVSQU5HRSkKCQlnb3RvIGJhZDsKCXYtPnMgPSB4c3RyZHVwKHNob3dfZGF0ZSh0aW1lc3RhbXAsIHR6LCBkYXRlX21vZGUpKTsKCXYtPnVsID0gdGltZXN0YW1wOwoJcmV0dXJuOwogYmFkOgoJdi0+cyA9ICIiOwoJdi0+dWwgPSAwOwp9CgovKiBTZWUgZ3JhYl92YWx1ZXMgKi8Kc3RhdGljIHZvaWQgZ3JhYl9wZXJzb24oY29uc3QgY2hhciAqd2hvLCBzdHJ1Y3QgYXRvbV92YWx1ZSAqdmFsLCBpbnQgZGVyZWYsIHN0cnVjdCBvYmplY3QgKm9iaiwgdm9pZCAqYnVmLCB1bnNpZ25lZCBsb25nIHN6KQp7CglpbnQgaTsKCWludCB3aG9sZW4gPSBzdHJsZW4od2hvKTsKCWNvbnN0IGNoYXIgKndob2xpbmUgPSBOVUxMOwoKCWZvciAoaSA9IDA7IGkgPCB1c2VkX2F0b21fY250OyBpKyspIHsKCQljb25zdCBjaGFyICpuYW1lID0gdXNlZF9hdG9tW2ldOwoJCXN0cnVjdCBhdG9tX3ZhbHVlICp2ID0gJnZhbFtpXTsKCQlpZiAoISFkZXJlZiAhPSAoKm5hbWUgPT0gJyonKSkKCQkJY29udGludWU7CgkJaWYgKGRlcmVmKQoJCQluYW1lKys7CgkJaWYgKHN0cm5jbXAod2hvLCBuYW1lLCB3aG9sZW4pKQoJCQljb250aW51ZTsKCQlpZiAobmFtZVt3aG9sZW5dICE9IDAgJiYKCQkgICAgc3RyY21wKG5hbWUgKyB3aG9sZW4sICJuYW1lIikgJiYKCQkgICAgc3RyY21wKG5hbWUgKyB3aG9sZW4sICJlbWFpbCIpICYmCgkJICAgICFzdGFydHNfd2l0aChuYW1lICsgd2hvbGVuLCAiZGF0ZSIpKQoJCQljb250aW51ZTsKCQlpZiAoIXdob2xpbmUpCgkJCXdob2xpbmUgPSBmaW5kX3dob2xpbmUod2hvLCB3aG9sZW4sIGJ1Ziwgc3opOwoJCWlmICghd2hvbGluZSkKCQkJcmV0dXJuOyAvKiBubyBwb2ludCBsb29raW5nIGZvciBpdCAqLwoJCWlmIChuYW1lW3dob2xlbl0gPT0gMCkKCQkJdi0+cyA9IGNvcHlfbGluZSh3aG9saW5lKTsKCQllbHNlIGlmICghc3RyY21wKG5hbWUgKyB3aG9sZW4sICJuYW1lIikpCgkJCXYtPnMgPSBjb3B5X25hbWUod2hvbGluZSk7CgkJZWxzZSBpZiAoIXN0cmNtcChuYW1lICsgd2hvbGVuLCAiZW1haWwiKSkKCQkJdi0+cyA9IGNvcHlfZW1haWwod2hvbGluZSk7CgkJZWxzZSBpZiAoc3RhcnRzX3dpdGgobmFtZSArIHdob2xlbiwgImRhdGUiKSkKCQkJZ3JhYl9kYXRlKHdob2xpbmUsIHYsIG5hbWUpOwoJfQoKCS8qCgkgKiBGb3IgYSB0YWcgb3IgYSBjb21taXQgb2JqZWN0LCBpZiAiY3JlYXRvciIgb3IgImNyZWF0b3JkYXRlIiBpcwoJICogcmVxdWVzdGVkLCBkbyBzb21ldGhpbmcgc3BlY2lhbC4KCSAqLwoJaWYgKHN0cmNtcCh3aG8sICJ0YWdnZXIiKSAmJiBzdHJjbXAod2hvLCAiY29tbWl0dGVyIikpCgkJcmV0dXJuOyAvKiAiYXV0aG9yIiBmb3IgY29tbWl0IG9iamVjdCBpcyBub3Qgd2FudGVkICovCglpZiAoIXdob2xpbmUpCgkJd2hvbGluZSA9IGZpbmRfd2hvbGluZSh3aG8sIHdob2xlbiwgYnVmLCBzeik7CglpZiAoIXdob2xpbmUpCgkJcmV0dXJuOwoJZm9yIChpID0gMDsgaSA8IHVzZWRfYXRvbV9jbnQ7IGkrKykgewoJCWNvbnN0IGNoYXIgKm5hbWUgPSB1c2VkX2F0b21baV07CgkJc3RydWN0IGF0b21fdmFsdWUgKnYgPSAmdmFsW2ldOwoJCWlmICghIWRlcmVmICE9ICgqbmFtZSA9PSAnKicpKQoJCQljb250aW51ZTsKCQlpZiAoZGVyZWYpCgkJCW5hbWUrKzsKCgkJaWYgKHN0YXJ0c193aXRoKG5hbWUsICJjcmVhdG9yZGF0ZSIpKQoJCQlncmFiX2RhdGUod2hvbGluZSwgdiwgbmFtZSk7CgkJZWxzZSBpZiAoIXN0cmNtcChuYW1lLCAiY3JlYXRvciIpKQoJCQl2LT5zID0gY29weV9saW5lKHdob2xpbmUpOwoJfQp9CgpzdGF0aWMgdm9pZCBmaW5kX3N1YnBvcyhjb25zdCBjaGFyICpidWYsIHVuc2lnbmVkIGxvbmcgc3osCgkJCWNvbnN0IGNoYXIgKipzdWIsIHVuc2lnbmVkIGxvbmcgKnN1YmxlbiwKCQkJY29uc3QgY2hhciAqKmJvZHksIHVuc2lnbmVkIGxvbmcgKmJvZHlsZW4sCgkJCXVuc2lnbmVkIGxvbmcgKm5vbnNpZ2xlbiwKCQkJY29uc3QgY2hhciAqKnNpZywgdW5zaWduZWQgbG9uZyAqc2lnbGVuKQp7Cgljb25zdCBjaGFyICplb2w7CgkvKiBza2lwIHBhc3QgaGVhZGVyIHVudGlsIHdlIGhpdCBlbXB0eSBsaW5lICovCgl3aGlsZSAoKmJ1ZiAmJiAqYnVmICE9ICdcbicpIHsKCQllb2wgPSBzdHJjaHJudWwoYnVmLCAnXG4nKTsKCQlpZiAoKmVvbCkKCQkJZW9sKys7CgkJYnVmID0gZW9sOwoJfQoJLyogc2tpcCBhbnkgZW1wdHkgbGluZXMgKi8KCXdoaWxlICgqYnVmID09ICdcbicpCgkJYnVmKys7CgoJLyogcGFyc2Ugc2lnbmF0dXJlIGZpcnN0OyB3ZSBtaWdodCBub3QgZXZlbiBoYXZlIGEgc3ViamVjdCBsaW5lICovCgkqc2lnID0gYnVmICsgcGFyc2Vfc2lnbmF0dXJlKGJ1Ziwgc3RybGVuKGJ1ZikpOwoJKnNpZ2xlbiA9IHN0cmxlbigqc2lnKTsKCgkvKiBzdWJqZWN0IGlzIGZpcnN0IG5vbi1lbXB0eSBsaW5lICovCgkqc3ViID0gYnVmOwoJLyogc3ViamVjdCBnb2VzIHRvIGZpcnN0IGVtcHR5IGxpbmUgKi8KCXdoaWxlIChidWYgPCAqc2lnICYmICpidWYgJiYgKmJ1ZiAhPSAnXG4nKSB7CgkJZW9sID0gc3RyY2hybnVsKGJ1ZiwgJ1xuJyk7CgkJaWYgKCplb2wpCgkJCWVvbCsrOwoJCWJ1ZiA9IGVvbDsKCX0KCSpzdWJsZW4gPSBidWYgLSAqc3ViOwoJLyogZHJvcCB0cmFpbGluZyBuZXdsaW5lLCBpZiBwcmVzZW50ICovCglpZiAoKnN1YmxlbiAmJiAoKnN1YilbKnN1YmxlbiAtIDFdID09ICdcbicpCgkJKnN1YmxlbiAtPSAxOwoKCS8qIHNraXAgYW55IGVtcHR5IGxpbmVzICovCgl3aGlsZSAoKmJ1ZiA9PSAnXG4nKQoJCWJ1ZisrOwoJKmJvZHkgPSBidWY7CgkqYm9keWxlbiA9IHN0cmxlbihidWYpOwoJKm5vbnNpZ2xlbiA9ICpzaWcgLSBidWY7Cn0KCi8qIFNlZSBncmFiX3ZhbHVlcyAqLwpzdGF0aWMgdm9pZCBncmFiX3N1Yl9ib2R5X2NvbnRlbnRzKHN0cnVjdCBhdG9tX3ZhbHVlICp2YWwsIGludCBkZXJlZiwgc3RydWN0IG9iamVjdCAqb2JqLCB2b2lkICpidWYsIHVuc2lnbmVkIGxvbmcgc3opCnsKCWludCBpOwoJY29uc3QgY2hhciAqc3VicG9zID0gTlVMTCwgKmJvZHlwb3MgPSBOVUxMLCAqc2lncG9zID0gTlVMTDsKCXVuc2lnbmVkIGxvbmcgc3VibGVuID0gMCwgYm9keWxlbiA9IDAsIG5vbnNpZ2xlbiA9IDAsIHNpZ2xlbiA9IDA7CgoJZm9yIChpID0gMDsgaSA8IHVzZWRfYXRvbV9jbnQ7IGkrKykgewoJCWNvbnN0IGNoYXIgKm5hbWUgPSB1c2VkX2F0b21baV07CgkJc3RydWN0IGF0b21fdmFsdWUgKnYgPSAmdmFsW2ldOwoJCWlmICghIWRlcmVmICE9ICgqbmFtZSA9PSAnKicpKQoJCQljb250aW51ZTsKCQlpZiAoZGVyZWYpCgkJCW5hbWUrKzsKCQlpZiAoc3RyY21wKG5hbWUsICJzdWJqZWN0IikgJiYKCQkgICAgc3RyY21wKG5hbWUsICJib2R5IikgJiYKCQkgICAgc3RyY21wKG5hbWUsICJjb250ZW50cyIpICYmCgkJICAgIHN0cmNtcChuYW1lLCAiY29udGVudHM6c3ViamVjdCIpICYmCgkJICAgIHN0cmNtcChuYW1lLCAiY29udGVudHM6Ym9keSIpICYmCgkJICAgIHN0cmNtcChuYW1lLCAiY29udGVudHM6c2lnbmF0dXJlIikpCgkJCWNvbnRpbnVlOwoJCWlmICghc3VicG9zKQoJCQlmaW5kX3N1YnBvcyhidWYsIHN6LAoJCQkJICAgICZzdWJwb3MsICZzdWJsZW4sCgkJCQkgICAgJmJvZHlwb3MsICZib2R5bGVuLCAmbm9uc2lnbGVuLAoJCQkJICAgICZzaWdwb3MsICZzaWdsZW4pOwoKCQlpZiAoIXN0cmNtcChuYW1lLCAic3ViamVjdCIpKQoJCQl2LT5zID0gY29weV9zdWJqZWN0KHN1YnBvcywgc3VibGVuKTsKCQllbHNlIGlmICghc3RyY21wKG5hbWUsICJjb250ZW50czpzdWJqZWN0IikpCgkJCXYtPnMgPSBjb3B5X3N1YmplY3Qoc3VicG9zLCBzdWJsZW4pOwoJCWVsc2UgaWYgKCFzdHJjbXAobmFtZSwgImJvZHkiKSkKCQkJdi0+cyA9IHhtZW1kdXB6KGJvZHlwb3MsIGJvZHlsZW4pOwoJCWVsc2UgaWYgKCFzdHJjbXAobmFtZSwgImNvbnRlbnRzOmJvZHkiKSkKCQkJdi0+cyA9IHhtZW1kdXB6KGJvZHlwb3MsIG5vbnNpZ2xlbik7CgkJZWxzZSBpZiAoIXN0cmNtcChuYW1lLCAiY29udGVudHM6c2lnbmF0dXJlIikpCgkJCXYtPnMgPSB4bWVtZHVweihzaWdwb3MsIHNpZ2xlbik7CgkJZWxzZSBpZiAoIXN0cmNtcChuYW1lLCAiY29udGVudHMiKSkKCQkJdi0+cyA9IHhzdHJkdXAoc3VicG9zKTsKCX0KfQoKLyoKICogV2Ugd2FudCB0byBoYXZlIGVtcHR5IHByaW50LXN0cmluZyBmb3IgZmllbGQgcmVxdWVzdHMKICogdGhhdCBkbyBub3QgYXBwbHkgKGUuZy4gImF1dGhvcmRhdGUiIGZvciBhIHRhZyBvYmplY3QpCiAqLwpzdGF0aWMgdm9pZCBmaWxsX21pc3NpbmdfdmFsdWVzKHN0cnVjdCBhdG9tX3ZhbHVlICp2YWwpCnsKCWludCBpOwoJZm9yIChpID0gMDsgaSA8IHVzZWRfYXRvbV9jbnQ7IGkrKykgewoJCXN0cnVjdCBhdG9tX3ZhbHVlICp2ID0gJnZhbFtpXTsKCQlpZiAodi0+cyA9PSBOVUxMKQoJCQl2LT5zID0gIiI7Cgl9Cn0KCi8qCiAqIHZhbCBpcyBhIGxpc3Qgb2YgYXRvbV92YWx1ZSB0byBob2xkIHJldHVybmVkIHZhbHVlcy4gIEV4dHJhY3QKICogdGhlIHZhbHVlcyBmb3IgYXRvbXMgaW4gdXNlZF9hdG9tIGFycmF5IG91dCBvZiAob2JqLCBidWYsIHN6KS4KICogd2hlbiBkZXJlZiBpcyBmYWxzZSwgKG9iaiwgYnVmLCBzeikgaXMgdGhlIG9iamVjdCB0aGF0IGlzCiAqIHBvaW50ZWQgYXQgYnkgdGhlIHJlZiBpdHNlbGY7IG90aGVyd2lzZSBpdCBpcyB0aGUgb2JqZWN0IHRoZQogKiByZWYgKHdoaWNoIGlzIGEgdGFnKSByZWZlcnMgdG8uCiAqLwpzdGF0aWMgdm9pZCBncmFiX3ZhbHVlcyhzdHJ1Y3QgYXRvbV92YWx1ZSAqdmFsLCBpbnQgZGVyZWYsIHN0cnVjdCBvYmplY3QgKm9iaiwgdm9pZCAqYnVmLCB1bnNpZ25lZCBsb25nIHN6KQp7CglncmFiX2NvbW1vbl92YWx1ZXModmFsLCBkZXJlZiwgb2JqLCBidWYsIHN6KTsKCXN3aXRjaCAob2JqLT50eXBlKSB7CgljYXNlIE9CSl9UQUc6CgkJZ3JhYl90YWdfdmFsdWVzKHZhbCwgZGVyZWYsIG9iaiwgYnVmLCBzeik7CgkJZ3JhYl9zdWJfYm9keV9jb250ZW50cyh2YWwsIGRlcmVmLCBvYmosIGJ1Ziwgc3opOwoJCWdyYWJfcGVyc29uKCJ0YWdnZXIiLCB2YWwsIGRlcmVmLCBvYmosIGJ1Ziwgc3opOwoJCWJyZWFrOwoJY2FzZSBPQkpfQ09NTUlUOgoJCWdyYWJfY29tbWl0X3ZhbHVlcyh2YWwsIGRlcmVmLCBvYmosIGJ1Ziwgc3opOwoJCWdyYWJfc3ViX2JvZHlfY29udGVudHModmFsLCBkZXJlZiwgb2JqLCBidWYsIHN6KTsKCQlncmFiX3BlcnNvbigiYXV0aG9yIiwgdmFsLCBkZXJlZiwgb2JqLCBidWYsIHN6KTsKCQlncmFiX3BlcnNvbigiY29tbWl0dGVyIiwgdmFsLCBkZXJlZiwgb2JqLCBidWYsIHN6KTsKCQlicmVhazsKCWNhc2UgT0JKX1RSRUU6CgkJLyogZ3JhYl90cmVlX3ZhbHVlcyh2YWwsIGRlcmVmLCBvYmosIGJ1Ziwgc3opOyAqLwoJCWJyZWFrOwoJY2FzZSBPQkpfQkxPQjoKCQkvKiBncmFiX2Jsb2JfdmFsdWVzKHZhbCwgZGVyZWYsIG9iaiwgYnVmLCBzeik7ICovCgkJYnJlYWs7CglkZWZhdWx0OgoJCWRpZSgiRWg/ICBPYmplY3Qgb2YgdHlwZSAlZD8iLCBvYmotPnR5cGUpOwoJfQp9CgpzdGF0aWMgaW5saW5lIGNoYXIgKmNvcHlfYWR2YW5jZShjaGFyICpkc3QsIGNvbnN0IGNoYXIgKnNyYykKewoJd2hpbGUgKCpzcmMpCgkJKmRzdCsrID0gKnNyYysrOwoJcmV0dXJuIGRzdDsKfQoKLyoKICogUGFyc2UgdGhlIG9iamVjdCByZWZlcnJlZCBieSByZWYsIGFuZCBncmFiIG5lZWRlZCB2YWx1ZS4KICovCnN0YXRpYyB2b2lkIHBvcHVsYXRlX3ZhbHVlKHN0cnVjdCByZWZpbmZvICpyZWYpCnsKCXZvaWQgKmJ1ZjsKCXN0cnVjdCBvYmplY3QgKm9iajsKCWludCBlYXRlbiwgaTsKCXVuc2lnbmVkIGxvbmcgc2l6ZTsKCWNvbnN0IHVuc2lnbmVkIGNoYXIgKnRhZ2dlZDsKCglyZWYtPnZhbHVlID0geGNhbGxvYyh1c2VkX2F0b21fY250LCBzaXplb2Yoc3RydWN0IGF0b21fdmFsdWUpKTsKCglpZiAobmVlZF9zeW1yZWYgJiYgKHJlZi0+ZmxhZyAmIFJFRl9JU1NZTVJFRikgJiYgIXJlZi0+c3ltcmVmKSB7CgkJdW5zaWduZWQgY2hhciB1bnVzZWQxWzIwXTsKCQlyZWYtPnN5bXJlZiA9IHJlc29sdmVfcmVmZHVwKHJlZi0+cmVmbmFtZSwgUkVTT0xWRV9SRUZfUkVBRElORywKCQkJCQkgICAgIHVudXNlZDEsIE5VTEwpOwoJCWlmICghcmVmLT5zeW1yZWYpCgkJCXJlZi0+c3ltcmVmID0gIiI7Cgl9CgoJLyogRmlsbCBpbiBzcGVjaWFscyBmaXJzdCAqLwoJZm9yIChpID0gMDsgaSA8IHVzZWRfYXRvbV9jbnQ7IGkrKykgewoJCWNvbnN0IGNoYXIgKm5hbWUgPSB1c2VkX2F0b21baV07CgkJc3RydWN0IGF0b21fdmFsdWUgKnYgPSAmcmVmLT52YWx1ZVtpXTsKCQlpbnQgZGVyZWYgPSAwOwoJCWNvbnN0IGNoYXIgKnJlZm5hbWU7CgkJY29uc3QgY2hhciAqZm9ybWF0cDsKCQlzdHJ1Y3QgYnJhbmNoICpicmFuY2ggPSBOVUxMOwoKCQlpZiAoKm5hbWUgPT0gJyonKSB7CgkJCWRlcmVmID0gMTsKCQkJbmFtZSsrOwoJCX0KCgkJaWYgKHN0YXJ0c193aXRoKG5hbWUsICJyZWZuYW1lIikpCgkJCXJlZm5hbWUgPSByZWYtPnJlZm5hbWU7CgkJZWxzZSBpZiAoc3RhcnRzX3dpdGgobmFtZSwgInN5bXJlZiIpKQoJCQlyZWZuYW1lID0gcmVmLT5zeW1yZWYgPyByZWYtPnN5bXJlZiA6ICIiOwoJCWVsc2UgaWYgKHN0YXJ0c193aXRoKG5hbWUsICJ1cHN0cmVhbSIpKSB7CgkJCS8qIG9ubHkgbG9jYWwgYnJhbmNoZXMgbWF5IGhhdmUgYW4gdXBzdHJlYW0gKi8KCQkJaWYgKCFzdGFydHNfd2l0aChyZWYtPnJlZm5hbWUsICJyZWZzL2hlYWRzLyIpKQoJCQkJY29udGludWU7CgkJCWJyYW5jaCA9IGJyYW5jaF9nZXQocmVmLT5yZWZuYW1lICsgMTEpOwoKCQkJaWYgKCFicmFuY2ggfHwgIWJyYW5jaC0+bWVyZ2UgfHwgIWJyYW5jaC0+bWVyZ2VbMF0gfHwKCQkJICAgICFicmFuY2gtPm1lcmdlWzBdLT5kc3QpCgkJCQljb250aW51ZTsKCQkJcmVmbmFtZSA9IGJyYW5jaC0+bWVyZ2VbMF0tPmRzdDsKCQl9IGVsc2UgaWYgKHN0YXJ0c193aXRoKG5hbWUsICJjb2xvcjoiKSkgewoJCQljaGFyIGNvbG9yW0NPTE9SX01BWExFTl0gPSAiIjsKCgkJCWlmIChjb2xvcl9wYXJzZShuYW1lICsgNiwgY29sb3IpIDwgMCkKCQkJCWRpZShfKCJ1bmFibGUgdG8gcGFyc2UgZm9ybWF0IikpOwoJCQl2LT5zID0geHN0cmR1cChjb2xvcik7CgkJCWNvbnRpbnVlOwoJCX0gZWxzZSBpZiAoIXN0cmNtcChuYW1lLCAiZmxhZyIpKSB7CgkJCWNoYXIgYnVmWzI1Nl0sICpjcCA9IGJ1ZjsKCQkJaWYgKHJlZi0+ZmxhZyAmIFJFRl9JU1NZTVJFRikKCQkJCWNwID0gY29weV9hZHZhbmNlKGNwLCAiLHN5bXJlZiIpOwoJCQlpZiAocmVmLT5mbGFnICYgUkVGX0lTUEFDS0VEKQoJCQkJY3AgPSBjb3B5X2FkdmFuY2UoY3AsICIscGFja2VkIik7CgkJCWlmIChjcCA9PSBidWYpCgkJCQl2LT5zID0gIiI7CgkJCWVsc2UgewoJCQkJKmNwID0gJ1wwJzsKCQkJCXYtPnMgPSB4c3RyZHVwKGJ1ZiArIDEpOwoJCQl9CgkJCWNvbnRpbnVlOwoJCX0gZWxzZSBpZiAoIWRlcmVmICYmIGdyYWJfb2JqZWN0bmFtZShuYW1lLCByZWYtPm9iamVjdG5hbWUsIHYpKSB7CgkJCWNvbnRpbnVlOwoJCX0gZWxzZSBpZiAoIXN0cmNtcChuYW1lLCAiSEVBRCIpKSB7CgkJCWNvbnN0IGNoYXIgKmhlYWQ7CgkJCXVuc2lnbmVkIGNoYXIgc2hhMVsyMF07CgoJCQloZWFkID0gcmVzb2x2ZV9yZWZfdW5zYWZlKCJIRUFEIiwgUkVTT0xWRV9SRUZfUkVBRElORywKCQkJCQkJICBzaGExLCBOVUxMKTsKCQkJaWYgKCFzdHJjbXAocmVmLT5yZWZuYW1lLCBoZWFkKSkKCQkJCXYtPnMgPSAiKiI7CgkJCWVsc2UKCQkJCXYtPnMgPSAiICI7CgkJCWNvbnRpbnVlOwoJCX0gZWxzZQoJCQljb250aW51ZTsKCgkJZm9ybWF0cCA9IHN0cmNocihuYW1lLCAnOicpOwoJCWlmIChmb3JtYXRwKSB7CgkJCWludCBudW1fb3VycywgbnVtX3RoZWlyczsKCgkJCWZvcm1hdHArKzsKCQkJaWYgKCFzdHJjbXAoZm9ybWF0cCwgInNob3J0IikpCgkJCQlyZWZuYW1lID0gc2hvcnRlbl91bmFtYmlndW91c19yZWYocmVmbmFtZSwKCQkJCQkJICAgICAgd2Fybl9hbWJpZ3VvdXNfcmVmcyk7CgkJCWVsc2UgaWYgKCFzdHJjbXAoZm9ybWF0cCwgInRyYWNrIikgJiYKCQkJCSBzdGFydHNfd2l0aChuYW1lLCAidXBzdHJlYW0iKSkgewoJCQkJY2hhciBidWZbNDBdOwoKCQkJCWlmIChzdGF0X3RyYWNraW5nX2luZm8oYnJhbmNoLCAmbnVtX291cnMsCgkJCQkJCSAgICAgICAmbnVtX3RoZWlycykgIT0gMSkKCQkJCQljb250aW51ZTsKCgkJCQlpZiAoIW51bV9vdXJzICYmICFudW1fdGhlaXJzKQoJCQkJCXYtPnMgPSAiIjsKCQkJCWVsc2UgaWYgKCFudW1fb3VycykgewoJCQkJCXNwcmludGYoYnVmLCAiW2JlaGluZCAlZF0iLCBudW1fdGhlaXJzKTsKCQkJCQl2LT5zID0geHN0cmR1cChidWYpOwoJCQkJfSBlbHNlIGlmICghbnVtX3RoZWlycykgewoJCQkJCXNwcmludGYoYnVmLCAiW2FoZWFkICVkXSIsIG51bV9vdXJzKTsKCQkJCQl2LT5zID0geHN0cmR1cChidWYpOwoJCQkJfSBlbHNlIHsKCQkJCQlzcHJpbnRmKGJ1ZiwgIlthaGVhZCAlZCwgYmVoaW5kICVkXSIsCgkJCQkJCW51bV9vdXJzLCBudW1fdGhlaXJzKTsKCQkJCQl2LT5zID0geHN0cmR1cChidWYpOwoJCQkJfQoJCQkJY29udGludWU7CgkJCX0gZWxzZSBpZiAoIXN0cmNtcChmb3JtYXRwLCAidHJhY2tzaG9ydCIpICYmCgkJCQkgICBzdGFydHNfd2l0aChuYW1lLCAidXBzdHJlYW0iKSkgewoJCQkJYXNzZXJ0KGJyYW5jaCk7CgoJCQkJaWYgKHN0YXRfdHJhY2tpbmdfaW5mbyhicmFuY2gsICZudW1fb3VycywKCQkJCQkJCSZudW1fdGhlaXJzKSAhPSAxKQoJCQkJCWNvbnRpbnVlOwoKCQkJCWlmICghbnVtX291cnMgJiYgIW51bV90aGVpcnMpCgkJCQkJdi0+cyA9ICI9IjsKCQkJCWVsc2UgaWYgKCFudW1fb3VycykKCQkJCQl2LT5zID0gIjwiOwoJCQkJZWxzZSBpZiAoIW51bV90aGVpcnMpCgkJCQkJdi0+cyA9ICI+IjsKCQkJCWVsc2UKCQkJCQl2LT5zID0gIjw+IjsKCQkJCWNvbnRpbnVlOwoJCQl9IGVsc2UKCQkJCWRpZSgidW5rbm93biAlLipzIGZvcm1hdCAlcyIsCgkJCQkgICAgKGludCkoZm9ybWF0cCAtIG5hbWUpLCBuYW1lLCBmb3JtYXRwKTsKCQl9CgoJCWlmICghZGVyZWYpCgkJCXYtPnMgPSByZWZuYW1lOwoJCWVsc2UgewoJCQlpbnQgbGVuID0gc3RybGVuKHJlZm5hbWUpOwoJCQljaGFyICpzID0geG1hbGxvYyhsZW4gKyA0KTsKCQkJc3ByaW50ZihzLCAiJXNee30iLCByZWZuYW1lKTsKCQkJdi0+cyA9IHM7CgkJfQoJfQoKCWZvciAoaSA9IDA7IGkgPCB1c2VkX2F0b21fY250OyBpKyspIHsKCQlzdHJ1Y3QgYXRvbV92YWx1ZSAqdiA9ICZyZWYtPnZhbHVlW2ldOwoJCWlmICh2LT5zID09IE5VTEwpCgkJCWdvdG8gbmVlZF9vYmo7Cgl9CglyZXR1cm47CgogbmVlZF9vYmo6CglidWYgPSBnZXRfb2JqKHJlZi0+b2JqZWN0bmFtZSwgJm9iaiwgJnNpemUsICZlYXRlbik7CglpZiAoIWJ1ZikKCQlkaWUoIm1pc3Npbmcgb2JqZWN0ICVzIGZvciAlcyIsCgkJICAgIHNoYTFfdG9faGV4KHJlZi0+b2JqZWN0bmFtZSksIHJlZi0+cmVmbmFtZSk7CglpZiAoIW9iaikKCQlkaWUoInBhcnNlX29iamVjdF9idWZmZXIgZmFpbGVkIG9uICVzIGZvciAlcyIsCgkJICAgIHNoYTFfdG9faGV4KHJlZi0+b2JqZWN0bmFtZSksIHJlZi0+cmVmbmFtZSk7CgoJZ3JhYl92YWx1ZXMocmVmLT52YWx1ZSwgMCwgb2JqLCBidWYsIHNpemUpOwoJaWYgKCFlYXRlbikKCQlmcmVlKGJ1Zik7CgoJLyoKCSAqIElmIHRoZXJlIGlzIG5vIGF0b20gdGhhdCB3YW50cyB0byBrbm93IGFib3V0IHRhZ2dlZAoJICogb2JqZWN0LCB3ZSBhcmUgZG9uZS4KCSAqLwoJaWYgKCFuZWVkX3RhZ2dlZCB8fCAob2JqLT50eXBlICE9IE9CSl9UQUcpKQoJCXJldHVybjsKCgkvKgoJICogSWYgaXQgaXMgYSB0YWcgb2JqZWN0LCBzZWUgaWYgd2UgdXNlIGEgdmFsdWUgdGhhdCBkZXJlZnMKCSAqIHRoZSBvYmplY3QsIGFuZCBpZiB3ZSBkbyBncmFiIHRoZSBvYmplY3QgaXQgcmVmZXJzIHRvLgoJICovCgl0YWdnZWQgPSAoKHN0cnVjdCB0YWcgKilvYmopLT50YWdnZWQtPnNoYTE7CgoJLyoKCSAqIE5FRURTV09SSzogVGhpcyBkZXJlZnMgdGFnIG9ubHkgb25jZSwgd2hpY2gKCSAqIGlzIGdvb2QgdG8gZGVhbCB3aXRoIGNoYWlucyBvZiB0cnVzdCwgYnV0CgkgKiBpcyBub3QgY29uc2lzdGVudCB3aXRoIHdoYXQgZGVyZWZfdGFnKCkgZG9lcwoJICogd2hpY2ggcGVlbHMgdGhlIG9uaW9uIHRvIHRoZSBjb3JlLgoJICovCglidWYgPSBnZXRfb2JqKHRhZ2dlZCwgJm9iaiwgJnNpemUsICZlYXRlbik7CglpZiAoIWJ1ZikKCQlkaWUoIm1pc3Npbmcgb2JqZWN0ICVzIGZvciAlcyIsCgkJICAgIHNoYTFfdG9faGV4KHRhZ2dlZCksIHJlZi0+cmVmbmFtZSk7CglpZiAoIW9iaikKCQlkaWUoInBhcnNlX29iamVjdF9idWZmZXIgZmFpbGVkIG9uICVzIGZvciAlcyIsCgkJICAgIHNoYTFfdG9faGV4KHRhZ2dlZCksIHJlZi0+cmVmbmFtZSk7CglncmFiX3ZhbHVlcyhyZWYtPnZhbHVlLCAxLCBvYmosIGJ1Ziwgc2l6ZSk7CglpZiAoIWVhdGVuKQoJCWZyZWUoYnVmKTsKfQoKLyoKICogR2l2ZW4gYSByZWYsIHJldHVybiB0aGUgdmFsdWUgZm9yIHRoZSBhdG9tLiAgVGhpcyBsYXppbHkgZ2V0cyB2YWx1ZQogKiBvdXQgb2YgdGhlIG9iamVjdCBieSBjYWxsaW5nIHBvcHVsYXRlIHZhbHVlLgogKi8Kc3RhdGljIHZvaWQgZ2V0X3ZhbHVlKHN0cnVjdCByZWZpbmZvICpyZWYsIGludCBhdG9tLCBzdHJ1Y3QgYXRvbV92YWx1ZSAqKnYpCnsKCWlmICghcmVmLT52YWx1ZSkgewoJCXBvcHVsYXRlX3ZhbHVlKHJlZik7CgkJZmlsbF9taXNzaW5nX3ZhbHVlcyhyZWYtPnZhbHVlKTsKCX0KCSp2ID0gJnJlZi0+dmFsdWVbYXRvbV07Cn0KCnN0cnVjdCBncmFiX3JlZl9jYmRhdGEgewoJc3RydWN0IHJlZmluZm8gKipncmFiX2FycmF5OwoJY29uc3QgY2hhciAqKmdyYWJfcGF0dGVybjsKCWludCBncmFiX2NudDsKfTsKCi8qCiAqIEEgY2FsbC1iYWNrIGdpdmVuIHRvIGZvcl9lYWNoX3JlZigpLiAgRmlsdGVyIHJlZnMgYW5kIGtlZXAgdGhlbSBmb3IKICogbGF0ZXIgb2JqZWN0IHByb2Nlc3NpbmcuCiAqLwpzdGF0aWMgaW50IGdyYWJfc2luZ2xlX3JlZihjb25zdCBjaGFyICpyZWZuYW1lLCBjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExLCBpbnQgZmxhZywgdm9pZCAqY2JfZGF0YSkKewoJc3RydWN0IGdyYWJfcmVmX2NiZGF0YSAqY2IgPSBjYl9kYXRhOwoJc3RydWN0IHJlZmluZm8gKnJlZjsKCWludCBjbnQ7CgoJaWYgKGZsYWcgJiBSRUZfQkFEX05BTUUpIHsKCQkgIHdhcm5pbmcoImlnbm9yaW5nIHJlZiB3aXRoIGJyb2tlbiBuYW1lICVzIiwgcmVmbmFtZSk7CgkJICByZXR1cm4gMDsKCX0KCglpZiAoKmNiLT5ncmFiX3BhdHRlcm4pIHsKCQljb25zdCBjaGFyICoqcGF0dGVybjsKCQlpbnQgbmFtZWxlbiA9IHN0cmxlbihyZWZuYW1lKTsKCQlmb3IgKHBhdHRlcm4gPSBjYi0+Z3JhYl9wYXR0ZXJuOyAqcGF0dGVybjsgcGF0dGVybisrKSB7CgkJCWNvbnN0IGNoYXIgKnAgPSAqcGF0dGVybjsKCQkJaW50IHBsZW4gPSBzdHJsZW4ocCk7CgoJCQlpZiAoKHBsZW4gPD0gbmFtZWxlbikgJiYKCQkJICAgICFzdHJuY21wKHJlZm5hbWUsIHAsIHBsZW4pICYmCgkJCSAgICAocmVmbmFtZVtwbGVuXSA9PSAnXDAnIHx8CgkJCSAgICAgcmVmbmFtZVtwbGVuXSA9PSAnLycgfHwKCQkJICAgICBwW3BsZW4tMV0gPT0gJy8nKSkKCQkJCWJyZWFrOwoJCQlpZiAoIXdpbGRtYXRjaChwLCByZWZuYW1lLCBXTV9QQVRITkFNRSwgTlVMTCkpCgkJCQlicmVhazsKCQl9CgkJaWYgKCEqcGF0dGVybikKCQkJcmV0dXJuIDA7Cgl9CgoJLyoKCSAqIFdlIGRvIG5vdCBvcGVuIHRoZSBvYmplY3QgeWV0OyBzb3J0IG1heSBvbmx5IG5lZWQgcmVmbmFtZQoJICogdG8gZG8gaXRzIGpvYiBhbmQgdGhlIHJlc3VsdGluZyBsaXN0IG1heSB5ZXQgdG8gYmUgcHJ1bmVkCgkgKiBieSBtYXhjb3VudCBsb2dpYy4KCSAqLwoJcmVmID0geGNhbGxvYygxLCBzaXplb2YoKnJlZikpOwoJcmVmLT5yZWZuYW1lID0geHN0cmR1cChyZWZuYW1lKTsKCWhhc2hjcHkocmVmLT5vYmplY3RuYW1lLCBzaGExKTsKCXJlZi0+ZmxhZyA9IGZsYWc7CgoJY250ID0gY2ItPmdyYWJfY250OwoJUkVBTExPQ19BUlJBWShjYi0+Z3JhYl9hcnJheSwgY250ICsgMSk7CgljYi0+Z3JhYl9hcnJheVtjbnQrK10gPSByZWY7CgljYi0+Z3JhYl9jbnQgPSBjbnQ7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBjbXBfcmVmX3NvcnQoc3RydWN0IHJlZl9zb3J0ICpzLCBzdHJ1Y3QgcmVmaW5mbyAqYSwgc3RydWN0IHJlZmluZm8gKmIpCnsKCXN0cnVjdCBhdG9tX3ZhbHVlICp2YSwgKnZiOwoJaW50IGNtcDsKCWNtcF90eXBlIGNtcF90eXBlID0gdXNlZF9hdG9tX3R5cGVbcy0+YXRvbV07CgoJZ2V0X3ZhbHVlKGEsIHMtPmF0b20sICZ2YSk7CglnZXRfdmFsdWUoYiwgcy0+YXRvbSwgJnZiKTsKCXN3aXRjaCAoY21wX3R5cGUpIHsKCWNhc2UgRklFTERfU1RSOgoJCWNtcCA9IHN0cmNtcCh2YS0+cywgdmItPnMpOwoJCWJyZWFrOwoJZGVmYXVsdDoKCQlpZiAodmEtPnVsIDwgdmItPnVsKQoJCQljbXAgPSAtMTsKCQllbHNlIGlmICh2YS0+dWwgPT0gdmItPnVsKQoJCQljbXAgPSAwOwoJCWVsc2UKCQkJY21wID0gMTsKCQlicmVhazsKCX0KCXJldHVybiAocy0+cmV2ZXJzZSkgPyAtY21wIDogY21wOwp9CgpzdGF0aWMgc3RydWN0IHJlZl9zb3J0ICpyZWZfc29ydDsKc3RhdGljIGludCBjb21wYXJlX3JlZnMoY29uc3Qgdm9pZCAqYV8sIGNvbnN0IHZvaWQgKmJfKQp7CglzdHJ1Y3QgcmVmaW5mbyAqYSA9ICooKHN0cnVjdCByZWZpbmZvICoqKWFfKTsKCXN0cnVjdCByZWZpbmZvICpiID0gKigoc3RydWN0IHJlZmluZm8gKiopYl8pOwoJc3RydWN0IHJlZl9zb3J0ICpzOwoKCWZvciAocyA9IHJlZl9zb3J0OyBzOyBzID0gcy0+bmV4dCkgewoJCWludCBjbXAgPSBjbXBfcmVmX3NvcnQocywgYSwgYik7CgkJaWYgKGNtcCkKCQkJcmV0dXJuIGNtcDsKCX0KCXJldHVybiAwOwp9CgpzdGF0aWMgdm9pZCBzb3J0X3JlZnMoc3RydWN0IHJlZl9zb3J0ICpzb3J0LCBzdHJ1Y3QgcmVmaW5mbyAqKnJlZnMsIGludCBudW1fcmVmcykKewoJcmVmX3NvcnQgPSBzb3J0OwoJcXNvcnQocmVmcywgbnVtX3JlZnMsIHNpemVvZihzdHJ1Y3QgcmVmaW5mbyAqKSwgY29tcGFyZV9yZWZzKTsKfQoKc3RhdGljIHZvaWQgcHJpbnRfdmFsdWUoc3RydWN0IGF0b21fdmFsdWUgKnYsIGludCBxdW90ZV9zdHlsZSkKewoJc3RydWN0IHN0cmJ1ZiBzYiA9IFNUUkJVRl9JTklUOwoJc3dpdGNoIChxdW90ZV9zdHlsZSkgewoJY2FzZSBRVU9URV9OT05FOgoJCWZwdXRzKHYtPnMsIHN0ZG91dCk7CgkJYnJlYWs7CgljYXNlIFFVT1RFX1NIRUxMOgoJCXNxX3F1b3RlX2J1Zigmc2IsIHYtPnMpOwoJCWJyZWFrOwoJY2FzZSBRVU9URV9QRVJMOgoJCXBlcmxfcXVvdGVfYnVmKCZzYiwgdi0+cyk7CgkJYnJlYWs7CgljYXNlIFFVT1RFX1BZVEhPTjoKCQlweXRob25fcXVvdGVfYnVmKCZzYiwgdi0+cyk7CgkJYnJlYWs7CgljYXNlIFFVT1RFX1RDTDoKCQl0Y2xfcXVvdGVfYnVmKCZzYiwgdi0+cyk7CgkJYnJlYWs7Cgl9CglpZiAocXVvdGVfc3R5bGUgIT0gUVVPVEVfTk9ORSkgewoJCWZwdXRzKHNiLmJ1Ziwgc3Rkb3V0KTsKCQlzdHJidWZfcmVsZWFzZSgmc2IpOwoJfQp9CgpzdGF0aWMgaW50IGhleDEoY2hhciBjaCkKewoJaWYgKCcwJyA8PSBjaCAmJiBjaCA8PSAnOScpCgkJcmV0dXJuIGNoIC0gJzAnOwoJZWxzZSBpZiAoJ2EnIDw9IGNoICYmIGNoIDw9ICdmJykKCQlyZXR1cm4gY2ggLSAnYScgKyAxMDsKCWVsc2UgaWYgKCdBJyA8PSBjaCAmJiBjaCA8PSAnRicpCgkJcmV0dXJuIGNoIC0gJ0EnICsgMTA7CglyZXR1cm4gLTE7Cn0Kc3RhdGljIGludCBoZXgyKGNvbnN0IGNoYXIgKmNwKQp7CglpZiAoY3BbMF0gJiYgY3BbMV0pCgkJcmV0dXJuIChoZXgxKGNwWzBdKSA8PCA0KSB8IGhleDEoY3BbMV0pOwoJZWxzZQoJCXJldHVybiAtMTsKfQoKc3RhdGljIHZvaWQgZW1pdChjb25zdCBjaGFyICpjcCwgY29uc3QgY2hhciAqZXApCnsKCXdoaWxlICgqY3AgJiYgKCFlcCB8fCBjcCA8IGVwKSkgewoJCWlmICgqY3AgPT0gJyUnKSB7CgkJCWlmIChjcFsxXSA9PSAnJScpCgkJCQljcCsrOwoJCQllbHNlIHsKCQkJCWludCBjaCA9IGhleDIoY3AgKyAxKTsKCQkJCWlmICgwIDw9IGNoKSB7CgkJCQkJcHV0Y2hhcihjaCk7CgkJCQkJY3AgKz0gMzsKCQkJCQljb250aW51ZTsKCQkJCX0KCQkJfQoJCX0KCQlwdXRjaGFyKCpjcCk7CgkJY3ArKzsKCX0KfQoKc3RhdGljIHZvaWQgc2hvd19yZWYoc3RydWN0IHJlZmluZm8gKmluZm8sIGNvbnN0IGNoYXIgKmZvcm1hdCwgaW50IHF1b3RlX3N0eWxlKQp7Cgljb25zdCBjaGFyICpjcCwgKnNwLCAqZXA7CgoJZm9yIChjcCA9IGZvcm1hdDsgKmNwICYmIChzcCA9IGZpbmRfbmV4dChjcCkpOyBjcCA9IGVwICsgMSkgewoJCXN0cnVjdCBhdG9tX3ZhbHVlICphdG9tdjsKCgkJZXAgPSBzdHJjaHIoc3AsICcpJyk7CgkJaWYgKGNwIDwgc3ApCgkJCWVtaXQoY3AsIHNwKTsKCQlnZXRfdmFsdWUoaW5mbywgcGFyc2VfYXRvbShzcCArIDIsIGVwKSwgJmF0b212KTsKCQlwcmludF92YWx1ZShhdG9tdiwgcXVvdGVfc3R5bGUpOwoJfQoJaWYgKCpjcCkgewoJCXNwID0gY3AgKyBzdHJsZW4oY3ApOwoJCWVtaXQoY3AsIHNwKTsKCX0KCWlmIChuZWVkX2NvbG9yX3Jlc2V0X2F0X2VvbCkgewoJCXN0cnVjdCBhdG9tX3ZhbHVlIHJlc2V0djsKCQljaGFyIGNvbG9yW0NPTE9SX01BWExFTl0gPSAiIjsKCgkJaWYgKGNvbG9yX3BhcnNlKCJyZXNldCIsIGNvbG9yKSA8IDApCgkJCWRpZSgiQlVHOiBjb3VsZG4ndCBwYXJzZSAncmVzZXQnIGFzIGEgY29sb3IiKTsKCQlyZXNldHYucyA9IGNvbG9yOwoJCXByaW50X3ZhbHVlKCZyZXNldHYsIHF1b3RlX3N0eWxlKTsKCX0KCXB1dGNoYXIoJ1xuJyk7Cn0KCnN0YXRpYyBzdHJ1Y3QgcmVmX3NvcnQgKmRlZmF1bHRfc29ydCh2b2lkKQp7CglzdGF0aWMgY29uc3QgY2hhciBjc3RyX25hbWVbXSA9ICJyZWZuYW1lIjsKCglzdHJ1Y3QgcmVmX3NvcnQgKnNvcnQgPSB4Y2FsbG9jKDEsIHNpemVvZigqc29ydCkpOwoKCXNvcnQtPm5leHQgPSBOVUxMOwoJc29ydC0+YXRvbSA9IHBhcnNlX2F0b20oY3N0cl9uYW1lLCBjc3RyX25hbWUgKyBzdHJsZW4oY3N0cl9uYW1lKSk7CglyZXR1cm4gc29ydDsKfQoKc3RhdGljIGludCBvcHRfcGFyc2Vfc29ydChjb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHQsIGNvbnN0IGNoYXIgKmFyZywgaW50IHVuc2V0KQp7CglzdHJ1Y3QgcmVmX3NvcnQgKipzb3J0X3RhaWwgPSBvcHQtPnZhbHVlOwoJc3RydWN0IHJlZl9zb3J0ICpzOwoJaW50IGxlbjsKCglpZiAoIWFyZykgLyogc2hvdWxkIC0tbm8tc29ydCB2b2lkIHRoZSBsaXN0ID8gKi8KCQlyZXR1cm4gLTE7CgoJcyA9IHhjYWxsb2MoMSwgc2l6ZW9mKCpzKSk7CglzLT5uZXh0ID0gKnNvcnRfdGFpbDsKCSpzb3J0X3RhaWwgPSBzOwoKCWlmICgqYXJnID09ICctJykgewoJCXMtPnJldmVyc2UgPSAxOwoJCWFyZysrOwoJfQoJbGVuID0gc3RybGVuKGFyZyk7CglzLT5hdG9tID0gcGFyc2VfYXRvbShhcmcsIGFyZytsZW4pOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBjaGFyIGNvbnN0ICogY29uc3QgZm9yX2VhY2hfcmVmX3VzYWdlW10gPSB7CglOXygiZ2l0IGZvci1lYWNoLXJlZiBbb3B0aW9uc10gWzxwYXR0ZXJuPl0iKSwKCU5VTEwKfTsKCmludCBjbWRfZm9yX2VhY2hfcmVmKGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndiwgY29uc3QgY2hhciAqcHJlZml4KQp7CglpbnQgaSwgbnVtX3JlZnM7Cgljb25zdCBjaGFyICpmb3JtYXQgPSAiJShvYmplY3RuYW1lKSAlKG9iamVjdHR5cGUpXHQlKHJlZm5hbWUpIjsKCXN0cnVjdCByZWZfc29ydCAqc29ydCA9IE5VTEwsICoqc29ydF90YWlsID0gJnNvcnQ7CglpbnQgbWF4Y291bnQgPSAwLCBxdW90ZV9zdHlsZSA9IDA7CglzdHJ1Y3QgcmVmaW5mbyAqKnJlZnM7CglzdHJ1Y3QgZ3JhYl9yZWZfY2JkYXRhIGNiZGF0YTsKCglzdHJ1Y3Qgb3B0aW9uIG9wdHNbXSA9IHsKCQlPUFRfQklUKCdzJywgInNoZWxsIiwgJnF1b3RlX3N0eWxlLAoJCQlOXygicXVvdGUgcGxhY2Vob2xkZXJzIHN1aXRhYmx5IGZvciBzaGVsbHMiKSwgUVVPVEVfU0hFTEwpLAoJCU9QVF9CSVQoJ3AnLCAicGVybCIsICAmcXVvdGVfc3R5bGUsCgkJCU5fKCJxdW90ZSBwbGFjZWhvbGRlcnMgc3VpdGFibHkgZm9yIHBlcmwiKSwgUVVPVEVfUEVSTCksCgkJT1BUX0JJVCgwICwgInB5dGhvbiIsICZxdW90ZV9zdHlsZSwKCQkJTl8oInF1b3RlIHBsYWNlaG9sZGVycyBzdWl0YWJseSBmb3IgcHl0aG9uIiksIFFVT1RFX1BZVEhPTiksCgkJT1BUX0JJVCgwICwgInRjbCIsICAmcXVvdGVfc3R5bGUsCgkJCU5fKCJxdW90ZSBwbGFjZWhvbGRlcnMgc3VpdGFibHkgZm9yIFRjbCIpLCBRVU9URV9UQ0wpLAoKCQlPUFRfR1JPVVAoIiIpLAoJCU9QVF9JTlRFR0VSKCAwICwgImNvdW50IiwgJm1heGNvdW50LCBOXygic2hvdyBvbmx5IDxuPiBtYXRjaGVkIHJlZnMiKSksCgkJT1BUX1NUUklORyggIDAgLCAiZm9ybWF0IiwgJmZvcm1hdCwgTl8oImZvcm1hdCIpLCBOXygiZm9ybWF0IHRvIHVzZSBmb3IgdGhlIG91dHB1dCIpKSwKCQlPUFRfQ0FMTEJBQ0soMCAsICJzb3J0Iiwgc29ydF90YWlsLCBOXygia2V5IiksCgkJCSAgICBOXygiZmllbGQgbmFtZSB0byBzb3J0IG9uIiksICZvcHRfcGFyc2Vfc29ydCksCgkJT1BUX0VORCgpLAoJfTsKCglwYXJzZV9vcHRpb25zKGFyZ2MsIGFyZ3YsIHByZWZpeCwgb3B0cywgZm9yX2VhY2hfcmVmX3VzYWdlLCAwKTsKCWlmIChtYXhjb3VudCA8IDApIHsKCQllcnJvcigiaW52YWxpZCAtLWNvdW50IGFyZ3VtZW50OiBgJWQnIiwgbWF4Y291bnQpOwoJCXVzYWdlX3dpdGhfb3B0aW9ucyhmb3JfZWFjaF9yZWZfdXNhZ2UsIG9wdHMpOwoJfQoJaWYgKEhBU19NVUxUSV9CSVRTKHF1b3RlX3N0eWxlKSkgewoJCWVycm9yKCJtb3JlIHRoYW4gb25lIHF1b3Rpbmcgc3R5bGU/Iik7CgkJdXNhZ2Vfd2l0aF9vcHRpb25zKGZvcl9lYWNoX3JlZl91c2FnZSwgb3B0cyk7Cgl9CglpZiAodmVyaWZ5X2Zvcm1hdChmb3JtYXQpKQoJCXVzYWdlX3dpdGhfb3B0aW9ucyhmb3JfZWFjaF9yZWZfdXNhZ2UsIG9wdHMpOwoKCWlmICghc29ydCkKCQlzb3J0ID0gZGVmYXVsdF9zb3J0KCk7CgoJLyogZm9yIHdhcm5fYW1iaWd1b3VzX3JlZnMgKi8KCWdpdF9jb25maWcoZ2l0X2RlZmF1bHRfY29uZmlnLCBOVUxMKTsKCgltZW1zZXQoJmNiZGF0YSwgMCwgc2l6ZW9mKGNiZGF0YSkpOwoJY2JkYXRhLmdyYWJfcGF0dGVybiA9IGFyZ3Y7Cglmb3JfZWFjaF9yYXdyZWYoZ3JhYl9zaW5nbGVfcmVmLCAmY2JkYXRhKTsKCXJlZnMgPSBjYmRhdGEuZ3JhYl9hcnJheTsKCW51bV9yZWZzID0gY2JkYXRhLmdyYWJfY250OwoKCXNvcnRfcmVmcyhzb3J0LCByZWZzLCBudW1fcmVmcyk7CgoJaWYgKCFtYXhjb3VudCB8fCBudW1fcmVmcyA8IG1heGNvdW50KQoJCW1heGNvdW50ID0gbnVtX3JlZnM7Cglmb3IgKGkgPSAwOyBpIDwgbWF4Y291bnQ7IGkrKykKCQlzaG93X3JlZihyZWZzW2ldLCBmb3JtYXQsIHF1b3RlX3N0eWxlKTsKCXJldHVybiAwOwp9Cg==",
    "text": "#include \"builtin.h\"\n#include \"cache.h\"\n#include \"refs.h\"\n#include \"object.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"tree.h\"\n#include \"blob.h\"\n#include \"quote.h\"\n#include \"parse-options.h\"\n#include \"remote.h\"\n#include \"color.h\"\n\n/* Quoting styles */\n#define QUOTE_NONE 0\n#define QUOTE_SHELL 1\n#define QUOTE_PERL 2\n#define QUOTE_PYTHON 4\n#define QUOTE_TCL 8\n\ntypedef enum { FIELD_STR, FIELD_ULONG, FIELD_TIME } cmp_type;\n\nstruct atom_value {\n\tconst char *s;\n\tunsigned long ul; /* used for sorting when not FIELD_STR */\n};\n\nstruct ref_sort {\n\tstruct ref_sort *next;\n\tint atom; /* index into used_atom array */\n\tunsigned reverse : 1;\n};\n\nstruct refinfo {\n\tchar *refname;\n\tunsigned char objectname[20];\n\tint flag;\n\tconst char *symref;\n\tstruct atom_value *value;\n};\n\nstatic struct {\n\tconst char *name;\n\tcmp_type cmp_type;\n} valid_atom[] = {\n\t{ \"refname\" },\n\t{ \"objecttype\" },\n\t{ \"objectsize\", FIELD_ULONG },\n\t{ \"objectname\" },\n\t{ \"tree\" },\n\t{ \"parent\" },\n\t{ \"numparent\", FIELD_ULONG },\n\t{ \"object\" },\n\t{ \"type\" },\n\t{ \"tag\" },\n\t{ \"author\" },\n\t{ \"authorname\" },\n\t{ \"authoremail\" },\n\t{ \"authordate\", FIELD_TIME },\n\t{ \"committer\" },\n\t{ \"committername\" },\n\t{ \"committeremail\" },\n\t{ \"committerdate\", FIELD_TIME },\n\t{ \"tagger\" },\n\t{ \"taggername\" },\n\t{ \"taggeremail\" },\n\t{ \"taggerdate\", FIELD_TIME },\n\t{ \"creator\" },\n\t{ \"creatordate\", FIELD_TIME },\n\t{ \"subject\" },\n\t{ \"body\" },\n\t{ \"contents\" },\n\t{ \"contents:subject\" },\n\t{ \"contents:body\" },\n\t{ \"contents:signature\" },\n\t{ \"upstream\" },\n\t{ \"symref\" },\n\t{ \"flag\" },\n\t{ \"HEAD\" },\n\t{ \"color\" },\n};\n\n/*\n * An atom is a valid field atom listed above, possibly prefixed with\n * a \"*\" to denote deref_tag().\n *\n * We parse given format string and sort specifiers, and make a list\n * of properties that we need to extract out of objects.  refinfo\n * structure will hold an array of values extracted that can be\n * indexed with the \"atom number\", which is an index into this\n * array.\n */\nstatic const char **used_atom;\nstatic cmp_type *used_atom_type;\nstatic int used_atom_cnt, need_tagged, need_symref;\nstatic int need_color_reset_at_eol;\n\n/*\n * Used to parse format string and sort specifiers\n */\nstatic int parse_atom(const char *atom, const char *ep)\n{\n\tconst char *sp;\n\tint i, at;\n\n\tsp = atom;\n\tif (*sp == '*' && sp < ep)\n\t\tsp++; /* deref */\n\tif (ep <= sp)\n\t\tdie(\"malformed field name: %.*s\", (int)(ep-atom), atom);\n\n\t/* Do we have the atom already used elsewhere? */\n\tfor (i = 0; i < used_atom_cnt; i++) {\n\t\tint len = strlen(used_atom[i]);\n\t\tif (len == ep - atom && !memcmp(used_atom[i], atom, len))\n\t\t\treturn i;\n\t}\n\n\t/* Is the atom a valid one? */\n\tfor (i = 0; i < ARRAY_SIZE(valid_atom); i++) {\n\t\tint len = strlen(valid_atom[i].name);\n\t\t/*\n\t\t * If the atom name has a colon, strip it and everything after\n\t\t * it off - it specifies the format for this entry, and\n\t\t * shouldn't be used for checking against the valid_atom\n\t\t * table.\n\t\t */\n\t\tconst char *formatp = strchr(sp, ':');\n\t\tif (!formatp || ep < formatp)\n\t\t\tformatp = ep;\n\t\tif (len == formatp - sp && !memcmp(valid_atom[i].name, sp, len))\n\t\t\tbreak;\n\t}\n\n\tif (ARRAY_SIZE(valid_atom) <= i)\n\t\tdie(\"unknown field name: %.*s\", (int)(ep-atom), atom);\n\n\t/* Add it in, including the deref prefix */\n\tat = used_atom_cnt;\n\tused_atom_cnt++;\n\tREALLOC_ARRAY(used_atom, used_atom_cnt);\n\tREALLOC_ARRAY(used_atom_type, used_atom_cnt);\n\tused_atom[at] = xmemdupz(atom, ep - atom);\n\tused_atom_type[at] = valid_atom[i].cmp_type;\n\tif (*atom == '*')\n\t\tneed_tagged = 1;\n\tif (!strcmp(used_atom[at], \"symref\"))\n\t\tneed_symref = 1;\n\treturn at;\n}\n\n/*\n * In a format string, find the next occurrence of %(atom).\n */\nstatic const char *find_next(const char *cp)\n{\n\twhile (*cp) {\n\t\tif (*cp == '%') {\n\t\t\t/*\n\t\t\t * %( is the start of an atom;\n\t\t\t * %% is a quoted per-cent.\n\t\t\t */\n\t\t\tif (cp[1] == '(')\n\t\t\t\treturn cp;\n\t\t\telse if (cp[1] == '%')\n\t\t\t\tcp++; /* skip over two % */\n\t\t\t/* otherwise this is a singleton, literal % */\n\t\t}\n\t\tcp++;\n\t}\n\treturn NULL;\n}\n\n/*\n * Make sure the format string is well formed, and parse out\n * the used atoms.\n */\nstatic int verify_format(const char *format)\n{\n\tconst char *cp, *sp;\n\n\tneed_color_reset_at_eol = 0;\n\tfor (cp = format; *cp && (sp = find_next(cp)); ) {\n\t\tconst char *color, *ep = strchr(sp, ')');\n\t\tint at;\n\n\t\tif (!ep)\n\t\t\treturn error(\"malformed format string %s\", sp);\n\t\t/* sp points at \"%(\" and ep points at the closing \")\" */\n\t\tat = parse_atom(sp + 2, ep);\n\t\tcp = ep + 1;\n\n\t\tif (skip_prefix(used_atom[at], \"color:\", &color))\n\t\t\tneed_color_reset_at_eol = !!strcmp(color, \"reset\");\n\t}\n\treturn 0;\n}\n\n/*\n * Given an object name, read the object data and size, and return a\n * \"struct object\".  If the object data we are returning is also borrowed\n * by the \"struct object\" representation, set *eaten as well---it is a\n * signal from parse_object_buffer to us not to free the buffer.\n */\nstatic void *get_obj(const unsigned char *sha1, struct object **obj, unsigned long *sz, int *eaten)\n{\n\tenum object_type type;\n\tvoid *buf = read_sha1_file(sha1, &type, sz);\n\n\tif (buf)\n\t\t*obj = parse_object_buffer(sha1, type, *sz, buf, eaten);\n\telse\n\t\t*obj = NULL;\n\treturn buf;\n}\n\nstatic int grab_objectname(const char *name, const unsigned char *sha1,\n\t\t\t    struct atom_value *v)\n{\n\tif (!strcmp(name, \"objectname\")) {\n\t\tchar *s = xmalloc(41);\n\t\tstrcpy(s, sha1_to_hex(sha1));\n\t\tv->s = s;\n\t\treturn 1;\n\t}\n\tif (!strcmp(name, \"objectname:short\")) {\n\t\tv->s = xstrdup(find_unique_abbrev(sha1, DEFAULT_ABBREV));\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/* See grab_values */\nstatic void grab_common_values(struct atom_value *val, int deref, struct object *obj, void *buf, unsigned long sz)\n{\n\tint i;\n\n\tfor (i = 0; i < used_atom_cnt; i++) {\n\t\tconst char *name = used_atom[i];\n\t\tstruct atom_value *v = &val[i];\n\t\tif (!!deref != (*name == '*'))\n\t\t\tcontinue;\n\t\tif (deref)\n\t\t\tname++;\n\t\tif (!strcmp(name, \"objecttype\"))\n\t\t\tv->s = typename(obj->type);\n\t\telse if (!strcmp(name, \"objectsize\")) {\n\t\t\tchar *s = xmalloc(40);\n\t\t\tsprintf(s, \"%lu\", sz);\n\t\t\tv->ul = sz;\n\t\t\tv->s = s;\n\t\t}\n\t\telse if (deref)\n\t\t\tgrab_objectname(name, obj->sha1, v);\n\t}\n}\n\n/* See grab_values */\nstatic void grab_tag_values(struct atom_value *val, int deref, struct object *obj, void *buf, unsigned long sz)\n{\n\tint i;\n\tstruct tag *tag = (struct tag *) obj;\n\n\tfor (i = 0; i < used_atom_cnt; i++) {\n\t\tconst char *name = used_atom[i];\n\t\tstruct atom_value *v = &val[i];\n\t\tif (!!deref != (*name == '*'))\n\t\t\tcontinue;\n\t\tif (deref)\n\t\t\tname++;\n\t\tif (!strcmp(name, \"tag\"))\n\t\t\tv->s = tag->tag;\n\t\telse if (!strcmp(name, \"type\") && tag->tagged)\n\t\t\tv->s = typename(tag->tagged->type);\n\t\telse if (!strcmp(name, \"object\") && tag->tagged) {\n\t\t\tchar *s = xmalloc(41);\n\t\t\tstrcpy(s, sha1_to_hex(tag->tagged->sha1));\n\t\t\tv->s = s;\n\t\t}\n\t}\n}\n\n/* See grab_values */\nstatic void grab_commit_values(struct atom_value *val, int deref, struct object *obj, void *buf, unsigned long sz)\n{\n\tint i;\n\tstruct commit *commit = (struct commit *) obj;\n\n\tfor (i = 0; i < used_atom_cnt; i++) {\n\t\tconst char *name = used_atom[i];\n\t\tstruct atom_value *v = &val[i];\n\t\tif (!!deref != (*name == '*'))\n\t\t\tcontinue;\n\t\tif (deref)\n\t\t\tname++;\n\t\tif (!strcmp(name, \"tree\")) {\n\t\t\tchar *s = xmalloc(41);\n\t\t\tstrcpy(s, sha1_to_hex(commit->tree->object.sha1));\n\t\t\tv->s = s;\n\t\t}\n\t\tif (!strcmp(name, \"numparent\")) {\n\t\t\tchar *s = xmalloc(40);\n\t\t\tv->ul = commit_list_count(commit->parents);\n\t\t\tsprintf(s, \"%lu\", v->ul);\n\t\t\tv->s = s;\n\t\t}\n\t\telse if (!strcmp(name, \"parent\")) {\n\t\t\tint num = commit_list_count(commit->parents);\n\t\t\tint i;\n\t\t\tstruct commit_list *parents;\n\t\t\tchar *s = xmalloc(41 * num + 1);\n\t\t\tv->s = s;\n\t\t\tfor (i = 0, parents = commit->parents;\n\t\t\t     parents;\n\t\t\t     parents = parents->next, i = i + 41) {\n\t\t\t\tstruct commit *parent = parents->item;\n\t\t\t\tstrcpy(s+i, sha1_to_hex(parent->object.sha1));\n\t\t\t\tif (parents->next)\n\t\t\t\t\ts[i+40] = ' ';\n\t\t\t}\n\t\t\tif (!i)\n\t\t\t\t*s = '\\0';\n\t\t}\n\t}\n}\n\nstatic const char *find_wholine(const char *who, int wholen, const char *buf, unsigned long sz)\n{\n\tconst char *eol;\n\twhile (*buf) {\n\t\tif (!strncmp(buf, who, wholen) &&\n\t\t    buf[wholen] == ' ')\n\t\t\treturn buf + wholen + 1;\n\t\teol = strchr(buf, '\\n');\n\t\tif (!eol)\n\t\t\treturn \"\";\n\t\teol++;\n\t\tif (*eol == '\\n')\n\t\t\treturn \"\"; /* end of header */\n\t\tbuf = eol;\n\t}\n\treturn \"\";\n}\n\nstatic const char *copy_line(const char *buf)\n{\n\tconst char *eol = strchrnul(buf, '\\n');\n\treturn xmemdupz(buf, eol - buf);\n}\n\nstatic const char *copy_name(const char *buf)\n{\n\tconst char *cp;\n\tfor (cp = buf; *cp && *cp != '\\n'; cp++) {\n\t\tif (!strncmp(cp, \" <\", 2))\n\t\t\treturn xmemdupz(buf, cp - buf);\n\t}\n\treturn \"\";\n}\n\nstatic const char *copy_email(const char *buf)\n{\n\tconst char *email = strchr(buf, '<');\n\tconst char *eoemail;\n\tif (!email)\n\t\treturn \"\";\n\teoemail = strchr(email, '>');\n\tif (!eoemail)\n\t\treturn \"\";\n\treturn xmemdupz(email, eoemail + 1 - email);\n}\n\nstatic char *copy_subject(const char *buf, unsigned long len)\n{\n\tchar *r = xmemdupz(buf, len);\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tif (r[i] == '\\n')\n\t\t\tr[i] = ' ';\n\n\treturn r;\n}\n\nstatic void grab_date(const char *buf, struct atom_value *v, const char *atomname)\n{\n\tconst char *eoemail = strstr(buf, \"> \");\n\tchar *zone;\n\tunsigned long timestamp;\n\tlong tz;\n\tenum date_mode date_mode = DATE_NORMAL;\n\tconst char *formatp;\n\n\t/*\n\t * We got here because atomname ends in \"date\" or \"date<something>\";\n\t * it's not possible that <something> is not \":<format>\" because\n\t * parse_atom() wouldn't have allowed it, so we can assume that no\n\t * \":\" means no format is specified, and use the default.\n\t */\n\tformatp = strchr(atomname, ':');\n\tif (formatp != NULL) {\n\t\tformatp++;\n\t\tdate_mode = parse_date_format(formatp);\n\t}\n\n\tif (!eoemail)\n\t\tgoto bad;\n\ttimestamp = strtoul(eoemail + 2, &zone, 10);\n\tif (timestamp == ULONG_MAX)\n\t\tgoto bad;\n\ttz = strtol(zone, NULL, 10);\n\tif ((tz == LONG_MIN || tz == LONG_MAX) && errno == ERANGE)\n\t\tgoto bad;\n\tv->s = xstrdup(show_date(timestamp, tz, date_mode));\n\tv->ul = timestamp;\n\treturn;\n bad:\n\tv->s = \"\";\n\tv->ul = 0;\n}\n\n/* See grab_values */\nstatic void grab_person(const char *who, struct atom_value *val, int deref, struct object *obj, void *buf, unsigned long sz)\n{\n\tint i;\n\tint wholen = strlen(who);\n\tconst char *wholine = NULL;\n\n\tfor (i = 0; i < used_atom_cnt; i++) {\n\t\tconst char *name = used_atom[i];\n\t\tstruct atom_value *v = &val[i];\n\t\tif (!!deref != (*name == '*'))\n\t\t\tcontinue;\n\t\tif (deref)\n\t\t\tname++;\n\t\tif (strncmp(who, name, wholen))\n\t\t\tcontinue;\n\t\tif (name[wholen] != 0 &&\n\t\t    strcmp(name + wholen, \"name\") &&\n\t\t    strcmp(name + wholen, \"email\") &&\n\t\t    !starts_with(name + wholen, \"date\"))\n\t\t\tcontinue;\n\t\tif (!wholine)\n\t\t\twholine = find_wholine(who, wholen, buf, sz);\n\t\tif (!wholine)\n\t\t\treturn; /* no point looking for it */\n\t\tif (name[wholen] == 0)\n\t\t\tv->s = copy_line(wholine);\n\t\telse if (!strcmp(name + wholen, \"name\"))\n\t\t\tv->s = copy_name(wholine);\n\t\telse if (!strcmp(name + wholen, \"email\"))\n\t\t\tv->s = copy_email(wholine);\n\t\telse if (starts_with(name + wholen, \"date\"))\n\t\t\tgrab_date(wholine, v, name);\n\t}\n\n\t/*\n\t * For a tag or a commit object, if \"creator\" or \"creatordate\" is\n\t * requested, do something special.\n\t */\n\tif (strcmp(who, \"tagger\") && strcmp(who, \"committer\"))\n\t\treturn; /* \"author\" for commit object is not wanted */\n\tif (!wholine)\n\t\twholine = find_wholine(who, wholen, buf, sz);\n\tif (!wholine)\n\t\treturn;\n\tfor (i = 0; i < used_atom_cnt; i++) {\n\t\tconst char *name = used_atom[i];\n\t\tstruct atom_value *v = &val[i];\n\t\tif (!!deref != (*name == '*'))\n\t\t\tcontinue;\n\t\tif (deref)\n\t\t\tname++;\n\n\t\tif (starts_with(name, \"creatordate\"))\n\t\t\tgrab_date(wholine, v, name);\n\t\telse if (!strcmp(name, \"creator\"))\n\t\t\tv->s = copy_line(wholine);\n\t}\n}\n\nstatic void find_subpos(const char *buf, unsigned long sz,\n\t\t\tconst char **sub, unsigned long *sublen,\n\t\t\tconst char **body, unsigned long *bodylen,\n\t\t\tunsigned long *nonsiglen,\n\t\t\tconst char **sig, unsigned long *siglen)\n{\n\tconst char *eol;\n\t/* skip past header until we hit empty line */\n\twhile (*buf && *buf != '\\n') {\n\t\teol = strchrnul(buf, '\\n');\n\t\tif (*eol)\n\t\t\teol++;\n\t\tbuf = eol;\n\t}\n\t/* skip any empty lines */\n\twhile (*buf == '\\n')\n\t\tbuf++;\n\n\t/* parse signature first; we might not even have a subject line */\n\t*sig = buf + parse_signature(buf, strlen(buf));\n\t*siglen = strlen(*sig);\n\n\t/* subject is first non-empty line */\n\t*sub = buf;\n\t/* subject goes to first empty line */\n\twhile (buf < *sig && *buf && *buf != '\\n') {\n\t\teol = strchrnul(buf, '\\n');\n\t\tif (*eol)\n\t\t\teol++;\n\t\tbuf = eol;\n\t}\n\t*sublen = buf - *sub;\n\t/* drop trailing newline, if present */\n\tif (*sublen && (*sub)[*sublen - 1] == '\\n')\n\t\t*sublen -= 1;\n\n\t/* skip any empty lines */\n\twhile (*buf == '\\n')\n\t\tbuf++;\n\t*body = buf;\n\t*bodylen = strlen(buf);\n\t*nonsiglen = *sig - buf;\n}\n\n/* See grab_values */\nstatic void grab_sub_body_contents(struct atom_value *val, int deref, struct object *obj, void *buf, unsigned long sz)\n{\n\tint i;\n\tconst char *subpos = NULL, *bodypos = NULL, *sigpos = NULL;\n\tunsigned long sublen = 0, bodylen = 0, nonsiglen = 0, siglen = 0;\n\n\tfor (i = 0; i < used_atom_cnt; i++) {\n\t\tconst char *name = used_atom[i];\n\t\tstruct atom_value *v = &val[i];\n\t\tif (!!deref != (*name == '*'))\n\t\t\tcontinue;\n\t\tif (deref)\n\t\t\tname++;\n\t\tif (strcmp(name, \"subject\") &&\n\t\t    strcmp(name, \"body\") &&\n\t\t    strcmp(name, \"contents\") &&\n\t\t    strcmp(name, \"contents:subject\") &&\n\t\t    strcmp(name, \"contents:body\") &&\n\t\t    strcmp(name, \"contents:signature\"))\n\t\t\tcontinue;\n\t\tif (!subpos)\n\t\t\tfind_subpos(buf, sz,\n\t\t\t\t    &subpos, &sublen,\n\t\t\t\t    &bodypos, &bodylen, &nonsiglen,\n\t\t\t\t    &sigpos, &siglen);\n\n\t\tif (!strcmp(name, \"subject\"))\n\t\t\tv->s = copy_subject(subpos, sublen);\n\t\telse if (!strcmp(name, \"contents:subject\"))\n\t\t\tv->s = copy_subject(subpos, sublen);\n\t\telse if (!strcmp(name, \"body\"))\n\t\t\tv->s = xmemdupz(bodypos, bodylen);\n\t\telse if (!strcmp(name, \"contents:body\"))\n\t\t\tv->s = xmemdupz(bodypos, nonsiglen);\n\t\telse if (!strcmp(name, \"contents:signature\"))\n\t\t\tv->s = xmemdupz(sigpos, siglen);\n\t\telse if (!strcmp(name, \"contents\"))\n\t\t\tv->s = xstrdup(subpos);\n\t}\n}\n\n/*\n * We want to have empty print-string for field requests\n * that do not apply (e.g. \"authordate\" for a tag object)\n */\nstatic void fill_missing_values(struct atom_value *val)\n{\n\tint i;\n\tfor (i = 0; i < used_atom_cnt; i++) {\n\t\tstruct atom_value *v = &val[i];\n\t\tif (v->s == NULL)\n\t\t\tv->s = \"\";\n\t}\n}\n\n/*\n * val is a list of atom_value to hold returned values.  Extract\n * the values for atoms in used_atom array out of (obj, buf, sz).\n * when deref is false, (obj, buf, sz) is the object that is\n * pointed at by the ref itself; otherwise it is the object the\n * ref (which is a tag) refers to.\n */\nstatic void grab_values(struct atom_value *val, int deref, struct object *obj, void *buf, unsigned long sz)\n{\n\tgrab_common_values(val, deref, obj, buf, sz);\n\tswitch (obj->type) {\n\tcase OBJ_TAG:\n\t\tgrab_tag_values(val, deref, obj, buf, sz);\n\t\tgrab_sub_body_contents(val, deref, obj, buf, sz);\n\t\tgrab_person(\"tagger\", val, deref, obj, buf, sz);\n\t\tbreak;\n\tcase OBJ_COMMIT:\n\t\tgrab_commit_values(val, deref, obj, buf, sz);\n\t\tgrab_sub_body_contents(val, deref, obj, buf, sz);\n\t\tgrab_person(\"author\", val, deref, obj, buf, sz);\n\t\tgrab_person(\"committer\", val, deref, obj, buf, sz);\n\t\tbreak;\n\tcase OBJ_TREE:\n\t\t/* grab_tree_values(val, deref, obj, buf, sz); */\n\t\tbreak;\n\tcase OBJ_BLOB:\n\t\t/* grab_blob_values(val, deref, obj, buf, sz); */\n\t\tbreak;\n\tdefault:\n\t\tdie(\"Eh?  Object of type %d?\", obj->type);\n\t}\n}\n\nstatic inline char *copy_advance(char *dst, const char *src)\n{\n\twhile (*src)\n\t\t*dst++ = *src++;\n\treturn dst;\n}\n\n/*\n * Parse the object referred by ref, and grab needed value.\n */\nstatic void populate_value(struct refinfo *ref)\n{\n\tvoid *buf;\n\tstruct object *obj;\n\tint eaten, i;\n\tunsigned long size;\n\tconst unsigned char *tagged;\n\n\tref->value = xcalloc(used_atom_cnt, sizeof(struct atom_value));\n\n\tif (need_symref && (ref->flag & REF_ISSYMREF) && !ref->symref) {\n\t\tunsigned char unused1[20];\n\t\tref->symref = resolve_refdup(ref->refname, RESOLVE_REF_READING,\n\t\t\t\t\t     unused1, NULL);\n\t\tif (!ref->symref)\n\t\t\tref->symref = \"\";\n\t}\n\n\t/* Fill in specials first */\n\tfor (i = 0; i < used_atom_cnt; i++) {\n\t\tconst char *name = used_atom[i];\n\t\tstruct atom_value *v = &ref->value[i];\n\t\tint deref = 0;\n\t\tconst char *refname;\n\t\tconst char *formatp;\n\t\tstruct branch *branch = NULL;\n\n\t\tif (*name == '*') {\n\t\t\tderef = 1;\n\t\t\tname++;\n\t\t}\n\n\t\tif (starts_with(name, \"refname\"))\n\t\t\trefname = ref->refname;\n\t\telse if (starts_with(name, \"symref\"))\n\t\t\trefname = ref->symref ? ref->symref : \"\";\n\t\telse if (starts_with(name, \"upstream\")) {\n\t\t\t/* only local branches may have an upstream */\n\t\t\tif (!starts_with(ref->refname, \"refs/heads/\"))\n\t\t\t\tcontinue;\n\t\t\tbranch = branch_get(ref->refname + 11);\n\n\t\t\tif (!branch || !branch->merge || !branch->merge[0] ||\n\t\t\t    !branch->merge[0]->dst)\n\t\t\t\tcontinue;\n\t\t\trefname = branch->merge[0]->dst;\n\t\t} else if (starts_with(name, \"color:\")) {\n\t\t\tchar color[COLOR_MAXLEN] = \"\";\n\n\t\t\tif (color_parse(name + 6, color) < 0)\n\t\t\t\tdie(_(\"unable to parse format\"));\n\t\t\tv->s = xstrdup(color);\n\t\t\tcontinue;\n\t\t} else if (!strcmp(name, \"flag\")) {\n\t\t\tchar buf[256], *cp = buf;\n\t\t\tif (ref->flag & REF_ISSYMREF)\n\t\t\t\tcp = copy_advance(cp, \",symref\");\n\t\t\tif (ref->flag & REF_ISPACKED)\n\t\t\t\tcp = copy_advance(cp, \",packed\");\n\t\t\tif (cp == buf)\n\t\t\t\tv->s = \"\";\n\t\t\telse {\n\t\t\t\t*cp = '\\0';\n\t\t\t\tv->s = xstrdup(buf + 1);\n\t\t\t}\n\t\t\tcontinue;\n\t\t} else if (!deref && grab_objectname(name, ref->objectname, v)) {\n\t\t\tcontinue;\n\t\t} else if (!strcmp(name, \"HEAD\")) {\n\t\t\tconst char *head;\n\t\t\tunsigned char sha1[20];\n\n\t\t\thead = resolve_ref_unsafe(\"HEAD\", RESOLVE_REF_READING,\n\t\t\t\t\t\t  sha1, NULL);\n\t\t\tif (!strcmp(ref->refname, head))\n\t\t\t\tv->s = \"*\";\n\t\t\telse\n\t\t\t\tv->s = \" \";\n\t\t\tcontinue;\n\t\t} else\n\t\t\tcontinue;\n\n\t\tformatp = strchr(name, ':');\n\t\tif (formatp) {\n\t\t\tint num_ours, num_theirs;\n\n\t\t\tformatp++;\n\t\t\tif (!strcmp(formatp, \"short\"))\n\t\t\t\trefname = shorten_unambiguous_ref(refname,\n\t\t\t\t\t\t      warn_ambiguous_refs);\n\t\t\telse if (!strcmp(formatp, \"track\") &&\n\t\t\t\t starts_with(name, \"upstream\")) {\n\t\t\t\tchar buf[40];\n\n\t\t\t\tif (stat_tracking_info(branch, &num_ours,\n\t\t\t\t\t\t       &num_theirs) != 1)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (!num_ours && !num_theirs)\n\t\t\t\t\tv->s = \"\";\n\t\t\t\telse if (!num_ours) {\n\t\t\t\t\tsprintf(buf, \"[behind %d]\", num_theirs);\n\t\t\t\t\tv->s = xstrdup(buf);\n\t\t\t\t} else if (!num_theirs) {\n\t\t\t\t\tsprintf(buf, \"[ahead %d]\", num_ours);\n\t\t\t\t\tv->s = xstrdup(buf);\n\t\t\t\t} else {\n\t\t\t\t\tsprintf(buf, \"[ahead %d, behind %d]\",\n\t\t\t\t\t\tnum_ours, num_theirs);\n\t\t\t\t\tv->s = xstrdup(buf);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else if (!strcmp(formatp, \"trackshort\") &&\n\t\t\t\t   starts_with(name, \"upstream\")) {\n\t\t\t\tassert(branch);\n\n\t\t\t\tif (stat_tracking_info(branch, &num_ours,\n\t\t\t\t\t\t\t&num_theirs) != 1)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (!num_ours && !num_theirs)\n\t\t\t\t\tv->s = \"=\";\n\t\t\t\telse if (!num_ours)\n\t\t\t\t\tv->s = \"<\";\n\t\t\t\telse if (!num_theirs)\n\t\t\t\t\tv->s = \">\";\n\t\t\t\telse\n\t\t\t\t\tv->s = \"<>\";\n\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\tdie(\"unknown %.*s format %s\",\n\t\t\t\t    (int)(formatp - name), name, formatp);\n\t\t}\n\n\t\tif (!deref)\n\t\t\tv->s = refname;\n\t\telse {\n\t\t\tint len = strlen(refname);\n\t\t\tchar *s = xmalloc(len + 4);\n\t\t\tsprintf(s, \"%s^{}\", refname);\n\t\t\tv->s = s;\n\t\t}\n\t}\n\n\tfor (i = 0; i < used_atom_cnt; i++) {\n\t\tstruct atom_value *v = &ref->value[i];\n\t\tif (v->s == NULL)\n\t\t\tgoto need_obj;\n\t}\n\treturn;\n\n need_obj:\n\tbuf = get_obj(ref->objectname, &obj, &size, &eaten);\n\tif (!buf)\n\t\tdie(\"missing object %s for %s\",\n\t\t    sha1_to_hex(ref->objectname), ref->refname);\n\tif (!obj)\n\t\tdie(\"parse_object_buffer failed on %s for %s\",\n\t\t    sha1_to_hex(ref->objectname), ref->refname);\n\n\tgrab_values(ref->value, 0, obj, buf, size);\n\tif (!eaten)\n\t\tfree(buf);\n\n\t/*\n\t * If there is no atom that wants to know about tagged\n\t * object, we are done.\n\t */\n\tif (!need_tagged || (obj->type != OBJ_TAG))\n\t\treturn;\n\n\t/*\n\t * If it is a tag object, see if we use a value that derefs\n\t * the object, and if we do grab the object it refers to.\n\t */\n\ttagged = ((struct tag *)obj)->tagged->sha1;\n\n\t/*\n\t * NEEDSWORK: This derefs tag only once, which\n\t * is good to deal with chains of trust, but\n\t * is not consistent with what deref_tag() does\n\t * which peels the onion to the core.\n\t */\n\tbuf = get_obj(tagged, &obj, &size, &eaten);\n\tif (!buf)\n\t\tdie(\"missing object %s for %s\",\n\t\t    sha1_to_hex(tagged), ref->refname);\n\tif (!obj)\n\t\tdie(\"parse_object_buffer failed on %s for %s\",\n\t\t    sha1_to_hex(tagged), ref->refname);\n\tgrab_values(ref->value, 1, obj, buf, size);\n\tif (!eaten)\n\t\tfree(buf);\n}\n\n/*\n * Given a ref, return the value for the atom.  This lazily gets value\n * out of the object by calling populate value.\n */\nstatic void get_value(struct refinfo *ref, int atom, struct atom_value **v)\n{\n\tif (!ref->value) {\n\t\tpopulate_value(ref);\n\t\tfill_missing_values(ref->value);\n\t}\n\t*v = &ref->value[atom];\n}\n\nstruct grab_ref_cbdata {\n\tstruct refinfo **grab_array;\n\tconst char **grab_pattern;\n\tint grab_cnt;\n};\n\n/*\n * A call-back given to for_each_ref().  Filter refs and keep them for\n * later object processing.\n */\nstatic int grab_single_ref(const char *refname, const unsigned char *sha1, int flag, void *cb_data)\n{\n\tstruct grab_ref_cbdata *cb = cb_data;\n\tstruct refinfo *ref;\n\tint cnt;\n\n\tif (flag & REF_BAD_NAME) {\n\t\t  warning(\"ignoring ref with broken name %s\", refname);\n\t\t  return 0;\n\t}\n\n\tif (*cb->grab_pattern) {\n\t\tconst char **pattern;\n\t\tint namelen = strlen(refname);\n\t\tfor (pattern = cb->grab_pattern; *pattern; pattern++) {\n\t\t\tconst char *p = *pattern;\n\t\t\tint plen = strlen(p);\n\n\t\t\tif ((plen <= namelen) &&\n\t\t\t    !strncmp(refname, p, plen) &&\n\t\t\t    (refname[plen] == '\\0' ||\n\t\t\t     refname[plen] == '/' ||\n\t\t\t     p[plen-1] == '/'))\n\t\t\t\tbreak;\n\t\t\tif (!wildmatch(p, refname, WM_PATHNAME, NULL))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!*pattern)\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * We do not open the object yet; sort may only need refname\n\t * to do its job and the resulting list may yet to be pruned\n\t * by maxcount logic.\n\t */\n\tref = xcalloc(1, sizeof(*ref));\n\tref->refname = xstrdup(refname);\n\thashcpy(ref->objectname, sha1);\n\tref->flag = flag;\n\n\tcnt = cb->grab_cnt;\n\tREALLOC_ARRAY(cb->grab_array, cnt + 1);\n\tcb->grab_array[cnt++] = ref;\n\tcb->grab_cnt = cnt;\n\treturn 0;\n}\n\nstatic int cmp_ref_sort(struct ref_sort *s, struct refinfo *a, struct refinfo *b)\n{\n\tstruct atom_value *va, *vb;\n\tint cmp;\n\tcmp_type cmp_type = used_atom_type[s->atom];\n\n\tget_value(a, s->atom, &va);\n\tget_value(b, s->atom, &vb);\n\tswitch (cmp_type) {\n\tcase FIELD_STR:\n\t\tcmp = strcmp(va->s, vb->s);\n\t\tbreak;\n\tdefault:\n\t\tif (va->ul < vb->ul)\n\t\t\tcmp = -1;\n\t\telse if (va->ul == vb->ul)\n\t\t\tcmp = 0;\n\t\telse\n\t\t\tcmp = 1;\n\t\tbreak;\n\t}\n\treturn (s->reverse) ? -cmp : cmp;\n}\n\nstatic struct ref_sort *ref_sort;\nstatic int compare_refs(const void *a_, const void *b_)\n{\n\tstruct refinfo *a = *((struct refinfo **)a_);\n\tstruct refinfo *b = *((struct refinfo **)b_);\n\tstruct ref_sort *s;\n\n\tfor (s = ref_sort; s; s = s->next) {\n\t\tint cmp = cmp_ref_sort(s, a, b);\n\t\tif (cmp)\n\t\t\treturn cmp;\n\t}\n\treturn 0;\n}\n\nstatic void sort_refs(struct ref_sort *sort, struct refinfo **refs, int num_refs)\n{\n\tref_sort = sort;\n\tqsort(refs, num_refs, sizeof(struct refinfo *), compare_refs);\n}\n\nstatic void print_value(struct atom_value *v, int quote_style)\n{\n\tstruct strbuf sb = STRBUF_INIT;\n\tswitch (quote_style) {\n\tcase QUOTE_NONE:\n\t\tfputs(v->s, stdout);\n\t\tbreak;\n\tcase QUOTE_SHELL:\n\t\tsq_quote_buf(&sb, v->s);\n\t\tbreak;\n\tcase QUOTE_PERL:\n\t\tperl_quote_buf(&sb, v->s);\n\t\tbreak;\n\tcase QUOTE_PYTHON:\n\t\tpython_quote_buf(&sb, v->s);\n\t\tbreak;\n\tcase QUOTE_TCL:\n\t\ttcl_quote_buf(&sb, v->s);\n\t\tbreak;\n\t}\n\tif (quote_style != QUOTE_NONE) {\n\t\tfputs(sb.buf, stdout);\n\t\tstrbuf_release(&sb);\n\t}\n}\n\nstatic int hex1(char ch)\n{\n\tif ('0' <= ch && ch <= '9')\n\t\treturn ch - '0';\n\telse if ('a' <= ch && ch <= 'f')\n\t\treturn ch - 'a' + 10;\n\telse if ('A' <= ch && ch <= 'F')\n\t\treturn ch - 'A' + 10;\n\treturn -1;\n}\nstatic int hex2(const char *cp)\n{\n\tif (cp[0] && cp[1])\n\t\treturn (hex1(cp[0]) << 4) | hex1(cp[1]);\n\telse\n\t\treturn -1;\n}\n\nstatic void emit(const char *cp, const char *ep)\n{\n\twhile (*cp && (!ep || cp < ep)) {\n\t\tif (*cp == '%') {\n\t\t\tif (cp[1] == '%')\n\t\t\t\tcp++;\n\t\t\telse {\n\t\t\t\tint ch = hex2(cp + 1);\n\t\t\t\tif (0 <= ch) {\n\t\t\t\t\tputchar(ch);\n\t\t\t\t\tcp += 3;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputchar(*cp);\n\t\tcp++;\n\t}\n}\n\nstatic void show_ref(struct refinfo *info, const char *format, int quote_style)\n{\n\tconst char *cp, *sp, *ep;\n\n\tfor (cp = format; *cp && (sp = find_next(cp)); cp = ep + 1) {\n\t\tstruct atom_value *atomv;\n\n\t\tep = strchr(sp, ')');\n\t\tif (cp < sp)\n\t\t\temit(cp, sp);\n\t\tget_value(info, parse_atom(sp + 2, ep), &atomv);\n\t\tprint_value(atomv, quote_style);\n\t}\n\tif (*cp) {\n\t\tsp = cp + strlen(cp);\n\t\temit(cp, sp);\n\t}\n\tif (need_color_reset_at_eol) {\n\t\tstruct atom_value resetv;\n\t\tchar color[COLOR_MAXLEN] = \"\";\n\n\t\tif (color_parse(\"reset\", color) < 0)\n\t\t\tdie(\"BUG: couldn't parse 'reset' as a color\");\n\t\tresetv.s = color;\n\t\tprint_value(&resetv, quote_style);\n\t}\n\tputchar('\\n');\n}\n\nstatic struct ref_sort *default_sort(void)\n{\n\tstatic const char cstr_name[] = \"refname\";\n\n\tstruct ref_sort *sort = xcalloc(1, sizeof(*sort));\n\n\tsort->next = NULL;\n\tsort->atom = parse_atom(cstr_name, cstr_name + strlen(cstr_name));\n\treturn sort;\n}\n\nstatic int opt_parse_sort(const struct option *opt, const char *arg, int unset)\n{\n\tstruct ref_sort **sort_tail = opt->value;\n\tstruct ref_sort *s;\n\tint len;\n\n\tif (!arg) /* should --no-sort void the list ? */\n\t\treturn -1;\n\n\ts = xcalloc(1, sizeof(*s));\n\ts->next = *sort_tail;\n\t*sort_tail = s;\n\n\tif (*arg == '-') {\n\t\ts->reverse = 1;\n\t\targ++;\n\t}\n\tlen = strlen(arg);\n\ts->atom = parse_atom(arg, arg+len);\n\treturn 0;\n}\n\nstatic char const * const for_each_ref_usage[] = {\n\tN_(\"git for-each-ref [options] [<pattern>]\"),\n\tNULL\n};\n\nint cmd_for_each_ref(int argc, const char **argv, const char *prefix)\n{\n\tint i, num_refs;\n\tconst char *format = \"%(objectname) %(objecttype)\\t%(refname)\";\n\tstruct ref_sort *sort = NULL, **sort_tail = &sort;\n\tint maxcount = 0, quote_style = 0;\n\tstruct refinfo **refs;\n\tstruct grab_ref_cbdata cbdata;\n\n\tstruct option opts[] = {\n\t\tOPT_BIT('s', \"shell\", &quote_style,\n\t\t\tN_(\"quote placeholders suitably for shells\"), QUOTE_SHELL),\n\t\tOPT_BIT('p', \"perl\",  &quote_style,\n\t\t\tN_(\"quote placeholders suitably for perl\"), QUOTE_PERL),\n\t\tOPT_BIT(0 , \"python\", &quote_style,\n\t\t\tN_(\"quote placeholders suitably for python\"), QUOTE_PYTHON),\n\t\tOPT_BIT(0 , \"tcl\",  &quote_style,\n\t\t\tN_(\"quote placeholders suitably for Tcl\"), QUOTE_TCL),\n\n\t\tOPT_GROUP(\"\"),\n\t\tOPT_INTEGER( 0 , \"count\", &maxcount, N_(\"show only <n> matched refs\")),\n\t\tOPT_STRING(  0 , \"format\", &format, N_(\"format\"), N_(\"format to use for the output\")),\n\t\tOPT_CALLBACK(0 , \"sort\", sort_tail, N_(\"key\"),\n\t\t\t    N_(\"field name to sort on\"), &opt_parse_sort),\n\t\tOPT_END(),\n\t};\n\n\tparse_options(argc, argv, prefix, opts, for_each_ref_usage, 0);\n\tif (maxcount < 0) {\n\t\terror(\"invalid --count argument: `%d'\", maxcount);\n\t\tusage_with_options(for_each_ref_usage, opts);\n\t}\n\tif (HAS_MULTI_BITS(quote_style)) {\n\t\terror(\"more than one quoting style?\");\n\t\tusage_with_options(for_each_ref_usage, opts);\n\t}\n\tif (verify_format(format))\n\t\tusage_with_options(for_each_ref_usage, opts);\n\n\tif (!sort)\n\t\tsort = default_sort();\n\n\t/* for warn_ambiguous_refs */\n\tgit_config(git_default_config, NULL);\n\n\tmemset(&cbdata, 0, sizeof(cbdata));\n\tcbdata.grab_pattern = argv;\n\tfor_each_rawref(grab_single_ref, &cbdata);\n\trefs = cbdata.grab_array;\n\tnum_refs = cbdata.grab_cnt;\n\n\tsort_refs(sort, refs, num_refs);\n\n\tif (!maxcount || num_refs < maxcount)\n\t\tmaxcount = num_refs;\n\tfor (i = 0; i < maxcount; i++)\n\t\tshow_ref(refs[i], format, quote_style);\n\treturn 0;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "008513c2f135b5a77d1642ff88e272a7e2f9f9d5",
  "sha1_ok": true,
  "size": 27241
}
