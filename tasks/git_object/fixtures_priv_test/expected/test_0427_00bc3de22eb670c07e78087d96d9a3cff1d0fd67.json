{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJ0YWcuaCIKI2luY2x1ZGUgImNvbW1pdC5oIgoKaW50IHNhdmVfY29tbWl0X2J1ZmZlciA9IDE7CgpzdHJ1Y3Qgc29ydF9ub2RlCnsKCS8qCgkgKiB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIG9mIHRoZSBhc3NvY2lhdGVkIGNvbW1pdAoJICogdGhhdCBhbHNvIG9jY3VyIGluIHRoZSBsaXN0IGJlaW5nIHNvcnRlZC4KCSAqLwoJdW5zaWduZWQgaW50IGluZGVncmVlOwoKCS8qCgkgKiByZWZlcmVuY2UgdG8gb3JpZ2luYWwgbGlzdCBpdGVtIHRoYXQgd2Ugd2lsbCByZS11c2UKCSAqIG9uIG91dHB1dC4KCSAqLwoJc3RydWN0IGNvbW1pdF9saXN0ICogbGlzdF9pdGVtOwoKfTsKCmNvbnN0IGNoYXIgKmNvbW1pdF90eXBlID0gImNvbW1pdCI7CgpzdHJ1Y3QgY210X2ZtdF9tYXAgewoJY29uc3QgY2hhciAqbjsKCXNpemVfdCBjbXBfbGVuOwoJZW51bSBjbWl0X2ZtdCB2Owp9IGNtdF9mbXRzW10gPSB7Cgl7ICJyYXciLAkxLAlDTUlUX0ZNVF9SQVcgfSwKCXsgIm1lZGl1bSIsCTEsCUNNSVRfRk1UX01FRElVTSB9LAoJeyAic2hvcnQiLAkxLAlDTUlUX0ZNVF9TSE9SVCB9LAoJeyAiZW1haWwiLAkxLAlDTUlUX0ZNVF9FTUFJTCB9LAoJeyAiZnVsbCIsCTUsCUNNSVRfRk1UX0ZVTEwgfSwKCXsgImZ1bGxlciIsCTUsCUNNSVRfRk1UX0ZVTExFUiB9LAoJeyAib25lbGluZSIsCTEsCUNNSVRfRk1UX09ORUxJTkUgfSwKfTsKCmVudW0gY21pdF9mbXQgZ2V0X2NvbW1pdF9mb3JtYXQoY29uc3QgY2hhciAqYXJnKQp7CglpbnQgaTsKCglpZiAoIWFyZyB8fCAhKmFyZykKCQlyZXR1cm4gQ01JVF9GTVRfREVGQVVMVDsKCWlmICgqYXJnID09ICc9JykKCQlhcmcrKzsKCWZvciAoaSA9IDA7IGkgPCBBUlJBWV9TSVpFKGNtdF9mbXRzKTsgaSsrKSB7CgkJaWYgKCFzdHJuY21wKGFyZywgY210X2ZtdHNbaV0ubiwgY210X2ZtdHNbaV0uY21wX2xlbikpCgkJCXJldHVybiBjbXRfZm10c1tpXS52OwoJfQoKCWRpZSgiaW52YWxpZCAtLXByZXR0eSBmb3JtYXQ6ICVzIiwgYXJnKTsKfQoKc3RhdGljIHN0cnVjdCBjb21taXQgKmNoZWNrX2NvbW1pdChzdHJ1Y3Qgb2JqZWN0ICpvYmosCgkJCQkgICBjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExLAoJCQkJICAgaW50IHF1aWV0KQp7CglpZiAob2JqLT50eXBlICE9IE9CSl9DT01NSVQpIHsKCQlpZiAoIXF1aWV0KQoJCQllcnJvcigiT2JqZWN0ICVzIGlzIGEgJXMsIG5vdCBhIGNvbW1pdCIsCgkJCSAgICAgIHNoYTFfdG9faGV4KHNoYTEpLCB0eXBlbmFtZShvYmotPnR5cGUpKTsKCQlyZXR1cm4gTlVMTDsKCX0KCXJldHVybiAoc3RydWN0IGNvbW1pdCAqKSBvYmo7Cn0KCnN0cnVjdCBjb21taXQgKmxvb2t1cF9jb21taXRfcmVmZXJlbmNlX2dlbnRseShjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExLAoJCQkJCSAgICAgIGludCBxdWlldCkKewoJc3RydWN0IG9iamVjdCAqb2JqID0gZGVyZWZfdGFnKHBhcnNlX29iamVjdChzaGExKSwgTlVMTCwgMCk7CgoJaWYgKCFvYmopCgkJcmV0dXJuIE5VTEw7CglyZXR1cm4gY2hlY2tfY29tbWl0KG9iaiwgc2hhMSwgcXVpZXQpOwp9CgpzdHJ1Y3QgY29tbWl0ICpsb29rdXBfY29tbWl0X3JlZmVyZW5jZShjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExKQp7CglyZXR1cm4gbG9va3VwX2NvbW1pdF9yZWZlcmVuY2VfZ2VudGx5KHNoYTEsIDApOwp9CgpzdHJ1Y3QgY29tbWl0ICpsb29rdXBfY29tbWl0KGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEpCnsKCXN0cnVjdCBvYmplY3QgKm9iaiA9IGxvb2t1cF9vYmplY3Qoc2hhMSk7CglpZiAoIW9iaikgewoJCXN0cnVjdCBjb21taXQgKnJldCA9IGFsbG9jX2NvbW1pdF9ub2RlKCk7CgkJY3JlYXRlZF9vYmplY3Qoc2hhMSwgJnJldC0+b2JqZWN0KTsKCQlyZXQtPm9iamVjdC50eXBlID0gT0JKX0NPTU1JVDsKCQlyZXR1cm4gcmV0OwoJfQoJaWYgKCFvYmotPnR5cGUpCgkJb2JqLT50eXBlID0gT0JKX0NPTU1JVDsKCXJldHVybiBjaGVja19jb21taXQob2JqLCBzaGExLCAwKTsKfQoKc3RhdGljIHVuc2lnbmVkIGxvbmcgcGFyc2VfY29tbWl0X2RhdGUoY29uc3QgY2hhciAqYnVmKQp7Cgl1bnNpZ25lZCBsb25nIGRhdGU7CgoJaWYgKG1lbWNtcChidWYsICJhdXRob3IiLCA2KSkKCQlyZXR1cm4gMDsKCXdoaWxlICgqYnVmKysgIT0gJ1xuJykKCQkvKiBuYWRhICovOwoJaWYgKG1lbWNtcChidWYsICJjb21taXR0ZXIiLCA5KSkKCQlyZXR1cm4gMDsKCXdoaWxlICgqYnVmKysgIT0gJz4nKQoJCS8qIG5hZGEgKi87CglkYXRlID0gc3RydG91bChidWYsIE5VTEwsIDEwKTsKCWlmIChkYXRlID09IFVMT05HX01BWCkKCQlkYXRlID0gMDsKCXJldHVybiBkYXRlOwp9CgpzdGF0aWMgc3RydWN0IGNvbW1pdF9ncmFmdCAqKmNvbW1pdF9ncmFmdDsKc3RhdGljIGludCBjb21taXRfZ3JhZnRfYWxsb2MsIGNvbW1pdF9ncmFmdF9ucjsKCnN0YXRpYyBpbnQgY29tbWl0X2dyYWZ0X3Bvcyhjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExKQp7CglpbnQgbG8sIGhpOwoJbG8gPSAwOwoJaGkgPSBjb21taXRfZ3JhZnRfbnI7Cgl3aGlsZSAobG8gPCBoaSkgewoJCWludCBtaSA9IChsbyArIGhpKSAvIDI7CgkJc3RydWN0IGNvbW1pdF9ncmFmdCAqZ3JhZnQgPSBjb21taXRfZ3JhZnRbbWldOwoJCWludCBjbXAgPSBoYXNoY21wKHNoYTEsIGdyYWZ0LT5zaGExKTsKCQlpZiAoIWNtcCkKCQkJcmV0dXJuIG1pOwoJCWlmIChjbXAgPCAwKQoJCQloaSA9IG1pOwoJCWVsc2UKCQkJbG8gPSBtaSArIDE7Cgl9CglyZXR1cm4gLWxvIC0gMTsKfQoKaW50IHJlZ2lzdGVyX2NvbW1pdF9ncmFmdChzdHJ1Y3QgY29tbWl0X2dyYWZ0ICpncmFmdCwgaW50IGlnbm9yZV9kdXBzKQp7CglpbnQgcG9zID0gY29tbWl0X2dyYWZ0X3BvcyhncmFmdC0+c2hhMSk7CgkKCWlmICgwIDw9IHBvcykgewoJCWlmIChpZ25vcmVfZHVwcykKCQkJZnJlZShncmFmdCk7CgkJZWxzZSB7CgkJCWZyZWUoY29tbWl0X2dyYWZ0W3Bvc10pOwoJCQljb21taXRfZ3JhZnRbcG9zXSA9IGdyYWZ0OwoJCX0KCQlyZXR1cm4gMTsKCX0KCXBvcyA9IC1wb3MgLSAxOwoJaWYgKGNvbW1pdF9ncmFmdF9hbGxvYyA8PSArK2NvbW1pdF9ncmFmdF9ucikgewoJCWNvbW1pdF9ncmFmdF9hbGxvYyA9IGFsbG9jX25yKGNvbW1pdF9ncmFmdF9hbGxvYyk7CgkJY29tbWl0X2dyYWZ0ID0geHJlYWxsb2MoY29tbWl0X2dyYWZ0LAoJCQkJCXNpemVvZigqY29tbWl0X2dyYWZ0KSAqCgkJCQkJY29tbWl0X2dyYWZ0X2FsbG9jKTsKCX0KCWlmIChwb3MgPCBjb21taXRfZ3JhZnRfbnIpCgkJbWVtbW92ZShjb21taXRfZ3JhZnQgKyBwb3MgKyAxLAoJCQljb21taXRfZ3JhZnQgKyBwb3MsCgkJCShjb21taXRfZ3JhZnRfbnIgLSBwb3MgLSAxKSAqCgkJCXNpemVvZigqY29tbWl0X2dyYWZ0KSk7Cgljb21taXRfZ3JhZnRbcG9zXSA9IGdyYWZ0OwoJcmV0dXJuIDA7Cn0KCnN0cnVjdCBjb21taXRfZ3JhZnQgKnJlYWRfZ3JhZnRfbGluZShjaGFyICpidWYsIGludCBsZW4pCnsKCS8qIFRoZSBmb3JtYXQgaXMganVzdCAiQ29tbWl0IFBhcmVudDEgUGFyZW50MiAuLi5cbiIgKi8KCWludCBpOwoJc3RydWN0IGNvbW1pdF9ncmFmdCAqZ3JhZnQgPSBOVUxMOwoKCWlmIChidWZbbGVuLTFdID09ICdcbicpCgkJYnVmWy0tbGVuXSA9IDA7CglpZiAoYnVmWzBdID09ICcjJyB8fCBidWZbMF0gPT0gJ1wwJykKCQlyZXR1cm4gTlVMTDsKCWlmICgobGVuICsgMSkgJSA0MSkgewoJYmFkX2dyYWZ0X2RhdGE6CgkJZXJyb3IoImJhZCBncmFmdCBkYXRhOiAlcyIsIGJ1Zik7CgkJZnJlZShncmFmdCk7CgkJcmV0dXJuIE5VTEw7Cgl9CglpID0gKGxlbiArIDEpIC8gNDEgLSAxOwoJZ3JhZnQgPSB4bWFsbG9jKHNpemVvZigqZ3JhZnQpICsgMjAgKiBpKTsKCWdyYWZ0LT5ucl9wYXJlbnQgPSBpOwoJaWYgKGdldF9zaGExX2hleChidWYsIGdyYWZ0LT5zaGExKSkKCQlnb3RvIGJhZF9ncmFmdF9kYXRhOwoJZm9yIChpID0gNDA7IGkgPCBsZW47IGkgKz0gNDEpIHsKCQlpZiAoYnVmW2ldICE9ICcgJykKCQkJZ290byBiYWRfZ3JhZnRfZGF0YTsKCQlpZiAoZ2V0X3NoYTFfaGV4KGJ1ZiArIGkgKyAxLCBncmFmdC0+cGFyZW50W2kvNDFdKSkKCQkJZ290byBiYWRfZ3JhZnRfZGF0YTsKCX0KCXJldHVybiBncmFmdDsKfQoKaW50IHJlYWRfZ3JhZnRfZmlsZShjb25zdCBjaGFyICpncmFmdF9maWxlKQp7CglGSUxFICpmcCA9IGZvcGVuKGdyYWZ0X2ZpbGUsICJyIik7CgljaGFyIGJ1ZlsxMDI0XTsKCWlmICghZnApCgkJcmV0dXJuIC0xOwoJd2hpbGUgKGZnZXRzKGJ1Ziwgc2l6ZW9mKGJ1ZiksIGZwKSkgewoJCS8qIFRoZSBmb3JtYXQgaXMganVzdCAiQ29tbWl0IFBhcmVudDEgUGFyZW50MiAuLi5cbiIgKi8KCQlpbnQgbGVuID0gc3RybGVuKGJ1Zik7CgkJc3RydWN0IGNvbW1pdF9ncmFmdCAqZ3JhZnQgPSByZWFkX2dyYWZ0X2xpbmUoYnVmLCBsZW4pOwoJCWlmICghZ3JhZnQpCgkJCWNvbnRpbnVlOwoJCWlmIChyZWdpc3Rlcl9jb21taXRfZ3JhZnQoZ3JhZnQsIDEpKQoJCQllcnJvcigiZHVwbGljYXRlIGdyYWZ0IGRhdGE6ICVzIiwgYnVmKTsKCX0KCWZjbG9zZShmcCk7CglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgcHJlcGFyZV9jb21taXRfZ3JhZnQodm9pZCkKewoJc3RhdGljIGludCBjb21taXRfZ3JhZnRfcHJlcGFyZWQ7CgljaGFyICpncmFmdF9maWxlOwoKCWlmIChjb21taXRfZ3JhZnRfcHJlcGFyZWQpCgkJcmV0dXJuOwoJZ3JhZnRfZmlsZSA9IGdldF9ncmFmdF9maWxlKCk7CglyZWFkX2dyYWZ0X2ZpbGUoZ3JhZnRfZmlsZSk7Cgljb21taXRfZ3JhZnRfcHJlcGFyZWQgPSAxOwp9CgpzdGF0aWMgc3RydWN0IGNvbW1pdF9ncmFmdCAqbG9va3VwX2NvbW1pdF9ncmFmdChjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExKQp7CglpbnQgcG9zOwoJcHJlcGFyZV9jb21taXRfZ3JhZnQoKTsKCXBvcyA9IGNvbW1pdF9ncmFmdF9wb3Moc2hhMSk7CglpZiAocG9zIDwgMCkKCQlyZXR1cm4gTlVMTDsKCXJldHVybiBjb21taXRfZ3JhZnRbcG9zXTsKfQoKaW50IHBhcnNlX2NvbW1pdF9idWZmZXIoc3RydWN0IGNvbW1pdCAqaXRlbSwgdm9pZCAqYnVmZmVyLCB1bnNpZ25lZCBsb25nIHNpemUpCnsKCWNoYXIgKnRhaWwgPSBidWZmZXI7CgljaGFyICpidWZwdHIgPSBidWZmZXI7Cgl1bnNpZ25lZCBjaGFyIHBhcmVudFsyMF07CglzdHJ1Y3QgY29tbWl0X2xpc3QgKipwcHRyOwoJc3RydWN0IGNvbW1pdF9ncmFmdCAqZ3JhZnQ7Cgl1bnNpZ25lZCBuX3JlZnMgPSAwOwoKCWlmIChpdGVtLT5vYmplY3QucGFyc2VkKQoJCXJldHVybiAwOwoJaXRlbS0+b2JqZWN0LnBhcnNlZCA9IDE7Cgl0YWlsICs9IHNpemU7CglpZiAodGFpbCA8PSBidWZwdHIgKyA1IHx8IG1lbWNtcChidWZwdHIsICJ0cmVlICIsIDUpKQoJCXJldHVybiBlcnJvcigiYm9ndXMgY29tbWl0IG9iamVjdCAlcyIsIHNoYTFfdG9faGV4KGl0ZW0tPm9iamVjdC5zaGExKSk7CglpZiAodGFpbCA8PSBidWZwdHIgKyA0NSB8fCBnZXRfc2hhMV9oZXgoYnVmcHRyICsgNSwgcGFyZW50KSA8IDApCgkJcmV0dXJuIGVycm9yKCJiYWQgdHJlZSBwb2ludGVyIGluIGNvbW1pdCAlcyIsCgkJCSAgICAgc2hhMV90b19oZXgoaXRlbS0+b2JqZWN0LnNoYTEpKTsKCWl0ZW0tPnRyZWUgPSBsb29rdXBfdHJlZShwYXJlbnQpOwoJaWYgKGl0ZW0tPnRyZWUpCgkJbl9yZWZzKys7CglidWZwdHIgKz0gNDY7IC8qICJ0cmVlICIgKyAiaGV4IHNoYTEiICsgIlxuIiAqLwoJcHB0ciA9ICZpdGVtLT5wYXJlbnRzOwoKCWdyYWZ0ID0gbG9va3VwX2NvbW1pdF9ncmFmdChpdGVtLT5vYmplY3Quc2hhMSk7Cgl3aGlsZSAoYnVmcHRyICsgNDggPCB0YWlsICYmICFtZW1jbXAoYnVmcHRyLCAicGFyZW50ICIsIDcpKSB7CgkJc3RydWN0IGNvbW1pdCAqbmV3X3BhcmVudDsKCgkJaWYgKHRhaWwgPD0gYnVmcHRyICsgNDggfHwKCQkgICAgZ2V0X3NoYTFfaGV4KGJ1ZnB0ciArIDcsIHBhcmVudCkgfHwKCQkgICAgYnVmcHRyWzQ3XSAhPSAnXG4nKQoJCQlyZXR1cm4gZXJyb3IoImJhZCBwYXJlbnRzIGluIGNvbW1pdCAlcyIsIHNoYTFfdG9faGV4KGl0ZW0tPm9iamVjdC5zaGExKSk7CgkJYnVmcHRyICs9IDQ4OwoJCWlmIChncmFmdCkKCQkJY29udGludWU7CgkJbmV3X3BhcmVudCA9IGxvb2t1cF9jb21taXQocGFyZW50KTsKCQlpZiAobmV3X3BhcmVudCkgewoJCQlwcHRyID0gJmNvbW1pdF9saXN0X2luc2VydChuZXdfcGFyZW50LCBwcHRyKS0+bmV4dDsKCQkJbl9yZWZzKys7CgkJfQoJfQoJaWYgKGdyYWZ0KSB7CgkJaW50IGk7CgkJc3RydWN0IGNvbW1pdCAqbmV3X3BhcmVudDsKCQlmb3IgKGkgPSAwOyBpIDwgZ3JhZnQtPm5yX3BhcmVudDsgaSsrKSB7CgkJCW5ld19wYXJlbnQgPSBsb29rdXBfY29tbWl0KGdyYWZ0LT5wYXJlbnRbaV0pOwoJCQlpZiAoIW5ld19wYXJlbnQpCgkJCQljb250aW51ZTsKCQkJcHB0ciA9ICZjb21taXRfbGlzdF9pbnNlcnQobmV3X3BhcmVudCwgcHB0ciktPm5leHQ7CgkJCW5fcmVmcysrOwoJCX0KCX0KCWl0ZW0tPmRhdGUgPSBwYXJzZV9jb21taXRfZGF0ZShidWZwdHIpOwoKCWlmICh0cmFja19vYmplY3RfcmVmcykgewoJCXVuc2lnbmVkIGkgPSAwOwoJCXN0cnVjdCBjb21taXRfbGlzdCAqcDsKCQlzdHJ1Y3Qgb2JqZWN0X3JlZnMgKnJlZnMgPSBhbGxvY19vYmplY3RfcmVmcyhuX3JlZnMpOwoJCWlmIChpdGVtLT50cmVlKQoJCQlyZWZzLT5yZWZbaSsrXSA9ICZpdGVtLT50cmVlLT5vYmplY3Q7CgkJZm9yIChwID0gaXRlbS0+cGFyZW50czsgcDsgcCA9IHAtPm5leHQpCgkJCXJlZnMtPnJlZltpKytdID0gJnAtPml0ZW0tPm9iamVjdDsKCQlzZXRfb2JqZWN0X3JlZnMoJml0ZW0tPm9iamVjdCwgcmVmcyk7Cgl9CgoJcmV0dXJuIDA7Cn0KCmludCBwYXJzZV9jb21taXQoc3RydWN0IGNvbW1pdCAqaXRlbSkKewoJY2hhciB0eXBlWzIwXTsKCXZvaWQgKmJ1ZmZlcjsKCXVuc2lnbmVkIGxvbmcgc2l6ZTsKCWludCByZXQ7CgoJaWYgKGl0ZW0tPm9iamVjdC5wYXJzZWQpCgkJcmV0dXJuIDA7CglidWZmZXIgPSByZWFkX3NoYTFfZmlsZShpdGVtLT5vYmplY3Quc2hhMSwgdHlwZSwgJnNpemUpOwoJaWYgKCFidWZmZXIpCgkJcmV0dXJuIGVycm9yKCJDb3VsZCBub3QgcmVhZCAlcyIsCgkJCSAgICAgc2hhMV90b19oZXgoaXRlbS0+b2JqZWN0LnNoYTEpKTsKCWlmIChzdHJjbXAodHlwZSwgY29tbWl0X3R5cGUpKSB7CgkJZnJlZShidWZmZXIpOwoJCXJldHVybiBlcnJvcigiT2JqZWN0ICVzIG5vdCBhIGNvbW1pdCIsCgkJCSAgICAgc2hhMV90b19oZXgoaXRlbS0+b2JqZWN0LnNoYTEpKTsKCX0KCXJldCA9IHBhcnNlX2NvbW1pdF9idWZmZXIoaXRlbSwgYnVmZmVyLCBzaXplKTsKCWlmIChzYXZlX2NvbW1pdF9idWZmZXIgJiYgIXJldCkgewoJCWl0ZW0tPmJ1ZmZlciA9IGJ1ZmZlcjsKCQlyZXR1cm4gMDsKCX0KCWZyZWUoYnVmZmVyKTsKCXJldHVybiByZXQ7Cn0KCnN0cnVjdCBjb21taXRfbGlzdCAqY29tbWl0X2xpc3RfaW5zZXJ0KHN0cnVjdCBjb21taXQgKml0ZW0sIHN0cnVjdCBjb21taXRfbGlzdCAqKmxpc3RfcCkKewoJc3RydWN0IGNvbW1pdF9saXN0ICpuZXdfbGlzdCA9IHhtYWxsb2Moc2l6ZW9mKHN0cnVjdCBjb21taXRfbGlzdCkpOwoJbmV3X2xpc3QtPml0ZW0gPSBpdGVtOwoJbmV3X2xpc3QtPm5leHQgPSAqbGlzdF9wOwoJKmxpc3RfcCA9IG5ld19saXN0OwoJcmV0dXJuIG5ld19saXN0Owp9Cgp2b2lkIGZyZWVfY29tbWl0X2xpc3Qoc3RydWN0IGNvbW1pdF9saXN0ICpsaXN0KQp7Cgl3aGlsZSAobGlzdCkgewoJCXN0cnVjdCBjb21taXRfbGlzdCAqdGVtcCA9IGxpc3Q7CgkJbGlzdCA9IHRlbXAtPm5leHQ7CgkJZnJlZSh0ZW1wKTsKCX0KfQoKc3RydWN0IGNvbW1pdF9saXN0ICogaW5zZXJ0X2J5X2RhdGUoc3RydWN0IGNvbW1pdCAqaXRlbSwgc3RydWN0IGNvbW1pdF9saXN0ICoqbGlzdCkKewoJc3RydWN0IGNvbW1pdF9saXN0ICoqcHAgPSBsaXN0OwoJc3RydWN0IGNvbW1pdF9saXN0ICpwOwoJd2hpbGUgKChwID0gKnBwKSAhPSBOVUxMKSB7CgkJaWYgKHAtPml0ZW0tPmRhdGUgPCBpdGVtLT5kYXRlKSB7CgkJCWJyZWFrOwoJCX0KCQlwcCA9ICZwLT5uZXh0OwoJfQoJcmV0dXJuIGNvbW1pdF9saXN0X2luc2VydChpdGVtLCBwcCk7Cn0KCgkKdm9pZCBzb3J0X2J5X2RhdGUoc3RydWN0IGNvbW1pdF9saXN0ICoqbGlzdCkKewoJc3RydWN0IGNvbW1pdF9saXN0ICpyZXQgPSBOVUxMOwoJd2hpbGUgKCpsaXN0KSB7CgkJaW5zZXJ0X2J5X2RhdGUoKCpsaXN0KS0+aXRlbSwgJnJldCk7CgkJKmxpc3QgPSAoKmxpc3QpLT5uZXh0OwoJfQoJKmxpc3QgPSByZXQ7Cn0KCnN0cnVjdCBjb21taXQgKnBvcF9tb3N0X3JlY2VudF9jb21taXQoc3RydWN0IGNvbW1pdF9saXN0ICoqbGlzdCwKCQkJCSAgICAgIHVuc2lnbmVkIGludCBtYXJrKQp7CglzdHJ1Y3QgY29tbWl0ICpyZXQgPSAoKmxpc3QpLT5pdGVtOwoJc3RydWN0IGNvbW1pdF9saXN0ICpwYXJlbnRzID0gcmV0LT5wYXJlbnRzOwoJc3RydWN0IGNvbW1pdF9saXN0ICpvbGQgPSAqbGlzdDsKCgkqbGlzdCA9ICgqbGlzdCktPm5leHQ7CglmcmVlKG9sZCk7CgoJd2hpbGUgKHBhcmVudHMpIHsKCQlzdHJ1Y3QgY29tbWl0ICpjb21taXQgPSBwYXJlbnRzLT5pdGVtOwoJCXBhcnNlX2NvbW1pdChjb21taXQpOwoJCWlmICghKGNvbW1pdC0+b2JqZWN0LmZsYWdzICYgbWFyaykpIHsKCQkJY29tbWl0LT5vYmplY3QuZmxhZ3MgfD0gbWFyazsKCQkJaW5zZXJ0X2J5X2RhdGUoY29tbWl0LCBsaXN0KTsKCQl9CgkJcGFyZW50cyA9IHBhcmVudHMtPm5leHQ7Cgl9CglyZXR1cm4gcmV0Owp9Cgp2b2lkIGNsZWFyX2NvbW1pdF9tYXJrcyhzdHJ1Y3QgY29tbWl0ICpjb21taXQsIHVuc2lnbmVkIGludCBtYXJrKQp7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKnBhcmVudHM7CgoJY29tbWl0LT5vYmplY3QuZmxhZ3MgJj0gfm1hcms7CglwYXJlbnRzID0gY29tbWl0LT5wYXJlbnRzOwoJd2hpbGUgKHBhcmVudHMpIHsKCQlzdHJ1Y3QgY29tbWl0ICpwYXJlbnQgPSBwYXJlbnRzLT5pdGVtOwoKCQkvKiBIYXZlIHdlIGFscmVhZHkgY2xlYXJlZCB0aGlzPyAqLwoJCWlmIChtYXJrICYgcGFyZW50LT5vYmplY3QuZmxhZ3MpCgkJCWNsZWFyX2NvbW1pdF9tYXJrcyhwYXJlbnQsIG1hcmspOwoJCXBhcmVudHMgPSBwYXJlbnRzLT5uZXh0OwoJfQp9CgovKgogKiBHZW5lcmljIHN1cHBvcnQgZm9yIHByZXR0eS1wcmludGluZyB0aGUgaGVhZGVyCiAqLwpzdGF0aWMgaW50IGdldF9vbmVfbGluZShjb25zdCBjaGFyICptc2csIHVuc2lnbmVkIGxvbmcgbGVuKQp7CglpbnQgcmV0ID0gMDsKCgl3aGlsZSAobGVuLS0pIHsKCQljaGFyIGMgPSAqbXNnKys7CgkJaWYgKCFjKQoJCQlicmVhazsKCQlyZXQrKzsKCQlpZiAoYyA9PSAnXG4nKQoJCQlicmVhazsKCX0KCXJldHVybiByZXQ7Cn0KCnN0YXRpYyBpbnQgaXNfcmZjMjA0N19zcGVjaWFsKGNoYXIgY2gpCnsKCXJldHVybiAoKGNoICYgMHg4MCkgfHwgKGNoID09ICc9JykgfHwgKGNoID09ICc/JykgfHwgKGNoID09ICdfJykpOwp9CgpzdGF0aWMgaW50IGFkZF9yZmMyMDQ3KGNoYXIgKmJ1ZiwgY29uc3QgY2hhciAqbGluZSwgaW50IGxlbikKewoJY2hhciAqYnAgPSBidWY7CglpbnQgaSwgbmVlZHF1b3RlOwoJc3RhdGljIGNvbnN0IGNoYXIgcV91dGY4W10gPSAiPT91dGYtOD9xPyI7CgoJZm9yIChpID0gbmVlZHF1b3RlID0gMDsgIW5lZWRxdW90ZSAmJiBpIDwgbGVuOyBpKyspIHsKCQl1bnNpZ25lZCBjaCA9IGxpbmVbaV07CgkJaWYgKGNoICYgMHg4MCkKCQkJbmVlZHF1b3RlKys7CgkJaWYgKChpICsgMSA8IGxlbikgJiYKCQkgICAgKGNoID09ICc9JyAmJiBsaW5lW2krMV0gPT0gJz8nKSkKCQkJbmVlZHF1b3RlKys7Cgl9CglpZiAoIW5lZWRxdW90ZSkKCQlyZXR1cm4gc3ByaW50ZihidWYsICIlLipzIiwgbGVuLCBsaW5lKTsKCgltZW1jcHkoYnAsIHFfdXRmOCwgc2l6ZW9mKHFfdXRmOCktMSk7CglicCArPSBzaXplb2YocV91dGY4KS0xOwoJZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7CgkJdW5zaWduZWQgY2ggPSBsaW5lW2ldICYgMHhGRjsKCQlpZiAoaXNfcmZjMjA0N19zcGVjaWFsKGNoKSkgewoJCQlzcHJpbnRmKGJwLCAiPSUwMlgiLCBjaCk7CgkJCWJwICs9IDM7CgkJfQoJCWVsc2UgaWYgKGNoID09ICcgJykKCQkJKmJwKysgPSAnXyc7CgkJZWxzZQoJCQkqYnArKyA9IGNoOwoJfQoJbWVtY3B5KGJwLCAiPz0iLCAyKTsKCWJwICs9IDI7CglyZXR1cm4gYnAgLSBidWY7Cn0KCnN0YXRpYyBpbnQgYWRkX3VzZXJfaW5mbyhjb25zdCBjaGFyICp3aGF0LCBlbnVtIGNtaXRfZm10IGZtdCwgY2hhciAqYnVmLCBjb25zdCBjaGFyICpsaW5lKQp7CgljaGFyICpkYXRlOwoJaW50IG5hbWVsZW47Cgl1bnNpZ25lZCBsb25nIHRpbWU7CglpbnQgdHosIHJldDsKCWNvbnN0IGNoYXIgKmZpbGxlciA9ICIgICAgIjsKCglpZiAoZm10ID09IENNSVRfRk1UX09ORUxJTkUpCgkJcmV0dXJuIDA7CglkYXRlID0gc3RyY2hyKGxpbmUsICc+Jyk7CglpZiAoIWRhdGUpCgkJcmV0dXJuIDA7CgluYW1lbGVuID0gKytkYXRlIC0gbGluZTsKCXRpbWUgPSBzdHJ0b3VsKGRhdGUsICZkYXRlLCAxMCk7Cgl0eiA9IHN0cnRvbChkYXRlLCBOVUxMLCAxMCk7CgoJaWYgKGZtdCA9PSBDTUlUX0ZNVF9FTUFJTCkgewoJCWNoYXIgKm5hbWVfdGFpbCA9IHN0cmNocihsaW5lLCAnPCcpOwoJCWludCBkaXNwbGF5X25hbWVfbGVuZ3RoOwoJCWlmICghbmFtZV90YWlsKQoJCQlyZXR1cm4gMDsKCQl3aGlsZSAobGluZSA8IG5hbWVfdGFpbCAmJiBpc3NwYWNlKG5hbWVfdGFpbFstMV0pKQoJCQluYW1lX3RhaWwtLTsKCQlkaXNwbGF5X25hbWVfbGVuZ3RoID0gbmFtZV90YWlsIC0gbGluZTsKCQlmaWxsZXIgPSAiIjsKCQlzdHJjcHkoYnVmLCAiRnJvbTogIik7CgkJcmV0ID0gc3RybGVuKGJ1Zik7CgkJcmV0ICs9IGFkZF9yZmMyMDQ3KGJ1ZiArIHJldCwgbGluZSwgZGlzcGxheV9uYW1lX2xlbmd0aCk7CgkJbWVtY3B5KGJ1ZiArIHJldCwgbmFtZV90YWlsLCBuYW1lbGVuIC0gZGlzcGxheV9uYW1lX2xlbmd0aCk7CgkJcmV0ICs9IG5hbWVsZW4gLSBkaXNwbGF5X25hbWVfbGVuZ3RoOwoJCWJ1ZltyZXQrK10gPSAnXG4nOwoJfQoJZWxzZSB7CgkJcmV0ID0gc3ByaW50ZihidWYsICIlczogJS4qcyUuKnNcbiIsIHdoYXQsCgkJCSAgICAgIChmbXQgPT0gQ01JVF9GTVRfRlVMTEVSKSA/IDQgOiAwLAoJCQkgICAgICBmaWxsZXIsIG5hbWVsZW4sIGxpbmUpOwoJfQoJc3dpdGNoIChmbXQpIHsKCWNhc2UgQ01JVF9GTVRfTUVESVVNOgoJCXJldCArPSBzcHJpbnRmKGJ1ZiArIHJldCwgIkRhdGU6ICAgJXNcbiIsIHNob3dfZGF0ZSh0aW1lLCB0eikpOwoJCWJyZWFrOwoJY2FzZSBDTUlUX0ZNVF9FTUFJTDoKCQlyZXQgKz0gc3ByaW50ZihidWYgKyByZXQsICJEYXRlOiAlc1xuIiwKCQkJICAgICAgIHNob3dfcmZjMjgyMl9kYXRlKHRpbWUsIHR6KSk7CgkJYnJlYWs7CgljYXNlIENNSVRfRk1UX0ZVTExFUjoKCQlyZXQgKz0gc3ByaW50ZihidWYgKyByZXQsICIlc0RhdGU6ICVzXG4iLCB3aGF0LCBzaG93X2RhdGUodGltZSwgdHopKTsKCQlicmVhazsKCWRlZmF1bHQ6CgkJLyogbm90aW4nICovCgkJYnJlYWs7Cgl9CglyZXR1cm4gcmV0Owp9CgpzdGF0aWMgaW50IGlzX2VtcHR5X2xpbmUoY29uc3QgY2hhciAqbGluZSwgaW50ICpsZW5fcCkKewoJaW50IGxlbiA9ICpsZW5fcDsKCXdoaWxlIChsZW4gJiYgaXNzcGFjZShsaW5lW2xlbi0xXSkpCgkJbGVuLS07CgkqbGVuX3AgPSBsZW47CglyZXR1cm4gIWxlbjsKfQoKc3RhdGljIGludCBhZGRfbWVyZ2VfaW5mbyhlbnVtIGNtaXRfZm10IGZtdCwgY2hhciAqYnVmLCBjb25zdCBzdHJ1Y3QgY29tbWl0ICpjb21taXQsIGludCBhYmJyZXYpCnsKCXN0cnVjdCBjb21taXRfbGlzdCAqcGFyZW50ID0gY29tbWl0LT5wYXJlbnRzOwoJaW50IG9mZnNldDsKCglpZiAoKGZtdCA9PSBDTUlUX0ZNVF9PTkVMSU5FKSB8fCAoZm10ID09IENNSVRfRk1UX0VNQUlMKSB8fAoJICAgICFwYXJlbnQgfHwgIXBhcmVudC0+bmV4dCkKCQlyZXR1cm4gMDsKCglvZmZzZXQgPSBzcHJpbnRmKGJ1ZiwgIk1lcmdlOiIpOwoKCXdoaWxlIChwYXJlbnQpIHsKCQlzdHJ1Y3QgY29tbWl0ICpwID0gcGFyZW50LT5pdGVtOwoJCWNvbnN0IGNoYXIgKmhleCA9IGFiYnJldgoJCQk/IGZpbmRfdW5pcXVlX2FiYnJldihwLT5vYmplY3Quc2hhMSwgYWJicmV2KQoJCQk6IHNoYTFfdG9faGV4KHAtPm9iamVjdC5zaGExKTsKCQljb25zdCBjaGFyICpkb3RzID0gKGFiYnJldiAmJiBzdHJsZW4oaGV4KSAhPSA0MCkgPyAiLi4uIiA6ICIiOwoJCXBhcmVudCA9IHBhcmVudC0+bmV4dDsKCgkJb2Zmc2V0ICs9IHNwcmludGYoYnVmICsgb2Zmc2V0LCAiICVzJXMiLCBoZXgsIGRvdHMpOwoJfQoJYnVmW29mZnNldCsrXSA9ICdcbic7CglyZXR1cm4gb2Zmc2V0Owp9Cgp1bnNpZ25lZCBsb25nIHByZXR0eV9wcmludF9jb21taXQoZW51bSBjbWl0X2ZtdCBmbXQsIGNvbnN0IHN0cnVjdCBjb21taXQgKmNvbW1pdCwgdW5zaWduZWQgbG9uZyBsZW4sIGNoYXIgKmJ1ZiwgdW5zaWduZWQgbG9uZyBzcGFjZSwgaW50IGFiYnJldiwgY29uc3QgY2hhciAqc3ViamVjdCwgY29uc3QgY2hhciAqYWZ0ZXJfc3ViamVjdCkKewoJaW50IGhkciA9IDEsIGJvZHkgPSAwOwoJdW5zaWduZWQgbG9uZyBvZmZzZXQgPSAwOwoJaW50IGluZGVudCA9IDQ7CglpbnQgcGFyZW50c19zaG93biA9IDA7Cgljb25zdCBjaGFyICptc2cgPSBjb21taXQtPmJ1ZmZlcjsKCWludCBwbGFpbl9ub25fYXNjaWkgPSAwOwoKCWlmIChmbXQgPT0gQ01JVF9GTVRfT05FTElORSB8fCBmbXQgPT0gQ01JVF9GTVRfRU1BSUwpCgkJaW5kZW50ID0gMDsKCgkvKiBBZnRlci1zdWJqZWN0IGlzIHVzZWQgdG8gcGFzcyBpbiBDb250ZW50LVR5cGU6IG11bHRpcGFydAoJICogTUlNRSBoZWFkZXI7IGluIHRoYXQgY2FzZSB3ZSBkbyBub3QgaGF2ZSB0byBkbyB0aGUKCSAqIHBsYWludGV4dCBjb250ZW50IHR5cGUgZXZlbiBpZiB0aGUgY29tbWl0IG1lc3NhZ2UgaGFzCgkgKiBub24gNy1iaXQgQVNDSUkgY2hhcmFjdGVyLiAgT3RoZXJ3aXNlLCBjaGVjayBpZiB3ZSBuZWVkCgkgKiB0byBzYXkgdGhpcyBpcyBub3QgYSA3LWJpdCBBU0NJSS4KCSAqLwoJaWYgKGZtdCA9PSBDTUlUX0ZNVF9FTUFJTCAmJiAhYWZ0ZXJfc3ViamVjdCkgewoJCWludCBpLCBjaCwgaW5fYm9keTsKCgkJZm9yIChpbl9ib2R5ID0gaSA9IDA7IChjaCA9IG1zZ1tpXSkgJiYgaSA8IGxlbjsgaSsrKSB7CgkJCWlmICghaW5fYm9keSkgewoJCQkJLyogYXV0aG9yIGNvdWxkIGJlIG5vbiA3LWJpdCBBU0NJSSBidXQKCQkJCSAqIHRoZSBsb2cgbWF5IHNvOyBza2lwIG92ZXIgdGhlCgkJCQkgKiBoZWFkZXIgcGFydCBmaXJzdC4KCQkJCSAqLwoJCQkJaWYgKGNoID09ICdcbicgJiYKCQkJCSAgICBpICsgMSA8IGxlbiAmJiBtc2dbaSsxXSA9PSAnXG4nKQoJCQkJCWluX2JvZHkgPSAxOwoJCQl9CgkJCWVsc2UgaWYgKGNoICYgMHg4MCkgewoJCQkJcGxhaW5fbm9uX2FzY2lpID0gMTsKCQkJCWJyZWFrOwoJCQl9CgkJfQoJfQoKCWZvciAoOzspIHsKCQljb25zdCBjaGFyICpsaW5lID0gbXNnOwoJCWludCBsaW5lbGVuID0gZ2V0X29uZV9saW5lKG1zZywgbGVuKTsKCgkJaWYgKCFsaW5lbGVuKQoJCQlicmVhazsKCgkJLyoKCQkgKiBXZSB3YW50IHNvbWUgc2xvcCBmb3IgaW5kZW50YXRpb24gYW5kIGEgcG9zc2libGUKCQkgKiBmaW5hbCAiLi4uIi4gVGh1cyB0aGUgIisgMjAiLgoJCSAqLwoJCWlmIChvZmZzZXQgKyBsaW5lbGVuICsgMjAgPiBzcGFjZSkgewoJCQltZW1jcHkoYnVmICsgb2Zmc2V0LCAiICAgIC4uLlxuIiwgOCk7CgkJCW9mZnNldCArPSA4OwoJCQlicmVhazsKCQl9CgoJCW1zZyArPSBsaW5lbGVuOwoJCWxlbiAtPSBsaW5lbGVuOwoJCWlmIChoZHIpIHsKCQkJaWYgKGxpbmVsZW4gPT0gMSkgewoJCQkJaGRyID0gMDsKCQkJCWlmICgoZm10ICE9IENNSVRfRk1UX09ORUxJTkUpICYmICFzdWJqZWN0KQoJCQkJCWJ1ZltvZmZzZXQrK10gPSAnXG4nOwoJCQkJY29udGludWU7CgkJCX0KCQkJaWYgKGZtdCA9PSBDTUlUX0ZNVF9SQVcpIHsKCQkJCW1lbWNweShidWYgKyBvZmZzZXQsIGxpbmUsIGxpbmVsZW4pOwoJCQkJb2Zmc2V0ICs9IGxpbmVsZW47CgkJCQljb250aW51ZTsKCQkJfQoJCQlpZiAoIW1lbWNtcChsaW5lLCAicGFyZW50ICIsIDcpKSB7CgkJCQlpZiAobGluZWxlbiAhPSA0OCkKCQkJCQlkaWUoImJhZCBwYXJlbnQgbGluZSBpbiBjb21taXQiKTsKCQkJCWNvbnRpbnVlOwoJCQl9CgoJCQlpZiAoIXBhcmVudHNfc2hvd24pIHsKCQkJCW9mZnNldCArPSBhZGRfbWVyZ2VfaW5mbyhmbXQsIGJ1ZiArIG9mZnNldCwKCQkJCQkJCSBjb21taXQsIGFiYnJldik7CgkJCQlwYXJlbnRzX3Nob3duID0gMTsKCQkJCWNvbnRpbnVlOwoJCQl9CgkJCS8qCgkJCSAqIE1FRElVTSA9PSBERUZBVUxUIHNob3dzIG9ubHkgYXV0aG9yIHdpdGggZGF0ZXMuCgkJCSAqIEZVTEwgc2hvd3MgYm90aCBhdXRob3JzIGJ1dCBub3QgZGF0ZXMuCgkJCSAqIEZVTExFUiBzaG93cyBib3RoIGF1dGhvcnMgYW5kIGRhdGVzLgoJCQkgKi8KCQkJaWYgKCFtZW1jbXAobGluZSwgImF1dGhvciAiLCA3KSkKCQkJCW9mZnNldCArPSBhZGRfdXNlcl9pbmZvKCJBdXRob3IiLCBmbXQsCgkJCQkJCQlidWYgKyBvZmZzZXQsCgkJCQkJCQlsaW5lICsgNyk7CgkJCWlmICghbWVtY21wKGxpbmUsICJjb21taXR0ZXIgIiwgMTApICYmCgkJCSAgICAoZm10ID09IENNSVRfRk1UX0ZVTEwgfHwgZm10ID09IENNSVRfRk1UX0ZVTExFUikpCgkJCQlvZmZzZXQgKz0gYWRkX3VzZXJfaW5mbygiQ29tbWl0IiwgZm10LAoJCQkJCQkJYnVmICsgb2Zmc2V0LAoJCQkJCQkJbGluZSArIDEwKTsKCQkJY29udGludWU7CgkJfQoKCQlpZiAoIXN1YmplY3QpCgkJCWJvZHkgPSAxOwoKCQlpZiAoaXNfZW1wdHlfbGluZShsaW5lLCAmbGluZWxlbikpIHsKCQkJaWYgKCFib2R5KQoJCQkJY29udGludWU7CgkJCWlmIChzdWJqZWN0KQoJCQkJY29udGludWU7CgkJCWlmIChmbXQgPT0gQ01JVF9GTVRfU0hPUlQpCgkJCQlicmVhazsKCQl9CgoJCWlmIChzdWJqZWN0KSB7CgkJCWludCBzbGVuID0gc3RybGVuKHN1YmplY3QpOwoJCQltZW1jcHkoYnVmICsgb2Zmc2V0LCBzdWJqZWN0LCBzbGVuKTsKCQkJb2Zmc2V0ICs9IHNsZW47CgkJCW9mZnNldCArPSBhZGRfcmZjMjA0NyhidWYgKyBvZmZzZXQsIGxpbmUsIGxpbmVsZW4pOwoJCX0KCQllbHNlIHsKCQkJbWVtc2V0KGJ1ZiArIG9mZnNldCwgJyAnLCBpbmRlbnQpOwoJCQltZW1jcHkoYnVmICsgb2Zmc2V0ICsgaW5kZW50LCBsaW5lLCBsaW5lbGVuKTsKCQkJb2Zmc2V0ICs9IGxpbmVsZW4gKyBpbmRlbnQ7CgkJfQoJCWJ1ZltvZmZzZXQrK10gPSAnXG4nOwoJCWlmIChmbXQgPT0gQ01JVF9GTVRfT05FTElORSkKCQkJYnJlYWs7CgkJaWYgKHN1YmplY3QgJiYgcGxhaW5fbm9uX2FzY2lpKSB7CgkJCXN0YXRpYyBjb25zdCBjaGFyIGhlYWRlcltdID0KCQkJCSJDb250ZW50LVR5cGU6IHRleHQvcGxhaW47IGNoYXJzZXQ9VVRGLThcbiIKCQkJCSJDb250ZW50LVRyYW5zZmVyLUVuY29kaW5nOiA4Yml0XG4iOwoJCQltZW1jcHkoYnVmICsgb2Zmc2V0LCBoZWFkZXIsIHNpemVvZihoZWFkZXIpLTEpOwoJCQlvZmZzZXQgKz0gc2l6ZW9mKGhlYWRlciktMTsKCQl9CgkJaWYgKGFmdGVyX3N1YmplY3QpIHsKCQkJaW50IHNsZW4gPSBzdHJsZW4oYWZ0ZXJfc3ViamVjdCk7CgkJCWlmIChzbGVuID4gc3BhY2UgLSBvZmZzZXQgLSAxKQoJCQkJc2xlbiA9IHNwYWNlIC0gb2Zmc2V0IC0gMTsKCQkJbWVtY3B5KGJ1ZiArIG9mZnNldCwgYWZ0ZXJfc3ViamVjdCwgc2xlbik7CgkJCW9mZnNldCArPSBzbGVuOwoJCQlhZnRlcl9zdWJqZWN0ID0gTlVMTDsKCQl9CgkJc3ViamVjdCA9IE5VTEw7Cgl9Cgl3aGlsZSAob2Zmc2V0ICYmIGlzc3BhY2UoYnVmW29mZnNldC0xXSkpCgkJb2Zmc2V0LS07CgkvKiBNYWtlIHN1cmUgdGhlcmUgaXMgYW4gRU9MTiBmb3IgdGhlIG5vbi1vbmVsaW5lIGNhc2UgKi8KCWlmIChmbXQgIT0gQ01JVF9GTVRfT05FTElORSkKCQlidWZbb2Zmc2V0KytdID0gJ1xuJzsKCS8qCgkgKiBtYWtlIHN1cmUgdGhlcmUgaXMgYW5vdGhlciBFT0xOIHRvIHNlcGFyYXRlIHRoZSBoZWFkZXJzIGZyb20gd2hhdGV2ZXIKCSAqIGJvZHkgdGhlIGNhbGxlciBhcHBlbmRzIGlmIHdlIGhhdmVuJ3QgYWxyZWFkeSB3cml0dGVuIGEgYm9keQoJICovCglpZiAoZm10ID09IENNSVRfRk1UX0VNQUlMICYmICFib2R5KQoJCWJ1ZltvZmZzZXQrK10gPSAnXG4nOwoJYnVmW29mZnNldF0gPSAnXDAnOwoJcmV0dXJuIG9mZnNldDsKfQoKc3RydWN0IGNvbW1pdCAqcG9wX2NvbW1pdChzdHJ1Y3QgY29tbWl0X2xpc3QgKipzdGFjaykKewoJc3RydWN0IGNvbW1pdF9saXN0ICp0b3AgPSAqc3RhY2s7CglzdHJ1Y3QgY29tbWl0ICppdGVtID0gdG9wID8gdG9wLT5pdGVtIDogTlVMTDsKCglpZiAodG9wKSB7CgkJKnN0YWNrID0gdG9wLT5uZXh0OwoJCWZyZWUodG9wKTsKCX0KCXJldHVybiBpdGVtOwp9CgppbnQgY291bnRfcGFyZW50cyhzdHJ1Y3QgY29tbWl0ICogY29tbWl0KQp7CiAgICAgICAgaW50IGNvdW50OwogICAgICAgIHN0cnVjdCBjb21taXRfbGlzdCAqIHBhcmVudHMgPSBjb21taXQtPnBhcmVudHM7CiAgICAgICAgZm9yIChjb3VudCA9IDA7IHBhcmVudHM7IHBhcmVudHMgPSBwYXJlbnRzLT5uZXh0LGNvdW50KyspCgkJOwogICAgICAgIHJldHVybiBjb3VudDsKfQoKdm9pZCB0b3BvX3NvcnRfZGVmYXVsdF9zZXR0ZXIoc3RydWN0IGNvbW1pdCAqYywgdm9pZCAqZGF0YSkKewoJYy0+dXRpbCA9IGRhdGE7Cn0KCnZvaWQgKnRvcG9fc29ydF9kZWZhdWx0X2dldHRlcihzdHJ1Y3QgY29tbWl0ICpjKQp7CglyZXR1cm4gYy0+dXRpbDsKfQoKLyoKICogUGVyZm9ybXMgYW4gaW4tcGxhY2UgdG9wb2xvZ2ljYWwgc29ydCBvbiB0aGUgbGlzdCBzdXBwbGllZC4KICovCnZvaWQgc29ydF9pbl90b3BvbG9naWNhbF9vcmRlcihzdHJ1Y3QgY29tbWl0X2xpc3QgKiogbGlzdCwgaW50IGxpZm8pCnsKCXNvcnRfaW5fdG9wb2xvZ2ljYWxfb3JkZXJfZm4obGlzdCwgbGlmbywgdG9wb19zb3J0X2RlZmF1bHRfc2V0dGVyLAoJCQkJICAgICB0b3BvX3NvcnRfZGVmYXVsdF9nZXR0ZXIpOwp9Cgp2b2lkIHNvcnRfaW5fdG9wb2xvZ2ljYWxfb3JkZXJfZm4oc3RydWN0IGNvbW1pdF9saXN0ICoqIGxpc3QsIGludCBsaWZvLAoJCQkJICB0b3BvX3NvcnRfc2V0X2ZuX3Qgc2V0dGVyLAoJCQkJICB0b3BvX3NvcnRfZ2V0X2ZuX3QgZ2V0dGVyKQp7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKiBuZXh0ID0gKmxpc3Q7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKiB3b3JrID0gTlVMTCwgKippbnNlcnQ7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKiogcHB0ciA9IGxpc3Q7CglzdHJ1Y3Qgc29ydF9ub2RlICogbm9kZXM7CglzdHJ1Y3Qgc29ydF9ub2RlICogbmV4dF9ub2RlczsKCWludCBjb3VudCA9IDA7CgoJLyogZGV0ZXJtaW5lIHRoZSBzaXplIG9mIHRoZSBsaXN0ICovCgl3aGlsZSAobmV4dCkgewoJCW5leHQgPSBuZXh0LT5uZXh0OwoJCWNvdW50Kys7Cgl9CgkKCWlmICghY291bnQpCgkJcmV0dXJuOwoJLyogYWxsb2NhdGUgYW4gYXJyYXkgdG8gaGVscCBzb3J0IHRoZSBsaXN0ICovCglub2RlcyA9IHhjYWxsb2MoY291bnQsIHNpemVvZigqbm9kZXMpKTsKCS8qIGxpbmsgdGhlIGxpc3QgdG8gdGhlIGFycmF5ICovCgluZXh0X25vZGVzID0gbm9kZXM7CgluZXh0PSpsaXN0OwoJd2hpbGUgKG5leHQpIHsKCQluZXh0X25vZGVzLT5saXN0X2l0ZW0gPSBuZXh0OwoJCXNldHRlcihuZXh0LT5pdGVtLCBuZXh0X25vZGVzKTsKCQluZXh0X25vZGVzKys7CgkJbmV4dCA9IG5leHQtPm5leHQ7Cgl9CgkvKiB1cGRhdGUgdGhlIGluZGVncmVlICovCgluZXh0PSpsaXN0OwoJd2hpbGUgKG5leHQpIHsKCQlzdHJ1Y3QgY29tbWl0X2xpc3QgKiBwYXJlbnRzID0gbmV4dC0+aXRlbS0+cGFyZW50czsKCQl3aGlsZSAocGFyZW50cykgewoJCQlzdHJ1Y3QgY29tbWl0ICogcGFyZW50PXBhcmVudHMtPml0ZW07CgkJCXN0cnVjdCBzb3J0X25vZGUgKiBwbiA9IChzdHJ1Y3Qgc29ydF9ub2RlICopIGdldHRlcihwYXJlbnQpOwoKCQkJaWYgKHBuKQoJCQkJcG4tPmluZGVncmVlKys7CgkJCXBhcmVudHM9cGFyZW50cy0+bmV4dDsKCQl9CgkJbmV4dD1uZXh0LT5uZXh0OwoJfQoJLyogCiAgICAgICAgICogZmluZCB0aGUgdGlwcwogICAgICAgICAqCiAgICAgICAgICogdGlwcyBhcmUgbm9kZXMgbm90IHJlYWNoYWJsZSBmcm9tIGFueSBvdGhlciBub2RlIGluIHRoZSBsaXN0IAogICAgICAgICAqIAogICAgICAgICAqIHRoZSB0aXBzIHNlcnZlIGFzIGEgc3RhcnRpbmcgc2V0IGZvciB0aGUgd29yayBxdWV1ZS4KICAgICAgICAgKi8KCW5leHQ9Kmxpc3Q7CglpbnNlcnQgPSAmd29yazsKCXdoaWxlIChuZXh0KSB7CgkJc3RydWN0IHNvcnRfbm9kZSAqIG5vZGUgPSAoc3RydWN0IHNvcnRfbm9kZSAqKSBnZXR0ZXIobmV4dC0+aXRlbSk7CgoJCWlmIChub2RlLT5pbmRlZ3JlZSA9PSAwKSB7CgkJCWluc2VydCA9ICZjb21taXRfbGlzdF9pbnNlcnQobmV4dC0+aXRlbSwgaW5zZXJ0KS0+bmV4dDsKCQl9CgkJbmV4dD1uZXh0LT5uZXh0OwoJfQoKCS8qIHByb2Nlc3MgdGhlIGxpc3QgaW4gdG9wb2xvZ2ljYWwgb3JkZXIgKi8KCWlmICghbGlmbykKCQlzb3J0X2J5X2RhdGUoJndvcmspOwoJd2hpbGUgKHdvcmspIHsKCQlzdHJ1Y3QgY29tbWl0ICogd29ya19pdGVtID0gcG9wX2NvbW1pdCgmd29yayk7CgkJc3RydWN0IHNvcnRfbm9kZSAqIHdvcmtfbm9kZSA9IChzdHJ1Y3Qgc29ydF9ub2RlICopIGdldHRlcih3b3JrX2l0ZW0pOwoJCXN0cnVjdCBjb21taXRfbGlzdCAqIHBhcmVudHMgPSB3b3JrX2l0ZW0tPnBhcmVudHM7CgoJCXdoaWxlIChwYXJlbnRzKSB7CgkJCXN0cnVjdCBjb21taXQgKiBwYXJlbnQ9cGFyZW50cy0+aXRlbTsKCQkJc3RydWN0IHNvcnRfbm9kZSAqIHBuID0gKHN0cnVjdCBzb3J0X25vZGUgKikgZ2V0dGVyKHBhcmVudCk7CgoJCQlpZiAocG4pIHsKCQkJCS8qCgkJCQkgKiBwYXJlbnRzIGFyZSBvbmx5IGVucXVldWVkIGZvciBlbWlzc2lvbiAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiB3aGVuIGFsbCB0aGVpciBjaGlsZHJlbiBoYXZlIGJlZW4gZW1pdHRlZCB0aGVyZWJ5CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogZ3VhcmFudGVlaW5nIHRvcG9sb2dpY2FsIG9yZGVyLgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqLwoJCQkJcG4tPmluZGVncmVlLS07CgkJCQlpZiAoIXBuLT5pbmRlZ3JlZSkgewoJCQkJCWlmICghbGlmbykKCQkJCQkJaW5zZXJ0X2J5X2RhdGUocGFyZW50LCAmd29yayk7CgkJCQkJZWxzZQoJCQkJCQljb21taXRfbGlzdF9pbnNlcnQocGFyZW50LCAmd29yayk7CgkJCQl9CgkJCX0KCQkJcGFyZW50cz1wYXJlbnRzLT5uZXh0OwoJCX0KCQkvKgogICAgICAgICAgICAgICAgICogd29ya19pdGVtIGlzIGEgY29tbWl0IGFsbCBvZiB3aG9zZSBjaGlsZHJlbgogICAgICAgICAgICAgICAgICogaGF2ZSBhbHJlYWR5IGJlZW4gZW1pdHRlZC4gd2UgY2FuIGVtaXQgaXQgbm93LgogICAgICAgICAgICAgICAgICovCgkJKnBwdHIgPSB3b3JrX25vZGUtPmxpc3RfaXRlbTsKCQlwcHRyID0gJigqcHB0ciktPm5leHQ7CgkJKnBwdHIgPSBOVUxMOwoJCXNldHRlcih3b3JrX2l0ZW0sIE5VTEwpOwoJfQoJZnJlZShub2Rlcyk7Cn0KCi8qIG1lcmdlLXJlYmFzZSBzdHVmZiAqLwoKLyogYml0cyAjMC4uNyBpbiByZXZpc2lvbi5oICovCiNkZWZpbmUgUEFSRU5UMQkJKDF1PDwgOCkKI2RlZmluZSBQQVJFTlQyCQkoMXU8PCA5KQojZGVmaW5lIFNUQUxFCQkoMXU8PDEwKQojZGVmaW5lIFJFU1VMVAkJKDF1PDwxMSkKCnN0YXRpYyBzdHJ1Y3QgY29tbWl0ICppbnRlcmVzdGluZyhzdHJ1Y3QgY29tbWl0X2xpc3QgKmxpc3QpCnsKCXdoaWxlIChsaXN0KSB7CgkJc3RydWN0IGNvbW1pdCAqY29tbWl0ID0gbGlzdC0+aXRlbTsKCQlsaXN0ID0gbGlzdC0+bmV4dDsKCQlpZiAoY29tbWl0LT5vYmplY3QuZmxhZ3MgJiBTVEFMRSkKCQkJY29udGludWU7CgkJcmV0dXJuIGNvbW1pdDsKCX0KCXJldHVybiBOVUxMOwp9CgpzdGF0aWMgc3RydWN0IGNvbW1pdF9saXN0ICptZXJnZV9iYXNlcyhzdHJ1Y3QgY29tbWl0ICpvbmUsIHN0cnVjdCBjb21taXQgKnR3bykKewoJc3RydWN0IGNvbW1pdF9saXN0ICpsaXN0ID0gTlVMTDsKCXN0cnVjdCBjb21taXRfbGlzdCAqcmVzdWx0ID0gTlVMTDsKCglpZiAob25lID09IHR3bykKCQkvKiBXZSBkbyBub3QgbWFyayB0aGlzIGV2ZW4gd2l0aCBSRVNVTFQgc28gd2UgZG8gbm90CgkJICogaGF2ZSB0byBjbGVhbiBpdCB1cC4KCQkgKi8KCQlyZXR1cm4gY29tbWl0X2xpc3RfaW5zZXJ0KG9uZSwgJnJlc3VsdCk7CgoJcGFyc2VfY29tbWl0KG9uZSk7CglwYXJzZV9jb21taXQodHdvKTsKCglvbmUtPm9iamVjdC5mbGFncyB8PSBQQVJFTlQxOwoJdHdvLT5vYmplY3QuZmxhZ3MgfD0gUEFSRU5UMjsKCWluc2VydF9ieV9kYXRlKG9uZSwgJmxpc3QpOwoJaW5zZXJ0X2J5X2RhdGUodHdvLCAmbGlzdCk7CgoJd2hpbGUgKGludGVyZXN0aW5nKGxpc3QpKSB7CgkJc3RydWN0IGNvbW1pdCAqY29tbWl0OwoJCXN0cnVjdCBjb21taXRfbGlzdCAqcGFyZW50czsKCQlzdHJ1Y3QgY29tbWl0X2xpc3QgKm47CgkJaW50IGZsYWdzOwoKCQljb21taXQgPSBsaXN0LT5pdGVtOwoJCW4gPSBsaXN0LT5uZXh0OwoJCWZyZWUobGlzdCk7CgkJbGlzdCA9IG47CgoJCWZsYWdzID0gY29tbWl0LT5vYmplY3QuZmxhZ3MgJiAoUEFSRU5UMSB8IFBBUkVOVDIgfCBTVEFMRSk7CgkJaWYgKGZsYWdzID09IChQQVJFTlQxIHwgUEFSRU5UMikpIHsKCQkJaWYgKCEoY29tbWl0LT5vYmplY3QuZmxhZ3MgJiBSRVNVTFQpKSB7CgkJCQljb21taXQtPm9iamVjdC5mbGFncyB8PSBSRVNVTFQ7CgkJCQlpbnNlcnRfYnlfZGF0ZShjb21taXQsICZyZXN1bHQpOwoJCQl9CgkJCS8qIE1hcmsgcGFyZW50cyBvZiBhIGZvdW5kIG1lcmdlIHN0YWxlICovCgkJCWZsYWdzIHw9IFNUQUxFOwoJCX0KCQlwYXJlbnRzID0gY29tbWl0LT5wYXJlbnRzOwoJCXdoaWxlIChwYXJlbnRzKSB7CgkJCXN0cnVjdCBjb21taXQgKnAgPSBwYXJlbnRzLT5pdGVtOwoJCQlwYXJlbnRzID0gcGFyZW50cy0+bmV4dDsKCQkJaWYgKChwLT5vYmplY3QuZmxhZ3MgJiBmbGFncykgPT0gZmxhZ3MpCgkJCQljb250aW51ZTsKCQkJcGFyc2VfY29tbWl0KHApOwoJCQlwLT5vYmplY3QuZmxhZ3MgfD0gZmxhZ3M7CgkJCWluc2VydF9ieV9kYXRlKHAsICZsaXN0KTsKCQl9Cgl9CgoJLyogQ2xlYW4gdXAgdGhlIHJlc3VsdCB0byByZW1vdmUgc3RhbGUgb25lcyAqLwoJbGlzdCA9IHJlc3VsdDsgcmVzdWx0ID0gTlVMTDsKCXdoaWxlIChsaXN0KSB7CgkJc3RydWN0IGNvbW1pdF9saXN0ICpuID0gbGlzdC0+bmV4dDsKCQlpZiAoIShsaXN0LT5pdGVtLT5vYmplY3QuZmxhZ3MgJiBTVEFMRSkpCgkJCWluc2VydF9ieV9kYXRlKGxpc3QtPml0ZW0sICZyZXN1bHQpOwoJCWZyZWUobGlzdCk7CgkJbGlzdCA9IG47Cgl9CglyZXR1cm4gcmVzdWx0Owp9CgpzdHJ1Y3QgY29tbWl0X2xpc3QgKmdldF9tZXJnZV9iYXNlcyhzdHJ1Y3QgY29tbWl0ICpvbmUsCgkJCQkgICAgc3RydWN0IGNvbW1pdCAqdHdvLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnQgY2xlYW51cCkKewoJY29uc3QgdW5zaWduZWQgYWxsX2ZsYWdzID0gKFBBUkVOVDEgfCBQQVJFTlQyIHwgU1RBTEUgfCBSRVNVTFQpOwoJc3RydWN0IGNvbW1pdF9saXN0ICpsaXN0OwoJc3RydWN0IGNvbW1pdCAqKnJzbHQ7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKnJlc3VsdDsKCWludCBjbnQsIGksIGo7CgoJcmVzdWx0ID0gbWVyZ2VfYmFzZXMob25lLCB0d28pOwoJaWYgKG9uZSA9PSB0d28pCgkJcmV0dXJuIHJlc3VsdDsKCWlmICghcmVzdWx0IHx8ICFyZXN1bHQtPm5leHQpIHsKCQlpZiAoY2xlYW51cCkgewoJCQljbGVhcl9jb21taXRfbWFya3Mob25lLCBhbGxfZmxhZ3MpOwoJCQljbGVhcl9jb21taXRfbWFya3ModHdvLCBhbGxfZmxhZ3MpOwoJCX0KCQlyZXR1cm4gcmVzdWx0OwoJfQoKCS8qIFRoZXJlIGFyZSBtb3JlIHRoYW4gb25lICovCgljbnQgPSAwOwoJbGlzdCA9IHJlc3VsdDsKCXdoaWxlIChsaXN0KSB7CgkJbGlzdCA9IGxpc3QtPm5leHQ7CgkJY250Kys7Cgl9Cglyc2x0ID0geGNhbGxvYyhjbnQsIHNpemVvZigqcnNsdCkpOwoJZm9yIChsaXN0ID0gcmVzdWx0LCBpID0gMDsgbGlzdDsgbGlzdCA9IGxpc3QtPm5leHQpCgkJcnNsdFtpKytdID0gbGlzdC0+aXRlbTsKCWZyZWVfY29tbWl0X2xpc3QocmVzdWx0KTsKCgljbGVhcl9jb21taXRfbWFya3Mob25lLCBhbGxfZmxhZ3MpOwoJY2xlYXJfY29tbWl0X21hcmtzKHR3bywgYWxsX2ZsYWdzKTsKCWZvciAoaSA9IDA7IGkgPCBjbnQgLSAxOyBpKyspIHsKCQlmb3IgKGogPSBpKzE7IGogPCBjbnQ7IGorKykgewoJCQlpZiAoIXJzbHRbaV0gfHwgIXJzbHRbal0pCgkJCQljb250aW51ZTsKCQkJcmVzdWx0ID0gbWVyZ2VfYmFzZXMocnNsdFtpXSwgcnNsdFtqXSk7CgkJCWNsZWFyX2NvbW1pdF9tYXJrcyhyc2x0W2ldLCBhbGxfZmxhZ3MpOwoJCQljbGVhcl9jb21taXRfbWFya3MocnNsdFtqXSwgYWxsX2ZsYWdzKTsKCQkJZm9yIChsaXN0ID0gcmVzdWx0OyBsaXN0OyBsaXN0ID0gbGlzdC0+bmV4dCkgewoJCQkJaWYgKHJzbHRbaV0gPT0gbGlzdC0+aXRlbSkKCQkJCQlyc2x0W2ldID0gTlVMTDsKCQkJCWlmIChyc2x0W2pdID09IGxpc3QtPml0ZW0pCgkJCQkJcnNsdFtqXSA9IE5VTEw7CgkJCX0KCQl9Cgl9CgoJLyogU3Vydml2aW5nIG9uZXMgaW4gcnNsdFtdIGFyZSB0aGUgaW5kZXBlbmRlbnQgcmVzdWx0cyAqLwoJcmVzdWx0ID0gTlVMTDsKCWZvciAoaSA9IDA7IGkgPCBjbnQ7IGkrKykgewoJCWlmIChyc2x0W2ldKQoJCQlpbnNlcnRfYnlfZGF0ZShyc2x0W2ldLCAmcmVzdWx0KTsKCX0KCWZyZWUocnNsdCk7CglyZXR1cm4gcmVzdWx0Owp9Cg==",
    "text": "#include \"cache.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n\nint save_commit_buffer = 1;\n\nstruct sort_node\n{\n\t/*\n\t * the number of children of the associated commit\n\t * that also occur in the list being sorted.\n\t */\n\tunsigned int indegree;\n\n\t/*\n\t * reference to original list item that we will re-use\n\t * on output.\n\t */\n\tstruct commit_list * list_item;\n\n};\n\nconst char *commit_type = \"commit\";\n\nstruct cmt_fmt_map {\n\tconst char *n;\n\tsize_t cmp_len;\n\tenum cmit_fmt v;\n} cmt_fmts[] = {\n\t{ \"raw\",\t1,\tCMIT_FMT_RAW },\n\t{ \"medium\",\t1,\tCMIT_FMT_MEDIUM },\n\t{ \"short\",\t1,\tCMIT_FMT_SHORT },\n\t{ \"email\",\t1,\tCMIT_FMT_EMAIL },\n\t{ \"full\",\t5,\tCMIT_FMT_FULL },\n\t{ \"fuller\",\t5,\tCMIT_FMT_FULLER },\n\t{ \"oneline\",\t1,\tCMIT_FMT_ONELINE },\n};\n\nenum cmit_fmt get_commit_format(const char *arg)\n{\n\tint i;\n\n\tif (!arg || !*arg)\n\t\treturn CMIT_FMT_DEFAULT;\n\tif (*arg == '=')\n\t\targ++;\n\tfor (i = 0; i < ARRAY_SIZE(cmt_fmts); i++) {\n\t\tif (!strncmp(arg, cmt_fmts[i].n, cmt_fmts[i].cmp_len))\n\t\t\treturn cmt_fmts[i].v;\n\t}\n\n\tdie(\"invalid --pretty format: %s\", arg);\n}\n\nstatic struct commit *check_commit(struct object *obj,\n\t\t\t\t   const unsigned char *sha1,\n\t\t\t\t   int quiet)\n{\n\tif (obj->type != OBJ_COMMIT) {\n\t\tif (!quiet)\n\t\t\terror(\"Object %s is a %s, not a commit\",\n\t\t\t      sha1_to_hex(sha1), typename(obj->type));\n\t\treturn NULL;\n\t}\n\treturn (struct commit *) obj;\n}\n\nstruct commit *lookup_commit_reference_gently(const unsigned char *sha1,\n\t\t\t\t\t      int quiet)\n{\n\tstruct object *obj = deref_tag(parse_object(sha1), NULL, 0);\n\n\tif (!obj)\n\t\treturn NULL;\n\treturn check_commit(obj, sha1, quiet);\n}\n\nstruct commit *lookup_commit_reference(const unsigned char *sha1)\n{\n\treturn lookup_commit_reference_gently(sha1, 0);\n}\n\nstruct commit *lookup_commit(const unsigned char *sha1)\n{\n\tstruct object *obj = lookup_object(sha1);\n\tif (!obj) {\n\t\tstruct commit *ret = alloc_commit_node();\n\t\tcreated_object(sha1, &ret->object);\n\t\tret->object.type = OBJ_COMMIT;\n\t\treturn ret;\n\t}\n\tif (!obj->type)\n\t\tobj->type = OBJ_COMMIT;\n\treturn check_commit(obj, sha1, 0);\n}\n\nstatic unsigned long parse_commit_date(const char *buf)\n{\n\tunsigned long date;\n\n\tif (memcmp(buf, \"author\", 6))\n\t\treturn 0;\n\twhile (*buf++ != '\\n')\n\t\t/* nada */;\n\tif (memcmp(buf, \"committer\", 9))\n\t\treturn 0;\n\twhile (*buf++ != '>')\n\t\t/* nada */;\n\tdate = strtoul(buf, NULL, 10);\n\tif (date == ULONG_MAX)\n\t\tdate = 0;\n\treturn date;\n}\n\nstatic struct commit_graft **commit_graft;\nstatic int commit_graft_alloc, commit_graft_nr;\n\nstatic int commit_graft_pos(const unsigned char *sha1)\n{\n\tint lo, hi;\n\tlo = 0;\n\thi = commit_graft_nr;\n\twhile (lo < hi) {\n\t\tint mi = (lo + hi) / 2;\n\t\tstruct commit_graft *graft = commit_graft[mi];\n\t\tint cmp = hashcmp(sha1, graft->sha1);\n\t\tif (!cmp)\n\t\t\treturn mi;\n\t\tif (cmp < 0)\n\t\t\thi = mi;\n\t\telse\n\t\t\tlo = mi + 1;\n\t}\n\treturn -lo - 1;\n}\n\nint register_commit_graft(struct commit_graft *graft, int ignore_dups)\n{\n\tint pos = commit_graft_pos(graft->sha1);\n\t\n\tif (0 <= pos) {\n\t\tif (ignore_dups)\n\t\t\tfree(graft);\n\t\telse {\n\t\t\tfree(commit_graft[pos]);\n\t\t\tcommit_graft[pos] = graft;\n\t\t}\n\t\treturn 1;\n\t}\n\tpos = -pos - 1;\n\tif (commit_graft_alloc <= ++commit_graft_nr) {\n\t\tcommit_graft_alloc = alloc_nr(commit_graft_alloc);\n\t\tcommit_graft = xrealloc(commit_graft,\n\t\t\t\t\tsizeof(*commit_graft) *\n\t\t\t\t\tcommit_graft_alloc);\n\t}\n\tif (pos < commit_graft_nr)\n\t\tmemmove(commit_graft + pos + 1,\n\t\t\tcommit_graft + pos,\n\t\t\t(commit_graft_nr - pos - 1) *\n\t\t\tsizeof(*commit_graft));\n\tcommit_graft[pos] = graft;\n\treturn 0;\n}\n\nstruct commit_graft *read_graft_line(char *buf, int len)\n{\n\t/* The format is just \"Commit Parent1 Parent2 ...\\n\" */\n\tint i;\n\tstruct commit_graft *graft = NULL;\n\n\tif (buf[len-1] == '\\n')\n\t\tbuf[--len] = 0;\n\tif (buf[0] == '#' || buf[0] == '\\0')\n\t\treturn NULL;\n\tif ((len + 1) % 41) {\n\tbad_graft_data:\n\t\terror(\"bad graft data: %s\", buf);\n\t\tfree(graft);\n\t\treturn NULL;\n\t}\n\ti = (len + 1) / 41 - 1;\n\tgraft = xmalloc(sizeof(*graft) + 20 * i);\n\tgraft->nr_parent = i;\n\tif (get_sha1_hex(buf, graft->sha1))\n\t\tgoto bad_graft_data;\n\tfor (i = 40; i < len; i += 41) {\n\t\tif (buf[i] != ' ')\n\t\t\tgoto bad_graft_data;\n\t\tif (get_sha1_hex(buf + i + 1, graft->parent[i/41]))\n\t\t\tgoto bad_graft_data;\n\t}\n\treturn graft;\n}\n\nint read_graft_file(const char *graft_file)\n{\n\tFILE *fp = fopen(graft_file, \"r\");\n\tchar buf[1024];\n\tif (!fp)\n\t\treturn -1;\n\twhile (fgets(buf, sizeof(buf), fp)) {\n\t\t/* The format is just \"Commit Parent1 Parent2 ...\\n\" */\n\t\tint len = strlen(buf);\n\t\tstruct commit_graft *graft = read_graft_line(buf, len);\n\t\tif (!graft)\n\t\t\tcontinue;\n\t\tif (register_commit_graft(graft, 1))\n\t\t\terror(\"duplicate graft data: %s\", buf);\n\t}\n\tfclose(fp);\n\treturn 0;\n}\n\nstatic void prepare_commit_graft(void)\n{\n\tstatic int commit_graft_prepared;\n\tchar *graft_file;\n\n\tif (commit_graft_prepared)\n\t\treturn;\n\tgraft_file = get_graft_file();\n\tread_graft_file(graft_file);\n\tcommit_graft_prepared = 1;\n}\n\nstatic struct commit_graft *lookup_commit_graft(const unsigned char *sha1)\n{\n\tint pos;\n\tprepare_commit_graft();\n\tpos = commit_graft_pos(sha1);\n\tif (pos < 0)\n\t\treturn NULL;\n\treturn commit_graft[pos];\n}\n\nint parse_commit_buffer(struct commit *item, void *buffer, unsigned long size)\n{\n\tchar *tail = buffer;\n\tchar *bufptr = buffer;\n\tunsigned char parent[20];\n\tstruct commit_list **pptr;\n\tstruct commit_graft *graft;\n\tunsigned n_refs = 0;\n\n\tif (item->object.parsed)\n\t\treturn 0;\n\titem->object.parsed = 1;\n\ttail += size;\n\tif (tail <= bufptr + 5 || memcmp(bufptr, \"tree \", 5))\n\t\treturn error(\"bogus commit object %s\", sha1_to_hex(item->object.sha1));\n\tif (tail <= bufptr + 45 || get_sha1_hex(bufptr + 5, parent) < 0)\n\t\treturn error(\"bad tree pointer in commit %s\",\n\t\t\t     sha1_to_hex(item->object.sha1));\n\titem->tree = lookup_tree(parent);\n\tif (item->tree)\n\t\tn_refs++;\n\tbufptr += 46; /* \"tree \" + \"hex sha1\" + \"\\n\" */\n\tpptr = &item->parents;\n\n\tgraft = lookup_commit_graft(item->object.sha1);\n\twhile (bufptr + 48 < tail && !memcmp(bufptr, \"parent \", 7)) {\n\t\tstruct commit *new_parent;\n\n\t\tif (tail <= bufptr + 48 ||\n\t\t    get_sha1_hex(bufptr + 7, parent) ||\n\t\t    bufptr[47] != '\\n')\n\t\t\treturn error(\"bad parents in commit %s\", sha1_to_hex(item->object.sha1));\n\t\tbufptr += 48;\n\t\tif (graft)\n\t\t\tcontinue;\n\t\tnew_parent = lookup_commit(parent);\n\t\tif (new_parent) {\n\t\t\tpptr = &commit_list_insert(new_parent, pptr)->next;\n\t\t\tn_refs++;\n\t\t}\n\t}\n\tif (graft) {\n\t\tint i;\n\t\tstruct commit *new_parent;\n\t\tfor (i = 0; i < graft->nr_parent; i++) {\n\t\t\tnew_parent = lookup_commit(graft->parent[i]);\n\t\t\tif (!new_parent)\n\t\t\t\tcontinue;\n\t\t\tpptr = &commit_list_insert(new_parent, pptr)->next;\n\t\t\tn_refs++;\n\t\t}\n\t}\n\titem->date = parse_commit_date(bufptr);\n\n\tif (track_object_refs) {\n\t\tunsigned i = 0;\n\t\tstruct commit_list *p;\n\t\tstruct object_refs *refs = alloc_object_refs(n_refs);\n\t\tif (item->tree)\n\t\t\trefs->ref[i++] = &item->tree->object;\n\t\tfor (p = item->parents; p; p = p->next)\n\t\t\trefs->ref[i++] = &p->item->object;\n\t\tset_object_refs(&item->object, refs);\n\t}\n\n\treturn 0;\n}\n\nint parse_commit(struct commit *item)\n{\n\tchar type[20];\n\tvoid *buffer;\n\tunsigned long size;\n\tint ret;\n\n\tif (item->object.parsed)\n\t\treturn 0;\n\tbuffer = read_sha1_file(item->object.sha1, type, &size);\n\tif (!buffer)\n\t\treturn error(\"Could not read %s\",\n\t\t\t     sha1_to_hex(item->object.sha1));\n\tif (strcmp(type, commit_type)) {\n\t\tfree(buffer);\n\t\treturn error(\"Object %s not a commit\",\n\t\t\t     sha1_to_hex(item->object.sha1));\n\t}\n\tret = parse_commit_buffer(item, buffer, size);\n\tif (save_commit_buffer && !ret) {\n\t\titem->buffer = buffer;\n\t\treturn 0;\n\t}\n\tfree(buffer);\n\treturn ret;\n}\n\nstruct commit_list *commit_list_insert(struct commit *item, struct commit_list **list_p)\n{\n\tstruct commit_list *new_list = xmalloc(sizeof(struct commit_list));\n\tnew_list->item = item;\n\tnew_list->next = *list_p;\n\t*list_p = new_list;\n\treturn new_list;\n}\n\nvoid free_commit_list(struct commit_list *list)\n{\n\twhile (list) {\n\t\tstruct commit_list *temp = list;\n\t\tlist = temp->next;\n\t\tfree(temp);\n\t}\n}\n\nstruct commit_list * insert_by_date(struct commit *item, struct commit_list **list)\n{\n\tstruct commit_list **pp = list;\n\tstruct commit_list *p;\n\twhile ((p = *pp) != NULL) {\n\t\tif (p->item->date < item->date) {\n\t\t\tbreak;\n\t\t}\n\t\tpp = &p->next;\n\t}\n\treturn commit_list_insert(item, pp);\n}\n\n\t\nvoid sort_by_date(struct commit_list **list)\n{\n\tstruct commit_list *ret = NULL;\n\twhile (*list) {\n\t\tinsert_by_date((*list)->item, &ret);\n\t\t*list = (*list)->next;\n\t}\n\t*list = ret;\n}\n\nstruct commit *pop_most_recent_commit(struct commit_list **list,\n\t\t\t\t      unsigned int mark)\n{\n\tstruct commit *ret = (*list)->item;\n\tstruct commit_list *parents = ret->parents;\n\tstruct commit_list *old = *list;\n\n\t*list = (*list)->next;\n\tfree(old);\n\n\twhile (parents) {\n\t\tstruct commit *commit = parents->item;\n\t\tparse_commit(commit);\n\t\tif (!(commit->object.flags & mark)) {\n\t\t\tcommit->object.flags |= mark;\n\t\t\tinsert_by_date(commit, list);\n\t\t}\n\t\tparents = parents->next;\n\t}\n\treturn ret;\n}\n\nvoid clear_commit_marks(struct commit *commit, unsigned int mark)\n{\n\tstruct commit_list *parents;\n\n\tcommit->object.flags &= ~mark;\n\tparents = commit->parents;\n\twhile (parents) {\n\t\tstruct commit *parent = parents->item;\n\n\t\t/* Have we already cleared this? */\n\t\tif (mark & parent->object.flags)\n\t\t\tclear_commit_marks(parent, mark);\n\t\tparents = parents->next;\n\t}\n}\n\n/*\n * Generic support for pretty-printing the header\n */\nstatic int get_one_line(const char *msg, unsigned long len)\n{\n\tint ret = 0;\n\n\twhile (len--) {\n\t\tchar c = *msg++;\n\t\tif (!c)\n\t\t\tbreak;\n\t\tret++;\n\t\tif (c == '\\n')\n\t\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int is_rfc2047_special(char ch)\n{\n\treturn ((ch & 0x80) || (ch == '=') || (ch == '?') || (ch == '_'));\n}\n\nstatic int add_rfc2047(char *buf, const char *line, int len)\n{\n\tchar *bp = buf;\n\tint i, needquote;\n\tstatic const char q_utf8[] = \"=?utf-8?q?\";\n\n\tfor (i = needquote = 0; !needquote && i < len; i++) {\n\t\tunsigned ch = line[i];\n\t\tif (ch & 0x80)\n\t\t\tneedquote++;\n\t\tif ((i + 1 < len) &&\n\t\t    (ch == '=' && line[i+1] == '?'))\n\t\t\tneedquote++;\n\t}\n\tif (!needquote)\n\t\treturn sprintf(buf, \"%.*s\", len, line);\n\n\tmemcpy(bp, q_utf8, sizeof(q_utf8)-1);\n\tbp += sizeof(q_utf8)-1;\n\tfor (i = 0; i < len; i++) {\n\t\tunsigned ch = line[i] & 0xFF;\n\t\tif (is_rfc2047_special(ch)) {\n\t\t\tsprintf(bp, \"=%02X\", ch);\n\t\t\tbp += 3;\n\t\t}\n\t\telse if (ch == ' ')\n\t\t\t*bp++ = '_';\n\t\telse\n\t\t\t*bp++ = ch;\n\t}\n\tmemcpy(bp, \"?=\", 2);\n\tbp += 2;\n\treturn bp - buf;\n}\n\nstatic int add_user_info(const char *what, enum cmit_fmt fmt, char *buf, const char *line)\n{\n\tchar *date;\n\tint namelen;\n\tunsigned long time;\n\tint tz, ret;\n\tconst char *filler = \"    \";\n\n\tif (fmt == CMIT_FMT_ONELINE)\n\t\treturn 0;\n\tdate = strchr(line, '>');\n\tif (!date)\n\t\treturn 0;\n\tnamelen = ++date - line;\n\ttime = strtoul(date, &date, 10);\n\ttz = strtol(date, NULL, 10);\n\n\tif (fmt == CMIT_FMT_EMAIL) {\n\t\tchar *name_tail = strchr(line, '<');\n\t\tint display_name_length;\n\t\tif (!name_tail)\n\t\t\treturn 0;\n\t\twhile (line < name_tail && isspace(name_tail[-1]))\n\t\t\tname_tail--;\n\t\tdisplay_name_length = name_tail - line;\n\t\tfiller = \"\";\n\t\tstrcpy(buf, \"From: \");\n\t\tret = strlen(buf);\n\t\tret += add_rfc2047(buf + ret, line, display_name_length);\n\t\tmemcpy(buf + ret, name_tail, namelen - display_name_length);\n\t\tret += namelen - display_name_length;\n\t\tbuf[ret++] = '\\n';\n\t}\n\telse {\n\t\tret = sprintf(buf, \"%s: %.*s%.*s\\n\", what,\n\t\t\t      (fmt == CMIT_FMT_FULLER) ? 4 : 0,\n\t\t\t      filler, namelen, line);\n\t}\n\tswitch (fmt) {\n\tcase CMIT_FMT_MEDIUM:\n\t\tret += sprintf(buf + ret, \"Date:   %s\\n\", show_date(time, tz));\n\t\tbreak;\n\tcase CMIT_FMT_EMAIL:\n\t\tret += sprintf(buf + ret, \"Date: %s\\n\",\n\t\t\t       show_rfc2822_date(time, tz));\n\t\tbreak;\n\tcase CMIT_FMT_FULLER:\n\t\tret += sprintf(buf + ret, \"%sDate: %s\\n\", what, show_date(time, tz));\n\t\tbreak;\n\tdefault:\n\t\t/* notin' */\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int is_empty_line(const char *line, int *len_p)\n{\n\tint len = *len_p;\n\twhile (len && isspace(line[len-1]))\n\t\tlen--;\n\t*len_p = len;\n\treturn !len;\n}\n\nstatic int add_merge_info(enum cmit_fmt fmt, char *buf, const struct commit *commit, int abbrev)\n{\n\tstruct commit_list *parent = commit->parents;\n\tint offset;\n\n\tif ((fmt == CMIT_FMT_ONELINE) || (fmt == CMIT_FMT_EMAIL) ||\n\t    !parent || !parent->next)\n\t\treturn 0;\n\n\toffset = sprintf(buf, \"Merge:\");\n\n\twhile (parent) {\n\t\tstruct commit *p = parent->item;\n\t\tconst char *hex = abbrev\n\t\t\t? find_unique_abbrev(p->object.sha1, abbrev)\n\t\t\t: sha1_to_hex(p->object.sha1);\n\t\tconst char *dots = (abbrev && strlen(hex) != 40) ? \"...\" : \"\";\n\t\tparent = parent->next;\n\n\t\toffset += sprintf(buf + offset, \" %s%s\", hex, dots);\n\t}\n\tbuf[offset++] = '\\n';\n\treturn offset;\n}\n\nunsigned long pretty_print_commit(enum cmit_fmt fmt, const struct commit *commit, unsigned long len, char *buf, unsigned long space, int abbrev, const char *subject, const char *after_subject)\n{\n\tint hdr = 1, body = 0;\n\tunsigned long offset = 0;\n\tint indent = 4;\n\tint parents_shown = 0;\n\tconst char *msg = commit->buffer;\n\tint plain_non_ascii = 0;\n\n\tif (fmt == CMIT_FMT_ONELINE || fmt == CMIT_FMT_EMAIL)\n\t\tindent = 0;\n\n\t/* After-subject is used to pass in Content-Type: multipart\n\t * MIME header; in that case we do not have to do the\n\t * plaintext content type even if the commit message has\n\t * non 7-bit ASCII character.  Otherwise, check if we need\n\t * to say this is not a 7-bit ASCII.\n\t */\n\tif (fmt == CMIT_FMT_EMAIL && !after_subject) {\n\t\tint i, ch, in_body;\n\n\t\tfor (in_body = i = 0; (ch = msg[i]) && i < len; i++) {\n\t\t\tif (!in_body) {\n\t\t\t\t/* author could be non 7-bit ASCII but\n\t\t\t\t * the log may so; skip over the\n\t\t\t\t * header part first.\n\t\t\t\t */\n\t\t\t\tif (ch == '\\n' &&\n\t\t\t\t    i + 1 < len && msg[i+1] == '\\n')\n\t\t\t\t\tin_body = 1;\n\t\t\t}\n\t\t\telse if (ch & 0x80) {\n\t\t\t\tplain_non_ascii = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (;;) {\n\t\tconst char *line = msg;\n\t\tint linelen = get_one_line(msg, len);\n\n\t\tif (!linelen)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * We want some slop for indentation and a possible\n\t\t * final \"...\". Thus the \"+ 20\".\n\t\t */\n\t\tif (offset + linelen + 20 > space) {\n\t\t\tmemcpy(buf + offset, \"    ...\\n\", 8);\n\t\t\toffset += 8;\n\t\t\tbreak;\n\t\t}\n\n\t\tmsg += linelen;\n\t\tlen -= linelen;\n\t\tif (hdr) {\n\t\t\tif (linelen == 1) {\n\t\t\t\thdr = 0;\n\t\t\t\tif ((fmt != CMIT_FMT_ONELINE) && !subject)\n\t\t\t\t\tbuf[offset++] = '\\n';\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (fmt == CMIT_FMT_RAW) {\n\t\t\t\tmemcpy(buf + offset, line, linelen);\n\t\t\t\toffset += linelen;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!memcmp(line, \"parent \", 7)) {\n\t\t\t\tif (linelen != 48)\n\t\t\t\t\tdie(\"bad parent line in commit\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!parents_shown) {\n\t\t\t\toffset += add_merge_info(fmt, buf + offset,\n\t\t\t\t\t\t\t commit, abbrev);\n\t\t\t\tparents_shown = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * MEDIUM == DEFAULT shows only author with dates.\n\t\t\t * FULL shows both authors but not dates.\n\t\t\t * FULLER shows both authors and dates.\n\t\t\t */\n\t\t\tif (!memcmp(line, \"author \", 7))\n\t\t\t\toffset += add_user_info(\"Author\", fmt,\n\t\t\t\t\t\t\tbuf + offset,\n\t\t\t\t\t\t\tline + 7);\n\t\t\tif (!memcmp(line, \"committer \", 10) &&\n\t\t\t    (fmt == CMIT_FMT_FULL || fmt == CMIT_FMT_FULLER))\n\t\t\t\toffset += add_user_info(\"Commit\", fmt,\n\t\t\t\t\t\t\tbuf + offset,\n\t\t\t\t\t\t\tline + 10);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!subject)\n\t\t\tbody = 1;\n\n\t\tif (is_empty_line(line, &linelen)) {\n\t\t\tif (!body)\n\t\t\t\tcontinue;\n\t\t\tif (subject)\n\t\t\t\tcontinue;\n\t\t\tif (fmt == CMIT_FMT_SHORT)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (subject) {\n\t\t\tint slen = strlen(subject);\n\t\t\tmemcpy(buf + offset, subject, slen);\n\t\t\toffset += slen;\n\t\t\toffset += add_rfc2047(buf + offset, line, linelen);\n\t\t}\n\t\telse {\n\t\t\tmemset(buf + offset, ' ', indent);\n\t\t\tmemcpy(buf + offset + indent, line, linelen);\n\t\t\toffset += linelen + indent;\n\t\t}\n\t\tbuf[offset++] = '\\n';\n\t\tif (fmt == CMIT_FMT_ONELINE)\n\t\t\tbreak;\n\t\tif (subject && plain_non_ascii) {\n\t\t\tstatic const char header[] =\n\t\t\t\t\"Content-Type: text/plain; charset=UTF-8\\n\"\n\t\t\t\t\"Content-Transfer-Encoding: 8bit\\n\";\n\t\t\tmemcpy(buf + offset, header, sizeof(header)-1);\n\t\t\toffset += sizeof(header)-1;\n\t\t}\n\t\tif (after_subject) {\n\t\t\tint slen = strlen(after_subject);\n\t\t\tif (slen > space - offset - 1)\n\t\t\t\tslen = space - offset - 1;\n\t\t\tmemcpy(buf + offset, after_subject, slen);\n\t\t\toffset += slen;\n\t\t\tafter_subject = NULL;\n\t\t}\n\t\tsubject = NULL;\n\t}\n\twhile (offset && isspace(buf[offset-1]))\n\t\toffset--;\n\t/* Make sure there is an EOLN for the non-oneline case */\n\tif (fmt != CMIT_FMT_ONELINE)\n\t\tbuf[offset++] = '\\n';\n\t/*\n\t * make sure there is another EOLN to separate the headers from whatever\n\t * body the caller appends if we haven't already written a body\n\t */\n\tif (fmt == CMIT_FMT_EMAIL && !body)\n\t\tbuf[offset++] = '\\n';\n\tbuf[offset] = '\\0';\n\treturn offset;\n}\n\nstruct commit *pop_commit(struct commit_list **stack)\n{\n\tstruct commit_list *top = *stack;\n\tstruct commit *item = top ? top->item : NULL;\n\n\tif (top) {\n\t\t*stack = top->next;\n\t\tfree(top);\n\t}\n\treturn item;\n}\n\nint count_parents(struct commit * commit)\n{\n        int count;\n        struct commit_list * parents = commit->parents;\n        for (count = 0; parents; parents = parents->next,count++)\n\t\t;\n        return count;\n}\n\nvoid topo_sort_default_setter(struct commit *c, void *data)\n{\n\tc->util = data;\n}\n\nvoid *topo_sort_default_getter(struct commit *c)\n{\n\treturn c->util;\n}\n\n/*\n * Performs an in-place topological sort on the list supplied.\n */\nvoid sort_in_topological_order(struct commit_list ** list, int lifo)\n{\n\tsort_in_topological_order_fn(list, lifo, topo_sort_default_setter,\n\t\t\t\t     topo_sort_default_getter);\n}\n\nvoid sort_in_topological_order_fn(struct commit_list ** list, int lifo,\n\t\t\t\t  topo_sort_set_fn_t setter,\n\t\t\t\t  topo_sort_get_fn_t getter)\n{\n\tstruct commit_list * next = *list;\n\tstruct commit_list * work = NULL, **insert;\n\tstruct commit_list ** pptr = list;\n\tstruct sort_node * nodes;\n\tstruct sort_node * next_nodes;\n\tint count = 0;\n\n\t/* determine the size of the list */\n\twhile (next) {\n\t\tnext = next->next;\n\t\tcount++;\n\t}\n\t\n\tif (!count)\n\t\treturn;\n\t/* allocate an array to help sort the list */\n\tnodes = xcalloc(count, sizeof(*nodes));\n\t/* link the list to the array */\n\tnext_nodes = nodes;\n\tnext=*list;\n\twhile (next) {\n\t\tnext_nodes->list_item = next;\n\t\tsetter(next->item, next_nodes);\n\t\tnext_nodes++;\n\t\tnext = next->next;\n\t}\n\t/* update the indegree */\n\tnext=*list;\n\twhile (next) {\n\t\tstruct commit_list * parents = next->item->parents;\n\t\twhile (parents) {\n\t\t\tstruct commit * parent=parents->item;\n\t\t\tstruct sort_node * pn = (struct sort_node *) getter(parent);\n\n\t\t\tif (pn)\n\t\t\t\tpn->indegree++;\n\t\t\tparents=parents->next;\n\t\t}\n\t\tnext=next->next;\n\t}\n\t/* \n         * find the tips\n         *\n         * tips are nodes not reachable from any other node in the list \n         * \n         * the tips serve as a starting set for the work queue.\n         */\n\tnext=*list;\n\tinsert = &work;\n\twhile (next) {\n\t\tstruct sort_node * node = (struct sort_node *) getter(next->item);\n\n\t\tif (node->indegree == 0) {\n\t\t\tinsert = &commit_list_insert(next->item, insert)->next;\n\t\t}\n\t\tnext=next->next;\n\t}\n\n\t/* process the list in topological order */\n\tif (!lifo)\n\t\tsort_by_date(&work);\n\twhile (work) {\n\t\tstruct commit * work_item = pop_commit(&work);\n\t\tstruct sort_node * work_node = (struct sort_node *) getter(work_item);\n\t\tstruct commit_list * parents = work_item->parents;\n\n\t\twhile (parents) {\n\t\t\tstruct commit * parent=parents->item;\n\t\t\tstruct sort_node * pn = (struct sort_node *) getter(parent);\n\n\t\t\tif (pn) {\n\t\t\t\t/*\n\t\t\t\t * parents are only enqueued for emission \n                                 * when all their children have been emitted thereby\n                                 * guaranteeing topological order.\n                                 */\n\t\t\t\tpn->indegree--;\n\t\t\t\tif (!pn->indegree) {\n\t\t\t\t\tif (!lifo)\n\t\t\t\t\t\tinsert_by_date(parent, &work);\n\t\t\t\t\telse\n\t\t\t\t\t\tcommit_list_insert(parent, &work);\n\t\t\t\t}\n\t\t\t}\n\t\t\tparents=parents->next;\n\t\t}\n\t\t/*\n                 * work_item is a commit all of whose children\n                 * have already been emitted. we can emit it now.\n                 */\n\t\t*pptr = work_node->list_item;\n\t\tpptr = &(*pptr)->next;\n\t\t*pptr = NULL;\n\t\tsetter(work_item, NULL);\n\t}\n\tfree(nodes);\n}\n\n/* merge-rebase stuff */\n\n/* bits #0..7 in revision.h */\n#define PARENT1\t\t(1u<< 8)\n#define PARENT2\t\t(1u<< 9)\n#define STALE\t\t(1u<<10)\n#define RESULT\t\t(1u<<11)\n\nstatic struct commit *interesting(struct commit_list *list)\n{\n\twhile (list) {\n\t\tstruct commit *commit = list->item;\n\t\tlist = list->next;\n\t\tif (commit->object.flags & STALE)\n\t\t\tcontinue;\n\t\treturn commit;\n\t}\n\treturn NULL;\n}\n\nstatic struct commit_list *merge_bases(struct commit *one, struct commit *two)\n{\n\tstruct commit_list *list = NULL;\n\tstruct commit_list *result = NULL;\n\n\tif (one == two)\n\t\t/* We do not mark this even with RESULT so we do not\n\t\t * have to clean it up.\n\t\t */\n\t\treturn commit_list_insert(one, &result);\n\n\tparse_commit(one);\n\tparse_commit(two);\n\n\tone->object.flags |= PARENT1;\n\ttwo->object.flags |= PARENT2;\n\tinsert_by_date(one, &list);\n\tinsert_by_date(two, &list);\n\n\twhile (interesting(list)) {\n\t\tstruct commit *commit;\n\t\tstruct commit_list *parents;\n\t\tstruct commit_list *n;\n\t\tint flags;\n\n\t\tcommit = list->item;\n\t\tn = list->next;\n\t\tfree(list);\n\t\tlist = n;\n\n\t\tflags = commit->object.flags & (PARENT1 | PARENT2 | STALE);\n\t\tif (flags == (PARENT1 | PARENT2)) {\n\t\t\tif (!(commit->object.flags & RESULT)) {\n\t\t\t\tcommit->object.flags |= RESULT;\n\t\t\t\tinsert_by_date(commit, &result);\n\t\t\t}\n\t\t\t/* Mark parents of a found merge stale */\n\t\t\tflags |= STALE;\n\t\t}\n\t\tparents = commit->parents;\n\t\twhile (parents) {\n\t\t\tstruct commit *p = parents->item;\n\t\t\tparents = parents->next;\n\t\t\tif ((p->object.flags & flags) == flags)\n\t\t\t\tcontinue;\n\t\t\tparse_commit(p);\n\t\t\tp->object.flags |= flags;\n\t\t\tinsert_by_date(p, &list);\n\t\t}\n\t}\n\n\t/* Clean up the result to remove stale ones */\n\tlist = result; result = NULL;\n\twhile (list) {\n\t\tstruct commit_list *n = list->next;\n\t\tif (!(list->item->object.flags & STALE))\n\t\t\tinsert_by_date(list->item, &result);\n\t\tfree(list);\n\t\tlist = n;\n\t}\n\treturn result;\n}\n\nstruct commit_list *get_merge_bases(struct commit *one,\n\t\t\t\t    struct commit *two,\n                                    int cleanup)\n{\n\tconst unsigned all_flags = (PARENT1 | PARENT2 | STALE | RESULT);\n\tstruct commit_list *list;\n\tstruct commit **rslt;\n\tstruct commit_list *result;\n\tint cnt, i, j;\n\n\tresult = merge_bases(one, two);\n\tif (one == two)\n\t\treturn result;\n\tif (!result || !result->next) {\n\t\tif (cleanup) {\n\t\t\tclear_commit_marks(one, all_flags);\n\t\t\tclear_commit_marks(two, all_flags);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/* There are more than one */\n\tcnt = 0;\n\tlist = result;\n\twhile (list) {\n\t\tlist = list->next;\n\t\tcnt++;\n\t}\n\trslt = xcalloc(cnt, sizeof(*rslt));\n\tfor (list = result, i = 0; list; list = list->next)\n\t\trslt[i++] = list->item;\n\tfree_commit_list(result);\n\n\tclear_commit_marks(one, all_flags);\n\tclear_commit_marks(two, all_flags);\n\tfor (i = 0; i < cnt - 1; i++) {\n\t\tfor (j = i+1; j < cnt; j++) {\n\t\t\tif (!rslt[i] || !rslt[j])\n\t\t\t\tcontinue;\n\t\t\tresult = merge_bases(rslt[i], rslt[j]);\n\t\t\tclear_commit_marks(rslt[i], all_flags);\n\t\t\tclear_commit_marks(rslt[j], all_flags);\n\t\t\tfor (list = result; list; list = list->next) {\n\t\t\t\tif (rslt[i] == list->item)\n\t\t\t\t\trslt[i] = NULL;\n\t\t\t\tif (rslt[j] == list->item)\n\t\t\t\t\trslt[j] = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Surviving ones in rslt[] are the independent results */\n\tresult = NULL;\n\tfor (i = 0; i < cnt; i++) {\n\t\tif (rslt[i])\n\t\t\tinsert_by_date(rslt[i], &result);\n\t}\n\tfree(rslt);\n\treturn result;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00bc3de22eb670c07e78087d96d9a3cff1d0fd67",
  "sha1_ok": true,
  "size": 22963
}
