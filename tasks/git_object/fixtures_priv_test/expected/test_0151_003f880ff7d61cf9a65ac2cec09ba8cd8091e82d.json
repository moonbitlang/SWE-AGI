{
  "content": {
    "base64": "I2lmbmRlZiBTVFJCVUZfSAojZGVmaW5lIFNUUkJVRl9ICgovKgogKiBOT1RFIEZPUiBTVFJCVUYgREVWRUxPUEVSUwogKgogKiBzdHJidWYgaXMgYSBsb3ctbGV2ZWwgcHJpbWl0aXZlOyBhcyBzdWNoIGl0IHNob3VsZCBpbnRlcmFjdCBvbmx5CiAqIHdpdGggb3RoZXIgbG93LWxldmVsIHByaW1pdGl2ZXMuIERvIG5vdCBpbnRyb2R1Y2UgbmV3IGZ1bmN0aW9ucwogKiB3aGljaCBpbnRlcmFjdCB3aXRoIGhpZ2hlci1sZXZlbCBBUElzLgogKi8KCnN0cnVjdCBzdHJpbmdfbGlzdDsKCi8qKgogKiBzdHJidWZzIGFyZSBtZWFudCB0byBiZSB1c2VkIHdpdGggYWxsIHRoZSB1c3VhbCBDIHN0cmluZyBhbmQgbWVtb3J5CiAqIEFQSXMuIEdpdmVuIHRoYXQgdGhlIGxlbmd0aCBvZiB0aGUgYnVmZmVyIGlzIGtub3duLCBpdCdzIG9mdGVuIGJldHRlciB0bwogKiB1c2UgdGhlIG1lbSogZnVuY3Rpb25zIHRoYW4gYSBzdHIqIG9uZSAoZS5nLiwgbWVtY2hyIHZzLiBzdHJjaHIpLgogKiBUaG91Z2gsIG9uZSBoYXMgdG8gYmUgY2FyZWZ1bCBhYm91dCB0aGUgZmFjdCB0aGF0IHN0ciogZnVuY3Rpb25zIG9mdGVuCiAqIHN0b3Agb24gTlVMcyBhbmQgdGhhdCBzdHJidWZzIG1heSBoYXZlIGVtYmVkZGVkIE5VTHMuCiAqCiAqIEEgc3RyYnVmIGlzIE5VTCB0ZXJtaW5hdGVkIGZvciBjb252ZW5pZW5jZSwgYnV0IG5vIGZ1bmN0aW9uIGluIHRoZQogKiBzdHJidWYgQVBJIGFjdHVhbGx5IHJlbGllcyBvbiB0aGUgc3RyaW5nIGJlaW5nIGZyZWUgb2YgTlVMcy4KICoKICogc3RyYnVmcyBoYXZlIHNvbWUgaW52YXJpYW50cyB0aGF0IGFyZSB2ZXJ5IGltcG9ydGFudCB0byBrZWVwIGluIG1pbmQ6CiAqCiAqICAtIFRoZSBgYnVmYCBtZW1iZXIgaXMgbmV2ZXIgTlVMTCwgc28gaXQgY2FuIGJlIHVzZWQgaW4gYW55IHVzdWFsIEMKICogICAgc3RyaW5nIG9wZXJhdGlvbnMgc2FmZWx5LiBzdHJidWZzIF9oYXZlXyB0byBiZSBpbml0aWFsaXplZCBlaXRoZXIgYnkKICogICAgYHN0cmJ1Zl9pbml0KClgIG9yIGJ5IGA9IFNUUkJVRl9JTklUYCBiZWZvcmUgdGhlIGludmFyaWFudHMsIHRob3VnaC4KICoKICogICAgRG8gKm5vdCogYXNzdW1lIGFueXRoaW5nIG9uIHdoYXQgYGJ1ZmAgcmVhbGx5IGlzIChlLmcuIGlmIGl0IGlzCiAqICAgIGFsbG9jYXRlZCBtZW1vcnkgb3Igbm90KSwgdXNlIGBzdHJidWZfZGV0YWNoKClgIHRvIHVud3JhcCBhIG1lbW9yeQogKiAgICBidWZmZXIgZnJvbSBpdHMgc3RyYnVmIHNoZWxsIGluIGEgc2FmZSB3YXkuIFRoYXQgaXMgdGhlIHNvbGUgc3VwcG9ydGVkCiAqICAgIHdheS4gVGhpcyB3aWxsIGdpdmUgeW91IGEgbWFsbG9jZWQgYnVmZmVyIHRoYXQgeW91IGNhbiBsYXRlciBgZnJlZSgpYC4KICoKICogICAgSG93ZXZlciwgaXQgaXMgdG90YWxseSBzYWZlIHRvIG1vZGlmeSBhbnl0aGluZyBpbiB0aGUgc3RyaW5nIHBvaW50ZWQgYnkKICogICAgdGhlIGBidWZgIG1lbWJlciwgYmV0d2VlbiB0aGUgaW5kaWNlcyBgMGAgYW5kIGBsZW4tMWAgKGluY2x1c2l2ZSkuCiAqCiAqICAtIFRoZSBgYnVmYCBtZW1iZXIgaXMgYSBieXRlIGFycmF5IHRoYXQgaGFzIGF0IGxlYXN0IGBsZW4gKyAxYCBieXRlcwogKiAgICBhbGxvY2F0ZWQuIFRoZSBleHRyYSBieXRlIGlzIHVzZWQgdG8gc3RvcmUgYSBgJ1wwJ2AsIGFsbG93aW5nIHRoZQogKiAgICBgYnVmYCBtZW1iZXIgdG8gYmUgYSB2YWxpZCBDLXN0cmluZy4gQWxsIHN0cmJ1ZiBmdW5jdGlvbnMgZW5zdXJlIHRoaXMKICogICAgaW52YXJpYW50IGlzIHByZXNlcnZlZC4KICoKICogICAgTk9URTogSXQgaXMgT0sgdG8gInBsYXkiIHdpdGggdGhlIGJ1ZmZlciBkaXJlY3RseSBpZiB5b3Ugd29yayBpdCB0aGlzCiAqICAgIHdheToKICoKICogICAgICAgIHN0cmJ1Zl9ncm93KHNiLCBTT01FX1NJWkUpOyA8MT4KICogICAgICAgIHN0cmJ1Zl9zZXRsZW4oc2IsIHNiLT5sZW4gKyBTT01FX09USEVSX1NJWkUpOwogKgogKiAgICA8MT4gSGVyZSwgdGhlIG1lbW9yeSBhcnJheSBzdGFydGluZyBhdCBgc2ItPmJ1ZmAsIGFuZCBvZiBsZW5ndGgKICogICAgYHN0cmJ1Zl9hdmFpbChzYilgIGlzIGFsbCB5b3VycywgYW5kIHlvdSBjYW4gYmUgc3VyZSB0aGF0CiAqICAgIGBzdHJidWZfYXZhaWwoc2IpYCBpcyBhdCBsZWFzdCBgU09NRV9TSVpFYC4KICoKICogICAgTk9URTogYFNPTUVfT1RIRVJfU0laRWAgbXVzdCBiZSBzbWFsbGVyIG9yIGVxdWFsIHRvIGBzdHJidWZfYXZhaWwoc2IpYC4KICoKICogICAgRG9pbmcgc28gaXMgc2FmZSwgdGhvdWdoIGlmIGl0IGhhcyB0byBiZSBkb25lIGluIG1hbnkgcGxhY2VzLCBhZGRpbmcgdGhlCiAqICAgIG1pc3NpbmcgQVBJIHRvIHRoZSBzdHJidWYgbW9kdWxlIGlzIHRoZSB3YXkgdG8gZ28uCiAqCiAqICAgIFdBUk5JTkc6IERvIF9ub3RfIGFzc3VtZSB0aGF0IHRoZSBhcmVhIHRoYXQgaXMgeW91cnMgaXMgb2Ygc2l6ZSBgYWxsb2MKICogICAgLSAxYCBldmVuIGlmIGl0J3MgdHJ1ZSBpbiB0aGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbi4gQWxsb2MgaXMgc29tZWhvdyBhCiAqICAgICJwcml2YXRlIiBtZW1iZXIgdGhhdCBzaG91bGQgbm90IGJlIG1lc3NlZCB3aXRoLiBVc2UgYHN0cmJ1Zl9hdmFpbCgpYAogKiAgICBpbnN0ZWFkLgoqLwoKLyoqCiAqIERhdGEgU3RydWN0dXJlcwogKiAtLS0tLS0tLS0tLS0tLS0KICovCgovKioKICogVGhpcyBpcyB0aGUgc3RyaW5nIGJ1ZmZlciBzdHJ1Y3R1cmUuIFRoZSBgbGVuYCBtZW1iZXIgY2FuIGJlIHVzZWQgdG8KICogZGV0ZXJtaW5lIHRoZSBjdXJyZW50IGxlbmd0aCBvZiB0aGUgc3RyaW5nLCBhbmQgYGJ1ZmAgbWVtYmVyIHByb3ZpZGVzCiAqIGFjY2VzcyB0byB0aGUgc3RyaW5nIGl0c2VsZi4KICovCnN0cnVjdCBzdHJidWYgewoJc2l6ZV90IGFsbG9jOwoJc2l6ZV90IGxlbjsKCWNoYXIgKmJ1ZjsKfTsKCmV4dGVybiBjaGFyIHN0cmJ1Zl9zbG9wYnVmW107CiNkZWZpbmUgU1RSQlVGX0lOSVQgIHsgLmJ1ZiA9IHN0cmJ1Zl9zbG9wYnVmIH0KCnN0cnVjdCBvYmplY3RfaWQ7CgovKioKICogTGlmZSBDeWNsZSBGdW5jdGlvbnMKICogLS0tLS0tLS0tLS0tLS0tLS0tLS0KICovCgovKioKICogSW5pdGlhbGl6ZSB0aGUgc3RydWN0dXJlLiBUaGUgc2Vjb25kIHBhcmFtZXRlciBjYW4gYmUgemVybyBvciBhIGJpZ2dlcgogKiBudW1iZXIgdG8gYWxsb2NhdGUgbWVtb3J5LCBpbiBjYXNlIHlvdSB3YW50IHRvIHByZXZlbnQgZnVydGhlciByZWFsbG9jcy4KICovCnZvaWQgc3RyYnVmX2luaXQoc3RydWN0IHN0cmJ1ZiAqc2IsIHNpemVfdCBhbGxvYyk7CgovKioKICogUmVsZWFzZSBhIHN0cmluZyBidWZmZXIgYW5kIHRoZSBtZW1vcnkgaXQgdXNlZC4gQWZ0ZXIgdGhpcyBjYWxsLCB0aGUKICogc3RyYnVmIHBvaW50cyB0byBhbiBlbXB0eSBzdHJpbmcgdGhhdCBkb2VzIG5vdCBuZWVkIHRvIGJlIGZyZWUoKWVkLCBhcwogKiBpZiBpdCBoYWQgYmVlbiBzZXQgdG8gYFNUUkJVRl9JTklUYCBhbmQgbmV2ZXIgbW9kaWZpZWQuCiAqCiAqIFRvIGNsZWFyIGEgc3RyYnVmIGluIHByZXBhcmF0aW9uIGZvciBmdXJ0aGVyIHVzZSB3aXRob3V0IHRoZSBvdmVyaGVhZAogKiBvZiBmcmVlKClpbmcgYW5kIG1hbGxvYygpaW5nIGFnYWluLCB1c2Ugc3RyYnVmX3Jlc2V0KCkgaW5zdGVhZC4KICovCnZvaWQgc3RyYnVmX3JlbGVhc2Uoc3RydWN0IHN0cmJ1ZiAqc2IpOwoKLyoqCiAqIERldGFjaCB0aGUgc3RyaW5nIGZyb20gdGhlIHN0cmJ1ZiBhbmQgcmV0dXJucyBpdDsgeW91IG5vdyBvd24gdGhlCiAqIHN0b3JhZ2UgdGhlIHN0cmluZyBvY2N1cGllcyBhbmQgaXQgaXMgeW91ciByZXNwb25zaWJpbGl0eSBmcm9tIHRoZW4gb24KICogdG8gcmVsZWFzZSBpdCB3aXRoIGBmcmVlKDMpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIGl0LgogKgogKiBUaGUgc3RyYnVmIHRoYXQgcHJldmlvdXNseSBoZWxkIHRoZSBzdHJpbmcgaXMgcmVzZXQgdG8gYFNUUkJVRl9JTklUYCBzbwogKiBpdCBjYW4gYmUgcmV1c2VkIGFmdGVyIGNhbGxpbmcgdGhpcyBmdW5jdGlvbi4KICovCmNoYXIgKnN0cmJ1Zl9kZXRhY2goc3RydWN0IHN0cmJ1ZiAqc2IsIHNpemVfdCAqc3opOwoKLyoqCiAqIEF0dGFjaCBhIHN0cmluZyB0byBhIGJ1ZmZlci4gWW91IHNob3VsZCBzcGVjaWZ5IHRoZSBzdHJpbmcgdG8gYXR0YWNoLAogKiB0aGUgY3VycmVudCBsZW5ndGggb2YgdGhlIHN0cmluZyBhbmQgdGhlIGFtb3VudCBvZiBhbGxvY2F0ZWQgbWVtb3J5LgogKiBUaGUgYW1vdW50IG11c3QgYmUgbGFyZ2VyIHRoYW4gdGhlIHN0cmluZyBsZW5ndGgsIGJlY2F1c2UgdGhlIHN0cmluZyB5b3UKICogcGFzcyBpcyBzdXBwb3NlZCB0byBiZSBhIE5VTC10ZXJtaW5hdGVkIHN0cmluZy4gIFRoaXMgc3RyaW5nIF9tdXN0XyBiZQogKiBtYWxsb2MoKWVkLCBhbmQgYWZ0ZXIgYXR0YWNoaW5nLCB0aGUgcG9pbnRlciBjYW5ub3QgYmUgcmVsaWVkIHVwb24KICogYW55bW9yZSwgYW5kIG5laXRoZXIgYmUgZnJlZSgpZCBkaXJlY3RseS4KICovCnZvaWQgc3RyYnVmX2F0dGFjaChzdHJ1Y3Qgc3RyYnVmICpzYiwgdm9pZCAqc3RyLCBzaXplX3QgbGVuLCBzaXplX3QgbWVtKTsKCi8qKgogKiBTd2FwIHRoZSBjb250ZW50cyBvZiB0d28gc3RyaW5nIGJ1ZmZlcnMuCiAqLwpzdGF0aWMgaW5saW5lIHZvaWQgc3RyYnVmX3N3YXAoc3RydWN0IHN0cmJ1ZiAqYSwgc3RydWN0IHN0cmJ1ZiAqYikKewoJU1dBUCgqYSwgKmIpOwp9CgoKLyoqCiAqIEZ1bmN0aW9ucyByZWxhdGVkIHRvIHRoZSBzaXplIG9mIHRoZSBidWZmZXIKICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQogKi8KCi8qKgogKiBEZXRlcm1pbmUgdGhlIGFtb3VudCBvZiBhbGxvY2F0ZWQgYnV0IHVudXNlZCBtZW1vcnkuCiAqLwpzdGF0aWMgaW5saW5lIHNpemVfdCBzdHJidWZfYXZhaWwoY29uc3Qgc3RydWN0IHN0cmJ1ZiAqc2IpCnsKCXJldHVybiBzYi0+YWxsb2MgPyBzYi0+YWxsb2MgLSBzYi0+bGVuIC0gMSA6IDA7Cn0KCi8qKgogKiBFbnN1cmUgdGhhdCBhdCBsZWFzdCB0aGlzIGFtb3VudCBvZiB1bnVzZWQgbWVtb3J5IGlzIGF2YWlsYWJsZSBhZnRlcgogKiBgbGVuYC4gVGhpcyBpcyB1c2VkIHdoZW4geW91IGtub3cgYSB0eXBpY2FsIHNpemUgZm9yIHdoYXQgeW91IHdpbGwgYWRkCiAqIGFuZCB3YW50IHRvIGF2b2lkIHJlcGV0aXRpdmUgYXV0b21hdGljIHJlc2l6aW5nIG9mIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlci4KICogVGhpcyBpcyBuZXZlciBhIG5lZWRlZCBvcGVyYXRpb24sIGJ1dCBjYW4gYmUgY3JpdGljYWwgZm9yIHBlcmZvcm1hbmNlIGluCiAqIHNvbWUgY2FzZXMuCiAqLwp2b2lkIHN0cmJ1Zl9ncm93KHN0cnVjdCBzdHJidWYgKnNiLCBzaXplX3QgYW1vdW50KTsKCi8qKgogKiBTZXQgdGhlIGxlbmd0aCBvZiB0aGUgYnVmZmVyIHRvIGEgZ2l2ZW4gdmFsdWUuIFRoaXMgZnVuY3Rpb24gZG9lcyAqbm90KgogKiBhbGxvY2F0ZSBuZXcgbWVtb3J5LCBzbyB5b3Ugc2hvdWxkIG5vdCBwZXJmb3JtIGEgYHN0cmJ1Zl9zZXRsZW4oKWAgdG8gYQogKiBsZW5ndGggdGhhdCBpcyBsYXJnZXIgdGhhbiBgbGVuICsgc3RyYnVmX2F2YWlsKClgLiBgc3RyYnVmX3NldGxlbigpYCBpcwogKiBqdXN0IG1lYW50IGFzIGEgJ3BsZWFzZSBmaXggaW52YXJpYW50cyBmcm9tIHRoaXMgc3RyYnVmIEkganVzdCBtZXNzZWQKICogd2l0aCcuCiAqLwpzdGF0aWMgaW5saW5lIHZvaWQgc3RyYnVmX3NldGxlbihzdHJ1Y3Qgc3RyYnVmICpzYiwgc2l6ZV90IGxlbikKewoJaWYgKGxlbiA+IChzYi0+YWxsb2MgPyBzYi0+YWxsb2MgLSAxIDogMCkpCgkJQlVHKCJzdHJidWZfc2V0bGVuKCkgYmV5b25kIGJ1ZmZlciIpOwoJc2ItPmxlbiA9IGxlbjsKCWlmIChzYi0+YnVmICE9IHN0cmJ1Zl9zbG9wYnVmKQoJCXNiLT5idWZbbGVuXSA9ICdcMCc7CgllbHNlCgkJYXNzZXJ0KCFzdHJidWZfc2xvcGJ1ZlswXSk7Cn0KCi8qKgogKiBFbXB0eSB0aGUgYnVmZmVyIGJ5IHNldHRpbmcgdGhlIHNpemUgb2YgaXQgdG8gemVyby4KICovCiNkZWZpbmUgc3RyYnVmX3Jlc2V0KHNiKSAgc3RyYnVmX3NldGxlbihzYiwgMCkKCgovKioKICogRnVuY3Rpb25zIHJlbGF0ZWQgdG8gdGhlIGNvbnRlbnRzIG9mIHRoZSBidWZmZXIKICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KICovCgovKioKICogU3RyaXAgd2hpdGVzcGFjZSBmcm9tIHRoZSBiZWdpbm5pbmcgKGBsdHJpbWApLCBlbmQgKGBydHJpbWApLCBvciBib3RoIHNpZGUKICogKGB0cmltYCkgb2YgYSBzdHJpbmcuCiAqLwp2b2lkIHN0cmJ1Zl90cmltKHN0cnVjdCBzdHJidWYgKnNiKTsKdm9pZCBzdHJidWZfcnRyaW0oc3RydWN0IHN0cmJ1ZiAqc2IpOwp2b2lkIHN0cmJ1Zl9sdHJpbShzdHJ1Y3Qgc3RyYnVmICpzYik7CgovKiBTdHJpcCB0cmFpbGluZyBkaXJlY3Rvcnkgc2VwYXJhdG9ycyAqLwp2b2lkIHN0cmJ1Zl90cmltX3RyYWlsaW5nX2Rpcl9zZXAoc3RydWN0IHN0cmJ1ZiAqc2IpOwoKLyogU3RyaXAgdHJhaWxpbmcgTEYgb3IgQ1IvTEYgKi8Kdm9pZCBzdHJidWZfdHJpbV90cmFpbGluZ19uZXdsaW5lKHN0cnVjdCBzdHJidWYgKnNiKTsKCi8qKgogKiBSZXBsYWNlIHRoZSBjb250ZW50cyBvZiB0aGUgc3RyYnVmIHdpdGggYSByZWVuY29kZWQgZm9ybS4gIFJldHVybnMgLTEKICogb24gZXJyb3IsIDAgb24gc3VjY2Vzcy4KICovCmludCBzdHJidWZfcmVlbmNvZGUoc3RydWN0IHN0cmJ1ZiAqc2IsIGNvbnN0IGNoYXIgKmZyb20sIGNvbnN0IGNoYXIgKnRvKTsKCi8qKgogKiBMb3dlcmNhc2UgZWFjaCBjaGFyYWN0ZXIgaW4gdGhlIGJ1ZmZlciB1c2luZyBgdG9sb3dlcmAuCiAqLwp2b2lkIHN0cmJ1Zl90b2xvd2VyKHN0cnVjdCBzdHJidWYgKnNiKTsKCi8qKgogKiBDb21wYXJlIHR3byBidWZmZXJzLiBSZXR1cm5zIGFuIGludGVnZXIgbGVzcyB0aGFuLCBlcXVhbCB0bywgb3IgZ3JlYXRlcgogKiB0aGFuIHplcm8gaWYgdGhlIGZpcnN0IGJ1ZmZlciBpcyBmb3VuZCwgcmVzcGVjdGl2ZWx5LCB0byBiZSBsZXNzIHRoYW4sCiAqIHRvIG1hdGNoLCBvciBiZSBncmVhdGVyIHRoYW4gdGhlIHNlY29uZCBidWZmZXIuCiAqLwppbnQgc3RyYnVmX2NtcChjb25zdCBzdHJ1Y3Qgc3RyYnVmICpmaXJzdCwgY29uc3Qgc3RydWN0IHN0cmJ1ZiAqc2Vjb25kKTsKCgovKioKICogQWRkaW5nIGRhdGEgdG8gdGhlIGJ1ZmZlcgogKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCiAqCiAqIE5PVEU6IEFsbCBvZiB0aGUgZnVuY3Rpb25zIGluIHRoaXMgc2VjdGlvbiB3aWxsIGdyb3cgdGhlIGJ1ZmZlciBhcwogKiBuZWNlc3NhcnkuICBJZiB0aGV5IGZhaWwgZm9yIHNvbWUgcmVhc29uIG90aGVyIHRoYW4gbWVtb3J5IHNob3J0YWdlIGFuZCB0aGUKICogYnVmZmVyIGhhZG4ndCBiZWVuIGFsbG9jYXRlZCBiZWZvcmUgKGkuZS4gdGhlIGBzdHJ1Y3Qgc3RyYnVmYCB3YXMgc2V0IHRvCiAqIGBTVFJCVUZfSU5JVGApLCB0aGVuIHRoZXkgd2lsbCBmcmVlKCkgaXQuCiAqLwoKLyoqCiAqIEFkZCBhIHNpbmdsZSBjaGFyYWN0ZXIgdG8gdGhlIGJ1ZmZlci4KICovCnN0YXRpYyBpbmxpbmUgdm9pZCBzdHJidWZfYWRkY2goc3RydWN0IHN0cmJ1ZiAqc2IsIGludCBjKQp7CglpZiAoIXN0cmJ1Zl9hdmFpbChzYikpCgkJc3RyYnVmX2dyb3coc2IsIDEpOwoJc2ItPmJ1ZltzYi0+bGVuKytdID0gYzsKCXNiLT5idWZbc2ItPmxlbl0gPSAnXDAnOwp9CgovKioKICogQWRkIGEgY2hhcmFjdGVyIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIHRpbWVzIHRvIHRoZSBidWZmZXIuCiAqLwp2b2lkIHN0cmJ1Zl9hZGRjaGFycyhzdHJ1Y3Qgc3RyYnVmICpzYiwgaW50IGMsIHNpemVfdCBuKTsKCi8qKgogKiBJbnNlcnQgZGF0YSB0byB0aGUgZ2l2ZW4gcG9zaXRpb24gb2YgdGhlIGJ1ZmZlci4gVGhlIHJlbWFpbmluZyBjb250ZW50cwogKiB3aWxsIGJlIHNoaWZ0ZWQsIG5vdCBvdmVyd3JpdHRlbi4KICovCnZvaWQgc3RyYnVmX2luc2VydChzdHJ1Y3Qgc3RyYnVmICpzYiwgc2l6ZV90IHBvcywgY29uc3Qgdm9pZCAqLCBzaXplX3QpOwoKLyoqCiAqIEluc2VydCBhIE5VTC10ZXJtaW5hdGVkIHN0cmluZyB0byB0aGUgZ2l2ZW4gcG9zaXRpb24gb2YgdGhlIGJ1ZmZlci4KICogVGhlIHJlbWFpbmluZyBjb250ZW50cyB3aWxsIGJlIHNoaWZ0ZWQsIG5vdCBvdmVyd3JpdHRlbi4gIEl0J3MgYW4KICogaW5saW5lIGZ1bmN0aW9uIHRvIGFsbG93IHRoZSBjb21waWxlciB0byByZXNvbHZlIHN0cmxlbigpIGNhbGxzIG9uCiAqIGNvbnN0YW50cyBhdCBjb21waWxlIHRpbWUuCiAqLwpzdGF0aWMgaW5saW5lIHZvaWQgc3RyYnVmX2luc2VydHN0cihzdHJ1Y3Qgc3RyYnVmICpzYiwgc2l6ZV90IHBvcywKCQkJCSAgICBjb25zdCBjaGFyICpzKQp7CglzdHJidWZfaW5zZXJ0KHNiLCBwb3MsIHMsIHN0cmxlbihzKSk7Cn0KCi8qKgogKiBJbnNlcnQgZGF0YSB0byB0aGUgZ2l2ZW4gcG9zaXRpb24gb2YgdGhlIGJ1ZmZlciBnaXZpbmcgYSBwcmludGYgZm9ybWF0CiAqIHN0cmluZy4gVGhlIGNvbnRlbnRzIHdpbGwgYmUgc2hpZnRlZCwgbm90IG92ZXJ3cml0dGVuLgogKi8Kdm9pZCBzdHJidWZfdmluc2VydGYoc3RydWN0IHN0cmJ1ZiAqc2IsIHNpemVfdCBwb3MsIGNvbnN0IGNoYXIgKmZtdCwKCQkgICAgIHZhX2xpc3QgYXApOwoKX19hdHRyaWJ1dGVfXygoZm9ybWF0IChwcmludGYsIDMsIDQpKSkKdm9pZCBzdHJidWZfaW5zZXJ0ZihzdHJ1Y3Qgc3RyYnVmICpzYiwgc2l6ZV90IHBvcywgY29uc3QgY2hhciAqZm10LCAuLi4pOwoKLyoqCiAqIFJlbW92ZSBnaXZlbiBhbW91bnQgb2YgZGF0YSBmcm9tIGEgZ2l2ZW4gcG9zaXRpb24gb2YgdGhlIGJ1ZmZlci4KICovCnZvaWQgc3RyYnVmX3JlbW92ZShzdHJ1Y3Qgc3RyYnVmICpzYiwgc2l6ZV90IHBvcywgc2l6ZV90IGxlbik7CgovKioKICogUmVtb3ZlIHRoZSBieXRlcyBiZXR3ZWVuIGBwb3MuLnBvcytsZW5gIGFuZCByZXBsYWNlIGl0IHdpdGggdGhlIGdpdmVuCiAqIGRhdGEuCiAqLwp2b2lkIHN0cmJ1Zl9zcGxpY2Uoc3RydWN0IHN0cmJ1ZiAqc2IsIHNpemVfdCBwb3MsIHNpemVfdCBsZW4sCgkJICAgY29uc3Qgdm9pZCAqZGF0YSwgc2l6ZV90IGRhdGFfbGVuKTsKCi8qKgogKiBBZGQgYSBOVUwtdGVybWluYXRlZCBzdHJpbmcgdG8gdGhlIGJ1ZmZlci4gRWFjaCBsaW5lIHdpbGwgYmUgcHJlcGVuZGVkCiAqIGJ5IGEgY29tbWVudCBjaGFyYWN0ZXIgYW5kIGEgYmxhbmsuCiAqLwp2b2lkIHN0cmJ1Zl9hZGRfY29tbWVudGVkX2xpbmVzKHN0cnVjdCBzdHJidWYgKm91dCwKCQkJCWNvbnN0IGNoYXIgKmJ1Ziwgc2l6ZV90IHNpemUsCgkJCQljb25zdCBjaGFyICpjb21tZW50X3ByZWZpeCk7CgoKLyoqCiAqIEFkZCBkYXRhIG9mIGdpdmVuIGxlbmd0aCB0byB0aGUgYnVmZmVyLgogKi8Kdm9pZCBzdHJidWZfYWRkKHN0cnVjdCBzdHJidWYgKnNiLCBjb25zdCB2b2lkICpkYXRhLCBzaXplX3QgbGVuKTsKCi8qKgogKiBBZGQgYSBOVUwtdGVybWluYXRlZCBzdHJpbmcgdG8gdGhlIGJ1ZmZlci4KICoKICogTk9URTogVGhpcyBmdW5jdGlvbiB3aWxsICphbHdheXMqIGJlIGltcGxlbWVudGVkIGFzIGFuIGlubGluZSBvciBhIG1hY3JvCiAqIHVzaW5nIHN0cmxlbiwgbWVhbmluZyB0aGF0IHRoaXMgaXMgZWZmaWNpZW50IHRvIHdyaXRlIHRoaW5ncyBsaWtlOgogKgogKiAgICAgc3RyYnVmX2FkZHN0cihzYiwgImltbWVkaWF0ZSBzdHJpbmciKTsKICoKICovCnN0YXRpYyBpbmxpbmUgdm9pZCBzdHJidWZfYWRkc3RyKHN0cnVjdCBzdHJidWYgKnNiLCBjb25zdCBjaGFyICpzKQp7CglzdHJidWZfYWRkKHNiLCBzLCBzdHJsZW4ocykpOwp9CgovKioKICogQWRkIGEgTlVMLXRlcm1pbmF0ZWQgc3RyaW5nIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIHRpbWVzIHRvIHRoZSBidWZmZXIuCiAqLwp2b2lkIHN0cmJ1Zl9hZGRzdHJpbmdzKHN0cnVjdCBzdHJidWYgKnNiLCBjb25zdCBjaGFyICpzLCBzaXplX3Qgbik7CgovKioKICogQ29weSB0aGUgY29udGVudHMgb2YgYW5vdGhlciBidWZmZXIgYXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBvbmUuCiAqLwp2b2lkIHN0cmJ1Zl9hZGRidWYoc3RydWN0IHN0cmJ1ZiAqc2IsIGNvbnN0IHN0cnVjdCBzdHJidWYgKnNiMik7CgovKioKICogSm9pbiB0aGUgYXJndW1lbnRzIGludG8gYSBidWZmZXIuIGBkZWxpbWAgaXMgcHV0IGJldHdlZW4gZXZlcnkKICogdHdvIGFyZ3VtZW50cy4KICovCmNvbnN0IGNoYXIgKnN0cmJ1Zl9qb2luX2FyZ3Yoc3RydWN0IHN0cmJ1ZiAqYnVmLCBpbnQgYXJnYywKCQkJICAgICBjb25zdCBjaGFyICoqYXJndiwgY2hhciBkZWxpbSk7CgovKioKICogVXNlZCB3aXRoIGBzdHJidWZfZXhwYW5kX3N0ZXBgIHRvIGV4cGFuZCB0aGUgbGl0ZXJhbHMgJW4gYW5kICV4CiAqIGZvbGxvd2VkIGJ5IHR3byBoZXhhZGVjaW1hbCBkaWdpdHMuIFJldHVybnMgdGhlIG51bWJlciBvZiByZWNvZ25pemVkCiAqIGNoYXJhY3RlcnMuCiAqLwpzaXplX3Qgc3RyYnVmX2V4cGFuZF9saXRlcmFsKHN0cnVjdCBzdHJidWYgKnNiLCBjb25zdCBjaGFyICpwbGFjZWhvbGRlcik7CgovKioKICogSWYgdGhlIHN0cmluZyBwb2ludGVkIHRvIGJ5IGBmb3JtYXRwYCBjb250YWlucyBhIHBlcmNlbnQgc2lnbiAoIiUiKSwKICogYWR2YW5jZSBpdCB0byBwb2ludCB0byB0aGUgY2hhcmFjdGVyIGZvbGxvd2luZyB0aGUgbmV4dCBvbmUgYW5kCiAqIHJldHVybiAxLCBvdGhlcndpc2UgcmV0dXJuIDAuICBBcHBlbmQgdGhlIHN1YnN0cmluZyBiZWZvcmUgdGhhdAogKiBwZXJjZW50IHNpZ24gdG8gYHNiYCwgb3IgdGhlIHdob2xlIHN0cmluZyBpZiB0aGVyZSBpcyBub25lLgogKi8KaW50IHN0cmJ1Zl9leHBhbmRfc3RlcChzdHJ1Y3Qgc3RyYnVmICpzYiwgY29uc3QgY2hhciAqKmZvcm1hdHApOwoKLyoqCiAqIFVzZWQgd2l0aCBgc3RyYnVmX2V4cGFuZF9zdGVwYCB0byByZXBvcnQgdW5rbm93biBwbGFjZWhvbGRlcnMuCiAqLwp2b2lkIHN0cmJ1Zl9leHBhbmRfYmFkX2Zvcm1hdChjb25zdCBjaGFyICpmb3JtYXQsIGNvbnN0IGNoYXIgKmNvbW1hbmQpOwoKLyoqCiAqIEFwcGVuZCB0aGUgY29udGVudHMgb2Ygb25lIHN0cmJ1ZiB0byBhbm90aGVyLCBxdW90aW5nIGFueQogKiBwZXJjZW50IHNpZ25zICgiJSIpIGludG8gZG91YmxlLXBlcmNlbnRzICgiJSUiKSBpbiB0aGUKICogZGVzdGluYXRpb24uIFRoaXMgaXMgdXNlZnVsIGZvciBsaXRlcmFsIGRhdGEgdG8gYmUgZmVkIHRvIGVpdGhlcgogKiBzdHJidWZfZXhwYW5kIG9yIHRvIHRoZSAqcHJpbnRmIGZhbWlseSBvZiBmdW5jdGlvbnMuCiAqLwp2b2lkIHN0cmJ1Zl9hZGRidWZfcGVyY2VudHF1b3RlKHN0cnVjdCBzdHJidWYgKmRzdCwgY29uc3Qgc3RydWN0IHN0cmJ1ZiAqc3JjKTsKCiNkZWZpbmUgU1RSQlVGX0VOQ09ERV9TTEFTSCAxCgovKioKICogQXBwZW5kIHRoZSBjb250ZW50cyBvZiBhIHN0cmluZyB0byBhIHN0cmJ1ZiwgcGVyY2VudC1lbmNvZGluZyBhbnkgY2hhcmFjdGVycwogKiB0aGF0IGFyZSBuZWVkZWQgdG8gYmUgZW5jb2RlZCBmb3IgYSBVUkwuCiAqCiAqIElmIFNUUkJVRl9FTkNPREVfU0xBU0ggaXMgc2V0IGluIGZsYWdzLCBwZXJjZW50LWVuY29kZSBzbGFzaGVzLiAgT3RoZXJ3aXNlLAogKiBzbGFzaGVzIGFyZSBub3QgcGVyY2VudC1lbmNvZGVkLgogKi8Kdm9pZCBzdHJidWZfYWRkX3BlcmNlbnRlbmNvZGUoc3RydWN0IHN0cmJ1ZiAqZHN0LCBjb25zdCBjaGFyICpzcmMsIGludCBmbGFncyk7CgovKioKICogQXBwZW5kIHRoZSBnaXZlbiBieXRlIHNpemUgYXMgYSBodW1hbi1yZWFkYWJsZSBzdHJpbmcgKGkuZS4gMTIuMjMgS2lCLAogKiAzLjUwIE1pQikuCiAqLwp2b2lkIHN0cmJ1Zl9odW1hbmlzZV9ieXRlcyhzdHJ1Y3Qgc3RyYnVmICpidWYsIG9mZl90IGJ5dGVzKTsKCi8qKgogKiBBcHBlbmQgdGhlIGdpdmVuIGJ5dGUgcmF0ZSBhcyBhIGh1bWFuLXJlYWRhYmxlIHN0cmluZyAoaS5lLiAxMi4yMyBLaUIvcywKICogMy41MCBNaUIvcykuCiAqLwp2b2lkIHN0cmJ1Zl9odW1hbmlzZV9yYXRlKHN0cnVjdCBzdHJidWYgKmJ1Ziwgb2ZmX3QgYnl0ZXMpOwoKLyoqCiAqIEFkZCBhIGZvcm1hdHRlZCBzdHJpbmcgdG8gdGhlIGJ1ZmZlci4KICovCl9fYXR0cmlidXRlX18oKGZvcm1hdCAocHJpbnRmLDIsMykpKQp2b2lkIHN0cmJ1Zl9hZGRmKHN0cnVjdCBzdHJidWYgKnNiLCBjb25zdCBjaGFyICpmbXQsIC4uLik7CgovKioKICogQWRkIGEgZm9ybWF0dGVkIHN0cmluZyBwcmVwZW5kZWQgYnkgYSBjb21tZW50IGNoYXJhY3RlciBhbmQgYQogKiBibGFuayB0byB0aGUgYnVmZmVyLgogKi8KX19hdHRyaWJ1dGVfXygoZm9ybWF0IChwcmludGYsIDMsIDQpKSkKdm9pZCBzdHJidWZfY29tbWVudGVkX2FkZGYoc3RydWN0IHN0cmJ1ZiAqc2IsIGNvbnN0IGNoYXIgKmNvbW1lbnRfcHJlZml4LCBjb25zdCBjaGFyICpmbXQsIC4uLik7CgpfX2F0dHJpYnV0ZV9fKChmb3JtYXQgKHByaW50ZiwyLDApKSkKdm9pZCBzdHJidWZfdmFkZGYoc3RydWN0IHN0cmJ1ZiAqc2IsIGNvbnN0IGNoYXIgKmZtdCwgdmFfbGlzdCBhcCk7CgovKioKICogQWRkIHRoZSB0aW1lIHNwZWNpZmllZCBieSBgdG1gLCBhcyBmb3JtYXR0ZWQgYnkgYHN0cmZ0aW1lYC4KICogYHR6X29mZnNldGAgaXMgaW4gZGVjaW1hbCBoaG1tIGZvcm1hdCwgZS5nLiAtNjAwIG1lYW5zIHNpeCBob3VycyB3ZXN0CiAqIG9mIEdyZWVud2ljaCwgYW5kIGl0J3MgdXNlZCB0byBleHBhbmQgJXogaW50ZXJuYWxseS4gIEhvd2V2ZXIsIHRva2VucwogKiB3aXRoIG1vZGlmaWVycyAoZS5nLiAlRXopIGFyZSBwYXNzZWQgdG8gYHN0cmZ0aW1lYC4KICogYHN1cHByZXNzX3R6X25hbWVgLCB3aGVuIHNldCwgZXhwYW5kcyAlWiBpbnRlcm5hbGx5IHRvIHRoZSBlbXB0eQogKiBzdHJpbmcgcmF0aGVyIHRoYW4gcGFzc2luZyBpdCB0byBgc3RyZnRpbWVgLgogKi8Kdm9pZCBzdHJidWZfYWRkZnRpbWUoc3RydWN0IHN0cmJ1ZiAqc2IsIGNvbnN0IGNoYXIgKmZtdCwKCQkgICAgY29uc3Qgc3RydWN0IHRtICp0bSwgaW50IHR6X29mZnNldCwKCQkgICAgaW50IHN1cHByZXNzX3R6X25hbWUpOwoKLyoqCiAqIFJlYWQgYSBnaXZlbiBzaXplIG9mIGRhdGEgZnJvbSBhIEZJTEUqIHBvaW50ZXIgdG8gdGhlIGJ1ZmZlci4KICoKICogTk9URTogVGhlIGJ1ZmZlciBpcyByZXdvdW5kIGlmIHRoZSByZWFkIGZhaWxzLiBJZiAtMSBpcyByZXR1cm5lZCwKICogYGVycm5vYCBtdXN0IGJlIGNvbnN1bHRlZCwgbGlrZSB5b3Ugd291bGQgZG8gZm9yIGByZWFkKDMpYC4KICogYHN0cmJ1Zl9yZWFkKClgLCBgc3RyYnVmX3JlYWRfZmlsZSgpYCBhbmQgYHN0cmJ1Zl9nZXRsaW5lXyooKWAKICogZmFtaWx5IG9mIGZ1bmN0aW9ucyBoYXZlIHRoZSBzYW1lIGJlaGF2aW91ciBhcyB3ZWxsLgogKi8Kc2l6ZV90IHN0cmJ1Zl9mcmVhZChzdHJ1Y3Qgc3RyYnVmICpzYiwgc2l6ZV90IHNpemUsIEZJTEUgKmZpbGUpOwoKLyoqCiAqIFJlYWQgdGhlIGNvbnRlbnRzIG9mIGEgZ2l2ZW4gZmlsZSBkZXNjcmlwdG9yLiBUaGUgdGhpcmQgYXJndW1lbnQgY2FuIGJlCiAqIHVzZWQgdG8gZ2l2ZSBhIGhpbnQgYWJvdXQgdGhlIGZpbGUgc2l6ZSwgdG8gYXZvaWQgcmVhbGxvY3MuICBJZiByZWFkIGZhaWxzLAogKiBhbnkgcGFydGlhbCByZWFkIGlzIHVuZG9uZS4KICovCnNzaXplX3Qgc3RyYnVmX3JlYWQoc3RydWN0IHN0cmJ1ZiAqc2IsIGludCBmZCwgc2l6ZV90IGhpbnQpOwoKLyoqCiAqIFJlYWQgdGhlIGNvbnRlbnRzIG9mIGEgZ2l2ZW4gZmlsZSBkZXNjcmlwdG9yIHBhcnRpYWxseSBieSB1c2luZyBvbmx5IG9uZQogKiBhdHRlbXB0IG9mIHhyZWFkLiBUaGUgdGhpcmQgYXJndW1lbnQgY2FuIGJlIHVzZWQgdG8gZ2l2ZSBhIGhpbnQgYWJvdXQgdGhlCiAqIGZpbGUgc2l6ZSwgdG8gYXZvaWQgcmVhbGxvY3MuIFJldHVybnMgdGhlIG51bWJlciBvZiBuZXcgYnl0ZXMgYXBwZW5kZWQgdG8KICogdGhlIHNiLgogKi8Kc3NpemVfdCBzdHJidWZfcmVhZF9vbmNlKHN0cnVjdCBzdHJidWYgKnNiLCBpbnQgZmQsIHNpemVfdCBoaW50KTsKCi8qKgogKiBSZWFkIHRoZSBjb250ZW50cyBvZiBhIGZpbGUsIHNwZWNpZmllZCBieSBpdHMgcGF0aC4gVGhlIHRoaXJkIGFyZ3VtZW50CiAqIGNhbiBiZSB1c2VkIHRvIGdpdmUgYSBoaW50IGFib3V0IHRoZSBmaWxlIHNpemUsIHRvIGF2b2lkIHJlYWxsb2NzLgogKiBSZXR1cm4gdGhlIG51bWJlciBvZiBieXRlcyByZWFkIG9yIGEgbmVnYXRpdmUgdmFsdWUgaWYgc29tZSBlcnJvcgogKiBvY2N1cnJlZCB3aGlsZSBvcGVuaW5nIG9yIHJlYWRpbmcgdGhlIGZpbGUuCiAqLwpzc2l6ZV90IHN0cmJ1Zl9yZWFkX2ZpbGUoc3RydWN0IHN0cmJ1ZiAqc2IsIGNvbnN0IGNoYXIgKnBhdGgsIHNpemVfdCBoaW50KTsKCi8qKgogKiBSZWFkIHRoZSB0YXJnZXQgb2YgYSBzeW1ib2xpYyBsaW5rLCBzcGVjaWZpZWQgYnkgaXRzIHBhdGguICBUaGUgdGhpcmQKICogYXJndW1lbnQgY2FuIGJlIHVzZWQgdG8gZ2l2ZSBhIGhpbnQgYWJvdXQgdGhlIHNpemUsIHRvIGF2b2lkIHJlYWxsb2NzLgogKi8KaW50IHN0cmJ1Zl9yZWFkbGluayhzdHJ1Y3Qgc3RyYnVmICpzYiwgY29uc3QgY2hhciAqcGF0aCwgc2l6ZV90IGhpbnQpOwoKLyoqCiAqIFdyaXRlIHRoZSB3aG9sZSBjb250ZW50IG9mIHRoZSBzdHJidWYgdG8gdGhlIHN0cmVhbSBub3Qgc3RvcHBpbmcgYXQKICogTlVMIGJ5dGVzLgogKi8Kc3NpemVfdCBzdHJidWZfd3JpdGUoc3RydWN0IHN0cmJ1ZiAqc2IsIEZJTEUgKnN0cmVhbSk7CgovKioKICogUmVhZCBmcm9tIGEgRklMRSAqIHVudGlsIHRoZSBzcGVjaWZpZWQgdGVybWluYXRvciBpcyBlbmNvdW50ZXJlZCwKICogb3ZlcndyaXRpbmcgdGhlIGV4aXN0aW5nIGNvbnRlbnRzIG9mIHRoZSBzdHJidWYuCiAqCiAqIFJlYWRpbmcgc3RvcHMgYWZ0ZXIgdGhlIHRlcm1pbmF0b3Igb3IgYXQgRU9GLiAgVGhlIHRlcm1pbmF0b3IgaXMKICogcmVtb3ZlZCBmcm9tIHRoZSBidWZmZXIgYmVmb3JlIHJldHVybmluZy4gIElmIHRoZSB0ZXJtaW5hdG9yIGlzIExGCiAqIGFuZCBpZiBpdCBpcyBwcmVjZWRlZCBieSBhIENSLCB0aGVuIHRoZSB3aG9sZSBDUkxGIGlzIHN0cmlwcGVkLgogKiBSZXR1cm5zIDAgdW5sZXNzIHRoZXJlIHdhcyBub3RoaW5nIGxlZnQgYmVmb3JlIEVPRiwgaW4gd2hpY2ggY2FzZQogKiBpdCByZXR1cm5zIGBFT0ZgLgogKi8KaW50IHN0cmJ1Zl9nZXRkZWxpbV9zdHJpcF9jcmxmKHN0cnVjdCBzdHJidWYgKnNiLCBGSUxFICpmcCwgaW50IHRlcm0pOwoKLyoqCiAqIFJlYWQgYSBsaW5lIGZyb20gYSBGSUxFICosIG92ZXJ3cml0aW5nIHRoZSBleGlzdGluZyBjb250ZW50cyBvZgogKiB0aGUgc3RyYnVmLiAgVGhlIHN0cmJ1Zl9nZXRsaW5lKigpIGZhbWlseSBvZiBmdW5jdGlvbnMgc2hhcmUKICogdGhpcyBzaWduYXR1cmUsIGJ1dCBoYXZlIGRpZmZlcmVudCBsaW5lIHRlcm1pbmF0aW9uIGNvbnZlbnRpb25zLgogKgogKiBSZWFkaW5nIHN0b3BzIGFmdGVyIHRoZSB0ZXJtaW5hdG9yIG9yIGF0IEVPRi4gIFRoZSB0ZXJtaW5hdG9yCiAqIGlzIHJlbW92ZWQgZnJvbSB0aGUgYnVmZmVyIGJlZm9yZSByZXR1cm5pbmcuICBSZXR1cm5zIDAgdW5sZXNzCiAqIHRoZXJlIHdhcyBub3RoaW5nIGxlZnQgYmVmb3JlIEVPRiwgaW4gd2hpY2ggY2FzZSBpdCByZXR1cm5zIGBFT0ZgLgogKi8KdHlwZWRlZiBpbnQgKCpzdHJidWZfZ2V0bGluZV9mbikoc3RydWN0IHN0cmJ1ZiAqLCBGSUxFICopOwoKLyogVXNlcyBMRiBhcyB0aGUgbGluZSB0ZXJtaW5hdG9yICovCmludCBzdHJidWZfZ2V0bGluZV9sZihzdHJ1Y3Qgc3RyYnVmICpzYiwgRklMRSAqZnApOwoKLyogVXNlcyBOVUwgYXMgdGhlIGxpbmUgdGVybWluYXRvciAqLwppbnQgc3RyYnVmX2dldGxpbmVfbnVsKHN0cnVjdCBzdHJidWYgKnNiLCBGSUxFICpmcCk7CgovKgogKiBTaW1pbGFyIHRvIHN0cmJ1Zl9nZXRsaW5lX2xmKCksIGJ1dCBhZGRpdGlvbmFsbHkgdHJlYXRzIGEgQ1IgdGhhdAogKiBjb21lcyBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIExGIGFzIHBhcnQgb2YgdGhlIHRlcm1pbmF0b3IuCiAqIFRoaXMgaXMgdGhlIG1vc3QgZnJpZW5kbHkgdmVyc2lvbiB0byBiZSB1c2VkIHRvIHJlYWQgInRleHQiIGZpbGVzCiAqIHRoYXQgY2FuIGNvbWUgZnJvbSBwbGF0Zm9ybXMgd2hvc2UgbmF0aXZlIHRleHQgZm9ybWF0IGlzIENSTEYKICogdGVybWluYXRlZC4KICovCmludCBzdHJidWZfZ2V0bGluZShzdHJ1Y3Qgc3RyYnVmICpzYiwgRklMRSAqZmlsZSk7CgoKLyoqCiAqIExpa2UgYHN0cmJ1Zl9nZXRsaW5lYCwgYnV0IGtlZXBzIHRoZSB0cmFpbGluZyB0ZXJtaW5hdG9yIChpZgogKiBhbnkpIGluIHRoZSBidWZmZXIuCiAqLwppbnQgc3RyYnVmX2dldHdob2xlbGluZShzdHJ1Y3Qgc3RyYnVmICpzYiwgRklMRSAqZmlsZSwgaW50IHRlcm0pOwoKLyoqCiAqIExpa2UgYHN0cmJ1Zl9nZXR3aG9sZWxpbmVgLCBidXQgYXBwZW5kcyB0aGUgbGluZSBpbnN0ZWFkIG9mCiAqIHJlc2V0dGluZyB0aGUgYnVmZmVyIGZpcnN0LgogKi8KaW50IHN0cmJ1Zl9hcHBlbmR3aG9sZWxpbmUoc3RydWN0IHN0cmJ1ZiAqc2IsIEZJTEUgKmZpbGUsIGludCB0ZXJtKTsKCi8qKgogKiBMaWtlIGBzdHJidWZfZ2V0d2hvbGVsaW5lYCwgYnV0IG9wZXJhdGVzIG9uIGEgZmlsZSBkZXNjcmlwdG9yLgogKiBJdCByZWFkcyBvbmUgY2hhcmFjdGVyIGF0IGEgdGltZSwgc28gaXQgaXMgdmVyeSBzbG93LiAgRG8gbm90CiAqIHVzZSBpdCB1bmxlc3MgeW91IG5lZWQgdGhlIGNvcnJlY3QgcG9zaXRpb24gaW4gdGhlIGZpbGUKICogZGVzY3JpcHRvci4KICovCmludCBzdHJidWZfZ2V0d2hvbGVsaW5lX2ZkKHN0cnVjdCBzdHJidWYgKnNiLCBpbnQgZmQsIGludCB0ZXJtKTsKCi8qKgogKiBTZXQgdGhlIGJ1ZmZlciB0byB0aGUgcGF0aCBvZiB0aGUgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeS4KICovCmludCBzdHJidWZfZ2V0Y3dkKHN0cnVjdCBzdHJidWYgKnNiKTsKCi8qKgogKiBOb3JtYWxpemUgaW4tcGxhY2UgdGhlIHBhdGggY29udGFpbmVkIGluIHRoZSBzdHJidWYuIFNlZQogKiBub3JtYWxpemVfcGF0aF9jb3B5KCkgZm9yIGRldGFpbHMuIElmIGFuIGVycm9yIG9jY3VycywgdGhlIGNvbnRlbnRzIG9mICJzYiIKICogYXJlIGxlZnQgdW50b3VjaGVkLCBhbmQgLTEgaXMgcmV0dXJuZWQuCiAqLwppbnQgc3RyYnVmX25vcm1hbGl6ZV9wYXRoKHN0cnVjdCBzdHJidWYgKnNiKTsKCi8qKgogKiBTdHJpcCB3aGl0ZXNwYWNlIGZyb20gYSBidWZmZXIuIElmIGNvbW1lbnRfcHJlZml4IGlzIG5vbi1OVUxMLAogKiB0aGVuIGxpbmVzIGJlZ2lubmluZyB3aXRoIHRoYXQgY2hhcmFjdGVyIGFyZSBjb25zaWRlcmVkIGNvbW1lbnRzLAogKiB0aHVzIHJlbW92ZWQuCiAqLwp2b2lkIHN0cmJ1Zl9zdHJpcHNwYWNlKHN0cnVjdCBzdHJidWYgKmJ1ZiwgY29uc3QgY2hhciAqY29tbWVudF9wcmVmaXgpOwoKc3RhdGljIGlubGluZSBpbnQgc3RyYnVmX3N0cmlwX3N1ZmZpeChzdHJ1Y3Qgc3RyYnVmICpzYiwgY29uc3QgY2hhciAqc3VmZml4KQp7CglpZiAoc3RyaXBfc3VmZml4X21lbShzYi0+YnVmLCAmc2ItPmxlbiwgc3VmZml4KSkgewoJCXN0cmJ1Zl9zZXRsZW4oc2IsIHNiLT5sZW4pOwoJCXJldHVybiAxOwoJfSBlbHNlCgkJcmV0dXJuIDA7Cn0KCi8qKgogKiBTcGxpdCBzdHIgKG9mIGxlbmd0aCBzbGVuKSBhdCB0aGUgc3BlY2lmaWVkIHRlcm1pbmF0b3IgY2hhcmFjdGVyLgogKiBSZXR1cm4gYSBudWxsLXRlcm1pbmF0ZWQgYXJyYXkgb2YgcG9pbnRlcnMgdG8gc3RyYnVmIG9iamVjdHMKICogaG9sZGluZyB0aGUgc3Vic3RyaW5ncy4gIFRoZSBzdWJzdHJpbmdzIGluY2x1ZGUgdGhlIHRlcm1pbmF0b3IsCiAqIGV4Y2VwdCBmb3IgdGhlIGxhc3Qgc3Vic3RyaW5nLCB3aGljaCBtaWdodCBiZSB1bnRlcm1pbmF0ZWQgaWYgdGhlCiAqIG9yaWdpbmFsIHN0cmluZyBkaWQgbm90IGVuZCB3aXRoIGEgdGVybWluYXRvci4gIElmIG1heCBpcyBwb3NpdGl2ZSwKICogdGhlbiBzcGxpdCB0aGUgc3RyaW5nIGludG8gYXQgbW9zdCBtYXggc3Vic3RyaW5ncyAod2l0aCB0aGUgbGFzdAogKiBzdWJzdHJpbmcgY29udGFpbmluZyBldmVyeXRoaW5nIGZvbGxvd2luZyB0aGUgKG1heC0xKXRoIHRlcm1pbmF0b3IKICogY2hhcmFjdGVyKS4KICoKICogVGhlIG1vc3QgZ2VuZXJpYyBmb3JtIGlzIGBzdHJidWZfc3BsaXRfYnVmYCwgd2hpY2ggdGFrZXMgYW4gYXJiaXRyYXJ5CiAqIHBvaW50ZXIvbGVuIGJ1ZmZlci4gVGhlIGBfc3RyYCB2YXJpYW50IHRha2VzIGEgTlVMLXRlcm1pbmF0ZWQgc3RyaW5nLAogKiB0aGUgYF9tYXhgIHZhcmlhbnQgdGFrZXMgYSBzdHJidWYsIGFuZCBqdXN0IGBzdHJidWZfc3BsaXRgIGlzIGEgY29udmVuaWVuY2UKICogd3JhcHBlciB0byBkcm9wIHRoZSBgbWF4YCBwYXJhbWV0ZXIuCiAqCiAqIEZvciBsaWdodGVyLXdlaWdodCBhbHRlcm5hdGl2ZXMsIHNlZSBzdHJpbmdfbGlzdF9zcGxpdCgpIGFuZAogKiBzdHJpbmdfbGlzdF9zcGxpdF9pbl9wbGFjZSgpLgogKi8Kc3RydWN0IHN0cmJ1ZiAqKnN0cmJ1Zl9zcGxpdF9idWYoY29uc3QgY2hhciAqc3RyLCBzaXplX3QgbGVuLAoJCQkJIGludCB0ZXJtaW5hdG9yLCBpbnQgbWF4KTsKCnN0YXRpYyBpbmxpbmUgc3RydWN0IHN0cmJ1ZiAqKnN0cmJ1Zl9zcGxpdF9zdHIoY29uc3QgY2hhciAqc3RyLAoJCQkJCSAgICAgICBpbnQgdGVybWluYXRvciwgaW50IG1heCkKewoJcmV0dXJuIHN0cmJ1Zl9zcGxpdF9idWYoc3RyLCBzdHJsZW4oc3RyKSwgdGVybWluYXRvciwgbWF4KTsKfQoKc3RhdGljIGlubGluZSBzdHJ1Y3Qgc3RyYnVmICoqc3RyYnVmX3NwbGl0X21heChjb25zdCBzdHJ1Y3Qgc3RyYnVmICpzYiwKCQkJCQkgICAgICAgaW50IHRlcm1pbmF0b3IsIGludCBtYXgpCnsKCXJldHVybiBzdHJidWZfc3BsaXRfYnVmKHNiLT5idWYsIHNiLT5sZW4sIHRlcm1pbmF0b3IsIG1heCk7Cn0KCnN0YXRpYyBpbmxpbmUgc3RydWN0IHN0cmJ1ZiAqKnN0cmJ1Zl9zcGxpdChjb25zdCBzdHJ1Y3Qgc3RyYnVmICpzYiwKCQkJCQkgICBpbnQgdGVybWluYXRvcikKewoJcmV0dXJuIHN0cmJ1Zl9zcGxpdF9tYXgoc2IsIHRlcm1pbmF0b3IsIDApOwp9CgovKgogKiBBZGRzIGFsbCBzdHJpbmdzIG9mIGEgc3RyaW5nIGxpc3QgdG8gdGhlIHN0cmJ1Ziwgc2VwYXJhdGVkIGJ5IHRoZSBnaXZlbgogKiBzZXBhcmF0b3IuICBGb3IgZXhhbXBsZSwgaWYgc2VwIGlzCiAqICAgJywgJwogKiBhbmQgc2xpc3QgY29udGFpbnMKICogICBbJ2VsZW1lbnQxJywgJ2VsZW1lbnQyJywgLi4uLCAnZWxlbWVudE4nXSwKICogdGhlbiB3cml0ZToKICogICAnZWxlbWVudDEsIGVsZW1lbnQyLCAuLi4sIGVsZW1lbnROJwogKiB0byBzdHIuICBJZiBvbmx5IG9uZSBlbGVtZW50LCBqdXN0IHdyaXRlICJlbGVtZW50MSIgdG8gc3RyLgogKi8Kdm9pZCBzdHJidWZfYWRkX3NlcGFyYXRlZF9zdHJpbmdfbGlzdChzdHJ1Y3Qgc3RyYnVmICpzdHIsCgkJCQkgICAgICBjb25zdCBjaGFyICpzZXAsCgkJCQkgICAgICBzdHJ1Y3Qgc3RyaW5nX2xpc3QgKnNsaXN0KTsKCi8qKgogKiBGcmVlIGEgTlVMTC10ZXJtaW5hdGVkIGxpc3Qgb2Ygc3RyYnVmcyAoZm9yIGV4YW1wbGUsIHRoZSByZXR1cm4KICogdmFsdWVzIG9mIHRoZSBzdHJidWZfc3BsaXQqKCkgZnVuY3Rpb25zKS4KICovCnZvaWQgc3RyYnVmX2xpc3RfZnJlZShzdHJ1Y3Qgc3RyYnVmICoqbGlzdCk7CgovKgogKiBSZW1vdmUgdGhlIGZpbGVuYW1lIGZyb20gdGhlIHByb3ZpZGVkIHBhdGggc3RyaW5nLiBJZiB0aGUgcGF0aAogKiBjb250YWlucyBhIHRyYWlsaW5nIHNlcGFyYXRvciwgdGhlbiB0aGUgcGF0aCBpcyBjb25zaWRlcmVkIGEgZGlyZWN0b3J5CiAqIGFuZCBub3RoaW5nIGlzIG1vZGlmaWVkLgogKgogKiBFeGFtcGxlczoKICogLSAiL3BhdGgvdG8vZmlsZSIgLT4gIi9wYXRoL3RvLyIKICogLSAiL3BhdGgvdG8vZGlyLyIgLT4gIi9wYXRoL3RvL2Rpci8iCiAqLwp2b2lkIHN0cmJ1Zl9zdHJpcF9maWxlX2Zyb21fcGF0aChzdHJ1Y3Qgc3RyYnVmICpzYik7Cgp2b2lkIHN0cmJ1Zl9hZGRfbGluZXMoc3RydWN0IHN0cmJ1ZiAqc2IsCgkJICAgICAgY29uc3QgY2hhciAqcHJlZml4LAoJCSAgICAgIGNvbnN0IGNoYXIgKmJ1ZiwKCQkgICAgICBzaXplX3Qgc2l6ZSk7CgovKioKICogQXBwZW5kIHMgdG8gc2IsIHdpdGggdGhlIGNoYXJhY3RlcnMgJzwnLCAnPicsICcmJyBhbmQgJyInIGNvbnZlcnRlZAogKiBpbnRvIFhNTCBlbnRpdGllcy4KICovCnZvaWQgc3RyYnVmX2FkZHN0cl94bWxfcXVvdGVkKHN0cnVjdCBzdHJidWYgKnNiLAoJCQkgICAgICBjb25zdCBjaGFyICpzKTsKCi8qKgogKiAiQ29tcGxldGUiIHRoZSBjb250ZW50cyBvZiBgc2JgIGJ5IGVuc3VyaW5nIHRoYXQgZWl0aGVyIGl0IGVuZHMgd2l0aCB0aGUKICogY2hhcmFjdGVyIGB0ZXJtYCwgb3IgaXQgaXMgZW1wdHkuICBUaGlzIGNhbiBiZSB1c2VkLCBmb3IgZXhhbXBsZSwKICogdG8gZW5zdXJlIHRoYXQgdGV4dCBlbmRzIHdpdGggYSBuZXdsaW5lLCBidXQgd2l0aG91dCBjcmVhdGluZyBhbiBlbXB0eQogKiBibGFuayBsaW5lIGlmIHRoZXJlIGlzIG5vIGNvbnRlbnQgaW4gdGhlIGZpcnN0IHBsYWNlLgogKi8Kc3RhdGljIGlubGluZSB2b2lkIHN0cmJ1Zl9jb21wbGV0ZShzdHJ1Y3Qgc3RyYnVmICpzYiwgY2hhciB0ZXJtKQp7CglpZiAoc2ItPmxlbiAmJiBzYi0+YnVmW3NiLT5sZW4gLSAxXSAhPSB0ZXJtKQoJCXN0cmJ1Zl9hZGRjaChzYiwgdGVybSk7Cn0KCnN0YXRpYyBpbmxpbmUgdm9pZCBzdHJidWZfY29tcGxldGVfbGluZShzdHJ1Y3Qgc3RyYnVmICpzYikKewoJc3RyYnVmX2NvbXBsZXRlKHNiLCAnXG4nKTsKfQoKLyoKICogQ29weSAibmFtZSIgdG8gInNiIiwgZXhwYW5kaW5nIGFueSBzcGVjaWFsIEAtbWFya3MgYXMgaGFuZGxlZCBieQogKiByZXBvX2ludGVycHJldF9icmFuY2hfbmFtZSgpLiBUaGUgcmVzdWx0IGlzIGEgbm9uLXF1YWxpZmllZCBicmFuY2ggbmFtZQogKiAoc28gImZvbyIgb3IgIm9yaWdpbi9tYXN0ZXIiIGluc3RlYWQgb2YgInJlZnMvaGVhZHMvZm9vIiBvcgogKiAicmVmcy9yZW1vdGVzL29yaWdpbi9tYXN0ZXIiKS4KICoKICogTm90ZSB0aGF0IHRoZSByZXN1bHRpbmcgbmFtZSBtYXkgbm90IGJlIGEgc3ludGFjdGljYWxseSB2YWxpZCByZWZuYW1lLgogKgogKiBJZiAiYWxsb3dlZCIgaXMgbm9uLXplcm8sIHJlc3RyaWN0IHRoZSBzZXQgb2YgYWxsb3dlZCBleHBhbnNpb25zLiBTZWUKICogcmVwb19pbnRlcnByZXRfYnJhbmNoX25hbWUoKSBmb3IgZGV0YWlscy4KICovCnZvaWQgc3RyYnVmX2JyYW5jaG5hbWUoc3RydWN0IHN0cmJ1ZiAqc2IsIGNvbnN0IGNoYXIgKm5hbWUsCgkJICAgICAgIHVuc2lnbmVkIGFsbG93ZWQpOwoKLyoKICogTGlrZSBzdHJidWZfYnJhbmNobmFtZSgpIGFib3ZlLCBidXQgY29uZmlybSB0aGF0IHRoZSByZXN1bHQgaXMKICogc3ludGFjdGljYWxseSB2YWxpZCB0byBiZSB1c2VkIGFzIGEgbG9jYWwgYnJhbmNoIG5hbWUgaW4gcmVmcy9oZWFkcy8uCiAqCiAqIFRoZSByZXR1cm4gdmFsdWUgaXMgIjAiIGlmIHRoZSByZXN1bHQgaXMgdmFsaWQsIGFuZCAiLTEiIG90aGVyd2lzZS4KICovCmludCBzdHJidWZfY2hlY2tfYnJhbmNoX3JlZihzdHJ1Y3Qgc3RyYnVmICpzYiwgY29uc3QgY2hhciAqbmFtZSk7Cgp0eXBlZGVmIGludCAoKmNoYXJfcHJlZGljYXRlKShjaGFyIGNoKTsKCnZvaWQgc3RyYnVmX2FkZHN0cl91cmxlbmNvZGUoc3RydWN0IHN0cmJ1ZiAqc2IsIGNvbnN0IGNoYXIgKm5hbWUsCgkJCSAgICAgY2hhcl9wcmVkaWNhdGUgYWxsb3dfdW5lbmNvZGVkX2ZuKTsKCl9fYXR0cmlidXRlX18oKGZvcm1hdCAocHJpbnRmLDEsMikpKQppbnQgcHJpbnRmX2xuKGNvbnN0IGNoYXIgKmZtdCwgLi4uKTsKX19hdHRyaWJ1dGVfXygoZm9ybWF0IChwcmludGYsMiwzKSkpCmludCBmcHJpbnRmX2xuKEZJTEUgKmZwLCBjb25zdCBjaGFyICpmbXQsIC4uLik7CgpjaGFyICp4c3RyZHVwX3RvbG93ZXIoY29uc3QgY2hhciAqKTsKY2hhciAqeHN0cmR1cF90b3VwcGVyKGNvbnN0IGNoYXIgKik7CgovKioKICogQ3JlYXRlIGEgbmV3bHkgYWxsb2NhdGVkIHN0cmluZyB1c2luZyBwcmludGYgZm9ybWF0LiBZb3UgY2FuIGRvIHRoaXMgZWFzaWx5CiAqIHdpdGggYSBzdHJidWYsIGJ1dCB0aGlzIHByb3ZpZGVzIGEgc2hvcnRjdXQgdG8gc2F2ZSBhIGZldyBsaW5lcy4KICovCl9fYXR0cmlidXRlX18oKGZvcm1hdCAocHJpbnRmLCAxLCAwKSkpCmNoYXIgKnhzdHJ2Zm10KGNvbnN0IGNoYXIgKmZtdCwgdmFfbGlzdCBhcCk7Cl9fYXR0cmlidXRlX18oKGZvcm1hdCAocHJpbnRmLCAxLCAyKSkpCmNoYXIgKnhzdHJmbXQoY29uc3QgY2hhciAqZm10LCAuLi4pOwoKaW50IHN0YXJ0c193aXRoKGNvbnN0IGNoYXIgKnN0ciwgY29uc3QgY2hhciAqcHJlZml4KTsKaW50IGlzdGFydHNfd2l0aChjb25zdCBjaGFyICpzdHIsIGNvbnN0IGNoYXIgKnByZWZpeCk7CmludCBzdGFydHNfd2l0aF9tZW0oY29uc3QgY2hhciAqc3RyLCBzaXplX3QgbGVuLCBjb25zdCBjaGFyICpwcmVmaXgpOwoKLyoKICogSWYgdGhlIHN0cmluZyAic3RyIiBpcyB0aGUgc2FtZSBhcyB0aGUgc3RyaW5nIGluICJwcmVmaXgiLCB0aGVuIHRoZSAiYXJnIgogKiBwYXJhbWV0ZXIgaXMgc2V0IHRvIHRoZSAiZGVmIiBwYXJhbWV0ZXIgYW5kIDEgaXMgcmV0dXJuZWQuCiAqIElmIHRoZSBzdHJpbmcgInN0ciIgYmVnaW5zIHdpdGggdGhlIHN0cmluZyBmb3VuZCBpbiAicHJlZml4IiBhbmQgdGhlbiBhCiAqICI9IiBzaWduLCB0aGVuIHRoZSAiYXJnIiBwYXJhbWV0ZXIgaXMgc2V0IHRvICJzdHIgKyBzdHJsZW4ocHJlZml4KSArIDEiCiAqIChpLmUuLCB0byB0aGUgcG9pbnQgaW4gdGhlIHN0cmluZyByaWdodCBhZnRlciB0aGUgcHJlZml4IGFuZCB0aGUgIj0iIHNpZ24pLAogKiBhbmQgMSBpcyByZXR1cm5lZC4KICoKICogT3RoZXJ3aXNlLCByZXR1cm4gMCBhbmQgbGVhdmUgImFyZyIgdW50b3VjaGVkLgogKgogKiBXaGVuIHdlIGFjY2VwdCBib3RoIGEgIi0ta2V5IiBhbmQgYSAiLS1rZXk9PHZhbD4iIG9wdGlvbiwgdGhpcyBmdW5jdGlvbgogKiBjYW4gYmUgdXNlZCBpbnN0ZWFkIG9mICFzdHJjbXAoYXJnLCAiLS1rZXkiKSBhbmQgdGhlbgogKiBza2lwX3ByZWZpeChhcmcsICItLWtleT0iLCAmYXJnKSB0byBwYXJzZSBzdWNoIGFuIG9wdGlvbi4KICovCmludCBza2lwX3RvX29wdGlvbmFsX2FyZ19kZWZhdWx0KGNvbnN0IGNoYXIgKnN0ciwgY29uc3QgY2hhciAqcHJlZml4LAoJCQkJIGNvbnN0IGNoYXIgKiphcmcsIGNvbnN0IGNoYXIgKmRlZik7CgpzdGF0aWMgaW5saW5lIGludCBza2lwX3RvX29wdGlvbmFsX2FyZyhjb25zdCBjaGFyICpzdHIsIGNvbnN0IGNoYXIgKnByZWZpeCwKCQkJCSAgICAgICBjb25zdCBjaGFyICoqYXJnKQp7CglyZXR1cm4gc2tpcF90b19vcHRpb25hbF9hcmdfZGVmYXVsdChzdHIsIHByZWZpeCwgYXJnLCAiIik7Cn0KCnN0YXRpYyBpbmxpbmUgaW50IGVuZHNfd2l0aChjb25zdCBjaGFyICpzdHIsIGNvbnN0IGNoYXIgKnN1ZmZpeCkKewoJc2l6ZV90IGxlbjsKCXJldHVybiBzdHJpcF9zdWZmaXgoc3RyLCBzdWZmaXgsICZsZW4pOwp9CgojZW5kaWYgLyogU1RSQlVGX0ggKi8K",
    "text": "#ifndef STRBUF_H\n#define STRBUF_H\n\n/*\n * NOTE FOR STRBUF DEVELOPERS\n *\n * strbuf is a low-level primitive; as such it should interact only\n * with other low-level primitives. Do not introduce new functions\n * which interact with higher-level APIs.\n */\n\nstruct string_list;\n\n/**\n * strbufs are meant to be used with all the usual C string and memory\n * APIs. Given that the length of the buffer is known, it's often better to\n * use the mem* functions than a str* one (e.g., memchr vs. strchr).\n * Though, one has to be careful about the fact that str* functions often\n * stop on NULs and that strbufs may have embedded NULs.\n *\n * A strbuf is NUL terminated for convenience, but no function in the\n * strbuf API actually relies on the string being free of NULs.\n *\n * strbufs have some invariants that are very important to keep in mind:\n *\n *  - The `buf` member is never NULL, so it can be used in any usual C\n *    string operations safely. strbufs _have_ to be initialized either by\n *    `strbuf_init()` or by `= STRBUF_INIT` before the invariants, though.\n *\n *    Do *not* assume anything on what `buf` really is (e.g. if it is\n *    allocated memory or not), use `strbuf_detach()` to unwrap a memory\n *    buffer from its strbuf shell in a safe way. That is the sole supported\n *    way. This will give you a malloced buffer that you can later `free()`.\n *\n *    However, it is totally safe to modify anything in the string pointed by\n *    the `buf` member, between the indices `0` and `len-1` (inclusive).\n *\n *  - The `buf` member is a byte array that has at least `len + 1` bytes\n *    allocated. The extra byte is used to store a `'\\0'`, allowing the\n *    `buf` member to be a valid C-string. All strbuf functions ensure this\n *    invariant is preserved.\n *\n *    NOTE: It is OK to \"play\" with the buffer directly if you work it this\n *    way:\n *\n *        strbuf_grow(sb, SOME_SIZE); <1>\n *        strbuf_setlen(sb, sb->len + SOME_OTHER_SIZE);\n *\n *    <1> Here, the memory array starting at `sb->buf`, and of length\n *    `strbuf_avail(sb)` is all yours, and you can be sure that\n *    `strbuf_avail(sb)` is at least `SOME_SIZE`.\n *\n *    NOTE: `SOME_OTHER_SIZE` must be smaller or equal to `strbuf_avail(sb)`.\n *\n *    Doing so is safe, though if it has to be done in many places, adding the\n *    missing API to the strbuf module is the way to go.\n *\n *    WARNING: Do _not_ assume that the area that is yours is of size `alloc\n *    - 1` even if it's true in the current implementation. Alloc is somehow a\n *    \"private\" member that should not be messed with. Use `strbuf_avail()`\n *    instead.\n*/\n\n/**\n * Data Structures\n * ---------------\n */\n\n/**\n * This is the string buffer structure. The `len` member can be used to\n * determine the current length of the string, and `buf` member provides\n * access to the string itself.\n */\nstruct strbuf {\n\tsize_t alloc;\n\tsize_t len;\n\tchar *buf;\n};\n\nextern char strbuf_slopbuf[];\n#define STRBUF_INIT  { .buf = strbuf_slopbuf }\n\nstruct object_id;\n\n/**\n * Life Cycle Functions\n * --------------------\n */\n\n/**\n * Initialize the structure. The second parameter can be zero or a bigger\n * number to allocate memory, in case you want to prevent further reallocs.\n */\nvoid strbuf_init(struct strbuf *sb, size_t alloc);\n\n/**\n * Release a string buffer and the memory it used. After this call, the\n * strbuf points to an empty string that does not need to be free()ed, as\n * if it had been set to `STRBUF_INIT` and never modified.\n *\n * To clear a strbuf in preparation for further use without the overhead\n * of free()ing and malloc()ing again, use strbuf_reset() instead.\n */\nvoid strbuf_release(struct strbuf *sb);\n\n/**\n * Detach the string from the strbuf and returns it; you now own the\n * storage the string occupies and it is your responsibility from then on\n * to release it with `free(3)` when you are done with it.\n *\n * The strbuf that previously held the string is reset to `STRBUF_INIT` so\n * it can be reused after calling this function.\n */\nchar *strbuf_detach(struct strbuf *sb, size_t *sz);\n\n/**\n * Attach a string to a buffer. You should specify the string to attach,\n * the current length of the string and the amount of allocated memory.\n * The amount must be larger than the string length, because the string you\n * pass is supposed to be a NUL-terminated string.  This string _must_ be\n * malloc()ed, and after attaching, the pointer cannot be relied upon\n * anymore, and neither be free()d directly.\n */\nvoid strbuf_attach(struct strbuf *sb, void *str, size_t len, size_t mem);\n\n/**\n * Swap the contents of two string buffers.\n */\nstatic inline void strbuf_swap(struct strbuf *a, struct strbuf *b)\n{\n\tSWAP(*a, *b);\n}\n\n\n/**\n * Functions related to the size of the buffer\n * -------------------------------------------\n */\n\n/**\n * Determine the amount of allocated but unused memory.\n */\nstatic inline size_t strbuf_avail(const struct strbuf *sb)\n{\n\treturn sb->alloc ? sb->alloc - sb->len - 1 : 0;\n}\n\n/**\n * Ensure that at least this amount of unused memory is available after\n * `len`. This is used when you know a typical size for what you will add\n * and want to avoid repetitive automatic resizing of the underlying buffer.\n * This is never a needed operation, but can be critical for performance in\n * some cases.\n */\nvoid strbuf_grow(struct strbuf *sb, size_t amount);\n\n/**\n * Set the length of the buffer to a given value. This function does *not*\n * allocate new memory, so you should not perform a `strbuf_setlen()` to a\n * length that is larger than `len + strbuf_avail()`. `strbuf_setlen()` is\n * just meant as a 'please fix invariants from this strbuf I just messed\n * with'.\n */\nstatic inline void strbuf_setlen(struct strbuf *sb, size_t len)\n{\n\tif (len > (sb->alloc ? sb->alloc - 1 : 0))\n\t\tBUG(\"strbuf_setlen() beyond buffer\");\n\tsb->len = len;\n\tif (sb->buf != strbuf_slopbuf)\n\t\tsb->buf[len] = '\\0';\n\telse\n\t\tassert(!strbuf_slopbuf[0]);\n}\n\n/**\n * Empty the buffer by setting the size of it to zero.\n */\n#define strbuf_reset(sb)  strbuf_setlen(sb, 0)\n\n\n/**\n * Functions related to the contents of the buffer\n * -----------------------------------------------\n */\n\n/**\n * Strip whitespace from the beginning (`ltrim`), end (`rtrim`), or both side\n * (`trim`) of a string.\n */\nvoid strbuf_trim(struct strbuf *sb);\nvoid strbuf_rtrim(struct strbuf *sb);\nvoid strbuf_ltrim(struct strbuf *sb);\n\n/* Strip trailing directory separators */\nvoid strbuf_trim_trailing_dir_sep(struct strbuf *sb);\n\n/* Strip trailing LF or CR/LF */\nvoid strbuf_trim_trailing_newline(struct strbuf *sb);\n\n/**\n * Replace the contents of the strbuf with a reencoded form.  Returns -1\n * on error, 0 on success.\n */\nint strbuf_reencode(struct strbuf *sb, const char *from, const char *to);\n\n/**\n * Lowercase each character in the buffer using `tolower`.\n */\nvoid strbuf_tolower(struct strbuf *sb);\n\n/**\n * Compare two buffers. Returns an integer less than, equal to, or greater\n * than zero if the first buffer is found, respectively, to be less than,\n * to match, or be greater than the second buffer.\n */\nint strbuf_cmp(const struct strbuf *first, const struct strbuf *second);\n\n\n/**\n * Adding data to the buffer\n * -------------------------\n *\n * NOTE: All of the functions in this section will grow the buffer as\n * necessary.  If they fail for some reason other than memory shortage and the\n * buffer hadn't been allocated before (i.e. the `struct strbuf` was set to\n * `STRBUF_INIT`), then they will free() it.\n */\n\n/**\n * Add a single character to the buffer.\n */\nstatic inline void strbuf_addch(struct strbuf *sb, int c)\n{\n\tif (!strbuf_avail(sb))\n\t\tstrbuf_grow(sb, 1);\n\tsb->buf[sb->len++] = c;\n\tsb->buf[sb->len] = '\\0';\n}\n\n/**\n * Add a character the specified number of times to the buffer.\n */\nvoid strbuf_addchars(struct strbuf *sb, int c, size_t n);\n\n/**\n * Insert data to the given position of the buffer. The remaining contents\n * will be shifted, not overwritten.\n */\nvoid strbuf_insert(struct strbuf *sb, size_t pos, const void *, size_t);\n\n/**\n * Insert a NUL-terminated string to the given position of the buffer.\n * The remaining contents will be shifted, not overwritten.  It's an\n * inline function to allow the compiler to resolve strlen() calls on\n * constants at compile time.\n */\nstatic inline void strbuf_insertstr(struct strbuf *sb, size_t pos,\n\t\t\t\t    const char *s)\n{\n\tstrbuf_insert(sb, pos, s, strlen(s));\n}\n\n/**\n * Insert data to the given position of the buffer giving a printf format\n * string. The contents will be shifted, not overwritten.\n */\nvoid strbuf_vinsertf(struct strbuf *sb, size_t pos, const char *fmt,\n\t\t     va_list ap);\n\n__attribute__((format (printf, 3, 4)))\nvoid strbuf_insertf(struct strbuf *sb, size_t pos, const char *fmt, ...);\n\n/**\n * Remove given amount of data from a given position of the buffer.\n */\nvoid strbuf_remove(struct strbuf *sb, size_t pos, size_t len);\n\n/**\n * Remove the bytes between `pos..pos+len` and replace it with the given\n * data.\n */\nvoid strbuf_splice(struct strbuf *sb, size_t pos, size_t len,\n\t\t   const void *data, size_t data_len);\n\n/**\n * Add a NUL-terminated string to the buffer. Each line will be prepended\n * by a comment character and a blank.\n */\nvoid strbuf_add_commented_lines(struct strbuf *out,\n\t\t\t\tconst char *buf, size_t size,\n\t\t\t\tconst char *comment_prefix);\n\n\n/**\n * Add data of given length to the buffer.\n */\nvoid strbuf_add(struct strbuf *sb, const void *data, size_t len);\n\n/**\n * Add a NUL-terminated string to the buffer.\n *\n * NOTE: This function will *always* be implemented as an inline or a macro\n * using strlen, meaning that this is efficient to write things like:\n *\n *     strbuf_addstr(sb, \"immediate string\");\n *\n */\nstatic inline void strbuf_addstr(struct strbuf *sb, const char *s)\n{\n\tstrbuf_add(sb, s, strlen(s));\n}\n\n/**\n * Add a NUL-terminated string the specified number of times to the buffer.\n */\nvoid strbuf_addstrings(struct strbuf *sb, const char *s, size_t n);\n\n/**\n * Copy the contents of another buffer at the end of the current one.\n */\nvoid strbuf_addbuf(struct strbuf *sb, const struct strbuf *sb2);\n\n/**\n * Join the arguments into a buffer. `delim` is put between every\n * two arguments.\n */\nconst char *strbuf_join_argv(struct strbuf *buf, int argc,\n\t\t\t     const char **argv, char delim);\n\n/**\n * Used with `strbuf_expand_step` to expand the literals %n and %x\n * followed by two hexadecimal digits. Returns the number of recognized\n * characters.\n */\nsize_t strbuf_expand_literal(struct strbuf *sb, const char *placeholder);\n\n/**\n * If the string pointed to by `formatp` contains a percent sign (\"%\"),\n * advance it to point to the character following the next one and\n * return 1, otherwise return 0.  Append the substring before that\n * percent sign to `sb`, or the whole string if there is none.\n */\nint strbuf_expand_step(struct strbuf *sb, const char **formatp);\n\n/**\n * Used with `strbuf_expand_step` to report unknown placeholders.\n */\nvoid strbuf_expand_bad_format(const char *format, const char *command);\n\n/**\n * Append the contents of one strbuf to another, quoting any\n * percent signs (\"%\") into double-percents (\"%%\") in the\n * destination. This is useful for literal data to be fed to either\n * strbuf_expand or to the *printf family of functions.\n */\nvoid strbuf_addbuf_percentquote(struct strbuf *dst, const struct strbuf *src);\n\n#define STRBUF_ENCODE_SLASH 1\n\n/**\n * Append the contents of a string to a strbuf, percent-encoding any characters\n * that are needed to be encoded for a URL.\n *\n * If STRBUF_ENCODE_SLASH is set in flags, percent-encode slashes.  Otherwise,\n * slashes are not percent-encoded.\n */\nvoid strbuf_add_percentencode(struct strbuf *dst, const char *src, int flags);\n\n/**\n * Append the given byte size as a human-readable string (i.e. 12.23 KiB,\n * 3.50 MiB).\n */\nvoid strbuf_humanise_bytes(struct strbuf *buf, off_t bytes);\n\n/**\n * Append the given byte rate as a human-readable string (i.e. 12.23 KiB/s,\n * 3.50 MiB/s).\n */\nvoid strbuf_humanise_rate(struct strbuf *buf, off_t bytes);\n\n/**\n * Add a formatted string to the buffer.\n */\n__attribute__((format (printf,2,3)))\nvoid strbuf_addf(struct strbuf *sb, const char *fmt, ...);\n\n/**\n * Add a formatted string prepended by a comment character and a\n * blank to the buffer.\n */\n__attribute__((format (printf, 3, 4)))\nvoid strbuf_commented_addf(struct strbuf *sb, const char *comment_prefix, const char *fmt, ...);\n\n__attribute__((format (printf,2,0)))\nvoid strbuf_vaddf(struct strbuf *sb, const char *fmt, va_list ap);\n\n/**\n * Add the time specified by `tm`, as formatted by `strftime`.\n * `tz_offset` is in decimal hhmm format, e.g. -600 means six hours west\n * of Greenwich, and it's used to expand %z internally.  However, tokens\n * with modifiers (e.g. %Ez) are passed to `strftime`.\n * `suppress_tz_name`, when set, expands %Z internally to the empty\n * string rather than passing it to `strftime`.\n */\nvoid strbuf_addftime(struct strbuf *sb, const char *fmt,\n\t\t    const struct tm *tm, int tz_offset,\n\t\t    int suppress_tz_name);\n\n/**\n * Read a given size of data from a FILE* pointer to the buffer.\n *\n * NOTE: The buffer is rewound if the read fails. If -1 is returned,\n * `errno` must be consulted, like you would do for `read(3)`.\n * `strbuf_read()`, `strbuf_read_file()` and `strbuf_getline_*()`\n * family of functions have the same behaviour as well.\n */\nsize_t strbuf_fread(struct strbuf *sb, size_t size, FILE *file);\n\n/**\n * Read the contents of a given file descriptor. The third argument can be\n * used to give a hint about the file size, to avoid reallocs.  If read fails,\n * any partial read is undone.\n */\nssize_t strbuf_read(struct strbuf *sb, int fd, size_t hint);\n\n/**\n * Read the contents of a given file descriptor partially by using only one\n * attempt of xread. The third argument can be used to give a hint about the\n * file size, to avoid reallocs. Returns the number of new bytes appended to\n * the sb.\n */\nssize_t strbuf_read_once(struct strbuf *sb, int fd, size_t hint);\n\n/**\n * Read the contents of a file, specified by its path. The third argument\n * can be used to give a hint about the file size, to avoid reallocs.\n * Return the number of bytes read or a negative value if some error\n * occurred while opening or reading the file.\n */\nssize_t strbuf_read_file(struct strbuf *sb, const char *path, size_t hint);\n\n/**\n * Read the target of a symbolic link, specified by its path.  The third\n * argument can be used to give a hint about the size, to avoid reallocs.\n */\nint strbuf_readlink(struct strbuf *sb, const char *path, size_t hint);\n\n/**\n * Write the whole content of the strbuf to the stream not stopping at\n * NUL bytes.\n */\nssize_t strbuf_write(struct strbuf *sb, FILE *stream);\n\n/**\n * Read from a FILE * until the specified terminator is encountered,\n * overwriting the existing contents of the strbuf.\n *\n * Reading stops after the terminator or at EOF.  The terminator is\n * removed from the buffer before returning.  If the terminator is LF\n * and if it is preceded by a CR, then the whole CRLF is stripped.\n * Returns 0 unless there was nothing left before EOF, in which case\n * it returns `EOF`.\n */\nint strbuf_getdelim_strip_crlf(struct strbuf *sb, FILE *fp, int term);\n\n/**\n * Read a line from a FILE *, overwriting the existing contents of\n * the strbuf.  The strbuf_getline*() family of functions share\n * this signature, but have different line termination conventions.\n *\n * Reading stops after the terminator or at EOF.  The terminator\n * is removed from the buffer before returning.  Returns 0 unless\n * there was nothing left before EOF, in which case it returns `EOF`.\n */\ntypedef int (*strbuf_getline_fn)(struct strbuf *, FILE *);\n\n/* Uses LF as the line terminator */\nint strbuf_getline_lf(struct strbuf *sb, FILE *fp);\n\n/* Uses NUL as the line terminator */\nint strbuf_getline_nul(struct strbuf *sb, FILE *fp);\n\n/*\n * Similar to strbuf_getline_lf(), but additionally treats a CR that\n * comes immediately before the LF as part of the terminator.\n * This is the most friendly version to be used to read \"text\" files\n * that can come from platforms whose native text format is CRLF\n * terminated.\n */\nint strbuf_getline(struct strbuf *sb, FILE *file);\n\n\n/**\n * Like `strbuf_getline`, but keeps the trailing terminator (if\n * any) in the buffer.\n */\nint strbuf_getwholeline(struct strbuf *sb, FILE *file, int term);\n\n/**\n * Like `strbuf_getwholeline`, but appends the line instead of\n * resetting the buffer first.\n */\nint strbuf_appendwholeline(struct strbuf *sb, FILE *file, int term);\n\n/**\n * Like `strbuf_getwholeline`, but operates on a file descriptor.\n * It reads one character at a time, so it is very slow.  Do not\n * use it unless you need the correct position in the file\n * descriptor.\n */\nint strbuf_getwholeline_fd(struct strbuf *sb, int fd, int term);\n\n/**\n * Set the buffer to the path of the current working directory.\n */\nint strbuf_getcwd(struct strbuf *sb);\n\n/**\n * Normalize in-place the path contained in the strbuf. See\n * normalize_path_copy() for details. If an error occurs, the contents of \"sb\"\n * are left untouched, and -1 is returned.\n */\nint strbuf_normalize_path(struct strbuf *sb);\n\n/**\n * Strip whitespace from a buffer. If comment_prefix is non-NULL,\n * then lines beginning with that character are considered comments,\n * thus removed.\n */\nvoid strbuf_stripspace(struct strbuf *buf, const char *comment_prefix);\n\nstatic inline int strbuf_strip_suffix(struct strbuf *sb, const char *suffix)\n{\n\tif (strip_suffix_mem(sb->buf, &sb->len, suffix)) {\n\t\tstrbuf_setlen(sb, sb->len);\n\t\treturn 1;\n\t} else\n\t\treturn 0;\n}\n\n/**\n * Split str (of length slen) at the specified terminator character.\n * Return a null-terminated array of pointers to strbuf objects\n * holding the substrings.  The substrings include the terminator,\n * except for the last substring, which might be unterminated if the\n * original string did not end with a terminator.  If max is positive,\n * then split the string into at most max substrings (with the last\n * substring containing everything following the (max-1)th terminator\n * character).\n *\n * The most generic form is `strbuf_split_buf`, which takes an arbitrary\n * pointer/len buffer. The `_str` variant takes a NUL-terminated string,\n * the `_max` variant takes a strbuf, and just `strbuf_split` is a convenience\n * wrapper to drop the `max` parameter.\n *\n * For lighter-weight alternatives, see string_list_split() and\n * string_list_split_in_place().\n */\nstruct strbuf **strbuf_split_buf(const char *str, size_t len,\n\t\t\t\t int terminator, int max);\n\nstatic inline struct strbuf **strbuf_split_str(const char *str,\n\t\t\t\t\t       int terminator, int max)\n{\n\treturn strbuf_split_buf(str, strlen(str), terminator, max);\n}\n\nstatic inline struct strbuf **strbuf_split_max(const struct strbuf *sb,\n\t\t\t\t\t       int terminator, int max)\n{\n\treturn strbuf_split_buf(sb->buf, sb->len, terminator, max);\n}\n\nstatic inline struct strbuf **strbuf_split(const struct strbuf *sb,\n\t\t\t\t\t   int terminator)\n{\n\treturn strbuf_split_max(sb, terminator, 0);\n}\n\n/*\n * Adds all strings of a string list to the strbuf, separated by the given\n * separator.  For example, if sep is\n *   ', '\n * and slist contains\n *   ['element1', 'element2', ..., 'elementN'],\n * then write:\n *   'element1, element2, ..., elementN'\n * to str.  If only one element, just write \"element1\" to str.\n */\nvoid strbuf_add_separated_string_list(struct strbuf *str,\n\t\t\t\t      const char *sep,\n\t\t\t\t      struct string_list *slist);\n\n/**\n * Free a NULL-terminated list of strbufs (for example, the return\n * values of the strbuf_split*() functions).\n */\nvoid strbuf_list_free(struct strbuf **list);\n\n/*\n * Remove the filename from the provided path string. If the path\n * contains a trailing separator, then the path is considered a directory\n * and nothing is modified.\n *\n * Examples:\n * - \"/path/to/file\" -> \"/path/to/\"\n * - \"/path/to/dir/\" -> \"/path/to/dir/\"\n */\nvoid strbuf_strip_file_from_path(struct strbuf *sb);\n\nvoid strbuf_add_lines(struct strbuf *sb,\n\t\t      const char *prefix,\n\t\t      const char *buf,\n\t\t      size_t size);\n\n/**\n * Append s to sb, with the characters '<', '>', '&' and '\"' converted\n * into XML entities.\n */\nvoid strbuf_addstr_xml_quoted(struct strbuf *sb,\n\t\t\t      const char *s);\n\n/**\n * \"Complete\" the contents of `sb` by ensuring that either it ends with the\n * character `term`, or it is empty.  This can be used, for example,\n * to ensure that text ends with a newline, but without creating an empty\n * blank line if there is no content in the first place.\n */\nstatic inline void strbuf_complete(struct strbuf *sb, char term)\n{\n\tif (sb->len && sb->buf[sb->len - 1] != term)\n\t\tstrbuf_addch(sb, term);\n}\n\nstatic inline void strbuf_complete_line(struct strbuf *sb)\n{\n\tstrbuf_complete(sb, '\\n');\n}\n\n/*\n * Copy \"name\" to \"sb\", expanding any special @-marks as handled by\n * repo_interpret_branch_name(). The result is a non-qualified branch name\n * (so \"foo\" or \"origin/master\" instead of \"refs/heads/foo\" or\n * \"refs/remotes/origin/master\").\n *\n * Note that the resulting name may not be a syntactically valid refname.\n *\n * If \"allowed\" is non-zero, restrict the set of allowed expansions. See\n * repo_interpret_branch_name() for details.\n */\nvoid strbuf_branchname(struct strbuf *sb, const char *name,\n\t\t       unsigned allowed);\n\n/*\n * Like strbuf_branchname() above, but confirm that the result is\n * syntactically valid to be used as a local branch name in refs/heads/.\n *\n * The return value is \"0\" if the result is valid, and \"-1\" otherwise.\n */\nint strbuf_check_branch_ref(struct strbuf *sb, const char *name);\n\ntypedef int (*char_predicate)(char ch);\n\nvoid strbuf_addstr_urlencode(struct strbuf *sb, const char *name,\n\t\t\t     char_predicate allow_unencoded_fn);\n\n__attribute__((format (printf,1,2)))\nint printf_ln(const char *fmt, ...);\n__attribute__((format (printf,2,3)))\nint fprintf_ln(FILE *fp, const char *fmt, ...);\n\nchar *xstrdup_tolower(const char *);\nchar *xstrdup_toupper(const char *);\n\n/**\n * Create a newly allocated string using printf format. You can do this easily\n * with a strbuf, but this provides a shortcut to save a few lines.\n */\n__attribute__((format (printf, 1, 0)))\nchar *xstrvfmt(const char *fmt, va_list ap);\n__attribute__((format (printf, 1, 2)))\nchar *xstrfmt(const char *fmt, ...);\n\nint starts_with(const char *str, const char *prefix);\nint istarts_with(const char *str, const char *prefix);\nint starts_with_mem(const char *str, size_t len, const char *prefix);\n\n/*\n * If the string \"str\" is the same as the string in \"prefix\", then the \"arg\"\n * parameter is set to the \"def\" parameter and 1 is returned.\n * If the string \"str\" begins with the string found in \"prefix\" and then a\n * \"=\" sign, then the \"arg\" parameter is set to \"str + strlen(prefix) + 1\"\n * (i.e., to the point in the string right after the prefix and the \"=\" sign),\n * and 1 is returned.\n *\n * Otherwise, return 0 and leave \"arg\" untouched.\n *\n * When we accept both a \"--key\" and a \"--key=<val>\" option, this function\n * can be used instead of !strcmp(arg, \"--key\") and then\n * skip_prefix(arg, \"--key=\", &arg) to parse such an option.\n */\nint skip_to_optional_arg_default(const char *str, const char *prefix,\n\t\t\t\t const char **arg, const char *def);\n\nstatic inline int skip_to_optional_arg(const char *str, const char *prefix,\n\t\t\t\t       const char **arg)\n{\n\treturn skip_to_optional_arg_default(str, prefix, arg, \"\");\n}\n\nstatic inline int ends_with(const char *str, const char *suffix)\n{\n\tsize_t len;\n\treturn strip_suffix(str, suffix, &len);\n}\n\n#endif /* STRBUF_H */\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "003f880ff7d61cf9a65ac2cec09ba8cd8091e82d",
  "sha1_ok": true,
  "size": 23553
}
