{
  "content": {
    "base64": "LyoKICogImdpdCBkaWZmdG9vbCIgYnVpbHRpbiBjb21tYW5kCiAqCiAqIFRoaXMgaXMgYSB3cmFwcGVyIGFyb3VuZCB0aGUgR0lUX0VYVEVSTkFMX0RJRkYtY29tcGF0aWJsZQogKiBnaXQtZGlmZnRvb2wtLWhlbHBlciBzY3JpcHQuCiAqCiAqIFRoaXMgc2NyaXB0IGV4cG9ydHMgR0lUX0VYVEVSTkFMX0RJRkYgYW5kIEdJVF9QQUdFUiBmb3IgdXNlIGJ5IGdpdC4KICogVGhlIEdJVF9ESUZGKiB2YXJpYWJsZXMgYXJlIGV4cG9ydGVkIGZvciB1c2UgYnkgZ2l0LWRpZmZ0b29sLS1oZWxwZXIuCiAqCiAqIEFueSBhcmd1bWVudHMgdGhhdCBhcmUgdW5rbm93biB0byB0aGlzIHNjcmlwdCBhcmUgZm9yd2FyZGVkIHRvICdnaXQgZGlmZicuCiAqCiAqIENvcHlyaWdodCAoQykgMjAxNiBKb2hhbm5lcyBTY2hpbmRlbGluCiAqLwojZGVmaW5lIFVTRV9USEVfSU5ERVhfVkFSSUFCTEUKI2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJhYnNwYXRoLmgiCiNpbmNsdWRlICJjb25maWcuaCIKI2luY2x1ZGUgImNvcHkuaCIKI2luY2x1ZGUgImJ1aWx0aW4uaCIKI2luY2x1ZGUgInJ1bi1jb21tYW5kLmgiCiNpbmNsdWRlICJlbnZpcm9ubWVudC5oIgojaW5jbHVkZSAiZXhlYy1jbWQuaCIKI2luY2x1ZGUgImdldHRleHQuaCIKI2luY2x1ZGUgImhleC5oIgojaW5jbHVkZSAicGFyc2Utb3B0aW9ucy5oIgojaW5jbHVkZSAic3RydmVjLmgiCiNpbmNsdWRlICJzdHJidWYuaCIKI2luY2x1ZGUgImxvY2tmaWxlLmgiCiNpbmNsdWRlICJvYmplY3QtZmlsZS5oIgojaW5jbHVkZSAib2JqZWN0LXN0b3JlLmgiCiNpbmNsdWRlICJkaXIuaCIKI2luY2x1ZGUgImVudHJ5LmgiCiNpbmNsdWRlICJzZXR1cC5oIgojaW5jbHVkZSAid3JhcHBlci5oIgoKc3RhdGljIGludCB0cnVzdF9leGl0X2NvZGU7CgpzdGF0aWMgY29uc3QgY2hhciAqY29uc3QgYnVpbHRpbl9kaWZmdG9vbF91c2FnZVtdID0gewoJTl8oImdpdCBkaWZmdG9vbCBbPG9wdGlvbnM+XSBbPGNvbW1pdD4gWzxjb21taXQ+XV0gWy0tXSBbPHBhdGg+Li4uXSIpLAoJTlVMTAp9OwoKc3RhdGljIGludCBkaWZmdG9vbF9jb25maWcoY29uc3QgY2hhciAqdmFyLCBjb25zdCBjaGFyICp2YWx1ZSwgdm9pZCAqY2IpCnsKCWlmICghc3RyY21wKHZhciwgImRpZmZ0b29sLnRydXN0ZXhpdGNvZGUiKSkgewoJCXRydXN0X2V4aXRfY29kZSA9IGdpdF9jb25maWdfYm9vbCh2YXIsIHZhbHVlKTsKCQlyZXR1cm4gMDsKCX0KCglyZXR1cm4gZ2l0X2RlZmF1bHRfY29uZmlnKHZhciwgdmFsdWUsIGNiKTsKfQoKc3RhdGljIGludCBwcmludF90b29sX2hlbHAodm9pZCkKewoJc3RydWN0IGNoaWxkX3Byb2Nlc3MgY21kID0gQ0hJTERfUFJPQ0VTU19JTklUOwoKCWNtZC5naXRfY21kID0gMTsKCXN0cnZlY19wdXNobCgmY21kLmFyZ3MsICJtZXJnZXRvb2wiLCAiLS10b29sLWhlbHA9ZGlmZiIsIE5VTEwpOwoJcmV0dXJuIHJ1bl9jb21tYW5kKCZjbWQpOwp9CgpzdGF0aWMgaW50IHBhcnNlX2luZGV4X2luZm8oY2hhciAqcCwgaW50ICptb2RlMSwgaW50ICptb2RlMiwKCQkJICAgIHN0cnVjdCBvYmplY3RfaWQgKm9pZDEsIHN0cnVjdCBvYmplY3RfaWQgKm9pZDIsCgkJCSAgICBjaGFyICpzdGF0dXMpCnsKCWlmICgqcCAhPSAnOicpCgkJcmV0dXJuIGVycm9yKCJleHBlY3RlZCAnOicsIGdvdCAnJWMnIiwgKnApOwoJKm1vZGUxID0gKGludClzdHJ0b2wocCArIDEsICZwLCA4KTsKCWlmICgqcCAhPSAnICcpCgkJcmV0dXJuIGVycm9yKCJleHBlY3RlZCAnICcsIGdvdCAnJWMnIiwgKnApOwoJKm1vZGUyID0gKGludClzdHJ0b2wocCArIDEsICZwLCA4KTsKCWlmICgqcCAhPSAnICcpCgkJcmV0dXJuIGVycm9yKCJleHBlY3RlZCAnICcsIGdvdCAnJWMnIiwgKnApOwoJaWYgKHBhcnNlX29pZF9oZXgoKytwLCBvaWQxLCAoY29uc3QgY2hhciAqKikmcCkpCgkJcmV0dXJuIGVycm9yKCJleHBlY3RlZCBvYmplY3QgSUQsIGdvdCAnJXMnIiwgcCk7CglpZiAoKnAgIT0gJyAnKQoJCXJldHVybiBlcnJvcigiZXhwZWN0ZWQgJyAnLCBnb3QgJyVjJyIsICpwKTsKCWlmIChwYXJzZV9vaWRfaGV4KCsrcCwgb2lkMiwgKGNvbnN0IGNoYXIgKiopJnApKQoJCXJldHVybiBlcnJvcigiZXhwZWN0ZWQgb2JqZWN0IElELCBnb3QgJyVzJyIsIHApOwoJaWYgKCpwICE9ICcgJykKCQlyZXR1cm4gZXJyb3IoImV4cGVjdGVkICcgJywgZ290ICclYyciLCAqcCk7Cgkqc3RhdHVzID0gKisrcDsKCWlmICghKnN0YXR1cykKCQlyZXR1cm4gZXJyb3IoIm1pc3Npbmcgc3RhdHVzIik7CglpZiAocFsxXSAmJiAhaXNkaWdpdChwWzFdKSkKCQlyZXR1cm4gZXJyb3IoInVuZXhwZWN0ZWQgdHJhaWxlcjogJyVzJyIsIHAgKyAxKTsKCXJldHVybiAwOwp9CgovKgogKiBSZW1vdmUgYW55IHRyYWlsaW5nIHNsYXNoIGZyb20gJHdvcmtkaXIKICogYmVmb3JlIHN0YXJ0aW5nIHRvIGF2b2lkIGRvdWJsZSBzbGFzaGVzIGluIHN5bWxpbmsgdGFyZ2V0cy4KICovCnN0YXRpYyB2b2lkIGFkZF9wYXRoKHN0cnVjdCBzdHJidWYgKmJ1Ziwgc2l6ZV90IGJhc2VfbGVuLCBjb25zdCBjaGFyICpwYXRoKQp7CglzdHJidWZfc2V0bGVuKGJ1ZiwgYmFzZV9sZW4pOwoJaWYgKGJ1Zi0+bGVuICYmIGJ1Zi0+YnVmW2J1Zi0+bGVuIC0gMV0gIT0gJy8nKQoJCXN0cmJ1Zl9hZGRjaChidWYsICcvJyk7CglzdHJidWZfYWRkc3RyKGJ1ZiwgcGF0aCk7Cn0KCi8qCiAqIERldGVybWluZSB3aGV0aGVyIHdlIGNhbiBzaW1wbHkgcmV1c2UgdGhlIGZpbGUgaW4gdGhlIHdvcmt0cmVlLgogKi8Kc3RhdGljIGludCB1c2Vfd3RfZmlsZShjb25zdCBjaGFyICp3b3JrZGlyLCBjb25zdCBjaGFyICpuYW1lLAoJCSAgICAgICBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQpCnsKCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3Qgc3RhdCBzdDsKCWludCB1c2UgPSAwOwoKCXN0cmJ1Zl9hZGRzdHIoJmJ1Ziwgd29ya2Rpcik7CglhZGRfcGF0aCgmYnVmLCBidWYubGVuLCBuYW1lKTsKCglpZiAoIWxzdGF0KGJ1Zi5idWYsICZzdCkgJiYgIVNfSVNMTksoc3Quc3RfbW9kZSkpIHsKCQlzdHJ1Y3Qgb2JqZWN0X2lkIHd0X29pZDsKCQlpbnQgZmQgPSBvcGVuKGJ1Zi5idWYsIE9fUkRPTkxZKTsKCgkJaWYgKGZkID49IDAgJiYKCQkgICAgIWluZGV4X2ZkKCZ0aGVfaW5kZXgsICZ3dF9vaWQsIGZkLCAmc3QsIE9CSl9CTE9CLCBuYW1lLCAwKSkgewoJCQlpZiAoaXNfbnVsbF9vaWQob2lkKSkgewoJCQkJb2lkY3B5KG9pZCwgJnd0X29pZCk7CgkJCQl1c2UgPSAxOwoJCQl9IGVsc2UgaWYgKG9pZGVxKG9pZCwgJnd0X29pZCkpCgkJCQl1c2UgPSAxOwoJCX0KCX0KCglzdHJidWZfcmVsZWFzZSgmYnVmKTsKCglyZXR1cm4gdXNlOwp9CgpzdHJ1Y3Qgd29ya2luZ190cmVlX2VudHJ5IHsKCXN0cnVjdCBoYXNobWFwX2VudHJ5IGVudHJ5OwoJY2hhciBwYXRoW0ZMRVhfQVJSQVldOwp9OwoKc3RhdGljIGludCB3b3JraW5nX3RyZWVfZW50cnlfY21wKGNvbnN0IHZvaWQgKmNtcF9kYXRhIFVOVVNFRCwKCQkJCSAgY29uc3Qgc3RydWN0IGhhc2htYXBfZW50cnkgKmVwdHIsCgkJCQkgIGNvbnN0IHN0cnVjdCBoYXNobWFwX2VudHJ5ICplbnRyeV9vcl9rZXksCgkJCQkgIGNvbnN0IHZvaWQgKmtleWRhdGEgVU5VU0VEKQp7Cgljb25zdCBzdHJ1Y3Qgd29ya2luZ190cmVlX2VudHJ5ICphLCAqYjsKCglhID0gY29udGFpbmVyX29mKGVwdHIsIGNvbnN0IHN0cnVjdCB3b3JraW5nX3RyZWVfZW50cnksIGVudHJ5KTsKCWIgPSBjb250YWluZXJfb2YoZW50cnlfb3Jfa2V5LCBjb25zdCBzdHJ1Y3Qgd29ya2luZ190cmVlX2VudHJ5LCBlbnRyeSk7CgoJcmV0dXJuIHN0cmNtcChhLT5wYXRoLCBiLT5wYXRoKTsKfQoKLyoKICogVGhlIGBsZWZ0YCBhbmQgYHJpZ2h0YCBlbnRyaWVzIGhvbGQgcGF0aHMgZm9yIHRoZSBzeW1saW5rcyBoYXNobWFwLAogKiBhbmQgYSBTSEEtMSBzdXJyb3VuZGVkIGJ5IGJyaWVmIHRleHQgZm9yIHN1Ym1vZHVsZXMuCiAqLwpzdHJ1Y3QgcGFpcl9lbnRyeSB7CglzdHJ1Y3QgaGFzaG1hcF9lbnRyeSBlbnRyeTsKCWNoYXIgbGVmdFtQQVRIX01BWF0sIHJpZ2h0W1BBVEhfTUFYXTsKCWNvbnN0IGNoYXIgcGF0aFtGTEVYX0FSUkFZXTsKfTsKCnN0YXRpYyBpbnQgcGFpcl9jbXAoY29uc3Qgdm9pZCAqY21wX2RhdGEgVU5VU0VELAoJCSAgICBjb25zdCBzdHJ1Y3QgaGFzaG1hcF9lbnRyeSAqZXB0ciwKCQkgICAgY29uc3Qgc3RydWN0IGhhc2htYXBfZW50cnkgKmVudHJ5X29yX2tleSwKCQkgICAgY29uc3Qgdm9pZCAqa2V5ZGF0YSBVTlVTRUQpCnsKCWNvbnN0IHN0cnVjdCBwYWlyX2VudHJ5ICphLCAqYjsKCglhID0gY29udGFpbmVyX29mKGVwdHIsIGNvbnN0IHN0cnVjdCBwYWlyX2VudHJ5LCBlbnRyeSk7CgliID0gY29udGFpbmVyX29mKGVudHJ5X29yX2tleSwgY29uc3Qgc3RydWN0IHBhaXJfZW50cnksIGVudHJ5KTsKCglyZXR1cm4gc3RyY21wKGEtPnBhdGgsIGItPnBhdGgpOwp9CgpzdGF0aWMgdm9pZCBhZGRfbGVmdF9vcl9yaWdodChzdHJ1Y3QgaGFzaG1hcCAqbWFwLCBjb25zdCBjaGFyICpwYXRoLAoJCQkgICAgICBjb25zdCBjaGFyICpjb250ZW50LCBpbnQgaXNfcmlnaHQpCnsKCXN0cnVjdCBwYWlyX2VudHJ5ICplLCAqZXhpc3Rpbmc7CgoJRkxFWF9BTExPQ19TVFIoZSwgcGF0aCwgcGF0aCk7CgloYXNobWFwX2VudHJ5X2luaXQoJmUtPmVudHJ5LCBzdHJoYXNoKHBhdGgpKTsKCWV4aXN0aW5nID0gaGFzaG1hcF9nZXRfZW50cnkobWFwLCBlLCBlbnRyeSwgTlVMTCk7CglpZiAoZXhpc3RpbmcpIHsKCQlmcmVlKGUpOwoJCWUgPSBleGlzdGluZzsKCX0gZWxzZSB7CgkJZS0+bGVmdFswXSA9IGUtPnJpZ2h0WzBdID0gJ1wwJzsKCQloYXNobWFwX2FkZChtYXAsICZlLT5lbnRyeSk7Cgl9CglzdHJsY3B5KGlzX3JpZ2h0ID8gZS0+cmlnaHQgOiBlLT5sZWZ0LCBjb250ZW50LCBQQVRIX01BWCk7Cn0KCnN0cnVjdCBwYXRoX2VudHJ5IHsKCXN0cnVjdCBoYXNobWFwX2VudHJ5IGVudHJ5OwoJY2hhciBwYXRoW0ZMRVhfQVJSQVldOwp9OwoKc3RhdGljIGludCBwYXRoX2VudHJ5X2NtcChjb25zdCB2b2lkICpjbXBfZGF0YSBVTlVTRUQsCgkJCSAgY29uc3Qgc3RydWN0IGhhc2htYXBfZW50cnkgKmVwdHIsCgkJCSAgY29uc3Qgc3RydWN0IGhhc2htYXBfZW50cnkgKmVudHJ5X29yX2tleSwKCQkJICBjb25zdCB2b2lkICprZXkpCnsKCWNvbnN0IHN0cnVjdCBwYXRoX2VudHJ5ICphLCAqYjsKCglhID0gY29udGFpbmVyX29mKGVwdHIsIGNvbnN0IHN0cnVjdCBwYXRoX2VudHJ5LCBlbnRyeSk7CgliID0gY29udGFpbmVyX29mKGVudHJ5X29yX2tleSwgY29uc3Qgc3RydWN0IHBhdGhfZW50cnksIGVudHJ5KTsKCglyZXR1cm4gc3RyY21wKGEtPnBhdGgsIGtleSA/IGtleSA6IGItPnBhdGgpOwp9CgpzdGF0aWMgdm9pZCBjaGFuZ2VkX2ZpbGVzKHN0cnVjdCBoYXNobWFwICpyZXN1bHQsIGNvbnN0IGNoYXIgKmluZGV4X3BhdGgsCgkJCSAgY29uc3QgY2hhciAqd29ya2RpcikKewoJc3RydWN0IGNoaWxkX3Byb2Nlc3MgdXBkYXRlX2luZGV4ID0gQ0hJTERfUFJPQ0VTU19JTklUOwoJc3RydWN0IGNoaWxkX3Byb2Nlc3MgZGlmZl9maWxlcyA9IENISUxEX1BST0NFU1NfSU5JVDsKCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7Cgljb25zdCBjaGFyICpnaXRfZGlyID0gYWJzb2x1dGVfcGF0aChnZXRfZ2l0X2RpcigpKTsKCUZJTEUgKmZwOwoKCXN0cnZlY19wdXNobCgmdXBkYXRlX2luZGV4LmFyZ3MsCgkJICAgICAiLS1naXQtZGlyIiwgZ2l0X2RpciwgIi0td29yay10cmVlIiwgd29ya2RpciwKCQkgICAgICJ1cGRhdGUtaW5kZXgiLCAiLS1yZWFsbHktcmVmcmVzaCIsICItcSIsCgkJICAgICAiLS11bm1lcmdlZCIsIE5VTEwpOwoJdXBkYXRlX2luZGV4Lm5vX3N0ZGluID0gMTsKCXVwZGF0ZV9pbmRleC5ub19zdGRvdXQgPSAxOwoJdXBkYXRlX2luZGV4Lm5vX3N0ZGVyciA9IDE7Cgl1cGRhdGVfaW5kZXguZ2l0X2NtZCA9IDE7Cgl1cGRhdGVfaW5kZXgudXNlX3NoZWxsID0gMDsKCXVwZGF0ZV9pbmRleC5jbGVhbl9vbl9leGl0ID0gMTsKCXVwZGF0ZV9pbmRleC5kaXIgPSB3b3JrZGlyOwoJc3RydmVjX3B1c2hmKCZ1cGRhdGVfaW5kZXguZW52LCAiR0lUX0lOREVYX0ZJTEU9JXMiLCBpbmRleF9wYXRoKTsKCS8qIElnbm9yZSBhbnkgZXJyb3JzIG9mIHVwZGF0ZS1pbmRleCAqLwoJcnVuX2NvbW1hbmQoJnVwZGF0ZV9pbmRleCk7CgoJc3RydmVjX3B1c2hsKCZkaWZmX2ZpbGVzLmFyZ3MsCgkJICAgICAiLS1naXQtZGlyIiwgZ2l0X2RpciwgIi0td29yay10cmVlIiwgd29ya2RpciwKCQkgICAgICJkaWZmLWZpbGVzIiwgIi0tbmFtZS1vbmx5IiwgIi16IiwgTlVMTCk7CglkaWZmX2ZpbGVzLm5vX3N0ZGluID0gMTsKCWRpZmZfZmlsZXMuZ2l0X2NtZCA9IDE7CglkaWZmX2ZpbGVzLnVzZV9zaGVsbCA9IDA7CglkaWZmX2ZpbGVzLmNsZWFuX29uX2V4aXQgPSAxOwoJZGlmZl9maWxlcy5vdXQgPSAtMTsKCWRpZmZfZmlsZXMuZGlyID0gd29ya2RpcjsKCXN0cnZlY19wdXNoZigmZGlmZl9maWxlcy5lbnYsICJHSVRfSU5ERVhfRklMRT0lcyIsIGluZGV4X3BhdGgpOwoJaWYgKHN0YXJ0X2NvbW1hbmQoJmRpZmZfZmlsZXMpKQoJCWRpZSgiY291bGQgbm90IG9idGFpbiByYXcgZGlmZiIpOwoJZnAgPSB4ZmRvcGVuKGRpZmZfZmlsZXMub3V0LCAiciIpOwoJd2hpbGUgKCFzdHJidWZfZ2V0bGluZV9udWwoJmJ1ZiwgZnApKSB7CgkJc3RydWN0IHBhdGhfZW50cnkgKmVudHJ5OwoJCUZMRVhfQUxMT0NfU1RSKGVudHJ5LCBwYXRoLCBidWYuYnVmKTsKCQloYXNobWFwX2VudHJ5X2luaXQoJmVudHJ5LT5lbnRyeSwgc3RyaGFzaChidWYuYnVmKSk7CgkJaGFzaG1hcF9hZGQocmVzdWx0LCAmZW50cnktPmVudHJ5KTsKCX0KCWZjbG9zZShmcCk7CglpZiAoZmluaXNoX2NvbW1hbmQoJmRpZmZfZmlsZXMpKQoJCWRpZSgiZGlmZi1maWxlcyBkaWQgbm90IGV4aXQgcHJvcGVybHkiKTsKCXN0cmJ1Zl9yZWxlYXNlKCZidWYpOwp9CgpzdGF0aWMgaW50IGVuc3VyZV9sZWFkaW5nX2RpcmVjdG9yaWVzKGNoYXIgKnBhdGgpCnsKCXN3aXRjaCAoc2FmZV9jcmVhdGVfbGVhZGluZ19kaXJlY3RvcmllcyhwYXRoKSkgewoJCWNhc2UgU0NMRF9PSzoKCQljYXNlIFNDTERfRVhJU1RTOgoJCQlyZXR1cm4gMDsKCQlkZWZhdWx0OgoJCQlyZXR1cm4gZXJyb3IoXygiY291bGQgbm90IGNyZWF0ZSBsZWFkaW5nIGRpcmVjdG9yaWVzICIKCQkJCSAgICAgICAib2YgJyVzJyIpLCBwYXRoKTsKCX0KfQoKLyoKICogVW5jb25kaXRpb25hbCB3cml0aW5nIG9mIGEgcGxhaW4gcmVndWxhciBmaWxlIGlzIHdoYXQKICogImdpdCBkaWZmdG9vbCAtLWRpci1kaWZmIiB3YW50cyB0byBkbyBmb3Igc3ltbGlua3MuICBXZSBhcmUgcHJlcGFyaW5nIHR3bwogKiB0ZW1wb3JhcnkgZGlyZWN0b3JpZXMgdG8gYmUgZmVkIHRvIGEgR2l0LXVuYXdhcmUgdG9vbCB0aGF0IGtub3dzIGhvdyB0bwogKiBzaG93IGEgZGlmZiBvZiB0d28gZGlyZWN0b3JpZXMgKGUuZy4gImRpZmYgLXIgQSBCIikuCiAqCiAqIEJlY2F1c2UgdGhlIHRvb2wgaXMgR2l0LXVuYXdhcmUsIGlmIGEgc3ltYm9saWMgbGluayBhcHBlYXJzIGluIGVpdGhlciBvZgogKiB0aGVzZSB0ZW1wb3JhcnkgZGlyZWN0b3JpZXMsIGl0IHdpbGwgdHJ5IHRvIGRlcmVmZXJlbmNlIGFuZCBzaG93IHRoZQogKiBkaWZmZXJlbmNlIG9mIHRoZSB0YXJnZXQgb2YgdGhlIHN5bWJvbGljIGxpbmssIHdoaWNoIGlzIG5vdCB3aGF0IHdlIHdhbnQsCiAqIGFzIHRoZSBnb2FsIG9mIHRoZSBkaXItZGlmZiBtb2RlIGlzIHRvIHByb2R1Y2UgYW4gb3V0cHV0IHRoYXQgaXMgbG9naWNhbGx5CiAqIGVxdWl2YWxlbnQgdG8gd2hhdCAiZ2l0IGRpZmYiIHByb2R1Y2VzLgogKgogKiBNb3N0IGltcG9ydGFudGx5LCB3ZSB3YW50IHRvIGdldCB0ZXh0dWFsIGNvbXBhcmlzb24gb2YgdGhlIHJlc3VsdCBvZiB0aGUKICogcmVhZGxpbmsoMikuICBnZXRfc3ltbGluaygpIHByb3ZpZGVzIHRoYXQtLS1pdCByZXR1cm5zIHRoZSBjb250ZW50cyBvZgogKiB0aGUgc3ltbGluayB0aGF0IGdldHMgd3JpdHRlbiB0byBhIHJlZ3VsYXIgZmlsZSB0byBmb3JjZSB0aGUgZXh0ZXJuYWwgdG9vbAogKiB0byBjb21wYXJlIHRoZSByZWFkbGluaygyKSByZXN1bHQgYXMgdGV4dCwgZXZlbiBvbiBhIGZpbGVzeXN0ZW0gdGhhdCBpcwogKiBjYXBhYmxlIG9mIGRvaW5nIGEgc3ltYm9saWMgbGluay4KICovCnN0YXRpYyBjaGFyICpnZXRfc3ltbGluayhjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsIGNvbnN0IGNoYXIgKnBhdGgpCnsKCWNoYXIgKmRhdGE7CglpZiAoaXNfbnVsbF9vaWQob2lkKSkgewoJCS8qIFRoZSBzeW1saW5rIGlzIHVua25vd24gdG8gR2l0IHNvIHJlYWQgZnJvbSB0aGUgZmlsZXN5c3RlbSAqLwoJCXN0cnVjdCBzdHJidWYgbGluayA9IFNUUkJVRl9JTklUOwoJCWlmIChoYXNfc3ltbGlua3MpIHsKCQkJaWYgKHN0cmJ1Zl9yZWFkbGluaygmbGluaywgcGF0aCwgc3RybGVuKHBhdGgpKSkKCQkJCWRpZShfKCJjb3VsZCBub3QgcmVhZCBzeW1saW5rICVzIiksIHBhdGgpOwoJCX0gZWxzZSBpZiAoc3RyYnVmX3JlYWRfZmlsZSgmbGluaywgcGF0aCwgMTI4KSkKCQkJZGllKF8oImNvdWxkIG5vdCByZWFkIHN5bWxpbmsgZmlsZSAlcyIpLCBwYXRoKTsKCgkJZGF0YSA9IHN0cmJ1Zl9kZXRhY2goJmxpbmssIE5VTEwpOwoJfSBlbHNlIHsKCQllbnVtIG9iamVjdF90eXBlIHR5cGU7CgkJdW5zaWduZWQgbG9uZyBzaXplOwoJCWRhdGEgPSByZXBvX3JlYWRfb2JqZWN0X2ZpbGUodGhlX3JlcG9zaXRvcnksIG9pZCwgJnR5cGUsCgkJCQkJICAgICAmc2l6ZSk7CgkJaWYgKCFkYXRhKQoJCQlkaWUoXygiY291bGQgbm90IHJlYWQgb2JqZWN0ICVzIGZvciBzeW1saW5rICVzIiksCgkJCQlvaWRfdG9faGV4KG9pZCksIHBhdGgpOwoJfQoKCXJldHVybiBkYXRhOwp9CgpzdGF0aWMgaW50IGNoZWNrb3V0X3BhdGgodW5zaWduZWQgbW9kZSwgc3RydWN0IG9iamVjdF9pZCAqb2lkLAoJCQkgY29uc3QgY2hhciAqcGF0aCwgY29uc3Qgc3RydWN0IGNoZWNrb3V0ICpzdGF0ZSkKewoJc3RydWN0IGNhY2hlX2VudHJ5ICpjZTsKCWludCByZXQ7CgoJY2UgPSBtYWtlX3RyYW5zaWVudF9jYWNoZV9lbnRyeShtb2RlLCBvaWQsIHBhdGgsIDAsIE5VTEwpOwoJcmV0ID0gY2hlY2tvdXRfZW50cnkoY2UsIHN0YXRlLCBOVUxMLCBOVUxMKTsKCglkaXNjYXJkX2NhY2hlX2VudHJ5KGNlKTsKCXJldHVybiByZXQ7Cn0KCnN0YXRpYyB2b2lkIHdyaXRlX2ZpbGVfaW5fZGlyZWN0b3J5KHN0cnVjdCBzdHJidWYgKmRpciwgc2l6ZV90IGRpcl9sZW4sCgkJCWNvbnN0IGNoYXIgKnBhdGgsIGNvbnN0IGNoYXIgKmNvbnRlbnQpCnsKCWFkZF9wYXRoKGRpciwgZGlyX2xlbiwgcGF0aCk7CgllbnN1cmVfbGVhZGluZ19kaXJlY3RvcmllcyhkaXItPmJ1Zik7Cgl1bmxpbmsoZGlyLT5idWYpOwoJd3JpdGVfZmlsZShkaXItPmJ1ZiwgIiVzIiwgY29udGVudCk7Cn0KCi8qIFdyaXRlIHRoZSBmaWxlIGNvbnRlbnRzIGZvciB0aGUgbGVmdCBhbmQgcmlnaHQgc2lkZXMgb2YgdGhlIGRpZmZ0b29sCiAqIGRpci1kaWZmIHJlcHJlc2VudGF0aW9uIGZvciBzdWJtb2R1bGVzIGFuZCBzeW1saW5rcy4gU3ltbGlua3MgYW5kIHN1Ym1vZHVsZXMKICogYXJlIHdyaXR0ZW4gYXMgcmVndWxhciB0ZXh0IGZpbGVzIHNvIHRoYXQgZXh0ZXJuYWwgZGlmZiB0b29scyBjYW4gZGlmZiB0aGVtCiAqIGFzIHRleHQgZmlsZXMsIHJlc3VsdGluZyBpbiBiZWhhdmlvciB0aGF0IGlzIGFuYWxvZ291cyB0byB0byB3aGF0ICJnaXQgZGlmZiIKICogZGlzcGxheXMgZm9yIHN5bWxpbmsgYW5kIHN1Ym1vZHVsZSBkaWZmcy4KICovCnN0YXRpYyB2b2lkIHdyaXRlX3N0YW5kaW5fZmlsZXMoc3RydWN0IHBhaXJfZW50cnkgKmVudHJ5LAoJCQlzdHJ1Y3Qgc3RyYnVmICpsZGlyLCBzaXplX3QgbGRpcl9sZW4sCgkJCXN0cnVjdCBzdHJidWYgKnJkaXIsIHNpemVfdCByZGlyX2xlbikKewoJaWYgKCplbnRyeS0+bGVmdCkKCQl3cml0ZV9maWxlX2luX2RpcmVjdG9yeShsZGlyLCBsZGlyX2xlbiwgZW50cnktPnBhdGgsIGVudHJ5LT5sZWZ0KTsKCWlmICgqZW50cnktPnJpZ2h0KQoJCXdyaXRlX2ZpbGVfaW5fZGlyZWN0b3J5KHJkaXIsIHJkaXJfbGVuLCBlbnRyeS0+cGF0aCwgZW50cnktPnJpZ2h0KTsKfQoKc3RhdGljIGludCBydW5fZGlyX2RpZmYoY29uc3QgY2hhciAqZXh0Y21kLCBpbnQgc3ltbGlua3MsIGNvbnN0IGNoYXIgKnByZWZpeCwKCQkJc3RydWN0IGNoaWxkX3Byb2Nlc3MgKmNoaWxkKQp7CglzdHJ1Y3Qgc3RyYnVmIGluZm8gPSBTVFJCVUZfSU5JVCwgbHBhdGggPSBTVFJCVUZfSU5JVDsKCXN0cnVjdCBzdHJidWYgcnBhdGggPSBTVFJCVUZfSU5JVCwgYnVmID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3Qgc3RyYnVmIGxkaXIgPSBTVFJCVUZfSU5JVCwgcmRpciA9IFNUUkJVRl9JTklUOwoJc3RydWN0IHN0cmJ1ZiB3dGRpciA9IFNUUkJVRl9JTklUOwoJc3RydWN0IHN0cmJ1ZiB0bXBkaXIgPSBTVFJCVUZfSU5JVDsKCWNoYXIgKmxiYXNlX2RpciA9IE5VTEwsICpyYmFzZV9kaXIgPSBOVUxMOwoJc2l6ZV90IGxkaXJfbGVuLCByZGlyX2xlbiwgd3RkaXJfbGVuOwoJY29uc3QgY2hhciAqd29ya2RpciwgKnRtcDsKCWludCByZXQgPSAwLCBpOwoJRklMRSAqZnAgPSBOVUxMOwoJc3RydWN0IGhhc2htYXAgd29ya2luZ190cmVlX2R1cHMgPSBIQVNITUFQX0lOSVQod29ya2luZ190cmVlX2VudHJ5X2NtcCwKCQkJCQkJCU5VTEwpOwoJc3RydWN0IGhhc2htYXAgc3VibW9kdWxlcyA9IEhBU0hNQVBfSU5JVChwYWlyX2NtcCwgTlVMTCk7CglzdHJ1Y3QgaGFzaG1hcCBzeW1saW5rczIgPSBIQVNITUFQX0lOSVQocGFpcl9jbXAsIE5VTEwpOwoJc3RydWN0IGhhc2htYXBfaXRlciBpdGVyOwoJc3RydWN0IHBhaXJfZW50cnkgKmVudHJ5OwoJc3RydWN0IGluZGV4X3N0YXRlIHd0aW5kZXggPSBJTkRFWF9TVEFURV9JTklUKHRoZV9yZXBvc2l0b3J5KTsKCXN0cnVjdCBjaGVja291dCBsc3RhdGUsIHJzdGF0ZTsKCWludCBlcnIgPSAwOwoJc3RydWN0IGNoaWxkX3Byb2Nlc3MgY21kID0gQ0hJTERfUFJPQ0VTU19JTklUOwoJc3RydWN0IGhhc2htYXAgd3RfbW9kaWZpZWQsIHRtcF9tb2RpZmllZDsKCWludCBpbmRpY2VzX2xvYWRlZCA9IDA7CgoJd29ya2RpciA9IGdldF9naXRfd29ya190cmVlKCk7CgoJLyogU2V0dXAgdGVtcCBkaXJlY3RvcmllcyAqLwoJdG1wID0gZ2V0ZW52KCJUTVBESVIiKTsKCXN0cmJ1Zl9hZGRfYWJzb2x1dGVfcGF0aCgmdG1wZGlyLCB0bXAgPyB0bXAgOiAiL3RtcCIpOwoJc3RyYnVmX3RyaW1fdHJhaWxpbmdfZGlyX3NlcCgmdG1wZGlyKTsKCXN0cmJ1Zl9hZGRzdHIoJnRtcGRpciwgIi9naXQtZGlmZnRvb2wuWFhYWFhYIik7CglpZiAoIW1rZHRlbXAodG1wZGlyLmJ1ZikpIHsKCQlyZXQgPSBlcnJvcigiY291bGQgbm90IGNyZWF0ZSAnJXMnIiwgdG1wZGlyLmJ1Zik7CgkJZ290byBmaW5pc2g7Cgl9CglzdHJidWZfYWRkZigmbGRpciwgIiVzL2xlZnQvIiwgdG1wZGlyLmJ1Zik7CglzdHJidWZfYWRkZigmcmRpciwgIiVzL3JpZ2h0LyIsIHRtcGRpci5idWYpOwoJc3RyYnVmX2FkZHN0cigmd3RkaXIsIHdvcmtkaXIpOwoJaWYgKCF3dGRpci5sZW4gfHwgIWlzX2Rpcl9zZXAod3RkaXIuYnVmW3d0ZGlyLmxlbiAtIDFdKSkKCQlzdHJidWZfYWRkY2goJnd0ZGlyLCAnLycpOwoJbWtkaXIobGRpci5idWYsIDA3MDApOwoJbWtkaXIocmRpci5idWYsIDA3MDApOwoKCW1lbXNldCgmbHN0YXRlLCAwLCBzaXplb2YobHN0YXRlKSk7Cglsc3RhdGUuYmFzZV9kaXIgPSBsYmFzZV9kaXIgPSB4c3RyZHVwKGxkaXIuYnVmKTsKCWxzdGF0ZS5iYXNlX2Rpcl9sZW4gPSBsZGlyLmxlbjsKCWxzdGF0ZS5mb3JjZSA9IDE7CgltZW1zZXQoJnJzdGF0ZSwgMCwgc2l6ZW9mKHJzdGF0ZSkpOwoJcnN0YXRlLmJhc2VfZGlyID0gcmJhc2VfZGlyID0geHN0cmR1cChyZGlyLmJ1Zik7Cglyc3RhdGUuYmFzZV9kaXJfbGVuID0gcmRpci5sZW47Cglyc3RhdGUuZm9yY2UgPSAxOwoKCWxkaXJfbGVuID0gbGRpci5sZW47CglyZGlyX2xlbiA9IHJkaXIubGVuOwoJd3RkaXJfbGVuID0gd3RkaXIubGVuOwoKCWNoaWxkLT5ub19zdGRpbiA9IDE7CgljaGlsZC0+Z2l0X2NtZCA9IDE7CgljaGlsZC0+dXNlX3NoZWxsID0gMDsKCWNoaWxkLT5jbGVhbl9vbl9leGl0ID0gMTsKCWNoaWxkLT5kaXIgPSBwcmVmaXg7CgljaGlsZC0+b3V0ID0gLTE7CglpZiAoc3RhcnRfY29tbWFuZChjaGlsZCkpCgkJZGllKCJjb3VsZCBub3Qgb2J0YWluIHJhdyBkaWZmIik7CglmcCA9IHhmZG9wZW4oY2hpbGQtPm91dCwgInIiKTsKCgkvKiBCdWlsZCBpbmRleCBpbmZvIGZvciBsZWZ0IGFuZCByaWdodCBzaWRlcyBvZiB0aGUgZGlmZiAqLwoJaSA9IDA7Cgl3aGlsZSAoIXN0cmJ1Zl9nZXRsaW5lX251bCgmaW5mbywgZnApKSB7CgkJaW50IGxtb2RlLCBybW9kZTsKCQlzdHJ1Y3Qgb2JqZWN0X2lkIGxvaWQsIHJvaWQ7CgkJY2hhciBzdGF0dXM7CgkJY29uc3QgY2hhciAqc3JjX3BhdGgsICpkc3RfcGF0aDsKCgkJaWYgKHN0YXJ0c193aXRoKGluZm8uYnVmLCAiOjoiKSkKCQkJZGllKE5fKCJjb21iaW5lZCBkaWZmIGZvcm1hdHMgKCctYycgYW5kICctLWNjJykgYXJlICIKCQkJICAgICAgICJub3Qgc3VwcG9ydGVkIGluXG4iCgkJCSAgICAgICAiZGlyZWN0b3J5IGRpZmYgbW9kZSAoJy1kJyBhbmQgJy0tZGlyLWRpZmYnKS4iKSk7CgoJCWlmIChwYXJzZV9pbmRleF9pbmZvKGluZm8uYnVmLCAmbG1vZGUsICZybW9kZSwgJmxvaWQsICZyb2lkLAoJCQkJICAgICAmc3RhdHVzKSkKCQkJYnJlYWs7CgkJaWYgKHN0cmJ1Zl9nZXRsaW5lX251bCgmbHBhdGgsIGZwKSkKCQkJYnJlYWs7CgkJc3JjX3BhdGggPSBscGF0aC5idWY7CgoJCWkrKzsKCQlpZiAoc3RhdHVzICE9ICdDJyAmJiBzdGF0dXMgIT0gJ1InKSB7CgkJCWRzdF9wYXRoID0gc3JjX3BhdGg7CgkJfSBlbHNlIHsKCQkJaWYgKHN0cmJ1Zl9nZXRsaW5lX251bCgmcnBhdGgsIGZwKSkKCQkJCWJyZWFrOwoJCQlkc3RfcGF0aCA9IHJwYXRoLmJ1ZjsKCQl9CgoJCWlmIChTX0lTR0lUTElOSyhsbW9kZSkgfHwgU19JU0dJVExJTksocm1vZGUpKSB7CgkJCXN0cmJ1Zl9yZXNldCgmYnVmKTsKCQkJc3RyYnVmX2FkZGYoJmJ1ZiwgIlN1YnByb2plY3QgY29tbWl0ICVzIiwKCQkJCSAgICBvaWRfdG9faGV4KCZsb2lkKSk7CgkJCWFkZF9sZWZ0X29yX3JpZ2h0KCZzdWJtb2R1bGVzLCBzcmNfcGF0aCwgYnVmLmJ1ZiwgMCk7CgkJCXN0cmJ1Zl9yZXNldCgmYnVmKTsKCQkJc3RyYnVmX2FkZGYoJmJ1ZiwgIlN1YnByb2plY3QgY29tbWl0ICVzIiwKCQkJCSAgICBvaWRfdG9faGV4KCZyb2lkKSk7CgkJCWlmIChvaWRlcSgmbG9pZCwgJnJvaWQpKQoJCQkJc3RyYnVmX2FkZHN0cigmYnVmLCAiLWRpcnR5Iik7CgkJCWFkZF9sZWZ0X29yX3JpZ2h0KCZzdWJtb2R1bGVzLCBkc3RfcGF0aCwgYnVmLmJ1ZiwgMSk7CgkJCWNvbnRpbnVlOwoJCX0KCgkJaWYgKFNfSVNMTksobG1vZGUpKSB7CgkJCWNoYXIgKmNvbnRlbnQgPSBnZXRfc3ltbGluaygmbG9pZCwgc3JjX3BhdGgpOwoJCQlhZGRfbGVmdF9vcl9yaWdodCgmc3ltbGlua3MyLCBzcmNfcGF0aCwgY29udGVudCwgMCk7CgkJCWZyZWUoY29udGVudCk7CgkJfQoKCQlpZiAoU19JU0xOSyhybW9kZSkpIHsKCQkJY2hhciAqY29udGVudCA9IGdldF9zeW1saW5rKCZyb2lkLCBkc3RfcGF0aCk7CgkJCWFkZF9sZWZ0X29yX3JpZ2h0KCZzeW1saW5rczIsIGRzdF9wYXRoLCBjb250ZW50LCAxKTsKCQkJZnJlZShjb250ZW50KTsKCQl9CgoJCWlmIChsbW9kZSAmJiBzdGF0dXMgIT0gJ0MnKSB7CgkJCWlmIChjaGVja291dF9wYXRoKGxtb2RlLCAmbG9pZCwgc3JjX3BhdGgsICZsc3RhdGUpKSB7CgkJCQlyZXQgPSBlcnJvcigiY291bGQgbm90IHdyaXRlICclcyciLCBzcmNfcGF0aCk7CgkJCQlnb3RvIGZpbmlzaDsKCQkJfQoJCX0KCgkJaWYgKHJtb2RlICYmICFTX0lTTE5LKHJtb2RlKSkgewoJCQlzdHJ1Y3Qgd29ya2luZ190cmVlX2VudHJ5ICplbnRyeTsKCgkJCS8qIEF2b2lkIGR1cGxpY2F0ZSB3b3JraW5nX3RyZWUgZW50cmllcyAqLwoJCQlGTEVYX0FMTE9DX1NUUihlbnRyeSwgcGF0aCwgZHN0X3BhdGgpOwoJCQloYXNobWFwX2VudHJ5X2luaXQoJmVudHJ5LT5lbnRyeSwgc3RyaGFzaChkc3RfcGF0aCkpOwoJCQlpZiAoaGFzaG1hcF9nZXQoJndvcmtpbmdfdHJlZV9kdXBzLCAmZW50cnktPmVudHJ5LAoJCQkJCU5VTEwpKSB7CgkJCQlmcmVlKGVudHJ5KTsKCQkJCWNvbnRpbnVlOwoJCQl9CgkJCWhhc2htYXBfYWRkKCZ3b3JraW5nX3RyZWVfZHVwcywgJmVudHJ5LT5lbnRyeSk7CgoJCQlpZiAoIXVzZV93dF9maWxlKHdvcmtkaXIsIGRzdF9wYXRoLCAmcm9pZCkpIHsKCQkJCWlmIChjaGVja291dF9wYXRoKHJtb2RlLCAmcm9pZCwgZHN0X3BhdGgsCgkJCQkJCSAgJnJzdGF0ZSkpIHsKCQkJCQlyZXQgPSBlcnJvcigiY291bGQgbm90IHdyaXRlICclcyciLAoJCQkJCQkgICAgZHN0X3BhdGgpOwoJCQkJCWdvdG8gZmluaXNoOwoJCQkJfQoJCQl9IGVsc2UgaWYgKCFpc19udWxsX29pZCgmcm9pZCkpIHsKCQkJCS8qCgkJCQkgKiBDaGFuZ2VzIGluIHRoZSB3b3JraW5nIHRyZWUgbmVlZCBzcGVjaWFsCgkJCQkgKiB0cmVhdG1lbnQgc2luY2UgdGhleSBhcmUgbm90IHBhcnQgb2YgdGhlCgkJCQkgKiBpbmRleC4KCQkJCSAqLwoJCQkJc3RydWN0IGNhY2hlX2VudHJ5ICpjZTIgPQoJCQkJCW1ha2VfY2FjaGVfZW50cnkoJnd0aW5kZXgsIHJtb2RlLCAmcm9pZCwKCQkJCQkJCSBkc3RfcGF0aCwgMCwgMCk7CgoJCQkJYWRkX2luZGV4X2VudHJ5KCZ3dGluZGV4LCBjZTIsCgkJCQkJCUFERF9DQUNIRV9KVVNUX0FQUEVORCk7CgoJCQkJYWRkX3BhdGgoJnJkaXIsIHJkaXJfbGVuLCBkc3RfcGF0aCk7CgkJCQlpZiAoZW5zdXJlX2xlYWRpbmdfZGlyZWN0b3JpZXMocmRpci5idWYpKSB7CgkJCQkJcmV0ID0gZXJyb3IoImNvdWxkIG5vdCBjcmVhdGUgIgoJCQkJCQkgICAgImRpcmVjdG9yeSBmb3IgJyVzJyIsCgkJCQkJCSAgICBkc3RfcGF0aCk7CgkJCQkJZ290byBmaW5pc2g7CgkJCQl9CgkJCQlhZGRfcGF0aCgmd3RkaXIsIHd0ZGlyX2xlbiwgZHN0X3BhdGgpOwoJCQkJaWYgKHN5bWxpbmtzKSB7CgkJCQkJaWYgKHN5bWxpbmsod3RkaXIuYnVmLCByZGlyLmJ1ZikpIHsKCQkJCQkJcmV0ID0gZXJyb3JfZXJybm8oImNvdWxkIG5vdCBzeW1saW5rICclcycgdG8gJyVzJyIsIHd0ZGlyLmJ1ZiwgcmRpci5idWYpOwoJCQkJCQlnb3RvIGZpbmlzaDsKCQkJCQl9CgkJCQl9IGVsc2UgewoJCQkJCXN0cnVjdCBzdGF0IHN0OwoJCQkJCWlmIChzdGF0KHd0ZGlyLmJ1ZiwgJnN0KSkKCQkJCQkJc3Quc3RfbW9kZSA9IDA2NDQ7CgkJCQkJaWYgKGNvcHlfZmlsZShyZGlyLmJ1Ziwgd3RkaXIuYnVmLAoJCQkJCQkgICAgICBzdC5zdF9tb2RlKSkgewoJCQkJCQlyZXQgPSBlcnJvcigiY291bGQgbm90IGNvcHkgJyVzJyB0byAnJXMnIiwgd3RkaXIuYnVmLCByZGlyLmJ1Zik7CgkJCQkJCWdvdG8gZmluaXNoOwoJCQkJCX0KCQkJCX0KCQkJfQoJCX0KCX0KCglmY2xvc2UoZnApOwoJZnAgPSBOVUxMOwoJaWYgKGZpbmlzaF9jb21tYW5kKGNoaWxkKSkgewoJCXJldCA9IGVycm9yKCJlcnJvciBvY2N1cnJlZCBydW5uaW5nIGRpZmYgLS1yYXciKTsKCQlnb3RvIGZpbmlzaDsKCX0KCglpZiAoIWkpCgkJZ290byBmaW5pc2g7CgoJLyoKCSAqIENoYW5nZXMgdG8gc3VibW9kdWxlcyByZXF1aXJlIHNwZWNpYWwgdHJlYXRtZW50LlRoaXMgbG9vcCB3cml0ZXMgYQoJICogdGVtcG9yYXJ5IGZpbGUgdG8gYm90aCB0aGUgbGVmdCBhbmQgcmlnaHQgZGlyZWN0b3JpZXMgdG8gc2hvdyB0aGUKCSAqIGNoYW5nZSBpbiB0aGUgcmVjb3JkZWQgU0hBMSBmb3IgdGhlIHN1Ym1vZHVsZS4KCSAqLwoJaGFzaG1hcF9mb3JfZWFjaF9lbnRyeSgmc3VibW9kdWxlcywgJml0ZXIsIGVudHJ5LAoJCQkJZW50cnkgLyogbWVtYmVyIG5hbWUgKi8pIHsKCQl3cml0ZV9zdGFuZGluX2ZpbGVzKGVudHJ5LCAmbGRpciwgbGRpcl9sZW4sICZyZGlyLCByZGlyX2xlbik7Cgl9CgoJLyoKCSAqIFN5bWJvbGljIGxpbmtzIHJlcXVpcmUgc3BlY2lhbCB0cmVhdG1lbnQuIFRoZSBzdGFuZGFyZCAiZ2l0IGRpZmYiCgkgKiBzaG93cyBvbmx5IHRoZSBsaW5rIGl0c2VsZiwgbm90IHRoZSBjb250ZW50cyBvZiB0aGUgbGluayB0YXJnZXQuCgkgKiBUaGlzIGxvb3AgcmVwbGljYXRlcyB0aGF0IGJlaGF2aW9yLgoJICovCgloYXNobWFwX2Zvcl9lYWNoX2VudHJ5KCZzeW1saW5rczIsICZpdGVyLCBlbnRyeSwKCQkJCWVudHJ5IC8qIG1lbWJlciBuYW1lICovKSB7CgoJCXdyaXRlX3N0YW5kaW5fZmlsZXMoZW50cnksICZsZGlyLCBsZGlyX2xlbiwgJnJkaXIsIHJkaXJfbGVuKTsKCX0KCglzdHJidWZfc2V0bGVuKCZsZGlyLCBsZGlyX2xlbik7CglzdHJidWZfc2V0bGVuKCZyZGlyLCByZGlyX2xlbik7CgoJaWYgKGV4dGNtZCkgewoJCXN0cnZlY19wdXNoKCZjbWQuYXJncywgZXh0Y21kKTsKCX0gZWxzZSB7CgkJc3RydmVjX3B1c2goJmNtZC5hcmdzLCAiZGlmZnRvb2wtLWhlbHBlciIpOwoJCWNtZC5naXRfY21kID0gMTsKCQlzZXRlbnYoIkdJVF9ESUZGVE9PTF9ESVJESUZGIiwgInRydWUiLCAxKTsKCX0KCXN0cnZlY19wdXNobCgmY21kLmFyZ3MsIGxkaXIuYnVmLCByZGlyLmJ1ZiwgTlVMTCk7CglyZXQgPSBydW5fY29tbWFuZCgmY21kKTsKCgkvKiBUT0RPOiBhdWRpdCBmb3IgaW50ZXJhY3Rpb24gd2l0aCBzcGFyc2UtaW5kZXguICovCgllbnN1cmVfZnVsbF9pbmRleCgmd3RpbmRleCk7CgoJLyoKCSAqIElmIHRoZSBkaWZmIGluY2x1ZGVzIHdvcmtpbmcgY29weSBmaWxlcyBhbmQgdGhvc2UKCSAqIGZpbGVzIHdlcmUgbW9kaWZpZWQgZHVyaW5nIHRoZSBkaWZmLCB0aGVuIHRoZSBjaGFuZ2VzCgkgKiBzaG91bGQgYmUgY29waWVkIGJhY2sgdG8gdGhlIHdvcmtpbmcgdHJlZS4KCSAqIERvIG5vdCBjb3B5IGJhY2sgZmlsZXMgd2hlbiBzeW1saW5rcyBhcmUgdXNlZCBhbmQgdGhlCgkgKiBleHRlcm5hbCB0b29sIGRpZCBub3QgcmVwbGFjZSB0aGUgb3JpZ2luYWwgbGluayB3aXRoIGEgZmlsZS4KCSAqCgkgKiBUaGVzZSBoYXNoZXMgYXJlIGxvYWRlZCBsYXppbHkgc2luY2UgdGhleSBhcmVuJ3QgbmVlZGVkCgkgKiBpbiB0aGUgY29tbW9uIGNhc2Ugb2YgLS1zeW1saW5rcyBhbmQgdGhlIGRpZmZ0b29sIHVwZGF0aW5nCgkgKiBmaWxlcyB0aHJvdWdoIHRoZSBzeW1saW5rLgoJICovCgloYXNobWFwX2luaXQoJnd0X21vZGlmaWVkLCBwYXRoX2VudHJ5X2NtcCwgTlVMTCwgd3RpbmRleC5jYWNoZV9ucik7CgloYXNobWFwX2luaXQoJnRtcF9tb2RpZmllZCwgcGF0aF9lbnRyeV9jbXAsIE5VTEwsIHd0aW5kZXguY2FjaGVfbnIpOwoKCWZvciAoaSA9IDA7IGkgPCB3dGluZGV4LmNhY2hlX25yOyBpKyspIHsKCQlzdHJ1Y3QgaGFzaG1hcF9lbnRyeSBkdW1teTsKCQljb25zdCBjaGFyICpuYW1lID0gd3RpbmRleC5jYWNoZVtpXS0+bmFtZTsKCQlzdHJ1Y3Qgc3RhdCBzdDsKCgkJYWRkX3BhdGgoJnJkaXIsIHJkaXJfbGVuLCBuYW1lKTsKCQlpZiAobHN0YXQocmRpci5idWYsICZzdCkpCgkJCWNvbnRpbnVlOwoKCQlpZiAoKHN5bWxpbmtzICYmIFNfSVNMTksoc3Quc3RfbW9kZSkpIHx8ICFTX0lTUkVHKHN0LnN0X21vZGUpKQoJCQljb250aW51ZTsKCgkJaWYgKCFpbmRpY2VzX2xvYWRlZCkgewoJCQlzdHJ1Y3QgbG9ja19maWxlIGxvY2sgPSBMT0NLX0lOSVQ7CgkJCXN0cmJ1Zl9yZXNldCgmYnVmKTsKCQkJc3RyYnVmX2FkZGYoJmJ1ZiwgIiVzL3d0aW5kZXgiLCB0bXBkaXIuYnVmKTsKCQkJaWYgKGhvbGRfbG9ja19maWxlX2Zvcl91cGRhdGUoJmxvY2ssIGJ1Zi5idWYsIDApIDwgMCB8fAoJCQkgICAgd3JpdGVfbG9ja2VkX2luZGV4KCZ3dGluZGV4LCAmbG9jaywgQ09NTUlUX0xPQ0spKSB7CgkJCQlyZXQgPSBlcnJvcigiY291bGQgbm90IHdyaXRlICVzIiwgYnVmLmJ1Zik7CgkJCQlnb3RvIGZpbmlzaDsKCQkJfQoJCQljaGFuZ2VkX2ZpbGVzKCZ3dF9tb2RpZmllZCwgYnVmLmJ1Ziwgd29ya2Rpcik7CgkJCXN0cmJ1Zl9zZXRsZW4oJnJkaXIsIHJkaXJfbGVuKTsKCQkJY2hhbmdlZF9maWxlcygmdG1wX21vZGlmaWVkLCBidWYuYnVmLCByZGlyLmJ1Zik7CgkJCWFkZF9wYXRoKCZyZGlyLCByZGlyX2xlbiwgbmFtZSk7CgkJCWluZGljZXNfbG9hZGVkID0gMTsKCQl9CgoJCWhhc2htYXBfZW50cnlfaW5pdCgmZHVtbXksIHN0cmhhc2gobmFtZSkpOwoJCWlmIChoYXNobWFwX2dldCgmdG1wX21vZGlmaWVkLCAmZHVtbXksIG5hbWUpKSB7CgkJCWFkZF9wYXRoKCZ3dGRpciwgd3RkaXJfbGVuLCBuYW1lKTsKCQkJaWYgKGhhc2htYXBfZ2V0KCZ3dF9tb2RpZmllZCwgJmR1bW15LCBuYW1lKSkgewoJCQkJd2FybmluZyhfKCJib3RoIGZpbGVzIG1vZGlmaWVkOiAnJXMnIGFuZCAnJXMnLiIpLAoJCQkJCXd0ZGlyLmJ1ZiwgcmRpci5idWYpOwoJCQkJd2FybmluZyhfKCJ3b3JraW5nIHRyZWUgZmlsZSBoYXMgYmVlbiBsZWZ0LiIpKTsKCQkJCXdhcm5pbmcoIiVzIiwgIiIpOwoJCQkJZXJyID0gMTsKCQkJfSBlbHNlIGlmICh1bmxpbmsod3RkaXIuYnVmKSB8fAoJCQkJICAgY29weV9maWxlKHd0ZGlyLmJ1ZiwgcmRpci5idWYsIHN0LnN0X21vZGUpKQoJCQkJd2FybmluZ19lcnJubyhfKCJjb3VsZCBub3QgY29weSAnJXMnIHRvICclcyciKSwKCQkJCQkgICAgICByZGlyLmJ1Ziwgd3RkaXIuYnVmKTsKCQl9Cgl9CgoJaWYgKGVycikgewoJCXdhcm5pbmcoXygidGVtcG9yYXJ5IGZpbGVzIGV4aXN0IGluICclcycuIiksIHRtcGRpci5idWYpOwoJCXdhcm5pbmcoXygieW91IG1heSB3YW50IHRvIGNsZWFudXAgb3IgcmVjb3ZlciB0aGVzZS4iKSk7CgkJcmV0ID0gMTsKCX0gZWxzZSB7CgkJcmVtb3ZlX2Rpcl9yZWN1cnNpdmVseSgmdG1wZGlyLCAwKTsKCQlpZiAocmV0KQoJCQl3YXJuaW5nKF8oImZhaWxlZDogJWQiKSwgcmV0KTsKCX0KCmZpbmlzaDoKCWlmIChmcCkKCQlmY2xvc2UoZnApOwoKCWZyZWUobGJhc2VfZGlyKTsKCWZyZWUocmJhc2VfZGlyKTsKCXN0cmJ1Zl9yZWxlYXNlKCZsZGlyKTsKCXN0cmJ1Zl9yZWxlYXNlKCZyZGlyKTsKCXN0cmJ1Zl9yZWxlYXNlKCZ3dGRpcik7CglzdHJidWZfcmVsZWFzZSgmYnVmKTsKCXN0cmJ1Zl9yZWxlYXNlKCZ0bXBkaXIpOwoKCXJldHVybiAocmV0IDwgMCkgPyAxIDogcmV0Owp9CgpzdGF0aWMgaW50IHJ1bl9maWxlX2RpZmYoaW50IHByb21wdCwgY29uc3QgY2hhciAqcHJlZml4LAoJCQkgc3RydWN0IGNoaWxkX3Byb2Nlc3MgKmNoaWxkKQp7Cgljb25zdCBjaGFyICplbnZbXSA9IHsKCQkiR0lUX1BBR0VSPSIsICJHSVRfRVhURVJOQUxfRElGRj1naXQtZGlmZnRvb2wtLWhlbHBlciIsIE5VTEwsCgkJTlVMTAoJfTsKCglpZiAocHJvbXB0ID4gMCkKCQllbnZbMl0gPSAiR0lUX0RJRkZUT09MX1BST01QVD10cnVlIjsKCWVsc2UgaWYgKCFwcm9tcHQpCgkJZW52WzJdID0gIkdJVF9ESUZGVE9PTF9OT19QUk9NUFQ9dHJ1ZSI7CgoJY2hpbGQtPmdpdF9jbWQgPSAxOwoJY2hpbGQtPmRpciA9IHByZWZpeDsKCXN0cnZlY19wdXNodigmY2hpbGQtPmVudiwgZW52KTsKCglyZXR1cm4gcnVuX2NvbW1hbmQoY2hpbGQpOwp9CgppbnQgY21kX2RpZmZ0b29sKGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndiwgY29uc3QgY2hhciAqcHJlZml4KQp7CglpbnQgdXNlX2d1aV90b29sID0gLTEsIGRpcl9kaWZmID0gMCwgcHJvbXB0ID0gLTEsIHN5bWxpbmtzID0gMCwKCSAgICB0b29sX2hlbHAgPSAwLCBub19pbmRleCA9IDA7CglzdGF0aWMgY2hhciAqZGlmZnRvb2xfY21kID0gTlVMTCwgKmV4dGNtZCA9IE5VTEw7CglzdHJ1Y3Qgb3B0aW9uIGJ1aWx0aW5fZGlmZnRvb2xfb3B0aW9uc1tdID0gewoJCU9QVF9CT09MKCdnJywgImd1aSIsICZ1c2VfZ3VpX3Rvb2wsCgkJCSBOXygidXNlIGBkaWZmLmd1aXRvb2xgIGluc3RlYWQgb2YgYGRpZmYudG9vbGAiKSksCgkJT1BUX0JPT0woJ2QnLCAiZGlyLWRpZmYiLCAmZGlyX2RpZmYsCgkJCSBOXygicGVyZm9ybSBhIGZ1bGwtZGlyZWN0b3J5IGRpZmYiKSksCgkJT1BUX1NFVF9JTlRfRigneScsICJuby1wcm9tcHQiLCAmcHJvbXB0LAoJCQlOXygiZG8gbm90IHByb21wdCBiZWZvcmUgbGF1bmNoaW5nIGEgZGlmZiB0b29sIiksCgkJCTAsIFBBUlNFX09QVF9OT05FRyksCgkJT1BUX1NFVF9JTlRfRigwLCAicHJvbXB0IiwgJnByb21wdCwgTlVMTCwKCQkJMSwgUEFSU0VfT1BUX05PTkVHIHwgUEFSU0VfT1BUX0hJRERFTiksCgkJT1BUX0JPT0woMCwgInN5bWxpbmtzIiwgJnN5bWxpbmtzLAoJCQkgTl8oInVzZSBzeW1saW5rcyBpbiBkaXItZGlmZiBtb2RlIikpLAoJCU9QVF9TVFJJTkcoJ3QnLCAidG9vbCIsICZkaWZmdG9vbF9jbWQsIE5fKCJ0b29sIiksCgkJCSAgIE5fKCJ1c2UgdGhlIHNwZWNpZmllZCBkaWZmIHRvb2wiKSksCgkJT1BUX0JPT0woMCwgInRvb2wtaGVscCIsICZ0b29sX2hlbHAsCgkJCSBOXygicHJpbnQgYSBsaXN0IG9mIGRpZmYgdG9vbHMgdGhhdCBtYXkgYmUgdXNlZCB3aXRoICIKCQkJICAgICJgLS10b29sYCIpKSwKCQlPUFRfQk9PTCgwLCAidHJ1c3QtZXhpdC1jb2RlIiwgJnRydXN0X2V4aXRfY29kZSwKCQkJIE5fKCJtYWtlICdnaXQtZGlmZnRvb2wnIGV4aXQgd2hlbiBhbiBpbnZva2VkIGRpZmYgIgoJCQkgICAgInRvb2wgcmV0dXJucyBhIG5vbi16ZXJvIGV4aXQgY29kZSIpKSwKCQlPUFRfU1RSSU5HKCd4JywgImV4dGNtZCIsICZleHRjbWQsIE5fKCJjb21tYW5kIiksCgkJCSAgIE5fKCJzcGVjaWZ5IGEgY3VzdG9tIGNvbW1hbmQgZm9yIHZpZXdpbmcgZGlmZnMiKSksCgkJT1BUX0JPT0woMCwgIm5vLWluZGV4IiwgJm5vX2luZGV4LCBOXygicGFzc2VkIHRvIGBkaWZmYCIpKSwKCQlPUFRfRU5EKCkKCX07CglzdHJ1Y3QgY2hpbGRfcHJvY2VzcyBjaGlsZCA9IENISUxEX1BST0NFU1NfSU5JVDsKCglnaXRfY29uZmlnKGRpZmZ0b29sX2NvbmZpZywgTlVMTCk7CglzeW1saW5rcyA9IGhhc19zeW1saW5rczsKCglhcmdjID0gcGFyc2Vfb3B0aW9ucyhhcmdjLCBhcmd2LCBwcmVmaXgsIGJ1aWx0aW5fZGlmZnRvb2xfb3B0aW9ucywKCQkJICAgICBidWlsdGluX2RpZmZ0b29sX3VzYWdlLCBQQVJTRV9PUFRfS0VFUF9VTktOT1dOX09QVCB8CgkJCSAgICAgUEFSU0VfT1BUX0tFRVBfREFTSERBU0gpOwoKCWlmICh0b29sX2hlbHApCgkJcmV0dXJuIHByaW50X3Rvb2xfaGVscCgpOwoKCWlmICghbm9faW5kZXggJiYgIXN0YXJ0dXBfaW5mby0+aGF2ZV9yZXBvc2l0b3J5KQoJCWRpZShfKCJkaWZmdG9vbCByZXF1aXJlcyB3b3JrdHJlZSBvciAtLW5vLWluZGV4IikpOwoKCWlmICghbm9faW5kZXgpewoJCXNldHVwX3dvcmtfdHJlZSgpOwoJCXNldGVudihHSVRfRElSX0VOVklST05NRU5ULCBhYnNvbHV0ZV9wYXRoKGdldF9naXRfZGlyKCkpLCAxKTsKCQlzZXRlbnYoR0lUX1dPUktfVFJFRV9FTlZJUk9OTUVOVCwgYWJzb2x1dGVfcGF0aChnZXRfZ2l0X3dvcmtfdHJlZSgpKSwgMSk7Cgl9IGVsc2UgaWYgKGRpcl9kaWZmKQoJCWRpZShfKCJvcHRpb25zICclcycgYW5kICclcycgY2Fubm90IGJlIHVzZWQgdG9nZXRoZXIiKSwgIi0tZGlyLWRpZmYiLCAiLS1uby1pbmRleCIpOwoKCWRpZV9mb3JfaW5jb21wYXRpYmxlX29wdDModXNlX2d1aV90b29sID09IDEsICItLWd1aSIsCgkJCQkgICEhZGlmZnRvb2xfY21kLCAiLS10b29sIiwKCQkJCSAgISFleHRjbWQsICItLWV4dGNtZCIpOwoKCS8qCgkgKiBFeHBsaWNpdGx5IHNwZWNpZmllZCBHVUkgb3B0aW9uIGlzIGZvcndhcmRlZCB0byBnaXQtbWVyZ2V0b29sLS1saWIuc2g7CgkgKiBlbXB0eSBvciB1bnNldCBtZWFucyAidXNlIHRoZSBkaWZmdG9vbC5ndWlEZWZhdWx0IGNvbmZpZyBvciBkZWZhdWx0IHRvCgkgKiBmYWxzZSIuCgkgKi8KCWlmICh1c2VfZ3VpX3Rvb2wgPT0gMSkKCQlzZXRlbnYoIkdJVF9NRVJHRVRPT0xfR1VJIiwgInRydWUiLCAxKTsKCWVsc2UgaWYgKHVzZV9ndWlfdG9vbCA9PSAwKQoJCXNldGVudigiR0lUX01FUkdFVE9PTF9HVUkiLCAiZmFsc2UiLCAxKTsKCglpZiAoZGlmZnRvb2xfY21kKSB7CgkJaWYgKCpkaWZmdG9vbF9jbWQpCgkJCXNldGVudigiR0lUX0RJRkZfVE9PTCIsIGRpZmZ0b29sX2NtZCwgMSk7CgkJZWxzZQoJCQlkaWUoXygibm8gPHRvb2w+IGdpdmVuIGZvciAtLXRvb2w9PHRvb2w+IikpOwoJfQoKCWlmIChleHRjbWQpIHsKCQlpZiAoKmV4dGNtZCkKCQkJc2V0ZW52KCJHSVRfRElGRlRPT0xfRVhUQ01EIiwgZXh0Y21kLCAxKTsKCQllbHNlCgkJCWRpZShfKCJubyA8Y21kPiBnaXZlbiBmb3IgLS1leHRjbWQ9PGNtZD4iKSk7Cgl9CgoJc2V0ZW52KCJHSVRfRElGRlRPT0xfVFJVU1RfRVhJVF9DT0RFIiwKCSAgICAgICB0cnVzdF9leGl0X2NvZGUgPyAidHJ1ZSIgOiAiZmFsc2UiLCAxKTsKCgkvKgoJICogSW4gZGlyZWN0b3J5IGRpZmYgbW9kZSwgJ2dpdC1kaWZmdG9vbC0taGVscGVyJyBpcyBjYWxsZWQgb25jZQoJICogdG8gY29tcGFyZSB0aGUgYSAvIGIgZGlyZWN0b3JpZXMuIEluIGZpbGUgZGlmZiBtb2RlLCAnZ2l0IGRpZmYnCgkgKiB3aWxsIGludm9rZSBhIHNlcGFyYXRlIGluc3RhbmNlIG9mICdnaXQtZGlmZnRvb2wtLWhlbHBlcicgZm9yCgkgKiBlYWNoIGZpbGUgdGhhdCBjaGFuZ2VkLgoJICovCglzdHJ2ZWNfcHVzaCgmY2hpbGQuYXJncywgImRpZmYiKTsKCWlmIChub19pbmRleCkKCQlzdHJ2ZWNfcHVzaCgmY2hpbGQuYXJncywgIi0tbm8taW5kZXgiKTsKCWlmIChkaXJfZGlmZikKCQlzdHJ2ZWNfcHVzaGwoJmNoaWxkLmFyZ3MsICItLXJhdyIsICItLW5vLWFiYnJldiIsICIteiIsIE5VTEwpOwoJc3RydmVjX3B1c2h2KCZjaGlsZC5hcmdzLCBhcmd2KTsKCglpZiAoZGlyX2RpZmYpCgkJcmV0dXJuIHJ1bl9kaXJfZGlmZihleHRjbWQsIHN5bWxpbmtzLCBwcmVmaXgsICZjaGlsZCk7CglyZXR1cm4gcnVuX2ZpbGVfZGlmZihwcm9tcHQsIHByZWZpeCwgJmNoaWxkKTsKfQo=",
    "text": "/*\n * \"git difftool\" builtin command\n *\n * This is a wrapper around the GIT_EXTERNAL_DIFF-compatible\n * git-difftool--helper script.\n *\n * This script exports GIT_EXTERNAL_DIFF and GIT_PAGER for use by git.\n * The GIT_DIFF* variables are exported for use by git-difftool--helper.\n *\n * Any arguments that are unknown to this script are forwarded to 'git diff'.\n *\n * Copyright (C) 2016 Johannes Schindelin\n */\n#define USE_THE_INDEX_VARIABLE\n#include \"cache.h\"\n#include \"abspath.h\"\n#include \"config.h\"\n#include \"copy.h\"\n#include \"builtin.h\"\n#include \"run-command.h\"\n#include \"environment.h\"\n#include \"exec-cmd.h\"\n#include \"gettext.h\"\n#include \"hex.h\"\n#include \"parse-options.h\"\n#include \"strvec.h\"\n#include \"strbuf.h\"\n#include \"lockfile.h\"\n#include \"object-file.h\"\n#include \"object-store.h\"\n#include \"dir.h\"\n#include \"entry.h\"\n#include \"setup.h\"\n#include \"wrapper.h\"\n\nstatic int trust_exit_code;\n\nstatic const char *const builtin_difftool_usage[] = {\n\tN_(\"git difftool [<options>] [<commit> [<commit>]] [--] [<path>...]\"),\n\tNULL\n};\n\nstatic int difftool_config(const char *var, const char *value, void *cb)\n{\n\tif (!strcmp(var, \"difftool.trustexitcode\")) {\n\t\ttrust_exit_code = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\n\treturn git_default_config(var, value, cb);\n}\n\nstatic int print_tool_help(void)\n{\n\tstruct child_process cmd = CHILD_PROCESS_INIT;\n\n\tcmd.git_cmd = 1;\n\tstrvec_pushl(&cmd.args, \"mergetool\", \"--tool-help=diff\", NULL);\n\treturn run_command(&cmd);\n}\n\nstatic int parse_index_info(char *p, int *mode1, int *mode2,\n\t\t\t    struct object_id *oid1, struct object_id *oid2,\n\t\t\t    char *status)\n{\n\tif (*p != ':')\n\t\treturn error(\"expected ':', got '%c'\", *p);\n\t*mode1 = (int)strtol(p + 1, &p, 8);\n\tif (*p != ' ')\n\t\treturn error(\"expected ' ', got '%c'\", *p);\n\t*mode2 = (int)strtol(p + 1, &p, 8);\n\tif (*p != ' ')\n\t\treturn error(\"expected ' ', got '%c'\", *p);\n\tif (parse_oid_hex(++p, oid1, (const char **)&p))\n\t\treturn error(\"expected object ID, got '%s'\", p);\n\tif (*p != ' ')\n\t\treturn error(\"expected ' ', got '%c'\", *p);\n\tif (parse_oid_hex(++p, oid2, (const char **)&p))\n\t\treturn error(\"expected object ID, got '%s'\", p);\n\tif (*p != ' ')\n\t\treturn error(\"expected ' ', got '%c'\", *p);\n\t*status = *++p;\n\tif (!*status)\n\t\treturn error(\"missing status\");\n\tif (p[1] && !isdigit(p[1]))\n\t\treturn error(\"unexpected trailer: '%s'\", p + 1);\n\treturn 0;\n}\n\n/*\n * Remove any trailing slash from $workdir\n * before starting to avoid double slashes in symlink targets.\n */\nstatic void add_path(struct strbuf *buf, size_t base_len, const char *path)\n{\n\tstrbuf_setlen(buf, base_len);\n\tif (buf->len && buf->buf[buf->len - 1] != '/')\n\t\tstrbuf_addch(buf, '/');\n\tstrbuf_addstr(buf, path);\n}\n\n/*\n * Determine whether we can simply reuse the file in the worktree.\n */\nstatic int use_wt_file(const char *workdir, const char *name,\n\t\t       struct object_id *oid)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tstruct stat st;\n\tint use = 0;\n\n\tstrbuf_addstr(&buf, workdir);\n\tadd_path(&buf, buf.len, name);\n\n\tif (!lstat(buf.buf, &st) && !S_ISLNK(st.st_mode)) {\n\t\tstruct object_id wt_oid;\n\t\tint fd = open(buf.buf, O_RDONLY);\n\n\t\tif (fd >= 0 &&\n\t\t    !index_fd(&the_index, &wt_oid, fd, &st, OBJ_BLOB, name, 0)) {\n\t\t\tif (is_null_oid(oid)) {\n\t\t\t\toidcpy(oid, &wt_oid);\n\t\t\t\tuse = 1;\n\t\t\t} else if (oideq(oid, &wt_oid))\n\t\t\t\tuse = 1;\n\t\t}\n\t}\n\n\tstrbuf_release(&buf);\n\n\treturn use;\n}\n\nstruct working_tree_entry {\n\tstruct hashmap_entry entry;\n\tchar path[FLEX_ARRAY];\n};\n\nstatic int working_tree_entry_cmp(const void *cmp_data UNUSED,\n\t\t\t\t  const struct hashmap_entry *eptr,\n\t\t\t\t  const struct hashmap_entry *entry_or_key,\n\t\t\t\t  const void *keydata UNUSED)\n{\n\tconst struct working_tree_entry *a, *b;\n\n\ta = container_of(eptr, const struct working_tree_entry, entry);\n\tb = container_of(entry_or_key, const struct working_tree_entry, entry);\n\n\treturn strcmp(a->path, b->path);\n}\n\n/*\n * The `left` and `right` entries hold paths for the symlinks hashmap,\n * and a SHA-1 surrounded by brief text for submodules.\n */\nstruct pair_entry {\n\tstruct hashmap_entry entry;\n\tchar left[PATH_MAX], right[PATH_MAX];\n\tconst char path[FLEX_ARRAY];\n};\n\nstatic int pair_cmp(const void *cmp_data UNUSED,\n\t\t    const struct hashmap_entry *eptr,\n\t\t    const struct hashmap_entry *entry_or_key,\n\t\t    const void *keydata UNUSED)\n{\n\tconst struct pair_entry *a, *b;\n\n\ta = container_of(eptr, const struct pair_entry, entry);\n\tb = container_of(entry_or_key, const struct pair_entry, entry);\n\n\treturn strcmp(a->path, b->path);\n}\n\nstatic void add_left_or_right(struct hashmap *map, const char *path,\n\t\t\t      const char *content, int is_right)\n{\n\tstruct pair_entry *e, *existing;\n\n\tFLEX_ALLOC_STR(e, path, path);\n\thashmap_entry_init(&e->entry, strhash(path));\n\texisting = hashmap_get_entry(map, e, entry, NULL);\n\tif (existing) {\n\t\tfree(e);\n\t\te = existing;\n\t} else {\n\t\te->left[0] = e->right[0] = '\\0';\n\t\thashmap_add(map, &e->entry);\n\t}\n\tstrlcpy(is_right ? e->right : e->left, content, PATH_MAX);\n}\n\nstruct path_entry {\n\tstruct hashmap_entry entry;\n\tchar path[FLEX_ARRAY];\n};\n\nstatic int path_entry_cmp(const void *cmp_data UNUSED,\n\t\t\t  const struct hashmap_entry *eptr,\n\t\t\t  const struct hashmap_entry *entry_or_key,\n\t\t\t  const void *key)\n{\n\tconst struct path_entry *a, *b;\n\n\ta = container_of(eptr, const struct path_entry, entry);\n\tb = container_of(entry_or_key, const struct path_entry, entry);\n\n\treturn strcmp(a->path, key ? key : b->path);\n}\n\nstatic void changed_files(struct hashmap *result, const char *index_path,\n\t\t\t  const char *workdir)\n{\n\tstruct child_process update_index = CHILD_PROCESS_INIT;\n\tstruct child_process diff_files = CHILD_PROCESS_INIT;\n\tstruct strbuf buf = STRBUF_INIT;\n\tconst char *git_dir = absolute_path(get_git_dir());\n\tFILE *fp;\n\n\tstrvec_pushl(&update_index.args,\n\t\t     \"--git-dir\", git_dir, \"--work-tree\", workdir,\n\t\t     \"update-index\", \"--really-refresh\", \"-q\",\n\t\t     \"--unmerged\", NULL);\n\tupdate_index.no_stdin = 1;\n\tupdate_index.no_stdout = 1;\n\tupdate_index.no_stderr = 1;\n\tupdate_index.git_cmd = 1;\n\tupdate_index.use_shell = 0;\n\tupdate_index.clean_on_exit = 1;\n\tupdate_index.dir = workdir;\n\tstrvec_pushf(&update_index.env, \"GIT_INDEX_FILE=%s\", index_path);\n\t/* Ignore any errors of update-index */\n\trun_command(&update_index);\n\n\tstrvec_pushl(&diff_files.args,\n\t\t     \"--git-dir\", git_dir, \"--work-tree\", workdir,\n\t\t     \"diff-files\", \"--name-only\", \"-z\", NULL);\n\tdiff_files.no_stdin = 1;\n\tdiff_files.git_cmd = 1;\n\tdiff_files.use_shell = 0;\n\tdiff_files.clean_on_exit = 1;\n\tdiff_files.out = -1;\n\tdiff_files.dir = workdir;\n\tstrvec_pushf(&diff_files.env, \"GIT_INDEX_FILE=%s\", index_path);\n\tif (start_command(&diff_files))\n\t\tdie(\"could not obtain raw diff\");\n\tfp = xfdopen(diff_files.out, \"r\");\n\twhile (!strbuf_getline_nul(&buf, fp)) {\n\t\tstruct path_entry *entry;\n\t\tFLEX_ALLOC_STR(entry, path, buf.buf);\n\t\thashmap_entry_init(&entry->entry, strhash(buf.buf));\n\t\thashmap_add(result, &entry->entry);\n\t}\n\tfclose(fp);\n\tif (finish_command(&diff_files))\n\t\tdie(\"diff-files did not exit properly\");\n\tstrbuf_release(&buf);\n}\n\nstatic int ensure_leading_directories(char *path)\n{\n\tswitch (safe_create_leading_directories(path)) {\n\t\tcase SCLD_OK:\n\t\tcase SCLD_EXISTS:\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn error(_(\"could not create leading directories \"\n\t\t\t\t       \"of '%s'\"), path);\n\t}\n}\n\n/*\n * Unconditional writing of a plain regular file is what\n * \"git difftool --dir-diff\" wants to do for symlinks.  We are preparing two\n * temporary directories to be fed to a Git-unaware tool that knows how to\n * show a diff of two directories (e.g. \"diff -r A B\").\n *\n * Because the tool is Git-unaware, if a symbolic link appears in either of\n * these temporary directories, it will try to dereference and show the\n * difference of the target of the symbolic link, which is not what we want,\n * as the goal of the dir-diff mode is to produce an output that is logically\n * equivalent to what \"git diff\" produces.\n *\n * Most importantly, we want to get textual comparison of the result of the\n * readlink(2).  get_symlink() provides that---it returns the contents of\n * the symlink that gets written to a regular file to force the external tool\n * to compare the readlink(2) result as text, even on a filesystem that is\n * capable of doing a symbolic link.\n */\nstatic char *get_symlink(const struct object_id *oid, const char *path)\n{\n\tchar *data;\n\tif (is_null_oid(oid)) {\n\t\t/* The symlink is unknown to Git so read from the filesystem */\n\t\tstruct strbuf link = STRBUF_INIT;\n\t\tif (has_symlinks) {\n\t\t\tif (strbuf_readlink(&link, path, strlen(path)))\n\t\t\t\tdie(_(\"could not read symlink %s\"), path);\n\t\t} else if (strbuf_read_file(&link, path, 128))\n\t\t\tdie(_(\"could not read symlink file %s\"), path);\n\n\t\tdata = strbuf_detach(&link, NULL);\n\t} else {\n\t\tenum object_type type;\n\t\tunsigned long size;\n\t\tdata = repo_read_object_file(the_repository, oid, &type,\n\t\t\t\t\t     &size);\n\t\tif (!data)\n\t\t\tdie(_(\"could not read object %s for symlink %s\"),\n\t\t\t\toid_to_hex(oid), path);\n\t}\n\n\treturn data;\n}\n\nstatic int checkout_path(unsigned mode, struct object_id *oid,\n\t\t\t const char *path, const struct checkout *state)\n{\n\tstruct cache_entry *ce;\n\tint ret;\n\n\tce = make_transient_cache_entry(mode, oid, path, 0, NULL);\n\tret = checkout_entry(ce, state, NULL, NULL);\n\n\tdiscard_cache_entry(ce);\n\treturn ret;\n}\n\nstatic void write_file_in_directory(struct strbuf *dir, size_t dir_len,\n\t\t\tconst char *path, const char *content)\n{\n\tadd_path(dir, dir_len, path);\n\tensure_leading_directories(dir->buf);\n\tunlink(dir->buf);\n\twrite_file(dir->buf, \"%s\", content);\n}\n\n/* Write the file contents for the left and right sides of the difftool\n * dir-diff representation for submodules and symlinks. Symlinks and submodules\n * are written as regular text files so that external diff tools can diff them\n * as text files, resulting in behavior that is analogous to to what \"git diff\"\n * displays for symlink and submodule diffs.\n */\nstatic void write_standin_files(struct pair_entry *entry,\n\t\t\tstruct strbuf *ldir, size_t ldir_len,\n\t\t\tstruct strbuf *rdir, size_t rdir_len)\n{\n\tif (*entry->left)\n\t\twrite_file_in_directory(ldir, ldir_len, entry->path, entry->left);\n\tif (*entry->right)\n\t\twrite_file_in_directory(rdir, rdir_len, entry->path, entry->right);\n}\n\nstatic int run_dir_diff(const char *extcmd, int symlinks, const char *prefix,\n\t\t\tstruct child_process *child)\n{\n\tstruct strbuf info = STRBUF_INIT, lpath = STRBUF_INIT;\n\tstruct strbuf rpath = STRBUF_INIT, buf = STRBUF_INIT;\n\tstruct strbuf ldir = STRBUF_INIT, rdir = STRBUF_INIT;\n\tstruct strbuf wtdir = STRBUF_INIT;\n\tstruct strbuf tmpdir = STRBUF_INIT;\n\tchar *lbase_dir = NULL, *rbase_dir = NULL;\n\tsize_t ldir_len, rdir_len, wtdir_len;\n\tconst char *workdir, *tmp;\n\tint ret = 0, i;\n\tFILE *fp = NULL;\n\tstruct hashmap working_tree_dups = HASHMAP_INIT(working_tree_entry_cmp,\n\t\t\t\t\t\t\tNULL);\n\tstruct hashmap submodules = HASHMAP_INIT(pair_cmp, NULL);\n\tstruct hashmap symlinks2 = HASHMAP_INIT(pair_cmp, NULL);\n\tstruct hashmap_iter iter;\n\tstruct pair_entry *entry;\n\tstruct index_state wtindex = INDEX_STATE_INIT(the_repository);\n\tstruct checkout lstate, rstate;\n\tint err = 0;\n\tstruct child_process cmd = CHILD_PROCESS_INIT;\n\tstruct hashmap wt_modified, tmp_modified;\n\tint indices_loaded = 0;\n\n\tworkdir = get_git_work_tree();\n\n\t/* Setup temp directories */\n\ttmp = getenv(\"TMPDIR\");\n\tstrbuf_add_absolute_path(&tmpdir, tmp ? tmp : \"/tmp\");\n\tstrbuf_trim_trailing_dir_sep(&tmpdir);\n\tstrbuf_addstr(&tmpdir, \"/git-difftool.XXXXXX\");\n\tif (!mkdtemp(tmpdir.buf)) {\n\t\tret = error(\"could not create '%s'\", tmpdir.buf);\n\t\tgoto finish;\n\t}\n\tstrbuf_addf(&ldir, \"%s/left/\", tmpdir.buf);\n\tstrbuf_addf(&rdir, \"%s/right/\", tmpdir.buf);\n\tstrbuf_addstr(&wtdir, workdir);\n\tif (!wtdir.len || !is_dir_sep(wtdir.buf[wtdir.len - 1]))\n\t\tstrbuf_addch(&wtdir, '/');\n\tmkdir(ldir.buf, 0700);\n\tmkdir(rdir.buf, 0700);\n\n\tmemset(&lstate, 0, sizeof(lstate));\n\tlstate.base_dir = lbase_dir = xstrdup(ldir.buf);\n\tlstate.base_dir_len = ldir.len;\n\tlstate.force = 1;\n\tmemset(&rstate, 0, sizeof(rstate));\n\trstate.base_dir = rbase_dir = xstrdup(rdir.buf);\n\trstate.base_dir_len = rdir.len;\n\trstate.force = 1;\n\n\tldir_len = ldir.len;\n\trdir_len = rdir.len;\n\twtdir_len = wtdir.len;\n\n\tchild->no_stdin = 1;\n\tchild->git_cmd = 1;\n\tchild->use_shell = 0;\n\tchild->clean_on_exit = 1;\n\tchild->dir = prefix;\n\tchild->out = -1;\n\tif (start_command(child))\n\t\tdie(\"could not obtain raw diff\");\n\tfp = xfdopen(child->out, \"r\");\n\n\t/* Build index info for left and right sides of the diff */\n\ti = 0;\n\twhile (!strbuf_getline_nul(&info, fp)) {\n\t\tint lmode, rmode;\n\t\tstruct object_id loid, roid;\n\t\tchar status;\n\t\tconst char *src_path, *dst_path;\n\n\t\tif (starts_with(info.buf, \"::\"))\n\t\t\tdie(N_(\"combined diff formats ('-c' and '--cc') are \"\n\t\t\t       \"not supported in\\n\"\n\t\t\t       \"directory diff mode ('-d' and '--dir-diff').\"));\n\n\t\tif (parse_index_info(info.buf, &lmode, &rmode, &loid, &roid,\n\t\t\t\t     &status))\n\t\t\tbreak;\n\t\tif (strbuf_getline_nul(&lpath, fp))\n\t\t\tbreak;\n\t\tsrc_path = lpath.buf;\n\n\t\ti++;\n\t\tif (status != 'C' && status != 'R') {\n\t\t\tdst_path = src_path;\n\t\t} else {\n\t\t\tif (strbuf_getline_nul(&rpath, fp))\n\t\t\t\tbreak;\n\t\t\tdst_path = rpath.buf;\n\t\t}\n\n\t\tif (S_ISGITLINK(lmode) || S_ISGITLINK(rmode)) {\n\t\t\tstrbuf_reset(&buf);\n\t\t\tstrbuf_addf(&buf, \"Subproject commit %s\",\n\t\t\t\t    oid_to_hex(&loid));\n\t\t\tadd_left_or_right(&submodules, src_path, buf.buf, 0);\n\t\t\tstrbuf_reset(&buf);\n\t\t\tstrbuf_addf(&buf, \"Subproject commit %s\",\n\t\t\t\t    oid_to_hex(&roid));\n\t\t\tif (oideq(&loid, &roid))\n\t\t\t\tstrbuf_addstr(&buf, \"-dirty\");\n\t\t\tadd_left_or_right(&submodules, dst_path, buf.buf, 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (S_ISLNK(lmode)) {\n\t\t\tchar *content = get_symlink(&loid, src_path);\n\t\t\tadd_left_or_right(&symlinks2, src_path, content, 0);\n\t\t\tfree(content);\n\t\t}\n\n\t\tif (S_ISLNK(rmode)) {\n\t\t\tchar *content = get_symlink(&roid, dst_path);\n\t\t\tadd_left_or_right(&symlinks2, dst_path, content, 1);\n\t\t\tfree(content);\n\t\t}\n\n\t\tif (lmode && status != 'C') {\n\t\t\tif (checkout_path(lmode, &loid, src_path, &lstate)) {\n\t\t\t\tret = error(\"could not write '%s'\", src_path);\n\t\t\t\tgoto finish;\n\t\t\t}\n\t\t}\n\n\t\tif (rmode && !S_ISLNK(rmode)) {\n\t\t\tstruct working_tree_entry *entry;\n\n\t\t\t/* Avoid duplicate working_tree entries */\n\t\t\tFLEX_ALLOC_STR(entry, path, dst_path);\n\t\t\thashmap_entry_init(&entry->entry, strhash(dst_path));\n\t\t\tif (hashmap_get(&working_tree_dups, &entry->entry,\n\t\t\t\t\tNULL)) {\n\t\t\t\tfree(entry);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\thashmap_add(&working_tree_dups, &entry->entry);\n\n\t\t\tif (!use_wt_file(workdir, dst_path, &roid)) {\n\t\t\t\tif (checkout_path(rmode, &roid, dst_path,\n\t\t\t\t\t\t  &rstate)) {\n\t\t\t\t\tret = error(\"could not write '%s'\",\n\t\t\t\t\t\t    dst_path);\n\t\t\t\t\tgoto finish;\n\t\t\t\t}\n\t\t\t} else if (!is_null_oid(&roid)) {\n\t\t\t\t/*\n\t\t\t\t * Changes in the working tree need special\n\t\t\t\t * treatment since they are not part of the\n\t\t\t\t * index.\n\t\t\t\t */\n\t\t\t\tstruct cache_entry *ce2 =\n\t\t\t\t\tmake_cache_entry(&wtindex, rmode, &roid,\n\t\t\t\t\t\t\t dst_path, 0, 0);\n\n\t\t\t\tadd_index_entry(&wtindex, ce2,\n\t\t\t\t\t\tADD_CACHE_JUST_APPEND);\n\n\t\t\t\tadd_path(&rdir, rdir_len, dst_path);\n\t\t\t\tif (ensure_leading_directories(rdir.buf)) {\n\t\t\t\t\tret = error(\"could not create \"\n\t\t\t\t\t\t    \"directory for '%s'\",\n\t\t\t\t\t\t    dst_path);\n\t\t\t\t\tgoto finish;\n\t\t\t\t}\n\t\t\t\tadd_path(&wtdir, wtdir_len, dst_path);\n\t\t\t\tif (symlinks) {\n\t\t\t\t\tif (symlink(wtdir.buf, rdir.buf)) {\n\t\t\t\t\t\tret = error_errno(\"could not symlink '%s' to '%s'\", wtdir.buf, rdir.buf);\n\t\t\t\t\t\tgoto finish;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tstruct stat st;\n\t\t\t\t\tif (stat(wtdir.buf, &st))\n\t\t\t\t\t\tst.st_mode = 0644;\n\t\t\t\t\tif (copy_file(rdir.buf, wtdir.buf,\n\t\t\t\t\t\t      st.st_mode)) {\n\t\t\t\t\t\tret = error(\"could not copy '%s' to '%s'\", wtdir.buf, rdir.buf);\n\t\t\t\t\t\tgoto finish;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfclose(fp);\n\tfp = NULL;\n\tif (finish_command(child)) {\n\t\tret = error(\"error occurred running diff --raw\");\n\t\tgoto finish;\n\t}\n\n\tif (!i)\n\t\tgoto finish;\n\n\t/*\n\t * Changes to submodules require special treatment.This loop writes a\n\t * temporary file to both the left and right directories to show the\n\t * change in the recorded SHA1 for the submodule.\n\t */\n\thashmap_for_each_entry(&submodules, &iter, entry,\n\t\t\t\tentry /* member name */) {\n\t\twrite_standin_files(entry, &ldir, ldir_len, &rdir, rdir_len);\n\t}\n\n\t/*\n\t * Symbolic links require special treatment. The standard \"git diff\"\n\t * shows only the link itself, not the contents of the link target.\n\t * This loop replicates that behavior.\n\t */\n\thashmap_for_each_entry(&symlinks2, &iter, entry,\n\t\t\t\tentry /* member name */) {\n\n\t\twrite_standin_files(entry, &ldir, ldir_len, &rdir, rdir_len);\n\t}\n\n\tstrbuf_setlen(&ldir, ldir_len);\n\tstrbuf_setlen(&rdir, rdir_len);\n\n\tif (extcmd) {\n\t\tstrvec_push(&cmd.args, extcmd);\n\t} else {\n\t\tstrvec_push(&cmd.args, \"difftool--helper\");\n\t\tcmd.git_cmd = 1;\n\t\tsetenv(\"GIT_DIFFTOOL_DIRDIFF\", \"true\", 1);\n\t}\n\tstrvec_pushl(&cmd.args, ldir.buf, rdir.buf, NULL);\n\tret = run_command(&cmd);\n\n\t/* TODO: audit for interaction with sparse-index. */\n\tensure_full_index(&wtindex);\n\n\t/*\n\t * If the diff includes working copy files and those\n\t * files were modified during the diff, then the changes\n\t * should be copied back to the working tree.\n\t * Do not copy back files when symlinks are used and the\n\t * external tool did not replace the original link with a file.\n\t *\n\t * These hashes are loaded lazily since they aren't needed\n\t * in the common case of --symlinks and the difftool updating\n\t * files through the symlink.\n\t */\n\thashmap_init(&wt_modified, path_entry_cmp, NULL, wtindex.cache_nr);\n\thashmap_init(&tmp_modified, path_entry_cmp, NULL, wtindex.cache_nr);\n\n\tfor (i = 0; i < wtindex.cache_nr; i++) {\n\t\tstruct hashmap_entry dummy;\n\t\tconst char *name = wtindex.cache[i]->name;\n\t\tstruct stat st;\n\n\t\tadd_path(&rdir, rdir_len, name);\n\t\tif (lstat(rdir.buf, &st))\n\t\t\tcontinue;\n\n\t\tif ((symlinks && S_ISLNK(st.st_mode)) || !S_ISREG(st.st_mode))\n\t\t\tcontinue;\n\n\t\tif (!indices_loaded) {\n\t\t\tstruct lock_file lock = LOCK_INIT;\n\t\t\tstrbuf_reset(&buf);\n\t\t\tstrbuf_addf(&buf, \"%s/wtindex\", tmpdir.buf);\n\t\t\tif (hold_lock_file_for_update(&lock, buf.buf, 0) < 0 ||\n\t\t\t    write_locked_index(&wtindex, &lock, COMMIT_LOCK)) {\n\t\t\t\tret = error(\"could not write %s\", buf.buf);\n\t\t\t\tgoto finish;\n\t\t\t}\n\t\t\tchanged_files(&wt_modified, buf.buf, workdir);\n\t\t\tstrbuf_setlen(&rdir, rdir_len);\n\t\t\tchanged_files(&tmp_modified, buf.buf, rdir.buf);\n\t\t\tadd_path(&rdir, rdir_len, name);\n\t\t\tindices_loaded = 1;\n\t\t}\n\n\t\thashmap_entry_init(&dummy, strhash(name));\n\t\tif (hashmap_get(&tmp_modified, &dummy, name)) {\n\t\t\tadd_path(&wtdir, wtdir_len, name);\n\t\t\tif (hashmap_get(&wt_modified, &dummy, name)) {\n\t\t\t\twarning(_(\"both files modified: '%s' and '%s'.\"),\n\t\t\t\t\twtdir.buf, rdir.buf);\n\t\t\t\twarning(_(\"working tree file has been left.\"));\n\t\t\t\twarning(\"%s\", \"\");\n\t\t\t\terr = 1;\n\t\t\t} else if (unlink(wtdir.buf) ||\n\t\t\t\t   copy_file(wtdir.buf, rdir.buf, st.st_mode))\n\t\t\t\twarning_errno(_(\"could not copy '%s' to '%s'\"),\n\t\t\t\t\t      rdir.buf, wtdir.buf);\n\t\t}\n\t}\n\n\tif (err) {\n\t\twarning(_(\"temporary files exist in '%s'.\"), tmpdir.buf);\n\t\twarning(_(\"you may want to cleanup or recover these.\"));\n\t\tret = 1;\n\t} else {\n\t\tremove_dir_recursively(&tmpdir, 0);\n\t\tif (ret)\n\t\t\twarning(_(\"failed: %d\"), ret);\n\t}\n\nfinish:\n\tif (fp)\n\t\tfclose(fp);\n\n\tfree(lbase_dir);\n\tfree(rbase_dir);\n\tstrbuf_release(&ldir);\n\tstrbuf_release(&rdir);\n\tstrbuf_release(&wtdir);\n\tstrbuf_release(&buf);\n\tstrbuf_release(&tmpdir);\n\n\treturn (ret < 0) ? 1 : ret;\n}\n\nstatic int run_file_diff(int prompt, const char *prefix,\n\t\t\t struct child_process *child)\n{\n\tconst char *env[] = {\n\t\t\"GIT_PAGER=\", \"GIT_EXTERNAL_DIFF=git-difftool--helper\", NULL,\n\t\tNULL\n\t};\n\n\tif (prompt > 0)\n\t\tenv[2] = \"GIT_DIFFTOOL_PROMPT=true\";\n\telse if (!prompt)\n\t\tenv[2] = \"GIT_DIFFTOOL_NO_PROMPT=true\";\n\n\tchild->git_cmd = 1;\n\tchild->dir = prefix;\n\tstrvec_pushv(&child->env, env);\n\n\treturn run_command(child);\n}\n\nint cmd_difftool(int argc, const char **argv, const char *prefix)\n{\n\tint use_gui_tool = -1, dir_diff = 0, prompt = -1, symlinks = 0,\n\t    tool_help = 0, no_index = 0;\n\tstatic char *difftool_cmd = NULL, *extcmd = NULL;\n\tstruct option builtin_difftool_options[] = {\n\t\tOPT_BOOL('g', \"gui\", &use_gui_tool,\n\t\t\t N_(\"use `diff.guitool` instead of `diff.tool`\")),\n\t\tOPT_BOOL('d', \"dir-diff\", &dir_diff,\n\t\t\t N_(\"perform a full-directory diff\")),\n\t\tOPT_SET_INT_F('y', \"no-prompt\", &prompt,\n\t\t\tN_(\"do not prompt before launching a diff tool\"),\n\t\t\t0, PARSE_OPT_NONEG),\n\t\tOPT_SET_INT_F(0, \"prompt\", &prompt, NULL,\n\t\t\t1, PARSE_OPT_NONEG | PARSE_OPT_HIDDEN),\n\t\tOPT_BOOL(0, \"symlinks\", &symlinks,\n\t\t\t N_(\"use symlinks in dir-diff mode\")),\n\t\tOPT_STRING('t', \"tool\", &difftool_cmd, N_(\"tool\"),\n\t\t\t   N_(\"use the specified diff tool\")),\n\t\tOPT_BOOL(0, \"tool-help\", &tool_help,\n\t\t\t N_(\"print a list of diff tools that may be used with \"\n\t\t\t    \"`--tool`\")),\n\t\tOPT_BOOL(0, \"trust-exit-code\", &trust_exit_code,\n\t\t\t N_(\"make 'git-difftool' exit when an invoked diff \"\n\t\t\t    \"tool returns a non-zero exit code\")),\n\t\tOPT_STRING('x', \"extcmd\", &extcmd, N_(\"command\"),\n\t\t\t   N_(\"specify a custom command for viewing diffs\")),\n\t\tOPT_BOOL(0, \"no-index\", &no_index, N_(\"passed to `diff`\")),\n\t\tOPT_END()\n\t};\n\tstruct child_process child = CHILD_PROCESS_INIT;\n\n\tgit_config(difftool_config, NULL);\n\tsymlinks = has_symlinks;\n\n\targc = parse_options(argc, argv, prefix, builtin_difftool_options,\n\t\t\t     builtin_difftool_usage, PARSE_OPT_KEEP_UNKNOWN_OPT |\n\t\t\t     PARSE_OPT_KEEP_DASHDASH);\n\n\tif (tool_help)\n\t\treturn print_tool_help();\n\n\tif (!no_index && !startup_info->have_repository)\n\t\tdie(_(\"difftool requires worktree or --no-index\"));\n\n\tif (!no_index){\n\t\tsetup_work_tree();\n\t\tsetenv(GIT_DIR_ENVIRONMENT, absolute_path(get_git_dir()), 1);\n\t\tsetenv(GIT_WORK_TREE_ENVIRONMENT, absolute_path(get_git_work_tree()), 1);\n\t} else if (dir_diff)\n\t\tdie(_(\"options '%s' and '%s' cannot be used together\"), \"--dir-diff\", \"--no-index\");\n\n\tdie_for_incompatible_opt3(use_gui_tool == 1, \"--gui\",\n\t\t\t\t  !!difftool_cmd, \"--tool\",\n\t\t\t\t  !!extcmd, \"--extcmd\");\n\n\t/*\n\t * Explicitly specified GUI option is forwarded to git-mergetool--lib.sh;\n\t * empty or unset means \"use the difftool.guiDefault config or default to\n\t * false\".\n\t */\n\tif (use_gui_tool == 1)\n\t\tsetenv(\"GIT_MERGETOOL_GUI\", \"true\", 1);\n\telse if (use_gui_tool == 0)\n\t\tsetenv(\"GIT_MERGETOOL_GUI\", \"false\", 1);\n\n\tif (difftool_cmd) {\n\t\tif (*difftool_cmd)\n\t\t\tsetenv(\"GIT_DIFF_TOOL\", difftool_cmd, 1);\n\t\telse\n\t\t\tdie(_(\"no <tool> given for --tool=<tool>\"));\n\t}\n\n\tif (extcmd) {\n\t\tif (*extcmd)\n\t\t\tsetenv(\"GIT_DIFFTOOL_EXTCMD\", extcmd, 1);\n\t\telse\n\t\t\tdie(_(\"no <cmd> given for --extcmd=<cmd>\"));\n\t}\n\n\tsetenv(\"GIT_DIFFTOOL_TRUST_EXIT_CODE\",\n\t       trust_exit_code ? \"true\" : \"false\", 1);\n\n\t/*\n\t * In directory diff mode, 'git-difftool--helper' is called once\n\t * to compare the a / b directories. In file diff mode, 'git diff'\n\t * will invoke a separate instance of 'git-difftool--helper' for\n\t * each file that changed.\n\t */\n\tstrvec_push(&child.args, \"diff\");\n\tif (no_index)\n\t\tstrvec_push(&child.args, \"--no-index\");\n\tif (dir_diff)\n\t\tstrvec_pushl(&child.args, \"--raw\", \"--no-abbrev\", \"-z\", NULL);\n\tstrvec_pushv(&child.args, argv);\n\n\tif (dir_diff)\n\t\treturn run_dir_diff(extcmd, symlinks, prefix, &child);\n\treturn run_file_diff(prompt, prefix, &child);\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0049342f5c0daf79f6818ac6dea89a8ea7692d8a",
  "sha1_ok": true,
  "size": 22925
}
