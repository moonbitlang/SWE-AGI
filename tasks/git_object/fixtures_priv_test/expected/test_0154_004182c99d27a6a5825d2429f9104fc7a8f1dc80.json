{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJibG9iLmgiCiNpbmNsdWRlICJkaXIuaCIKCnN0YXRpYyB2b2lkIGNyZWF0ZV9kaXJlY3Rvcmllcyhjb25zdCBjaGFyICpwYXRoLCBpbnQgcGF0aF9sZW4sCgkJCSAgICAgICBjb25zdCBzdHJ1Y3QgY2hlY2tvdXQgKnN0YXRlKQp7CgljaGFyICpidWYgPSB4bWFsbG9jKHBhdGhfbGVuICsgMSk7CglpbnQgbGVuID0gMDsKCgl3aGlsZSAobGVuIDwgcGF0aF9sZW4pIHsKCQlkbyB7CgkJCWJ1ZltsZW5dID0gcGF0aFtsZW5dOwoJCQlsZW4rKzsKCQl9IHdoaWxlIChsZW4gPCBwYXRoX2xlbiAmJiBwYXRoW2xlbl0gIT0gJy8nKTsKCQlpZiAobGVuID49IHBhdGhfbGVuKQoJCQlicmVhazsKCQlidWZbbGVuXSA9IDA7CgoJCS8qCgkJICogRm9yICdjaGVja291dC1pbmRleCAtLXByZWZpeD08ZGlyPicsIDxkaXI+IGlzCgkJICogYWxsb3dlZCB0byBiZSBhIHN5bWxpbmsgdG8gYW4gZXhpc3RpbmcgZGlyZWN0b3J5LAoJCSAqIGFuZCB3ZSBzZXQgJ3N0YXRlLT5iYXNlX2Rpcl9sZW4nIGJlbG93LCBzdWNoIHRoYXQKCQkgKiB3ZSB0ZXN0IHRoZSBwYXRoIGNvbXBvbmVudHMgb2YgdGhlIHByZWZpeCB3aXRoIHRoZQoJCSAqIHN0YXQoKSBmdW5jdGlvbiBpbnN0ZWFkIG9mIHRoZSBsc3RhdCgpIGZ1bmN0aW9uLgoJCSAqLwoJCWlmIChoYXNfZGlyc19vbmx5X3BhdGgoYnVmLCBsZW4sIHN0YXRlLT5iYXNlX2Rpcl9sZW4pKQoJCQljb250aW51ZTsgLyogb2ssIGl0IGlzIGFscmVhZHkgYSBkaXJlY3RvcnkuICovCgoJCS8qCgkJICogSWYgdGhpcyBta2RpcigpIHdvdWxkIGZhaWwsIGl0IGNvdWxkIGJlIHRoYXQgdGhlcmUKCQkgKiBpcyBhbHJlYWR5IGEgc3ltbGluayBvciBzb21ldGhpbmcgZWxzZSBleGlzdHMKCQkgKiB0aGVyZSwgdGhlcmVmb3JlIHdlIHRoZW4gdHJ5IHRvIHVubGluayBpdCBhbmQgdHJ5CgkJICogb25lIG1vcmUgdGltZSB0byBjcmVhdGUgdGhlIGRpcmVjdG9yeS4KCQkgKi8KCQlpZiAobWtkaXIoYnVmLCAwNzc3KSkgewoJCQlpZiAoZXJybm8gPT0gRUVYSVNUICYmIHN0YXRlLT5mb3JjZSAmJgoJCQkgICAgIXVubGlua19vcl93YXJuKGJ1ZikgJiYgIW1rZGlyKGJ1ZiwgMDc3NykpCgkJCQljb250aW51ZTsKCQkJZGllX2Vycm5vKCJjYW5ub3QgY3JlYXRlIGRpcmVjdG9yeSBhdCAnJXMnIiwgYnVmKTsKCQl9Cgl9CglmcmVlKGJ1Zik7Cn0KCnN0YXRpYyB2b2lkIHJlbW92ZV9zdWJ0cmVlKGNvbnN0IGNoYXIgKnBhdGgpCnsKCURJUiAqZGlyID0gb3BlbmRpcihwYXRoKTsKCXN0cnVjdCBkaXJlbnQgKmRlOwoJY2hhciBwYXRoYnVmW1BBVEhfTUFYXTsKCWNoYXIgKm5hbWU7CgoJaWYgKCFkaXIpCgkJZGllX2Vycm5vKCJjYW5ub3Qgb3BlbmRpciAnJXMnIiwgcGF0aCk7CglzdHJjcHkocGF0aGJ1ZiwgcGF0aCk7CgluYW1lID0gcGF0aGJ1ZiArIHN0cmxlbihwYXRoKTsKCSpuYW1lKysgPSAnLyc7Cgl3aGlsZSAoKGRlID0gcmVhZGRpcihkaXIpKSAhPSBOVUxMKSB7CgkJc3RydWN0IHN0YXQgc3Q7CgkJaWYgKGlzX2RvdF9vcl9kb3Rkb3QoZGUtPmRfbmFtZSkpCgkJCWNvbnRpbnVlOwoJCXN0cmNweShuYW1lLCBkZS0+ZF9uYW1lKTsKCQlpZiAobHN0YXQocGF0aGJ1ZiwgJnN0KSkKCQkJZGllX2Vycm5vKCJjYW5ub3QgbHN0YXQgJyVzJyIsIHBhdGhidWYpOwoJCWlmIChTX0lTRElSKHN0LnN0X21vZGUpKQoJCQlyZW1vdmVfc3VidHJlZShwYXRoYnVmKTsKCQllbHNlIGlmICh1bmxpbmsocGF0aGJ1ZikpCgkJCWRpZV9lcnJubygiY2Fubm90IHVubGluayAnJXMnIiwgcGF0aGJ1Zik7Cgl9CgljbG9zZWRpcihkaXIpOwoJaWYgKHJtZGlyKHBhdGgpKQoJCWRpZV9lcnJubygiY2Fubm90IHJtZGlyICclcyciLCBwYXRoKTsKfQoKc3RhdGljIGludCBjcmVhdGVfZmlsZShjb25zdCBjaGFyICpwYXRoLCB1bnNpZ25lZCBpbnQgbW9kZSkKewoJbW9kZSA9IChtb2RlICYgMDEwMCkgPyAwNzc3IDogMDY2NjsKCXJldHVybiBvcGVuKHBhdGgsIE9fV1JPTkxZIHwgT19DUkVBVCB8IE9fRVhDTCwgbW9kZSk7Cn0KCnN0YXRpYyB2b2lkICpyZWFkX2Jsb2JfZW50cnkoc3RydWN0IGNhY2hlX2VudHJ5ICpjZSwgdW5zaWduZWQgbG9uZyAqc2l6ZSkKewoJZW51bSBvYmplY3RfdHlwZSB0eXBlOwoJdm9pZCAqbmV3ID0gcmVhZF9zaGExX2ZpbGUoY2UtPnNoYTEsICZ0eXBlLCBzaXplKTsKCglpZiAobmV3KSB7CgkJaWYgKHR5cGUgPT0gT0JKX0JMT0IpCgkJCXJldHVybiBuZXc7CgkJZnJlZShuZXcpOwoJfQoJcmV0dXJuIE5VTEw7Cn0KCnN0YXRpYyBpbnQgd3JpdGVfZW50cnkoc3RydWN0IGNhY2hlX2VudHJ5ICpjZSwgY2hhciAqcGF0aCwgY29uc3Qgc3RydWN0IGNoZWNrb3V0ICpzdGF0ZSwgaW50IHRvX3RlbXBmaWxlKQp7Cgl1bnNpZ25lZCBpbnQgY2VfbW9kZV9zX2lmbXQgPSBjZS0+Y2VfbW9kZSAmIFNfSUZNVDsKCWludCBmZCwgcmV0LCBmc3RhdF9kb25lID0gMDsKCWNoYXIgKm5ldzsKCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7Cgl1bnNpZ25lZCBsb25nIHNpemU7CglzaXplX3Qgd3JvdGUsIG5ld3NpemUgPSAwOwoJc3RydWN0IHN0YXQgc3Q7CgoJc3dpdGNoIChjZV9tb2RlX3NfaWZtdCkgewoJY2FzZSBTX0lGUkVHOgoJY2FzZSBTX0lGTE5LOgoJCW5ldyA9IHJlYWRfYmxvYl9lbnRyeShjZSwgJnNpemUpOwoJCWlmICghbmV3KQoJCQlyZXR1cm4gZXJyb3IoImdpdCBjaGVja291dC1pbmRleDogdW5hYmxlIHRvIHJlYWQgc2hhMSBmaWxlIG9mICVzICglcykiLAoJCQkJcGF0aCwgc2hhMV90b19oZXgoY2UtPnNoYTEpKTsKCgkJaWYgKGNlX21vZGVfc19pZm10ID09IFNfSUZMTksgJiYgaGFzX3N5bWxpbmtzICYmICF0b190ZW1wZmlsZSkgewoJCQlyZXQgPSBzeW1saW5rKG5ldywgcGF0aCk7CgkJCWZyZWUobmV3KTsKCQkJaWYgKHJldCkKCQkJCXJldHVybiBlcnJvcigiZ2l0IGNoZWNrb3V0LWluZGV4OiB1bmFibGUgdG8gY3JlYXRlIHN5bWxpbmsgJXMgKCVzKSIsCgkJCQkJICAgICBwYXRoLCBzdHJlcnJvcihlcnJubykpOwoJCQlicmVhazsKCQl9CgoJCS8qCgkJICogQ29udmVydCBmcm9tIGdpdCBpbnRlcm5hbCBmb3JtYXQgdG8gd29ya2luZyB0cmVlIGZvcm1hdAoJCSAqLwoJCWlmIChjZV9tb2RlX3NfaWZtdCA9PSBTX0lGUkVHICYmCgkJICAgIGNvbnZlcnRfdG9fd29ya2luZ190cmVlKGNlLT5uYW1lLCBuZXcsIHNpemUsICZidWYpKSB7CgkJCWZyZWUobmV3KTsKCQkJbmV3ID0gc3RyYnVmX2RldGFjaCgmYnVmLCAmbmV3c2l6ZSk7CgkJCXNpemUgPSBuZXdzaXplOwoJCX0KCgkJaWYgKHRvX3RlbXBmaWxlKSB7CgkJCWlmIChjZV9tb2RlX3NfaWZtdCA9PSBTX0lGUkVHKQoJCQkJc3RyY3B5KHBhdGgsICIubWVyZ2VfZmlsZV9YWFhYWFgiKTsKCQkJZWxzZQoJCQkJc3RyY3B5KHBhdGgsICIubWVyZ2VfbGlua19YWFhYWFgiKTsKCQkJZmQgPSBta3N0ZW1wKHBhdGgpOwoJCX0gZWxzZSBpZiAoY2VfbW9kZV9zX2lmbXQgPT0gU19JRlJFRykgewoJCQlmZCA9IGNyZWF0ZV9maWxlKHBhdGgsIGNlLT5jZV9tb2RlKTsKCQl9IGVsc2UgewoJCQlmZCA9IGNyZWF0ZV9maWxlKHBhdGgsIDA2NjYpOwoJCX0KCQlpZiAoZmQgPCAwKSB7CgkJCWZyZWUobmV3KTsKCQkJcmV0dXJuIGVycm9yKCJnaXQgY2hlY2tvdXQtaW5kZXg6IHVuYWJsZSB0byBjcmVhdGUgZmlsZSAlcyAoJXMpIiwKCQkJCXBhdGgsIHN0cmVycm9yKGVycm5vKSk7CgkJfQoKCQl3cm90ZSA9IHdyaXRlX2luX2Z1bGwoZmQsIG5ldywgc2l6ZSk7CgkJLyogdXNlIGZzdGF0KCkgb25seSB3aGVuIHBhdGggPT0gY2UtPm5hbWUgKi8KCQlpZiAoZnN0YXRfaXNfcmVsaWFibGUoKSAmJgoJCSAgICBzdGF0ZS0+cmVmcmVzaF9jYWNoZSAmJiAhdG9fdGVtcGZpbGUgJiYgIXN0YXRlLT5iYXNlX2Rpcl9sZW4pIHsKCQkJZnN0YXQoZmQsICZzdCk7CgkJCWZzdGF0X2RvbmUgPSAxOwoJCX0KCQljbG9zZShmZCk7CgkJZnJlZShuZXcpOwoJCWlmICh3cm90ZSAhPSBzaXplKQoJCQlyZXR1cm4gZXJyb3IoImdpdCBjaGVja291dC1pbmRleDogdW5hYmxlIHRvIHdyaXRlIGZpbGUgJXMiLCBwYXRoKTsKCQlicmVhazsKCWNhc2UgU19JRkdJVExJTks6CgkJaWYgKHRvX3RlbXBmaWxlKQoJCQlyZXR1cm4gZXJyb3IoImdpdCBjaGVja291dC1pbmRleDogY2Fubm90IGNyZWF0ZSB0ZW1wb3Jhcnkgc3VicHJvamVjdCAlcyIsIHBhdGgpOwoJCWlmIChta2RpcihwYXRoLCAwNzc3KSA8IDApCgkJCXJldHVybiBlcnJvcigiZ2l0IGNoZWNrb3V0LWluZGV4OiBjYW5ub3QgY3JlYXRlIHN1YnByb2plY3QgZGlyZWN0b3J5ICVzIiwgcGF0aCk7CgkJYnJlYWs7CglkZWZhdWx0OgoJCXJldHVybiBlcnJvcigiZ2l0IGNoZWNrb3V0LWluZGV4OiB1bmtub3duIGZpbGUgbW9kZSBmb3IgJXMiLCBwYXRoKTsKCX0KCglpZiAoc3RhdGUtPnJlZnJlc2hfY2FjaGUpIHsKCQlpZiAoIWZzdGF0X2RvbmUpCgkJCWxzdGF0KGNlLT5uYW1lLCAmc3QpOwoJCWZpbGxfc3RhdF9jYWNoZV9pbmZvKGNlLCAmc3QpOwoJfQoJcmV0dXJuIDA7Cn0KCi8qCiAqIFRoaXMgaXMgbGlrZSAnbHN0YXQoKScsIGV4Y2VwdCBpdCByZWZ1c2VzIHRvIGZvbGxvdyBzeW1saW5rcwogKiBpbiB0aGUgcGF0aCwgYWZ0ZXIgc2tpcHBpbmcgInNraXBsZW4iLgogKi8Kc3RhdGljIGludCBjaGVja19wYXRoKGNvbnN0IGNoYXIgKnBhdGgsIGludCBsZW4sIHN0cnVjdCBzdGF0ICpzdCwgaW50IHNraXBsZW4pCnsKCWNvbnN0IGNoYXIgKnNsYXNoID0gcGF0aCArIGxlbjsKCgl3aGlsZSAocGF0aCA8IHNsYXNoICYmICpzbGFzaCAhPSAnLycpCgkJc2xhc2gtLTsKCWlmICghaGFzX2RpcnNfb25seV9wYXRoKHBhdGgsIHNsYXNoIC0gcGF0aCwgc2tpcGxlbikpIHsKCQllcnJubyA9IEVOT0VOVDsKCQlyZXR1cm4gLTE7Cgl9CglyZXR1cm4gbHN0YXQocGF0aCwgc3QpOwp9CgppbnQgY2hlY2tvdXRfZW50cnkoc3RydWN0IGNhY2hlX2VudHJ5ICpjZSwgY29uc3Qgc3RydWN0IGNoZWNrb3V0ICpzdGF0ZSwgY2hhciAqdG9wYXRoKQp7CglzdGF0aWMgY2hhciBwYXRoW1BBVEhfTUFYICsgMV07CglzdHJ1Y3Qgc3RhdCBzdDsKCWludCBsZW4gPSBzdGF0ZS0+YmFzZV9kaXJfbGVuOwoKCWlmICh0b3BhdGgpCgkJcmV0dXJuIHdyaXRlX2VudHJ5KGNlLCB0b3BhdGgsIHN0YXRlLCAxKTsKCgltZW1jcHkocGF0aCwgc3RhdGUtPmJhc2VfZGlyLCBsZW4pOwoJc3RyY3B5KHBhdGggKyBsZW4sIGNlLT5uYW1lKTsKCWxlbiArPSBjZV9uYW1lbGVuKGNlKTsKCglpZiAoIWNoZWNrX3BhdGgocGF0aCwgbGVuLCAmc3QsIHN0YXRlLT5iYXNlX2Rpcl9sZW4pKSB7CgkJdW5zaWduZWQgY2hhbmdlZCA9IGNlX21hdGNoX3N0YXQoY2UsICZzdCwgQ0VfTUFUQ0hfSUdOT1JFX1ZBTElEfENFX01BVENIX0lHTk9SRV9TS0lQX1dPUktUUkVFKTsKCQlpZiAoIWNoYW5nZWQpCgkJCXJldHVybiAwOwoJCWlmICghc3RhdGUtPmZvcmNlKSB7CgkJCWlmICghc3RhdGUtPnF1aWV0KQoJCQkJZnByaW50ZihzdGRlcnIsICJnaXQtY2hlY2tvdXQtaW5kZXg6ICVzIGFscmVhZHkgZXhpc3RzXG4iLCBwYXRoKTsKCQkJcmV0dXJuIC0xOwoJCX0KCgkJLyoKCQkgKiBXZSB1bmxpbmsgdGhlIG9sZCBmaWxlLCB0byBnZXQgdGhlIG5ldyBvbmUgd2l0aCB0aGUKCQkgKiByaWdodCBwZXJtaXNzaW9ucyAoaW5jbHVkaW5nIHVtYXNrLCB3aGljaCBpcyBuYXN0eQoJCSAqIHRvIGVtdWxhdGUgYnkgaGFuZCAtIG11Y2ggZWFzaWVyIHRvIGxldCB0aGUgc3lzdGVtCgkJICoganVzdCBkbyB0aGUgcmlnaHQgdGhpbmcpCgkJICovCgkJaWYgKFNfSVNESVIoc3Quc3RfbW9kZSkpIHsKCQkJLyogSWYgaXQgaXMgYSBnaXRsaW5rLCBsZWF2ZSBpdCBhbG9uZSEgKi8KCQkJaWYgKFNfSVNHSVRMSU5LKGNlLT5jZV9tb2RlKSkKCQkJCXJldHVybiAwOwoJCQlpZiAoIXN0YXRlLT5mb3JjZSkKCQkJCXJldHVybiBlcnJvcigiJXMgaXMgYSBkaXJlY3RvcnkiLCBwYXRoKTsKCQkJcmVtb3ZlX3N1YnRyZWUocGF0aCk7CgkJfSBlbHNlIGlmICh1bmxpbmsocGF0aCkpCgkJCXJldHVybiBlcnJvcigidW5hYmxlIHRvIHVubGluayBvbGQgJyVzJyAoJXMpIiwgcGF0aCwgc3RyZXJyb3IoZXJybm8pKTsKCX0gZWxzZSBpZiAoc3RhdGUtPm5vdF9uZXcpCgkJcmV0dXJuIDA7CgljcmVhdGVfZGlyZWN0b3JpZXMocGF0aCwgbGVuLCBzdGF0ZSk7CglyZXR1cm4gd3JpdGVfZW50cnkoY2UsIHBhdGgsIHN0YXRlLCAwKTsKfQo=",
    "text": "#include \"cache.h\"\n#include \"blob.h\"\n#include \"dir.h\"\n\nstatic void create_directories(const char *path, int path_len,\n\t\t\t       const struct checkout *state)\n{\n\tchar *buf = xmalloc(path_len + 1);\n\tint len = 0;\n\n\twhile (len < path_len) {\n\t\tdo {\n\t\t\tbuf[len] = path[len];\n\t\t\tlen++;\n\t\t} while (len < path_len && path[len] != '/');\n\t\tif (len >= path_len)\n\t\t\tbreak;\n\t\tbuf[len] = 0;\n\n\t\t/*\n\t\t * For 'checkout-index --prefix=<dir>', <dir> is\n\t\t * allowed to be a symlink to an existing directory,\n\t\t * and we set 'state->base_dir_len' below, such that\n\t\t * we test the path components of the prefix with the\n\t\t * stat() function instead of the lstat() function.\n\t\t */\n\t\tif (has_dirs_only_path(buf, len, state->base_dir_len))\n\t\t\tcontinue; /* ok, it is already a directory. */\n\n\t\t/*\n\t\t * If this mkdir() would fail, it could be that there\n\t\t * is already a symlink or something else exists\n\t\t * there, therefore we then try to unlink it and try\n\t\t * one more time to create the directory.\n\t\t */\n\t\tif (mkdir(buf, 0777)) {\n\t\t\tif (errno == EEXIST && state->force &&\n\t\t\t    !unlink_or_warn(buf) && !mkdir(buf, 0777))\n\t\t\t\tcontinue;\n\t\t\tdie_errno(\"cannot create directory at '%s'\", buf);\n\t\t}\n\t}\n\tfree(buf);\n}\n\nstatic void remove_subtree(const char *path)\n{\n\tDIR *dir = opendir(path);\n\tstruct dirent *de;\n\tchar pathbuf[PATH_MAX];\n\tchar *name;\n\n\tif (!dir)\n\t\tdie_errno(\"cannot opendir '%s'\", path);\n\tstrcpy(pathbuf, path);\n\tname = pathbuf + strlen(path);\n\t*name++ = '/';\n\twhile ((de = readdir(dir)) != NULL) {\n\t\tstruct stat st;\n\t\tif (is_dot_or_dotdot(de->d_name))\n\t\t\tcontinue;\n\t\tstrcpy(name, de->d_name);\n\t\tif (lstat(pathbuf, &st))\n\t\t\tdie_errno(\"cannot lstat '%s'\", pathbuf);\n\t\tif (S_ISDIR(st.st_mode))\n\t\t\tremove_subtree(pathbuf);\n\t\telse if (unlink(pathbuf))\n\t\t\tdie_errno(\"cannot unlink '%s'\", pathbuf);\n\t}\n\tclosedir(dir);\n\tif (rmdir(path))\n\t\tdie_errno(\"cannot rmdir '%s'\", path);\n}\n\nstatic int create_file(const char *path, unsigned int mode)\n{\n\tmode = (mode & 0100) ? 0777 : 0666;\n\treturn open(path, O_WRONLY | O_CREAT | O_EXCL, mode);\n}\n\nstatic void *read_blob_entry(struct cache_entry *ce, unsigned long *size)\n{\n\tenum object_type type;\n\tvoid *new = read_sha1_file(ce->sha1, &type, size);\n\n\tif (new) {\n\t\tif (type == OBJ_BLOB)\n\t\t\treturn new;\n\t\tfree(new);\n\t}\n\treturn NULL;\n}\n\nstatic int write_entry(struct cache_entry *ce, char *path, const struct checkout *state, int to_tempfile)\n{\n\tunsigned int ce_mode_s_ifmt = ce->ce_mode & S_IFMT;\n\tint fd, ret, fstat_done = 0;\n\tchar *new;\n\tstruct strbuf buf = STRBUF_INIT;\n\tunsigned long size;\n\tsize_t wrote, newsize = 0;\n\tstruct stat st;\n\n\tswitch (ce_mode_s_ifmt) {\n\tcase S_IFREG:\n\tcase S_IFLNK:\n\t\tnew = read_blob_entry(ce, &size);\n\t\tif (!new)\n\t\t\treturn error(\"git checkout-index: unable to read sha1 file of %s (%s)\",\n\t\t\t\tpath, sha1_to_hex(ce->sha1));\n\n\t\tif (ce_mode_s_ifmt == S_IFLNK && has_symlinks && !to_tempfile) {\n\t\t\tret = symlink(new, path);\n\t\t\tfree(new);\n\t\t\tif (ret)\n\t\t\t\treturn error(\"git checkout-index: unable to create symlink %s (%s)\",\n\t\t\t\t\t     path, strerror(errno));\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Convert from git internal format to working tree format\n\t\t */\n\t\tif (ce_mode_s_ifmt == S_IFREG &&\n\t\t    convert_to_working_tree(ce->name, new, size, &buf)) {\n\t\t\tfree(new);\n\t\t\tnew = strbuf_detach(&buf, &newsize);\n\t\t\tsize = newsize;\n\t\t}\n\n\t\tif (to_tempfile) {\n\t\t\tif (ce_mode_s_ifmt == S_IFREG)\n\t\t\t\tstrcpy(path, \".merge_file_XXXXXX\");\n\t\t\telse\n\t\t\t\tstrcpy(path, \".merge_link_XXXXXX\");\n\t\t\tfd = mkstemp(path);\n\t\t} else if (ce_mode_s_ifmt == S_IFREG) {\n\t\t\tfd = create_file(path, ce->ce_mode);\n\t\t} else {\n\t\t\tfd = create_file(path, 0666);\n\t\t}\n\t\tif (fd < 0) {\n\t\t\tfree(new);\n\t\t\treturn error(\"git checkout-index: unable to create file %s (%s)\",\n\t\t\t\tpath, strerror(errno));\n\t\t}\n\n\t\twrote = write_in_full(fd, new, size);\n\t\t/* use fstat() only when path == ce->name */\n\t\tif (fstat_is_reliable() &&\n\t\t    state->refresh_cache && !to_tempfile && !state->base_dir_len) {\n\t\t\tfstat(fd, &st);\n\t\t\tfstat_done = 1;\n\t\t}\n\t\tclose(fd);\n\t\tfree(new);\n\t\tif (wrote != size)\n\t\t\treturn error(\"git checkout-index: unable to write file %s\", path);\n\t\tbreak;\n\tcase S_IFGITLINK:\n\t\tif (to_tempfile)\n\t\t\treturn error(\"git checkout-index: cannot create temporary subproject %s\", path);\n\t\tif (mkdir(path, 0777) < 0)\n\t\t\treturn error(\"git checkout-index: cannot create subproject directory %s\", path);\n\t\tbreak;\n\tdefault:\n\t\treturn error(\"git checkout-index: unknown file mode for %s\", path);\n\t}\n\n\tif (state->refresh_cache) {\n\t\tif (!fstat_done)\n\t\t\tlstat(ce->name, &st);\n\t\tfill_stat_cache_info(ce, &st);\n\t}\n\treturn 0;\n}\n\n/*\n * This is like 'lstat()', except it refuses to follow symlinks\n * in the path, after skipping \"skiplen\".\n */\nstatic int check_path(const char *path, int len, struct stat *st, int skiplen)\n{\n\tconst char *slash = path + len;\n\n\twhile (path < slash && *slash != '/')\n\t\tslash--;\n\tif (!has_dirs_only_path(path, slash - path, skiplen)) {\n\t\terrno = ENOENT;\n\t\treturn -1;\n\t}\n\treturn lstat(path, st);\n}\n\nint checkout_entry(struct cache_entry *ce, const struct checkout *state, char *topath)\n{\n\tstatic char path[PATH_MAX + 1];\n\tstruct stat st;\n\tint len = state->base_dir_len;\n\n\tif (topath)\n\t\treturn write_entry(ce, topath, state, 1);\n\n\tmemcpy(path, state->base_dir, len);\n\tstrcpy(path + len, ce->name);\n\tlen += ce_namelen(ce);\n\n\tif (!check_path(path, len, &st, state->base_dir_len)) {\n\t\tunsigned changed = ce_match_stat(ce, &st, CE_MATCH_IGNORE_VALID|CE_MATCH_IGNORE_SKIP_WORKTREE);\n\t\tif (!changed)\n\t\t\treturn 0;\n\t\tif (!state->force) {\n\t\t\tif (!state->quiet)\n\t\t\t\tfprintf(stderr, \"git-checkout-index: %s already exists\\n\", path);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * We unlink the old file, to get the new one with the\n\t\t * right permissions (including umask, which is nasty\n\t\t * to emulate by hand - much easier to let the system\n\t\t * just do the right thing)\n\t\t */\n\t\tif (S_ISDIR(st.st_mode)) {\n\t\t\t/* If it is a gitlink, leave it alone! */\n\t\t\tif (S_ISGITLINK(ce->ce_mode))\n\t\t\t\treturn 0;\n\t\t\tif (!state->force)\n\t\t\t\treturn error(\"%s is a directory\", path);\n\t\t\tremove_subtree(path);\n\t\t} else if (unlink(path))\n\t\t\treturn error(\"unable to unlink old '%s' (%s)\", path, strerror(errno));\n\t} else if (state->not_new)\n\t\treturn 0;\n\tcreate_directories(path, len, state);\n\treturn write_entry(ce, path, state, 0);\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "004182c99d27a6a5825d2429f9104fc7a8f1dc80",
  "sha1_ok": true,
  "size": 6182
}
