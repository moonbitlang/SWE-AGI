{
  "content": {
    "base64": "I2luY2x1ZGUgImdpdC1jb21wYXQtdXRpbC5oIgojaW5jbHVkZSAiYWJzcGF0aC5oIgojaW5jbHVkZSAiY29tbWl0LWdyYXBoLmgiCiNpbmNsdWRlICJjb25maWcuaCIKI2luY2x1ZGUgImRpci5oIgojaW5jbHVkZSAiZW52aXJvbm1lbnQuaCIKI2luY2x1ZGUgImdldHRleHQuaCIKI2luY2x1ZGUgImhleC5oIgojaW5jbHVkZSAia2hhc2guaCIKI2luY2x1ZGUgImxvY2tmaWxlLmgiCiNpbmNsdWRlICJsb29zZS5oIgojaW5jbHVkZSAib2JqZWN0LWZpbGUtY29udmVydC5oIgojaW5jbHVkZSAib2JqZWN0LWZpbGUuaCIKI2luY2x1ZGUgIm9kYi5oIgojaW5jbHVkZSAicGFja2ZpbGUuaCIKI2luY2x1ZGUgInBhdGguaCIKI2luY2x1ZGUgInByb21pc29yLXJlbW90ZS5oIgojaW5jbHVkZSAicXVvdGUuaCIKI2luY2x1ZGUgInJlcGxhY2Utb2JqZWN0LmgiCiNpbmNsdWRlICJydW4tY29tbWFuZC5oIgojaW5jbHVkZSAic2V0dXAuaCIKI2luY2x1ZGUgInN0cmJ1Zi5oIgojaW5jbHVkZSAic3RydmVjLmgiCiNpbmNsdWRlICJzdWJtb2R1bGUuaCIKI2luY2x1ZGUgInRyYWNlMi5oIgojaW5jbHVkZSAid3JpdGUtb3ItZGllLmgiCgpLSEFTSF9JTklUKG9kYl9wYXRoX21hcCwgY29uc3QgY2hhciAqIC8qIGtleTogb2RiX3BhdGggKi8sCglzdHJ1Y3Qgb2RiX3NvdXJjZSAqLCAxLCBmc3BhdGhoYXNoLCBmc3BhdGhlcSkKCi8qCiAqIFRoaXMgaXMgbWVhbnQgdG8gaG9sZCBhICpzbWFsbCogbnVtYmVyIG9mIG9iamVjdHMgdGhhdCB5b3Ugd291bGQKICogd2FudCBvZGJfcmVhZF9vYmplY3QoKSB0byBiZSBhYmxlIHRvIHJldHVybiwgYnV0IHlldCB5b3UgZG8gbm90IHdhbnQKICogdG8gd3JpdGUgdGhlbSBpbnRvIHRoZSBvYmplY3Qgc3RvcmUgKGUuZy4gYSBicm93c2Utb25seQogKiBhcHBsaWNhdGlvbikuCiAqLwpzdHJ1Y3QgY2FjaGVkX29iamVjdF9lbnRyeSB7CglzdHJ1Y3Qgb2JqZWN0X2lkIG9pZDsKCXN0cnVjdCBjYWNoZWRfb2JqZWN0IHsKCQllbnVtIG9iamVjdF90eXBlIHR5cGU7CgkJY29uc3Qgdm9pZCAqYnVmOwoJCXVuc2lnbmVkIGxvbmcgc2l6ZTsKCX0gdmFsdWU7Cn07CgpzdGF0aWMgY29uc3Qgc3RydWN0IGNhY2hlZF9vYmplY3QgKmZpbmRfY2FjaGVkX29iamVjdChzdHJ1Y3Qgb2JqZWN0X2RhdGFiYXNlICpvYmplY3Rfc3RvcmUsCgkJCQkJCSAgICAgIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCkKewoJc3RhdGljIGNvbnN0IHN0cnVjdCBjYWNoZWRfb2JqZWN0IGVtcHR5X3RyZWUgPSB7CgkJLnR5cGUgPSBPQkpfVFJFRSwKCQkuYnVmID0gIiIsCgl9OwoJY29uc3Qgc3RydWN0IGNhY2hlZF9vYmplY3RfZW50cnkgKmNvID0gb2JqZWN0X3N0b3JlLT5jYWNoZWRfb2JqZWN0czsKCglmb3IgKHNpemVfdCBpID0gMDsgaSA8IG9iamVjdF9zdG9yZS0+Y2FjaGVkX29iamVjdF9ucjsgaSsrLCBjbysrKQoJCWlmIChvaWRlcSgmY28tPm9pZCwgb2lkKSkKCQkJcmV0dXJuICZjby0+dmFsdWU7CgoJaWYgKG9pZC0+YWxnbyAmJiBvaWRlcShvaWQsIGhhc2hfYWxnb3Nbb2lkLT5hbGdvXS5lbXB0eV90cmVlKSkKCQlyZXR1cm4gJmVtcHR5X3RyZWU7CgoJcmV0dXJuIE5VTEw7Cn0KCmludCBvZGJfbWtzdGVtcChzdHJ1Y3Qgb2JqZWN0X2RhdGFiYXNlICpvZGIsCgkJc3RydWN0IHN0cmJ1ZiAqdGVtcF9maWxlbmFtZSwgY29uc3QgY2hhciAqcGF0dGVybikKewoJaW50IGZkOwoJLyoKCSAqIHdlIGxldCB0aGUgdW1hc2sgZG8gaXRzIGpvYiwgZG9uJ3QgdHJ5IHRvIGJlIG1vcmUKCSAqIHJlc3RyaWN0aXZlIGV4Y2VwdCB0byByZW1vdmUgd3JpdGUgcGVybWlzc2lvbi4KCSAqLwoJaW50IG1vZGUgPSAwNDQ0OwoJcmVwb19naXRfcGF0aF9yZXBsYWNlKG9kYi0+cmVwbywgdGVtcF9maWxlbmFtZSwgIm9iamVjdHMvJXMiLCBwYXR0ZXJuKTsKCWZkID0gZ2l0X21rc3RlbXBfbW9kZSh0ZW1wX2ZpbGVuYW1lLT5idWYsIG1vZGUpOwoJaWYgKDAgPD0gZmQpCgkJcmV0dXJuIGZkOwoKCS8qIHNsb3cgcGF0aCAqLwoJLyogc29tZSBta3N0ZW1wIGltcGxlbWVudGF0aW9ucyBlcmFzZSB0ZW1wX2ZpbGVuYW1lIG9uIGZhaWx1cmUgKi8KCXJlcG9fZ2l0X3BhdGhfcmVwbGFjZShvZGItPnJlcG8sIHRlbXBfZmlsZW5hbWUsICJvYmplY3RzLyVzIiwgcGF0dGVybik7CglzYWZlX2NyZWF0ZV9sZWFkaW5nX2RpcmVjdG9yaWVzKG9kYi0+cmVwbywgdGVtcF9maWxlbmFtZS0+YnVmKTsKCXJldHVybiB4bWtzdGVtcF9tb2RlKHRlbXBfZmlsZW5hbWUtPmJ1ZiwgbW9kZSk7Cn0KCi8qCiAqIFJldHVybiBub24temVybyBpZmYgdGhlIHBhdGggaXMgdXNhYmxlIGFzIGFuIGFsdGVybmF0ZSBvYmplY3QgZGF0YWJhc2UuCiAqLwpzdGF0aWMgaW50IGFsdF9vZGJfdXNhYmxlKHN0cnVjdCBvYmplY3RfZGF0YWJhc2UgKm8sCgkJCSAgc3RydWN0IHN0cmJ1ZiAqcGF0aCwKCQkJICBjb25zdCBjaGFyICpub3JtYWxpemVkX29iamRpciwga2hpdGVyX3QgKnBvcykKewoJaW50IHI7CgoJLyogRGV0ZWN0IGNhc2VzIHdoZXJlIGFsdGVybmF0ZSBkaXNhcHBlYXJlZCAqLwoJaWYgKCFpc19kaXJlY3RvcnkocGF0aC0+YnVmKSkgewoJCWVycm9yKF8oIm9iamVjdCBkaXJlY3RvcnkgJXMgZG9lcyBub3QgZXhpc3Q7ICIKCQkJImNoZWNrIC5naXQvb2JqZWN0cy9pbmZvL2FsdGVybmF0ZXMiKSwKCQkgICAgICBwYXRoLT5idWYpOwoJCXJldHVybiAwOwoJfQoKCS8qCgkgKiBQcmV2ZW50IHRoZSBjb21tb24gbWlzdGFrZSBvZiBsaXN0aW5nIHRoZSBzYW1lCgkgKiB0aGluZyB0d2ljZSwgb3Igb2JqZWN0IGRpcmVjdG9yeSBpdHNlbGYuCgkgKi8KCWlmICghby0+c291cmNlX2J5X3BhdGgpIHsKCQlraGl0ZXJfdCBwOwoKCQlvLT5zb3VyY2VfYnlfcGF0aCA9IGtoX2luaXRfb2RiX3BhdGhfbWFwKCk7CgkJYXNzZXJ0KCFvLT5zb3VyY2VzLT5uZXh0KTsKCQlwID0ga2hfcHV0X29kYl9wYXRoX21hcChvLT5zb3VyY2VfYnlfcGF0aCwgby0+c291cmNlcy0+cGF0aCwgJnIpOwoJCWFzc2VydChyID09IDEpOyAvKiBuZXZlciB1c2VkICovCgkJa2hfdmFsdWUoby0+c291cmNlX2J5X3BhdGgsIHApID0gby0+c291cmNlczsKCX0KCWlmIChmc3BhdGhlcShwYXRoLT5idWYsIG5vcm1hbGl6ZWRfb2JqZGlyKSkKCQlyZXR1cm4gMDsKCSpwb3MgPSBraF9wdXRfb2RiX3BhdGhfbWFwKG8tPnNvdXJjZV9ieV9wYXRoLCBwYXRoLT5idWYsICZyKTsKCS8qIHI6IDAgPSBleGlzdHMsIDEgPSBuZXZlciB1c2VkLCAyID0gZGVsZXRlZCAqLwoJcmV0dXJuIHIgPT0gMCA/IDAgOiAxOwp9CgovKgogKiBQcmVwYXJlIGFsdGVybmF0ZSBvYmplY3QgZGF0YWJhc2UgcmVnaXN0cnkuCiAqCiAqIFRoZSB2YXJpYWJsZSBhbHRfb2RiX2xpc3QgcG9pbnRzIGF0IHRoZSBsaXN0IG9mIHN0cnVjdAogKiBvZGJfc291cmNlLiAgVGhlIGVsZW1lbnRzIG9uIHRoaXMgbGlzdCBjb21lIGZyb20KICogbm9uLWVtcHR5IGVsZW1lbnRzIGZyb20gY29sb24gc2VwYXJhdGVkIEFMVEVSTkFURV9EQl9FTlZJUk9OTUVOVAogKiBlbnZpcm9ubWVudCB2YXJpYWJsZSwgYW5kICRHSVRfT0JKRUNUX0RJUkVDVE9SWS9pbmZvL2FsdGVybmF0ZXMsCiAqIHdob3NlIGNvbnRlbnRzIGlzIHNpbWlsYXIgdG8gdGhhdCBlbnZpcm9ubWVudCB2YXJpYWJsZSBidXQgY2FuIGJlCiAqIExGIHNlcGFyYXRlZC4gIEl0cyBiYXNlIHBvaW50cyBhdCBhIHN0YXRpY2FsbHkgYWxsb2NhdGVkIGJ1ZmZlciB0aGF0CiAqIGNvbnRhaW5zICIvdGhlL2RpcmVjdG9yeS9jb3JyZXNwb25kaW5nL3RvLy5naXQvb2JqZWN0cy8uLi4iLCB3aGlsZQogKiBpdHMgbmFtZSBwb2ludHMganVzdCBhZnRlciB0aGUgc2xhc2ggYXQgdGhlIGVuZCBvZiAiLmdpdC9vYmplY3RzLyIKICogaW4gdGhlIGV4YW1wbGUgYWJvdmUsIGFuZCBoYXMgZW5vdWdoIHNwYWNlIHRvIGhvbGQgYWxsIGhleCBjaGFyYWN0ZXJzCiAqIG9mIHRoZSBvYmplY3QgSUQsIGFuIGV4dHJhIHNsYXNoIGZvciB0aGUgZmlyc3QgbGV2ZWwgaW5kaXJlY3Rpb24sIGFuZAogKiB0aGUgdGVybWluYXRpbmcgTlVMLgogKi8Kc3RhdGljIHZvaWQgcmVhZF9pbmZvX2FsdGVybmF0ZXMoc3RydWN0IG9iamVjdF9kYXRhYmFzZSAqb2RiLAoJCQkJIGNvbnN0IGNoYXIgKnJlbGF0aXZlX2Jhc2UsCgkJCQkgaW50IGRlcHRoKTsKCnN0YXRpYyBzdHJ1Y3Qgb2RiX3NvdXJjZSAqbGlua19hbHRfb2RiX2VudHJ5KHN0cnVjdCBvYmplY3RfZGF0YWJhc2UgKm9kYiwKCQkJCQkgICAgIGNvbnN0IGNoYXIgKmRpciwKCQkJCQkgICAgIGNvbnN0IGNoYXIgKnJlbGF0aXZlX2Jhc2UsCgkJCQkJICAgICBpbnQgZGVwdGgpCnsKCXN0cnVjdCBvZGJfc291cmNlICphbHRlcm5hdGUgPSBOVUxMOwoJc3RydWN0IHN0cmJ1ZiBwYXRoYnVmID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3Qgc3RyYnVmIHRtcCA9IFNUUkJVRl9JTklUOwoJa2hpdGVyX3QgcG9zOwoKCWlmICghaXNfYWJzb2x1dGVfcGF0aChkaXIpICYmIHJlbGF0aXZlX2Jhc2UpIHsKCQlzdHJidWZfcmVhbHBhdGgoJnBhdGhidWYsIHJlbGF0aXZlX2Jhc2UsIDEpOwoJCXN0cmJ1Zl9hZGRjaCgmcGF0aGJ1ZiwgJy8nKTsKCX0KCXN0cmJ1Zl9hZGRzdHIoJnBhdGhidWYsIGRpcik7CgoJaWYgKCFzdHJidWZfcmVhbHBhdGgoJnRtcCwgcGF0aGJ1Zi5idWYsIDApKSB7CgkJZXJyb3IoXygidW5hYmxlIHRvIG5vcm1hbGl6ZSBhbHRlcm5hdGUgb2JqZWN0IHBhdGg6ICVzIiksCgkJICAgICAgcGF0aGJ1Zi5idWYpOwoJCWdvdG8gZXJyb3I7Cgl9CglzdHJidWZfc3dhcCgmcGF0aGJ1ZiwgJnRtcCk7CgoJLyoKCSAqIFRoZSB0cmFpbGluZyBzbGFzaCBhZnRlciB0aGUgZGlyZWN0b3J5IG5hbWUgaXMgZ2l2ZW4gYnkKCSAqIHRoaXMgZnVuY3Rpb24gYXQgdGhlIGVuZC4gUmVtb3ZlIGR1cGxpY2F0ZXMuCgkgKi8KCXdoaWxlIChwYXRoYnVmLmxlbiAmJiBwYXRoYnVmLmJ1ZltwYXRoYnVmLmxlbiAtIDFdID09ICcvJykKCQlzdHJidWZfc2V0bGVuKCZwYXRoYnVmLCBwYXRoYnVmLmxlbiAtIDEpOwoKCXN0cmJ1Zl9yZXNldCgmdG1wKTsKCXN0cmJ1Zl9yZWFscGF0aCgmdG1wLCBvZGItPnNvdXJjZXMtPnBhdGgsIDEpOwoKCWlmICghYWx0X29kYl91c2FibGUob2RiLCAmcGF0aGJ1ZiwgdG1wLmJ1ZiwgJnBvcykpCgkJZ290byBlcnJvcjsKCglDQUxMT0NfQVJSQVkoYWx0ZXJuYXRlLCAxKTsKCWFsdGVybmF0ZS0+b2RiID0gb2RiOwoJYWx0ZXJuYXRlLT5sb2NhbCA9IGZhbHNlOwoJLyogcGF0aGJ1Zi5idWYgaXMgYWxyZWFkeSBpbiByLT5vYmplY3RzLT5zb3VyY2VfYnlfcGF0aCAqLwoJYWx0ZXJuYXRlLT5wYXRoID0gc3RyYnVmX2RldGFjaCgmcGF0aGJ1ZiwgTlVMTCk7CgoJLyogYWRkIHRoZSBhbHRlcm5hdGUgZW50cnkgKi8KCSpvZGItPnNvdXJjZXNfdGFpbCA9IGFsdGVybmF0ZTsKCW9kYi0+c291cmNlc190YWlsID0gJihhbHRlcm5hdGUtPm5leHQpOwoJYWx0ZXJuYXRlLT5uZXh0ID0gTlVMTDsKCWFzc2VydChvZGItPnNvdXJjZV9ieV9wYXRoKTsKCWtoX3ZhbHVlKG9kYi0+c291cmNlX2J5X3BhdGgsIHBvcykgPSBhbHRlcm5hdGU7CgoJLyogcmVjdXJzaXZlbHkgYWRkIGFsdGVybmF0ZXMgKi8KCXJlYWRfaW5mb19hbHRlcm5hdGVzKG9kYiwgYWx0ZXJuYXRlLT5wYXRoLCBkZXB0aCArIDEpOwoKIGVycm9yOgoJc3RyYnVmX3JlbGVhc2UoJnRtcCk7CglzdHJidWZfcmVsZWFzZSgmcGF0aGJ1Zik7CglyZXR1cm4gYWx0ZXJuYXRlOwp9CgpzdGF0aWMgY29uc3QgY2hhciAqcGFyc2VfYWx0X29kYl9lbnRyeShjb25zdCBjaGFyICpzdHJpbmcsCgkJCQkgICAgICAgaW50IHNlcCwKCQkJCSAgICAgICBzdHJ1Y3Qgc3RyYnVmICpvdXQpCnsKCWNvbnN0IGNoYXIgKmVuZDsKCglzdHJidWZfcmVzZXQob3V0KTsKCglpZiAoKnN0cmluZyA9PSAnIycpIHsKCQkvKiBjb21tZW50OyBjb25zdW1lIHVwIHRvIG5leHQgc2VwYXJhdG9yICovCgkJZW5kID0gc3RyY2hybnVsKHN0cmluZywgc2VwKTsKCX0gZWxzZSBpZiAoKnN0cmluZyA9PSAnIicgJiYgIXVucXVvdGVfY19zdHlsZShvdXQsIHN0cmluZywgJmVuZCkpIHsKCQkvKgoJCSAqIHF1b3RlZCBwYXRoOyB1bnF1b3RlX2Nfc3R5bGUgaGFzIGNvcGllZCB0aGUKCQkgKiBkYXRhIGZvciB1cyBhbmQgc2V0ICJlbmQiLiBCcm9rZW4gcXVvdGluZyAoZS5nLiwKCQkgKiBhbiBlbnRyeSB0aGF0IGRvZXNuJ3QgZW5kIHdpdGggYSBxdW90ZSkgZmFsbHMKCQkgKiBiYWNrIHRvIHRoZSB1bnF1b3RlZCBjYXNlIGJlbG93LgoJCSAqLwoJfSBlbHNlIHsKCQkvKiBub3JtYWwsIHVucXVvdGVkIHBhdGggKi8KCQllbmQgPSBzdHJjaHJudWwoc3RyaW5nLCBzZXApOwoJCXN0cmJ1Zl9hZGQob3V0LCBzdHJpbmcsIGVuZCAtIHN0cmluZyk7Cgl9CgoJaWYgKCplbmQpCgkJZW5kKys7CglyZXR1cm4gZW5kOwp9CgpzdGF0aWMgdm9pZCBsaW5rX2FsdF9vZGJfZW50cmllcyhzdHJ1Y3Qgb2JqZWN0X2RhdGFiYXNlICpvZGIsIGNvbnN0IGNoYXIgKmFsdCwKCQkJCSBpbnQgc2VwLCBjb25zdCBjaGFyICpyZWxhdGl2ZV9iYXNlLCBpbnQgZGVwdGgpCnsKCXN0cnVjdCBzdHJidWYgZGlyID0gU1RSQlVGX0lOSVQ7CgoJaWYgKCFhbHQgfHwgISphbHQpCgkJcmV0dXJuOwoKCWlmIChkZXB0aCA+IDUpIHsKCQllcnJvcihfKCIlczogaWdub3JpbmcgYWx0ZXJuYXRlIG9iamVjdCBzdG9yZXMsIG5lc3RpbmcgdG9vIGRlZXAiKSwKCQkJCXJlbGF0aXZlX2Jhc2UpOwoJCXJldHVybjsKCX0KCgl3aGlsZSAoKmFsdCkgewoJCWFsdCA9IHBhcnNlX2FsdF9vZGJfZW50cnkoYWx0LCBzZXAsICZkaXIpOwoJCWlmICghZGlyLmxlbikKCQkJY29udGludWU7CgkJbGlua19hbHRfb2RiX2VudHJ5KG9kYiwgZGlyLmJ1ZiwgcmVsYXRpdmVfYmFzZSwgZGVwdGgpOwoJfQoJc3RyYnVmX3JlbGVhc2UoJmRpcik7Cn0KCnN0YXRpYyB2b2lkIHJlYWRfaW5mb19hbHRlcm5hdGVzKHN0cnVjdCBvYmplY3RfZGF0YWJhc2UgKm9kYiwKCQkJCSBjb25zdCBjaGFyICpyZWxhdGl2ZV9iYXNlLAoJCQkJIGludCBkZXB0aCkKewoJY2hhciAqcGF0aDsKCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7CgoJcGF0aCA9IHhzdHJmbXQoIiVzL2luZm8vYWx0ZXJuYXRlcyIsIHJlbGF0aXZlX2Jhc2UpOwoJaWYgKHN0cmJ1Zl9yZWFkX2ZpbGUoJmJ1ZiwgcGF0aCwgMTAyNCkgPCAwKSB7CgkJd2Fybl9vbl9mb3Blbl9lcnJvcnMocGF0aCk7CgkJZnJlZShwYXRoKTsKCQlyZXR1cm47Cgl9CgoJbGlua19hbHRfb2RiX2VudHJpZXMob2RiLCBidWYuYnVmLCAnXG4nLCByZWxhdGl2ZV9iYXNlLCBkZXB0aCk7CglzdHJidWZfcmVsZWFzZSgmYnVmKTsKCWZyZWUocGF0aCk7Cn0KCnZvaWQgb2RiX2FkZF90b19hbHRlcm5hdGVzX2ZpbGUoc3RydWN0IG9iamVjdF9kYXRhYmFzZSAqb2RiLAoJCQkJY29uc3QgY2hhciAqZGlyKQp7CglzdHJ1Y3QgbG9ja19maWxlIGxvY2sgPSBMT0NLX0lOSVQ7CgljaGFyICphbHRzID0gcmVwb19naXRfcGF0aChvZGItPnJlcG8sICJvYmplY3RzL2luZm8vYWx0ZXJuYXRlcyIpOwoJRklMRSAqaW4sICpvdXQ7CglpbnQgZm91bmQgPSAwOwoKCWhvbGRfbG9ja19maWxlX2Zvcl91cGRhdGUoJmxvY2ssIGFsdHMsIExPQ0tfRElFX09OX0VSUk9SKTsKCW91dCA9IGZkb3Blbl9sb2NrX2ZpbGUoJmxvY2ssICJ3Iik7CglpZiAoIW91dCkKCQlkaWVfZXJybm8oXygidW5hYmxlIHRvIGZkb3BlbiBhbHRlcm5hdGVzIGxvY2tmaWxlIikpOwoKCWluID0gZm9wZW4oYWx0cywgInIiKTsKCWlmIChpbikgewoJCXN0cnVjdCBzdHJidWYgbGluZSA9IFNUUkJVRl9JTklUOwoKCQl3aGlsZSAoc3RyYnVmX2dldGxpbmUoJmxpbmUsIGluKSAhPSBFT0YpIHsKCQkJaWYgKCFzdHJjbXAoZGlyLCBsaW5lLmJ1ZikpIHsKCQkJCWZvdW5kID0gMTsKCQkJCWJyZWFrOwoJCQl9CgkJCWZwcmludGZfb3JfZGllKG91dCwgIiVzXG4iLCBsaW5lLmJ1Zik7CgkJfQoKCQlzdHJidWZfcmVsZWFzZSgmbGluZSk7CgkJZmNsb3NlKGluKTsKCX0KCWVsc2UgaWYgKGVycm5vICE9IEVOT0VOVCkKCQlkaWVfZXJybm8oXygidW5hYmxlIHRvIHJlYWQgYWx0ZXJuYXRlcyBmaWxlIikpOwoKCWlmIChmb3VuZCkgewoJCXJvbGxiYWNrX2xvY2tfZmlsZSgmbG9jayk7Cgl9IGVsc2UgewoJCWZwcmludGZfb3JfZGllKG91dCwgIiVzXG4iLCBkaXIpOwoJCWlmIChjb21taXRfbG9ja19maWxlKCZsb2NrKSkKCQkJZGllX2Vycm5vKF8oInVuYWJsZSB0byBtb3ZlIG5ldyBhbHRlcm5hdGVzIGZpbGUgaW50byBwbGFjZSIpKTsKCQlpZiAob2RiLT5sb2FkZWRfYWx0ZXJuYXRlcykKCQkJbGlua19hbHRfb2RiX2VudHJpZXMob2RiLCBkaXIsICdcbicsIE5VTEwsIDApOwoJfQoJZnJlZShhbHRzKTsKfQoKc3RydWN0IG9kYl9zb3VyY2UgKm9kYl9hZGRfdG9fYWx0ZXJuYXRlc19tZW1vcnkoc3RydWN0IG9iamVjdF9kYXRhYmFzZSAqb2RiLAoJCQkJCQljb25zdCBjaGFyICpkaXIpCnsKCS8qCgkgKiBNYWtlIHN1cmUgYWx0ZXJuYXRlcyBhcmUgaW5pdGlhbGl6ZWQsIG9yIGVsc2Ugb3VyIGVudHJ5IG1heSBiZQoJICogb3ZlcndyaXR0ZW4gd2hlbiB0aGV5IGFyZS4KCSAqLwoJb2RiX3ByZXBhcmVfYWx0ZXJuYXRlcyhvZGIpOwoJcmV0dXJuIGxpbmtfYWx0X29kYl9lbnRyeShvZGIsIGRpciwgTlVMTCwgMCk7Cn0KCnN0cnVjdCBvZGJfc291cmNlICpvZGJfc2V0X3RlbXBvcmFyeV9wcmltYXJ5X3NvdXJjZShzdHJ1Y3Qgb2JqZWN0X2RhdGFiYXNlICpvZGIsCgkJCQkJCSAgICBjb25zdCBjaGFyICpkaXIsIGludCB3aWxsX2Rlc3Ryb3kpCnsKCXN0cnVjdCBvZGJfc291cmNlICpzb3VyY2U7CgoJLyoKCSAqIE1ha2Ugc3VyZSBhbHRlcm5hdGVzIGFyZSBpbml0aWFsaXplZCwgb3IgZWxzZSBvdXIgZW50cnkgbWF5IGJlCgkgKiBvdmVyd3JpdHRlbiB3aGVuIHRoZXkgYXJlLgoJICovCglvZGJfcHJlcGFyZV9hbHRlcm5hdGVzKG9kYik7CgoJLyoKCSAqIE1ha2UgYSBuZXcgcHJpbWFyeSBvZGIgYW5kIGxpbmsgdGhlIG9sZCBwcmltYXJ5IE9EQiBpbiBhcyBhbgoJICogYWx0ZXJuYXRlCgkgKi8KCXNvdXJjZSA9IHhjYWxsb2MoMSwgc2l6ZW9mKCpzb3VyY2UpKTsKCXNvdXJjZS0+b2RiID0gb2RiOwoJc291cmNlLT5wYXRoID0geHN0cmR1cChkaXIpOwoKCS8qCgkgKiBEaXNhYmxlIHJlZiB1cGRhdGVzIHdoaWxlIGEgdGVtcG9yYXJ5IG9kYiBpcyBhY3RpdmUsIHNpbmNlCgkgKiB0aGUgb2JqZWN0cyBpbiB0aGUgZGF0YWJhc2UgbWF5IHJvbGwgYmFjay4KCSAqLwoJc291cmNlLT5kaXNhYmxlX3JlZl91cGRhdGVzID0gMTsKCXNvdXJjZS0+d2lsbF9kZXN0cm95ID0gd2lsbF9kZXN0cm95OwoJc291cmNlLT5uZXh0ID0gb2RiLT5zb3VyY2VzOwoJb2RiLT5zb3VyY2VzID0gc291cmNlOwoJcmV0dXJuIHNvdXJjZS0+bmV4dDsKfQoKc3RhdGljIHZvaWQgZnJlZV9vYmplY3RfZGlyZWN0b3J5KHN0cnVjdCBvZGJfc291cmNlICpzb3VyY2UpCnsKCWZyZWUoc291cmNlLT5wYXRoKTsKCW9kYl9jbGVhcl9sb29zZV9jYWNoZShzb3VyY2UpOwoJbG9vc2Vfb2JqZWN0X21hcF9jbGVhcigmc291cmNlLT5sb29zZV9tYXApOwoJZnJlZShzb3VyY2UpOwp9Cgp2b2lkIG9kYl9yZXN0b3JlX3ByaW1hcnlfc291cmNlKHN0cnVjdCBvYmplY3RfZGF0YWJhc2UgKm9kYiwKCQkJCXN0cnVjdCBvZGJfc291cmNlICpyZXN0b3JlX3NvdXJjZSwKCQkJCWNvbnN0IGNoYXIgKm9sZF9wYXRoKQp7CglzdHJ1Y3Qgb2RiX3NvdXJjZSAqY3VyX3NvdXJjZSA9IG9kYi0+c291cmNlczsKCglpZiAoc3RyY21wKG9sZF9wYXRoLCBjdXJfc291cmNlLT5wYXRoKSkKCQlCVUcoImV4cGVjdGVkICVzIGFzIHByaW1hcnkgb2JqZWN0IHN0b3JlOyBmb3VuZCAlcyIsCgkJICAgIG9sZF9wYXRoLCBjdXJfc291cmNlLT5wYXRoKTsKCglpZiAoY3VyX3NvdXJjZS0+bmV4dCAhPSByZXN0b3JlX3NvdXJjZSkKCQlCVUcoIndlIGV4cGVjdCB0aGUgb2xkIHByaW1hcnkgb2JqZWN0IHN0b3JlIHRvIGJlIHRoZSBmaXJzdCBhbHRlcm5hdGUiKTsKCglvZGItPnNvdXJjZXMgPSByZXN0b3JlX3NvdXJjZTsKCWZyZWVfb2JqZWN0X2RpcmVjdG9yeShjdXJfc291cmNlKTsKfQoKY2hhciAqY29tcHV0ZV9hbHRlcm5hdGVfcGF0aChjb25zdCBjaGFyICpwYXRoLCBzdHJ1Y3Qgc3RyYnVmICplcnIpCnsKCWNoYXIgKnJlZl9naXQgPSBOVUxMOwoJY29uc3QgY2hhciAqcmVwbzsKCWludCBzZWVuX2Vycm9yID0gMDsKCglyZWZfZ2l0ID0gcmVhbF9wYXRoZHVwKHBhdGgsIDApOwoJaWYgKCFyZWZfZ2l0KSB7CgkJc2Vlbl9lcnJvciA9IDE7CgkJc3RyYnVmX2FkZGYoZXJyLCBfKCJwYXRoICclcycgZG9lcyBub3QgZXhpc3QiKSwgcGF0aCk7CgkJZ290byBvdXQ7Cgl9CgoJcmVwbyA9IHJlYWRfZ2l0ZmlsZShyZWZfZ2l0KTsKCWlmICghcmVwbykKCQlyZXBvID0gcmVhZF9naXRmaWxlKG1rcGF0aCgiJXMvLmdpdCIsIHJlZl9naXQpKTsKCWlmIChyZXBvKSB7CgkJZnJlZShyZWZfZ2l0KTsKCQlyZWZfZ2l0ID0geHN0cmR1cChyZXBvKTsKCX0KCglpZiAoIXJlcG8gJiYgaXNfZGlyZWN0b3J5KG1rcGF0aCgiJXMvLmdpdC9vYmplY3RzIiwgcmVmX2dpdCkpKSB7CgkJY2hhciAqcmVmX2dpdF9naXQgPSBta3BhdGhkdXAoIiVzLy5naXQiLCByZWZfZ2l0KTsKCQlmcmVlKHJlZl9naXQpOwoJCXJlZl9naXQgPSByZWZfZ2l0X2dpdDsKCX0gZWxzZSBpZiAoIWlzX2RpcmVjdG9yeShta3BhdGgoIiVzL29iamVjdHMiLCByZWZfZ2l0KSkpIHsKCQlzdHJ1Y3Qgc3RyYnVmIHNiID0gU1RSQlVGX0lOSVQ7CgkJc2Vlbl9lcnJvciA9IDE7CgkJaWYgKGdldF9jb21tb25fZGlyKCZzYiwgcmVmX2dpdCkpIHsKCQkJc3RyYnVmX2FkZGYoZXJyLAoJCQkJICAgIF8oInJlZmVyZW5jZSByZXBvc2l0b3J5ICclcycgYXMgYSBsaW5rZWQgIgoJCQkJICAgICAgImNoZWNrb3V0IGlzIG5vdCBzdXBwb3J0ZWQgeWV0LiIpLAoJCQkJICAgIHBhdGgpOwoJCQlnb3RvIG91dDsKCQl9CgoJCXN0cmJ1Zl9hZGRmKGVyciwgXygicmVmZXJlbmNlIHJlcG9zaXRvcnkgJyVzJyBpcyBub3QgYSAiCgkJCQkJImxvY2FsIHJlcG9zaXRvcnkuIiksIHBhdGgpOwoJCWdvdG8gb3V0OwoJfQoKCWlmICghYWNjZXNzKG1rcGF0aCgiJXMvc2hhbGxvdyIsIHJlZl9naXQpLCBGX09LKSkgewoJCXN0cmJ1Zl9hZGRmKGVyciwgXygicmVmZXJlbmNlIHJlcG9zaXRvcnkgJyVzJyBpcyBzaGFsbG93IiksCgkJCSAgICBwYXRoKTsKCQlzZWVuX2Vycm9yID0gMTsKCQlnb3RvIG91dDsKCX0KCglpZiAoIWFjY2Vzcyhta3BhdGgoIiVzL2luZm8vZ3JhZnRzIiwgcmVmX2dpdCksIEZfT0spKSB7CgkJc3RyYnVmX2FkZGYoZXJyLAoJCQkgICAgXygicmVmZXJlbmNlIHJlcG9zaXRvcnkgJyVzJyBpcyBncmFmdGVkIiksCgkJCSAgICBwYXRoKTsKCQlzZWVuX2Vycm9yID0gMTsKCQlnb3RvIG91dDsKCX0KCm91dDoKCWlmIChzZWVuX2Vycm9yKSB7CgkJRlJFRV9BTkRfTlVMTChyZWZfZ2l0KTsKCX0KCglyZXR1cm4gcmVmX2dpdDsKfQoKc3RydWN0IG9kYl9zb3VyY2UgKm9kYl9maW5kX3NvdXJjZShzdHJ1Y3Qgb2JqZWN0X2RhdGFiYXNlICpvZGIsIGNvbnN0IGNoYXIgKm9ial9kaXIpCnsKCXN0cnVjdCBvZGJfc291cmNlICpzb3VyY2U7CgljaGFyICpvYmpfZGlyX3JlYWwgPSByZWFsX3BhdGhkdXAob2JqX2RpciwgMSk7CglzdHJ1Y3Qgc3RyYnVmIG9kYl9wYXRoX3JlYWwgPSBTVFJCVUZfSU5JVDsKCglvZGJfcHJlcGFyZV9hbHRlcm5hdGVzKG9kYik7Cglmb3IgKHNvdXJjZSA9IG9kYi0+c291cmNlczsgc291cmNlOyBzb3VyY2UgPSBzb3VyY2UtPm5leHQpIHsKCQlzdHJidWZfcmVhbHBhdGgoJm9kYl9wYXRoX3JlYWwsIHNvdXJjZS0+cGF0aCwgMSk7CgkJaWYgKCFzdHJjbXAob2JqX2Rpcl9yZWFsLCBvZGJfcGF0aF9yZWFsLmJ1ZikpCgkJCWJyZWFrOwoJfQoKCWZyZWUob2JqX2Rpcl9yZWFsKTsKCXN0cmJ1Zl9yZWxlYXNlKCZvZGJfcGF0aF9yZWFsKTsKCglyZXR1cm4gc291cmNlOwp9CgpzdHJ1Y3Qgb2RiX3NvdXJjZSAqb2RiX2ZpbmRfc291cmNlX29yX2RpZShzdHJ1Y3Qgb2JqZWN0X2RhdGFiYXNlICpvZGIsIGNvbnN0IGNoYXIgKm9ial9kaXIpCnsKCXN0cnVjdCBvZGJfc291cmNlICpzb3VyY2UgPSBvZGJfZmluZF9zb3VyY2Uob2RiLCBvYmpfZGlyKTsKCWlmICghc291cmNlKQoJCWRpZShfKCJjb3VsZCBub3QgZmluZCBvYmplY3QgZGlyZWN0b3J5IG1hdGNoaW5nICVzIiksIG9ial9kaXIpOwoJcmV0dXJuIHNvdXJjZTsKfQoKdm9pZCBvZGJfYWRkX3N1Ym1vZHVsZV9zb3VyY2VfYnlfcGF0aChzdHJ1Y3Qgb2JqZWN0X2RhdGFiYXNlICpvZGIsCgkJCQkgICAgICBjb25zdCBjaGFyICpwYXRoKQp7CglzdHJpbmdfbGlzdF9pbnNlcnQoJm9kYi0+c3VibW9kdWxlX3NvdXJjZV9wYXRocywgcGF0aCk7Cn0KCnN0YXRpYyB2b2lkIGZpbGxfYWx0ZXJuYXRlX3JlZnNfY29tbWFuZChzdHJ1Y3QgcmVwb3NpdG9yeSAqcmVwbywKCQkJCQlzdHJ1Y3QgY2hpbGRfcHJvY2VzcyAqY21kLAoJCQkJCWNvbnN0IGNoYXIgKnJlcG9fcGF0aCkKewoJY29uc3QgY2hhciAqdmFsdWU7CgoJaWYgKCFyZXBvX2NvbmZpZ19nZXRfdmFsdWUocmVwbywgImNvcmUuYWx0ZXJuYXRlUmVmc0NvbW1hbmQiLCAmdmFsdWUpKSB7CgkJY21kLT51c2Vfc2hlbGwgPSAxOwoKCQlzdHJ2ZWNfcHVzaCgmY21kLT5hcmdzLCB2YWx1ZSk7CgkJc3RydmVjX3B1c2goJmNtZC0+YXJncywgcmVwb19wYXRoKTsKCX0gZWxzZSB7CgkJY21kLT5naXRfY21kID0gMTsKCgkJc3RydmVjX3B1c2hmKCZjbWQtPmFyZ3MsICItLWdpdC1kaXI9JXMiLCByZXBvX3BhdGgpOwoJCXN0cnZlY19wdXNoKCZjbWQtPmFyZ3MsICJmb3ItZWFjaC1yZWYiKTsKCQlzdHJ2ZWNfcHVzaCgmY21kLT5hcmdzLCAiLS1mb3JtYXQ9JShvYmplY3RuYW1lKSIpOwoKCQlpZiAoIXJlcG9fY29uZmlnX2dldF92YWx1ZShyZXBvLCAiY29yZS5hbHRlcm5hdGVSZWZzUHJlZml4ZXMiLCAmdmFsdWUpKSB7CgkJCXN0cnZlY19wdXNoKCZjbWQtPmFyZ3MsICItLSIpOwoJCQlzdHJ2ZWNfc3BsaXQoJmNtZC0+YXJncywgdmFsdWUpOwoJCX0KCX0KCglzdHJ2ZWNfcHVzaHYoJmNtZC0+ZW52LCAoY29uc3QgY2hhciAqKilsb2NhbF9yZXBvX2Vudik7CgljbWQtPm91dCA9IC0xOwp9CgpzdGF0aWMgdm9pZCByZWFkX2FsdGVybmF0ZV9yZWZzKHN0cnVjdCByZXBvc2l0b3J5ICpyZXBvLAoJCQkJY29uc3QgY2hhciAqcGF0aCwKCQkJCW9kYl9mb3JfZWFjaF9hbHRlcm5hdGVfcmVmX2ZuICpjYiwKCQkJCXZvaWQgKnBheWxvYWQpCnsKCXN0cnVjdCBjaGlsZF9wcm9jZXNzIGNtZCA9IENISUxEX1BST0NFU1NfSU5JVDsKCXN0cnVjdCBzdHJidWYgbGluZSA9IFNUUkJVRl9JTklUOwoJRklMRSAqZmg7CgoJZmlsbF9hbHRlcm5hdGVfcmVmc19jb21tYW5kKHJlcG8sICZjbWQsIHBhdGgpOwoKCWlmIChzdGFydF9jb21tYW5kKCZjbWQpKQoJCXJldHVybjsKCglmaCA9IHhmZG9wZW4oY21kLm91dCwgInIiKTsKCXdoaWxlIChzdHJidWZfZ2V0bGluZV9sZigmbGluZSwgZmgpICE9IEVPRikgewoJCXN0cnVjdCBvYmplY3RfaWQgb2lkOwoJCWNvbnN0IGNoYXIgKnA7CgoJCWlmIChwYXJzZV9vaWRfaGV4X2FsZ29wKGxpbmUuYnVmLCAmb2lkLCAmcCwgcmVwby0+aGFzaF9hbGdvKSB8fCAqcCkgewoJCQl3YXJuaW5nKF8oImludmFsaWQgbGluZSB3aGlsZSBwYXJzaW5nIGFsdGVybmF0ZSByZWZzOiAlcyIpLAoJCQkJbGluZS5idWYpOwoJCQlicmVhazsKCQl9CgoJCWNiKCZvaWQsIHBheWxvYWQpOwoJfQoKCWZjbG9zZShmaCk7CglmaW5pc2hfY29tbWFuZCgmY21kKTsKCXN0cmJ1Zl9yZWxlYXNlKCZsaW5lKTsKfQoKc3RydWN0IGFsdGVybmF0ZV9yZWZzX2RhdGEgewoJb2RiX2Zvcl9lYWNoX2FsdGVybmF0ZV9yZWZfZm4gKmZuOwoJdm9pZCAqcGF5bG9hZDsKfTsKCnN0YXRpYyBpbnQgcmVmc19mcm9tX2FsdGVybmF0ZV9jYihzdHJ1Y3Qgb2RiX3NvdXJjZSAqYWx0ZXJuYXRlLAoJCQkJICB2b2lkICpwYXlsb2FkKQp7CglzdHJ1Y3Qgc3RyYnVmIHBhdGggPSBTVFJCVUZfSU5JVDsKCXNpemVfdCBiYXNlX2xlbjsKCXN0cnVjdCBhbHRlcm5hdGVfcmVmc19kYXRhICpjYiA9IHBheWxvYWQ7CgoJaWYgKCFzdHJidWZfcmVhbHBhdGgoJnBhdGgsIGFsdGVybmF0ZS0+cGF0aCwgMCkpCgkJZ290byBvdXQ7CglpZiAoIXN0cmJ1Zl9zdHJpcF9zdWZmaXgoJnBhdGgsICIvb2JqZWN0cyIpKQoJCWdvdG8gb3V0OwoJYmFzZV9sZW4gPSBwYXRoLmxlbjsKCgkvKiBJcyB0aGlzIGEgZ2l0IHJlcG9zaXRvcnkgd2l0aCByZWZzPyAqLwoJc3RyYnVmX2FkZHN0cigmcGF0aCwgIi9yZWZzIik7CglpZiAoIWlzX2RpcmVjdG9yeShwYXRoLmJ1ZikpCgkJZ290byBvdXQ7CglzdHJidWZfc2V0bGVuKCZwYXRoLCBiYXNlX2xlbik7CgoJcmVhZF9hbHRlcm5hdGVfcmVmcyhhbHRlcm5hdGUtPm9kYi0+cmVwbywgcGF0aC5idWYsIGNiLT5mbiwgY2ItPnBheWxvYWQpOwoKb3V0OgoJc3RyYnVmX3JlbGVhc2UoJnBhdGgpOwoJcmV0dXJuIDA7Cn0KCnZvaWQgb2RiX2Zvcl9lYWNoX2FsdGVybmF0ZV9yZWYoc3RydWN0IG9iamVjdF9kYXRhYmFzZSAqb2RiLAoJCQkJb2RiX2Zvcl9lYWNoX2FsdGVybmF0ZV9yZWZfZm4gY2IsIHZvaWQgKnBheWxvYWQpCnsKCXN0cnVjdCBhbHRlcm5hdGVfcmVmc19kYXRhIGRhdGE7CglkYXRhLmZuID0gY2I7CglkYXRhLnBheWxvYWQgPSBwYXlsb2FkOwoJb2RiX2Zvcl9lYWNoX2FsdGVybmF0ZShvZGIsIHJlZnNfZnJvbV9hbHRlcm5hdGVfY2IsICZkYXRhKTsKfQoKaW50IG9kYl9mb3JfZWFjaF9hbHRlcm5hdGUoc3RydWN0IG9iamVjdF9kYXRhYmFzZSAqb2RiLAoJCQkgb2RiX2Zvcl9lYWNoX2FsdGVybmF0ZV9mbiBjYiwgdm9pZCAqcGF5bG9hZCkKewoJc3RydWN0IG9kYl9zb3VyY2UgKmFsdGVybmF0ZTsKCWludCByID0gMDsKCglvZGJfcHJlcGFyZV9hbHRlcm5hdGVzKG9kYik7Cglmb3IgKGFsdGVybmF0ZSA9IG9kYi0+c291cmNlcy0+bmV4dDsgYWx0ZXJuYXRlOyBhbHRlcm5hdGUgPSBhbHRlcm5hdGUtPm5leHQpIHsKCQlyID0gY2IoYWx0ZXJuYXRlLCBwYXlsb2FkKTsKCQlpZiAocikKCQkJYnJlYWs7Cgl9CglyZXR1cm4gcjsKfQoKdm9pZCBvZGJfcHJlcGFyZV9hbHRlcm5hdGVzKHN0cnVjdCBvYmplY3RfZGF0YWJhc2UgKm9kYikKewoJaWYgKG9kYi0+bG9hZGVkX2FsdGVybmF0ZXMpCgkJcmV0dXJuOwoKCWxpbmtfYWx0X29kYl9lbnRyaWVzKG9kYiwgb2RiLT5hbHRlcm5hdGVfZGIsIFBBVEhfU0VQLCBOVUxMLCAwKTsKCglyZWFkX2luZm9fYWx0ZXJuYXRlcyhvZGIsIG9kYi0+c291cmNlcy0+cGF0aCwgMCk7CglvZGItPmxvYWRlZF9hbHRlcm5hdGVzID0gMTsKfQoKaW50IG9kYl9oYXNfYWx0ZXJuYXRlcyhzdHJ1Y3Qgb2JqZWN0X2RhdGFiYXNlICpvZGIpCnsKCW9kYl9wcmVwYXJlX2FsdGVybmF0ZXMob2RiKTsKCXJldHVybiAhIW9kYi0+c291cmNlcy0+bmV4dDsKfQoKaW50IG9ial9yZWFkX3VzZV9sb2NrID0gMDsKcHRocmVhZF9tdXRleF90IG9ial9yZWFkX211dGV4OwoKdm9pZCBlbmFibGVfb2JqX3JlYWRfbG9jayh2b2lkKQp7CglpZiAob2JqX3JlYWRfdXNlX2xvY2spCgkJcmV0dXJuOwoKCW9ial9yZWFkX3VzZV9sb2NrID0gMTsKCWluaXRfcmVjdXJzaXZlX211dGV4KCZvYmpfcmVhZF9tdXRleCk7Cn0KCnZvaWQgZGlzYWJsZV9vYmpfcmVhZF9sb2NrKHZvaWQpCnsKCWlmICghb2JqX3JlYWRfdXNlX2xvY2spCgkJcmV0dXJuOwoKCW9ial9yZWFkX3VzZV9sb2NrID0gMDsKCXB0aHJlYWRfbXV0ZXhfZGVzdHJveSgmb2JqX3JlYWRfbXV0ZXgpOwp9CgppbnQgZmV0Y2hfaWZfbWlzc2luZyA9IDE7CgpzdGF0aWMgaW50IHJlZ2lzdGVyX2FsbF9zdWJtb2R1bGVfc291cmNlcyhzdHJ1Y3Qgb2JqZWN0X2RhdGFiYXNlICpvZGIpCnsKCWludCByZXQgPSBvZGItPnN1Ym1vZHVsZV9zb3VyY2VfcGF0aHMubnI7CgoJZm9yIChzaXplX3QgaSA9IDA7IGkgPCBvZGItPnN1Ym1vZHVsZV9zb3VyY2VfcGF0aHMubnI7IGkrKykKCQlvZGJfYWRkX3RvX2FsdGVybmF0ZXNfbWVtb3J5KG9kYiwKCQkJCQkgICAgIG9kYi0+c3VibW9kdWxlX3NvdXJjZV9wYXRocy5pdGVtc1tpXS5zdHJpbmcpOwoJaWYgKHJldCkgewoJCXN0cmluZ19saXN0X2NsZWFyKCZvZGItPnN1Ym1vZHVsZV9zb3VyY2VfcGF0aHMsIDApOwoJCXRyYWNlMl9kYXRhX2ludG1heCgic3VibW9kdWxlIiwgb2RiLT5yZXBvLAoJCQkJICAgInJlZ2lzdGVyX2FsbF9zdWJtb2R1bGVfc291cmNlcy9yZWdpc3RlcmVkIiwgcmV0KTsKCQlpZiAoZ2l0X2Vudl9ib29sKCJHSVRfVEVTVF9GQVRBTF9SRUdJU1RFUl9TVUJNT0RVTEVfT0RCIiwgMCkpCgkJCUJVRygicmVnaXN0ZXJfYWxsX3N1Ym1vZHVsZV9zb3VyY2VzKCkgY2FsbGVkIik7Cgl9CglyZXR1cm4gcmV0Owp9CgpzdGF0aWMgaW50IGRvX29pZF9vYmplY3RfaW5mb19leHRlbmRlZChzdHJ1Y3Qgb2JqZWN0X2RhdGFiYXNlICpvZGIsCgkJCQkgICAgICAgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLAoJCQkJICAgICAgIHN0cnVjdCBvYmplY3RfaW5mbyAqb2ksIHVuc2lnbmVkIGZsYWdzKQp7CglzdGF0aWMgc3RydWN0IG9iamVjdF9pbmZvIGJsYW5rX29pID0gT0JKRUNUX0lORk9fSU5JVDsKCWNvbnN0IHN0cnVjdCBjYWNoZWRfb2JqZWN0ICpjbzsKCXN0cnVjdCBwYWNrX2VudHJ5IGU7CglpbnQgcnR5cGU7Cgljb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpyZWFsID0gb2lkOwoJaW50IGFscmVhZHlfcmV0cmllZCA9IDA7CgoKCWlmIChmbGFncyAmIE9CSkVDVF9JTkZPX0xPT0tVUF9SRVBMQUNFKQoJCXJlYWwgPSBsb29rdXBfcmVwbGFjZV9vYmplY3Qob2RiLT5yZXBvLCBvaWQpOwoKCWlmIChpc19udWxsX29pZChyZWFsKSkKCQlyZXR1cm4gLTE7CgoJaWYgKCFvaSkKCQlvaSA9ICZibGFua19vaTsKCgljbyA9IGZpbmRfY2FjaGVkX29iamVjdChvZGIsIHJlYWwpOwoJaWYgKGNvKSB7CgkJaWYgKG9pLT50eXBlcCkKCQkJKihvaS0+dHlwZXApID0gY28tPnR5cGU7CgkJaWYgKG9pLT5zaXplcCkKCQkJKihvaS0+c2l6ZXApID0gY28tPnNpemU7CgkJaWYgKG9pLT5kaXNrX3NpemVwKQoJCQkqKG9pLT5kaXNrX3NpemVwKSA9IDA7CgkJaWYgKG9pLT5kZWx0YV9iYXNlX29pZCkKCQkJb2lkY2xyKG9pLT5kZWx0YV9iYXNlX29pZCwgb2RiLT5yZXBvLT5oYXNoX2FsZ28pOwoJCWlmIChvaS0+Y29udGVudHApCgkJCSpvaS0+Y29udGVudHAgPSB4bWVtZHVweihjby0+YnVmLCBjby0+c2l6ZSk7CgkJb2ktPndoZW5jZSA9IE9JX0NBQ0hFRDsKCQlyZXR1cm4gMDsKCX0KCgl3aGlsZSAoMSkgewoJCWlmIChmaW5kX3BhY2tfZW50cnkob2RiLT5yZXBvLCByZWFsLCAmZSkpCgkJCWJyZWFrOwoKCQkvKiBNb3N0IGxpa2VseSBpdCdzIGEgbG9vc2Ugb2JqZWN0LiAqLwoJCWlmICghbG9vc2Vfb2JqZWN0X2luZm8ob2RiLT5yZXBvLCByZWFsLCBvaSwgZmxhZ3MpKQoJCQlyZXR1cm4gMDsKCgkJLyogTm90IGEgbG9vc2Ugb2JqZWN0OyBzb21lb25lIGVsc2UgbWF5IGhhdmUganVzdCBwYWNrZWQgaXQuICovCgkJaWYgKCEoZmxhZ3MgJiBPQkpFQ1RfSU5GT19RVUlDSykpIHsKCQkJb2RiX3JlcHJlcGFyZShvZGItPnJlcG8tPm9iamVjdHMpOwoJCQlpZiAoZmluZF9wYWNrX2VudHJ5KG9kYi0+cmVwbywgcmVhbCwgJmUpKQoJCQkJYnJlYWs7CgkJfQoKCQkvKgoJCSAqIFRoaXMgbWlnaHQgYmUgYW4gYXR0ZW1wdCBhdCBhY2Nlc3NpbmcgYSBzdWJtb2R1bGUgb2JqZWN0IGFzCgkJICogaWYgaXQgd2VyZSBpbiBtYWluIG9iamVjdCBzdG9yZSAoaGF2aW5nIGNhbGxlZAoJCSAqIGBvZGJfYWRkX3N1Ym1vZHVsZV9zb3VyY2VfYnlfcGF0aCgpYCBvbiB0aGF0IHN1Ym1vZHVsZSdzCgkJICogT0RCKS4gSWYgYW55IHN1Y2ggT0RCcyBleGlzdCwgcmVnaXN0ZXIgdGhlbSBhbmQgdHJ5IGFnYWluLgoJCSAqLwoJCWlmIChyZWdpc3Rlcl9hbGxfc3VibW9kdWxlX3NvdXJjZXMob2RiKSkKCQkJLyogV2UgYWRkZWQgc29tZSBhbHRlcm5hdGVzOyByZXRyeSAqLwoJCQljb250aW51ZTsKCgkJLyogQ2hlY2sgaWYgaXQgaXMgYSBtaXNzaW5nIG9iamVjdCAqLwoJCWlmIChmZXRjaF9pZl9taXNzaW5nICYmIHJlcG9faGFzX3Byb21pc29yX3JlbW90ZShvZGItPnJlcG8pICYmCgkJICAgICFhbHJlYWR5X3JldHJpZWQgJiYKCQkgICAgIShmbGFncyAmIE9CSkVDVF9JTkZPX1NLSVBfRkVUQ0hfT0JKRUNUKSkgewoJCQlwcm9taXNvcl9yZW1vdGVfZ2V0X2RpcmVjdChvZGItPnJlcG8sIHJlYWwsIDEpOwoJCQlhbHJlYWR5X3JldHJpZWQgPSAxOwoJCQljb250aW51ZTsKCQl9CgoJCWlmIChmbGFncyAmIE9CSkVDVF9JTkZPX0RJRV9JRl9DT1JSVVBUKSB7CgkJCWNvbnN0IHN0cnVjdCBwYWNrZWRfZ2l0ICpwOwoJCQlpZiAoKGZsYWdzICYgT0JKRUNUX0lORk9fTE9PS1VQX1JFUExBQ0UpICYmICFvaWRlcShyZWFsLCBvaWQpKQoJCQkJZGllKF8oInJlcGxhY2VtZW50ICVzIG5vdCBmb3VuZCBmb3IgJXMiKSwKCQkJCSAgICBvaWRfdG9faGV4KHJlYWwpLCBvaWRfdG9faGV4KG9pZCkpOwoJCQlpZiAoKHAgPSBoYXNfcGFja2VkX2FuZF9iYWQob2RiLT5yZXBvLCByZWFsKSkpCgkJCQlkaWUoXygicGFja2VkIG9iamVjdCAlcyAoc3RvcmVkIGluICVzKSBpcyBjb3JydXB0IiksCgkJCQkgICAgb2lkX3RvX2hleChyZWFsKSwgcC0+cGFja19uYW1lKTsKCQl9CgkJcmV0dXJuIC0xOwoJfQoKCWlmIChvaSA9PSAmYmxhbmtfb2kpCgkJLyoKCQkgKiBXZSBrbm93IHRoYXQgdGhlIGNhbGxlciBkb2Vzbid0IGFjdHVhbGx5IG5lZWQgdGhlCgkJICogaW5mb3JtYXRpb24gYmVsb3csIHNvIHJldHVybiBlYXJseS4KCQkgKi8KCQlyZXR1cm4gMDsKCXJ0eXBlID0gcGFja2VkX29iamVjdF9pbmZvKG9kYi0+cmVwbywgZS5wLCBlLm9mZnNldCwgb2kpOwoJaWYgKHJ0eXBlIDwgMCkgewoJCW1hcmtfYmFkX3BhY2tlZF9vYmplY3QoZS5wLCByZWFsKTsKCQlyZXR1cm4gZG9fb2lkX29iamVjdF9pbmZvX2V4dGVuZGVkKG9kYiwgcmVhbCwgb2ksIDApOwoJfSBlbHNlIGlmIChvaS0+d2hlbmNlID09IE9JX1BBQ0tFRCkgewoJCW9pLT51LnBhY2tlZC5vZmZzZXQgPSBlLm9mZnNldDsKCQlvaS0+dS5wYWNrZWQucGFjayA9IGUucDsKCQlvaS0+dS5wYWNrZWQuaXNfZGVsdGEgPSAocnR5cGUgPT0gT0JKX1JFRl9ERUxUQSB8fAoJCQkJCSBydHlwZSA9PSBPQkpfT0ZTX0RFTFRBKTsKCX0KCglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBvaWRfb2JqZWN0X2luZm9fY29udmVydChzdHJ1Y3QgcmVwb3NpdG9yeSAqciwKCQkJCSAgIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKmlucHV0X29pZCwKCQkJCSAgIHN0cnVjdCBvYmplY3RfaW5mbyAqaW5wdXRfb2ksIHVuc2lnbmVkIGZsYWdzKQp7Cgljb25zdCBzdHJ1Y3QgZ2l0X2hhc2hfYWxnbyAqaW5wdXRfYWxnbyA9ICZoYXNoX2FsZ29zW2lucHV0X29pZC0+YWxnb107CglpbnQgZG9fZGllID0gZmxhZ3MgJiBPQkpFQ1RfSU5GT19ESUVfSUZfQ09SUlVQVDsKCWVudW0gb2JqZWN0X3R5cGUgdHlwZTsKCXN0cnVjdCBvYmplY3RfaWQgb2lkLCBkZWx0YV9iYXNlX29pZDsKCXN0cnVjdCBvYmplY3RfaW5mbyBuZXdfb2ksICpvaTsKCXVuc2lnbmVkIGxvbmcgc2l6ZTsKCXZvaWQgKmNvbnRlbnQ7CglpbnQgcmV0OwoKCWlmIChyZXBvX29pZF90b19hbGdvcChyLCBpbnB1dF9vaWQsIHItPmhhc2hfYWxnbywgJm9pZCkpIHsKCQlpZiAoZG9fZGllKQoJCQlkaWUoXygibWlzc2luZyBtYXBwaW5nIG9mICVzIHRvICVzIiksCgkJCSAgICBvaWRfdG9faGV4KGlucHV0X29pZCksIHItPmhhc2hfYWxnby0+bmFtZSk7CgkJcmV0dXJuIC0xOwoJfQoKCS8qIElzIG5ld19vaSBuZWVkZWQ/ICovCglvaSA9IGlucHV0X29pOwoJaWYgKGlucHV0X29pICYmIChpbnB1dF9vaS0+ZGVsdGFfYmFzZV9vaWQgfHwgaW5wdXRfb2ktPnNpemVwIHx8CgkJCSBpbnB1dF9vaS0+Y29udGVudHApKSB7CgkJbmV3X29pID0gKmlucHV0X29pOwoJCS8qIERvZXMgZGVsdGFfYmFzZV9vaWQgbmVlZCB0byBiZSBjb252ZXJ0ZWQ/ICovCgkJaWYgKGlucHV0X29pLT5kZWx0YV9iYXNlX29pZCkKCQkJbmV3X29pLmRlbHRhX2Jhc2Vfb2lkID0gJmRlbHRhX2Jhc2Vfb2lkOwoJCS8qIFdpbGwgdGhlIGF0dHJpYnV0ZXMgZGlmZmVyIHdoZW4gY29udmVydGVkPyAqLwoJCWlmIChpbnB1dF9vaS0+c2l6ZXAgfHwgaW5wdXRfb2ktPmNvbnRlbnRwKSB7CgkJCW5ld19vaS5jb250ZW50cCA9ICZjb250ZW50OwoJCQluZXdfb2kuc2l6ZXAgPSAmc2l6ZTsKCQkJbmV3X29pLnR5cGVwID0gJnR5cGU7CgkJfQoJCW9pID0gJm5ld19vaTsKCX0KCglyZXQgPSBvZGJfcmVhZF9vYmplY3RfaW5mb19leHRlbmRlZChyLT5vYmplY3RzLCAmb2lkLCBvaSwgZmxhZ3MpOwoJaWYgKHJldCkKCQlyZXR1cm4gLTE7CglpZiAob2kgPT0gaW5wdXRfb2kpCgkJcmV0dXJuIHJldDsKCglpZiAobmV3X29pLmNvbnRlbnRwKSB7CgkJc3RydWN0IHN0cmJ1ZiBvdXRidWYgPSBTVFJCVUZfSU5JVDsKCgkJaWYgKHR5cGUgIT0gT0JKX0JMT0IpIHsKCQkJcmV0ID0gY29udmVydF9vYmplY3RfZmlsZShyLCAmb3V0YnVmLAoJCQkJCQkgIHItPmhhc2hfYWxnbywgaW5wdXRfYWxnbywKCQkJCQkJICBjb250ZW50LCBzaXplLCB0eXBlLCAhZG9fZGllKTsKCQkJZnJlZShjb250ZW50KTsKCQkJaWYgKHJldCA9PSAtMSkKCQkJCXJldHVybiAtMTsKCQkJc2l6ZSA9IG91dGJ1Zi5sZW47CgkJCWNvbnRlbnQgPSBzdHJidWZfZGV0YWNoKCZvdXRidWYsIE5VTEwpOwoJCX0KCQlpZiAoaW5wdXRfb2ktPnNpemVwKQoJCQkqaW5wdXRfb2ktPnNpemVwID0gc2l6ZTsKCQlpZiAoaW5wdXRfb2ktPmNvbnRlbnRwKQoJCQkqaW5wdXRfb2ktPmNvbnRlbnRwID0gY29udGVudDsKCQllbHNlCgkJCWZyZWUoY29udGVudCk7CgkJaWYgKGlucHV0X29pLT50eXBlcCkKCQkJKmlucHV0X29pLT50eXBlcCA9IHR5cGU7Cgl9CglpZiAobmV3X29pLmRlbHRhX2Jhc2Vfb2lkID09ICZkZWx0YV9iYXNlX29pZCkgewoJCWlmIChyZXBvX29pZF90b19hbGdvcChyLCAmZGVsdGFfYmFzZV9vaWQsIGlucHV0X2FsZ28sCgkJCQkgaW5wdXRfb2ktPmRlbHRhX2Jhc2Vfb2lkKSkgewoJCQlpZiAoZG9fZGllKQoJCQkJZGllKF8oIm1pc3NpbmcgbWFwcGluZyBvZiAlcyB0byAlcyIpLAoJCQkJICAgIG9pZF90b19oZXgoJmRlbHRhX2Jhc2Vfb2lkKSwKCQkJCSAgICBpbnB1dF9hbGdvLT5uYW1lKTsKCQkJcmV0dXJuIC0xOwoJCX0KCX0KCWlucHV0X29pLT53aGVuY2UgPSBuZXdfb2kud2hlbmNlOwoJaW5wdXRfb2ktPnUgPSBuZXdfb2kudTsKCXJldHVybiByZXQ7Cn0KCmludCBvZGJfcmVhZF9vYmplY3RfaW5mb19leHRlbmRlZChzdHJ1Y3Qgb2JqZWN0X2RhdGFiYXNlICpvZGIsCgkJCQkgIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwKCQkJCSAgc3RydWN0IG9iamVjdF9pbmZvICpvaSwKCQkJCSAgdW5zaWduZWQgZmxhZ3MpCnsKCWludCByZXQ7CgoJaWYgKG9pZC0+YWxnbyAmJiAoaGFzaF9hbGdvX2J5X3B0cihvZGItPnJlcG8tPmhhc2hfYWxnbykgIT0gb2lkLT5hbGdvKSkKCQlyZXR1cm4gb2lkX29iamVjdF9pbmZvX2NvbnZlcnQob2RiLT5yZXBvLCBvaWQsIG9pLCBmbGFncyk7CgoJb2JqX3JlYWRfbG9jaygpOwoJcmV0ID0gZG9fb2lkX29iamVjdF9pbmZvX2V4dGVuZGVkKG9kYiwgb2lkLCBvaSwgZmxhZ3MpOwoJb2JqX3JlYWRfdW5sb2NrKCk7CglyZXR1cm4gcmV0Owp9CgoKLyogcmV0dXJucyBlbnVtIG9iamVjdF90eXBlIG9yIG5lZ2F0aXZlICovCmludCBvZGJfcmVhZF9vYmplY3RfaW5mbyhzdHJ1Y3Qgb2JqZWN0X2RhdGFiYXNlICpvZGIsCgkJCSBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsCgkJCSB1bnNpZ25lZCBsb25nICpzaXplcCkKewoJZW51bSBvYmplY3RfdHlwZSB0eXBlOwoJc3RydWN0IG9iamVjdF9pbmZvIG9pID0gT0JKRUNUX0lORk9fSU5JVDsKCglvaS50eXBlcCA9ICZ0eXBlOwoJb2kuc2l6ZXAgPSBzaXplcDsKCWlmIChvZGJfcmVhZF9vYmplY3RfaW5mb19leHRlbmRlZChvZGIsIG9pZCwgJm9pLAoJCQkJCSAgT0JKRUNUX0lORk9fTE9PS1VQX1JFUExBQ0UpIDwgMCkKCQlyZXR1cm4gLTE7CglyZXR1cm4gdHlwZTsKfQoKaW50IG9kYl9wcmV0ZW5kX29iamVjdChzdHJ1Y3Qgb2JqZWN0X2RhdGFiYXNlICpvZGIsCgkJICAgICAgIHZvaWQgKmJ1ZiwgdW5zaWduZWQgbG9uZyBsZW4sIGVudW0gb2JqZWN0X3R5cGUgdHlwZSwKCQkgICAgICAgc3RydWN0IG9iamVjdF9pZCAqb2lkKQp7CglzdHJ1Y3QgY2FjaGVkX29iamVjdF9lbnRyeSAqY287CgljaGFyICpjb19idWY7CgoJaGFzaF9vYmplY3RfZmlsZShvZGItPnJlcG8tPmhhc2hfYWxnbywgYnVmLCBsZW4sIHR5cGUsIG9pZCk7CglpZiAob2RiX2hhc19vYmplY3Qob2RiLCBvaWQsIDApIHx8CgkgICAgZmluZF9jYWNoZWRfb2JqZWN0KG9kYiwgb2lkKSkKCQlyZXR1cm4gMDsKCglBTExPQ19HUk9XKG9kYi0+Y2FjaGVkX29iamVjdHMsCgkJICAgb2RiLT5jYWNoZWRfb2JqZWN0X25yICsgMSwgb2RiLT5jYWNoZWRfb2JqZWN0X2FsbG9jKTsKCWNvID0gJm9kYi0+Y2FjaGVkX29iamVjdHNbb2RiLT5jYWNoZWRfb2JqZWN0X25yKytdOwoJY28tPnZhbHVlLnNpemUgPSBsZW47Cgljby0+dmFsdWUudHlwZSA9IHR5cGU7Cgljb19idWYgPSB4bWFsbG9jKGxlbik7CgltZW1jcHkoY29fYnVmLCBidWYsIGxlbik7Cgljby0+dmFsdWUuYnVmID0gY29fYnVmOwoJb2lkY3B5KCZjby0+b2lkLCBvaWQpOwoJcmV0dXJuIDA7Cn0KCnZvaWQgKm9kYl9yZWFkX29iamVjdChzdHJ1Y3Qgb2JqZWN0X2RhdGFiYXNlICpvZGIsCgkJICAgICAgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLAoJCSAgICAgIGVudW0gb2JqZWN0X3R5cGUgKnR5cGUsCgkJICAgICAgdW5zaWduZWQgbG9uZyAqc2l6ZSkKewoJc3RydWN0IG9iamVjdF9pbmZvIG9pID0gT0JKRUNUX0lORk9fSU5JVDsKCXVuc2lnbmVkIGZsYWdzID0gT0JKRUNUX0lORk9fRElFX0lGX0NPUlJVUFQgfCBPQkpFQ1RfSU5GT19MT09LVVBfUkVQTEFDRTsKCXZvaWQgKmRhdGE7CgoJb2kudHlwZXAgPSB0eXBlOwoJb2kuc2l6ZXAgPSBzaXplOwoJb2kuY29udGVudHAgPSAmZGF0YTsKCWlmIChvZGJfcmVhZF9vYmplY3RfaW5mb19leHRlbmRlZChvZGIsIG9pZCwgJm9pLCBmbGFncykpCgkJcmV0dXJuIE5VTEw7CgoJcmV0dXJuIGRhdGE7Cn0KCnZvaWQgKm9kYl9yZWFkX29iamVjdF9wZWVsZWQoc3RydWN0IG9iamVjdF9kYXRhYmFzZSAqb2RiLAoJCQkgICAgIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwKCQkJICAgICBlbnVtIG9iamVjdF90eXBlIHJlcXVpcmVkX3R5cGUsCgkJCSAgICAgdW5zaWduZWQgbG9uZyAqc2l6ZSwKCQkJICAgICBzdHJ1Y3Qgb2JqZWN0X2lkICphY3R1YWxfb2lkX3JldHVybikKewoJZW51bSBvYmplY3RfdHlwZSB0eXBlOwoJdm9pZCAqYnVmZmVyOwoJdW5zaWduZWQgbG9uZyBpc2l6ZTsKCXN0cnVjdCBvYmplY3RfaWQgYWN0dWFsX29pZDsKCglvaWRjcHkoJmFjdHVhbF9vaWQsIG9pZCk7Cgl3aGlsZSAoMSkgewoJCWludCByZWZfbGVuZ3RoID0gLTE7CgkJY29uc3QgY2hhciAqcmVmX3R5cGUgPSBOVUxMOwoKCQlidWZmZXIgPSBvZGJfcmVhZF9vYmplY3Qob2RiLCAmYWN0dWFsX29pZCwgJnR5cGUsICZpc2l6ZSk7CgkJaWYgKCFidWZmZXIpCgkJCXJldHVybiBOVUxMOwoJCWlmICh0eXBlID09IHJlcXVpcmVkX3R5cGUpIHsKCQkJKnNpemUgPSBpc2l6ZTsKCQkJaWYgKGFjdHVhbF9vaWRfcmV0dXJuKQoJCQkJb2lkY3B5KGFjdHVhbF9vaWRfcmV0dXJuLCAmYWN0dWFsX29pZCk7CgkJCXJldHVybiBidWZmZXI7CgkJfQoJCS8qIEhhbmRsZSByZWZlcmVuY2VzICovCgkJZWxzZSBpZiAodHlwZSA9PSBPQkpfQ09NTUlUKQoJCQlyZWZfdHlwZSA9ICJ0cmVlICI7CgkJZWxzZSBpZiAodHlwZSA9PSBPQkpfVEFHKQoJCQlyZWZfdHlwZSA9ICJvYmplY3QgIjsKCQllbHNlIHsKCQkJZnJlZShidWZmZXIpOwoJCQlyZXR1cm4gTlVMTDsKCQl9CgkJcmVmX2xlbmd0aCA9IHN0cmxlbihyZWZfdHlwZSk7CgoJCWlmIChyZWZfbGVuZ3RoICsgb2RiLT5yZXBvLT5oYXNoX2FsZ28tPmhleHN6ID4gaXNpemUgfHwKCQkgICAgbWVtY21wKGJ1ZmZlciwgcmVmX3R5cGUsIHJlZl9sZW5ndGgpIHx8CgkJICAgIGdldF9vaWRfaGV4X2FsZ29wKChjaGFyICopIGJ1ZmZlciArIHJlZl9sZW5ndGgsICZhY3R1YWxfb2lkLAoJCQkJICAgICAgb2RiLT5yZXBvLT5oYXNoX2FsZ28pKSB7CgkJCWZyZWUoYnVmZmVyKTsKCQkJcmV0dXJuIE5VTEw7CgkJfQoJCWZyZWUoYnVmZmVyKTsKCQkvKiBOb3cgd2UgaGF2ZSB0aGUgSUQgb2YgdGhlIHJlZmVycmVkLXRvIG9iamVjdCBpbgoJCSAqIGFjdHVhbF9vaWQuICBDaGVjayBhZ2Fpbi4gKi8KCX0KfQoKaW50IG9kYl9oYXNfb2JqZWN0KHN0cnVjdCBvYmplY3RfZGF0YWJhc2UgKm9kYiwgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLAoJICAgICAgIHVuc2lnbmVkIGZsYWdzKQp7Cgl1bnNpZ25lZCBvYmplY3RfaW5mb19mbGFncyA9IDA7CgoJaWYgKCFzdGFydHVwX2luZm8tPmhhdmVfcmVwb3NpdG9yeSkKCQlyZXR1cm4gMDsKCWlmICghKGZsYWdzICYgSEFTX09CSkVDVF9SRUNIRUNLX1BBQ0tFRCkpCgkJb2JqZWN0X2luZm9fZmxhZ3MgfD0gT0JKRUNUX0lORk9fUVVJQ0s7CglpZiAoIShmbGFncyAmIEhBU19PQkpFQ1RfRkVUQ0hfUFJPTUlTT1IpKQoJCW9iamVjdF9pbmZvX2ZsYWdzIHw9IE9CSkVDVF9JTkZPX1NLSVBfRkVUQ0hfT0JKRUNUOwoKCXJldHVybiBvZGJfcmVhZF9vYmplY3RfaW5mb19leHRlbmRlZChvZGIsIG9pZCwgTlVMTCwgb2JqZWN0X2luZm9fZmxhZ3MpID49IDA7Cn0KCnZvaWQgb2RiX2Fzc2VydF9vaWRfdHlwZShzdHJ1Y3Qgb2JqZWN0X2RhdGFiYXNlICpvZGIsCgkJCSBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsIGVudW0gb2JqZWN0X3R5cGUgZXhwZWN0KQp7CgllbnVtIG9iamVjdF90eXBlIHR5cGUgPSBvZGJfcmVhZF9vYmplY3RfaW5mbyhvZGIsIG9pZCwgTlVMTCk7CglpZiAodHlwZSA8IDApCgkJZGllKF8oIiVzIGlzIG5vdCBhIHZhbGlkIG9iamVjdCIpLCBvaWRfdG9faGV4KG9pZCkpOwoJaWYgKHR5cGUgIT0gZXhwZWN0KQoJCWRpZShfKCIlcyBpcyBub3QgYSB2YWxpZCAnJXMnIG9iamVjdCIpLCBvaWRfdG9faGV4KG9pZCksCgkJICAgIHR5cGVfbmFtZShleHBlY3QpKTsKfQoKaW50IG9kYl93cml0ZV9vYmplY3RfZXh0KHN0cnVjdCBvYmplY3RfZGF0YWJhc2UgKm9kYiwKCQkJIGNvbnN0IHZvaWQgKmJ1ZiwgdW5zaWduZWQgbG9uZyBsZW4sCgkJCSBlbnVtIG9iamVjdF90eXBlIHR5cGUsCgkJCSBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsCgkJCSBzdHJ1Y3Qgb2JqZWN0X2lkICpjb21wYXRfb2lkLAoJCQkgdW5zaWduZWQgZmxhZ3MpCnsKCXJldHVybiB3cml0ZV9vYmplY3RfZmlsZShvZGItPnNvdXJjZXMsIGJ1ZiwgbGVuLCB0eXBlLCBvaWQsIGNvbXBhdF9vaWQsIGZsYWdzKTsKfQoKc3RydWN0IG9iamVjdF9kYXRhYmFzZSAqb2RiX25ldyhzdHJ1Y3QgcmVwb3NpdG9yeSAqcmVwbykKewoJc3RydWN0IG9iamVjdF9kYXRhYmFzZSAqbyA9IHhtYWxsb2Moc2l6ZW9mKCpvKSk7CgoJbWVtc2V0KG8sIDAsIHNpemVvZigqbykpOwoJby0+cmVwbyA9IHJlcG87CglvLT5wYWNrZmlsZXMgPSBwYWNrZmlsZV9zdG9yZV9uZXcobyk7CglwdGhyZWFkX211dGV4X2luaXQoJm8tPnJlcGxhY2VfbXV0ZXgsIE5VTEwpOwoJc3RyaW5nX2xpc3RfaW5pdF9kdXAoJm8tPnN1Ym1vZHVsZV9zb3VyY2VfcGF0aHMpOwoJcmV0dXJuIG87Cn0KCnN0YXRpYyB2b2lkIGZyZWVfb2JqZWN0X2RpcmVjdG9yaWVzKHN0cnVjdCBvYmplY3RfZGF0YWJhc2UgKm8pCnsKCXdoaWxlIChvLT5zb3VyY2VzKSB7CgkJc3RydWN0IG9kYl9zb3VyY2UgKm5leHQ7CgoJCW5leHQgPSBvLT5zb3VyY2VzLT5uZXh0OwoJCWZyZWVfb2JqZWN0X2RpcmVjdG9yeShvLT5zb3VyY2VzKTsKCQlvLT5zb3VyY2VzID0gbmV4dDsKCX0KCWtoX2Rlc3Ryb3lfb2RiX3BhdGhfbWFwKG8tPnNvdXJjZV9ieV9wYXRoKTsKCW8tPnNvdXJjZV9ieV9wYXRoID0gTlVMTDsKfQoKdm9pZCBvZGJfY2xlYXIoc3RydWN0IG9iamVjdF9kYXRhYmFzZSAqbykKewoJRlJFRV9BTkRfTlVMTChvLT5hbHRlcm5hdGVfZGIpOwoKCW9pZG1hcF9jbGVhcigmby0+cmVwbGFjZV9tYXAsIDEpOwoJcHRocmVhZF9tdXRleF9kZXN0cm95KCZvLT5yZXBsYWNlX211dGV4KTsKCglmcmVlX2NvbW1pdF9ncmFwaChvLT5jb21taXRfZ3JhcGgpOwoJby0+Y29tbWl0X2dyYXBoID0gTlVMTDsKCW8tPmNvbW1pdF9ncmFwaF9hdHRlbXB0ZWQgPSAwOwoKCWZyZWVfb2JqZWN0X2RpcmVjdG9yaWVzKG8pOwoJby0+c291cmNlc190YWlsID0gTlVMTDsKCW8tPmxvYWRlZF9hbHRlcm5hdGVzID0gMDsKCglmb3IgKHNpemVfdCBpID0gMDsgaSA8IG8tPmNhY2hlZF9vYmplY3RfbnI7IGkrKykKCQlmcmVlKChjaGFyICopIG8tPmNhY2hlZF9vYmplY3RzW2ldLnZhbHVlLmJ1Zik7CglGUkVFX0FORF9OVUxMKG8tPmNhY2hlZF9vYmplY3RzKTsKCgljbG9zZV9vYmplY3Rfc3RvcmUobyk7CglwYWNrZmlsZV9zdG9yZV9mcmVlKG8tPnBhY2tmaWxlcyk7CglvLT5wYWNrZmlsZXMgPSBOVUxMOwoKCXN0cmluZ19saXN0X2NsZWFyKCZvLT5zdWJtb2R1bGVfc291cmNlX3BhdGhzLCAwKTsKfQoKdm9pZCBvZGJfcmVwcmVwYXJlKHN0cnVjdCBvYmplY3RfZGF0YWJhc2UgKm8pCnsKCXN0cnVjdCBvZGJfc291cmNlICpzb3VyY2U7CgoJb2JqX3JlYWRfbG9jaygpOwoKCS8qCgkgKiBSZXByZXBhcmUgYWx0IG9kYnMsIGluIGNhc2UgdGhlIGFsdGVybmF0ZXMgZmlsZSB3YXMgbW9kaWZpZWQKCSAqIGR1cmluZyB0aGUgY291cnNlIG9mIHRoaXMgcHJvY2Vzcy4gVGhpcyBvbmx5IF9hZGRzXyBvZGJzIHRvCgkgKiB0aGUgbGlua2VkIGxpc3QsIHNvIGV4aXN0aW5nIG9kYnMgd2lsbCBjb250aW51ZSB0byBleGlzdCBmb3IKCSAqIHRoZSBsaWZldGltZSBvZiB0aGUgcHJvY2Vzcy4KCSAqLwoJby0+bG9hZGVkX2FsdGVybmF0ZXMgPSAwOwoJb2RiX3ByZXBhcmVfYWx0ZXJuYXRlcyhvKTsKCglmb3IgKHNvdXJjZSA9IG8tPnNvdXJjZXM7IHNvdXJjZTsgc291cmNlID0gc291cmNlLT5uZXh0KQoJCW9kYl9jbGVhcl9sb29zZV9jYWNoZShzb3VyY2UpOwoKCW8tPmFwcHJveGltYXRlX29iamVjdF9jb3VudF92YWxpZCA9IDA7CgoJcGFja2ZpbGVfc3RvcmVfcmVwcmVwYXJlKG8tPnBhY2tmaWxlcyk7CgoJb2JqX3JlYWRfdW5sb2NrKCk7Cn0KCnN0cnVjdCBvZGJfdHJhbnNhY3Rpb24gKm9kYl90cmFuc2FjdGlvbl9iZWdpbihzdHJ1Y3Qgb2JqZWN0X2RhdGFiYXNlICpvZGIpCnsKCXJldHVybiBvYmplY3RfZmlsZV90cmFuc2FjdGlvbl9iZWdpbihvZGItPnNvdXJjZXMpOwp9Cgp2b2lkIG9kYl90cmFuc2FjdGlvbl9jb21taXQoc3RydWN0IG9kYl90cmFuc2FjdGlvbiAqdHJhbnNhY3Rpb24pCnsKCW9iamVjdF9maWxlX3RyYW5zYWN0aW9uX2NvbW1pdCh0cmFuc2FjdGlvbik7Cn0K",
    "text": "#include \"git-compat-util.h\"\n#include \"abspath.h\"\n#include \"commit-graph.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"environment.h\"\n#include \"gettext.h\"\n#include \"hex.h\"\n#include \"khash.h\"\n#include \"lockfile.h\"\n#include \"loose.h\"\n#include \"object-file-convert.h\"\n#include \"object-file.h\"\n#include \"odb.h\"\n#include \"packfile.h\"\n#include \"path.h\"\n#include \"promisor-remote.h\"\n#include \"quote.h\"\n#include \"replace-object.h\"\n#include \"run-command.h\"\n#include \"setup.h\"\n#include \"strbuf.h\"\n#include \"strvec.h\"\n#include \"submodule.h\"\n#include \"trace2.h\"\n#include \"write-or-die.h\"\n\nKHASH_INIT(odb_path_map, const char * /* key: odb_path */,\n\tstruct odb_source *, 1, fspathhash, fspatheq)\n\n/*\n * This is meant to hold a *small* number of objects that you would\n * want odb_read_object() to be able to return, but yet you do not want\n * to write them into the object store (e.g. a browse-only\n * application).\n */\nstruct cached_object_entry {\n\tstruct object_id oid;\n\tstruct cached_object {\n\t\tenum object_type type;\n\t\tconst void *buf;\n\t\tunsigned long size;\n\t} value;\n};\n\nstatic const struct cached_object *find_cached_object(struct object_database *object_store,\n\t\t\t\t\t\t      const struct object_id *oid)\n{\n\tstatic const struct cached_object empty_tree = {\n\t\t.type = OBJ_TREE,\n\t\t.buf = \"\",\n\t};\n\tconst struct cached_object_entry *co = object_store->cached_objects;\n\n\tfor (size_t i = 0; i < object_store->cached_object_nr; i++, co++)\n\t\tif (oideq(&co->oid, oid))\n\t\t\treturn &co->value;\n\n\tif (oid->algo && oideq(oid, hash_algos[oid->algo].empty_tree))\n\t\treturn &empty_tree;\n\n\treturn NULL;\n}\n\nint odb_mkstemp(struct object_database *odb,\n\t\tstruct strbuf *temp_filename, const char *pattern)\n{\n\tint fd;\n\t/*\n\t * we let the umask do its job, don't try to be more\n\t * restrictive except to remove write permission.\n\t */\n\tint mode = 0444;\n\trepo_git_path_replace(odb->repo, temp_filename, \"objects/%s\", pattern);\n\tfd = git_mkstemp_mode(temp_filename->buf, mode);\n\tif (0 <= fd)\n\t\treturn fd;\n\n\t/* slow path */\n\t/* some mkstemp implementations erase temp_filename on failure */\n\trepo_git_path_replace(odb->repo, temp_filename, \"objects/%s\", pattern);\n\tsafe_create_leading_directories(odb->repo, temp_filename->buf);\n\treturn xmkstemp_mode(temp_filename->buf, mode);\n}\n\n/*\n * Return non-zero iff the path is usable as an alternate object database.\n */\nstatic int alt_odb_usable(struct object_database *o,\n\t\t\t  struct strbuf *path,\n\t\t\t  const char *normalized_objdir, khiter_t *pos)\n{\n\tint r;\n\n\t/* Detect cases where alternate disappeared */\n\tif (!is_directory(path->buf)) {\n\t\terror(_(\"object directory %s does not exist; \"\n\t\t\t\"check .git/objects/info/alternates\"),\n\t\t      path->buf);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Prevent the common mistake of listing the same\n\t * thing twice, or object directory itself.\n\t */\n\tif (!o->source_by_path) {\n\t\tkhiter_t p;\n\n\t\to->source_by_path = kh_init_odb_path_map();\n\t\tassert(!o->sources->next);\n\t\tp = kh_put_odb_path_map(o->source_by_path, o->sources->path, &r);\n\t\tassert(r == 1); /* never used */\n\t\tkh_value(o->source_by_path, p) = o->sources;\n\t}\n\tif (fspatheq(path->buf, normalized_objdir))\n\t\treturn 0;\n\t*pos = kh_put_odb_path_map(o->source_by_path, path->buf, &r);\n\t/* r: 0 = exists, 1 = never used, 2 = deleted */\n\treturn r == 0 ? 0 : 1;\n}\n\n/*\n * Prepare alternate object database registry.\n *\n * The variable alt_odb_list points at the list of struct\n * odb_source.  The elements on this list come from\n * non-empty elements from colon separated ALTERNATE_DB_ENVIRONMENT\n * environment variable, and $GIT_OBJECT_DIRECTORY/info/alternates,\n * whose contents is similar to that environment variable but can be\n * LF separated.  Its base points at a statically allocated buffer that\n * contains \"/the/directory/corresponding/to/.git/objects/...\", while\n * its name points just after the slash at the end of \".git/objects/\"\n * in the example above, and has enough space to hold all hex characters\n * of the object ID, an extra slash for the first level indirection, and\n * the terminating NUL.\n */\nstatic void read_info_alternates(struct object_database *odb,\n\t\t\t\t const char *relative_base,\n\t\t\t\t int depth);\n\nstatic struct odb_source *link_alt_odb_entry(struct object_database *odb,\n\t\t\t\t\t     const char *dir,\n\t\t\t\t\t     const char *relative_base,\n\t\t\t\t\t     int depth)\n{\n\tstruct odb_source *alternate = NULL;\n\tstruct strbuf pathbuf = STRBUF_INIT;\n\tstruct strbuf tmp = STRBUF_INIT;\n\tkhiter_t pos;\n\n\tif (!is_absolute_path(dir) && relative_base) {\n\t\tstrbuf_realpath(&pathbuf, relative_base, 1);\n\t\tstrbuf_addch(&pathbuf, '/');\n\t}\n\tstrbuf_addstr(&pathbuf, dir);\n\n\tif (!strbuf_realpath(&tmp, pathbuf.buf, 0)) {\n\t\terror(_(\"unable to normalize alternate object path: %s\"),\n\t\t      pathbuf.buf);\n\t\tgoto error;\n\t}\n\tstrbuf_swap(&pathbuf, &tmp);\n\n\t/*\n\t * The trailing slash after the directory name is given by\n\t * this function at the end. Remove duplicates.\n\t */\n\twhile (pathbuf.len && pathbuf.buf[pathbuf.len - 1] == '/')\n\t\tstrbuf_setlen(&pathbuf, pathbuf.len - 1);\n\n\tstrbuf_reset(&tmp);\n\tstrbuf_realpath(&tmp, odb->sources->path, 1);\n\n\tif (!alt_odb_usable(odb, &pathbuf, tmp.buf, &pos))\n\t\tgoto error;\n\n\tCALLOC_ARRAY(alternate, 1);\n\talternate->odb = odb;\n\talternate->local = false;\n\t/* pathbuf.buf is already in r->objects->source_by_path */\n\talternate->path = strbuf_detach(&pathbuf, NULL);\n\n\t/* add the alternate entry */\n\t*odb->sources_tail = alternate;\n\todb->sources_tail = &(alternate->next);\n\talternate->next = NULL;\n\tassert(odb->source_by_path);\n\tkh_value(odb->source_by_path, pos) = alternate;\n\n\t/* recursively add alternates */\n\tread_info_alternates(odb, alternate->path, depth + 1);\n\n error:\n\tstrbuf_release(&tmp);\n\tstrbuf_release(&pathbuf);\n\treturn alternate;\n}\n\nstatic const char *parse_alt_odb_entry(const char *string,\n\t\t\t\t       int sep,\n\t\t\t\t       struct strbuf *out)\n{\n\tconst char *end;\n\n\tstrbuf_reset(out);\n\n\tif (*string == '#') {\n\t\t/* comment; consume up to next separator */\n\t\tend = strchrnul(string, sep);\n\t} else if (*string == '\"' && !unquote_c_style(out, string, &end)) {\n\t\t/*\n\t\t * quoted path; unquote_c_style has copied the\n\t\t * data for us and set \"end\". Broken quoting (e.g.,\n\t\t * an entry that doesn't end with a quote) falls\n\t\t * back to the unquoted case below.\n\t\t */\n\t} else {\n\t\t/* normal, unquoted path */\n\t\tend = strchrnul(string, sep);\n\t\tstrbuf_add(out, string, end - string);\n\t}\n\n\tif (*end)\n\t\tend++;\n\treturn end;\n}\n\nstatic void link_alt_odb_entries(struct object_database *odb, const char *alt,\n\t\t\t\t int sep, const char *relative_base, int depth)\n{\n\tstruct strbuf dir = STRBUF_INIT;\n\n\tif (!alt || !*alt)\n\t\treturn;\n\n\tif (depth > 5) {\n\t\terror(_(\"%s: ignoring alternate object stores, nesting too deep\"),\n\t\t\t\trelative_base);\n\t\treturn;\n\t}\n\n\twhile (*alt) {\n\t\talt = parse_alt_odb_entry(alt, sep, &dir);\n\t\tif (!dir.len)\n\t\t\tcontinue;\n\t\tlink_alt_odb_entry(odb, dir.buf, relative_base, depth);\n\t}\n\tstrbuf_release(&dir);\n}\n\nstatic void read_info_alternates(struct object_database *odb,\n\t\t\t\t const char *relative_base,\n\t\t\t\t int depth)\n{\n\tchar *path;\n\tstruct strbuf buf = STRBUF_INIT;\n\n\tpath = xstrfmt(\"%s/info/alternates\", relative_base);\n\tif (strbuf_read_file(&buf, path, 1024) < 0) {\n\t\twarn_on_fopen_errors(path);\n\t\tfree(path);\n\t\treturn;\n\t}\n\n\tlink_alt_odb_entries(odb, buf.buf, '\\n', relative_base, depth);\n\tstrbuf_release(&buf);\n\tfree(path);\n}\n\nvoid odb_add_to_alternates_file(struct object_database *odb,\n\t\t\t\tconst char *dir)\n{\n\tstruct lock_file lock = LOCK_INIT;\n\tchar *alts = repo_git_path(odb->repo, \"objects/info/alternates\");\n\tFILE *in, *out;\n\tint found = 0;\n\n\thold_lock_file_for_update(&lock, alts, LOCK_DIE_ON_ERROR);\n\tout = fdopen_lock_file(&lock, \"w\");\n\tif (!out)\n\t\tdie_errno(_(\"unable to fdopen alternates lockfile\"));\n\n\tin = fopen(alts, \"r\");\n\tif (in) {\n\t\tstruct strbuf line = STRBUF_INIT;\n\n\t\twhile (strbuf_getline(&line, in) != EOF) {\n\t\t\tif (!strcmp(dir, line.buf)) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfprintf_or_die(out, \"%s\\n\", line.buf);\n\t\t}\n\n\t\tstrbuf_release(&line);\n\t\tfclose(in);\n\t}\n\telse if (errno != ENOENT)\n\t\tdie_errno(_(\"unable to read alternates file\"));\n\n\tif (found) {\n\t\trollback_lock_file(&lock);\n\t} else {\n\t\tfprintf_or_die(out, \"%s\\n\", dir);\n\t\tif (commit_lock_file(&lock))\n\t\t\tdie_errno(_(\"unable to move new alternates file into place\"));\n\t\tif (odb->loaded_alternates)\n\t\t\tlink_alt_odb_entries(odb, dir, '\\n', NULL, 0);\n\t}\n\tfree(alts);\n}\n\nstruct odb_source *odb_add_to_alternates_memory(struct object_database *odb,\n\t\t\t\t\t\tconst char *dir)\n{\n\t/*\n\t * Make sure alternates are initialized, or else our entry may be\n\t * overwritten when they are.\n\t */\n\todb_prepare_alternates(odb);\n\treturn link_alt_odb_entry(odb, dir, NULL, 0);\n}\n\nstruct odb_source *odb_set_temporary_primary_source(struct object_database *odb,\n\t\t\t\t\t\t    const char *dir, int will_destroy)\n{\n\tstruct odb_source *source;\n\n\t/*\n\t * Make sure alternates are initialized, or else our entry may be\n\t * overwritten when they are.\n\t */\n\todb_prepare_alternates(odb);\n\n\t/*\n\t * Make a new primary odb and link the old primary ODB in as an\n\t * alternate\n\t */\n\tsource = xcalloc(1, sizeof(*source));\n\tsource->odb = odb;\n\tsource->path = xstrdup(dir);\n\n\t/*\n\t * Disable ref updates while a temporary odb is active, since\n\t * the objects in the database may roll back.\n\t */\n\tsource->disable_ref_updates = 1;\n\tsource->will_destroy = will_destroy;\n\tsource->next = odb->sources;\n\todb->sources = source;\n\treturn source->next;\n}\n\nstatic void free_object_directory(struct odb_source *source)\n{\n\tfree(source->path);\n\todb_clear_loose_cache(source);\n\tloose_object_map_clear(&source->loose_map);\n\tfree(source);\n}\n\nvoid odb_restore_primary_source(struct object_database *odb,\n\t\t\t\tstruct odb_source *restore_source,\n\t\t\t\tconst char *old_path)\n{\n\tstruct odb_source *cur_source = odb->sources;\n\n\tif (strcmp(old_path, cur_source->path))\n\t\tBUG(\"expected %s as primary object store; found %s\",\n\t\t    old_path, cur_source->path);\n\n\tif (cur_source->next != restore_source)\n\t\tBUG(\"we expect the old primary object store to be the first alternate\");\n\n\todb->sources = restore_source;\n\tfree_object_directory(cur_source);\n}\n\nchar *compute_alternate_path(const char *path, struct strbuf *err)\n{\n\tchar *ref_git = NULL;\n\tconst char *repo;\n\tint seen_error = 0;\n\n\tref_git = real_pathdup(path, 0);\n\tif (!ref_git) {\n\t\tseen_error = 1;\n\t\tstrbuf_addf(err, _(\"path '%s' does not exist\"), path);\n\t\tgoto out;\n\t}\n\n\trepo = read_gitfile(ref_git);\n\tif (!repo)\n\t\trepo = read_gitfile(mkpath(\"%s/.git\", ref_git));\n\tif (repo) {\n\t\tfree(ref_git);\n\t\tref_git = xstrdup(repo);\n\t}\n\n\tif (!repo && is_directory(mkpath(\"%s/.git/objects\", ref_git))) {\n\t\tchar *ref_git_git = mkpathdup(\"%s/.git\", ref_git);\n\t\tfree(ref_git);\n\t\tref_git = ref_git_git;\n\t} else if (!is_directory(mkpath(\"%s/objects\", ref_git))) {\n\t\tstruct strbuf sb = STRBUF_INIT;\n\t\tseen_error = 1;\n\t\tif (get_common_dir(&sb, ref_git)) {\n\t\t\tstrbuf_addf(err,\n\t\t\t\t    _(\"reference repository '%s' as a linked \"\n\t\t\t\t      \"checkout is not supported yet.\"),\n\t\t\t\t    path);\n\t\t\tgoto out;\n\t\t}\n\n\t\tstrbuf_addf(err, _(\"reference repository '%s' is not a \"\n\t\t\t\t\t\"local repository.\"), path);\n\t\tgoto out;\n\t}\n\n\tif (!access(mkpath(\"%s/shallow\", ref_git), F_OK)) {\n\t\tstrbuf_addf(err, _(\"reference repository '%s' is shallow\"),\n\t\t\t    path);\n\t\tseen_error = 1;\n\t\tgoto out;\n\t}\n\n\tif (!access(mkpath(\"%s/info/grafts\", ref_git), F_OK)) {\n\t\tstrbuf_addf(err,\n\t\t\t    _(\"reference repository '%s' is grafted\"),\n\t\t\t    path);\n\t\tseen_error = 1;\n\t\tgoto out;\n\t}\n\nout:\n\tif (seen_error) {\n\t\tFREE_AND_NULL(ref_git);\n\t}\n\n\treturn ref_git;\n}\n\nstruct odb_source *odb_find_source(struct object_database *odb, const char *obj_dir)\n{\n\tstruct odb_source *source;\n\tchar *obj_dir_real = real_pathdup(obj_dir, 1);\n\tstruct strbuf odb_path_real = STRBUF_INIT;\n\n\todb_prepare_alternates(odb);\n\tfor (source = odb->sources; source; source = source->next) {\n\t\tstrbuf_realpath(&odb_path_real, source->path, 1);\n\t\tif (!strcmp(obj_dir_real, odb_path_real.buf))\n\t\t\tbreak;\n\t}\n\n\tfree(obj_dir_real);\n\tstrbuf_release(&odb_path_real);\n\n\treturn source;\n}\n\nstruct odb_source *odb_find_source_or_die(struct object_database *odb, const char *obj_dir)\n{\n\tstruct odb_source *source = odb_find_source(odb, obj_dir);\n\tif (!source)\n\t\tdie(_(\"could not find object directory matching %s\"), obj_dir);\n\treturn source;\n}\n\nvoid odb_add_submodule_source_by_path(struct object_database *odb,\n\t\t\t\t      const char *path)\n{\n\tstring_list_insert(&odb->submodule_source_paths, path);\n}\n\nstatic void fill_alternate_refs_command(struct repository *repo,\n\t\t\t\t\tstruct child_process *cmd,\n\t\t\t\t\tconst char *repo_path)\n{\n\tconst char *value;\n\n\tif (!repo_config_get_value(repo, \"core.alternateRefsCommand\", &value)) {\n\t\tcmd->use_shell = 1;\n\n\t\tstrvec_push(&cmd->args, value);\n\t\tstrvec_push(&cmd->args, repo_path);\n\t} else {\n\t\tcmd->git_cmd = 1;\n\n\t\tstrvec_pushf(&cmd->args, \"--git-dir=%s\", repo_path);\n\t\tstrvec_push(&cmd->args, \"for-each-ref\");\n\t\tstrvec_push(&cmd->args, \"--format=%(objectname)\");\n\n\t\tif (!repo_config_get_value(repo, \"core.alternateRefsPrefixes\", &value)) {\n\t\t\tstrvec_push(&cmd->args, \"--\");\n\t\t\tstrvec_split(&cmd->args, value);\n\t\t}\n\t}\n\n\tstrvec_pushv(&cmd->env, (const char **)local_repo_env);\n\tcmd->out = -1;\n}\n\nstatic void read_alternate_refs(struct repository *repo,\n\t\t\t\tconst char *path,\n\t\t\t\todb_for_each_alternate_ref_fn *cb,\n\t\t\t\tvoid *payload)\n{\n\tstruct child_process cmd = CHILD_PROCESS_INIT;\n\tstruct strbuf line = STRBUF_INIT;\n\tFILE *fh;\n\n\tfill_alternate_refs_command(repo, &cmd, path);\n\n\tif (start_command(&cmd))\n\t\treturn;\n\n\tfh = xfdopen(cmd.out, \"r\");\n\twhile (strbuf_getline_lf(&line, fh) != EOF) {\n\t\tstruct object_id oid;\n\t\tconst char *p;\n\n\t\tif (parse_oid_hex_algop(line.buf, &oid, &p, repo->hash_algo) || *p) {\n\t\t\twarning(_(\"invalid line while parsing alternate refs: %s\"),\n\t\t\t\tline.buf);\n\t\t\tbreak;\n\t\t}\n\n\t\tcb(&oid, payload);\n\t}\n\n\tfclose(fh);\n\tfinish_command(&cmd);\n\tstrbuf_release(&line);\n}\n\nstruct alternate_refs_data {\n\todb_for_each_alternate_ref_fn *fn;\n\tvoid *payload;\n};\n\nstatic int refs_from_alternate_cb(struct odb_source *alternate,\n\t\t\t\t  void *payload)\n{\n\tstruct strbuf path = STRBUF_INIT;\n\tsize_t base_len;\n\tstruct alternate_refs_data *cb = payload;\n\n\tif (!strbuf_realpath(&path, alternate->path, 0))\n\t\tgoto out;\n\tif (!strbuf_strip_suffix(&path, \"/objects\"))\n\t\tgoto out;\n\tbase_len = path.len;\n\n\t/* Is this a git repository with refs? */\n\tstrbuf_addstr(&path, \"/refs\");\n\tif (!is_directory(path.buf))\n\t\tgoto out;\n\tstrbuf_setlen(&path, base_len);\n\n\tread_alternate_refs(alternate->odb->repo, path.buf, cb->fn, cb->payload);\n\nout:\n\tstrbuf_release(&path);\n\treturn 0;\n}\n\nvoid odb_for_each_alternate_ref(struct object_database *odb,\n\t\t\t\todb_for_each_alternate_ref_fn cb, void *payload)\n{\n\tstruct alternate_refs_data data;\n\tdata.fn = cb;\n\tdata.payload = payload;\n\todb_for_each_alternate(odb, refs_from_alternate_cb, &data);\n}\n\nint odb_for_each_alternate(struct object_database *odb,\n\t\t\t odb_for_each_alternate_fn cb, void *payload)\n{\n\tstruct odb_source *alternate;\n\tint r = 0;\n\n\todb_prepare_alternates(odb);\n\tfor (alternate = odb->sources->next; alternate; alternate = alternate->next) {\n\t\tr = cb(alternate, payload);\n\t\tif (r)\n\t\t\tbreak;\n\t}\n\treturn r;\n}\n\nvoid odb_prepare_alternates(struct object_database *odb)\n{\n\tif (odb->loaded_alternates)\n\t\treturn;\n\n\tlink_alt_odb_entries(odb, odb->alternate_db, PATH_SEP, NULL, 0);\n\n\tread_info_alternates(odb, odb->sources->path, 0);\n\todb->loaded_alternates = 1;\n}\n\nint odb_has_alternates(struct object_database *odb)\n{\n\todb_prepare_alternates(odb);\n\treturn !!odb->sources->next;\n}\n\nint obj_read_use_lock = 0;\npthread_mutex_t obj_read_mutex;\n\nvoid enable_obj_read_lock(void)\n{\n\tif (obj_read_use_lock)\n\t\treturn;\n\n\tobj_read_use_lock = 1;\n\tinit_recursive_mutex(&obj_read_mutex);\n}\n\nvoid disable_obj_read_lock(void)\n{\n\tif (!obj_read_use_lock)\n\t\treturn;\n\n\tobj_read_use_lock = 0;\n\tpthread_mutex_destroy(&obj_read_mutex);\n}\n\nint fetch_if_missing = 1;\n\nstatic int register_all_submodule_sources(struct object_database *odb)\n{\n\tint ret = odb->submodule_source_paths.nr;\n\n\tfor (size_t i = 0; i < odb->submodule_source_paths.nr; i++)\n\t\todb_add_to_alternates_memory(odb,\n\t\t\t\t\t     odb->submodule_source_paths.items[i].string);\n\tif (ret) {\n\t\tstring_list_clear(&odb->submodule_source_paths, 0);\n\t\ttrace2_data_intmax(\"submodule\", odb->repo,\n\t\t\t\t   \"register_all_submodule_sources/registered\", ret);\n\t\tif (git_env_bool(\"GIT_TEST_FATAL_REGISTER_SUBMODULE_ODB\", 0))\n\t\t\tBUG(\"register_all_submodule_sources() called\");\n\t}\n\treturn ret;\n}\n\nstatic int do_oid_object_info_extended(struct object_database *odb,\n\t\t\t\t       const struct object_id *oid,\n\t\t\t\t       struct object_info *oi, unsigned flags)\n{\n\tstatic struct object_info blank_oi = OBJECT_INFO_INIT;\n\tconst struct cached_object *co;\n\tstruct pack_entry e;\n\tint rtype;\n\tconst struct object_id *real = oid;\n\tint already_retried = 0;\n\n\n\tif (flags & OBJECT_INFO_LOOKUP_REPLACE)\n\t\treal = lookup_replace_object(odb->repo, oid);\n\n\tif (is_null_oid(real))\n\t\treturn -1;\n\n\tif (!oi)\n\t\toi = &blank_oi;\n\n\tco = find_cached_object(odb, real);\n\tif (co) {\n\t\tif (oi->typep)\n\t\t\t*(oi->typep) = co->type;\n\t\tif (oi->sizep)\n\t\t\t*(oi->sizep) = co->size;\n\t\tif (oi->disk_sizep)\n\t\t\t*(oi->disk_sizep) = 0;\n\t\tif (oi->delta_base_oid)\n\t\t\toidclr(oi->delta_base_oid, odb->repo->hash_algo);\n\t\tif (oi->contentp)\n\t\t\t*oi->contentp = xmemdupz(co->buf, co->size);\n\t\toi->whence = OI_CACHED;\n\t\treturn 0;\n\t}\n\n\twhile (1) {\n\t\tif (find_pack_entry(odb->repo, real, &e))\n\t\t\tbreak;\n\n\t\t/* Most likely it's a loose object. */\n\t\tif (!loose_object_info(odb->repo, real, oi, flags))\n\t\t\treturn 0;\n\n\t\t/* Not a loose object; someone else may have just packed it. */\n\t\tif (!(flags & OBJECT_INFO_QUICK)) {\n\t\t\todb_reprepare(odb->repo->objects);\n\t\t\tif (find_pack_entry(odb->repo, real, &e))\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * This might be an attempt at accessing a submodule object as\n\t\t * if it were in main object store (having called\n\t\t * `odb_add_submodule_source_by_path()` on that submodule's\n\t\t * ODB). If any such ODBs exist, register them and try again.\n\t\t */\n\t\tif (register_all_submodule_sources(odb))\n\t\t\t/* We added some alternates; retry */\n\t\t\tcontinue;\n\n\t\t/* Check if it is a missing object */\n\t\tif (fetch_if_missing && repo_has_promisor_remote(odb->repo) &&\n\t\t    !already_retried &&\n\t\t    !(flags & OBJECT_INFO_SKIP_FETCH_OBJECT)) {\n\t\t\tpromisor_remote_get_direct(odb->repo, real, 1);\n\t\t\talready_retried = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (flags & OBJECT_INFO_DIE_IF_CORRUPT) {\n\t\t\tconst struct packed_git *p;\n\t\t\tif ((flags & OBJECT_INFO_LOOKUP_REPLACE) && !oideq(real, oid))\n\t\t\t\tdie(_(\"replacement %s not found for %s\"),\n\t\t\t\t    oid_to_hex(real), oid_to_hex(oid));\n\t\t\tif ((p = has_packed_and_bad(odb->repo, real)))\n\t\t\t\tdie(_(\"packed object %s (stored in %s) is corrupt\"),\n\t\t\t\t    oid_to_hex(real), p->pack_name);\n\t\t}\n\t\treturn -1;\n\t}\n\n\tif (oi == &blank_oi)\n\t\t/*\n\t\t * We know that the caller doesn't actually need the\n\t\t * information below, so return early.\n\t\t */\n\t\treturn 0;\n\trtype = packed_object_info(odb->repo, e.p, e.offset, oi);\n\tif (rtype < 0) {\n\t\tmark_bad_packed_object(e.p, real);\n\t\treturn do_oid_object_info_extended(odb, real, oi, 0);\n\t} else if (oi->whence == OI_PACKED) {\n\t\toi->u.packed.offset = e.offset;\n\t\toi->u.packed.pack = e.p;\n\t\toi->u.packed.is_delta = (rtype == OBJ_REF_DELTA ||\n\t\t\t\t\t rtype == OBJ_OFS_DELTA);\n\t}\n\n\treturn 0;\n}\n\nstatic int oid_object_info_convert(struct repository *r,\n\t\t\t\t   const struct object_id *input_oid,\n\t\t\t\t   struct object_info *input_oi, unsigned flags)\n{\n\tconst struct git_hash_algo *input_algo = &hash_algos[input_oid->algo];\n\tint do_die = flags & OBJECT_INFO_DIE_IF_CORRUPT;\n\tenum object_type type;\n\tstruct object_id oid, delta_base_oid;\n\tstruct object_info new_oi, *oi;\n\tunsigned long size;\n\tvoid *content;\n\tint ret;\n\n\tif (repo_oid_to_algop(r, input_oid, r->hash_algo, &oid)) {\n\t\tif (do_die)\n\t\t\tdie(_(\"missing mapping of %s to %s\"),\n\t\t\t    oid_to_hex(input_oid), r->hash_algo->name);\n\t\treturn -1;\n\t}\n\n\t/* Is new_oi needed? */\n\toi = input_oi;\n\tif (input_oi && (input_oi->delta_base_oid || input_oi->sizep ||\n\t\t\t input_oi->contentp)) {\n\t\tnew_oi = *input_oi;\n\t\t/* Does delta_base_oid need to be converted? */\n\t\tif (input_oi->delta_base_oid)\n\t\t\tnew_oi.delta_base_oid = &delta_base_oid;\n\t\t/* Will the attributes differ when converted? */\n\t\tif (input_oi->sizep || input_oi->contentp) {\n\t\t\tnew_oi.contentp = &content;\n\t\t\tnew_oi.sizep = &size;\n\t\t\tnew_oi.typep = &type;\n\t\t}\n\t\toi = &new_oi;\n\t}\n\n\tret = odb_read_object_info_extended(r->objects, &oid, oi, flags);\n\tif (ret)\n\t\treturn -1;\n\tif (oi == input_oi)\n\t\treturn ret;\n\n\tif (new_oi.contentp) {\n\t\tstruct strbuf outbuf = STRBUF_INIT;\n\n\t\tif (type != OBJ_BLOB) {\n\t\t\tret = convert_object_file(r, &outbuf,\n\t\t\t\t\t\t  r->hash_algo, input_algo,\n\t\t\t\t\t\t  content, size, type, !do_die);\n\t\t\tfree(content);\n\t\t\tif (ret == -1)\n\t\t\t\treturn -1;\n\t\t\tsize = outbuf.len;\n\t\t\tcontent = strbuf_detach(&outbuf, NULL);\n\t\t}\n\t\tif (input_oi->sizep)\n\t\t\t*input_oi->sizep = size;\n\t\tif (input_oi->contentp)\n\t\t\t*input_oi->contentp = content;\n\t\telse\n\t\t\tfree(content);\n\t\tif (input_oi->typep)\n\t\t\t*input_oi->typep = type;\n\t}\n\tif (new_oi.delta_base_oid == &delta_base_oid) {\n\t\tif (repo_oid_to_algop(r, &delta_base_oid, input_algo,\n\t\t\t\t input_oi->delta_base_oid)) {\n\t\t\tif (do_die)\n\t\t\t\tdie(_(\"missing mapping of %s to %s\"),\n\t\t\t\t    oid_to_hex(&delta_base_oid),\n\t\t\t\t    input_algo->name);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tinput_oi->whence = new_oi.whence;\n\tinput_oi->u = new_oi.u;\n\treturn ret;\n}\n\nint odb_read_object_info_extended(struct object_database *odb,\n\t\t\t\t  const struct object_id *oid,\n\t\t\t\t  struct object_info *oi,\n\t\t\t\t  unsigned flags)\n{\n\tint ret;\n\n\tif (oid->algo && (hash_algo_by_ptr(odb->repo->hash_algo) != oid->algo))\n\t\treturn oid_object_info_convert(odb->repo, oid, oi, flags);\n\n\tobj_read_lock();\n\tret = do_oid_object_info_extended(odb, oid, oi, flags);\n\tobj_read_unlock();\n\treturn ret;\n}\n\n\n/* returns enum object_type or negative */\nint odb_read_object_info(struct object_database *odb,\n\t\t\t const struct object_id *oid,\n\t\t\t unsigned long *sizep)\n{\n\tenum object_type type;\n\tstruct object_info oi = OBJECT_INFO_INIT;\n\n\toi.typep = &type;\n\toi.sizep = sizep;\n\tif (odb_read_object_info_extended(odb, oid, &oi,\n\t\t\t\t\t  OBJECT_INFO_LOOKUP_REPLACE) < 0)\n\t\treturn -1;\n\treturn type;\n}\n\nint odb_pretend_object(struct object_database *odb,\n\t\t       void *buf, unsigned long len, enum object_type type,\n\t\t       struct object_id *oid)\n{\n\tstruct cached_object_entry *co;\n\tchar *co_buf;\n\n\thash_object_file(odb->repo->hash_algo, buf, len, type, oid);\n\tif (odb_has_object(odb, oid, 0) ||\n\t    find_cached_object(odb, oid))\n\t\treturn 0;\n\n\tALLOC_GROW(odb->cached_objects,\n\t\t   odb->cached_object_nr + 1, odb->cached_object_alloc);\n\tco = &odb->cached_objects[odb->cached_object_nr++];\n\tco->value.size = len;\n\tco->value.type = type;\n\tco_buf = xmalloc(len);\n\tmemcpy(co_buf, buf, len);\n\tco->value.buf = co_buf;\n\toidcpy(&co->oid, oid);\n\treturn 0;\n}\n\nvoid *odb_read_object(struct object_database *odb,\n\t\t      const struct object_id *oid,\n\t\t      enum object_type *type,\n\t\t      unsigned long *size)\n{\n\tstruct object_info oi = OBJECT_INFO_INIT;\n\tunsigned flags = OBJECT_INFO_DIE_IF_CORRUPT | OBJECT_INFO_LOOKUP_REPLACE;\n\tvoid *data;\n\n\toi.typep = type;\n\toi.sizep = size;\n\toi.contentp = &data;\n\tif (odb_read_object_info_extended(odb, oid, &oi, flags))\n\t\treturn NULL;\n\n\treturn data;\n}\n\nvoid *odb_read_object_peeled(struct object_database *odb,\n\t\t\t     const struct object_id *oid,\n\t\t\t     enum object_type required_type,\n\t\t\t     unsigned long *size,\n\t\t\t     struct object_id *actual_oid_return)\n{\n\tenum object_type type;\n\tvoid *buffer;\n\tunsigned long isize;\n\tstruct object_id actual_oid;\n\n\toidcpy(&actual_oid, oid);\n\twhile (1) {\n\t\tint ref_length = -1;\n\t\tconst char *ref_type = NULL;\n\n\t\tbuffer = odb_read_object(odb, &actual_oid, &type, &isize);\n\t\tif (!buffer)\n\t\t\treturn NULL;\n\t\tif (type == required_type) {\n\t\t\t*size = isize;\n\t\t\tif (actual_oid_return)\n\t\t\t\toidcpy(actual_oid_return, &actual_oid);\n\t\t\treturn buffer;\n\t\t}\n\t\t/* Handle references */\n\t\telse if (type == OBJ_COMMIT)\n\t\t\tref_type = \"tree \";\n\t\telse if (type == OBJ_TAG)\n\t\t\tref_type = \"object \";\n\t\telse {\n\t\t\tfree(buffer);\n\t\t\treturn NULL;\n\t\t}\n\t\tref_length = strlen(ref_type);\n\n\t\tif (ref_length + odb->repo->hash_algo->hexsz > isize ||\n\t\t    memcmp(buffer, ref_type, ref_length) ||\n\t\t    get_oid_hex_algop((char *) buffer + ref_length, &actual_oid,\n\t\t\t\t      odb->repo->hash_algo)) {\n\t\t\tfree(buffer);\n\t\t\treturn NULL;\n\t\t}\n\t\tfree(buffer);\n\t\t/* Now we have the ID of the referred-to object in\n\t\t * actual_oid.  Check again. */\n\t}\n}\n\nint odb_has_object(struct object_database *odb, const struct object_id *oid,\n\t       unsigned flags)\n{\n\tunsigned object_info_flags = 0;\n\n\tif (!startup_info->have_repository)\n\t\treturn 0;\n\tif (!(flags & HAS_OBJECT_RECHECK_PACKED))\n\t\tobject_info_flags |= OBJECT_INFO_QUICK;\n\tif (!(flags & HAS_OBJECT_FETCH_PROMISOR))\n\t\tobject_info_flags |= OBJECT_INFO_SKIP_FETCH_OBJECT;\n\n\treturn odb_read_object_info_extended(odb, oid, NULL, object_info_flags) >= 0;\n}\n\nvoid odb_assert_oid_type(struct object_database *odb,\n\t\t\t const struct object_id *oid, enum object_type expect)\n{\n\tenum object_type type = odb_read_object_info(odb, oid, NULL);\n\tif (type < 0)\n\t\tdie(_(\"%s is not a valid object\"), oid_to_hex(oid));\n\tif (type != expect)\n\t\tdie(_(\"%s is not a valid '%s' object\"), oid_to_hex(oid),\n\t\t    type_name(expect));\n}\n\nint odb_write_object_ext(struct object_database *odb,\n\t\t\t const void *buf, unsigned long len,\n\t\t\t enum object_type type,\n\t\t\t struct object_id *oid,\n\t\t\t struct object_id *compat_oid,\n\t\t\t unsigned flags)\n{\n\treturn write_object_file(odb->sources, buf, len, type, oid, compat_oid, flags);\n}\n\nstruct object_database *odb_new(struct repository *repo)\n{\n\tstruct object_database *o = xmalloc(sizeof(*o));\n\n\tmemset(o, 0, sizeof(*o));\n\to->repo = repo;\n\to->packfiles = packfile_store_new(o);\n\tpthread_mutex_init(&o->replace_mutex, NULL);\n\tstring_list_init_dup(&o->submodule_source_paths);\n\treturn o;\n}\n\nstatic void free_object_directories(struct object_database *o)\n{\n\twhile (o->sources) {\n\t\tstruct odb_source *next;\n\n\t\tnext = o->sources->next;\n\t\tfree_object_directory(o->sources);\n\t\to->sources = next;\n\t}\n\tkh_destroy_odb_path_map(o->source_by_path);\n\to->source_by_path = NULL;\n}\n\nvoid odb_clear(struct object_database *o)\n{\n\tFREE_AND_NULL(o->alternate_db);\n\n\toidmap_clear(&o->replace_map, 1);\n\tpthread_mutex_destroy(&o->replace_mutex);\n\n\tfree_commit_graph(o->commit_graph);\n\to->commit_graph = NULL;\n\to->commit_graph_attempted = 0;\n\n\tfree_object_directories(o);\n\to->sources_tail = NULL;\n\to->loaded_alternates = 0;\n\n\tfor (size_t i = 0; i < o->cached_object_nr; i++)\n\t\tfree((char *) o->cached_objects[i].value.buf);\n\tFREE_AND_NULL(o->cached_objects);\n\n\tclose_object_store(o);\n\tpackfile_store_free(o->packfiles);\n\to->packfiles = NULL;\n\n\tstring_list_clear(&o->submodule_source_paths, 0);\n}\n\nvoid odb_reprepare(struct object_database *o)\n{\n\tstruct odb_source *source;\n\n\tobj_read_lock();\n\n\t/*\n\t * Reprepare alt odbs, in case the alternates file was modified\n\t * during the course of this process. This only _adds_ odbs to\n\t * the linked list, so existing odbs will continue to exist for\n\t * the lifetime of the process.\n\t */\n\to->loaded_alternates = 0;\n\todb_prepare_alternates(o);\n\n\tfor (source = o->sources; source; source = source->next)\n\t\todb_clear_loose_cache(source);\n\n\to->approximate_object_count_valid = 0;\n\n\tpackfile_store_reprepare(o->packfiles);\n\n\tobj_read_unlock();\n}\n\nstruct odb_transaction *odb_transaction_begin(struct object_database *odb)\n{\n\treturn object_file_transaction_begin(odb->sources);\n}\n\nvoid odb_transaction_commit(struct odb_transaction *transaction)\n{\n\tobject_file_transaction_commit(transaction);\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00a6e71568b5985c0b344bfebbe92d1e0bff1294",
  "sha1_ok": true,
  "size": 27360
}
