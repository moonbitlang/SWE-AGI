{
  "content": {
    "base64": "IyEvdXNyL2Jpbi9wZXJsCgp1c2Ugc3RyaWN0Owp1c2UgRmlsZTo6U3BlYzsKCiRFTlZ7UEFUSH0gICAgID0gJy9vcHQvZ2l0L2Jpbic7Cm15ICRhY2xfZ2l0ICAgID0gJy92Y3MvYWNscy5naXQnOwpteSAkYWNsX2JyYW5jaCA9ICdyZWZzL2hlYWRzL21hc3Rlcic7Cm15ICRkZWJ1ZyAgICAgID0gMDsKCj1kb2MKSW52b2tlZCBhczogdXBkYXRlIHJlZm5hbWUgb2xkLXNoYTEgbmV3LXNoYTEKClRoaXMgc2NyaXB0IGlzIHJ1biBieSBnaXQtcmVjZWl2ZS1wYWNrIG9uY2UgZm9yIGVhY2ggcmVmIHRoYXQgdGhlCmNsaWVudCBpcyB0cnlpbmcgdG8gbW9kaWZ5LiAgSWYgd2UgZXhpdCB3aXRoIGEgbm9uLXplcm8gZXhpdCB2YWx1ZQp0aGVuIHRoZSB1cGRhdGUgZm9yIHRoYXQgcGFydGljdWxhciByZWYgaXMgZGVuaWVkLCBidXQgdXBkYXRlcyBmb3IKb3RoZXIgcmVmcyBpbiB0aGUgc2FtZSBydW4gb2YgcmVjZWl2ZS1wYWNrIG1heSBzdGlsbCBiZSBhbGxvd2VkLgoKV2UgYXJlIHJ1biBhZnRlciB0aGUgb2JqZWN0cyBoYXZlIGJlZW4gdXBsb2FkZWQsIGJ1dCBiZWZvcmUgdGhlCnJlZiBpcyBhY3R1YWxseSBtb2RpZmllZC4gIFdlIHRha2UgYWR2YW50YWdlIG9mIHRoYXQgZmFjdCB3aGVuIHdlCmxvb2sgZm9yICJuZXciIGNvbW1pdHMgYW5kIHRhZ3MgKHRoZSBuZXcgb2JqZWN0cyB3b24ndCBzaG93IHVwIGluCmByZXYtbGlzdCAtLWFsbGApLgoKVGhpcyBzY3JpcHQgbG9hZHMgYW5kIHBhcnNlcyB0aGUgY29udGVudCBvZiB0aGUgY29uZmlnIGZpbGUKInVzZXJzLyR0aGlzX3VzZXIuYWNsIiBmcm9tIHRoZSAkYWNsX2JyYW5jaCBjb21taXQgb2YgJGFjbF9naXQgT0RCLgpUaGUgYWNsIGZpbGUgaXMgYSBnaXQtY29uZmlnIHN0eWxlIGZpbGUsIGJ1dCB1c2VzIGEgc2xpZ2h0bHkgbW9yZQpyZXN0cmljdGVkIHN5bnRheCBhcyB0aGUgUGVybCBwYXJzZXIgY29udGFpbmVkIHdpdGhpbiB0aGlzIHNjcmlwdAppcyBub3QgbmVhcmx5IGFzIHBlcm1pc3NpdmUgYXMgZ2l0LWNvbmZpZy4KCkV4YW1wbGU6CgogIFt1c2VyXQogICAgY29tbWl0dGVyID0gSm9obiBEb2UgPGpvaG4uZG9lQGV4YW1wbGUuY29tPgogICAgY29tbWl0dGVyID0gSm9obiBSLiBEb2UgPGpvaG4uZG9lQGV4YW1wbGUuY29tPgoKICBbcmVwb3NpdG9yeSAiYWNscyJdCiAgICBhbGxvdyA9IGhlYWRzL21hc3RlcgogICAgYWxsb3cgPSBDRFVSIGZvciBoZWFkcy9qZC8KICAgIGFsbG93ID0gQyAgICBmb3IgXnRhZ3MvdlxcZCskCgpGb3IgYWxsIG5ldyBjb21taXQgb3IgdGFnIG9iamVjdHMgdGhlIGNvbW1pdHRlciAob3IgdGFnZ2VyKSBsaW5lCndpdGhpbiB0aGUgb2JqZWN0IG11c3QgZXhhY3RseSBtYXRjaCBvbmUgb2YgdGhlIHVzZXIuY29tbWl0dGVyCnZhbHVlcyBsaXN0ZWQgaW4gdGhlIGFjbCBmaWxlICgiSEVBRDp1c2Vycy8kdGhpc191c2VyLmFjbCIpLgoKRm9yIGEgYnJhbmNoIHRvIGJlIG1vZGlmaWVkIGFuIGFsbG93IGxpbmUgd2l0aGluIHRoZSBtYXRjaGluZwpyZXBvc2l0b3J5IHNlY3Rpb24gbXVzdCBiZSBtYXRjaGVkIGZvciBib3RoIHRoZSByZWZuYW1lIGFuZCB0aGUKb3Bjb2RlLgoKUmVwb3NpdG9yeSBzZWN0aW9ucyBhcmUgbWF0Y2hlZCBvbiB0aGUgYmFzZW5hbWUgb2YgdGhlIHJlcG9zaXRvcnkKKGFmdGVyIHJlbW92aW5nIHRoZSAuZ2l0IHN1ZmZpeCkuCgpUaGUgb3Bjb2RlIGFiYnJldmlhdGlvbnMgYXJlOgoKICBDOiBjcmVhdGUgbmV3IHJlZgogIEQ6IGRlbGV0ZSBleGlzdGluZyByZWYKICBVOiBmYXN0LWZvcndhcmQgZXhpc3RpbmcgcmVmIChubyBjb21taXQgbG9zcykKICBSOiByZXdpbmQvcmViYXNlIGV4aXN0aW5nIHJlZiAoY29tbWl0IGxvc3MpCgppZiBubyBvcGNvZGVzIGFyZSBsaXN0ZWQgYmVmb3JlIHRoZSAiZm9yIiBrZXl3b3JkIHRoZW4gIlUiIChmb3IKZmFzdC1mb3J3YXJkIHVwZGF0ZSBvbmx5KSBpcyBhc3N1bWVkIGFzIHRoaXMgaXMgdGhlIG1vc3QgY29tbW9uCnVzYWdlLgoKUmVmbmFtZXMgYXJlIG1hdGNoZWQgYnkgYWx3YXlzIGFzc3VtaW5nIGEgcHJlZml4IG9mICJyZWZzLyIuClRoaXMgaG9vayBmb3JiaWRzIHB1c2hpbmcgb3IgZGVsZXRpbmcgYW55dGhpbmcgbm90IHVuZGVyICJyZWZzLyIuCgpSZWZuYW1lcyB0aGF0IHN0YXJ0IHdpdGggXiBhcmUgUGVybCByZWd1bGFyIGV4cHJlc3Npb25zLCBhbmQgdGhlIF4KaXMga2VwdCBhcyBwYXJ0IG9mIHRoZSByZWdleHAuICBcXCBpcyBuZWVkZWQgdG8gZ2V0IGp1c3Qgb25lIFwsIHNvClxcZCBleHBhbmRzIHRvIFxkIGluIFBlcmwuICBUaGUgM3JkIGFsbG93IGxpbmUgYWJvdmUgaXMgYW4gZXhhbXBsZS4KClJlZm5hbWVzIHRoYXQgZG9uJ3Qgc3RhcnQgd2l0aCBeIGJ1dCB0aGF0IGVuZCB3aXRoIC8gYXJlIHByZWZpeAptYXRjaGVzICgybmQgYWxsb3cgbGluZSBhYm92ZSk7IGFsbCBvdGhlciByZWZuYW1lcyBhcmUgc3RyaWN0CmVxdWFsaXR5IG1hdGNoZXMgKDFzdCBhbGxvdyBsaW5lKS4KCkFueXRoaW5nIHB1c2hlZCB0byAiaGVhZHMvIiAob2ssIHJlYWxseSAicmVmcy9oZWFkcy8iKSBtdXN0IGJlCmEgY29tbWl0LiAgVGFncyBhcmUgbm90IHBlcm1pdHRlZCBoZXJlLgoKQW55dGhpbmcgcHVzaGVkIHRvICJ0YWdzLyIgKGVyciwgcmVhbGx5ICJyZWZzL3RhZ3MvIikgbXVzdCBiZSBhbgphbm5vdGF0ZWQgdGFnLiAgQ29tbWl0cywgYmxvYnMsIHRyZWVzLCBldGMuIGFyZSBub3QgcGVybWl0dGVkIGhlcmUuCkFubm90YXRlZCB0YWcgc2lnbmF0dXJlcyBhcmVuJ3QgY2hlY2tlZCwgbm9yIGFyZSB0aGV5IHJlcXVpcmVkLgoKVGhlIHNwZWNpYWwgc3VicmVwb3NpdG9yeSBvZiAnaW5mby9uZXctY29tbWl0LWNoZWNrJyBjYW4KYmUgY3JlYXRlZCBhbmQgdXNlZCB0byBhbGxvdyB1c2VycyB0byBwdXNoIG5ldyBjb21taXRzIGFuZAp0YWdzIGZyb20gYW5vdGhlciBsb2NhbCByZXBvc2l0b3J5IHRvIHRoaXMgb25lLCBldmVuIGlmIHRoZXkKYXJlbid0IHRoZSBjb21taXR0ZXIvdGFnZ2VyIG9mIHRob3NlIG9iamVjdHMuICBJbiBhIG51dCBzaGVsbAp0aGUgaW5mby9uZXctY29tbWl0LWNoZWNrIGRpcmVjdG9yeSBpcyBhIEdpdCByZXBvc2l0b3J5IHdob3NlCm9iamVjdHMvaW5mby9hbHRlcm5hdGVzIGZpbGUgbGlzdHMgdGhpcyByZXBvc2l0b3J5IGFuZCBhbGwgb3RoZXIKcG9zc2libGUgc291cmNlcywgYW5kIHdob3NlIHJlZnMgc3ViZGlyZWN0b3J5IGNvbnRhaW5zIHN5bWxpbmtzCnRvIHRoaXMgcmVwb3NpdG9yeSdzIHJlZnMgc3ViZGlyZWN0b3J5LCBhbmQgdG8gYWxsIG90aGVyIHBvc3NpYmxlCnNvdXJjZXMgcmVmcyBzdWJkaXJlY3Rvcmllcy4gIFllcywgdGhpcyBtZWFucyB0aGF0IHlvdSBjYW5ub3QKdXNlIHBhY2tlZC1yZWZzIGluIHRob3NlIHJlcG9zaXRvcmllcyBhcyB0aGV5IHdvbid0IGJlIHJlc29sdmVkCmNvcnJlY3RseS4KCj1jdXQKCm15ICRnaXRfZGlyID0gJEVOVntHSVRfRElSfTsKbXkgJG5ld19jb21taXRfY2hlY2sgPSAiJGdpdF9kaXIvaW5mby9uZXctY29tbWl0LWNoZWNrIjsKbXkgJHJlZiA9ICRBUkdWWzBdOwpteSAkb2xkID0gJEFSR1ZbMV07Cm15ICRuZXcgPSAkQVJHVlsyXTsKbXkgJG5ld190eXBlOwpteSAoJHRoaXNfdXNlcikgPSBnZXRwd3VpZCAkPDsgIyBSRUFMX1VTRVJfSUQKbXkgJHJlcG9zaXRvcnlfbmFtZTsKbXkgJXVzZXJfY29tbWl0dGVyOwpteSBAYWxsb3dfcnVsZXM7Cm15IEBwYXRoX3J1bGVzOwpteSAlZGlmZl9jYWNoZTsKCnN1YiBkZW55ICgkKSB7CglwcmludCBTVERFUlIgIi1EZW55LSAgICAkX1swXVxuIiBpZiAkZGVidWc7CglwcmludCBTVERFUlIgIlxuZGVuaWVkOiAkX1swXVxuXG4iOwoJZXhpdCAxOwp9CgpzdWIgZ3JhbnQgKCQpIHsKCXByaW50IFNUREVSUiAiLUdyYW50LSAgICRfWzBdXG4iIGlmICRkZWJ1ZzsKCWV4aXQgMDsKfQoKc3ViIGluZm8gKCQpIHsKCXByaW50IFNUREVSUiAiLUluZm8tICAgICRfWzBdXG4iIGlmICRkZWJ1ZzsKfQoKc3ViIGdpdF92YWx1ZSAoQCkgewoJb3BlbihULCctfCcsJ2dpdCcsQF8pOyBsb2NhbCAkXyA9IDxUPjsgY2hvcDsgY2xvc2UgVDsgJF87Cn0KCnN1YiBtYXRjaF9zdHJpbmcgKCQkKSB7CglteSAoJGFjbF9uLCAkcmVmKSA9IEBfOwoJICAgKCRhY2xfbiBlcSAkcmVmKQoJfHwgKCRhY2xfbiA9fiBtLC8kLCAmJiBzdWJzdHIoJHJlZiwwLGxlbmd0aCAkYWNsX24pIGVxICRhY2xfbikKCXx8ICgkYWNsX24gPX4gbSxeXF4sICYmICRyZWYgPX4gbTokYWNsX246KTsKfQoKc3ViIHBhcnNlX2NvbmZpZyAoJCQkJCkgewoJbXkgJGRhdGEgPSBzaGlmdDsKCWxvY2FsICRFTlZ7R0lUX0RJUn0gPSBzaGlmdDsKCW15ICRiciA9IHNoaWZ0OwoJbXkgJGZuID0gc2hpZnQ7CglyZXR1cm4gdW5sZXNzIGdpdF92YWx1ZSgncmV2LWxpc3QnLCctLW1heC1jb3VudD0xJywkYnIsJy0tJywkZm4pOwoJaW5mbyAiTG9hZGluZyAkYnI6JGZuIjsKCW9wZW4oSSwnLXwnLCdnaXQnLCdjYXQtZmlsZScsJ2Jsb2InLCIkYnI6JGZuIik7CglteSAkc2VjdGlvbiA9ICcnOwoJd2hpbGUgKDxJPikgewoJCWNob21wOwoJCWlmICgvXlxzKiQvIHx8IC9eXHMqIy8pIHsKCQl9IGVsc2lmICgvXlxbKFthLXpdKylcXSQvaSkgewoJCQkkc2VjdGlvbiA9IGxjICQxOwoJCX0gZWxzaWYgKC9eXFsoW2Etel0rKVxzKyIoLiopIlxdJC9pKSB7CgkJCSRzZWN0aW9uID0gam9pbignLicsbGMgJDEsJDIpOwoJCX0gZWxzaWYgKC9eXHMqKFthLXpdW2EtejAtOV0rKVxzKj1ccyooLio/KVxzKiQvaSkgewoJCQlwdXNoIEB7JGRhdGEtPntqb2luKCcuJywkc2VjdGlvbixsYyAkMSl9fSwgJDI7CgkJfSBlbHNlIHsKCQkJZGVueSAiYmFkIGNvbmZpZyBmaWxlIGxpbmUgJC4gaW4gJGJyOiRmbiI7CgkJfQoJfQoJY2xvc2UgSTsKfQoKc3ViIGFsbF9uZXdfY29tbWl0dGVycyAoKSB7Cglsb2NhbCAkRU5We0dJVF9ESVJ9ID0gJGdpdF9kaXI7CgkkRU5We0dJVF9ESVJ9ID0gJG5ld19jb21taXRfY2hlY2sgaWYgLWQgJG5ld19jb21taXRfY2hlY2s7CgoJaW5mbyAiR2V0dGluZyBjb21taXR0ZXJzIG9mIG5ldyBjb21taXRzLiI7CglteSAldXNlZDsKCW9wZW4oVCwnLXwnLCdnaXQnLCdyZXYtbGlzdCcsJy0tcHJldHR5PXJhdycsJG5ldywnLS1ub3QnLCctLWFsbCcpOwoJd2hpbGUgKDxUPikgewoJCW5leHQgdW5sZXNzIHMvXmNvbW1pdHRlciAvLzsKCQljaG9wOwoJCXMvPi4qJC8+LzsKCQlpbmZvICJGb3VuZCAkXy4iIHVubGVzcyAkdXNlZHskX30rKzsKCX0KCWNsb3NlIFQ7CglpbmZvICJObyBuZXcgY29tbWl0cy4iIHVubGVzcyAldXNlZDsKCWtleXMgJXVzZWQ7Cn0KCnN1YiBhbGxfbmV3X3RhZ2dlcnMgKCkgewoJbXkgJWV4aXN0czsKCW9wZW4oVCwnLXwnLCdnaXQnLCdmb3ItZWFjaC1yZWYnLCctLWZvcm1hdD0lKG9iamVjdG5hbWUpJywncmVmcy90YWdzJyk7Cgl3aGlsZSAoPFQ+KSB7CgkJY2hvcDsKCQkkZXhpc3RzeyRffSA9IDE7Cgl9CgljbG9zZSBUOwoKCWluZm8gIkdldHRpbmcgdGFnZ2VycyBvZiBuZXcgdGFncy4iOwoJbXkgJXVzZWQ7CglteSAkb2JqID0gJG5ldzsKCW15ICRvYmpfdHlwZSA9ICRuZXdfdHlwZTsKCXdoaWxlICgkb2JqX3R5cGUgZXEgJ3RhZycpIHsKCQlsYXN0IGlmICRleGlzdHN7JG9ian07CgkJJG9ial90eXBlID0gJyc7CgkJb3BlbihULCctfCcsJ2dpdCcsJ2NhdC1maWxlJywndGFnJywkb2JqKTsKCQl3aGlsZSAoPFQ+KSB7CgkJCWNob3A7CgkJCWlmICgvXm9iamVjdCAoW2EtejAtOV17NDB9KSQvKSB7CgkJCQkkb2JqID0gJDE7CgkJCX0gZWxzaWYgKC9edHlwZSAoLispJC8pIHsKCQkJCSRvYmpfdHlwZSA9ICQxOwoJCQl9IGVsc2lmIChzL150YWdnZXIgLy8pIHsKCQkJCXMvPi4qJC8+LzsKCQkJCWluZm8gIkZvdW5kICRfLiIgdW5sZXNzICR1c2VkeyRffSsrOwoJCQkJbGFzdDsKCQkJfQoJCX0KCQljbG9zZSBUOwoJfQoJaW5mbyAiTm8gbmV3IHRhZ3MuIiB1bmxlc3MgJXVzZWQ7CglrZXlzICV1c2VkOwp9CgpzdWIgY2hlY2tfY29tbWl0dGVycyAoQCkgewoJbXkgQGJhZDsKCWZvcmVhY2ggKEBfKSB7IHB1c2ggQGJhZCwgJF8gdW5sZXNzICR1c2VyX2NvbW1pdHRlcnskX307IH0KCWlmIChAYmFkKSB7CgkJcHJpbnQgU1RERVJSICJcbiI7CgkJcHJpbnQgU1RERVJSICJZb3UgYXJlIG5vdCAkXy5cbiIgZm9yZWFjaCAoc29ydCBAYmFkKTsKCQlkZW55ICJZb3UgY2Fubm90IHB1c2ggY2hhbmdlcyBub3QgY29tbWl0dGVkIGJ5IHlvdS4iOwoJfQp9CgpzdWIgbG9hZF9kaWZmICgkKSB7CglteSAkYmFzZSA9IHNoaWZ0OwoJbXkgJGQgPSAkZGlmZl9jYWNoZXskYmFzZX07Cgl1bmxlc3MgKCRkKSB7CgkJbG9jYWwgJC8gPSAiXDAiOwoJCW15ICV0aGlzX2RpZmY7CgkJaWYgKCRiYXNlID1+IC9eMHs0MH0kLykgewoJCQkjIERvbid0IGxvYWQgdGhlIGRpZmYgYXQgYWxsOyB3ZSBhcmUgbWFraW5nIHRoZQoJCQkjIGJyYW5jaCBhbmQgaGF2ZSBubyBiYXNlIHRvIGNvbXBhcmUgdG8gaW4gdGhpcwoJCQkjIGNhc2UuICBBIGZpbGUgbGV2ZWwgQUNMIG1ha2VzIG5vIHNlbnNlIGluIHRoaXMKCQkJIyBjb250ZXh0LiAgSGF2aW5nIGFuIGVtcHR5IGRpZmYgd2lsbCBhbGxvdyB0aGUKCQkJIyBicmFuY2ggY3JlYXRpb24uCgkJCSMKCQl9IGVsc2UgewoJCQlvcGVuKFQsJy18JywnZ2l0JywnZGlmZi10cmVlJywKCQkJCSctcicsJy0tbmFtZS1zdGF0dXMnLCcteicsCgkJCQkkYmFzZSwkbmV3KSBvciByZXR1cm4gdW5kZWY7CgkJCXdoaWxlICg8VD4pIHsKCQkJCW15ICRvcCA9ICRfOwoJCQkJY2hvcCAkb3A7CgoJCQkJbXkgJHBhdGggPSA8VD47CgkJCQljaG9wICRwYXRoOwoKCQkJCSR0aGlzX2RpZmZ7JHBhdGh9ID0gJG9wOwoJCQl9CgkJCWNsb3NlIFQgb3IgcmV0dXJuIHVuZGVmOwoJCX0KCQkkZCA9IFwldGhpc19kaWZmOwoJCSRkaWZmX2NhY2hleyRiYXNlfSA9ICRkOwoJfQoJcmV0dXJuICRkOwp9CgpkZW55ICJObyBHSVRfRElSIGluaGVyaXRlZCBmcm9tIGNhbGxlciIgdW5sZXNzICRnaXRfZGlyOwpkZW55ICJOZWVkIGEgcmVmIG5hbWUiIHVubGVzcyAkcmVmOwpkZW55ICJSZWZ1c2luZyBmdW5ueSByZWYgJHJlZiIgdW5sZXNzICRyZWYgPX4gcyxecmVmcy8sLDsKZGVueSAiQmFkIG9sZCB2YWx1ZSAkb2xkIiB1bmxlc3MgJG9sZCA9fiAvXlthLXowLTldezQwfSQvOwpkZW55ICJCYWQgbmV3IHZhbHVlICRuZXciIHVubGVzcyAkbmV3ID1+IC9eW2EtejAtOV17NDB9JC87CmRlbnkgIkNhbm5vdCBkZXRlcm1pbmUgd2hvIHlvdSBhcmUuIiB1bmxlc3MgJHRoaXNfdXNlcjsKZ3JhbnQgIk5vIGNoYW5nZSByZXF1ZXN0ZWQuIiBpZiAkb2xkIGVxICRuZXc7CgokcmVwb3NpdG9yeV9uYW1lID0gRmlsZTo6U3BlYy0+cmVsMmFicygkZ2l0X2Rpcik7CiRyZXBvc2l0b3J5X25hbWUgPX4gbSwvKFteL10rKSg/OlwuZ2l0fC9cLmdpdCkkLDsKJHJlcG9zaXRvcnlfbmFtZSA9ICQxOwppbmZvICJVcGRhdGluZyBpbiAnJHJlcG9zaXRvcnlfbmFtZScuIjsKCm15ICRvcDsKaWYgICAgKCRvbGQgPX4gL14wezQwfSQvKSB7ICRvcCA9ICdDJzsgfQplbHNpZiAoJG5ldyA9fiAvXjB7NDB9JC8pIHsgJG9wID0gJ0QnOyB9CmVsc2UgICAgICAgICAgICAgICAgICAgICAgeyAkb3AgPSAnUic7IH0KCiMgVGhpcyBpcyByZWFsbHkgYW4gdXBkYXRlIChmYXN0LWZvcndhcmQpIGlmIHRoZQojIG1lcmdlIGJhc2Ugb2YgJG9sZCBhbmQgJG5ldyBpcyAkb2xkLgojCiRvcCA9ICdVJyBpZiAoJG9wIGVxICdSJwoJJiYgJHJlZiA9fiBtLF5oZWFkcy8sCgkmJiAkb2xkIGVxIGdpdF92YWx1ZSgnbWVyZ2UtYmFzZScsJG9sZCwkbmV3KSk7CgojIExvYWQgdGhlIHVzZXIncyBBQ0wgZmlsZS4gRXhwYW5kIGdyb3VwcyAodXNlci5tZW1iZXJvZikgb25lIGxldmVsLgp7CglteSAlZGF0YSA9ICgndXNlci5jb21taXR0ZXInID0+IFtdKTsKCXBhcnNlX2NvbmZpZyhcJWRhdGEsJGFjbF9naXQsJGFjbF9icmFuY2gsImV4dGVybmFsLyRyZXBvc2l0b3J5X25hbWUuYWNsIik7CgoJJWRhdGEgPSAoCgkJJ3VzZXIuY29tbWl0dGVyJyA9PiAkZGF0YXsndXNlci5jb21taXR0ZXInfSwKCQkndXNlci5tZW1iZXJvZicgPT4gW10sCgkpOwoJcGFyc2VfY29uZmlnKFwlZGF0YSwkYWNsX2dpdCwkYWNsX2JyYW5jaCwidXNlcnMvJHRoaXNfdXNlci5hY2wiKTsKCgkldXNlcl9jb21taXR0ZXIgPSBtYXAgeyRfID0+ICRffSBAeyRkYXRheyd1c2VyLmNvbW1pdHRlcid9fTsKCW15ICRydWxlX2tleSA9ICJyZXBvc2l0b3J5LiRyZXBvc2l0b3J5X25hbWUuYWxsb3ciOwoJbXkgJHJ1bGVzID0gJGRhdGF7JHJ1bGVfa2V5fSB8fCBbXTsKCglmb3JlYWNoIG15ICRncm91cCAoQHskZGF0YXsndXNlci5tZW1iZXJvZid9fSkgewoJCW15ICVnOwoJCXBhcnNlX2NvbmZpZyhcJWcsJGFjbF9naXQsJGFjbF9icmFuY2gsImdyb3Vwcy8kZ3JvdXAuYWNsIik7CgkJbXkgJGdyb3VwX3J1bGVzID0gJGd7JHJ1bGVfa2V5fTsKCQlwdXNoIEAkcnVsZXMsIEAkZ3JvdXBfcnVsZXMgaWYgJGdyb3VwX3J1bGVzOwoJfQoKUlVMRToKCWZvcmVhY2ggKEAkcnVsZXMpIHsKCQl3aGlsZSAoL1wke3VzZXJcLihbYS16XVthLXpBLVowLTldKyl9LykgewoJCQlteSAkayA9IGxjICQxOwoJCQlteSAkdiA9ICRkYXRheyJ1c2VyLiRrIn07CgkJCW5leHQgUlVMRSB1bmxlc3MgZGVmaW5lZCAkdjsKCQkJbmV4dCBSVUxFIGlmIEAkdiAhPSAxOwoJCQluZXh0IFJVTEUgdW5sZXNzIGRlZmluZWQgJHYtPlswXTsKCQkJcy9cJHt1c2VyXC4ka30vJHYtPlswXS9nOwoJCX0KCgkJaWYgKC9eKFtBTUQgXSspXHMrb2ZccysoW15cc10rKVxzK2ZvclxzKyhbXlxzXSspXHMrZGlmZlxzKyhbXlxzXSspJC8pIHsKCQkJbXkgKCRvcHMsICRwdGgsICRyZWYsICRic3QpID0gKCQxLCAkMiwgJDMsICQ0KTsKCQkJJG9wcyA9fiBzLyAvL2c7CgkJCSRwdGggPX4gcy9cXFxcL1xcL2c7CgkJCSRyZWYgPX4gcy9cXFxcL1xcL2c7CgkJCXB1c2ggQHBhdGhfcnVsZXMsIFskb3BzLCAkcHRoLCAkcmVmLCAkYnN0XTsKCQl9IGVsc2lmICgvXihbQU1EIF0rKVxzK29mXHMrKFteXHNdKylccytmb3JccysoW15cc10rKSQvKSB7CgkJCW15ICgkb3BzLCAkcHRoLCAkcmVmKSA9ICgkMSwgJDIsICQzKTsKCQkJJG9wcyA9fiBzLyAvL2c7CgkJCSRwdGggPX4gcy9cXFxcL1xcL2c7CgkJCSRyZWYgPX4gcy9cXFxcL1xcL2c7CgkJCXB1c2ggQHBhdGhfcnVsZXMsIFskb3BzLCAkcHRoLCAkcmVmLCAkb2xkXTsKCQl9IGVsc2lmICgvXihbQ0RSVSBdKylccytmb3JccysoW15cc10rKSQvKSB7CgkJCW15ICRvcHMgPSAkMTsKCQkJbXkgJHJlZiA9ICQyOwoJCQkkb3BzID1+IHMvIC8vZzsKCQkJJHJlZiA9fiBzL1xcXFwvXFwvZzsKCQkJcHVzaCBAYWxsb3dfcnVsZXMsIFskb3BzLCAkcmVmXTsKCQl9IGVsc2lmICgvXmZvclxzKyhbXlxzXSspJC8pIHsKCQkJIyBNZW50aW9uZWQsIGJ1dCBub3RoaW5nIGdyYW50ZWQ/CgkJfSBlbHNpZiAoL15bXlxzXSskLykgewoJCQlzL1xcXFwvXFwvZzsKCQkJcHVzaCBAYWxsb3dfcnVsZXMsIFsnVScsICRfXTsKCQl9Cgl9Cn0KCmlmICgkb3AgbmUgJ0QnKSB7CgkkbmV3X3R5cGUgPSBnaXRfdmFsdWUoJ2NhdC1maWxlJywnLXQnLCRuZXcpOwoKCWlmICgkcmVmID1+IG0sXmhlYWRzLywpIHsKCQlkZW55ICIkcmVmIG11c3QgYmUgYSBjb21taXQuIiB1bmxlc3MgJG5ld190eXBlIGVxICdjb21taXQnOwoJfSBlbHNpZiAoJHJlZiA9fiBtLF50YWdzLywpIHsKCQlkZW55ICIkcmVmIG11c3QgYmUgYW4gYW5ub3RhdGVkIHRhZy4iIHVubGVzcyAkbmV3X3R5cGUgZXEgJ3RhZyc7Cgl9CgoJY2hlY2tfY29tbWl0dGVycyAoYWxsX25ld19jb21taXR0ZXJzKTsKCWNoZWNrX2NvbW1pdHRlcnMgKGFsbF9uZXdfdGFnZ2VycykgaWYgJG5ld190eXBlIGVxICd0YWcnOwp9CgppbmZvICIkdGhpc191c2VyIHdhbnRzICRvcCBmb3IgJHJlZiI7CmZvcmVhY2ggbXkgJGFjbF9lbnRyeSAoQGFsbG93X3J1bGVzKSB7CglteSAoJGFjbF9vcHMsICRhY2xfbikgPSBAJGFjbF9lbnRyeTsKCW5leHQgdW5sZXNzICRhY2xfb3BzID1+IC9eW0NEUlVdKyQvOyAjIFVoaC4uLi4gc2hvdWxkbid0IGhhcHBlbi4KCW5leHQgdW5sZXNzICRhY2xfbjsKCW5leHQgdW5sZXNzICRvcCA9fiAvXlskYWNsX29wc10kLzsKCW5leHQgdW5sZXNzIG1hdGNoX3N0cmluZyAkYWNsX24sICRyZWY7CgoJIyBEb24ndCB0ZXN0IHBhdGggcnVsZXMgb24gYnJhbmNoIGRlbGV0ZXMuCgkjCglncmFudCAiQWxsb3dlZCBieTogJGFjbF9vcHMgZm9yICRhY2xfbiIgaWYgJG9wIGVxICdEJzsKCgkjIEFnZ3JlZ2F0ZSBtYXRjaGluZyBwYXRoIHJ1bGVzOyBhbGxvdyBpZiB0aGVyZSBhcmVuJ3QKCSMgYW55IG1hdGNoaW5nIHRoaXMgcmVmLgoJIwoJbXkgJXByOwoJZm9yZWFjaCBteSAkcF9lbnRyeSAoQHBhdGhfcnVsZXMpIHsKCQlteSAoJHBfb3BzLCAkcF9uLCAkcF9yZWYsICRwX2JzdCkgPSBAJHBfZW50cnk7CgkJbmV4dCB1bmxlc3MgJHBfcmVmOwoJCXB1c2ggQHskcHJ7JHBfYnN0fX0sICRwX2VudHJ5IGlmIG1hdGNoX3N0cmluZyAkcF9yZWYsICRyZWY7Cgl9CglncmFudCAiQWxsb3dlZCBieTogJGFjbF9vcHMgZm9yICRhY2xfbiIgdW5sZXNzICVwcjsKCgkjIEFsbG93IG9ubHkgaWYgYWxsIGNoYW5nZXMgYWdhaW5zdCBhIHNpbmdsZSBiYXNlIGFyZQoJIyBhbGxvd2VkIGJ5IGZpbGUgcGF0aCBydWxlcy4KCSMKCW15IEBiYWQ7Cglmb3JlYWNoIG15ICRwX2JzdCAoa2V5cyAlcHIpIHsKCQlteSAkZGlmZl9yZWYgPSBsb2FkX2RpZmYgJHBfYnN0OwoJCWRlbnkgIkNhbm5vdCBkaWZmZXJlbmNlIHRyZWVzLiIgdW5sZXNzIHJlZiAkZGlmZl9yZWY7CgoJCW15ICVmZCA9ICUkZGlmZl9yZWY7CgkJZm9yZWFjaCBteSAkcF9lbnRyeSAoQHskcHJ7JHBfYnN0fX0pIHsKCQkJbXkgKCRwX29wcywgJHBfbiwgJHBfcmVmLCAkcF9ic3QpID0gQCRwX2VudHJ5OwoJCQluZXh0IHVubGVzcyAkcF9vcHMgPX4gL15bQU1EXSskLzsKCQkJbmV4dCB1bmxlc3MgJHBfbjsKCgkJCWZvcmVhY2ggbXkgJGZfbiAoa2V5cyAlZmQpIHsKCQkJCW15ICRmX29wID0gJGZkeyRmX259OwoJCQkJbmV4dCB1bmxlc3MgJGZfb3A7CgkJCQluZXh0IHVubGVzcyAkZl9vcCA9fiAvXlskcF9vcHNdJC87CgkJCQlkZWxldGUgJGZkeyRmX259IGlmIG1hdGNoX3N0cmluZyAkcF9uLCAkZl9uOwoJCQl9CgkJCWxhc3QgdW5sZXNzICVmZDsKCQl9CgoJCWlmICglZmQpIHsKCQkJcHVzaCBAYmFkLCBbJHBfYnN0LCBcJWZkXTsKCQl9IGVsc2UgewoJCQkjIEFsbCBjaGFuZ2VzIHJlbGF0aXZlIHRvICRwX2JzdCB3ZXJlIGFsbG93ZWQuCgkJCSMKCQkJZ3JhbnQgIkFsbG93ZWQgYnk6ICRhY2xfb3BzIGZvciAkYWNsX24gZGlmZiAkcF9ic3QiOwoJCX0KCX0KCglmb3JlYWNoIG15ICRiYWRfcmVmIChAYmFkKSB7CgkJbXkgKCRwX2JzdCwgJGZkKSA9IEAkYmFkX3JlZjsKCQlwcmludCBTVERFUlIgIlxuIjsKCQlwcmludCBTVERFUlIgIk5vdCBhbGxvd2VkIHRvIG1ha2UgdGhlIGZvbGxvd2luZyBjaGFuZ2VzOlxuIjsKCQlwcmludCBTVERFUlIgIihiYXNlOiAkcF9ic3QpXG4iOwoJCWZvcmVhY2ggbXkgJGZfbiAoc29ydCBrZXlzICUkZmQpIHsKCQkJcHJpbnQgU1RERVJSICIgICRmZC0+eyRmX259ICRmX25cbiI7CgkJfQoJfQoJZGVueSAiWW91IGFyZSBub3QgcGVybWl0dGVkIHRvICRvcCAkcmVmIjsKfQpjbG9zZSBBOwpkZW55ICJZb3UgYXJlIG5vdCBwZXJtaXR0ZWQgdG8gJG9wICRyZWYiOwo=",
    "text": "#!/usr/bin/perl\n\nuse strict;\nuse File::Spec;\n\n$ENV{PATH}     = '/opt/git/bin';\nmy $acl_git    = '/vcs/acls.git';\nmy $acl_branch = 'refs/heads/master';\nmy $debug      = 0;\n\n=doc\nInvoked as: update refname old-sha1 new-sha1\n\nThis script is run by git-receive-pack once for each ref that the\nclient is trying to modify.  If we exit with a non-zero exit value\nthen the update for that particular ref is denied, but updates for\nother refs in the same run of receive-pack may still be allowed.\n\nWe are run after the objects have been uploaded, but before the\nref is actually modified.  We take advantage of that fact when we\nlook for \"new\" commits and tags (the new objects won't show up in\n`rev-list --all`).\n\nThis script loads and parses the content of the config file\n\"users/$this_user.acl\" from the $acl_branch commit of $acl_git ODB.\nThe acl file is a git-config style file, but uses a slightly more\nrestricted syntax as the Perl parser contained within this script\nis not nearly as permissive as git-config.\n\nExample:\n\n  [user]\n    committer = John Doe <john.doe@example.com>\n    committer = John R. Doe <john.doe@example.com>\n\n  [repository \"acls\"]\n    allow = heads/master\n    allow = CDUR for heads/jd/\n    allow = C    for ^tags/v\\\\d+$\n\nFor all new commit or tag objects the committer (or tagger) line\nwithin the object must exactly match one of the user.committer\nvalues listed in the acl file (\"HEAD:users/$this_user.acl\").\n\nFor a branch to be modified an allow line within the matching\nrepository section must be matched for both the refname and the\nopcode.\n\nRepository sections are matched on the basename of the repository\n(after removing the .git suffix).\n\nThe opcode abbreviations are:\n\n  C: create new ref\n  D: delete existing ref\n  U: fast-forward existing ref (no commit loss)\n  R: rewind/rebase existing ref (commit loss)\n\nif no opcodes are listed before the \"for\" keyword then \"U\" (for\nfast-forward update only) is assumed as this is the most common\nusage.\n\nRefnames are matched by always assuming a prefix of \"refs/\".\nThis hook forbids pushing or deleting anything not under \"refs/\".\n\nRefnames that start with ^ are Perl regular expressions, and the ^\nis kept as part of the regexp.  \\\\ is needed to get just one \\, so\n\\\\d expands to \\d in Perl.  The 3rd allow line above is an example.\n\nRefnames that don't start with ^ but that end with / are prefix\nmatches (2nd allow line above); all other refnames are strict\nequality matches (1st allow line).\n\nAnything pushed to \"heads/\" (ok, really \"refs/heads/\") must be\na commit.  Tags are not permitted here.\n\nAnything pushed to \"tags/\" (err, really \"refs/tags/\") must be an\nannotated tag.  Commits, blobs, trees, etc. are not permitted here.\nAnnotated tag signatures aren't checked, nor are they required.\n\nThe special subrepository of 'info/new-commit-check' can\nbe created and used to allow users to push new commits and\ntags from another local repository to this one, even if they\naren't the committer/tagger of those objects.  In a nut shell\nthe info/new-commit-check directory is a Git repository whose\nobjects/info/alternates file lists this repository and all other\npossible sources, and whose refs subdirectory contains symlinks\nto this repository's refs subdirectory, and to all other possible\nsources refs subdirectories.  Yes, this means that you cannot\nuse packed-refs in those repositories as they won't be resolved\ncorrectly.\n\n=cut\n\nmy $git_dir = $ENV{GIT_DIR};\nmy $new_commit_check = \"$git_dir/info/new-commit-check\";\nmy $ref = $ARGV[0];\nmy $old = $ARGV[1];\nmy $new = $ARGV[2];\nmy $new_type;\nmy ($this_user) = getpwuid $<; # REAL_USER_ID\nmy $repository_name;\nmy %user_committer;\nmy @allow_rules;\nmy @path_rules;\nmy %diff_cache;\n\nsub deny ($) {\n\tprint STDERR \"-Deny-    $_[0]\\n\" if $debug;\n\tprint STDERR \"\\ndenied: $_[0]\\n\\n\";\n\texit 1;\n}\n\nsub grant ($) {\n\tprint STDERR \"-Grant-   $_[0]\\n\" if $debug;\n\texit 0;\n}\n\nsub info ($) {\n\tprint STDERR \"-Info-    $_[0]\\n\" if $debug;\n}\n\nsub git_value (@) {\n\topen(T,'-|','git',@_); local $_ = <T>; chop; close T; $_;\n}\n\nsub match_string ($$) {\n\tmy ($acl_n, $ref) = @_;\n\t   ($acl_n eq $ref)\n\t|| ($acl_n =~ m,/$, && substr($ref,0,length $acl_n) eq $acl_n)\n\t|| ($acl_n =~ m,^\\^, && $ref =~ m:$acl_n:);\n}\n\nsub parse_config ($$$$) {\n\tmy $data = shift;\n\tlocal $ENV{GIT_DIR} = shift;\n\tmy $br = shift;\n\tmy $fn = shift;\n\treturn unless git_value('rev-list','--max-count=1',$br,'--',$fn);\n\tinfo \"Loading $br:$fn\";\n\topen(I,'-|','git','cat-file','blob',\"$br:$fn\");\n\tmy $section = '';\n\twhile (<I>) {\n\t\tchomp;\n\t\tif (/^\\s*$/ || /^\\s*#/) {\n\t\t} elsif (/^\\[([a-z]+)\\]$/i) {\n\t\t\t$section = lc $1;\n\t\t} elsif (/^\\[([a-z]+)\\s+\"(.*)\"\\]$/i) {\n\t\t\t$section = join('.',lc $1,$2);\n\t\t} elsif (/^\\s*([a-z][a-z0-9]+)\\s*=\\s*(.*?)\\s*$/i) {\n\t\t\tpush @{$data->{join('.',$section,lc $1)}}, $2;\n\t\t} else {\n\t\t\tdeny \"bad config file line $. in $br:$fn\";\n\t\t}\n\t}\n\tclose I;\n}\n\nsub all_new_committers () {\n\tlocal $ENV{GIT_DIR} = $git_dir;\n\t$ENV{GIT_DIR} = $new_commit_check if -d $new_commit_check;\n\n\tinfo \"Getting committers of new commits.\";\n\tmy %used;\n\topen(T,'-|','git','rev-list','--pretty=raw',$new,'--not','--all');\n\twhile (<T>) {\n\t\tnext unless s/^committer //;\n\t\tchop;\n\t\ts/>.*$/>/;\n\t\tinfo \"Found $_.\" unless $used{$_}++;\n\t}\n\tclose T;\n\tinfo \"No new commits.\" unless %used;\n\tkeys %used;\n}\n\nsub all_new_taggers () {\n\tmy %exists;\n\topen(T,'-|','git','for-each-ref','--format=%(objectname)','refs/tags');\n\twhile (<T>) {\n\t\tchop;\n\t\t$exists{$_} = 1;\n\t}\n\tclose T;\n\n\tinfo \"Getting taggers of new tags.\";\n\tmy %used;\n\tmy $obj = $new;\n\tmy $obj_type = $new_type;\n\twhile ($obj_type eq 'tag') {\n\t\tlast if $exists{$obj};\n\t\t$obj_type = '';\n\t\topen(T,'-|','git','cat-file','tag',$obj);\n\t\twhile (<T>) {\n\t\t\tchop;\n\t\t\tif (/^object ([a-z0-9]{40})$/) {\n\t\t\t\t$obj = $1;\n\t\t\t} elsif (/^type (.+)$/) {\n\t\t\t\t$obj_type = $1;\n\t\t\t} elsif (s/^tagger //) {\n\t\t\t\ts/>.*$/>/;\n\t\t\t\tinfo \"Found $_.\" unless $used{$_}++;\n\t\t\t\tlast;\n\t\t\t}\n\t\t}\n\t\tclose T;\n\t}\n\tinfo \"No new tags.\" unless %used;\n\tkeys %used;\n}\n\nsub check_committers (@) {\n\tmy @bad;\n\tforeach (@_) { push @bad, $_ unless $user_committer{$_}; }\n\tif (@bad) {\n\t\tprint STDERR \"\\n\";\n\t\tprint STDERR \"You are not $_.\\n\" foreach (sort @bad);\n\t\tdeny \"You cannot push changes not committed by you.\";\n\t}\n}\n\nsub load_diff ($) {\n\tmy $base = shift;\n\tmy $d = $diff_cache{$base};\n\tunless ($d) {\n\t\tlocal $/ = \"\\0\";\n\t\tmy %this_diff;\n\t\tif ($base =~ /^0{40}$/) {\n\t\t\t# Don't load the diff at all; we are making the\n\t\t\t# branch and have no base to compare to in this\n\t\t\t# case.  A file level ACL makes no sense in this\n\t\t\t# context.  Having an empty diff will allow the\n\t\t\t# branch creation.\n\t\t\t#\n\t\t} else {\n\t\t\topen(T,'-|','git','diff-tree',\n\t\t\t\t'-r','--name-status','-z',\n\t\t\t\t$base,$new) or return undef;\n\t\t\twhile (<T>) {\n\t\t\t\tmy $op = $_;\n\t\t\t\tchop $op;\n\n\t\t\t\tmy $path = <T>;\n\t\t\t\tchop $path;\n\n\t\t\t\t$this_diff{$path} = $op;\n\t\t\t}\n\t\t\tclose T or return undef;\n\t\t}\n\t\t$d = \\%this_diff;\n\t\t$diff_cache{$base} = $d;\n\t}\n\treturn $d;\n}\n\ndeny \"No GIT_DIR inherited from caller\" unless $git_dir;\ndeny \"Need a ref name\" unless $ref;\ndeny \"Refusing funny ref $ref\" unless $ref =~ s,^refs/,,;\ndeny \"Bad old value $old\" unless $old =~ /^[a-z0-9]{40}$/;\ndeny \"Bad new value $new\" unless $new =~ /^[a-z0-9]{40}$/;\ndeny \"Cannot determine who you are.\" unless $this_user;\ngrant \"No change requested.\" if $old eq $new;\n\n$repository_name = File::Spec->rel2abs($git_dir);\n$repository_name =~ m,/([^/]+)(?:\\.git|/\\.git)$,;\n$repository_name = $1;\ninfo \"Updating in '$repository_name'.\";\n\nmy $op;\nif    ($old =~ /^0{40}$/) { $op = 'C'; }\nelsif ($new =~ /^0{40}$/) { $op = 'D'; }\nelse                      { $op = 'R'; }\n\n# This is really an update (fast-forward) if the\n# merge base of $old and $new is $old.\n#\n$op = 'U' if ($op eq 'R'\n\t&& $ref =~ m,^heads/,\n\t&& $old eq git_value('merge-base',$old,$new));\n\n# Load the user's ACL file. Expand groups (user.memberof) one level.\n{\n\tmy %data = ('user.committer' => []);\n\tparse_config(\\%data,$acl_git,$acl_branch,\"external/$repository_name.acl\");\n\n\t%data = (\n\t\t'user.committer' => $data{'user.committer'},\n\t\t'user.memberof' => [],\n\t);\n\tparse_config(\\%data,$acl_git,$acl_branch,\"users/$this_user.acl\");\n\n\t%user_committer = map {$_ => $_} @{$data{'user.committer'}};\n\tmy $rule_key = \"repository.$repository_name.allow\";\n\tmy $rules = $data{$rule_key} || [];\n\n\tforeach my $group (@{$data{'user.memberof'}}) {\n\t\tmy %g;\n\t\tparse_config(\\%g,$acl_git,$acl_branch,\"groups/$group.acl\");\n\t\tmy $group_rules = $g{$rule_key};\n\t\tpush @$rules, @$group_rules if $group_rules;\n\t}\n\nRULE:\n\tforeach (@$rules) {\n\t\twhile (/\\${user\\.([a-z][a-zA-Z0-9]+)}/) {\n\t\t\tmy $k = lc $1;\n\t\t\tmy $v = $data{\"user.$k\"};\n\t\t\tnext RULE unless defined $v;\n\t\t\tnext RULE if @$v != 1;\n\t\t\tnext RULE unless defined $v->[0];\n\t\t\ts/\\${user\\.$k}/$v->[0]/g;\n\t\t}\n\n\t\tif (/^([AMD ]+)\\s+of\\s+([^\\s]+)\\s+for\\s+([^\\s]+)\\s+diff\\s+([^\\s]+)$/) {\n\t\t\tmy ($ops, $pth, $ref, $bst) = ($1, $2, $3, $4);\n\t\t\t$ops =~ s/ //g;\n\t\t\t$pth =~ s/\\\\\\\\/\\\\/g;\n\t\t\t$ref =~ s/\\\\\\\\/\\\\/g;\n\t\t\tpush @path_rules, [$ops, $pth, $ref, $bst];\n\t\t} elsif (/^([AMD ]+)\\s+of\\s+([^\\s]+)\\s+for\\s+([^\\s]+)$/) {\n\t\t\tmy ($ops, $pth, $ref) = ($1, $2, $3);\n\t\t\t$ops =~ s/ //g;\n\t\t\t$pth =~ s/\\\\\\\\/\\\\/g;\n\t\t\t$ref =~ s/\\\\\\\\/\\\\/g;\n\t\t\tpush @path_rules, [$ops, $pth, $ref, $old];\n\t\t} elsif (/^([CDRU ]+)\\s+for\\s+([^\\s]+)$/) {\n\t\t\tmy $ops = $1;\n\t\t\tmy $ref = $2;\n\t\t\t$ops =~ s/ //g;\n\t\t\t$ref =~ s/\\\\\\\\/\\\\/g;\n\t\t\tpush @allow_rules, [$ops, $ref];\n\t\t} elsif (/^for\\s+([^\\s]+)$/) {\n\t\t\t# Mentioned, but nothing granted?\n\t\t} elsif (/^[^\\s]+$/) {\n\t\t\ts/\\\\\\\\/\\\\/g;\n\t\t\tpush @allow_rules, ['U', $_];\n\t\t}\n\t}\n}\n\nif ($op ne 'D') {\n\t$new_type = git_value('cat-file','-t',$new);\n\n\tif ($ref =~ m,^heads/,) {\n\t\tdeny \"$ref must be a commit.\" unless $new_type eq 'commit';\n\t} elsif ($ref =~ m,^tags/,) {\n\t\tdeny \"$ref must be an annotated tag.\" unless $new_type eq 'tag';\n\t}\n\n\tcheck_committers (all_new_committers);\n\tcheck_committers (all_new_taggers) if $new_type eq 'tag';\n}\n\ninfo \"$this_user wants $op for $ref\";\nforeach my $acl_entry (@allow_rules) {\n\tmy ($acl_ops, $acl_n) = @$acl_entry;\n\tnext unless $acl_ops =~ /^[CDRU]+$/; # Uhh.... shouldn't happen.\n\tnext unless $acl_n;\n\tnext unless $op =~ /^[$acl_ops]$/;\n\tnext unless match_string $acl_n, $ref;\n\n\t# Don't test path rules on branch deletes.\n\t#\n\tgrant \"Allowed by: $acl_ops for $acl_n\" if $op eq 'D';\n\n\t# Aggregate matching path rules; allow if there aren't\n\t# any matching this ref.\n\t#\n\tmy %pr;\n\tforeach my $p_entry (@path_rules) {\n\t\tmy ($p_ops, $p_n, $p_ref, $p_bst) = @$p_entry;\n\t\tnext unless $p_ref;\n\t\tpush @{$pr{$p_bst}}, $p_entry if match_string $p_ref, $ref;\n\t}\n\tgrant \"Allowed by: $acl_ops for $acl_n\" unless %pr;\n\n\t# Allow only if all changes against a single base are\n\t# allowed by file path rules.\n\t#\n\tmy @bad;\n\tforeach my $p_bst (keys %pr) {\n\t\tmy $diff_ref = load_diff $p_bst;\n\t\tdeny \"Cannot difference trees.\" unless ref $diff_ref;\n\n\t\tmy %fd = %$diff_ref;\n\t\tforeach my $p_entry (@{$pr{$p_bst}}) {\n\t\t\tmy ($p_ops, $p_n, $p_ref, $p_bst) = @$p_entry;\n\t\t\tnext unless $p_ops =~ /^[AMD]+$/;\n\t\t\tnext unless $p_n;\n\n\t\t\tforeach my $f_n (keys %fd) {\n\t\t\t\tmy $f_op = $fd{$f_n};\n\t\t\t\tnext unless $f_op;\n\t\t\t\tnext unless $f_op =~ /^[$p_ops]$/;\n\t\t\t\tdelete $fd{$f_n} if match_string $p_n, $f_n;\n\t\t\t}\n\t\t\tlast unless %fd;\n\t\t}\n\n\t\tif (%fd) {\n\t\t\tpush @bad, [$p_bst, \\%fd];\n\t\t} else {\n\t\t\t# All changes relative to $p_bst were allowed.\n\t\t\t#\n\t\t\tgrant \"Allowed by: $acl_ops for $acl_n diff $p_bst\";\n\t\t}\n\t}\n\n\tforeach my $bad_ref (@bad) {\n\t\tmy ($p_bst, $fd) = @$bad_ref;\n\t\tprint STDERR \"\\n\";\n\t\tprint STDERR \"Not allowed to make the following changes:\\n\";\n\t\tprint STDERR \"(base: $p_bst)\\n\";\n\t\tforeach my $f_n (sort keys %$fd) {\n\t\t\tprint STDERR \"  $fd->{$f_n} $f_n\\n\";\n\t\t}\n\t}\n\tdeny \"You are not permitted to $op $ref\";\n}\nclose A;\ndeny \"You are not permitted to $op $ref\";\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0092d67b8a474367239f8f196a517c288de47dab",
  "sha1_ok": true,
  "size": 11648
}
