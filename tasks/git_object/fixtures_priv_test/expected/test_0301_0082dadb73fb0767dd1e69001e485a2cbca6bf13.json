{
  "content": {
    "base64": "LyoKICogImdpdCBwdXNoIgogKi8KI2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJyZWZzLmgiCiNpbmNsdWRlICJydW4tY29tbWFuZC5oIgojaW5jbHVkZSAiYnVpbHRpbi5oIgojaW5jbHVkZSAicmVtb3RlLmgiCiNpbmNsdWRlICJ0cmFuc3BvcnQuaCIKI2luY2x1ZGUgInBhcnNlLW9wdGlvbnMuaCIKCnN0YXRpYyBjb25zdCBjaGFyICogY29uc3QgcHVzaF91c2FnZVtdID0gewoJImdpdCBwdXNoIFs8b3B0aW9ucz5dIFs8cmVwb3NpdG9yeT4gPHJlZnNwZWM+Li4uXSIsCglOVUxMLAp9OwoKc3RhdGljIGludCB0aGluOwpzdGF0aWMgaW50IGRlbGV0ZXJlZnM7CnN0YXRpYyBjb25zdCBjaGFyICpyZWNlaXZlcGFjazsKc3RhdGljIGludCB2ZXJib3NpdHk7CgpzdGF0aWMgY29uc3QgY2hhciAqKnJlZnNwZWM7CnN0YXRpYyBpbnQgcmVmc3BlY19ucjsKCnN0YXRpYyB2b2lkIGFkZF9yZWZzcGVjKGNvbnN0IGNoYXIgKnJlZikKewoJaW50IG5yID0gcmVmc3BlY19uciArIDE7CglyZWZzcGVjID0geHJlYWxsb2MocmVmc3BlYywgbnIgKiBzaXplb2YoY2hhciAqKSk7CglyZWZzcGVjW25yLTFdID0gcmVmOwoJcmVmc3BlY19uciA9IG5yOwp9CgpzdGF0aWMgdm9pZCBzZXRfcmVmc3BlY3MoY29uc3QgY2hhciAqKnJlZnMsIGludCBucikKewoJaW50IGk7Cglmb3IgKGkgPSAwOyBpIDwgbnI7IGkrKykgewoJCWNvbnN0IGNoYXIgKnJlZiA9IHJlZnNbaV07CgkJaWYgKCFzdHJjbXAoInRhZyIsIHJlZikpIHsKCQkJY2hhciAqdGFnOwoJCQlpbnQgbGVuOwoJCQlpZiAobnIgPD0gKytpKQoJCQkJZGllKCJ0YWcgc2hvcnRoYW5kIHdpdGhvdXQgPHRhZz4iKTsKCQkJbGVuID0gc3RybGVuKHJlZnNbaV0pICsgMTE7CgkJCWlmIChkZWxldGVyZWZzKSB7CgkJCQl0YWcgPSB4bWFsbG9jKGxlbisxKTsKCQkJCXN0cmNweSh0YWcsICI6cmVmcy90YWdzLyIpOwoJCQl9IGVsc2UgewoJCQkJdGFnID0geG1hbGxvYyhsZW4pOwoJCQkJc3RyY3B5KHRhZywgInJlZnMvdGFncy8iKTsKCQkJfQoJCQlzdHJjYXQodGFnLCByZWZzW2ldKTsKCQkJcmVmID0gdGFnOwoJCX0gZWxzZSBpZiAoZGVsZXRlcmVmcyAmJiAhc3RyY2hyKHJlZiwgJzonKSkgewoJCQljaGFyICpkZWxyZWY7CgkJCWludCBsZW4gPSBzdHJsZW4ocmVmKSsxOwoJCQlkZWxyZWYgPSB4bWFsbG9jKGxlbisxKTsKCQkJc3RyY3B5KGRlbHJlZiwgIjoiKTsKCQkJc3RyY2F0KGRlbHJlZiwgcmVmKTsKCQkJcmVmID0gZGVscmVmOwoJCX0gZWxzZSBpZiAoZGVsZXRlcmVmcykKCQkJZGllKCItLWRlbGV0ZSBvbmx5IGFjY2VwdHMgcGxhaW4gdGFyZ2V0IHJlZiBuYW1lcyIpOwoJCWFkZF9yZWZzcGVjKHJlZik7Cgl9Cn0KCnN0YXRpYyB2b2lkIHNldHVwX3B1c2hfdHJhY2tpbmcodm9pZCkKewoJc3RydWN0IHN0cmJ1ZiByZWZzcGVjID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3QgYnJhbmNoICpicmFuY2ggPSBicmFuY2hfZ2V0KE5VTEwpOwoJaWYgKCFicmFuY2gpCgkJZGllKCJZb3UgYXJlIG5vdCBjdXJyZW50bHkgb24gYSBicmFuY2guIik7CglpZiAoIWJyYW5jaC0+bWVyZ2VfbnIpCgkJZGllKCJUaGUgY3VycmVudCBicmFuY2ggJXMgaXMgbm90IHRyYWNraW5nIGFueXRoaW5nLiIsCgkJICAgIGJyYW5jaC0+bmFtZSk7CglpZiAoYnJhbmNoLT5tZXJnZV9uciAhPSAxKQoJCWRpZSgiVGhlIGN1cnJlbnQgYnJhbmNoICVzIGlzIHRyYWNraW5nIG11bHRpcGxlIGJyYW5jaGVzLCAiCgkJICAgICJyZWZ1c2luZyB0byBwdXNoLiIsIGJyYW5jaC0+bmFtZSk7CglzdHJidWZfYWRkZigmcmVmc3BlYywgIiVzOiVzIiwgYnJhbmNoLT5uYW1lLCBicmFuY2gtPm1lcmdlWzBdLT5zcmMpOwoJYWRkX3JlZnNwZWMocmVmc3BlYy5idWYpOwp9CgpzdGF0aWMgdm9pZCBzZXR1cF9kZWZhdWx0X3B1c2hfcmVmc3BlY3Modm9pZCkKewoJc3dpdGNoIChwdXNoX2RlZmF1bHQpIHsKCWRlZmF1bHQ6CgljYXNlIFBVU0hfREVGQVVMVF9NQVRDSElORzoKCQlhZGRfcmVmc3BlYygiOiIpOwoJCWJyZWFrOwoKCWNhc2UgUFVTSF9ERUZBVUxUX1RSQUNLSU5HOgoJCXNldHVwX3B1c2hfdHJhY2tpbmcoKTsKCQlicmVhazsKCgljYXNlIFBVU0hfREVGQVVMVF9DVVJSRU5UOgoJCWFkZF9yZWZzcGVjKCJIRUFEIik7CgkJYnJlYWs7CgoJY2FzZSBQVVNIX0RFRkFVTFRfTk9USElORzoKCQlkaWUoIllvdSBkaWRuJ3Qgc3BlY2lmeSBhbnkgcmVmc3BlY3MgdG8gcHVzaCwgYW5kICIKCQkgICAgInB1c2guZGVmYXVsdCBpcyBcIm5vdGhpbmdcIi4iKTsKCQlicmVhazsKCX0KfQoKc3RhdGljIGludCBwdXNoX3dpdGhfb3B0aW9ucyhzdHJ1Y3QgdHJhbnNwb3J0ICp0cmFuc3BvcnQsIGludCBmbGFncykKewoJaW50IGVycjsKCWludCBub25mYXN0Zm9yd2FyZDsKCgl0cmFuc3BvcnRfc2V0X3ZlcmJvc2l0eSh0cmFuc3BvcnQsIHZlcmJvc2l0eSk7CgoJaWYgKHJlY2VpdmVwYWNrKQoJCXRyYW5zcG9ydF9zZXRfb3B0aW9uKHRyYW5zcG9ydCwKCQkJCSAgICAgVFJBTlNfT1BUX1JFQ0VJVkVQQUNLLCByZWNlaXZlcGFjayk7CglpZiAodGhpbikKCQl0cmFuc3BvcnRfc2V0X29wdGlvbih0cmFuc3BvcnQsIFRSQU5TX09QVF9USElOLCAieWVzIik7CgoJaWYgKHZlcmJvc2l0eSA+IDApCgkJZnByaW50ZihzdGRlcnIsICJQdXNoaW5nIHRvICVzXG4iLCB0cmFuc3BvcnQtPnVybCk7CgllcnIgPSB0cmFuc3BvcnRfcHVzaCh0cmFuc3BvcnQsIHJlZnNwZWNfbnIsIHJlZnNwZWMsIGZsYWdzLAoJCQkgICAgICZub25mYXN0Zm9yd2FyZCk7CglpZiAoZXJyICE9IDApCgkJZXJyb3IoImZhaWxlZCB0byBwdXNoIHNvbWUgcmVmcyB0byAnJXMnIiwgdHJhbnNwb3J0LT51cmwpOwoKCWVyciB8PSB0cmFuc3BvcnRfZGlzY29ubmVjdCh0cmFuc3BvcnQpOwoKCWlmICghZXJyKQoJCXJldHVybiAwOwoKCWlmIChub25mYXN0Zm9yd2FyZCAmJiBhZHZpY2VfcHVzaF9ub25mYXN0Zm9yd2FyZCkgewoJCXByaW50ZigiVG8gcHJldmVudCB5b3UgZnJvbSBsb3NpbmcgaGlzdG9yeSwgbm9uLWZhc3QtZm9yd2FyZCB1cGRhdGVzIHdlcmUgcmVqZWN0ZWRcbiIKCQkgICAgICAgIk1lcmdlIHRoZSByZW1vdGUgY2hhbmdlcyBiZWZvcmUgcHVzaGluZyBhZ2Fpbi4gIFNlZSB0aGUgJ05vdGUgYWJvdXRcbiIKCQkgICAgICAgImZhc3QtZm9yd2FyZHMnIHNlY3Rpb24gb2YgJ2dpdCBwdXNoIC0taGVscCcgZm9yIGRldGFpbHMuXG4iKTsKCX0KCglyZXR1cm4gMTsKfQoKc3RhdGljIGludCBkb19wdXNoKGNvbnN0IGNoYXIgKnJlcG8sIGludCBmbGFncykKewoJaW50IGksIGVycnM7CglzdHJ1Y3QgcmVtb3RlICpyZW1vdGUgPSByZW1vdGVfZ2V0KHJlcG8pOwoJY29uc3QgY2hhciAqKnVybDsKCWludCB1cmxfbnI7CgoJaWYgKCFyZW1vdGUpIHsKCQlpZiAocmVwbykKCQkJZGllKCJiYWQgcmVwb3NpdG9yeSAnJXMnIiwgcmVwbyk7CgkJZGllKCJObyBkZXN0aW5hdGlvbiBjb25maWd1cmVkIHRvIHB1c2ggdG8uIik7Cgl9CgoJaWYgKHJlbW90ZS0+bWlycm9yKQoJCWZsYWdzIHw9IChUUkFOU1BPUlRfUFVTSF9NSVJST1J8VFJBTlNQT1JUX1BVU0hfRk9SQ0UpOwoKCWlmICgoZmxhZ3MgJiBUUkFOU1BPUlRfUFVTSF9BTEwpICYmIHJlZnNwZWMpIHsKCQlpZiAoIXN0cmNtcCgqcmVmc3BlYywgInJlZnMvdGFncy8qIikpCgkJCXJldHVybiBlcnJvcigiLS1hbGwgYW5kIC0tdGFncyBhcmUgaW5jb21wYXRpYmxlIik7CgkJcmV0dXJuIGVycm9yKCItLWFsbCBjYW4ndCBiZSBjb21iaW5lZCB3aXRoIHJlZnNwZWNzIik7Cgl9CgoJaWYgKChmbGFncyAmIFRSQU5TUE9SVF9QVVNIX01JUlJPUikgJiYgcmVmc3BlYykgewoJCWlmICghc3RyY21wKCpyZWZzcGVjLCAicmVmcy90YWdzLyoiKSkKCQkJcmV0dXJuIGVycm9yKCItLW1pcnJvciBhbmQgLS10YWdzIGFyZSBpbmNvbXBhdGlibGUiKTsKCQlyZXR1cm4gZXJyb3IoIi0tbWlycm9yIGNhbid0IGJlIGNvbWJpbmVkIHdpdGggcmVmc3BlY3MiKTsKCX0KCglpZiAoKGZsYWdzICYgKFRSQU5TUE9SVF9QVVNIX0FMTHxUUkFOU1BPUlRfUFVTSF9NSVJST1IpKSA9PQoJCQkJKFRSQU5TUE9SVF9QVVNIX0FMTHxUUkFOU1BPUlRfUFVTSF9NSVJST1IpKSB7CgkJcmV0dXJuIGVycm9yKCItLWFsbCBhbmQgLS1taXJyb3IgYXJlIGluY29tcGF0aWJsZSIpOwoJfQoKCWlmICghcmVmc3BlYyAmJiAhKGZsYWdzICYgVFJBTlNQT1JUX1BVU0hfQUxMKSkgewoJCWlmIChyZW1vdGUtPnB1c2hfcmVmc3BlY19ucikgewoJCQlyZWZzcGVjID0gcmVtb3RlLT5wdXNoX3JlZnNwZWM7CgkJCXJlZnNwZWNfbnIgPSByZW1vdGUtPnB1c2hfcmVmc3BlY19ucjsKCQl9IGVsc2UgaWYgKCEoZmxhZ3MgJiBUUkFOU1BPUlRfUFVTSF9NSVJST1IpKQoJCQlzZXR1cF9kZWZhdWx0X3B1c2hfcmVmc3BlY3MoKTsKCX0KCWVycnMgPSAwOwoJaWYgKHJlbW90ZS0+cHVzaHVybF9ucikgewoJCXVybCA9IHJlbW90ZS0+cHVzaHVybDsKCQl1cmxfbnIgPSByZW1vdGUtPnB1c2h1cmxfbnI7Cgl9IGVsc2UgewoJCXVybCA9IHJlbW90ZS0+dXJsOwoJCXVybF9uciA9IHJlbW90ZS0+dXJsX25yOwoJfQoJaWYgKHVybF9ucikgewoJCWZvciAoaSA9IDA7IGkgPCB1cmxfbnI7IGkrKykgewoJCQlzdHJ1Y3QgdHJhbnNwb3J0ICp0cmFuc3BvcnQgPQoJCQkJdHJhbnNwb3J0X2dldChyZW1vdGUsIHVybFtpXSk7CgkJCWlmIChwdXNoX3dpdGhfb3B0aW9ucyh0cmFuc3BvcnQsIGZsYWdzKSkKCQkJCWVycnMrKzsKCQl9Cgl9IGVsc2UgewoJCXN0cnVjdCB0cmFuc3BvcnQgKnRyYW5zcG9ydCA9CgkJCXRyYW5zcG9ydF9nZXQocmVtb3RlLCBOVUxMKTsKCgkJaWYgKHB1c2hfd2l0aF9vcHRpb25zKHRyYW5zcG9ydCwgZmxhZ3MpKQoJCQllcnJzKys7Cgl9CglyZXR1cm4gISFlcnJzOwp9CgppbnQgY21kX3B1c2goaW50IGFyZ2MsIGNvbnN0IGNoYXIgKiphcmd2LCBjb25zdCBjaGFyICpwcmVmaXgpCnsKCWludCBmbGFncyA9IDA7CglpbnQgdGFncyA9IDA7CglpbnQgcmM7Cgljb25zdCBjaGFyICpyZXBvID0gTlVMTDsJLyogZGVmYXVsdCByZXBvc2l0b3J5ICovCglzdHJ1Y3Qgb3B0aW9uIG9wdGlvbnNbXSA9IHsKCQlPUFRfX1ZFUkJPU0lUWSgmdmVyYm9zaXR5KSwKCQlPUFRfU1RSSU5HKCAwICwgInJlcG8iLCAmcmVwbywgInJlcG9zaXRvcnkiLCAicmVwb3NpdG9yeSIpLAoJCU9QVF9CSVQoIDAgLCAiYWxsIiwgJmZsYWdzLCAicHVzaCBhbGwgcmVmcyIsIFRSQU5TUE9SVF9QVVNIX0FMTCksCgkJT1BUX0JJVCggMCAsICJtaXJyb3IiLCAmZmxhZ3MsICJtaXJyb3IgYWxsIHJlZnMiLAoJCQkgICAgKFRSQU5TUE9SVF9QVVNIX01JUlJPUnxUUkFOU1BPUlRfUFVTSF9GT1JDRSkpLAoJCU9QVF9CT09MRUFOKCAwLCAiZGVsZXRlIiwgJmRlbGV0ZXJlZnMsICJkZWxldGUgcmVmcyIpLAoJCU9QVF9CT09MRUFOKCAwICwgInRhZ3MiLCAmdGFncywgInB1c2ggdGFncyAoY2FuJ3QgYmUgdXNlZCB3aXRoIC0tYWxsIG9yIC0tbWlycm9yKSIpLAoJCU9QVF9CSVQoJ24nICwgImRyeS1ydW4iLCAmZmxhZ3MsICJkcnkgcnVuIiwgVFJBTlNQT1JUX1BVU0hfRFJZX1JVTiksCgkJT1BUX0JJVCggMCwgICJwb3JjZWxhaW4iLCAmZmxhZ3MsICJtYWNoaW5lLXJlYWRhYmxlIG91dHB1dCIsIFRSQU5TUE9SVF9QVVNIX1BPUkNFTEFJTiksCgkJT1BUX0JJVCgnZicsICJmb3JjZSIsICZmbGFncywgImZvcmNlIHVwZGF0ZXMiLCBUUkFOU1BPUlRfUFVTSF9GT1JDRSksCgkJT1BUX0JPT0xFQU4oIDAgLCAidGhpbiIsICZ0aGluLCAidXNlIHRoaW4gcGFjayIpLAoJCU9QVF9TVFJJTkcoIDAgLCAicmVjZWl2ZS1wYWNrIiwgJnJlY2VpdmVwYWNrLCAicmVjZWl2ZS1wYWNrIiwgInJlY2VpdmUgcGFjayBwcm9ncmFtIiksCgkJT1BUX1NUUklORyggMCAsICJleGVjIiwgJnJlY2VpdmVwYWNrLCAicmVjZWl2ZS1wYWNrIiwgInJlY2VpdmUgcGFjayBwcm9ncmFtIiksCgkJT1BUX0JJVCgndScsICJzZXQtdXBzdHJlYW0iLCAmZmxhZ3MsICJzZXQgdXBzdHJlYW0gZm9yIGdpdCBwdWxsL3N0YXR1cyIsCgkJCVRSQU5TUE9SVF9QVVNIX1NFVF9VUFNUUkVBTSksCgkJT1BUX0VORCgpCgl9OwoKCWdpdF9jb25maWcoZ2l0X2RlZmF1bHRfY29uZmlnLCBOVUxMKTsKCWFyZ2MgPSBwYXJzZV9vcHRpb25zKGFyZ2MsIGFyZ3YsIHByZWZpeCwgb3B0aW9ucywgcHVzaF91c2FnZSwgMCk7CgoJaWYgKGRlbGV0ZXJlZnMgJiYgKHRhZ3MgfHwgKGZsYWdzICYgKFRSQU5TUE9SVF9QVVNIX0FMTCB8IFRSQU5TUE9SVF9QVVNIX01JUlJPUikpKSkKCQlkaWUoIi0tZGVsZXRlIGlzIGluY29tcGF0aWJsZSB3aXRoIC0tYWxsLCAtLW1pcnJvciBhbmQgLS10YWdzIik7CglpZiAoZGVsZXRlcmVmcyAmJiBhcmdjIDwgMikKCQlkaWUoIi0tZGVsZXRlIGRvZXNuJ3QgbWFrZSBzZW5zZSB3aXRob3V0IGFueSByZWZzIik7CgoJaWYgKHRhZ3MpCgkJYWRkX3JlZnNwZWMoInJlZnMvdGFncy8qIik7CgoJaWYgKGFyZ2MgPiAwKSB7CgkJcmVwbyA9IGFyZ3ZbMF07CgkJc2V0X3JlZnNwZWNzKGFyZ3YgKyAxLCBhcmdjIC0gMSk7Cgl9CgoJcmMgPSBkb19wdXNoKHJlcG8sIGZsYWdzKTsKCWlmIChyYyA9PSAtMSkKCQl1c2FnZV93aXRoX29wdGlvbnMocHVzaF91c2FnZSwgb3B0aW9ucyk7CgllbHNlCgkJcmV0dXJuIHJjOwp9Cg==",
    "text": "/*\n * \"git push\"\n */\n#include \"cache.h\"\n#include \"refs.h\"\n#include \"run-command.h\"\n#include \"builtin.h\"\n#include \"remote.h\"\n#include \"transport.h\"\n#include \"parse-options.h\"\n\nstatic const char * const push_usage[] = {\n\t\"git push [<options>] [<repository> <refspec>...]\",\n\tNULL,\n};\n\nstatic int thin;\nstatic int deleterefs;\nstatic const char *receivepack;\nstatic int verbosity;\n\nstatic const char **refspec;\nstatic int refspec_nr;\n\nstatic void add_refspec(const char *ref)\n{\n\tint nr = refspec_nr + 1;\n\trefspec = xrealloc(refspec, nr * sizeof(char *));\n\trefspec[nr-1] = ref;\n\trefspec_nr = nr;\n}\n\nstatic void set_refspecs(const char **refs, int nr)\n{\n\tint i;\n\tfor (i = 0; i < nr; i++) {\n\t\tconst char *ref = refs[i];\n\t\tif (!strcmp(\"tag\", ref)) {\n\t\t\tchar *tag;\n\t\t\tint len;\n\t\t\tif (nr <= ++i)\n\t\t\t\tdie(\"tag shorthand without <tag>\");\n\t\t\tlen = strlen(refs[i]) + 11;\n\t\t\tif (deleterefs) {\n\t\t\t\ttag = xmalloc(len+1);\n\t\t\t\tstrcpy(tag, \":refs/tags/\");\n\t\t\t} else {\n\t\t\t\ttag = xmalloc(len);\n\t\t\t\tstrcpy(tag, \"refs/tags/\");\n\t\t\t}\n\t\t\tstrcat(tag, refs[i]);\n\t\t\tref = tag;\n\t\t} else if (deleterefs && !strchr(ref, ':')) {\n\t\t\tchar *delref;\n\t\t\tint len = strlen(ref)+1;\n\t\t\tdelref = xmalloc(len+1);\n\t\t\tstrcpy(delref, \":\");\n\t\t\tstrcat(delref, ref);\n\t\t\tref = delref;\n\t\t} else if (deleterefs)\n\t\t\tdie(\"--delete only accepts plain target ref names\");\n\t\tadd_refspec(ref);\n\t}\n}\n\nstatic void setup_push_tracking(void)\n{\n\tstruct strbuf refspec = STRBUF_INIT;\n\tstruct branch *branch = branch_get(NULL);\n\tif (!branch)\n\t\tdie(\"You are not currently on a branch.\");\n\tif (!branch->merge_nr)\n\t\tdie(\"The current branch %s is not tracking anything.\",\n\t\t    branch->name);\n\tif (branch->merge_nr != 1)\n\t\tdie(\"The current branch %s is tracking multiple branches, \"\n\t\t    \"refusing to push.\", branch->name);\n\tstrbuf_addf(&refspec, \"%s:%s\", branch->name, branch->merge[0]->src);\n\tadd_refspec(refspec.buf);\n}\n\nstatic void setup_default_push_refspecs(void)\n{\n\tswitch (push_default) {\n\tdefault:\n\tcase PUSH_DEFAULT_MATCHING:\n\t\tadd_refspec(\":\");\n\t\tbreak;\n\n\tcase PUSH_DEFAULT_TRACKING:\n\t\tsetup_push_tracking();\n\t\tbreak;\n\n\tcase PUSH_DEFAULT_CURRENT:\n\t\tadd_refspec(\"HEAD\");\n\t\tbreak;\n\n\tcase PUSH_DEFAULT_NOTHING:\n\t\tdie(\"You didn't specify any refspecs to push, and \"\n\t\t    \"push.default is \\\"nothing\\\".\");\n\t\tbreak;\n\t}\n}\n\nstatic int push_with_options(struct transport *transport, int flags)\n{\n\tint err;\n\tint nonfastforward;\n\n\ttransport_set_verbosity(transport, verbosity);\n\n\tif (receivepack)\n\t\ttransport_set_option(transport,\n\t\t\t\t     TRANS_OPT_RECEIVEPACK, receivepack);\n\tif (thin)\n\t\ttransport_set_option(transport, TRANS_OPT_THIN, \"yes\");\n\n\tif (verbosity > 0)\n\t\tfprintf(stderr, \"Pushing to %s\\n\", transport->url);\n\terr = transport_push(transport, refspec_nr, refspec, flags,\n\t\t\t     &nonfastforward);\n\tif (err != 0)\n\t\terror(\"failed to push some refs to '%s'\", transport->url);\n\n\terr |= transport_disconnect(transport);\n\n\tif (!err)\n\t\treturn 0;\n\n\tif (nonfastforward && advice_push_nonfastforward) {\n\t\tprintf(\"To prevent you from losing history, non-fast-forward updates were rejected\\n\"\n\t\t       \"Merge the remote changes before pushing again.  See the 'Note about\\n\"\n\t\t       \"fast-forwards' section of 'git push --help' for details.\\n\");\n\t}\n\n\treturn 1;\n}\n\nstatic int do_push(const char *repo, int flags)\n{\n\tint i, errs;\n\tstruct remote *remote = remote_get(repo);\n\tconst char **url;\n\tint url_nr;\n\n\tif (!remote) {\n\t\tif (repo)\n\t\t\tdie(\"bad repository '%s'\", repo);\n\t\tdie(\"No destination configured to push to.\");\n\t}\n\n\tif (remote->mirror)\n\t\tflags |= (TRANSPORT_PUSH_MIRROR|TRANSPORT_PUSH_FORCE);\n\n\tif ((flags & TRANSPORT_PUSH_ALL) && refspec) {\n\t\tif (!strcmp(*refspec, \"refs/tags/*\"))\n\t\t\treturn error(\"--all and --tags are incompatible\");\n\t\treturn error(\"--all can't be combined with refspecs\");\n\t}\n\n\tif ((flags & TRANSPORT_PUSH_MIRROR) && refspec) {\n\t\tif (!strcmp(*refspec, \"refs/tags/*\"))\n\t\t\treturn error(\"--mirror and --tags are incompatible\");\n\t\treturn error(\"--mirror can't be combined with refspecs\");\n\t}\n\n\tif ((flags & (TRANSPORT_PUSH_ALL|TRANSPORT_PUSH_MIRROR)) ==\n\t\t\t\t(TRANSPORT_PUSH_ALL|TRANSPORT_PUSH_MIRROR)) {\n\t\treturn error(\"--all and --mirror are incompatible\");\n\t}\n\n\tif (!refspec && !(flags & TRANSPORT_PUSH_ALL)) {\n\t\tif (remote->push_refspec_nr) {\n\t\t\trefspec = remote->push_refspec;\n\t\t\trefspec_nr = remote->push_refspec_nr;\n\t\t} else if (!(flags & TRANSPORT_PUSH_MIRROR))\n\t\t\tsetup_default_push_refspecs();\n\t}\n\terrs = 0;\n\tif (remote->pushurl_nr) {\n\t\turl = remote->pushurl;\n\t\turl_nr = remote->pushurl_nr;\n\t} else {\n\t\turl = remote->url;\n\t\turl_nr = remote->url_nr;\n\t}\n\tif (url_nr) {\n\t\tfor (i = 0; i < url_nr; i++) {\n\t\t\tstruct transport *transport =\n\t\t\t\ttransport_get(remote, url[i]);\n\t\t\tif (push_with_options(transport, flags))\n\t\t\t\terrs++;\n\t\t}\n\t} else {\n\t\tstruct transport *transport =\n\t\t\ttransport_get(remote, NULL);\n\n\t\tif (push_with_options(transport, flags))\n\t\t\terrs++;\n\t}\n\treturn !!errs;\n}\n\nint cmd_push(int argc, const char **argv, const char *prefix)\n{\n\tint flags = 0;\n\tint tags = 0;\n\tint rc;\n\tconst char *repo = NULL;\t/* default repository */\n\tstruct option options[] = {\n\t\tOPT__VERBOSITY(&verbosity),\n\t\tOPT_STRING( 0 , \"repo\", &repo, \"repository\", \"repository\"),\n\t\tOPT_BIT( 0 , \"all\", &flags, \"push all refs\", TRANSPORT_PUSH_ALL),\n\t\tOPT_BIT( 0 , \"mirror\", &flags, \"mirror all refs\",\n\t\t\t    (TRANSPORT_PUSH_MIRROR|TRANSPORT_PUSH_FORCE)),\n\t\tOPT_BOOLEAN( 0, \"delete\", &deleterefs, \"delete refs\"),\n\t\tOPT_BOOLEAN( 0 , \"tags\", &tags, \"push tags (can't be used with --all or --mirror)\"),\n\t\tOPT_BIT('n' , \"dry-run\", &flags, \"dry run\", TRANSPORT_PUSH_DRY_RUN),\n\t\tOPT_BIT( 0,  \"porcelain\", &flags, \"machine-readable output\", TRANSPORT_PUSH_PORCELAIN),\n\t\tOPT_BIT('f', \"force\", &flags, \"force updates\", TRANSPORT_PUSH_FORCE),\n\t\tOPT_BOOLEAN( 0 , \"thin\", &thin, \"use thin pack\"),\n\t\tOPT_STRING( 0 , \"receive-pack\", &receivepack, \"receive-pack\", \"receive pack program\"),\n\t\tOPT_STRING( 0 , \"exec\", &receivepack, \"receive-pack\", \"receive pack program\"),\n\t\tOPT_BIT('u', \"set-upstream\", &flags, \"set upstream for git pull/status\",\n\t\t\tTRANSPORT_PUSH_SET_UPSTREAM),\n\t\tOPT_END()\n\t};\n\n\tgit_config(git_default_config, NULL);\n\targc = parse_options(argc, argv, prefix, options, push_usage, 0);\n\n\tif (deleterefs && (tags || (flags & (TRANSPORT_PUSH_ALL | TRANSPORT_PUSH_MIRROR))))\n\t\tdie(\"--delete is incompatible with --all, --mirror and --tags\");\n\tif (deleterefs && argc < 2)\n\t\tdie(\"--delete doesn't make sense without any refs\");\n\n\tif (tags)\n\t\tadd_refspec(\"refs/tags/*\");\n\n\tif (argc > 0) {\n\t\trepo = argv[0];\n\t\tset_refspecs(argv + 1, argc - 1);\n\t}\n\n\trc = do_push(repo, flags);\n\tif (rc == -1)\n\t\tusage_with_options(push_usage, options);\n\telse\n\t\treturn rc;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0082dadb73fb0767dd1e69001e485a2cbca6bf13",
  "sha1_ok": true,
  "size": 6580
}
