{
  "content": {
    "base64": "I2lmbmRlZiBDT01NSVRfU0xBQl9ICiNkZWZpbmUgQ09NTUlUX1NMQUJfSAoKLyoKICogZGVmaW5lX2NvbW1pdF9zbGFiKHNsYWJuYW1lLCBlbGVtdHlwZSkgY3JlYXRlcyBib2lsZXJwbGF0ZSBjb2RlIHRvIGRlZmluZQogKiBhIG5ldyBzdHJ1Y3QgKHN0cnVjdCBzbGFibmFtZSkgdGhhdCBpcyB1c2VkIHRvIGFzc29jaWF0ZSBhIHBpZWNlIG9mIGRhdGEKICogb2YgZWxlbXR5cGUgdG8gY29tbWl0cywgYW5kIGEgZmV3IGZ1bmN0aW9ucyB0byB1c2UgdGhhdCBzdHJ1Y3QuCiAqCiAqIEFmdGVyIGluY2x1ZGluZyB0aGlzIGhlYWRlciBmaWxlLCB1c2luZzoKICoKICogZGVmaW5lX2NvbW1pdF9zbGFiKGluZGVnZWUsIGludCk7CiAqCiAqIHdpbGwgbGV0IHlvdSBjYWxsIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zOgogKgogKiAtIGludCAqaW5kZWdyZWVfYXQoc3RydWN0IGluZGVncmVlICosIHN0cnVjdCBjb21taXQgKik7CiAqCiAqICAgVGhpcyBmdW5jdGlvbiBsb2NhdGVzIHRoZSBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gY29tbWl0IGluCiAqICAgdGhlIGluZGVncmVlIHNsYWIsIGFuZCByZXR1cm5zIHRoZSBwb2ludGVyIHRvIGl0LiAgVGhlIGxvY2F0aW9uIHRvCiAqICAgc3RvcmUgdGhlIGRhdGEgaXMgYWxsb2NhdGVkIGFzIG5lY2Vzc2FyeS4KICoKICogLSBpbnQgKmluZGVncmVlX3BlZWsoc3RydWN0IGluZGVncmVlICosIHN0cnVjdCBjb21taXQgKik7CiAqCiAqICAgVGhpcyBmdW5jdGlvbiBpcyBzaW1pbGFyIHRvIGluZGVncmVlX2F0KCksIGJ1dCBpdCB3aWxsIHJldHVybiBOVUxMCiAqICAgdW50aWwgYSBjYWxsIHRvIGluZGVncmVlX2F0KCkgd2FzIG1hZGUgZm9yIHRoZSBjb21taXQuCiAqCiAqIC0gdm9pZCBpbml0X2luZGVncmVlKHN0cnVjdCBpbmRlZ3JlZSAqKTsKICogICB2b2lkIGluaXRfaW5kZWdyZWVfd2l0aF9zdHJpZGUoc3RydWN0IGluZGVncmVlICosIGludCk7CiAqCiAqICAgSW5pdGlhbGl6ZXMgdGhlIGluZGVncmVlIHNsYWIgdGhhdCBhc3NvY2lhdGVzIGFuIGFycmF5IG9mIGludGVnZXJzCiAqICAgdG8gZWFjaCBjb21taXQuICdzdHJpZGUnIHNwZWNpZmllcyBob3cgYmlnIGVhY2ggYXJyYXkgaXMuICBUaGUgc2xhYgogKiAgIHRoYXQgaXMgaW5pdGlhbGl6ZWQgYnkgdGhlIHZhcmlhbnQgd2l0aG91dCAiX3dpdGhfc3RyaWRlIiBhc3NvY2lhdGVzCiAqICAgZWFjaCBjb21taXQgd2l0aCBhbiBhcnJheSBvZiBvbmUgaW50ZWdlci4KICoKICogLSB2b2lkIGNsZWFyX2luZGVncmVlKHN0cnVjdCBpbmRlZ3JlZSAqKTsKICoKICogICBFbXB0aWVzIHRoZSBzbGFiLiAgVGhlIHNsYWIgY2FuIGJlIHJldXNlZCB3aXRoIHRoZSBzYW1lIHN0cmlkZQogKiAgIHdpdGhvdXQgY2FsbGluZyBpbml0X2luZGVncmVlKCkgYWdhaW4gb3IgY2FuIGJlIHJlY29uZmlndXJlZCB0byBhCiAqICAgZGlmZmVyZW50IHN0cmlkZSBieSBjYWxsaW5nIGluaXRfaW5kZWdyZWVfd2l0aF9zdHJpZGUoKS4KICoKICogICBDYWxsIHRoaXMgZnVuY3Rpb24gYmVmb3JlIHRoZSBzbGFiIGZhbGxzIG91dCBvZiBzY29wZSB0byBhdm9pZAogKiAgIGxlYWtpbmcgbWVtb3J5LgogKi8KCi8qIGFsbG9jYXRlIH41MTJrQiBhdCBvbmNlLCBhbGxvd2luZyBmb3IgbWFsbG9jIG92ZXJoZWFkICovCiNpZm5kZWYgQ09NTUlUX1NMQUJfU0laRQojZGVmaW5lIENPTU1JVF9TTEFCX1NJWkUgKDUxMioxMDI0LTMyKQojZW5kaWYKCiNkZWZpbmUgTUFZQkVfVU5VU0VEIF9fYXR0cmlidXRlX18oKF9fdW51c2VkX18pKQoKI2RlZmluZSBkZWZpbmVfY29tbWl0X3NsYWIoc2xhYm5hbWUsIGVsZW10eXBlKSAJCQkJXAoJCQkJCQkJCQlcCnN0cnVjdCBzbGFibmFtZSB7CQkJCQkJCVwKCXVuc2lnbmVkIHNsYWJfc2l6ZTsJCQkJCQlcCgl1bnNpZ25lZCBzdHJpZGU7CQkJCQkJXAoJdW5zaWduZWQgc2xhYl9jb3VudDsJCQkJCQlcCgllbGVtdHlwZSAqKnNsYWI7CQkJCQkJXAp9OwkJCQkJCQkJCVwKc3RhdGljIGludCBzdGF0XyAjI3NsYWJuYW1lIyMgcmVhbGxvYzsJCQkJCVwKCQkJCQkJCQkJXApzdGF0aWMgTUFZQkVfVU5VU0VEIHZvaWQgaW5pdF8gIyNzbGFibmFtZSMjIF93aXRoX3N0cmlkZShzdHJ1Y3Qgc2xhYm5hbWUgKnMsIFwKCQkJCQkJICAgdW5zaWduZWQgc3RyaWRlKQlcCnsJCQkJCQkJCQlcCgl1bnNpZ25lZCBpbnQgZWxlbV9zaXplOwkJCQkJCVwKCWlmICghc3RyaWRlKQkJCQkJCQlcCgkJc3RyaWRlID0gMTsJCQkJCQlcCglzLT5zdHJpZGUgPSBzdHJpZGU7CQkJCQkJXAoJZWxlbV9zaXplID0gc2l6ZW9mKGVsZW10eXBlKSAqIHN0cmlkZTsJCQkJXAoJcy0+c2xhYl9zaXplID0gQ09NTUlUX1NMQUJfU0laRSAvIGVsZW1fc2l6ZTsJCQlcCglzLT5zbGFiX2NvdW50ID0gMDsJCQkJCQlcCglzLT5zbGFiID0gTlVMTDsJCQkJCQkJXAp9CQkJCQkJCQkJXAoJCQkJCQkJCQlcCnN0YXRpYyBNQVlCRV9VTlVTRUQgdm9pZCBpbml0XyAjI3NsYWJuYW1lKHN0cnVjdCBzbGFibmFtZSAqcykJCVwKewkJCQkJCQkJCVwKCWluaXRfICMjc2xhYm5hbWUjIyBfd2l0aF9zdHJpZGUocywgMSk7CQkJCVwKfQkJCQkJCQkJCVwKCQkJCQkJCQkJXApzdGF0aWMgTUFZQkVfVU5VU0VEIHZvaWQgY2xlYXJfICMjc2xhYm5hbWUoc3RydWN0IHNsYWJuYW1lICpzKQkJXAp7CQkJCQkJCQkJXAoJaW50IGk7CQkJCQkJCQlcCglmb3IgKGkgPSAwOyBpIDwgcy0+c2xhYl9jb3VudDsgaSsrKQkJCQlcCgkJZnJlZShzLT5zbGFiW2ldKTsJCQkJCVwKCXMtPnNsYWJfY291bnQgPSAwOwkJCQkJCVwKCWZyZWUocy0+c2xhYik7CQkJCQkJCVwKCXMtPnNsYWIgPSBOVUxMOwkJCQkJCQlcCn0JCQkJCQkJCQlcCgkJCQkJCQkJCVwKc3RhdGljIE1BWUJFX1VOVVNFRCBlbGVtdHlwZSAqc2xhYm5hbWUjIyBfYXRfcGVlayhzdHJ1Y3Qgc2xhYm5hbWUgKnMsCVwKCQkJCQkJICBjb25zdCBzdHJ1Y3QgY29tbWl0ICpjLCBcCgkJCQkJCSAgaW50IGFkZF9pZl9taXNzaW5nKSAgIFwKewkJCQkJCQkJCVwKCWludCBudGhfc2xhYiwgbnRoX3Nsb3Q7CQkJCQkJXAoJCQkJCQkJCQlcCgludGhfc2xhYiA9IGMtPmluZGV4IC8gcy0+c2xhYl9zaXplOwkJCQlcCgludGhfc2xvdCA9IGMtPmluZGV4ICUgcy0+c2xhYl9zaXplOwkJCQlcCgkJCQkJCQkJCVwKCWlmIChzLT5zbGFiX2NvdW50IDw9IG50aF9zbGFiKSB7CQkJCVwKCQlpbnQgaTsJCQkJCQkJXAoJCWlmICghYWRkX2lmX21pc3NpbmcpCQkJCQlcCgkJCXJldHVybiBOVUxMOwkJCQkJXAoJCVJFQUxMT0NfQVJSQVkocy0+c2xhYiwgbnRoX3NsYWIgKyAxKTsJCQlcCgkJc3RhdF8gIyNzbGFibmFtZSMjIHJlYWxsb2MrKzsJCQkJXAoJCWZvciAoaSA9IHMtPnNsYWJfY291bnQ7IGkgPD0gbnRoX3NsYWI7IGkrKykJCVwKCQkJcy0+c2xhYltpXSA9IE5VTEw7CQkJCVwKCQlzLT5zbGFiX2NvdW50ID0gbnRoX3NsYWIgKyAxOwkJCQlcCgl9CQkJCQkJCQlcCglpZiAoIXMtPnNsYWJbbnRoX3NsYWJdKSB7CQkJCQlcCgkJaWYgKCFhZGRfaWZfbWlzc2luZykJCQkJCVwKCQkJcmV0dXJuIE5VTEw7CQkJCQlcCgkJcy0+c2xhYltudGhfc2xhYl0gPSB4Y2FsbG9jKHMtPnNsYWJfc2l6ZSwJCVwKCQkJCQkgICAgc2l6ZW9mKCoqcy0+c2xhYikgKiBzLT5zdHJpZGUpOwkJXAoJfQkJCQkJCQkJXAoJcmV0dXJuICZzLT5zbGFiW250aF9zbGFiXVtudGhfc2xvdCAqIHMtPnN0cmlkZV07CQlcCn0JCQkJCQkJCQlcCgkJCQkJCQkJCVwKc3RhdGljIE1BWUJFX1VOVVNFRCBlbGVtdHlwZSAqc2xhYm5hbWUjIyBfYXQoc3RydWN0IHNsYWJuYW1lICpzLAlcCgkJCQkJICAgICBjb25zdCBzdHJ1Y3QgY29tbWl0ICpjKQlcCnsJCQkJCQkJCQlcCglyZXR1cm4gc2xhYm5hbWUjI19hdF9wZWVrKHMsIGMsIDEpOwkJCQlcCn0JCQkJCQkJCQlcCgkJCQkJCQkJCVwKc3RhdGljIE1BWUJFX1VOVVNFRCBlbGVtdHlwZSAqc2xhYm5hbWUjIyBfcGVlayhzdHJ1Y3Qgc2xhYm5hbWUgKnMsCVwKCQkJCQkgICAgIGNvbnN0IHN0cnVjdCBjb21taXQgKmMpCVwKewkJCQkJCQkJCVwKCXJldHVybiBzbGFibmFtZSMjX2F0X3BlZWsocywgYywgMCk7CQkJCVwKfQkJCQkJCQkJCVwKCQkJCQkJCQkJXApzdHJ1Y3Qgc2xhYm5hbWUKCi8qCiAqIE5vdGUgdGhhdCB0aGlzIHJlZHVuZGFudCBmb3J3YXJkIGRlY2xhcmF0aW9uIGlzIHJlcXVpcmVkCiAqIHRvIGFsbG93IGEgdGVybWluYXRpbmcgc2VtaWNvbG9uLCB3aGljaCBtYWtlcyBpbnN0YW50aWF0aW9ucyBsb29rCiAqIGxpa2UgZnVuY3Rpb24gZGVjbGFyYXRpb25zLiAgSS5lLiwgdGhlIGV4cGFuc2lvbiBvZgogKgogKiAgICBkZWZpbmVfY29tbWl0X3NsYWIoaW5kZWdyZWUsIGludCk7CiAqCiAqIGVuZHMgaW4gJ3N0cnVjdCBpbmRlZ3JlZTsnLiAgVGhpcyB3b3VsZCBvdGhlcndpc2UKICogYmUgYSBzeW50YXggZXJyb3IgYWNjb3JkaW5nIChhdCBsZWFzdCkgdG8gSVNPIEMuICBJdCdzIGhhcmQgdG8KICogY2F0Y2ggYmVjYXVzZSBHQ0Mgc2lsZW50bHkgcGFyc2VzIGl0IGJ5IGRlZmF1bHQuCiAqLwoKLyoKICogU3RhdGljYWxseSBpbml0aWFsaXplIGEgY29tbWl0IHNsYWIgbmFtZWQgInZhciIuIE5vdGUgdGhhdCB0aGlzCiAqIGV2YWx1YXRlcyAic3RyaWRlIiBtdWx0aXBsZSB0aW1lcyEgRXhhbXBsZToKICoKICogICBzdHJ1Y3QgaW5kZWdyZWUgaW5kZWdyZWVzID0gQ09NTUlUX1NMQUJfSU5JVCgxLCBpbmRlZ3JlZXMpOwogKgogKi8KI2RlZmluZSBDT01NSVRfU0xBQl9JTklUKHN0cmlkZSwgdmFyKSB7IFwKCUNPTU1JVF9TTEFCX1NJWkUgLyBzaXplb2YoKiooKHZhcikuc2xhYikpIC8gKHN0cmlkZSksIFwKCShzdHJpZGUpLCAwLCBOVUxMIFwKfQoKI2VuZGlmIC8qIENPTU1JVF9TTEFCX0ggKi8K",
    "text": "#ifndef COMMIT_SLAB_H\n#define COMMIT_SLAB_H\n\n/*\n * define_commit_slab(slabname, elemtype) creates boilerplate code to define\n * a new struct (struct slabname) that is used to associate a piece of data\n * of elemtype to commits, and a few functions to use that struct.\n *\n * After including this header file, using:\n *\n * define_commit_slab(indegee, int);\n *\n * will let you call the following functions:\n *\n * - int *indegree_at(struct indegree *, struct commit *);\n *\n *   This function locates the data associated with the given commit in\n *   the indegree slab, and returns the pointer to it.  The location to\n *   store the data is allocated as necessary.\n *\n * - int *indegree_peek(struct indegree *, struct commit *);\n *\n *   This function is similar to indegree_at(), but it will return NULL\n *   until a call to indegree_at() was made for the commit.\n *\n * - void init_indegree(struct indegree *);\n *   void init_indegree_with_stride(struct indegree *, int);\n *\n *   Initializes the indegree slab that associates an array of integers\n *   to each commit. 'stride' specifies how big each array is.  The slab\n *   that is initialized by the variant without \"_with_stride\" associates\n *   each commit with an array of one integer.\n *\n * - void clear_indegree(struct indegree *);\n *\n *   Empties the slab.  The slab can be reused with the same stride\n *   without calling init_indegree() again or can be reconfigured to a\n *   different stride by calling init_indegree_with_stride().\n *\n *   Call this function before the slab falls out of scope to avoid\n *   leaking memory.\n */\n\n/* allocate ~512kB at once, allowing for malloc overhead */\n#ifndef COMMIT_SLAB_SIZE\n#define COMMIT_SLAB_SIZE (512*1024-32)\n#endif\n\n#define MAYBE_UNUSED __attribute__((__unused__))\n\n#define define_commit_slab(slabname, elemtype) \t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstruct slabname {\t\t\t\t\t\t\t\\\n\tunsigned slab_size;\t\t\t\t\t\t\\\n\tunsigned stride;\t\t\t\t\t\t\\\n\tunsigned slab_count;\t\t\t\t\t\t\\\n\telemtype **slab;\t\t\t\t\t\t\\\n};\t\t\t\t\t\t\t\t\t\\\nstatic int stat_ ##slabname## realloc;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic MAYBE_UNUSED void init_ ##slabname## _with_stride(struct slabname *s, \\\n\t\t\t\t\t\t   unsigned stride)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tunsigned int elem_size;\t\t\t\t\t\t\\\n\tif (!stride)\t\t\t\t\t\t\t\\\n\t\tstride = 1;\t\t\t\t\t\t\\\n\ts->stride = stride;\t\t\t\t\t\t\\\n\telem_size = sizeof(elemtype) * stride;\t\t\t\t\\\n\ts->slab_size = COMMIT_SLAB_SIZE / elem_size;\t\t\t\\\n\ts->slab_count = 0;\t\t\t\t\t\t\\\n\ts->slab = NULL;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic MAYBE_UNUSED void init_ ##slabname(struct slabname *s)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tinit_ ##slabname## _with_stride(s, 1);\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic MAYBE_UNUSED void clear_ ##slabname(struct slabname *s)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tint i;\t\t\t\t\t\t\t\t\\\n\tfor (i = 0; i < s->slab_count; i++)\t\t\t\t\\\n\t\tfree(s->slab[i]);\t\t\t\t\t\\\n\ts->slab_count = 0;\t\t\t\t\t\t\\\n\tfree(s->slab);\t\t\t\t\t\t\t\\\n\ts->slab = NULL;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic MAYBE_UNUSED elemtype *slabname## _at_peek(struct slabname *s,\t\\\n\t\t\t\t\t\t  const struct commit *c, \\\n\t\t\t\t\t\t  int add_if_missing)   \\\n{\t\t\t\t\t\t\t\t\t\\\n\tint nth_slab, nth_slot;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tnth_slab = c->index / s->slab_size;\t\t\t\t\\\n\tnth_slot = c->index % s->slab_size;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (s->slab_count <= nth_slab) {\t\t\t\t\\\n\t\tint i;\t\t\t\t\t\t\t\\\n\t\tif (!add_if_missing)\t\t\t\t\t\\\n\t\t\treturn NULL;\t\t\t\t\t\\\n\t\tREALLOC_ARRAY(s->slab, nth_slab + 1);\t\t\t\\\n\t\tstat_ ##slabname## realloc++;\t\t\t\t\\\n\t\tfor (i = s->slab_count; i <= nth_slab; i++)\t\t\\\n\t\t\ts->slab[i] = NULL;\t\t\t\t\\\n\t\ts->slab_count = nth_slab + 1;\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tif (!s->slab[nth_slab]) {\t\t\t\t\t\\\n\t\tif (!add_if_missing)\t\t\t\t\t\\\n\t\t\treturn NULL;\t\t\t\t\t\\\n\t\ts->slab[nth_slab] = xcalloc(s->slab_size,\t\t\\\n\t\t\t\t\t    sizeof(**s->slab) * s->stride);\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\treturn &s->slab[nth_slab][nth_slot * s->stride];\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic MAYBE_UNUSED elemtype *slabname## _at(struct slabname *s,\t\\\n\t\t\t\t\t     const struct commit *c)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn slabname##_at_peek(s, c, 1);\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic MAYBE_UNUSED elemtype *slabname## _peek(struct slabname *s,\t\\\n\t\t\t\t\t     const struct commit *c)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn slabname##_at_peek(s, c, 0);\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstruct slabname\n\n/*\n * Note that this redundant forward declaration is required\n * to allow a terminating semicolon, which makes instantiations look\n * like function declarations.  I.e., the expansion of\n *\n *    define_commit_slab(indegree, int);\n *\n * ends in 'struct indegree;'.  This would otherwise\n * be a syntax error according (at least) to ISO C.  It's hard to\n * catch because GCC silently parses it by default.\n */\n\n/*\n * Statically initialize a commit slab named \"var\". Note that this\n * evaluates \"stride\" multiple times! Example:\n *\n *   struct indegree indegrees = COMMIT_SLAB_INIT(1, indegrees);\n *\n */\n#define COMMIT_SLAB_INIT(stride, var) { \\\n\tCOMMIT_SLAB_SIZE / sizeof(**((var).slab)) / (stride), \\\n\t(stride), 0, NULL \\\n}\n\n#endif /* COMMIT_SLAB_H */\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "006a50b5481b552278931f5aec33883d79891a80",
  "sha1_ok": true,
  "size": 4827
}
