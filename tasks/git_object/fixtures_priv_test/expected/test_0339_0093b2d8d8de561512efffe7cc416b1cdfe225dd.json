{
  "content": {
    "base64": "LyoKICogQnVpbHRpbiAiZ2l0IGxvZyIgYW5kIHJlbGF0ZWQgY29tbWFuZHMgKHNob3csIHdoYXRjaGFuZ2VkKQogKgogKiAoQykgQ29weXJpZ2h0IDIwMDYgTGludXMgVG9ydmFsZHMKICoJCSAyMDA2IEp1bmlvIEhhbWFubwogKi8KI2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJjb2xvci5oIgojaW5jbHVkZSAiY29tbWl0LmgiCiNpbmNsdWRlICJkaWZmLmgiCiNpbmNsdWRlICJyZXZpc2lvbi5oIgojaW5jbHVkZSAibG9nLXRyZWUuaCIKI2luY2x1ZGUgImJ1aWx0aW4uaCIKI2luY2x1ZGUgInRhZy5oIgojaW5jbHVkZSAicmVmbG9nLXdhbGsuaCIKI2luY2x1ZGUgInBhdGNoLWlkcy5oIgojaW5jbHVkZSAicnVuLWNvbW1hbmQuaCIKI2luY2x1ZGUgInNob3J0bG9nLmgiCiNpbmNsdWRlICJyZW1vdGUuaCIKI2luY2x1ZGUgInN0cmluZy1saXN0LmgiCiNpbmNsdWRlICJwYXJzZS1vcHRpb25zLmgiCgovKiBTZXQgYSBkZWZhdWx0IGRhdGUtdGltZSBmb3JtYXQgZm9yIGdpdCBsb2cgKCJsb2cuZGF0ZSIgY29uZmlnIHZhcmlhYmxlKSAqLwpzdGF0aWMgY29uc3QgY2hhciAqZGVmYXVsdF9kYXRlX21vZGUgPSBOVUxMOwoKc3RhdGljIGludCBkZWZhdWx0X3Nob3dfcm9vdCA9IDE7CnN0YXRpYyBjb25zdCBjaGFyICpmbXRfcGF0Y2hfc3ViamVjdF9wcmVmaXggPSAiUEFUQ0giOwpzdGF0aWMgY29uc3QgY2hhciAqZm10X3ByZXR0eTsKCnN0YXRpYyBjb25zdCBjaGFyICogY29uc3QgYnVpbHRpbl9sb2dfdXNhZ2UgPQoJImdpdCBsb2cgWzxvcHRpb25zPl0gWzxzaW5jZT4uLjx1bnRpbD5dIFtbLS1dIDxwYXRoPi4uLl1cbiIKCSIgICBvcjogZ2l0IHNob3cgW29wdGlvbnNdIDxvYmplY3Q+Li4uIjsKCnN0YXRpYyB2b2lkIGNtZF9sb2dfaW5pdChpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsIGNvbnN0IGNoYXIgKnByZWZpeCwKCQkJIHN0cnVjdCByZXZfaW5mbyAqcmV2LCBzdHJ1Y3Qgc2V0dXBfcmV2aXNpb25fb3B0ICpvcHQpCnsKCWludCBpOwoJaW50IGRlY29yYXRpb25fc3R5bGUgPSAwOwoJc3RydWN0IHVzZXJmb3JtYXRfd2FudCB3OwoKCXJldi0+YWJicmV2ID0gREVGQVVMVF9BQkJSRVY7CglyZXYtPmNvbW1pdF9mb3JtYXQgPSBDTUlUX0ZNVF9ERUZBVUxUOwoJaWYgKGZtdF9wcmV0dHkpCgkJZ2V0X2NvbW1pdF9mb3JtYXQoZm10X3ByZXR0eSwgcmV2KTsKCXJldi0+dmVyYm9zZV9oZWFkZXIgPSAxOwoJRElGRl9PUFRfU0VUKCZyZXYtPmRpZmZvcHQsIFJFQ1VSU0lWRSk7CglyZXYtPnNob3dfcm9vdF9kaWZmID0gZGVmYXVsdF9zaG93X3Jvb3Q7CglyZXYtPnN1YmplY3RfcHJlZml4ID0gZm10X3BhdGNoX3N1YmplY3RfcHJlZml4OwoJRElGRl9PUFRfU0VUKCZyZXYtPmRpZmZvcHQsIEFMTE9XX1RFWFRDT05WKTsKCglpZiAoZGVmYXVsdF9kYXRlX21vZGUpCgkJcmV2LT5kYXRlX21vZGUgPSBwYXJzZV9kYXRlX2Zvcm1hdChkZWZhdWx0X2RhdGVfbW9kZSk7CgoJLyoKCSAqIENoZWNrIGZvciAtaCBiZWZvcmUgc2V0dXBfcmV2aXNpb25zKCksIG9yICJnaXQgbG9nIC1oIiB3aWxsCgkgKiBmYWlsIHdoZW4gcnVuIHdpdGhvdXQgYSBnaXQgZGlyZWN0b3J5LgoJICovCglpZiAoYXJnYyA9PSAyICYmICFzdHJjbXAoYXJndlsxXSwgIi1oIikpCgkJdXNhZ2UoYnVpbHRpbl9sb2dfdXNhZ2UpOwoJYXJnYyA9IHNldHVwX3JldmlzaW9ucyhhcmdjLCBhcmd2LCByZXYsIG9wdCk7CgoJbWVtc2V0KCZ3LCAwLCBzaXplb2YodykpOwoJdXNlcmZvcm1hdF9maW5kX3JlcXVpcmVtZW50cyhOVUxMLCAmdyk7CgoJaWYgKCFyZXYtPnNob3dfbm90ZXNfZ2l2ZW4gJiYgKCFyZXYtPnByZXR0eV9naXZlbiB8fCB3Lm5vdGVzKSkKCQlyZXYtPnNob3dfbm90ZXMgPSAxOwoJaWYgKHJldi0+c2hvd19ub3RlcykKCQlpbml0X2Rpc3BsYXlfbm90ZXMoJnJldi0+bm90ZXNfb3B0KTsKCglpZiAocmV2LT5kaWZmb3B0LnBpY2theGUgfHwgcmV2LT5kaWZmb3B0LmZpbHRlcikKCQlyZXYtPmFsd2F5c19zaG93X2hlYWRlciA9IDA7CglpZiAoRElGRl9PUFRfVFNUKCZyZXYtPmRpZmZvcHQsIEZPTExPV19SRU5BTUVTKSkgewoJCXJldi0+YWx3YXlzX3Nob3dfaGVhZGVyID0gMDsKCQlpZiAocmV2LT5kaWZmb3B0Lm5yX3BhdGhzICE9IDEpCgkJCXVzYWdlKCJnaXQgbG9ncyBjYW4gb25seSBmb2xsb3cgcmVuYW1lcyBvbiBvbmUgcGF0aG5hbWUgYXQgYSB0aW1lIik7Cgl9Cglmb3IgKGkgPSAxOyBpIDwgYXJnYzsgaSsrKSB7CgkJY29uc3QgY2hhciAqYXJnID0gYXJndltpXTsKCQlpZiAoIXN0cmNtcChhcmcsICItLWRlY29yYXRlIikpIHsKCQkJZGVjb3JhdGlvbl9zdHlsZSA9IERFQ09SQVRFX1NIT1JUX1JFRlM7CgkJfSBlbHNlIGlmICghcHJlZml4Y21wKGFyZywgIi0tZGVjb3JhdGU9IikpIHsKCQkJY29uc3QgY2hhciAqdiA9IHNraXBfcHJlZml4KGFyZywgIi0tZGVjb3JhdGU9Iik7CgkJCWlmICghc3RyY21wKHYsICJmdWxsIikpCgkJCQlkZWNvcmF0aW9uX3N0eWxlID0gREVDT1JBVEVfRlVMTF9SRUZTOwoJCQllbHNlIGlmICghc3RyY21wKHYsICJzaG9ydCIpKQoJCQkJZGVjb3JhdGlvbl9zdHlsZSA9IERFQ09SQVRFX1NIT1JUX1JFRlM7CgkJCWVsc2UKCQkJCWRpZSgiaW52YWxpZCAtLWRlY29yYXRlIG9wdGlvbjogJXMiLCBhcmcpOwoJCX0gZWxzZSBpZiAoIXN0cmNtcChhcmcsICItLXNvdXJjZSIpKSB7CgkJCXJldi0+c2hvd19zb3VyY2UgPSAxOwoJCX0gZWxzZSBpZiAoIXN0cmNtcChhcmcsICItaCIpKSB7CgkJCXVzYWdlKGJ1aWx0aW5fbG9nX3VzYWdlKTsKCQl9IGVsc2UKCQkJZGllKCJ1bnJlY29nbml6ZWQgYXJndW1lbnQ6ICVzIiwgYXJnKTsKCX0KCWlmIChkZWNvcmF0aW9uX3N0eWxlKSB7CgkJcmV2LT5zaG93X2RlY29yYXRpb25zID0gMTsKCQlsb2FkX3JlZl9kZWNvcmF0aW9ucyhkZWNvcmF0aW9uX3N0eWxlKTsKCX0KfQoKLyoKICogVGhpcyBnaXZlcyBhIHJvdWdoIGVzdGltYXRlIGZvciBob3cgbWFueSBjb21taXRzIHdlCiAqIHdpbGwgcHJpbnQgb3V0IGluIHRoZSBsaXN0LgogKi8Kc3RhdGljIGludCBlc3RpbWF0ZV9jb21taXRfY291bnQoc3RydWN0IHJldl9pbmZvICpyZXYsIHN0cnVjdCBjb21taXRfbGlzdCAqbGlzdCkKewoJaW50IG4gPSAwOwoKCXdoaWxlIChsaXN0KSB7CgkJc3RydWN0IGNvbW1pdCAqY29tbWl0ID0gbGlzdC0+aXRlbTsKCQl1bnNpZ25lZCBpbnQgZmxhZ3MgPSBjb21taXQtPm9iamVjdC5mbGFnczsKCQlsaXN0ID0gbGlzdC0+bmV4dDsKCQlpZiAoIShmbGFncyAmIChUUkVFU0FNRSB8IFVOSU5URVJFU1RJTkcpKSkKCQkJbisrOwoJfQoJcmV0dXJuIG47Cn0KCnN0YXRpYyB2b2lkIHNob3dfZWFybHlfaGVhZGVyKHN0cnVjdCByZXZfaW5mbyAqcmV2LCBjb25zdCBjaGFyICpzdGFnZSwgaW50IG5yKQp7CglpZiAocmV2LT5zaG93bl9vbmUpIHsKCQlyZXYtPnNob3duX29uZSA9IDA7CgkJaWYgKHJldi0+Y29tbWl0X2Zvcm1hdCAhPSBDTUlUX0ZNVF9PTkVMSU5FKQoJCQlwdXRjaGFyKHJldi0+ZGlmZm9wdC5saW5lX3Rlcm1pbmF0aW9uKTsKCX0KCXByaW50ZigiRmluYWwgb3V0cHV0OiAlZCAlc1xuIiwgbnIsIHN0YWdlKTsKfQoKc3RhdGljIHN0cnVjdCBpdGltZXJ2YWwgZWFybHlfb3V0cHV0X3RpbWVyOwoKc3RhdGljIHZvaWQgbG9nX3Nob3dfZWFybHkoc3RydWN0IHJldl9pbmZvICpyZXZzLCBzdHJ1Y3QgY29tbWl0X2xpc3QgKmxpc3QpCnsKCWludCBpID0gcmV2cy0+ZWFybHlfb3V0cHV0OwoJaW50IHNob3dfaGVhZGVyID0gMTsKCglzb3J0X2luX3RvcG9sb2dpY2FsX29yZGVyKCZsaXN0LCByZXZzLT5saWZvKTsKCXdoaWxlIChsaXN0ICYmIGkpIHsKCQlzdHJ1Y3QgY29tbWl0ICpjb21taXQgPSBsaXN0LT5pdGVtOwoJCXN3aXRjaCAoc2ltcGxpZnlfY29tbWl0KHJldnMsIGNvbW1pdCkpIHsKCQljYXNlIGNvbW1pdF9zaG93OgoJCQlpZiAoc2hvd19oZWFkZXIpIHsKCQkJCWludCBuID0gZXN0aW1hdGVfY29tbWl0X2NvdW50KHJldnMsIGxpc3QpOwoJCQkJc2hvd19lYXJseV9oZWFkZXIocmV2cywgImluY29tcGxldGUiLCBuKTsKCQkJCXNob3dfaGVhZGVyID0gMDsKCQkJfQoJCQlsb2dfdHJlZV9jb21taXQocmV2cywgY29tbWl0KTsKCQkJaS0tOwoJCQlicmVhazsKCQljYXNlIGNvbW1pdF9pZ25vcmU6CgkJCWJyZWFrOwoJCWNhc2UgY29tbWl0X2Vycm9yOgoJCQlyZXR1cm47CgkJfQoJCWxpc3QgPSBsaXN0LT5uZXh0OwoJfQoKCS8qIERpZCB3ZSBhbHJlYWR5IGdldCBlbm91Z2ggY29tbWl0cyBmb3IgdGhlIGVhcmx5IG91dHB1dD8gKi8KCWlmICghaSkKCQlyZXR1cm47CgoJLyoKCSAqIC4uaWYgbm8sIHRoZW4gcmVwZWF0IGl0IHR3aWNlIGEgc2Vjb25kIHVudGlsIHdlCgkgKiBkby4KCSAqCgkgKiBOT1RFISBXZSBkb24ndCB1c2UgIml0X2ludGVydmFsIiwgYmVjYXVzZSBpZiB0aGUKCSAqIHJlYWRlciBpc24ndCBsaXN0ZW5pbmcsIHdlIHdhbnQgb3VyIG91dHB1dCB0byBiZQoJICogdGhyb3R0bGVkIGJ5IHRoZSB3cml0aW5nLCBhbmQgbm90IGhhdmUgdGhlIHRpbWVyCgkgKiB0cmlnZ2VyIGV2ZXJ5IHNlY29uZCBldmVuIGlmIHdlJ3JlIGJsb2NrZWQgb24gYQoJICogcmVhZGVyIQoJICovCgllYXJseV9vdXRwdXRfdGltZXIuaXRfdmFsdWUudHZfc2VjID0gMDsKCWVhcmx5X291dHB1dF90aW1lci5pdF92YWx1ZS50dl91c2VjID0gNTAwMDAwOwoJc2V0aXRpbWVyKElUSU1FUl9SRUFMLCAmZWFybHlfb3V0cHV0X3RpbWVyLCBOVUxMKTsKfQoKc3RhdGljIHZvaWQgZWFybHlfb3V0cHV0KGludCBzaWduYWwpCnsKCXNob3dfZWFybHlfb3V0cHV0ID0gbG9nX3Nob3dfZWFybHk7Cn0KCnN0YXRpYyB2b2lkIHNldHVwX2Vhcmx5X291dHB1dChzdHJ1Y3QgcmV2X2luZm8gKnJldikKewoJc3RydWN0IHNpZ2FjdGlvbiBzYTsKCgkvKgoJICogU2V0IHVwIHRoZSBzaWduYWwgaGFuZGxlciwgbWluaW1hbGx5IGludHJ1c2l2ZWx5OgoJICogd2Ugb25seSBzZXQgYSBzaW5nbGUgdm9sYXRpbGUgaW50ZWdlciB3b3JkIChub3QKCSAqIHVzaW5nIHNpZ2F0b21pY190IC0gdHJ5aW5nIHRvIGF2b2lkIHVubmVjZXNzYXJ5CgkgKiBzeXN0ZW0gZGVwZW5kZW5jaWVzIGFuZCBoZWFkZXJzKSwgYW5kIHVzaW5nCgkgKiBTQV9SRVNUQVJULgoJICovCgltZW1zZXQoJnNhLCAwLCBzaXplb2Yoc2EpKTsKCXNhLnNhX2hhbmRsZXIgPSBlYXJseV9vdXRwdXQ7CglzaWdlbXB0eXNldCgmc2Euc2FfbWFzayk7CglzYS5zYV9mbGFncyA9IFNBX1JFU1RBUlQ7CglzaWdhY3Rpb24oU0lHQUxSTSwgJnNhLCBOVUxMKTsKCgkvKgoJICogSWYgd2UgY2FuIGdldCB0aGUgd2hvbGUgb3V0cHV0IGluIGxlc3MgdGhhbiBhCgkgKiB0ZW50aCBvZiBhIHNlY29uZCwgZG9uJ3QgZXZlbiBib3RoZXIgZG9pbmcgdGhlCgkgKiBlYXJseS1vdXRwdXQgdGhpbmcuLgoJICoKCSAqIFRoaXMgaXMgYSBvbmUtdGltZS1vbmx5IHRyaWdnZXIuCgkgKi8KCWVhcmx5X291dHB1dF90aW1lci5pdF92YWx1ZS50dl9zZWMgPSAwOwoJZWFybHlfb3V0cHV0X3RpbWVyLml0X3ZhbHVlLnR2X3VzZWMgPSAxMDAwMDA7CglzZXRpdGltZXIoSVRJTUVSX1JFQUwsICZlYXJseV9vdXRwdXRfdGltZXIsIE5VTEwpOwp9CgpzdGF0aWMgdm9pZCBmaW5pc2hfZWFybHlfb3V0cHV0KHN0cnVjdCByZXZfaW5mbyAqcmV2KQp7CglpbnQgbiA9IGVzdGltYXRlX2NvbW1pdF9jb3VudChyZXYsIHJldi0+Y29tbWl0cyk7CglzaWduYWwoU0lHQUxSTSwgU0lHX0lHTik7CglzaG93X2Vhcmx5X2hlYWRlcihyZXYsICJkb25lIiwgbik7Cn0KCnN0YXRpYyBpbnQgY21kX2xvZ193YWxrKHN0cnVjdCByZXZfaW5mbyAqcmV2KQp7CglzdHJ1Y3QgY29tbWl0ICpjb21taXQ7CgoJaWYgKHJldi0+ZWFybHlfb3V0cHV0KQoJCXNldHVwX2Vhcmx5X291dHB1dChyZXYpOwoKCWlmIChwcmVwYXJlX3JldmlzaW9uX3dhbGsocmV2KSkKCQlkaWUoInJldmlzaW9uIHdhbGsgc2V0dXAgZmFpbGVkIik7CgoJaWYgKHJldi0+ZWFybHlfb3V0cHV0KQoJCWZpbmlzaF9lYXJseV9vdXRwdXQocmV2KTsKCgkvKgoJICogRm9yIC0tY2hlY2sgYW5kIC0tZXhpdC1jb2RlLCB0aGUgZXhpdCBjb2RlIGlzIGJhc2VkIG9uIENIRUNLX0ZBSUxFRAoJICogYW5kIEhBU19DSEFOR0VTIGJlaW5nIGFjY3VtdWxhdGVkIGluIHJldi0+ZGlmZm9wdCwgc28gYmUgY2FyZWZ1bCB0bwoJICogcmV0YWluIHRoYXQgc3RhdGUgaW5mb3JtYXRpb24gaWYgcmVwbGFjaW5nIHJldi0+ZGlmZm9wdCBpbiB0aGlzIGxvb3AKCSAqLwoJd2hpbGUgKChjb21taXQgPSBnZXRfcmV2aXNpb24ocmV2KSkgIT0gTlVMTCkgewoJCWxvZ190cmVlX2NvbW1pdChyZXYsIGNvbW1pdCk7CgkJaWYgKCFyZXYtPnJlZmxvZ19pbmZvKSB7CgkJCS8qIHdlIGFsbG93IGN5Y2xlcyBpbiByZWZsb2cgYW5jZXN0cnkgKi8KCQkJZnJlZShjb21taXQtPmJ1ZmZlcik7CgkJCWNvbW1pdC0+YnVmZmVyID0gTlVMTDsKCQl9CgkJZnJlZV9jb21taXRfbGlzdChjb21taXQtPnBhcmVudHMpOwoJCWNvbW1pdC0+cGFyZW50cyA9IE5VTEw7Cgl9CglpZiAocmV2LT5kaWZmb3B0Lm91dHB1dF9mb3JtYXQgJiBESUZGX0ZPUk1BVF9DSEVDS0RJRkYgJiYKCSAgICBESUZGX09QVF9UU1QoJnJldi0+ZGlmZm9wdCwgQ0hFQ0tfRkFJTEVEKSkgewoJCXJldHVybiAwMjsKCX0KCXJldHVybiBkaWZmX3Jlc3VsdF9jb2RlKCZyZXYtPmRpZmZvcHQsIDApOwp9CgpzdGF0aWMgaW50IGdpdF9sb2dfY29uZmlnKGNvbnN0IGNoYXIgKnZhciwgY29uc3QgY2hhciAqdmFsdWUsIHZvaWQgKmNiKQp7CglpZiAoIXN0cmNtcCh2YXIsICJmb3JtYXQucHJldHR5IikpCgkJcmV0dXJuIGdpdF9jb25maWdfc3RyaW5nKCZmbXRfcHJldHR5LCB2YXIsIHZhbHVlKTsKCWlmICghc3RyY21wKHZhciwgImZvcm1hdC5zdWJqZWN0cHJlZml4IikpCgkJcmV0dXJuIGdpdF9jb25maWdfc3RyaW5nKCZmbXRfcGF0Y2hfc3ViamVjdF9wcmVmaXgsIHZhciwgdmFsdWUpOwoJaWYgKCFzdHJjbXAodmFyLCAibG9nLmRhdGUiKSkKCQlyZXR1cm4gZ2l0X2NvbmZpZ19zdHJpbmcoJmRlZmF1bHRfZGF0ZV9tb2RlLCB2YXIsIHZhbHVlKTsKCWlmICghc3RyY21wKHZhciwgImxvZy5zaG93cm9vdCIpKSB7CgkJZGVmYXVsdF9zaG93X3Jvb3QgPSBnaXRfY29uZmlnX2Jvb2wodmFyLCB2YWx1ZSk7CgkJcmV0dXJuIDA7Cgl9CglyZXR1cm4gZ2l0X2RpZmZfdWlfY29uZmlnKHZhciwgdmFsdWUsIGNiKTsKfQoKaW50IGNtZF93aGF0Y2hhbmdlZChpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsIGNvbnN0IGNoYXIgKnByZWZpeCkKewoJc3RydWN0IHJldl9pbmZvIHJldjsKCXN0cnVjdCBzZXR1cF9yZXZpc2lvbl9vcHQgb3B0OwoKCWdpdF9jb25maWcoZ2l0X2xvZ19jb25maWcsIE5VTEwpOwoKCWlmIChkaWZmX3VzZV9jb2xvcl9kZWZhdWx0ID09IC0xKQoJCWRpZmZfdXNlX2NvbG9yX2RlZmF1bHQgPSBnaXRfdXNlX2NvbG9yX2RlZmF1bHQ7CgoJaW5pdF9yZXZpc2lvbnMoJnJldiwgcHJlZml4KTsKCXJldi5kaWZmID0gMTsKCXJldi5zaW1wbGlmeV9oaXN0b3J5ID0gMDsKCW1lbXNldCgmb3B0LCAwLCBzaXplb2Yob3B0KSk7CglvcHQuZGVmID0gIkhFQUQiOwoJY21kX2xvZ19pbml0KGFyZ2MsIGFyZ3YsIHByZWZpeCwgJnJldiwgJm9wdCk7CglpZiAoIXJldi5kaWZmb3B0Lm91dHB1dF9mb3JtYXQpCgkJcmV2LmRpZmZvcHQub3V0cHV0X2Zvcm1hdCA9IERJRkZfRk9STUFUX1JBVzsKCXJldHVybiBjbWRfbG9nX3dhbGsoJnJldik7Cn0KCnN0YXRpYyB2b2lkIHNob3dfdGFnZ2VyKGNoYXIgKmJ1ZiwgaW50IGxlbiwgc3RydWN0IHJldl9pbmZvICpyZXYpCnsKCXN0cnVjdCBzdHJidWYgb3V0ID0gU1RSQlVGX0lOSVQ7CgoJcHBfdXNlcl9pbmZvKCJUYWdnZXIiLCByZXYtPmNvbW1pdF9mb3JtYXQsICZvdXQsIGJ1ZiwgcmV2LT5kYXRlX21vZGUsCgkJZ2l0X2xvZ19vdXRwdXRfZW5jb2RpbmcgPwoJCWdpdF9sb2dfb3V0cHV0X2VuY29kaW5nOiBnaXRfY29tbWl0X2VuY29kaW5nKTsKCXByaW50ZigiJXMiLCBvdXQuYnVmKTsKCXN0cmJ1Zl9yZWxlYXNlKCZvdXQpOwp9CgpzdGF0aWMgaW50IHNob3dfb2JqZWN0KGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEsIGludCBzaG93X3RhZ19vYmplY3QsCglzdHJ1Y3QgcmV2X2luZm8gKnJldikKewoJdW5zaWduZWQgbG9uZyBzaXplOwoJZW51bSBvYmplY3RfdHlwZSB0eXBlOwoJY2hhciAqYnVmID0gcmVhZF9zaGExX2ZpbGUoc2hhMSwgJnR5cGUsICZzaXplKTsKCWludCBvZmZzZXQgPSAwOwoKCWlmICghYnVmKQoJCXJldHVybiBlcnJvcigiQ291bGQgbm90IHJlYWQgb2JqZWN0ICVzIiwgc2hhMV90b19oZXgoc2hhMSkpOwoKCWlmIChzaG93X3RhZ19vYmplY3QpCgkJd2hpbGUgKG9mZnNldCA8IHNpemUgJiYgYnVmW29mZnNldF0gIT0gJ1xuJykgewoJCQlpbnQgbmV3X29mZnNldCA9IG9mZnNldCArIDE7CgkJCXdoaWxlIChuZXdfb2Zmc2V0IDwgc2l6ZSAmJiBidWZbbmV3X29mZnNldCsrXSAhPSAnXG4nKQoJCQkJOyAvKiBkbyBub3RoaW5nICovCgkJCWlmICghcHJlZml4Y21wKGJ1ZiArIG9mZnNldCwgInRhZ2dlciAiKSkKCQkJCXNob3dfdGFnZ2VyKGJ1ZiArIG9mZnNldCArIDcsCgkJCQkJICAgIG5ld19vZmZzZXQgLSBvZmZzZXQgLSA3LCByZXYpOwoJCQlvZmZzZXQgPSBuZXdfb2Zmc2V0OwoJCX0KCglpZiAob2Zmc2V0IDwgc2l6ZSkKCQlmd3JpdGUoYnVmICsgb2Zmc2V0LCBzaXplIC0gb2Zmc2V0LCAxLCBzdGRvdXQpOwoJZnJlZShidWYpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgc2hvd190cmVlX29iamVjdChjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExLAoJCWNvbnN0IGNoYXIgKmJhc2UsIGludCBiYXNlbGVuLAoJCWNvbnN0IGNoYXIgKnBhdGhuYW1lLCB1bnNpZ25lZCBtb2RlLCBpbnQgc3RhZ2UsIHZvaWQgKmNvbnRleHQpCnsKCXByaW50ZigiJXMlc1xuIiwgcGF0aG5hbWUsIFNfSVNESVIobW9kZSkgPyAiLyIgOiAiIik7CglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgc2hvd19yZXZfdHdlYWtfcmV2KHN0cnVjdCByZXZfaW5mbyAqcmV2LCBzdHJ1Y3Qgc2V0dXBfcmV2aXNpb25fb3B0ICpvcHQpCnsKCWlmIChyZXYtPmlnbm9yZV9tZXJnZXMpIHsKCQkvKiBUaGVyZSB3YXMgbm8gIi1tIiBvbiB0aGUgY29tbWFuZCBsaW5lICovCgkJcmV2LT5pZ25vcmVfbWVyZ2VzID0gMDsKCQlpZiAoIXJldi0+Zmlyc3RfcGFyZW50X29ubHkgJiYgIXJldi0+Y29tYmluZV9tZXJnZXMpIHsKCQkJLyogTm8gIi0tZmlyc3QtcGFyZW50IiwgIi1jIiwgbm9yICItLWNjIiAqLwoJCQlyZXYtPmNvbWJpbmVfbWVyZ2VzID0gMTsKCQkJcmV2LT5kZW5zZV9jb21iaW5lZF9tZXJnZXMgPSAxOwoJCX0KCX0KCWlmICghcmV2LT5kaWZmb3B0Lm91dHB1dF9mb3JtYXQpCgkJcmV2LT5kaWZmb3B0Lm91dHB1dF9mb3JtYXQgPSBESUZGX0ZPUk1BVF9QQVRDSDsKfQoKaW50IGNtZF9zaG93KGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndiwgY29uc3QgY2hhciAqcHJlZml4KQp7CglzdHJ1Y3QgcmV2X2luZm8gcmV2OwoJc3RydWN0IG9iamVjdF9hcnJheV9lbnRyeSAqb2JqZWN0czsKCXN0cnVjdCBzZXR1cF9yZXZpc2lvbl9vcHQgb3B0OwoJaW50IGksIGNvdW50LCByZXQgPSAwOwoKCWdpdF9jb25maWcoZ2l0X2xvZ19jb25maWcsIE5VTEwpOwoKCWlmIChkaWZmX3VzZV9jb2xvcl9kZWZhdWx0ID09IC0xKQoJCWRpZmZfdXNlX2NvbG9yX2RlZmF1bHQgPSBnaXRfdXNlX2NvbG9yX2RlZmF1bHQ7CgoJaW5pdF9yZXZpc2lvbnMoJnJldiwgcHJlZml4KTsKCXJldi5kaWZmID0gMTsKCXJldi5hbHdheXNfc2hvd19oZWFkZXIgPSAxOwoJcmV2Lm5vX3dhbGsgPSAxOwoJbWVtc2V0KCZvcHQsIDAsIHNpemVvZihvcHQpKTsKCW9wdC5kZWYgPSAiSEVBRCI7CglvcHQudHdlYWsgPSBzaG93X3Jldl90d2Vha19yZXY7CgljbWRfbG9nX2luaXQoYXJnYywgYXJndiwgcHJlZml4LCAmcmV2LCAmb3B0KTsKCgljb3VudCA9IHJldi5wZW5kaW5nLm5yOwoJb2JqZWN0cyA9IHJldi5wZW5kaW5nLm9iamVjdHM7Cglmb3IgKGkgPSAwOyBpIDwgY291bnQgJiYgIXJldDsgaSsrKSB7CgkJc3RydWN0IG9iamVjdCAqbyA9IG9iamVjdHNbaV0uaXRlbTsKCQljb25zdCBjaGFyICpuYW1lID0gb2JqZWN0c1tpXS5uYW1lOwoJCXN3aXRjaCAoby0+dHlwZSkgewoJCWNhc2UgT0JKX0JMT0I6CgkJCXJldCA9IHNob3dfb2JqZWN0KG8tPnNoYTEsIDAsIE5VTEwpOwoJCQlicmVhazsKCQljYXNlIE9CSl9UQUc6IHsKCQkJc3RydWN0IHRhZyAqdCA9IChzdHJ1Y3QgdGFnICopbzsKCgkJCWlmIChyZXYuc2hvd25fb25lKQoJCQkJcHV0Y2hhcignXG4nKTsKCQkJcHJpbnRmKCIlc3RhZyAlcyVzXG4iLAoJCQkJCWRpZmZfZ2V0X2NvbG9yX29wdCgmcmV2LmRpZmZvcHQsIERJRkZfQ09NTUlUKSwKCQkJCQl0LT50YWcsCgkJCQkJZGlmZl9nZXRfY29sb3Jfb3B0KCZyZXYuZGlmZm9wdCwgRElGRl9SRVNFVCkpOwoJCQlyZXQgPSBzaG93X29iamVjdChvLT5zaGExLCAxLCAmcmV2KTsKCQkJcmV2LnNob3duX29uZSA9IDE7CgkJCWlmIChyZXQpCgkJCQlicmVhazsKCQkJbyA9IHBhcnNlX29iamVjdCh0LT50YWdnZWQtPnNoYTEpOwoJCQlpZiAoIW8pCgkJCQlyZXQgPSBlcnJvcigiQ291bGQgbm90IHJlYWQgb2JqZWN0ICVzIiwKCQkJCQkgICAgc2hhMV90b19oZXgodC0+dGFnZ2VkLT5zaGExKSk7CgkJCW9iamVjdHNbaV0uaXRlbSA9IG87CgkJCWktLTsKCQkJYnJlYWs7CgkJfQoJCWNhc2UgT0JKX1RSRUU6CgkJCWlmIChyZXYuc2hvd25fb25lKQoJCQkJcHV0Y2hhcignXG4nKTsKCQkJcHJpbnRmKCIlc3RyZWUgJXMlc1xuXG4iLAoJCQkJCWRpZmZfZ2V0X2NvbG9yX29wdCgmcmV2LmRpZmZvcHQsIERJRkZfQ09NTUlUKSwKCQkJCQluYW1lLAoJCQkJCWRpZmZfZ2V0X2NvbG9yX29wdCgmcmV2LmRpZmZvcHQsIERJRkZfUkVTRVQpKTsKCQkJcmVhZF90cmVlX3JlY3Vyc2l2ZSgoc3RydWN0IHRyZWUgKilvLCAiIiwgMCwgMCwgTlVMTCwKCQkJCQlzaG93X3RyZWVfb2JqZWN0LCBOVUxMKTsKCQkJcmV2LnNob3duX29uZSA9IDE7CgkJCWJyZWFrOwoJCWNhc2UgT0JKX0NPTU1JVDoKCQkJcmV2LnBlbmRpbmcubnIgPSByZXYucGVuZGluZy5hbGxvYyA9IDA7CgkJCXJldi5wZW5kaW5nLm9iamVjdHMgPSBOVUxMOwoJCQlhZGRfb2JqZWN0X2FycmF5KG8sIG5hbWUsICZyZXYucGVuZGluZyk7CgkJCXJldCA9IGNtZF9sb2dfd2FsaygmcmV2KTsKCQkJYnJlYWs7CgkJZGVmYXVsdDoKCQkJcmV0ID0gZXJyb3IoIlVua25vd24gdHlwZTogJWQiLCBvLT50eXBlKTsKCQl9Cgl9CglmcmVlKG9iamVjdHMpOwoJcmV0dXJuIHJldDsKfQoKLyoKICogVGhpcyBpcyBlcXVpdmFsZW50IHRvICJnaXQgbG9nIC1nIC0tYWJicmV2LWNvbW1pdCAtLXByZXR0eT1vbmVsaW5lIgogKi8KaW50IGNtZF9sb2dfcmVmbG9nKGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndiwgY29uc3QgY2hhciAqcHJlZml4KQp7CglzdHJ1Y3QgcmV2X2luZm8gcmV2OwoJc3RydWN0IHNldHVwX3JldmlzaW9uX29wdCBvcHQ7CgoJZ2l0X2NvbmZpZyhnaXRfbG9nX2NvbmZpZywgTlVMTCk7CgoJaWYgKGRpZmZfdXNlX2NvbG9yX2RlZmF1bHQgPT0gLTEpCgkJZGlmZl91c2VfY29sb3JfZGVmYXVsdCA9IGdpdF91c2VfY29sb3JfZGVmYXVsdDsKCglpbml0X3JldmlzaW9ucygmcmV2LCBwcmVmaXgpOwoJaW5pdF9yZWZsb2dfd2FsaygmcmV2LnJlZmxvZ19pbmZvKTsKCXJldi5hYmJyZXZfY29tbWl0ID0gMTsKCXJldi52ZXJib3NlX2hlYWRlciA9IDE7CgltZW1zZXQoJm9wdCwgMCwgc2l6ZW9mKG9wdCkpOwoJb3B0LmRlZiA9ICJIRUFEIjsKCWNtZF9sb2dfaW5pdChhcmdjLCBhcmd2LCBwcmVmaXgsICZyZXYsICZvcHQpOwoKCS8qCgkgKiBUaGlzIG1lYW5zIHRoYXQgd2Ugb3ZlcnJpZGUgd2hhdGV2ZXIgY29tbWl0IGZvcm1hdCB0aGUgdXNlciBnYXZlCgkgKiBvbiB0aGUgY21kIGxpbmUuICBTYWQsIGJ1dCBjbWRfbG9nX2luaXQoKSBjdXJyZW50bHkgZG9lc24ndAoJICogYWxsb3cgdXMgdG8gc2V0IGEgZGlmZmVyZW50IGRlZmF1bHQuCgkgKi8KCXJldi5jb21taXRfZm9ybWF0ID0gQ01JVF9GTVRfT05FTElORTsKCXJldi51c2VfdGVybWluYXRvciA9IDE7CglyZXYuYWx3YXlzX3Nob3dfaGVhZGVyID0gMTsKCgkvKgoJICogV2UgZ2V0IGNhbGxlZCB0aHJvdWdoICJnaXQgcmVmbG9nIiwgc28gdW5saWtlIHRoZSBvdGhlciBsb2cKCSAqIHJvdXRpbmVzLCB3ZSBuZWVkIHRvIHNldCB1cCBvdXIgcGFnZXIgbWFudWFsbHkuLgoJICovCglzZXR1cF9wYWdlcigpOwoKCXJldHVybiBjbWRfbG9nX3dhbGsoJnJldik7Cn0KCmludCBjbWRfbG9nKGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndiwgY29uc3QgY2hhciAqcHJlZml4KQp7CglzdHJ1Y3QgcmV2X2luZm8gcmV2OwoJc3RydWN0IHNldHVwX3JldmlzaW9uX29wdCBvcHQ7CgoJZ2l0X2NvbmZpZyhnaXRfbG9nX2NvbmZpZywgTlVMTCk7CgoJaWYgKGRpZmZfdXNlX2NvbG9yX2RlZmF1bHQgPT0gLTEpCgkJZGlmZl91c2VfY29sb3JfZGVmYXVsdCA9IGdpdF91c2VfY29sb3JfZGVmYXVsdDsKCglpbml0X3JldmlzaW9ucygmcmV2LCBwcmVmaXgpOwoJcmV2LmFsd2F5c19zaG93X2hlYWRlciA9IDE7CgltZW1zZXQoJm9wdCwgMCwgc2l6ZW9mKG9wdCkpOwoJb3B0LmRlZiA9ICJIRUFEIjsKCWNtZF9sb2dfaW5pdChhcmdjLCBhcmd2LCBwcmVmaXgsICZyZXYsICZvcHQpOwoJcmV0dXJuIGNtZF9sb2dfd2FsaygmcmV2KTsKfQoKLyogZm9ybWF0LXBhdGNoICovCgpzdGF0aWMgY29uc3QgY2hhciAqZm10X3BhdGNoX3N1ZmZpeCA9ICIucGF0Y2giOwpzdGF0aWMgaW50IG51bWJlcmVkID0gMDsKc3RhdGljIGludCBhdXRvX251bWJlciA9IDE7CgpzdGF0aWMgY2hhciAqZGVmYXVsdF9hdHRhY2ggPSBOVUxMOwoKc3RhdGljIHN0cnVjdCBzdHJpbmdfbGlzdCBleHRyYV9oZHI7CnN0YXRpYyBzdHJ1Y3Qgc3RyaW5nX2xpc3QgZXh0cmFfdG87CnN0YXRpYyBzdHJ1Y3Qgc3RyaW5nX2xpc3QgZXh0cmFfY2M7CgpzdGF0aWMgdm9pZCBhZGRfaGVhZGVyKGNvbnN0IGNoYXIgKnZhbHVlKQp7CglzdHJ1Y3Qgc3RyaW5nX2xpc3RfaXRlbSAqaXRlbTsKCWludCBsZW4gPSBzdHJsZW4odmFsdWUpOwoJd2hpbGUgKGxlbiAmJiB2YWx1ZVtsZW4gLSAxXSA9PSAnXG4nKQoJCWxlbi0tOwoKCWlmICghc3RybmNhc2VjbXAodmFsdWUsICJ0bzogIiwgNCkpIHsKCQlpdGVtID0gc3RyaW5nX2xpc3RfYXBwZW5kKHZhbHVlICsgNCwgJmV4dHJhX3RvKTsKCQlsZW4gLT0gNDsKCX0gZWxzZSBpZiAoIXN0cm5jYXNlY21wKHZhbHVlLCAiY2M6ICIsIDQpKSB7CgkJaXRlbSA9IHN0cmluZ19saXN0X2FwcGVuZCh2YWx1ZSArIDQsICZleHRyYV9jYyk7CgkJbGVuIC09IDQ7Cgl9IGVsc2UgewoJCWl0ZW0gPSBzdHJpbmdfbGlzdF9hcHBlbmQodmFsdWUsICZleHRyYV9oZHIpOwoJfQoKCWl0ZW0tPnN0cmluZ1tsZW5dID0gJ1wwJzsKfQoKI2RlZmluZSBUSFJFQURfU0hBTExPVyAxCiNkZWZpbmUgVEhSRUFEX0RFRVAgMgpzdGF0aWMgaW50IHRocmVhZCA9IDA7CnN0YXRpYyBpbnQgZG9fc2lnbm9mZiA9IDA7CgpzdGF0aWMgaW50IGdpdF9mb3JtYXRfY29uZmlnKGNvbnN0IGNoYXIgKnZhciwgY29uc3QgY2hhciAqdmFsdWUsIHZvaWQgKmNiKQp7CglpZiAoIXN0cmNtcCh2YXIsICJmb3JtYXQuaGVhZGVycyIpKSB7CgkJaWYgKCF2YWx1ZSkKCQkJZGllKCJmb3JtYXQuaGVhZGVycyB3aXRob3V0IHZhbHVlIik7CgkJYWRkX2hlYWRlcih2YWx1ZSk7CgkJcmV0dXJuIDA7Cgl9CglpZiAoIXN0cmNtcCh2YXIsICJmb3JtYXQuc3VmZml4IikpCgkJcmV0dXJuIGdpdF9jb25maWdfc3RyaW5nKCZmbXRfcGF0Y2hfc3VmZml4LCB2YXIsIHZhbHVlKTsKCWlmICghc3RyY21wKHZhciwgImZvcm1hdC50byIpKSB7CgkJaWYgKCF2YWx1ZSkKCQkJcmV0dXJuIGNvbmZpZ19lcnJvcl9ub25ib29sKHZhcik7CgkJc3RyaW5nX2xpc3RfYXBwZW5kKHZhbHVlLCAmZXh0cmFfdG8pOwoJCXJldHVybiAwOwoJfQoJaWYgKCFzdHJjbXAodmFyLCAiZm9ybWF0LmNjIikpIHsKCQlpZiAoIXZhbHVlKQoJCQlyZXR1cm4gY29uZmlnX2Vycm9yX25vbmJvb2wodmFyKTsKCQlzdHJpbmdfbGlzdF9hcHBlbmQodmFsdWUsICZleHRyYV9jYyk7CgkJcmV0dXJuIDA7Cgl9CglpZiAoIXN0cmNtcCh2YXIsICJkaWZmLmNvbG9yIikgfHwgIXN0cmNtcCh2YXIsICJjb2xvci5kaWZmIikpIHsKCQlyZXR1cm4gMDsKCX0KCWlmICghc3RyY21wKHZhciwgImZvcm1hdC5udW1iZXJlZCIpKSB7CgkJaWYgKHZhbHVlICYmICFzdHJjYXNlY21wKHZhbHVlLCAiYXV0byIpKSB7CgkJCWF1dG9fbnVtYmVyID0gMTsKCQkJcmV0dXJuIDA7CgkJfQoJCW51bWJlcmVkID0gZ2l0X2NvbmZpZ19ib29sKHZhciwgdmFsdWUpOwoJCWF1dG9fbnVtYmVyID0gYXV0b19udW1iZXIgJiYgbnVtYmVyZWQ7CgkJcmV0dXJuIDA7Cgl9CglpZiAoIXN0cmNtcCh2YXIsICJmb3JtYXQuYXR0YWNoIikpIHsKCQlpZiAodmFsdWUgJiYgKnZhbHVlKQoJCQlkZWZhdWx0X2F0dGFjaCA9IHhzdHJkdXAodmFsdWUpOwoJCWVsc2UKCQkJZGVmYXVsdF9hdHRhY2ggPSB4c3RyZHVwKGdpdF92ZXJzaW9uX3N0cmluZyk7CgkJcmV0dXJuIDA7Cgl9CglpZiAoIXN0cmNtcCh2YXIsICJmb3JtYXQudGhyZWFkIikpIHsKCQlpZiAodmFsdWUgJiYgIXN0cmNhc2VjbXAodmFsdWUsICJkZWVwIikpIHsKCQkJdGhyZWFkID0gVEhSRUFEX0RFRVA7CgkJCXJldHVybiAwOwoJCX0KCQlpZiAodmFsdWUgJiYgIXN0cmNhc2VjbXAodmFsdWUsICJzaGFsbG93IikpIHsKCQkJdGhyZWFkID0gVEhSRUFEX1NIQUxMT1c7CgkJCXJldHVybiAwOwoJCX0KCQl0aHJlYWQgPSBnaXRfY29uZmlnX2Jvb2wodmFyLCB2YWx1ZSkgJiYgVEhSRUFEX1NIQUxMT1c7CgkJcmV0dXJuIDA7Cgl9CglpZiAoIXN0cmNtcCh2YXIsICJmb3JtYXQuc2lnbm9mZiIpKSB7CgkJZG9fc2lnbm9mZiA9IGdpdF9jb25maWdfYm9vbCh2YXIsIHZhbHVlKTsKCQlyZXR1cm4gMDsKCX0KCglyZXR1cm4gZ2l0X2xvZ19jb25maWcodmFyLCB2YWx1ZSwgY2IpOwp9CgpzdGF0aWMgRklMRSAqcmVhbHN0ZG91dCA9IE5VTEw7CnN0YXRpYyBjb25zdCBjaGFyICpvdXRwdXRfZGlyZWN0b3J5ID0gTlVMTDsKc3RhdGljIGludCBvdXRkaXJfb2Zmc2V0OwoKc3RhdGljIGludCByZW9wZW5fc3Rkb3V0KHN0cnVjdCBjb21taXQgKmNvbW1pdCwgc3RydWN0IHJldl9pbmZvICpyZXYpCnsKCXN0cnVjdCBzdHJidWYgZmlsZW5hbWUgPSBTVFJCVUZfSU5JVDsKCWludCBzdWZmaXhfbGVuID0gc3RybGVuKGZtdF9wYXRjaF9zdWZmaXgpICsgMTsKCglpZiAob3V0cHV0X2RpcmVjdG9yeSkgewoJCXN0cmJ1Zl9hZGRzdHIoJmZpbGVuYW1lLCBvdXRwdXRfZGlyZWN0b3J5KTsKCQlpZiAoZmlsZW5hbWUubGVuID49CgkJICAgIFBBVEhfTUFYIC0gRk9STUFUX1BBVENIX05BTUVfTUFYIC0gc3VmZml4X2xlbikKCQkJcmV0dXJuIGVycm9yKCJuYW1lIG9mIG91dHB1dCBkaXJlY3RvcnkgaXMgdG9vIGxvbmciKTsKCQlpZiAoZmlsZW5hbWUuYnVmW2ZpbGVuYW1lLmxlbiAtIDFdICE9ICcvJykKCQkJc3RyYnVmX2FkZGNoKCZmaWxlbmFtZSwgJy8nKTsKCX0KCglnZXRfcGF0Y2hfZmlsZW5hbWUoY29tbWl0LCByZXYtPm5yLCBmbXRfcGF0Y2hfc3VmZml4LCAmZmlsZW5hbWUpOwoKCWlmICghRElGRl9PUFRfVFNUKCZyZXYtPmRpZmZvcHQsIFFVSUNLKSkKCQlmcHJpbnRmKHJlYWxzdGRvdXQsICIlc1xuIiwgZmlsZW5hbWUuYnVmICsgb3V0ZGlyX29mZnNldCk7CgoJaWYgKGZyZW9wZW4oZmlsZW5hbWUuYnVmLCAidyIsIHN0ZG91dCkgPT0gTlVMTCkKCQlyZXR1cm4gZXJyb3IoIkNhbm5vdCBvcGVuIHBhdGNoIGZpbGUgJXMiLCBmaWxlbmFtZS5idWYpOwoKCXN0cmJ1Zl9yZWxlYXNlKCZmaWxlbmFtZSk7CglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgZ2V0X3BhdGNoX2lkcyhzdHJ1Y3QgcmV2X2luZm8gKnJldiwgc3RydWN0IHBhdGNoX2lkcyAqaWRzLCBjb25zdCBjaGFyICpwcmVmaXgpCnsKCXN0cnVjdCByZXZfaW5mbyBjaGVja19yZXY7CglzdHJ1Y3QgY29tbWl0ICpjb21taXQ7CglzdHJ1Y3Qgb2JqZWN0ICpvMSwgKm8yOwoJdW5zaWduZWQgZmxhZ3MxLCBmbGFnczI7CgoJaWYgKHJldi0+cGVuZGluZy5uciAhPSAyKQoJCWRpZSgiTmVlZCBleGFjdGx5IG9uZSByYW5nZS4iKTsKCglvMSA9IHJldi0+cGVuZGluZy5vYmplY3RzWzBdLml0ZW07CglmbGFnczEgPSBvMS0+ZmxhZ3M7CglvMiA9IHJldi0+cGVuZGluZy5vYmplY3RzWzFdLml0ZW07CglmbGFnczIgPSBvMi0+ZmxhZ3M7CgoJaWYgKChmbGFnczEgJiBVTklOVEVSRVNUSU5HKSA9PSAoZmxhZ3MyICYgVU5JTlRFUkVTVElORykpCgkJZGllKCJOb3QgYSByYW5nZS4iKTsKCglpbml0X3BhdGNoX2lkcyhpZHMpOwoKCS8qIGdpdmVuIGEgcmFuZ2UgYS4uYiBnZXQgYWxsIHBhdGNoIGlkcyBmb3IgYi4uYSAqLwoJaW5pdF9yZXZpc2lvbnMoJmNoZWNrX3JldiwgcHJlZml4KTsKCW8xLT5mbGFncyBePSBVTklOVEVSRVNUSU5HOwoJbzItPmZsYWdzIF49IFVOSU5URVJFU1RJTkc7CglhZGRfcGVuZGluZ19vYmplY3QoJmNoZWNrX3JldiwgbzEsICJvMSIpOwoJYWRkX3BlbmRpbmdfb2JqZWN0KCZjaGVja19yZXYsIG8yLCAibzIiKTsKCWlmIChwcmVwYXJlX3JldmlzaW9uX3dhbGsoJmNoZWNrX3JldikpCgkJZGllKCJyZXZpc2lvbiB3YWxrIHNldHVwIGZhaWxlZCIpOwoKCXdoaWxlICgoY29tbWl0ID0gZ2V0X3JldmlzaW9uKCZjaGVja19yZXYpKSAhPSBOVUxMKSB7CgkJLyogaWdub3JlIG1lcmdlcyAqLwoJCWlmIChjb21taXQtPnBhcmVudHMgJiYgY29tbWl0LT5wYXJlbnRzLT5uZXh0KQoJCQljb250aW51ZTsKCgkJYWRkX2NvbW1pdF9wYXRjaF9pZChjb21taXQsIGlkcyk7Cgl9CgoJLyogcmVzZXQgZm9yIG5leHQgcmV2aXNpb24gd2FsayAqLwoJY2xlYXJfY29tbWl0X21hcmtzKChzdHJ1Y3QgY29tbWl0ICopbzEsCgkJCVNFRU4gfCBVTklOVEVSRVNUSU5HIHwgU0hPV04gfCBBRERFRCk7CgljbGVhcl9jb21taXRfbWFya3MoKHN0cnVjdCBjb21taXQgKilvMiwKCQkJU0VFTiB8IFVOSU5URVJFU1RJTkcgfCBTSE9XTiB8IEFEREVEKTsKCW8xLT5mbGFncyA9IGZsYWdzMTsKCW8yLT5mbGFncyA9IGZsYWdzMjsKfQoKc3RhdGljIHZvaWQgZ2VuX21lc3NhZ2VfaWQoc3RydWN0IHJldl9pbmZvICppbmZvLCBjaGFyICpiYXNlKQp7Cgljb25zdCBjaGFyICpjb21taXR0ZXIgPSBnaXRfY29tbWl0dGVyX2luZm8oSURFTlRfV0FSTl9PTl9OT19OQU1FKTsKCWNvbnN0IGNoYXIgKmVtYWlsX3N0YXJ0ID0gc3RycmNocihjb21taXR0ZXIsICc8Jyk7Cgljb25zdCBjaGFyICplbWFpbF9lbmQgPSBzdHJyY2hyKGNvbW1pdHRlciwgJz4nKTsKCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7CglpZiAoIWVtYWlsX3N0YXJ0IHx8ICFlbWFpbF9lbmQgfHwgZW1haWxfc3RhcnQgPiBlbWFpbF9lbmQgLSAxKQoJCWRpZSgiQ291bGQgbm90IGV4dHJhY3QgZW1haWwgZnJvbSBjb21taXR0ZXIgaWRlbnRpdHkuIik7CglzdHJidWZfYWRkZigmYnVmLCAiJXMuJWx1LmdpdC4lLipzIiwgYmFzZSwKCQkgICAgKHVuc2lnbmVkIGxvbmcpIHRpbWUoTlVMTCksCgkJICAgIChpbnQpKGVtYWlsX2VuZCAtIGVtYWlsX3N0YXJ0IC0gMSksIGVtYWlsX3N0YXJ0ICsgMSk7CglpbmZvLT5tZXNzYWdlX2lkID0gc3RyYnVmX2RldGFjaCgmYnVmLCBOVUxMKTsKfQoKc3RhdGljIHZvaWQgbWFrZV9jb3Zlcl9sZXR0ZXIoc3RydWN0IHJldl9pbmZvICpyZXYsIGludCB1c2Vfc3Rkb3V0LAoJCQkgICAgICBpbnQgbnVtYmVyZWQsIGludCBudW1iZXJlZF9maWxlcywKCQkJICAgICAgc3RydWN0IGNvbW1pdCAqb3JpZ2luLAoJCQkgICAgICBpbnQgbnIsIHN0cnVjdCBjb21taXQgKipsaXN0LCBzdHJ1Y3QgY29tbWl0ICpoZWFkKQp7Cgljb25zdCBjaGFyICpjb21taXR0ZXI7Cgljb25zdCBjaGFyICpzdWJqZWN0X3N0YXJ0ID0gTlVMTDsKCWNvbnN0IGNoYXIgKmJvZHkgPSAiKioqIFNVQkpFQ1QgSEVSRSAqKipcblxuKioqIEJMVVJCIEhFUkUgKioqXG4iOwoJY29uc3QgY2hhciAqbXNnOwoJY29uc3QgY2hhciAqZXh0cmFfaGVhZGVycyA9IHJldi0+ZXh0cmFfaGVhZGVyczsKCXN0cnVjdCBzaG9ydGxvZyBsb2c7CglzdHJ1Y3Qgc3RyYnVmIHNiID0gU1RSQlVGX0lOSVQ7CglpbnQgaTsKCWNvbnN0IGNoYXIgKmVuY29kaW5nID0gIlVURi04IjsKCXN0cnVjdCBkaWZmX29wdGlvbnMgb3B0czsKCWludCBuZWVkXzhiaXRfY3RlID0gMDsKCXN0cnVjdCBjb21taXQgKmNvbW1pdCA9IE5VTEw7CgoJaWYgKHJldi0+Y29tbWl0X2Zvcm1hdCAhPSBDTUlUX0ZNVF9FTUFJTCkKCQlkaWUoIkNvdmVyIGxldHRlciBuZWVkcyBlbWFpbCBmb3JtYXQiKTsKCgljb21taXR0ZXIgPSBnaXRfY29tbWl0dGVyX2luZm8oMCk7CgoJaWYgKCFudW1iZXJlZF9maWxlcykgewoJCS8qCgkJICogV2UgZmFrZSBhIGNvbW1pdCBmb3IgdGhlIGNvdmVyIGxldHRlciBzbyB3ZSBnZXQgdGhlIGZpbGVuYW1lCgkJICogZGVzaXJlZC4KCQkgKi8KCQljb21taXQgPSB4Y2FsbG9jKDEsIHNpemVvZigqY29tbWl0KSk7CgkJY29tbWl0LT5idWZmZXIgPSB4bWFsbG9jKDQwMCk7CgkJc25wcmludGYoY29tbWl0LT5idWZmZXIsIDQwMCwKCQkJInRyZWUgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFxuIgoJCQkicGFyZW50ICVzXG4iCgkJCSJhdXRob3IgJXNcbiIKCQkJImNvbW1pdHRlciAlc1xuXG4iCgkJCSJjb3ZlciBsZXR0ZXJcbiIsCgkJCXNoYTFfdG9faGV4KGhlYWQtPm9iamVjdC5zaGExKSwgY29tbWl0dGVyLCBjb21taXR0ZXIpOwoJfQoKCWlmICghdXNlX3N0ZG91dCAmJiByZW9wZW5fc3Rkb3V0KGNvbW1pdCwgcmV2KSkKCQlyZXR1cm47CgoJaWYgKGNvbW1pdCkgewoKCQlmcmVlKGNvbW1pdC0+YnVmZmVyKTsKCQlmcmVlKGNvbW1pdCk7Cgl9CgoJbG9nX3dyaXRlX2VtYWlsX2hlYWRlcnMocmV2LCBoZWFkLCAmc3ViamVjdF9zdGFydCwgJmV4dHJhX2hlYWRlcnMsCgkJCQkmbmVlZF84Yml0X2N0ZSk7CgoJZm9yIChpID0gMDsgIW5lZWRfOGJpdF9jdGUgJiYgaSA8IG5yOyBpKyspCgkJaWYgKGhhc19ub25fYXNjaWkobGlzdFtpXS0+YnVmZmVyKSkKCQkJbmVlZF84Yml0X2N0ZSA9IDE7CgoJbXNnID0gYm9keTsKCXBwX3VzZXJfaW5mbyhOVUxMLCBDTUlUX0ZNVF9FTUFJTCwgJnNiLCBjb21taXR0ZXIsIERBVEVfUkZDMjgyMiwKCQkgICAgIGVuY29kaW5nKTsKCXBwX3RpdGxlX2xpbmUoQ01JVF9GTVRfRU1BSUwsICZtc2csICZzYiwgc3ViamVjdF9zdGFydCwgZXh0cmFfaGVhZGVycywKCQkgICAgICBlbmNvZGluZywgbmVlZF84Yml0X2N0ZSk7CglwcF9yZW1haW5kZXIoQ01JVF9GTVRfRU1BSUwsICZtc2csICZzYiwgMCk7CglwcmludGYoIiVzXG4iLCBzYi5idWYpOwoKCXN0cmJ1Zl9yZWxlYXNlKCZzYik7CgoJc2hvcnRsb2dfaW5pdCgmbG9nKTsKCWxvZy53cmFwX2xpbmVzID0gMTsKCWxvZy53cmFwID0gNzI7Cglsb2cuaW4xID0gMjsKCWxvZy5pbjIgPSA0OwoJZm9yIChpID0gMDsgaSA8IG5yOyBpKyspCgkJc2hvcnRsb2dfYWRkX2NvbW1pdCgmbG9nLCBsaXN0W2ldKTsKCglzaG9ydGxvZ19vdXRwdXQoJmxvZyk7CgoJLyoKCSAqIFdlIGNhbiBvbmx5IGRvIGRpZmZzdGF0IHdpdGggYSB1bmlxdWUgcmVmZXJlbmNlIHBvaW50CgkgKi8KCWlmICghb3JpZ2luKQoJCXJldHVybjsKCgltZW1jcHkoJm9wdHMsICZyZXYtPmRpZmZvcHQsIHNpemVvZihvcHRzKSk7CglvcHRzLm91dHB1dF9mb3JtYXQgPSBESUZGX0ZPUk1BVF9TVU1NQVJZIHwgRElGRl9GT1JNQVRfRElGRlNUQVQ7CgoJZGlmZl9zZXR1cF9kb25lKCZvcHRzKTsKCglkaWZmX3RyZWVfc2hhMShvcmlnaW4tPnRyZWUtPm9iamVjdC5zaGExLAoJCSAgICAgICBoZWFkLT50cmVlLT5vYmplY3Quc2hhMSwKCQkgICAgICAgIiIsICZvcHRzKTsKCWRpZmZjb3JlX3N0ZCgmb3B0cyk7CglkaWZmX2ZsdXNoKCZvcHRzKTsKCglwcmludGYoIlxuIik7Cn0KCnN0YXRpYyBjb25zdCBjaGFyICpjbGVhbl9tZXNzYWdlX2lkKGNvbnN0IGNoYXIgKm1zZ19pZCkKewoJY2hhciBjaDsKCWNvbnN0IGNoYXIgKmEsICp6LCAqbTsKCgltID0gbXNnX2lkOwoJd2hpbGUgKChjaCA9ICptKSAmJiAoaXNzcGFjZShjaCkgfHwgKGNoID09ICc8JykpKQoJCW0rKzsKCWEgPSBtOwoJeiA9IE5VTEw7Cgl3aGlsZSAoKGNoID0gKm0pKSB7CgkJaWYgKCFpc3NwYWNlKGNoKSAmJiAoY2ggIT0gJz4nKSkKCQkJeiA9IG07CgkJbSsrOwoJfQoJaWYgKCF6KQoJCWRpZSgiaW5zYW5lIGluLXJlcGx5LXRvOiAlcyIsIG1zZ19pZCk7CglpZiAoKyt6ID09IG0pCgkJcmV0dXJuIGE7CglyZXR1cm4geG1lbWR1cHooYSwgeiAtIGEpOwp9CgpzdGF0aWMgY29uc3QgY2hhciAqc2V0X291dGRpcihjb25zdCBjaGFyICpwcmVmaXgsIGNvbnN0IGNoYXIgKm91dHB1dF9kaXJlY3RvcnkpCnsKCWlmIChvdXRwdXRfZGlyZWN0b3J5ICYmIGlzX2Fic29sdXRlX3BhdGgob3V0cHV0X2RpcmVjdG9yeSkpCgkJcmV0dXJuIG91dHB1dF9kaXJlY3Rvcnk7CgoJaWYgKCFwcmVmaXggfHwgISpwcmVmaXgpIHsKCQlpZiAob3V0cHV0X2RpcmVjdG9yeSkKCQkJcmV0dXJuIG91dHB1dF9kaXJlY3Rvcnk7CgkJLyogVGhlIHVzZXIgZGlkIG5vdCBleHBsaWNpdGx5IGFzayBmb3IgIi4vIiAqLwoJCW91dGRpcl9vZmZzZXQgPSAyOwoJCXJldHVybiAiLi8iOwoJfQoKCW91dGRpcl9vZmZzZXQgPSBzdHJsZW4ocHJlZml4KTsKCWlmICghb3V0cHV0X2RpcmVjdG9yeSkKCQlyZXR1cm4gcHJlZml4OwoKCXJldHVybiB4c3RyZHVwKHByZWZpeF9maWxlbmFtZShwcmVmaXgsIG91dGRpcl9vZmZzZXQsCgkJCQkgICAgICAgb3V0cHV0X2RpcmVjdG9yeSkpOwp9CgpzdGF0aWMgY29uc3QgY2hhciAqIGNvbnN0IGJ1aWx0aW5fZm9ybWF0X3BhdGNoX3VzYWdlW10gPSB7CgkiZ2l0IGZvcm1hdC1wYXRjaCBbb3B0aW9uc10gWzxzaW5jZT4gfCA8cmV2aXNpb24gcmFuZ2U+XSIsCglOVUxMCn07CgpzdGF0aWMgaW50IGtlZXBfc3ViamVjdCA9IDA7CgpzdGF0aWMgaW50IGtlZXBfY2FsbGJhY2soY29uc3Qgc3RydWN0IG9wdGlvbiAqb3B0LCBjb25zdCBjaGFyICphcmcsIGludCB1bnNldCkKewoJKChzdHJ1Y3QgcmV2X2luZm8gKilvcHQtPnZhbHVlKS0+dG90YWwgPSAtMTsKCWtlZXBfc3ViamVjdCA9IDE7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBzdWJqZWN0X3ByZWZpeCA9IDA7CgpzdGF0aWMgaW50IHN1YmplY3RfcHJlZml4X2NhbGxiYWNrKGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdCwgY29uc3QgY2hhciAqYXJnLAoJCQkgICAgaW50IHVuc2V0KQp7CglzdWJqZWN0X3ByZWZpeCA9IDE7CgkoKHN0cnVjdCByZXZfaW5mbyAqKW9wdC0+dmFsdWUpLT5zdWJqZWN0X3ByZWZpeCA9IGFyZzsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IG51bWJlcmVkX2NtZGxpbmVfb3B0ID0gMDsKCnN0YXRpYyBpbnQgbnVtYmVyZWRfY2FsbGJhY2soY29uc3Qgc3RydWN0IG9wdGlvbiAqb3B0LCBjb25zdCBjaGFyICphcmcsCgkJCSAgICAgaW50IHVuc2V0KQp7CgkqKGludCAqKW9wdC0+dmFsdWUgPSBudW1iZXJlZF9jbWRsaW5lX29wdCA9IHVuc2V0ID8gMCA6IDE7CglpZiAodW5zZXQpCgkJYXV0b19udW1iZXIgPSAgMDsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IG5vX251bWJlcmVkX2NhbGxiYWNrKGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdCwgY29uc3QgY2hhciAqYXJnLAoJCQkJaW50IHVuc2V0KQp7CglyZXR1cm4gbnVtYmVyZWRfY2FsbGJhY2sob3B0LCBhcmcsIDEpOwp9CgpzdGF0aWMgaW50IG91dHB1dF9kaXJlY3RvcnlfY2FsbGJhY2soY29uc3Qgc3RydWN0IG9wdGlvbiAqb3B0LCBjb25zdCBjaGFyICphcmcsCgkJCSAgICAgIGludCB1bnNldCkKewoJY29uc3QgY2hhciAqKmRpciA9IChjb25zdCBjaGFyICoqKW9wdC0+dmFsdWU7CglpZiAoKmRpcikKCQlkaWUoIlR3byBvdXRwdXQgZGlyZWN0b3JpZXM/Iik7CgkqZGlyID0gYXJnOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgdGhyZWFkX2NhbGxiYWNrKGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdCwgY29uc3QgY2hhciAqYXJnLCBpbnQgdW5zZXQpCnsKCWludCAqdGhyZWFkID0gKGludCAqKW9wdC0+dmFsdWU7CglpZiAodW5zZXQpCgkJKnRocmVhZCA9IDA7CgllbHNlIGlmICghYXJnIHx8ICFzdHJjbXAoYXJnLCAic2hhbGxvdyIpKQoJCSp0aHJlYWQgPSBUSFJFQURfU0hBTExPVzsKCWVsc2UgaWYgKCFzdHJjbXAoYXJnLCAiZGVlcCIpKQoJCSp0aHJlYWQgPSBUSFJFQURfREVFUDsKCWVsc2UKCQlyZXR1cm4gMTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGF0dGFjaF9jYWxsYmFjayhjb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHQsIGNvbnN0IGNoYXIgKmFyZywgaW50IHVuc2V0KQp7CglzdHJ1Y3QgcmV2X2luZm8gKnJldiA9IChzdHJ1Y3QgcmV2X2luZm8gKilvcHQtPnZhbHVlOwoJaWYgKHVuc2V0KQoJCXJldi0+bWltZV9ib3VuZGFyeSA9IE5VTEw7CgllbHNlIGlmIChhcmcpCgkJcmV2LT5taW1lX2JvdW5kYXJ5ID0gYXJnOwoJZWxzZQoJCXJldi0+bWltZV9ib3VuZGFyeSA9IGdpdF92ZXJzaW9uX3N0cmluZzsKCXJldi0+bm9faW5saW5lID0gdW5zZXQgPyAwIDogMTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGlubGluZV9jYWxsYmFjayhjb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHQsIGNvbnN0IGNoYXIgKmFyZywgaW50IHVuc2V0KQp7CglzdHJ1Y3QgcmV2X2luZm8gKnJldiA9IChzdHJ1Y3QgcmV2X2luZm8gKilvcHQtPnZhbHVlOwoJaWYgKHVuc2V0KQoJCXJldi0+bWltZV9ib3VuZGFyeSA9IE5VTEw7CgllbHNlIGlmIChhcmcpCgkJcmV2LT5taW1lX2JvdW5kYXJ5ID0gYXJnOwoJZWxzZQoJCXJldi0+bWltZV9ib3VuZGFyeSA9IGdpdF92ZXJzaW9uX3N0cmluZzsKCXJldi0+bm9faW5saW5lID0gMDsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGhlYWRlcl9jYWxsYmFjayhjb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHQsIGNvbnN0IGNoYXIgKmFyZywgaW50IHVuc2V0KQp7CglpZiAodW5zZXQpIHsKCQlzdHJpbmdfbGlzdF9jbGVhcigmZXh0cmFfaGRyLCAwKTsKCQlzdHJpbmdfbGlzdF9jbGVhcigmZXh0cmFfdG8sIDApOwoJCXN0cmluZ19saXN0X2NsZWFyKCZleHRyYV9jYywgMCk7Cgl9IGVsc2UgewoJICAgIGFkZF9oZWFkZXIoYXJnKTsKCX0KCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IHRvX2NhbGxiYWNrKGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdCwgY29uc3QgY2hhciAqYXJnLCBpbnQgdW5zZXQpCnsKCWlmICh1bnNldCkKCQlzdHJpbmdfbGlzdF9jbGVhcigmZXh0cmFfdG8sIDApOwoJZWxzZQoJCXN0cmluZ19saXN0X2FwcGVuZChhcmcsICZleHRyYV90byk7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBjY19jYWxsYmFjayhjb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHQsIGNvbnN0IGNoYXIgKmFyZywgaW50IHVuc2V0KQp7CglpZiAodW5zZXQpCgkJc3RyaW5nX2xpc3RfY2xlYXIoJmV4dHJhX2NjLCAwKTsKCWVsc2UKCQlzdHJpbmdfbGlzdF9hcHBlbmQoYXJnLCAmZXh0cmFfY2MpOwoJcmV0dXJuIDA7Cn0KCmludCBjbWRfZm9ybWF0X3BhdGNoKGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndiwgY29uc3QgY2hhciAqcHJlZml4KQp7CglzdHJ1Y3QgY29tbWl0ICpjb21taXQ7CglzdHJ1Y3QgY29tbWl0ICoqbGlzdCA9IE5VTEw7CglzdHJ1Y3QgcmV2X2luZm8gcmV2OwoJc3RydWN0IHNldHVwX3JldmlzaW9uX29wdCBzX3Jfb3B0OwoJaW50IG5yID0gMCwgdG90YWwsIGk7CglpbnQgdXNlX3N0ZG91dCA9IDA7CglpbnQgc3RhcnRfbnVtYmVyID0gLTE7CglpbnQgbnVtYmVyZWRfZmlsZXMgPSAwOwkJLyogX2p1c3RfIG51bWJlcnMgKi8KCWludCBpZ25vcmVfaWZfaW5fdXBzdHJlYW0gPSAwOwoJaW50IGNvdmVyX2xldHRlciA9IDA7CglpbnQgYm91bmRhcnlfY291bnQgPSAwOwoJaW50IG5vX2JpbmFyeV9kaWZmID0gMDsKCXN0cnVjdCBjb21taXQgKm9yaWdpbiA9IE5VTEwsICpoZWFkID0gTlVMTDsKCWNvbnN0IGNoYXIgKmluX3JlcGx5X3RvID0gTlVMTDsKCXN0cnVjdCBwYXRjaF9pZHMgaWRzOwoJY2hhciAqYWRkX3NpZ25vZmYgPSBOVUxMOwoJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCWludCB1c2VfcGF0Y2hfZm9ybWF0ID0gMDsKCWNvbnN0IHN0cnVjdCBvcHRpb24gYnVpbHRpbl9mb3JtYXRfcGF0Y2hfb3B0aW9uc1tdID0gewoJCXsgT1BUSU9OX0NBTExCQUNLLCAnbicsICJudW1iZXJlZCIsICZudW1iZXJlZCwgTlVMTCwKCQkJICAgICJ1c2UgW1BBVENIIG4vbV0gZXZlbiB3aXRoIGEgc2luZ2xlIHBhdGNoIiwKCQkJICAgIFBBUlNFX09QVF9OT0FSRywgbnVtYmVyZWRfY2FsbGJhY2sgfSwKCQl7IE9QVElPTl9DQUxMQkFDSywgJ04nLCAibm8tbnVtYmVyZWQiLCAmbnVtYmVyZWQsIE5VTEwsCgkJCSAgICAidXNlIFtQQVRDSF0gZXZlbiB3aXRoIG11bHRpcGxlIHBhdGNoZXMiLAoJCQkgICAgUEFSU0VfT1BUX05PQVJHLCBub19udW1iZXJlZF9jYWxsYmFjayB9LAoJCU9QVF9CT09MRUFOKCdzJywgInNpZ25vZmYiLCAmZG9fc2lnbm9mZiwgImFkZCBTaWduZWQtb2ZmLWJ5OiIpLAoJCU9QVF9CT09MRUFOKDAsICJzdGRvdXQiLCAmdXNlX3N0ZG91dCwKCQkJICAgICJwcmludCBwYXRjaGVzIHRvIHN0YW5kYXJkIG91dCIpLAoJCU9QVF9CT09MRUFOKDAsICJjb3Zlci1sZXR0ZXIiLCAmY292ZXJfbGV0dGVyLAoJCQkgICAgImdlbmVyYXRlIGEgY292ZXIgbGV0dGVyIiksCgkJT1BUX0JPT0xFQU4oMCwgIm51bWJlcmVkLWZpbGVzIiwgJm51bWJlcmVkX2ZpbGVzLAoJCQkgICAgInVzZSBzaW1wbGUgbnVtYmVyIHNlcXVlbmNlIGZvciBvdXRwdXQgZmlsZSBuYW1lcyIpLAoJCU9QVF9TVFJJTkcoMCwgInN1ZmZpeCIsICZmbXRfcGF0Y2hfc3VmZml4LCAic2Z4IiwKCQkJICAgICJ1c2UgPHNmeD4gaW5zdGVhZCBvZiAnLnBhdGNoJyIpLAoJCU9QVF9JTlRFR0VSKDAsICJzdGFydC1udW1iZXIiLCAmc3RhcnRfbnVtYmVyLAoJCQkgICAgInN0YXJ0IG51bWJlcmluZyBwYXRjaGVzIGF0IDxuPiBpbnN0ZWFkIG9mIDEiKSwKCQl7IE9QVElPTl9DQUxMQkFDSywgMCwgInN1YmplY3QtcHJlZml4IiwgJnJldiwgInByZWZpeCIsCgkJCSAgICAiVXNlIFs8cHJlZml4Pl0gaW5zdGVhZCBvZiBbUEFUQ0hdIiwKCQkJICAgIFBBUlNFX09QVF9OT05FRywgc3ViamVjdF9wcmVmaXhfY2FsbGJhY2sgfSwKCQl7IE9QVElPTl9DQUxMQkFDSywgJ28nLCAib3V0cHV0LWRpcmVjdG9yeSIsICZvdXRwdXRfZGlyZWN0b3J5LAoJCQkgICAgImRpciIsICJzdG9yZSByZXN1bHRpbmcgZmlsZXMgaW4gPGRpcj4iLAoJCQkgICAgUEFSU0VfT1BUX05PTkVHLCBvdXRwdXRfZGlyZWN0b3J5X2NhbGxiYWNrIH0sCgkJeyBPUFRJT05fQ0FMTEJBQ0ssICdrJywgImtlZXAtc3ViamVjdCIsICZyZXYsIE5VTEwsCgkJCSAgICAiZG9uJ3Qgc3RyaXAvYWRkIFtQQVRDSF0iLAoJCQkgICAgUEFSU0VfT1BUX05PQVJHIHwgUEFSU0VfT1BUX05PTkVHLCBrZWVwX2NhbGxiYWNrIH0sCgkJT1BUX0JPT0xFQU4oMCwgIm5vLWJpbmFyeSIsICZub19iaW5hcnlfZGlmZiwKCQkJICAgICJkb24ndCBvdXRwdXQgYmluYXJ5IGRpZmZzIiksCgkJT1BUX0JPT0xFQU4oMCwgImlnbm9yZS1pZi1pbi11cHN0cmVhbSIsICZpZ25vcmVfaWZfaW5fdXBzdHJlYW0sCgkJCSAgICAiZG9uJ3QgaW5jbHVkZSBhIHBhdGNoIG1hdGNoaW5nIGEgY29tbWl0IHVwc3RyZWFtIiksCgkJeyBPUFRJT05fQk9PTEVBTiwgJ3AnLCAibm8tc3RhdCIsICZ1c2VfcGF0Y2hfZm9ybWF0LCBOVUxMLAoJCSAgInNob3cgcGF0Y2ggZm9ybWF0IGluc3RlYWQgb2YgZGVmYXVsdCAocGF0Y2ggKyBzdGF0KSIsCgkJICBQQVJTRV9PUFRfTk9ORUcgfCBQQVJTRV9PUFRfTk9BUkcgfSwKCQlPUFRfR1JPVVAoIk1lc3NhZ2luZyIpLAoJCXsgT1BUSU9OX0NBTExCQUNLLCAwLCAiYWRkLWhlYWRlciIsIE5VTEwsICJoZWFkZXIiLAoJCQkgICAgImFkZCBlbWFpbCBoZWFkZXIiLCAwLCBoZWFkZXJfY2FsbGJhY2sgfSwKCQl7IE9QVElPTl9DQUxMQkFDSywgMCwgInRvIiwgTlVMTCwgImVtYWlsIiwgImFkZCBUbzogaGVhZGVyIiwKCQkJICAgIDAsIHRvX2NhbGxiYWNrIH0sCgkJeyBPUFRJT05fQ0FMTEJBQ0ssIDAsICJjYyIsIE5VTEwsICJlbWFpbCIsICJhZGQgQ2M6IGhlYWRlciIsCgkJCSAgICAwLCBjY19jYWxsYmFjayB9LAoJCU9QVF9TVFJJTkcoMCwgImluLXJlcGx5LXRvIiwgJmluX3JlcGx5X3RvLCAibWVzc2FnZS1pZCIsCgkJCSAgICAibWFrZSBmaXJzdCBtYWlsIGEgcmVwbHkgdG8gPG1lc3NhZ2UtaWQ+IiksCgkJeyBPUFRJT05fQ0FMTEJBQ0ssIDAsICJhdHRhY2giLCAmcmV2LCAiYm91bmRhcnkiLAoJCQkgICAgImF0dGFjaCB0aGUgcGF0Y2giLCBQQVJTRV9PUFRfT1BUQVJHLAoJCQkgICAgYXR0YWNoX2NhbGxiYWNrIH0sCgkJeyBPUFRJT05fQ0FMTEJBQ0ssIDAsICJpbmxpbmUiLCAmcmV2LCAiYm91bmRhcnkiLAoJCQkgICAgImlubGluZSB0aGUgcGF0Y2giLAoJCQkgICAgUEFSU0VfT1BUX09QVEFSRyB8IFBBUlNFX09QVF9OT05FRywKCQkJICAgIGlubGluZV9jYWxsYmFjayB9LAoJCXsgT1BUSU9OX0NBTExCQUNLLCAwLCAidGhyZWFkIiwgJnRocmVhZCwgInN0eWxlIiwKCQkJICAgICJlbmFibGUgbWVzc2FnZSB0aHJlYWRpbmcsIHN0eWxlczogc2hhbGxvdywgZGVlcCIsCgkJCSAgICBQQVJTRV9PUFRfT1BUQVJHLCB0aHJlYWRfY2FsbGJhY2sgfSwKCQlPUFRfRU5EKCkKCX07CgoJZXh0cmFfaGRyLnN0cmR1cF9zdHJpbmdzID0gMTsKCWV4dHJhX3RvLnN0cmR1cF9zdHJpbmdzID0gMTsKCWV4dHJhX2NjLnN0cmR1cF9zdHJpbmdzID0gMTsKCWdpdF9jb25maWcoZ2l0X2Zvcm1hdF9jb25maWcsIE5VTEwpOwoJaW5pdF9yZXZpc2lvbnMoJnJldiwgcHJlZml4KTsKCXJldi5jb21taXRfZm9ybWF0ID0gQ01JVF9GTVRfRU1BSUw7CglyZXYudmVyYm9zZV9oZWFkZXIgPSAxOwoJcmV2LmRpZmYgPSAxOwoJcmV2Lm5vX21lcmdlcyA9IDE7CglESUZGX09QVF9TRVQoJnJldi5kaWZmb3B0LCBSRUNVUlNJVkUpOwoJcmV2LnN1YmplY3RfcHJlZml4ID0gZm10X3BhdGNoX3N1YmplY3RfcHJlZml4OwoJbWVtc2V0KCZzX3Jfb3B0LCAwLCBzaXplb2Yoc19yX29wdCkpOwoJc19yX29wdC5kZWYgPSAiSEVBRCI7CgoJaWYgKGRlZmF1bHRfYXR0YWNoKSB7CgkJcmV2Lm1pbWVfYm91bmRhcnkgPSBkZWZhdWx0X2F0dGFjaDsKCQlyZXYubm9faW5saW5lID0gMTsKCX0KCgkvKgoJICogUGFyc2UgdGhlIGFyZ3VtZW50cyBiZWZvcmUgc2V0dXBfcmV2aXNpb25zKCksIG9yIHNvbWV0aGluZwoJICogbGlrZSAiZ2l0IGZvcm1hdC1wYXRjaCAtbyBhMTIzIEhFQUReLi4iIG1heSBmYWlsOyBhMTIzIGlzCgkgKiBwb3NzaWJseSBhIHZhbGlkIFNIQTEuCgkgKi8KCWFyZ2MgPSBwYXJzZV9vcHRpb25zKGFyZ2MsIGFyZ3YsIHByZWZpeCwgYnVpbHRpbl9mb3JtYXRfcGF0Y2hfb3B0aW9ucywKCQkJICAgICBidWlsdGluX2Zvcm1hdF9wYXRjaF91c2FnZSwKCQkJICAgICBQQVJTRV9PUFRfS0VFUF9BUkdWMCB8IFBBUlNFX09QVF9LRUVQX1VOS05PV04gfAoJCQkgICAgIFBBUlNFX09QVF9LRUVQX0RBU0hEQVNIKTsKCglpZiAoZG9fc2lnbm9mZikgewoJCWNvbnN0IGNoYXIgKmNvbW1pdHRlcjsKCQljb25zdCBjaGFyICplbmRwb3M7CgkJY29tbWl0dGVyID0gZ2l0X2NvbW1pdHRlcl9pbmZvKElERU5UX0VSUk9SX09OX05PX05BTUUpOwoJCWVuZHBvcyA9IHN0cmNocihjb21taXR0ZXIsICc+Jyk7CgkJaWYgKCFlbmRwb3MpCgkJCWRpZSgiYm9ndXMgY29tbWl0dGVyIGluZm8gJXMiLCBjb21taXR0ZXIpOwoJCWFkZF9zaWdub2ZmID0geG1lbWR1cHooY29tbWl0dGVyLCBlbmRwb3MgLSBjb21taXR0ZXIgKyAxKTsKCX0KCglmb3IgKGkgPSAwOyBpIDwgZXh0cmFfaGRyLm5yOyBpKyspIHsKCQlzdHJidWZfYWRkc3RyKCZidWYsIGV4dHJhX2hkci5pdGVtc1tpXS5zdHJpbmcpOwoJCXN0cmJ1Zl9hZGRjaCgmYnVmLCAnXG4nKTsKCX0KCglpZiAoZXh0cmFfdG8ubnIpCgkJc3RyYnVmX2FkZHN0cigmYnVmLCAiVG86ICIpOwoJZm9yIChpID0gMDsgaSA8IGV4dHJhX3RvLm5yOyBpKyspIHsKCQlpZiAoaSkKCQkJc3RyYnVmX2FkZHN0cigmYnVmLCAiICAgICIpOwoJCXN0cmJ1Zl9hZGRzdHIoJmJ1ZiwgZXh0cmFfdG8uaXRlbXNbaV0uc3RyaW5nKTsKCQlpZiAoaSArIDEgPCBleHRyYV90by5ucikKCQkJc3RyYnVmX2FkZGNoKCZidWYsICcsJyk7CgkJc3RyYnVmX2FkZGNoKCZidWYsICdcbicpOwoJfQoKCWlmIChleHRyYV9jYy5ucikKCQlzdHJidWZfYWRkc3RyKCZidWYsICJDYzogIik7Cglmb3IgKGkgPSAwOyBpIDwgZXh0cmFfY2MubnI7IGkrKykgewoJCWlmIChpKQoJCQlzdHJidWZfYWRkc3RyKCZidWYsICIgICAgIik7CgkJc3RyYnVmX2FkZHN0cigmYnVmLCBleHRyYV9jYy5pdGVtc1tpXS5zdHJpbmcpOwoJCWlmIChpICsgMSA8IGV4dHJhX2NjLm5yKQoJCQlzdHJidWZfYWRkY2goJmJ1ZiwgJywnKTsKCQlzdHJidWZfYWRkY2goJmJ1ZiwgJ1xuJyk7Cgl9CgoJcmV2LmV4dHJhX2hlYWRlcnMgPSBzdHJidWZfZGV0YWNoKCZidWYsIE5VTEwpOwoKCWlmIChzdGFydF9udW1iZXIgPCAwKQoJCXN0YXJ0X251bWJlciA9IDE7CgoJLyoKCSAqIElmIG51bWJlcmVkIGlzIHNldCBzb2xlbHkgZHVlIHRvIGZvcm1hdC5udW1iZXJlZCBpbiBjb25maWcsCgkgKiBhbmQgaXQgd291bGQgY29uZmxpY3Qgd2l0aCAtLWtlZXAtc3ViamVjdCAoLWspIGZyb20gdGhlCgkgKiBjb21tYW5kIGxpbmUsIHJlc2V0ICJudW1iZXJlZCIuCgkgKi8KCWlmIChudW1iZXJlZCAmJiBrZWVwX3N1YmplY3QgJiYgIW51bWJlcmVkX2NtZGxpbmVfb3B0KQoJCW51bWJlcmVkID0gMDsKCglpZiAobnVtYmVyZWQgJiYga2VlcF9zdWJqZWN0KQoJCWRpZSAoIi1uIGFuZCAtayBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlLiIpOwoJaWYgKGtlZXBfc3ViamVjdCAmJiBzdWJqZWN0X3ByZWZpeCkKCQlkaWUgKCItLXN1YmplY3QtcHJlZml4IGFuZCAtayBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlLiIpOwoKCWFyZ2MgPSBzZXR1cF9yZXZpc2lvbnMoYXJnYywgYXJndiwgJnJldiwgJnNfcl9vcHQpOwoJaWYgKGFyZ2MgPiAxKQoJCWRpZSAoInVucmVjb2duaXplZCBhcmd1bWVudDogJXMiLCBhcmd2WzFdKTsKCglpZiAocmV2LmRpZmZvcHQub3V0cHV0X2Zvcm1hdCAmIERJRkZfRk9STUFUX05BTUUpCgkJZGllKCItLW5hbWUtb25seSBkb2VzIG5vdCBtYWtlIHNlbnNlIik7CglpZiAocmV2LmRpZmZvcHQub3V0cHV0X2Zvcm1hdCAmIERJRkZfRk9STUFUX05BTUVfU1RBVFVTKQoJCWRpZSgiLS1uYW1lLXN0YXR1cyBkb2VzIG5vdCBtYWtlIHNlbnNlIik7CglpZiAocmV2LmRpZmZvcHQub3V0cHV0X2Zvcm1hdCAmIERJRkZfRk9STUFUX0NIRUNLRElGRikKCQlkaWUoIi0tY2hlY2sgZG9lcyBub3QgbWFrZSBzZW5zZSIpOwoKCWlmICghdXNlX3BhdGNoX2Zvcm1hdCAmJgoJCSghcmV2LmRpZmZvcHQub3V0cHV0X2Zvcm1hdCB8fAoJCSByZXYuZGlmZm9wdC5vdXRwdXRfZm9ybWF0ID09IERJRkZfRk9STUFUX1BBVENIKSkKCQlyZXYuZGlmZm9wdC5vdXRwdXRfZm9ybWF0ID0gRElGRl9GT1JNQVRfRElGRlNUQVQgfCBESUZGX0ZPUk1BVF9TVU1NQVJZOwoKCS8qIEFsd2F5cyBnZW5lcmF0ZSBhIHBhdGNoICovCglyZXYuZGlmZm9wdC5vdXRwdXRfZm9ybWF0IHw9IERJRkZfRk9STUFUX1BBVENIOwoKCWlmICghRElGRl9PUFRfVFNUKCZyZXYuZGlmZm9wdCwgVEVYVCkgJiYgIW5vX2JpbmFyeV9kaWZmKQoJCURJRkZfT1BUX1NFVCgmcmV2LmRpZmZvcHQsIEJJTkFSWSk7CgoJaWYgKHJldi5zaG93X25vdGVzKQoJCWluaXRfZGlzcGxheV9ub3RlcygmcmV2Lm5vdGVzX29wdCk7CgoJaWYgKCF1c2Vfc3Rkb3V0KQoJCW91dHB1dF9kaXJlY3RvcnkgPSBzZXRfb3V0ZGlyKHByZWZpeCwgb3V0cHV0X2RpcmVjdG9yeSk7CgoJaWYgKG91dHB1dF9kaXJlY3RvcnkpIHsKCQlpZiAodXNlX3N0ZG91dCkKCQkJZGllKCJzdGFuZGFyZCBvdXRwdXQsIG9yIGRpcmVjdG9yeSwgd2hpY2ggb25lPyIpOwoJCWlmIChta2RpcihvdXRwdXRfZGlyZWN0b3J5LCAwNzc3KSA8IDAgJiYgZXJybm8gIT0gRUVYSVNUKQoJCQlkaWVfZXJybm8oIkNvdWxkIG5vdCBjcmVhdGUgZGlyZWN0b3J5ICclcyciLAoJCQkJICBvdXRwdXRfZGlyZWN0b3J5KTsKCX0KCglpZiAocmV2LnBlbmRpbmcubnIgPT0gMSkgewoJCWlmIChyZXYubWF4X2NvdW50IDwgMCAmJiAhcmV2LnNob3dfcm9vdF9kaWZmKSB7CgkJCS8qCgkJCSAqIFRoaXMgaXMgdHJhZGl0aW9uYWwgYmVoYXZpb3VyIG9mICJnaXQgZm9ybWF0LXBhdGNoCgkJCSAqIG9yaWdpbiIgdGhhdCBwcmVwYXJlcyB3aGF0IHRoZSBvcmlnaW4gc2lkZSBzdGlsbAoJCQkgKiBkb2VzIG5vdCBoYXZlLgoJCQkgKi8KCQkJcmV2LnBlbmRpbmcub2JqZWN0c1swXS5pdGVtLT5mbGFncyB8PSBVTklOVEVSRVNUSU5HOwoJCQlhZGRfaGVhZF90b19wZW5kaW5nKCZyZXYpOwoJCX0KCQkvKgoJCSAqIE90aGVyd2lzZSwgaXQgaXMgImZvcm1hdC1wYXRjaCAtMjIgSEVBRCIsIGFuZC9vcgoJCSAqICJmb3JtYXQtcGF0Y2ggLS1yb290IEhFQUQiLiAgVGhlIHVzZXIgd2FudHMKCQkgKiBnZXRfcmV2aXNpb24oKSB0byBkbyB0aGUgdXN1YWwgdHJhdmVyc2FsLgoJCSAqLwoJfQoKCS8qCgkgKiBXZSBjYW5ub3QgbW92ZSB0aGlzIGFueXdoZXJlIGVhcmxpZXIgYmVjYXVzZSB3ZSBkbyB3YW50IHRvCgkgKiBrbm93IGlmIC0tcm9vdCB3YXMgZ2l2ZW4gZXhwbGljaXRseSBmcm9tIHRoZSBjb21tYW5kIGxpbmUuCgkgKi8KCXJldi5zaG93X3Jvb3RfZGlmZiA9IDE7CgoJaWYgKGNvdmVyX2xldHRlcikgewoJCS8qIHJlbWVtYmVyIHRoZSByYW5nZSAqLwoJCWludCBpOwoJCWZvciAoaSA9IDA7IGkgPCByZXYucGVuZGluZy5ucjsgaSsrKSB7CgkJCXN0cnVjdCBvYmplY3QgKm8gPSByZXYucGVuZGluZy5vYmplY3RzW2ldLml0ZW07CgkJCWlmICghKG8tPmZsYWdzICYgVU5JTlRFUkVTVElORykpCgkJCQloZWFkID0gKHN0cnVjdCBjb21taXQgKilvOwoJCX0KCQkvKiBXZSBjYW4ndCBnZW5lcmF0ZSBhIGNvdmVyIGxldHRlciB3aXRob3V0IGFueSBwYXRjaGVzICovCgkJaWYgKCFoZWFkKQoJCQlyZXR1cm4gMDsKCX0KCglpZiAoaWdub3JlX2lmX2luX3Vwc3RyZWFtKSB7CgkJLyogRG9uJ3Qgc2F5IGFueXRoaW5nIGlmIGhlYWQgYW5kIHVwc3RyZWFtIGFyZSB0aGUgc2FtZS4gKi8KCQlpZiAocmV2LnBlbmRpbmcubnIgPT0gMikgewoJCQlzdHJ1Y3Qgb2JqZWN0X2FycmF5X2VudHJ5ICpvID0gcmV2LnBlbmRpbmcub2JqZWN0czsKCQkJaWYgKGhhc2hjbXAob1swXS5pdGVtLT5zaGExLCBvWzFdLml0ZW0tPnNoYTEpID09IDApCgkJCQlyZXR1cm4gMDsKCQl9CgkJZ2V0X3BhdGNoX2lkcygmcmV2LCAmaWRzLCBwcmVmaXgpOwoJfQoKCWlmICghdXNlX3N0ZG91dCkKCQlyZWFsc3Rkb3V0ID0geGZkb3Blbih4ZHVwKDEpLCAidyIpOwoKCWlmIChwcmVwYXJlX3JldmlzaW9uX3dhbGsoJnJldikpCgkJZGllKCJyZXZpc2lvbiB3YWxrIHNldHVwIGZhaWxlZCIpOwoJcmV2LmJvdW5kYXJ5ID0gMTsKCXdoaWxlICgoY29tbWl0ID0gZ2V0X3JldmlzaW9uKCZyZXYpKSAhPSBOVUxMKSB7CgkJaWYgKGNvbW1pdC0+b2JqZWN0LmZsYWdzICYgQk9VTkRBUlkpIHsKCQkJYm91bmRhcnlfY291bnQrKzsKCQkJb3JpZ2luID0gKGJvdW5kYXJ5X2NvdW50ID09IDEpID8gY29tbWl0IDogTlVMTDsKCQkJY29udGludWU7CgkJfQoKCQlpZiAoaWdub3JlX2lmX2luX3Vwc3RyZWFtICYmCgkJCQloYXNfY29tbWl0X3BhdGNoX2lkKGNvbW1pdCwgJmlkcykpCgkJCWNvbnRpbnVlOwoKCQlucisrOwoJCWxpc3QgPSB4cmVhbGxvYyhsaXN0LCBuciAqIHNpemVvZihsaXN0WzBdKSk7CgkJbGlzdFtuciAtIDFdID0gY29tbWl0OwoJfQoJdG90YWwgPSBucjsKCWlmICgha2VlcF9zdWJqZWN0ICYmIGF1dG9fbnVtYmVyICYmIHRvdGFsID4gMSkKCQludW1iZXJlZCA9IDE7CglpZiAobnVtYmVyZWQpCgkJcmV2LnRvdGFsID0gdG90YWwgKyBzdGFydF9udW1iZXIgLSAxOwoJaWYgKGluX3JlcGx5X3RvIHx8IHRocmVhZCB8fCBjb3Zlcl9sZXR0ZXIpCgkJcmV2LnJlZl9tZXNzYWdlX2lkcyA9IHhjYWxsb2MoMSwgc2l6ZW9mKHN0cnVjdCBzdHJpbmdfbGlzdCkpOwoJaWYgKGluX3JlcGx5X3RvKSB7CgkJY29uc3QgY2hhciAqbXNnaWQgPSBjbGVhbl9tZXNzYWdlX2lkKGluX3JlcGx5X3RvKTsKCQlzdHJpbmdfbGlzdF9hcHBlbmQobXNnaWQsIHJldi5yZWZfbWVzc2FnZV9pZHMpOwoJfQoJcmV2Lm51bWJlcmVkX2ZpbGVzID0gbnVtYmVyZWRfZmlsZXM7CglyZXYucGF0Y2hfc3VmZml4ID0gZm10X3BhdGNoX3N1ZmZpeDsKCWlmIChjb3Zlcl9sZXR0ZXIpIHsKCQlpZiAodGhyZWFkKQoJCQlnZW5fbWVzc2FnZV9pZCgmcmV2LCAiY292ZXIiKTsKCQltYWtlX2NvdmVyX2xldHRlcigmcmV2LCB1c2Vfc3Rkb3V0LCBudW1iZXJlZCwgbnVtYmVyZWRfZmlsZXMsCgkJCQkgIG9yaWdpbiwgbnIsIGxpc3QsIGhlYWQpOwoJCXRvdGFsKys7CgkJc3RhcnRfbnVtYmVyLS07Cgl9CglyZXYuYWRkX3NpZ25vZmYgPSBhZGRfc2lnbm9mZjsKCXdoaWxlICgwIDw9IC0tbnIpIHsKCQlpbnQgc2hvd247CgkJY29tbWl0ID0gbGlzdFtucl07CgkJcmV2Lm5yID0gdG90YWwgLSBuciArIChzdGFydF9udW1iZXIgLSAxKTsKCQkvKiBNYWtlIHRoZSBzZWNvbmQgYW5kIHN1YnNlcXVlbnQgbWFpbHMgcmVwbGllcyB0byB0aGUgZmlyc3QgKi8KCQlpZiAodGhyZWFkKSB7CgkJCS8qIEhhdmUgd2UgYWxyZWFkeSBoYWQgYSBtZXNzYWdlIElEPyAqLwoJCQlpZiAocmV2Lm1lc3NhZ2VfaWQpIHsKCQkJCS8qCgkJCQkgKiBGb3IgZGVlcCB0aHJlYWRpbmc6IG1ha2UgZXZlcnkgbWFpbAoJCQkJICogYSByZXBseSB0byB0aGUgcHJldmlvdXMgb25lLCBubwoJCQkJICogbWF0dGVyIHdoYXQgb3RoZXIgb3B0aW9ucyBhcmUgc2V0LgoJCQkJICoKCQkJCSAqIEZvciBzaGFsbG93IHRocmVhZGluZzoKCQkJCSAqCgkJCQkgKiBXaXRob3V0IC0tY292ZXItbGV0dGVyIGFuZAoJCQkJICogLS1pbi1yZXBseS10bywgbWFrZSBldmVyeSBtYWlsIGEKCQkJCSAqIHJlcGx5IHRvIHRoZSBvbmUgYmVmb3JlLgoJCQkJICoKCQkJCSAqIFdpdGggLS1pbi1yZXBseS10byBidXQgbm8KCQkJCSAqIC0tY292ZXItbGV0dGVyLCBtYWtlIGV2ZXJ5IG1haWwgYQoJCQkJICogcmVwbHkgdG8gdGhlIDxyZXBseS10bz4uCgkJCQkgKgoJCQkJICogV2l0aCAtLWNvdmVyLWxldHRlciwgbWFrZSBldmVyeQoJCQkJICogbWFpbCBidXQgdGhlIGNvdmVyIGxldHRlciBhIHJlcGx5CgkJCQkgKiB0byB0aGUgY292ZXIgbGV0dGVyLiAgVGhlIGNvdmVyCgkJCQkgKiBsZXR0ZXIgaXMgYSByZXBseSB0byB0aGUKCQkJCSAqIC0taW4tcmVwbHktdG8sIGlmIHNwZWNpZmllZC4KCQkJCSAqLwoJCQkJaWYgKHRocmVhZCA9PSBUSFJFQURfU0hBTExPVwoJCQkJICAgICYmIHJldi5yZWZfbWVzc2FnZV9pZHMtPm5yID4gMAoJCQkJICAgICYmICghY292ZXJfbGV0dGVyIHx8IHJldi5uciA+IDEpKQoJCQkJCWZyZWUocmV2Lm1lc3NhZ2VfaWQpOwoJCQkJZWxzZQoJCQkJCXN0cmluZ19saXN0X2FwcGVuZChyZXYubWVzc2FnZV9pZCwKCQkJCQkJCSAgIHJldi5yZWZfbWVzc2FnZV9pZHMpOwoJCQl9CgkJCWdlbl9tZXNzYWdlX2lkKCZyZXYsIHNoYTFfdG9faGV4KGNvbW1pdC0+b2JqZWN0LnNoYTEpKTsKCQl9CgoJCWlmICghdXNlX3N0ZG91dCAmJiByZW9wZW5fc3Rkb3V0KG51bWJlcmVkX2ZpbGVzID8gTlVMTCA6IGNvbW1pdCwKCQkJCQkJICZyZXYpKQoJCQlkaWUoIkZhaWxlZCB0byBjcmVhdGUgb3V0cHV0IGZpbGVzIik7CgkJc2hvd24gPSBsb2dfdHJlZV9jb21taXQoJnJldiwgY29tbWl0KTsKCQlmcmVlKGNvbW1pdC0+YnVmZmVyKTsKCQljb21taXQtPmJ1ZmZlciA9IE5VTEw7CgoJCS8qIFdlIHB1dCBvbmUgZXh0cmEgYmxhbmsgbGluZSBiZXR3ZWVuIGZvcm1hdHRlZAoJCSAqIHBhdGNoZXMgYW5kIHRoaXMgZmxhZyBpcyB1c2VkIGJ5IGxvZy10cmVlIGNvZGUKCQkgKiB0byBzZWUgaWYgaXQgbmVlZHMgdG8gZW1pdCBhIExGIGJlZm9yZSBzaG93aW5nCgkJICogdGhlIGxvZzsgd2hlbiB1c2luZyBvbmUgZmlsZSBwZXIgcGF0Y2gsIHdlIGRvCgkJICogbm90IHdhbnQgdGhlIGV4dHJhIGJsYW5rIGxpbmUuCgkJICovCgkJaWYgKCF1c2Vfc3Rkb3V0KQoJCQlyZXYuc2hvd25fb25lID0gMDsKCQlpZiAoc2hvd24pIHsKCQkJaWYgKHJldi5taW1lX2JvdW5kYXJ5KQoJCQkJcHJpbnRmKCJcbi0tJXMlcy0tXG5cblxuIiwKCQkJCSAgICAgICBtaW1lX2JvdW5kYXJ5X2xlYWRlciwKCQkJCSAgICAgICByZXYubWltZV9ib3VuZGFyeSk7CgkJCWVsc2UKCQkJCXByaW50ZigiLS0gXG4lc1xuXG4iLCBnaXRfdmVyc2lvbl9zdHJpbmcpOwoJCX0KCQlpZiAoIXVzZV9zdGRvdXQpCgkJCWZjbG9zZShzdGRvdXQpOwoJfQoJZnJlZShsaXN0KTsKCXN0cmluZ19saXN0X2NsZWFyKCZleHRyYV90bywgMCk7CglzdHJpbmdfbGlzdF9jbGVhcigmZXh0cmFfY2MsIDApOwoJc3RyaW5nX2xpc3RfY2xlYXIoJmV4dHJhX2hkciwgMCk7CglpZiAoaWdub3JlX2lmX2luX3Vwc3RyZWFtKQoJCWZyZWVfcGF0Y2hfaWRzKCZpZHMpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgYWRkX3BlbmRpbmdfY29tbWl0KGNvbnN0IGNoYXIgKmFyZywgc3RydWN0IHJldl9pbmZvICpyZXZzLCBpbnQgZmxhZ3MpCnsKCXVuc2lnbmVkIGNoYXIgc2hhMVsyMF07CglpZiAoZ2V0X3NoYTEoYXJnLCBzaGExKSA9PSAwKSB7CgkJc3RydWN0IGNvbW1pdCAqY29tbWl0ID0gbG9va3VwX2NvbW1pdF9yZWZlcmVuY2Uoc2hhMSk7CgkJaWYgKGNvbW1pdCkgewoJCQljb21taXQtPm9iamVjdC5mbGFncyB8PSBmbGFnczsKCQkJYWRkX3BlbmRpbmdfb2JqZWN0KHJldnMsICZjb21taXQtPm9iamVjdCwgYXJnKTsKCQkJcmV0dXJuIDA7CgkJfQoJfQoJcmV0dXJuIC0xOwp9CgpzdGF0aWMgY29uc3QgY2hhciAqIGNvbnN0IGNoZXJyeV91c2FnZVtdID0gewoJImdpdCBjaGVycnkgWy12XSBbPHVwc3RyZWFtPiBbPGhlYWQ+IFs8bGltaXQ+XV1dIiwKCU5VTEwKfTsKCmludCBjbWRfY2hlcnJ5KGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndiwgY29uc3QgY2hhciAqcHJlZml4KQp7CglzdHJ1Y3QgcmV2X2luZm8gcmV2czsKCXN0cnVjdCBwYXRjaF9pZHMgaWRzOwoJc3RydWN0IGNvbW1pdCAqY29tbWl0OwoJc3RydWN0IGNvbW1pdF9saXN0ICpsaXN0ID0gTlVMTDsKCXN0cnVjdCBicmFuY2ggKmN1cnJlbnRfYnJhbmNoOwoJY29uc3QgY2hhciAqdXBzdHJlYW07Cgljb25zdCBjaGFyICpoZWFkID0gIkhFQUQiOwoJY29uc3QgY2hhciAqbGltaXQgPSBOVUxMOwoJaW50IHZlcmJvc2UgPSAwLCBhYmJyZXYgPSAwOwoKCXN0cnVjdCBvcHRpb24gb3B0aW9uc1tdID0gewoJCU9QVF9fQUJCUkVWKCZhYmJyZXYpLAoJCU9QVF9fVkVSQk9TRSgmdmVyYm9zZSksCgkJT1BUX0VORCgpCgl9OwoKCWFyZ2MgPSBwYXJzZV9vcHRpb25zKGFyZ2MsIGFyZ3YsIHByZWZpeCwgb3B0aW9ucywgY2hlcnJ5X3VzYWdlLCAwKTsKCglzd2l0Y2ggKGFyZ2MpIHsKCWNhc2UgMzoKCQlsaW1pdCA9IGFyZ3ZbMl07CgkJLyogRkFMTFRIUk9VR0ggKi8KCWNhc2UgMjoKCQloZWFkID0gYXJndlsxXTsKCQkvKiBGQUxMVEhST1VHSCAqLwoJY2FzZSAxOgoJCXVwc3RyZWFtID0gYXJndlswXTsKCQlicmVhazsKCWRlZmF1bHQ6CgkJY3VycmVudF9icmFuY2ggPSBicmFuY2hfZ2V0KE5VTEwpOwoJCWlmICghY3VycmVudF9icmFuY2ggfHwgIWN1cnJlbnRfYnJhbmNoLT5tZXJnZQoJCQkJCXx8ICFjdXJyZW50X2JyYW5jaC0+bWVyZ2VbMF0KCQkJCQl8fCAhY3VycmVudF9icmFuY2gtPm1lcmdlWzBdLT5kc3QpIHsKCQkJZnByaW50ZihzdGRlcnIsICJDb3VsZCBub3QgZmluZCBhIHRyYWNrZWQiCgkJCQkJIiByZW1vdGUgYnJhbmNoLCBwbGVhc2UiCgkJCQkJIiBzcGVjaWZ5IDx1cHN0cmVhbT4gbWFudWFsbHkuXG4iKTsKCQkJdXNhZ2Vfd2l0aF9vcHRpb25zKGNoZXJyeV91c2FnZSwgb3B0aW9ucyk7CgkJfQoKCQl1cHN0cmVhbSA9IGN1cnJlbnRfYnJhbmNoLT5tZXJnZVswXS0+ZHN0OwoJfQoKCWluaXRfcmV2aXNpb25zKCZyZXZzLCBwcmVmaXgpOwoJcmV2cy5kaWZmID0gMTsKCXJldnMuY29tYmluZV9tZXJnZXMgPSAwOwoJcmV2cy5pZ25vcmVfbWVyZ2VzID0gMTsKCURJRkZfT1BUX1NFVCgmcmV2cy5kaWZmb3B0LCBSRUNVUlNJVkUpOwoKCWlmIChhZGRfcGVuZGluZ19jb21taXQoaGVhZCwgJnJldnMsIDApKQoJCWRpZSgiVW5rbm93biBjb21taXQgJXMiLCBoZWFkKTsKCWlmIChhZGRfcGVuZGluZ19jb21taXQodXBzdHJlYW0sICZyZXZzLCBVTklOVEVSRVNUSU5HKSkKCQlkaWUoIlVua25vd24gY29tbWl0ICVzIiwgdXBzdHJlYW0pOwoKCS8qIERvbid0IHNheSBhbnl0aGluZyBpZiBoZWFkIGFuZCB1cHN0cmVhbSBhcmUgdGhlIHNhbWUuICovCglpZiAocmV2cy5wZW5kaW5nLm5yID09IDIpIHsKCQlzdHJ1Y3Qgb2JqZWN0X2FycmF5X2VudHJ5ICpvID0gcmV2cy5wZW5kaW5nLm9iamVjdHM7CgkJaWYgKGhhc2hjbXAob1swXS5pdGVtLT5zaGExLCBvWzFdLml0ZW0tPnNoYTEpID09IDApCgkJCXJldHVybiAwOwoJfQoKCWdldF9wYXRjaF9pZHMoJnJldnMsICZpZHMsIHByZWZpeCk7CgoJaWYgKGxpbWl0ICYmIGFkZF9wZW5kaW5nX2NvbW1pdChsaW1pdCwgJnJldnMsIFVOSU5URVJFU1RJTkcpKQoJCWRpZSgiVW5rbm93biBjb21taXQgJXMiLCBsaW1pdCk7CgoJLyogcmV2ZXJzZSB0aGUgbGlzdCBvZiBjb21taXRzICovCglpZiAocHJlcGFyZV9yZXZpc2lvbl93YWxrKCZyZXZzKSkKCQlkaWUoInJldmlzaW9uIHdhbGsgc2V0dXAgZmFpbGVkIik7Cgl3aGlsZSAoKGNvbW1pdCA9IGdldF9yZXZpc2lvbigmcmV2cykpICE9IE5VTEwpIHsKCQkvKiBpZ25vcmUgbWVyZ2VzICovCgkJaWYgKGNvbW1pdC0+cGFyZW50cyAmJiBjb21taXQtPnBhcmVudHMtPm5leHQpCgkJCWNvbnRpbnVlOwoKCQljb21taXRfbGlzdF9pbnNlcnQoY29tbWl0LCAmbGlzdCk7Cgl9CgoJd2hpbGUgKGxpc3QpIHsKCQljaGFyIHNpZ24gPSAnKyc7CgoJCWNvbW1pdCA9IGxpc3QtPml0ZW07CgkJaWYgKGhhc19jb21taXRfcGF0Y2hfaWQoY29tbWl0LCAmaWRzKSkKCQkJc2lnbiA9ICctJzsKCgkJaWYgKHZlcmJvc2UpIHsKCQkJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCQkJc3RydWN0IHByZXR0eV9wcmludF9jb250ZXh0IGN0eCA9IHswfTsKCQkJcHJldHR5X3ByaW50X2NvbW1pdChDTUlUX0ZNVF9PTkVMSU5FLCBjb21taXQsCgkJCQkJICAgICZidWYsICZjdHgpOwoJCQlwcmludGYoIiVjICVzICVzXG4iLCBzaWduLAoJCQkgICAgICAgZmluZF91bmlxdWVfYWJicmV2KGNvbW1pdC0+b2JqZWN0LnNoYTEsIGFiYnJldiksCgkJCSAgICAgICBidWYuYnVmKTsKCQkJc3RyYnVmX3JlbGVhc2UoJmJ1Zik7CgkJfQoJCWVsc2UgewoJCQlwcmludGYoIiVjICVzXG4iLCBzaWduLAoJCQkgICAgICAgZmluZF91bmlxdWVfYWJicmV2KGNvbW1pdC0+b2JqZWN0LnNoYTEsIGFiYnJldikpOwoJCX0KCgkJbGlzdCA9IGxpc3QtPm5leHQ7Cgl9CgoJZnJlZV9wYXRjaF9pZHMoJmlkcyk7CglyZXR1cm4gMDsKfQo=",
    "text": "/*\n * Builtin \"git log\" and related commands (show, whatchanged)\n *\n * (C) Copyright 2006 Linus Torvalds\n *\t\t 2006 Junio Hamano\n */\n#include \"cache.h\"\n#include \"color.h\"\n#include \"commit.h\"\n#include \"diff.h\"\n#include \"revision.h\"\n#include \"log-tree.h\"\n#include \"builtin.h\"\n#include \"tag.h\"\n#include \"reflog-walk.h\"\n#include \"patch-ids.h\"\n#include \"run-command.h\"\n#include \"shortlog.h\"\n#include \"remote.h\"\n#include \"string-list.h\"\n#include \"parse-options.h\"\n\n/* Set a default date-time format for git log (\"log.date\" config variable) */\nstatic const char *default_date_mode = NULL;\n\nstatic int default_show_root = 1;\nstatic const char *fmt_patch_subject_prefix = \"PATCH\";\nstatic const char *fmt_pretty;\n\nstatic const char * const builtin_log_usage =\n\t\"git log [<options>] [<since>..<until>] [[--] <path>...]\\n\"\n\t\"   or: git show [options] <object>...\";\n\nstatic void cmd_log_init(int argc, const char **argv, const char *prefix,\n\t\t\t struct rev_info *rev, struct setup_revision_opt *opt)\n{\n\tint i;\n\tint decoration_style = 0;\n\tstruct userformat_want w;\n\n\trev->abbrev = DEFAULT_ABBREV;\n\trev->commit_format = CMIT_FMT_DEFAULT;\n\tif (fmt_pretty)\n\t\tget_commit_format(fmt_pretty, rev);\n\trev->verbose_header = 1;\n\tDIFF_OPT_SET(&rev->diffopt, RECURSIVE);\n\trev->show_root_diff = default_show_root;\n\trev->subject_prefix = fmt_patch_subject_prefix;\n\tDIFF_OPT_SET(&rev->diffopt, ALLOW_TEXTCONV);\n\n\tif (default_date_mode)\n\t\trev->date_mode = parse_date_format(default_date_mode);\n\n\t/*\n\t * Check for -h before setup_revisions(), or \"git log -h\" will\n\t * fail when run without a git directory.\n\t */\n\tif (argc == 2 && !strcmp(argv[1], \"-h\"))\n\t\tusage(builtin_log_usage);\n\targc = setup_revisions(argc, argv, rev, opt);\n\n\tmemset(&w, 0, sizeof(w));\n\tuserformat_find_requirements(NULL, &w);\n\n\tif (!rev->show_notes_given && (!rev->pretty_given || w.notes))\n\t\trev->show_notes = 1;\n\tif (rev->show_notes)\n\t\tinit_display_notes(&rev->notes_opt);\n\n\tif (rev->diffopt.pickaxe || rev->diffopt.filter)\n\t\trev->always_show_header = 0;\n\tif (DIFF_OPT_TST(&rev->diffopt, FOLLOW_RENAMES)) {\n\t\trev->always_show_header = 0;\n\t\tif (rev->diffopt.nr_paths != 1)\n\t\t\tusage(\"git logs can only follow renames on one pathname at a time\");\n\t}\n\tfor (i = 1; i < argc; i++) {\n\t\tconst char *arg = argv[i];\n\t\tif (!strcmp(arg, \"--decorate\")) {\n\t\t\tdecoration_style = DECORATE_SHORT_REFS;\n\t\t} else if (!prefixcmp(arg, \"--decorate=\")) {\n\t\t\tconst char *v = skip_prefix(arg, \"--decorate=\");\n\t\t\tif (!strcmp(v, \"full\"))\n\t\t\t\tdecoration_style = DECORATE_FULL_REFS;\n\t\t\telse if (!strcmp(v, \"short\"))\n\t\t\t\tdecoration_style = DECORATE_SHORT_REFS;\n\t\t\telse\n\t\t\t\tdie(\"invalid --decorate option: %s\", arg);\n\t\t} else if (!strcmp(arg, \"--source\")) {\n\t\t\trev->show_source = 1;\n\t\t} else if (!strcmp(arg, \"-h\")) {\n\t\t\tusage(builtin_log_usage);\n\t\t} else\n\t\t\tdie(\"unrecognized argument: %s\", arg);\n\t}\n\tif (decoration_style) {\n\t\trev->show_decorations = 1;\n\t\tload_ref_decorations(decoration_style);\n\t}\n}\n\n/*\n * This gives a rough estimate for how many commits we\n * will print out in the list.\n */\nstatic int estimate_commit_count(struct rev_info *rev, struct commit_list *list)\n{\n\tint n = 0;\n\n\twhile (list) {\n\t\tstruct commit *commit = list->item;\n\t\tunsigned int flags = commit->object.flags;\n\t\tlist = list->next;\n\t\tif (!(flags & (TREESAME | UNINTERESTING)))\n\t\t\tn++;\n\t}\n\treturn n;\n}\n\nstatic void show_early_header(struct rev_info *rev, const char *stage, int nr)\n{\n\tif (rev->shown_one) {\n\t\trev->shown_one = 0;\n\t\tif (rev->commit_format != CMIT_FMT_ONELINE)\n\t\t\tputchar(rev->diffopt.line_termination);\n\t}\n\tprintf(\"Final output: %d %s\\n\", nr, stage);\n}\n\nstatic struct itimerval early_output_timer;\n\nstatic void log_show_early(struct rev_info *revs, struct commit_list *list)\n{\n\tint i = revs->early_output;\n\tint show_header = 1;\n\n\tsort_in_topological_order(&list, revs->lifo);\n\twhile (list && i) {\n\t\tstruct commit *commit = list->item;\n\t\tswitch (simplify_commit(revs, commit)) {\n\t\tcase commit_show:\n\t\t\tif (show_header) {\n\t\t\t\tint n = estimate_commit_count(revs, list);\n\t\t\t\tshow_early_header(revs, \"incomplete\", n);\n\t\t\t\tshow_header = 0;\n\t\t\t}\n\t\t\tlog_tree_commit(revs, commit);\n\t\t\ti--;\n\t\t\tbreak;\n\t\tcase commit_ignore:\n\t\t\tbreak;\n\t\tcase commit_error:\n\t\t\treturn;\n\t\t}\n\t\tlist = list->next;\n\t}\n\n\t/* Did we already get enough commits for the early output? */\n\tif (!i)\n\t\treturn;\n\n\t/*\n\t * ..if no, then repeat it twice a second until we\n\t * do.\n\t *\n\t * NOTE! We don't use \"it_interval\", because if the\n\t * reader isn't listening, we want our output to be\n\t * throttled by the writing, and not have the timer\n\t * trigger every second even if we're blocked on a\n\t * reader!\n\t */\n\tearly_output_timer.it_value.tv_sec = 0;\n\tearly_output_timer.it_value.tv_usec = 500000;\n\tsetitimer(ITIMER_REAL, &early_output_timer, NULL);\n}\n\nstatic void early_output(int signal)\n{\n\tshow_early_output = log_show_early;\n}\n\nstatic void setup_early_output(struct rev_info *rev)\n{\n\tstruct sigaction sa;\n\n\t/*\n\t * Set up the signal handler, minimally intrusively:\n\t * we only set a single volatile integer word (not\n\t * using sigatomic_t - trying to avoid unnecessary\n\t * system dependencies and headers), and using\n\t * SA_RESTART.\n\t */\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sa_handler = early_output;\n\tsigemptyset(&sa.sa_mask);\n\tsa.sa_flags = SA_RESTART;\n\tsigaction(SIGALRM, &sa, NULL);\n\n\t/*\n\t * If we can get the whole output in less than a\n\t * tenth of a second, don't even bother doing the\n\t * early-output thing..\n\t *\n\t * This is a one-time-only trigger.\n\t */\n\tearly_output_timer.it_value.tv_sec = 0;\n\tearly_output_timer.it_value.tv_usec = 100000;\n\tsetitimer(ITIMER_REAL, &early_output_timer, NULL);\n}\n\nstatic void finish_early_output(struct rev_info *rev)\n{\n\tint n = estimate_commit_count(rev, rev->commits);\n\tsignal(SIGALRM, SIG_IGN);\n\tshow_early_header(rev, \"done\", n);\n}\n\nstatic int cmd_log_walk(struct rev_info *rev)\n{\n\tstruct commit *commit;\n\n\tif (rev->early_output)\n\t\tsetup_early_output(rev);\n\n\tif (prepare_revision_walk(rev))\n\t\tdie(\"revision walk setup failed\");\n\n\tif (rev->early_output)\n\t\tfinish_early_output(rev);\n\n\t/*\n\t * For --check and --exit-code, the exit code is based on CHECK_FAILED\n\t * and HAS_CHANGES being accumulated in rev->diffopt, so be careful to\n\t * retain that state information if replacing rev->diffopt in this loop\n\t */\n\twhile ((commit = get_revision(rev)) != NULL) {\n\t\tlog_tree_commit(rev, commit);\n\t\tif (!rev->reflog_info) {\n\t\t\t/* we allow cycles in reflog ancestry */\n\t\t\tfree(commit->buffer);\n\t\t\tcommit->buffer = NULL;\n\t\t}\n\t\tfree_commit_list(commit->parents);\n\t\tcommit->parents = NULL;\n\t}\n\tif (rev->diffopt.output_format & DIFF_FORMAT_CHECKDIFF &&\n\t    DIFF_OPT_TST(&rev->diffopt, CHECK_FAILED)) {\n\t\treturn 02;\n\t}\n\treturn diff_result_code(&rev->diffopt, 0);\n}\n\nstatic int git_log_config(const char *var, const char *value, void *cb)\n{\n\tif (!strcmp(var, \"format.pretty\"))\n\t\treturn git_config_string(&fmt_pretty, var, value);\n\tif (!strcmp(var, \"format.subjectprefix\"))\n\t\treturn git_config_string(&fmt_patch_subject_prefix, var, value);\n\tif (!strcmp(var, \"log.date\"))\n\t\treturn git_config_string(&default_date_mode, var, value);\n\tif (!strcmp(var, \"log.showroot\")) {\n\t\tdefault_show_root = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\treturn git_diff_ui_config(var, value, cb);\n}\n\nint cmd_whatchanged(int argc, const char **argv, const char *prefix)\n{\n\tstruct rev_info rev;\n\tstruct setup_revision_opt opt;\n\n\tgit_config(git_log_config, NULL);\n\n\tif (diff_use_color_default == -1)\n\t\tdiff_use_color_default = git_use_color_default;\n\n\tinit_revisions(&rev, prefix);\n\trev.diff = 1;\n\trev.simplify_history = 0;\n\tmemset(&opt, 0, sizeof(opt));\n\topt.def = \"HEAD\";\n\tcmd_log_init(argc, argv, prefix, &rev, &opt);\n\tif (!rev.diffopt.output_format)\n\t\trev.diffopt.output_format = DIFF_FORMAT_RAW;\n\treturn cmd_log_walk(&rev);\n}\n\nstatic void show_tagger(char *buf, int len, struct rev_info *rev)\n{\n\tstruct strbuf out = STRBUF_INIT;\n\n\tpp_user_info(\"Tagger\", rev->commit_format, &out, buf, rev->date_mode,\n\t\tgit_log_output_encoding ?\n\t\tgit_log_output_encoding: git_commit_encoding);\n\tprintf(\"%s\", out.buf);\n\tstrbuf_release(&out);\n}\n\nstatic int show_object(const unsigned char *sha1, int show_tag_object,\n\tstruct rev_info *rev)\n{\n\tunsigned long size;\n\tenum object_type type;\n\tchar *buf = read_sha1_file(sha1, &type, &size);\n\tint offset = 0;\n\n\tif (!buf)\n\t\treturn error(\"Could not read object %s\", sha1_to_hex(sha1));\n\n\tif (show_tag_object)\n\t\twhile (offset < size && buf[offset] != '\\n') {\n\t\t\tint new_offset = offset + 1;\n\t\t\twhile (new_offset < size && buf[new_offset++] != '\\n')\n\t\t\t\t; /* do nothing */\n\t\t\tif (!prefixcmp(buf + offset, \"tagger \"))\n\t\t\t\tshow_tagger(buf + offset + 7,\n\t\t\t\t\t    new_offset - offset - 7, rev);\n\t\t\toffset = new_offset;\n\t\t}\n\n\tif (offset < size)\n\t\tfwrite(buf + offset, size - offset, 1, stdout);\n\tfree(buf);\n\treturn 0;\n}\n\nstatic int show_tree_object(const unsigned char *sha1,\n\t\tconst char *base, int baselen,\n\t\tconst char *pathname, unsigned mode, int stage, void *context)\n{\n\tprintf(\"%s%s\\n\", pathname, S_ISDIR(mode) ? \"/\" : \"\");\n\treturn 0;\n}\n\nstatic void show_rev_tweak_rev(struct rev_info *rev, struct setup_revision_opt *opt)\n{\n\tif (rev->ignore_merges) {\n\t\t/* There was no \"-m\" on the command line */\n\t\trev->ignore_merges = 0;\n\t\tif (!rev->first_parent_only && !rev->combine_merges) {\n\t\t\t/* No \"--first-parent\", \"-c\", nor \"--cc\" */\n\t\t\trev->combine_merges = 1;\n\t\t\trev->dense_combined_merges = 1;\n\t\t}\n\t}\n\tif (!rev->diffopt.output_format)\n\t\trev->diffopt.output_format = DIFF_FORMAT_PATCH;\n}\n\nint cmd_show(int argc, const char **argv, const char *prefix)\n{\n\tstruct rev_info rev;\n\tstruct object_array_entry *objects;\n\tstruct setup_revision_opt opt;\n\tint i, count, ret = 0;\n\n\tgit_config(git_log_config, NULL);\n\n\tif (diff_use_color_default == -1)\n\t\tdiff_use_color_default = git_use_color_default;\n\n\tinit_revisions(&rev, prefix);\n\trev.diff = 1;\n\trev.always_show_header = 1;\n\trev.no_walk = 1;\n\tmemset(&opt, 0, sizeof(opt));\n\topt.def = \"HEAD\";\n\topt.tweak = show_rev_tweak_rev;\n\tcmd_log_init(argc, argv, prefix, &rev, &opt);\n\n\tcount = rev.pending.nr;\n\tobjects = rev.pending.objects;\n\tfor (i = 0; i < count && !ret; i++) {\n\t\tstruct object *o = objects[i].item;\n\t\tconst char *name = objects[i].name;\n\t\tswitch (o->type) {\n\t\tcase OBJ_BLOB:\n\t\t\tret = show_object(o->sha1, 0, NULL);\n\t\t\tbreak;\n\t\tcase OBJ_TAG: {\n\t\t\tstruct tag *t = (struct tag *)o;\n\n\t\t\tif (rev.shown_one)\n\t\t\t\tputchar('\\n');\n\t\t\tprintf(\"%stag %s%s\\n\",\n\t\t\t\t\tdiff_get_color_opt(&rev.diffopt, DIFF_COMMIT),\n\t\t\t\t\tt->tag,\n\t\t\t\t\tdiff_get_color_opt(&rev.diffopt, DIFF_RESET));\n\t\t\tret = show_object(o->sha1, 1, &rev);\n\t\t\trev.shown_one = 1;\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\to = parse_object(t->tagged->sha1);\n\t\t\tif (!o)\n\t\t\t\tret = error(\"Could not read object %s\",\n\t\t\t\t\t    sha1_to_hex(t->tagged->sha1));\n\t\t\tobjects[i].item = o;\n\t\t\ti--;\n\t\t\tbreak;\n\t\t}\n\t\tcase OBJ_TREE:\n\t\t\tif (rev.shown_one)\n\t\t\t\tputchar('\\n');\n\t\t\tprintf(\"%stree %s%s\\n\\n\",\n\t\t\t\t\tdiff_get_color_opt(&rev.diffopt, DIFF_COMMIT),\n\t\t\t\t\tname,\n\t\t\t\t\tdiff_get_color_opt(&rev.diffopt, DIFF_RESET));\n\t\t\tread_tree_recursive((struct tree *)o, \"\", 0, 0, NULL,\n\t\t\t\t\tshow_tree_object, NULL);\n\t\t\trev.shown_one = 1;\n\t\t\tbreak;\n\t\tcase OBJ_COMMIT:\n\t\t\trev.pending.nr = rev.pending.alloc = 0;\n\t\t\trev.pending.objects = NULL;\n\t\t\tadd_object_array(o, name, &rev.pending);\n\t\t\tret = cmd_log_walk(&rev);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = error(\"Unknown type: %d\", o->type);\n\t\t}\n\t}\n\tfree(objects);\n\treturn ret;\n}\n\n/*\n * This is equivalent to \"git log -g --abbrev-commit --pretty=oneline\"\n */\nint cmd_log_reflog(int argc, const char **argv, const char *prefix)\n{\n\tstruct rev_info rev;\n\tstruct setup_revision_opt opt;\n\n\tgit_config(git_log_config, NULL);\n\n\tif (diff_use_color_default == -1)\n\t\tdiff_use_color_default = git_use_color_default;\n\n\tinit_revisions(&rev, prefix);\n\tinit_reflog_walk(&rev.reflog_info);\n\trev.abbrev_commit = 1;\n\trev.verbose_header = 1;\n\tmemset(&opt, 0, sizeof(opt));\n\topt.def = \"HEAD\";\n\tcmd_log_init(argc, argv, prefix, &rev, &opt);\n\n\t/*\n\t * This means that we override whatever commit format the user gave\n\t * on the cmd line.  Sad, but cmd_log_init() currently doesn't\n\t * allow us to set a different default.\n\t */\n\trev.commit_format = CMIT_FMT_ONELINE;\n\trev.use_terminator = 1;\n\trev.always_show_header = 1;\n\n\t/*\n\t * We get called through \"git reflog\", so unlike the other log\n\t * routines, we need to set up our pager manually..\n\t */\n\tsetup_pager();\n\n\treturn cmd_log_walk(&rev);\n}\n\nint cmd_log(int argc, const char **argv, const char *prefix)\n{\n\tstruct rev_info rev;\n\tstruct setup_revision_opt opt;\n\n\tgit_config(git_log_config, NULL);\n\n\tif (diff_use_color_default == -1)\n\t\tdiff_use_color_default = git_use_color_default;\n\n\tinit_revisions(&rev, prefix);\n\trev.always_show_header = 1;\n\tmemset(&opt, 0, sizeof(opt));\n\topt.def = \"HEAD\";\n\tcmd_log_init(argc, argv, prefix, &rev, &opt);\n\treturn cmd_log_walk(&rev);\n}\n\n/* format-patch */\n\nstatic const char *fmt_patch_suffix = \".patch\";\nstatic int numbered = 0;\nstatic int auto_number = 1;\n\nstatic char *default_attach = NULL;\n\nstatic struct string_list extra_hdr;\nstatic struct string_list extra_to;\nstatic struct string_list extra_cc;\n\nstatic void add_header(const char *value)\n{\n\tstruct string_list_item *item;\n\tint len = strlen(value);\n\twhile (len && value[len - 1] == '\\n')\n\t\tlen--;\n\n\tif (!strncasecmp(value, \"to: \", 4)) {\n\t\titem = string_list_append(value + 4, &extra_to);\n\t\tlen -= 4;\n\t} else if (!strncasecmp(value, \"cc: \", 4)) {\n\t\titem = string_list_append(value + 4, &extra_cc);\n\t\tlen -= 4;\n\t} else {\n\t\titem = string_list_append(value, &extra_hdr);\n\t}\n\n\titem->string[len] = '\\0';\n}\n\n#define THREAD_SHALLOW 1\n#define THREAD_DEEP 2\nstatic int thread = 0;\nstatic int do_signoff = 0;\n\nstatic int git_format_config(const char *var, const char *value, void *cb)\n{\n\tif (!strcmp(var, \"format.headers\")) {\n\t\tif (!value)\n\t\t\tdie(\"format.headers without value\");\n\t\tadd_header(value);\n\t\treturn 0;\n\t}\n\tif (!strcmp(var, \"format.suffix\"))\n\t\treturn git_config_string(&fmt_patch_suffix, var, value);\n\tif (!strcmp(var, \"format.to\")) {\n\t\tif (!value)\n\t\t\treturn config_error_nonbool(var);\n\t\tstring_list_append(value, &extra_to);\n\t\treturn 0;\n\t}\n\tif (!strcmp(var, \"format.cc\")) {\n\t\tif (!value)\n\t\t\treturn config_error_nonbool(var);\n\t\tstring_list_append(value, &extra_cc);\n\t\treturn 0;\n\t}\n\tif (!strcmp(var, \"diff.color\") || !strcmp(var, \"color.diff\")) {\n\t\treturn 0;\n\t}\n\tif (!strcmp(var, \"format.numbered\")) {\n\t\tif (value && !strcasecmp(value, \"auto\")) {\n\t\t\tauto_number = 1;\n\t\t\treturn 0;\n\t\t}\n\t\tnumbered = git_config_bool(var, value);\n\t\tauto_number = auto_number && numbered;\n\t\treturn 0;\n\t}\n\tif (!strcmp(var, \"format.attach\")) {\n\t\tif (value && *value)\n\t\t\tdefault_attach = xstrdup(value);\n\t\telse\n\t\t\tdefault_attach = xstrdup(git_version_string);\n\t\treturn 0;\n\t}\n\tif (!strcmp(var, \"format.thread\")) {\n\t\tif (value && !strcasecmp(value, \"deep\")) {\n\t\t\tthread = THREAD_DEEP;\n\t\t\treturn 0;\n\t\t}\n\t\tif (value && !strcasecmp(value, \"shallow\")) {\n\t\t\tthread = THREAD_SHALLOW;\n\t\t\treturn 0;\n\t\t}\n\t\tthread = git_config_bool(var, value) && THREAD_SHALLOW;\n\t\treturn 0;\n\t}\n\tif (!strcmp(var, \"format.signoff\")) {\n\t\tdo_signoff = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\n\treturn git_log_config(var, value, cb);\n}\n\nstatic FILE *realstdout = NULL;\nstatic const char *output_directory = NULL;\nstatic int outdir_offset;\n\nstatic int reopen_stdout(struct commit *commit, struct rev_info *rev)\n{\n\tstruct strbuf filename = STRBUF_INIT;\n\tint suffix_len = strlen(fmt_patch_suffix) + 1;\n\n\tif (output_directory) {\n\t\tstrbuf_addstr(&filename, output_directory);\n\t\tif (filename.len >=\n\t\t    PATH_MAX - FORMAT_PATCH_NAME_MAX - suffix_len)\n\t\t\treturn error(\"name of output directory is too long\");\n\t\tif (filename.buf[filename.len - 1] != '/')\n\t\t\tstrbuf_addch(&filename, '/');\n\t}\n\n\tget_patch_filename(commit, rev->nr, fmt_patch_suffix, &filename);\n\n\tif (!DIFF_OPT_TST(&rev->diffopt, QUICK))\n\t\tfprintf(realstdout, \"%s\\n\", filename.buf + outdir_offset);\n\n\tif (freopen(filename.buf, \"w\", stdout) == NULL)\n\t\treturn error(\"Cannot open patch file %s\", filename.buf);\n\n\tstrbuf_release(&filename);\n\treturn 0;\n}\n\nstatic void get_patch_ids(struct rev_info *rev, struct patch_ids *ids, const char *prefix)\n{\n\tstruct rev_info check_rev;\n\tstruct commit *commit;\n\tstruct object *o1, *o2;\n\tunsigned flags1, flags2;\n\n\tif (rev->pending.nr != 2)\n\t\tdie(\"Need exactly one range.\");\n\n\to1 = rev->pending.objects[0].item;\n\tflags1 = o1->flags;\n\to2 = rev->pending.objects[1].item;\n\tflags2 = o2->flags;\n\n\tif ((flags1 & UNINTERESTING) == (flags2 & UNINTERESTING))\n\t\tdie(\"Not a range.\");\n\n\tinit_patch_ids(ids);\n\n\t/* given a range a..b get all patch ids for b..a */\n\tinit_revisions(&check_rev, prefix);\n\to1->flags ^= UNINTERESTING;\n\to2->flags ^= UNINTERESTING;\n\tadd_pending_object(&check_rev, o1, \"o1\");\n\tadd_pending_object(&check_rev, o2, \"o2\");\n\tif (prepare_revision_walk(&check_rev))\n\t\tdie(\"revision walk setup failed\");\n\n\twhile ((commit = get_revision(&check_rev)) != NULL) {\n\t\t/* ignore merges */\n\t\tif (commit->parents && commit->parents->next)\n\t\t\tcontinue;\n\n\t\tadd_commit_patch_id(commit, ids);\n\t}\n\n\t/* reset for next revision walk */\n\tclear_commit_marks((struct commit *)o1,\n\t\t\tSEEN | UNINTERESTING | SHOWN | ADDED);\n\tclear_commit_marks((struct commit *)o2,\n\t\t\tSEEN | UNINTERESTING | SHOWN | ADDED);\n\to1->flags = flags1;\n\to2->flags = flags2;\n}\n\nstatic void gen_message_id(struct rev_info *info, char *base)\n{\n\tconst char *committer = git_committer_info(IDENT_WARN_ON_NO_NAME);\n\tconst char *email_start = strrchr(committer, '<');\n\tconst char *email_end = strrchr(committer, '>');\n\tstruct strbuf buf = STRBUF_INIT;\n\tif (!email_start || !email_end || email_start > email_end - 1)\n\t\tdie(\"Could not extract email from committer identity.\");\n\tstrbuf_addf(&buf, \"%s.%lu.git.%.*s\", base,\n\t\t    (unsigned long) time(NULL),\n\t\t    (int)(email_end - email_start - 1), email_start + 1);\n\tinfo->message_id = strbuf_detach(&buf, NULL);\n}\n\nstatic void make_cover_letter(struct rev_info *rev, int use_stdout,\n\t\t\t      int numbered, int numbered_files,\n\t\t\t      struct commit *origin,\n\t\t\t      int nr, struct commit **list, struct commit *head)\n{\n\tconst char *committer;\n\tconst char *subject_start = NULL;\n\tconst char *body = \"*** SUBJECT HERE ***\\n\\n*** BLURB HERE ***\\n\";\n\tconst char *msg;\n\tconst char *extra_headers = rev->extra_headers;\n\tstruct shortlog log;\n\tstruct strbuf sb = STRBUF_INIT;\n\tint i;\n\tconst char *encoding = \"UTF-8\";\n\tstruct diff_options opts;\n\tint need_8bit_cte = 0;\n\tstruct commit *commit = NULL;\n\n\tif (rev->commit_format != CMIT_FMT_EMAIL)\n\t\tdie(\"Cover letter needs email format\");\n\n\tcommitter = git_committer_info(0);\n\n\tif (!numbered_files) {\n\t\t/*\n\t\t * We fake a commit for the cover letter so we get the filename\n\t\t * desired.\n\t\t */\n\t\tcommit = xcalloc(1, sizeof(*commit));\n\t\tcommit->buffer = xmalloc(400);\n\t\tsnprintf(commit->buffer, 400,\n\t\t\t\"tree 0000000000000000000000000000000000000000\\n\"\n\t\t\t\"parent %s\\n\"\n\t\t\t\"author %s\\n\"\n\t\t\t\"committer %s\\n\\n\"\n\t\t\t\"cover letter\\n\",\n\t\t\tsha1_to_hex(head->object.sha1), committer, committer);\n\t}\n\n\tif (!use_stdout && reopen_stdout(commit, rev))\n\t\treturn;\n\n\tif (commit) {\n\n\t\tfree(commit->buffer);\n\t\tfree(commit);\n\t}\n\n\tlog_write_email_headers(rev, head, &subject_start, &extra_headers,\n\t\t\t\t&need_8bit_cte);\n\n\tfor (i = 0; !need_8bit_cte && i < nr; i++)\n\t\tif (has_non_ascii(list[i]->buffer))\n\t\t\tneed_8bit_cte = 1;\n\n\tmsg = body;\n\tpp_user_info(NULL, CMIT_FMT_EMAIL, &sb, committer, DATE_RFC2822,\n\t\t     encoding);\n\tpp_title_line(CMIT_FMT_EMAIL, &msg, &sb, subject_start, extra_headers,\n\t\t      encoding, need_8bit_cte);\n\tpp_remainder(CMIT_FMT_EMAIL, &msg, &sb, 0);\n\tprintf(\"%s\\n\", sb.buf);\n\n\tstrbuf_release(&sb);\n\n\tshortlog_init(&log);\n\tlog.wrap_lines = 1;\n\tlog.wrap = 72;\n\tlog.in1 = 2;\n\tlog.in2 = 4;\n\tfor (i = 0; i < nr; i++)\n\t\tshortlog_add_commit(&log, list[i]);\n\n\tshortlog_output(&log);\n\n\t/*\n\t * We can only do diffstat with a unique reference point\n\t */\n\tif (!origin)\n\t\treturn;\n\n\tmemcpy(&opts, &rev->diffopt, sizeof(opts));\n\topts.output_format = DIFF_FORMAT_SUMMARY | DIFF_FORMAT_DIFFSTAT;\n\n\tdiff_setup_done(&opts);\n\n\tdiff_tree_sha1(origin->tree->object.sha1,\n\t\t       head->tree->object.sha1,\n\t\t       \"\", &opts);\n\tdiffcore_std(&opts);\n\tdiff_flush(&opts);\n\n\tprintf(\"\\n\");\n}\n\nstatic const char *clean_message_id(const char *msg_id)\n{\n\tchar ch;\n\tconst char *a, *z, *m;\n\n\tm = msg_id;\n\twhile ((ch = *m) && (isspace(ch) || (ch == '<')))\n\t\tm++;\n\ta = m;\n\tz = NULL;\n\twhile ((ch = *m)) {\n\t\tif (!isspace(ch) && (ch != '>'))\n\t\t\tz = m;\n\t\tm++;\n\t}\n\tif (!z)\n\t\tdie(\"insane in-reply-to: %s\", msg_id);\n\tif (++z == m)\n\t\treturn a;\n\treturn xmemdupz(a, z - a);\n}\n\nstatic const char *set_outdir(const char *prefix, const char *output_directory)\n{\n\tif (output_directory && is_absolute_path(output_directory))\n\t\treturn output_directory;\n\n\tif (!prefix || !*prefix) {\n\t\tif (output_directory)\n\t\t\treturn output_directory;\n\t\t/* The user did not explicitly ask for \"./\" */\n\t\toutdir_offset = 2;\n\t\treturn \"./\";\n\t}\n\n\toutdir_offset = strlen(prefix);\n\tif (!output_directory)\n\t\treturn prefix;\n\n\treturn xstrdup(prefix_filename(prefix, outdir_offset,\n\t\t\t\t       output_directory));\n}\n\nstatic const char * const builtin_format_patch_usage[] = {\n\t\"git format-patch [options] [<since> | <revision range>]\",\n\tNULL\n};\n\nstatic int keep_subject = 0;\n\nstatic int keep_callback(const struct option *opt, const char *arg, int unset)\n{\n\t((struct rev_info *)opt->value)->total = -1;\n\tkeep_subject = 1;\n\treturn 0;\n}\n\nstatic int subject_prefix = 0;\n\nstatic int subject_prefix_callback(const struct option *opt, const char *arg,\n\t\t\t    int unset)\n{\n\tsubject_prefix = 1;\n\t((struct rev_info *)opt->value)->subject_prefix = arg;\n\treturn 0;\n}\n\nstatic int numbered_cmdline_opt = 0;\n\nstatic int numbered_callback(const struct option *opt, const char *arg,\n\t\t\t     int unset)\n{\n\t*(int *)opt->value = numbered_cmdline_opt = unset ? 0 : 1;\n\tif (unset)\n\t\tauto_number =  0;\n\treturn 0;\n}\n\nstatic int no_numbered_callback(const struct option *opt, const char *arg,\n\t\t\t\tint unset)\n{\n\treturn numbered_callback(opt, arg, 1);\n}\n\nstatic int output_directory_callback(const struct option *opt, const char *arg,\n\t\t\t      int unset)\n{\n\tconst char **dir = (const char **)opt->value;\n\tif (*dir)\n\t\tdie(\"Two output directories?\");\n\t*dir = arg;\n\treturn 0;\n}\n\nstatic int thread_callback(const struct option *opt, const char *arg, int unset)\n{\n\tint *thread = (int *)opt->value;\n\tif (unset)\n\t\t*thread = 0;\n\telse if (!arg || !strcmp(arg, \"shallow\"))\n\t\t*thread = THREAD_SHALLOW;\n\telse if (!strcmp(arg, \"deep\"))\n\t\t*thread = THREAD_DEEP;\n\telse\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int attach_callback(const struct option *opt, const char *arg, int unset)\n{\n\tstruct rev_info *rev = (struct rev_info *)opt->value;\n\tif (unset)\n\t\trev->mime_boundary = NULL;\n\telse if (arg)\n\t\trev->mime_boundary = arg;\n\telse\n\t\trev->mime_boundary = git_version_string;\n\trev->no_inline = unset ? 0 : 1;\n\treturn 0;\n}\n\nstatic int inline_callback(const struct option *opt, const char *arg, int unset)\n{\n\tstruct rev_info *rev = (struct rev_info *)opt->value;\n\tif (unset)\n\t\trev->mime_boundary = NULL;\n\telse if (arg)\n\t\trev->mime_boundary = arg;\n\telse\n\t\trev->mime_boundary = git_version_string;\n\trev->no_inline = 0;\n\treturn 0;\n}\n\nstatic int header_callback(const struct option *opt, const char *arg, int unset)\n{\n\tif (unset) {\n\t\tstring_list_clear(&extra_hdr, 0);\n\t\tstring_list_clear(&extra_to, 0);\n\t\tstring_list_clear(&extra_cc, 0);\n\t} else {\n\t    add_header(arg);\n\t}\n\treturn 0;\n}\n\nstatic int to_callback(const struct option *opt, const char *arg, int unset)\n{\n\tif (unset)\n\t\tstring_list_clear(&extra_to, 0);\n\telse\n\t\tstring_list_append(arg, &extra_to);\n\treturn 0;\n}\n\nstatic int cc_callback(const struct option *opt, const char *arg, int unset)\n{\n\tif (unset)\n\t\tstring_list_clear(&extra_cc, 0);\n\telse\n\t\tstring_list_append(arg, &extra_cc);\n\treturn 0;\n}\n\nint cmd_format_patch(int argc, const char **argv, const char *prefix)\n{\n\tstruct commit *commit;\n\tstruct commit **list = NULL;\n\tstruct rev_info rev;\n\tstruct setup_revision_opt s_r_opt;\n\tint nr = 0, total, i;\n\tint use_stdout = 0;\n\tint start_number = -1;\n\tint numbered_files = 0;\t\t/* _just_ numbers */\n\tint ignore_if_in_upstream = 0;\n\tint cover_letter = 0;\n\tint boundary_count = 0;\n\tint no_binary_diff = 0;\n\tstruct commit *origin = NULL, *head = NULL;\n\tconst char *in_reply_to = NULL;\n\tstruct patch_ids ids;\n\tchar *add_signoff = NULL;\n\tstruct strbuf buf = STRBUF_INIT;\n\tint use_patch_format = 0;\n\tconst struct option builtin_format_patch_options[] = {\n\t\t{ OPTION_CALLBACK, 'n', \"numbered\", &numbered, NULL,\n\t\t\t    \"use [PATCH n/m] even with a single patch\",\n\t\t\t    PARSE_OPT_NOARG, numbered_callback },\n\t\t{ OPTION_CALLBACK, 'N', \"no-numbered\", &numbered, NULL,\n\t\t\t    \"use [PATCH] even with multiple patches\",\n\t\t\t    PARSE_OPT_NOARG, no_numbered_callback },\n\t\tOPT_BOOLEAN('s', \"signoff\", &do_signoff, \"add Signed-off-by:\"),\n\t\tOPT_BOOLEAN(0, \"stdout\", &use_stdout,\n\t\t\t    \"print patches to standard out\"),\n\t\tOPT_BOOLEAN(0, \"cover-letter\", &cover_letter,\n\t\t\t    \"generate a cover letter\"),\n\t\tOPT_BOOLEAN(0, \"numbered-files\", &numbered_files,\n\t\t\t    \"use simple number sequence for output file names\"),\n\t\tOPT_STRING(0, \"suffix\", &fmt_patch_suffix, \"sfx\",\n\t\t\t    \"use <sfx> instead of '.patch'\"),\n\t\tOPT_INTEGER(0, \"start-number\", &start_number,\n\t\t\t    \"start numbering patches at <n> instead of 1\"),\n\t\t{ OPTION_CALLBACK, 0, \"subject-prefix\", &rev, \"prefix\",\n\t\t\t    \"Use [<prefix>] instead of [PATCH]\",\n\t\t\t    PARSE_OPT_NONEG, subject_prefix_callback },\n\t\t{ OPTION_CALLBACK, 'o', \"output-directory\", &output_directory,\n\t\t\t    \"dir\", \"store resulting files in <dir>\",\n\t\t\t    PARSE_OPT_NONEG, output_directory_callback },\n\t\t{ OPTION_CALLBACK, 'k', \"keep-subject\", &rev, NULL,\n\t\t\t    \"don't strip/add [PATCH]\",\n\t\t\t    PARSE_OPT_NOARG | PARSE_OPT_NONEG, keep_callback },\n\t\tOPT_BOOLEAN(0, \"no-binary\", &no_binary_diff,\n\t\t\t    \"don't output binary diffs\"),\n\t\tOPT_BOOLEAN(0, \"ignore-if-in-upstream\", &ignore_if_in_upstream,\n\t\t\t    \"don't include a patch matching a commit upstream\"),\n\t\t{ OPTION_BOOLEAN, 'p', \"no-stat\", &use_patch_format, NULL,\n\t\t  \"show patch format instead of default (patch + stat)\",\n\t\t  PARSE_OPT_NONEG | PARSE_OPT_NOARG },\n\t\tOPT_GROUP(\"Messaging\"),\n\t\t{ OPTION_CALLBACK, 0, \"add-header\", NULL, \"header\",\n\t\t\t    \"add email header\", 0, header_callback },\n\t\t{ OPTION_CALLBACK, 0, \"to\", NULL, \"email\", \"add To: header\",\n\t\t\t    0, to_callback },\n\t\t{ OPTION_CALLBACK, 0, \"cc\", NULL, \"email\", \"add Cc: header\",\n\t\t\t    0, cc_callback },\n\t\tOPT_STRING(0, \"in-reply-to\", &in_reply_to, \"message-id\",\n\t\t\t    \"make first mail a reply to <message-id>\"),\n\t\t{ OPTION_CALLBACK, 0, \"attach\", &rev, \"boundary\",\n\t\t\t    \"attach the patch\", PARSE_OPT_OPTARG,\n\t\t\t    attach_callback },\n\t\t{ OPTION_CALLBACK, 0, \"inline\", &rev, \"boundary\",\n\t\t\t    \"inline the patch\",\n\t\t\t    PARSE_OPT_OPTARG | PARSE_OPT_NONEG,\n\t\t\t    inline_callback },\n\t\t{ OPTION_CALLBACK, 0, \"thread\", &thread, \"style\",\n\t\t\t    \"enable message threading, styles: shallow, deep\",\n\t\t\t    PARSE_OPT_OPTARG, thread_callback },\n\t\tOPT_END()\n\t};\n\n\textra_hdr.strdup_strings = 1;\n\textra_to.strdup_strings = 1;\n\textra_cc.strdup_strings = 1;\n\tgit_config(git_format_config, NULL);\n\tinit_revisions(&rev, prefix);\n\trev.commit_format = CMIT_FMT_EMAIL;\n\trev.verbose_header = 1;\n\trev.diff = 1;\n\trev.no_merges = 1;\n\tDIFF_OPT_SET(&rev.diffopt, RECURSIVE);\n\trev.subject_prefix = fmt_patch_subject_prefix;\n\tmemset(&s_r_opt, 0, sizeof(s_r_opt));\n\ts_r_opt.def = \"HEAD\";\n\n\tif (default_attach) {\n\t\trev.mime_boundary = default_attach;\n\t\trev.no_inline = 1;\n\t}\n\n\t/*\n\t * Parse the arguments before setup_revisions(), or something\n\t * like \"git format-patch -o a123 HEAD^..\" may fail; a123 is\n\t * possibly a valid SHA1.\n\t */\n\targc = parse_options(argc, argv, prefix, builtin_format_patch_options,\n\t\t\t     builtin_format_patch_usage,\n\t\t\t     PARSE_OPT_KEEP_ARGV0 | PARSE_OPT_KEEP_UNKNOWN |\n\t\t\t     PARSE_OPT_KEEP_DASHDASH);\n\n\tif (do_signoff) {\n\t\tconst char *committer;\n\t\tconst char *endpos;\n\t\tcommitter = git_committer_info(IDENT_ERROR_ON_NO_NAME);\n\t\tendpos = strchr(committer, '>');\n\t\tif (!endpos)\n\t\t\tdie(\"bogus committer info %s\", committer);\n\t\tadd_signoff = xmemdupz(committer, endpos - committer + 1);\n\t}\n\n\tfor (i = 0; i < extra_hdr.nr; i++) {\n\t\tstrbuf_addstr(&buf, extra_hdr.items[i].string);\n\t\tstrbuf_addch(&buf, '\\n');\n\t}\n\n\tif (extra_to.nr)\n\t\tstrbuf_addstr(&buf, \"To: \");\n\tfor (i = 0; i < extra_to.nr; i++) {\n\t\tif (i)\n\t\t\tstrbuf_addstr(&buf, \"    \");\n\t\tstrbuf_addstr(&buf, extra_to.items[i].string);\n\t\tif (i + 1 < extra_to.nr)\n\t\t\tstrbuf_addch(&buf, ',');\n\t\tstrbuf_addch(&buf, '\\n');\n\t}\n\n\tif (extra_cc.nr)\n\t\tstrbuf_addstr(&buf, \"Cc: \");\n\tfor (i = 0; i < extra_cc.nr; i++) {\n\t\tif (i)\n\t\t\tstrbuf_addstr(&buf, \"    \");\n\t\tstrbuf_addstr(&buf, extra_cc.items[i].string);\n\t\tif (i + 1 < extra_cc.nr)\n\t\t\tstrbuf_addch(&buf, ',');\n\t\tstrbuf_addch(&buf, '\\n');\n\t}\n\n\trev.extra_headers = strbuf_detach(&buf, NULL);\n\n\tif (start_number < 0)\n\t\tstart_number = 1;\n\n\t/*\n\t * If numbered is set solely due to format.numbered in config,\n\t * and it would conflict with --keep-subject (-k) from the\n\t * command line, reset \"numbered\".\n\t */\n\tif (numbered && keep_subject && !numbered_cmdline_opt)\n\t\tnumbered = 0;\n\n\tif (numbered && keep_subject)\n\t\tdie (\"-n and -k are mutually exclusive.\");\n\tif (keep_subject && subject_prefix)\n\t\tdie (\"--subject-prefix and -k are mutually exclusive.\");\n\n\targc = setup_revisions(argc, argv, &rev, &s_r_opt);\n\tif (argc > 1)\n\t\tdie (\"unrecognized argument: %s\", argv[1]);\n\n\tif (rev.diffopt.output_format & DIFF_FORMAT_NAME)\n\t\tdie(\"--name-only does not make sense\");\n\tif (rev.diffopt.output_format & DIFF_FORMAT_NAME_STATUS)\n\t\tdie(\"--name-status does not make sense\");\n\tif (rev.diffopt.output_format & DIFF_FORMAT_CHECKDIFF)\n\t\tdie(\"--check does not make sense\");\n\n\tif (!use_patch_format &&\n\t\t(!rev.diffopt.output_format ||\n\t\t rev.diffopt.output_format == DIFF_FORMAT_PATCH))\n\t\trev.diffopt.output_format = DIFF_FORMAT_DIFFSTAT | DIFF_FORMAT_SUMMARY;\n\n\t/* Always generate a patch */\n\trev.diffopt.output_format |= DIFF_FORMAT_PATCH;\n\n\tif (!DIFF_OPT_TST(&rev.diffopt, TEXT) && !no_binary_diff)\n\t\tDIFF_OPT_SET(&rev.diffopt, BINARY);\n\n\tif (rev.show_notes)\n\t\tinit_display_notes(&rev.notes_opt);\n\n\tif (!use_stdout)\n\t\toutput_directory = set_outdir(prefix, output_directory);\n\n\tif (output_directory) {\n\t\tif (use_stdout)\n\t\t\tdie(\"standard output, or directory, which one?\");\n\t\tif (mkdir(output_directory, 0777) < 0 && errno != EEXIST)\n\t\t\tdie_errno(\"Could not create directory '%s'\",\n\t\t\t\t  output_directory);\n\t}\n\n\tif (rev.pending.nr == 1) {\n\t\tif (rev.max_count < 0 && !rev.show_root_diff) {\n\t\t\t/*\n\t\t\t * This is traditional behaviour of \"git format-patch\n\t\t\t * origin\" that prepares what the origin side still\n\t\t\t * does not have.\n\t\t\t */\n\t\t\trev.pending.objects[0].item->flags |= UNINTERESTING;\n\t\t\tadd_head_to_pending(&rev);\n\t\t}\n\t\t/*\n\t\t * Otherwise, it is \"format-patch -22 HEAD\", and/or\n\t\t * \"format-patch --root HEAD\".  The user wants\n\t\t * get_revision() to do the usual traversal.\n\t\t */\n\t}\n\n\t/*\n\t * We cannot move this anywhere earlier because we do want to\n\t * know if --root was given explicitly from the command line.\n\t */\n\trev.show_root_diff = 1;\n\n\tif (cover_letter) {\n\t\t/* remember the range */\n\t\tint i;\n\t\tfor (i = 0; i < rev.pending.nr; i++) {\n\t\t\tstruct object *o = rev.pending.objects[i].item;\n\t\t\tif (!(o->flags & UNINTERESTING))\n\t\t\t\thead = (struct commit *)o;\n\t\t}\n\t\t/* We can't generate a cover letter without any patches */\n\t\tif (!head)\n\t\t\treturn 0;\n\t}\n\n\tif (ignore_if_in_upstream) {\n\t\t/* Don't say anything if head and upstream are the same. */\n\t\tif (rev.pending.nr == 2) {\n\t\t\tstruct object_array_entry *o = rev.pending.objects;\n\t\t\tif (hashcmp(o[0].item->sha1, o[1].item->sha1) == 0)\n\t\t\t\treturn 0;\n\t\t}\n\t\tget_patch_ids(&rev, &ids, prefix);\n\t}\n\n\tif (!use_stdout)\n\t\trealstdout = xfdopen(xdup(1), \"w\");\n\n\tif (prepare_revision_walk(&rev))\n\t\tdie(\"revision walk setup failed\");\n\trev.boundary = 1;\n\twhile ((commit = get_revision(&rev)) != NULL) {\n\t\tif (commit->object.flags & BOUNDARY) {\n\t\t\tboundary_count++;\n\t\t\torigin = (boundary_count == 1) ? commit : NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ignore_if_in_upstream &&\n\t\t\t\thas_commit_patch_id(commit, &ids))\n\t\t\tcontinue;\n\n\t\tnr++;\n\t\tlist = xrealloc(list, nr * sizeof(list[0]));\n\t\tlist[nr - 1] = commit;\n\t}\n\ttotal = nr;\n\tif (!keep_subject && auto_number && total > 1)\n\t\tnumbered = 1;\n\tif (numbered)\n\t\trev.total = total + start_number - 1;\n\tif (in_reply_to || thread || cover_letter)\n\t\trev.ref_message_ids = xcalloc(1, sizeof(struct string_list));\n\tif (in_reply_to) {\n\t\tconst char *msgid = clean_message_id(in_reply_to);\n\t\tstring_list_append(msgid, rev.ref_message_ids);\n\t}\n\trev.numbered_files = numbered_files;\n\trev.patch_suffix = fmt_patch_suffix;\n\tif (cover_letter) {\n\t\tif (thread)\n\t\t\tgen_message_id(&rev, \"cover\");\n\t\tmake_cover_letter(&rev, use_stdout, numbered, numbered_files,\n\t\t\t\t  origin, nr, list, head);\n\t\ttotal++;\n\t\tstart_number--;\n\t}\n\trev.add_signoff = add_signoff;\n\twhile (0 <= --nr) {\n\t\tint shown;\n\t\tcommit = list[nr];\n\t\trev.nr = total - nr + (start_number - 1);\n\t\t/* Make the second and subsequent mails replies to the first */\n\t\tif (thread) {\n\t\t\t/* Have we already had a message ID? */\n\t\t\tif (rev.message_id) {\n\t\t\t\t/*\n\t\t\t\t * For deep threading: make every mail\n\t\t\t\t * a reply to the previous one, no\n\t\t\t\t * matter what other options are set.\n\t\t\t\t *\n\t\t\t\t * For shallow threading:\n\t\t\t\t *\n\t\t\t\t * Without --cover-letter and\n\t\t\t\t * --in-reply-to, make every mail a\n\t\t\t\t * reply to the one before.\n\t\t\t\t *\n\t\t\t\t * With --in-reply-to but no\n\t\t\t\t * --cover-letter, make every mail a\n\t\t\t\t * reply to the <reply-to>.\n\t\t\t\t *\n\t\t\t\t * With --cover-letter, make every\n\t\t\t\t * mail but the cover letter a reply\n\t\t\t\t * to the cover letter.  The cover\n\t\t\t\t * letter is a reply to the\n\t\t\t\t * --in-reply-to, if specified.\n\t\t\t\t */\n\t\t\t\tif (thread == THREAD_SHALLOW\n\t\t\t\t    && rev.ref_message_ids->nr > 0\n\t\t\t\t    && (!cover_letter || rev.nr > 1))\n\t\t\t\t\tfree(rev.message_id);\n\t\t\t\telse\n\t\t\t\t\tstring_list_append(rev.message_id,\n\t\t\t\t\t\t\t   rev.ref_message_ids);\n\t\t\t}\n\t\t\tgen_message_id(&rev, sha1_to_hex(commit->object.sha1));\n\t\t}\n\n\t\tif (!use_stdout && reopen_stdout(numbered_files ? NULL : commit,\n\t\t\t\t\t\t &rev))\n\t\t\tdie(\"Failed to create output files\");\n\t\tshown = log_tree_commit(&rev, commit);\n\t\tfree(commit->buffer);\n\t\tcommit->buffer = NULL;\n\n\t\t/* We put one extra blank line between formatted\n\t\t * patches and this flag is used by log-tree code\n\t\t * to see if it needs to emit a LF before showing\n\t\t * the log; when using one file per patch, we do\n\t\t * not want the extra blank line.\n\t\t */\n\t\tif (!use_stdout)\n\t\t\trev.shown_one = 0;\n\t\tif (shown) {\n\t\t\tif (rev.mime_boundary)\n\t\t\t\tprintf(\"\\n--%s%s--\\n\\n\\n\",\n\t\t\t\t       mime_boundary_leader,\n\t\t\t\t       rev.mime_boundary);\n\t\t\telse\n\t\t\t\tprintf(\"-- \\n%s\\n\\n\", git_version_string);\n\t\t}\n\t\tif (!use_stdout)\n\t\t\tfclose(stdout);\n\t}\n\tfree(list);\n\tstring_list_clear(&extra_to, 0);\n\tstring_list_clear(&extra_cc, 0);\n\tstring_list_clear(&extra_hdr, 0);\n\tif (ignore_if_in_upstream)\n\t\tfree_patch_ids(&ids);\n\treturn 0;\n}\n\nstatic int add_pending_commit(const char *arg, struct rev_info *revs, int flags)\n{\n\tunsigned char sha1[20];\n\tif (get_sha1(arg, sha1) == 0) {\n\t\tstruct commit *commit = lookup_commit_reference(sha1);\n\t\tif (commit) {\n\t\t\tcommit->object.flags |= flags;\n\t\t\tadd_pending_object(revs, &commit->object, arg);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -1;\n}\n\nstatic const char * const cherry_usage[] = {\n\t\"git cherry [-v] [<upstream> [<head> [<limit>]]]\",\n\tNULL\n};\n\nint cmd_cherry(int argc, const char **argv, const char *prefix)\n{\n\tstruct rev_info revs;\n\tstruct patch_ids ids;\n\tstruct commit *commit;\n\tstruct commit_list *list = NULL;\n\tstruct branch *current_branch;\n\tconst char *upstream;\n\tconst char *head = \"HEAD\";\n\tconst char *limit = NULL;\n\tint verbose = 0, abbrev = 0;\n\n\tstruct option options[] = {\n\t\tOPT__ABBREV(&abbrev),\n\t\tOPT__VERBOSE(&verbose),\n\t\tOPT_END()\n\t};\n\n\targc = parse_options(argc, argv, prefix, options, cherry_usage, 0);\n\n\tswitch (argc) {\n\tcase 3:\n\t\tlimit = argv[2];\n\t\t/* FALLTHROUGH */\n\tcase 2:\n\t\thead = argv[1];\n\t\t/* FALLTHROUGH */\n\tcase 1:\n\t\tupstream = argv[0];\n\t\tbreak;\n\tdefault:\n\t\tcurrent_branch = branch_get(NULL);\n\t\tif (!current_branch || !current_branch->merge\n\t\t\t\t\t|| !current_branch->merge[0]\n\t\t\t\t\t|| !current_branch->merge[0]->dst) {\n\t\t\tfprintf(stderr, \"Could not find a tracked\"\n\t\t\t\t\t\" remote branch, please\"\n\t\t\t\t\t\" specify <upstream> manually.\\n\");\n\t\t\tusage_with_options(cherry_usage, options);\n\t\t}\n\n\t\tupstream = current_branch->merge[0]->dst;\n\t}\n\n\tinit_revisions(&revs, prefix);\n\trevs.diff = 1;\n\trevs.combine_merges = 0;\n\trevs.ignore_merges = 1;\n\tDIFF_OPT_SET(&revs.diffopt, RECURSIVE);\n\n\tif (add_pending_commit(head, &revs, 0))\n\t\tdie(\"Unknown commit %s\", head);\n\tif (add_pending_commit(upstream, &revs, UNINTERESTING))\n\t\tdie(\"Unknown commit %s\", upstream);\n\n\t/* Don't say anything if head and upstream are the same. */\n\tif (revs.pending.nr == 2) {\n\t\tstruct object_array_entry *o = revs.pending.objects;\n\t\tif (hashcmp(o[0].item->sha1, o[1].item->sha1) == 0)\n\t\t\treturn 0;\n\t}\n\n\tget_patch_ids(&revs, &ids, prefix);\n\n\tif (limit && add_pending_commit(limit, &revs, UNINTERESTING))\n\t\tdie(\"Unknown commit %s\", limit);\n\n\t/* reverse the list of commits */\n\tif (prepare_revision_walk(&revs))\n\t\tdie(\"revision walk setup failed\");\n\twhile ((commit = get_revision(&revs)) != NULL) {\n\t\t/* ignore merges */\n\t\tif (commit->parents && commit->parents->next)\n\t\t\tcontinue;\n\n\t\tcommit_list_insert(commit, &list);\n\t}\n\n\twhile (list) {\n\t\tchar sign = '+';\n\n\t\tcommit = list->item;\n\t\tif (has_commit_patch_id(commit, &ids))\n\t\t\tsign = '-';\n\n\t\tif (verbose) {\n\t\t\tstruct strbuf buf = STRBUF_INIT;\n\t\t\tstruct pretty_print_context ctx = {0};\n\t\t\tpretty_print_commit(CMIT_FMT_ONELINE, commit,\n\t\t\t\t\t    &buf, &ctx);\n\t\t\tprintf(\"%c %s %s\\n\", sign,\n\t\t\t       find_unique_abbrev(commit->object.sha1, abbrev),\n\t\t\t       buf.buf);\n\t\t\tstrbuf_release(&buf);\n\t\t}\n\t\telse {\n\t\t\tprintf(\"%c %s\\n\", sign,\n\t\t\t       find_unique_abbrev(commit->object.sha1, abbrev));\n\t\t}\n\n\t\tlist = list->next;\n\t}\n\n\tfree_patch_ids(&ids);\n\treturn 0;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0093b2d8d8de561512efffe7cc416b1cdfe225dd",
  "sha1_ok": true,
  "size": 37562
}
