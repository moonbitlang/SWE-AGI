{
  "content": {
    "base64": "I2luY2x1ZGUgImJ1aWx0aW4uaCIKI2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJjb21taXQuaCIKI2luY2x1ZGUgImRpZmYuaCIKI2luY2x1ZGUgInBhdGgtbGlzdC5oIgojaW5jbHVkZSAicmV2aXNpb24uaCIKI2luY2x1ZGUgInV0ZjguaCIKI2luY2x1ZGUgIm1haWxtYXAuaCIKCnN0YXRpYyBjb25zdCBjaGFyIHNob3J0bG9nX3VzYWdlW10gPQoiZ2l0LXNob3J0bG9nIFstbl0gWy1zXSBbLWVdIFs8Y29tbWl0LWlkPi4uLiBdIjsKCnN0YXRpYyBjaGFyICpjb21tb25fcmVwb19wcmVmaXg7CnN0YXRpYyBpbnQgZW1haWw7CgpzdGF0aWMgaW50IGNvbXBhcmVfYnlfbnVtYmVyKGNvbnN0IHZvaWQgKmExLCBjb25zdCB2b2lkICphMikKewoJY29uc3Qgc3RydWN0IHBhdGhfbGlzdF9pdGVtICppMSA9IGExLCAqaTIgPSBhMjsKCWNvbnN0IHN0cnVjdCBwYXRoX2xpc3QgKmwxID0gaTEtPnV0aWwsICpsMiA9IGkyLT51dGlsOwoKCWlmIChsMS0+bnIgPCBsMi0+bnIpCgkJcmV0dXJuIDE7CgllbHNlIGlmIChsMS0+bnIgPT0gbDItPm5yKQoJCXJldHVybiAwOwoJZWxzZQoJCXJldHVybiAtMTsKfQoKc3RhdGljIHN0cnVjdCBwYXRoX2xpc3QgbWFpbG1hcCA9IHtOVUxMLCAwLCAwLCAwfTsKCnN0YXRpYyB2b2lkIGluc2VydF9vbmVfcmVjb3JkKHN0cnVjdCBwYXRoX2xpc3QgKmxpc3QsCgkJCSAgICAgIGNvbnN0IGNoYXIgKmF1dGhvciwKCQkJICAgICAgY29uc3QgY2hhciAqb25lbGluZSkKewoJY29uc3QgY2hhciAqZG90MyA9IGNvbW1vbl9yZXBvX3ByZWZpeDsKCWNoYXIgKmJ1ZmZlciwgKnA7CglzdHJ1Y3QgcGF0aF9saXN0X2l0ZW0gKml0ZW07CglzdHJ1Y3QgcGF0aF9saXN0ICpvbmVsaW5lczsKCWNoYXIgbmFtZWJ1ZlsxMDI0XTsKCXNpemVfdCBsZW47Cgljb25zdCBjaGFyICplb2w7Cgljb25zdCBjaGFyICpib2VtYWlsLCAqZW9lbWFpbDsKCglib2VtYWlsID0gc3RyY2hyKGF1dGhvciwgJzwnKTsKCWlmICghYm9lbWFpbCkKCQlyZXR1cm47Cgllb2VtYWlsID0gc3RyY2hyKGJvZW1haWwsICc+Jyk7CglpZiAoIWVvZW1haWwpCgkJcmV0dXJuOwoJaWYgKCFtYXBfZW1haWwoJm1haWxtYXAsIGJvZW1haWwrMSwgbmFtZWJ1Ziwgc2l6ZW9mKG5hbWVidWYpKSkgewoJCXdoaWxlIChhdXRob3IgPCBib2VtYWlsICYmIGlzc3BhY2UoKmF1dGhvcikpCgkJCWF1dGhvcisrOwoJCWZvciAobGVuID0gMDsKCQkgICAgIGxlbiA8IHNpemVvZihuYW1lYnVmKSAtIDEgJiYgYXV0aG9yICsgbGVuIDwgYm9lbWFpbDsKCQkgICAgIGxlbisrKQoJCQluYW1lYnVmW2xlbl0gPSBhdXRob3JbbGVuXTsKCQl3aGlsZSAoMCA8IGxlbiAmJiBpc3NwYWNlKG5hbWVidWZbbGVuLTFdKSkKCQkJbGVuLS07CgkJbmFtZWJ1ZltsZW5dID0gJ1wwJzsKCX0KCWVsc2UKCQlsZW4gPSBzdHJsZW4obmFtZWJ1Zik7CgoJaWYgKGVtYWlsKSB7CgkJc2l6ZV90IHJvb20gPSBzaXplb2YobmFtZWJ1ZikgLSBsZW4gLSAxOwoJCWludCBtYWlsbGVuID0gZW9lbWFpbCAtIGJvZW1haWwgKyAxOwoJCXNucHJpbnRmKG5hbWVidWYgKyBsZW4sIHJvb20sICIgJS4qcyIsIG1haWxsZW4sIGJvZW1haWwpOwoJfQoKCWJ1ZmZlciA9IHhzdHJkdXAobmFtZWJ1Zik7CglpdGVtID0gcGF0aF9saXN0X2luc2VydChidWZmZXIsIGxpc3QpOwoJaWYgKGl0ZW0tPnV0aWwgPT0gTlVMTCkKCQlpdGVtLT51dGlsID0geGNhbGxvYygxLCBzaXplb2Yoc3RydWN0IHBhdGhfbGlzdCkpOwoJZWxzZQoJCWZyZWUoYnVmZmVyKTsKCgllb2wgPSBzdHJjaHIob25lbGluZSwgJ1xuJyk7CglpZiAoIWVvbCkKCQllb2wgPSBvbmVsaW5lICsgc3RybGVuKG9uZWxpbmUpOwoJd2hpbGUgKCpvbmVsaW5lICYmIGlzc3BhY2UoKm9uZWxpbmUpICYmICpvbmVsaW5lICE9ICdcbicpCgkJb25lbGluZSsrOwoJaWYgKCFwcmVmaXhjbXAob25lbGluZSwgIltQQVRDSCIpKSB7CgkJY2hhciAqZW9iID0gc3RyY2hyKG9uZWxpbmUsICddJyk7CgkJaWYgKGVvYiAmJiAoIWVvbCB8fCBlb2IgPCBlb2wpKQoJCQlvbmVsaW5lID0gZW9iICsgMTsKCX0KCXdoaWxlICgqb25lbGluZSAmJiBpc3NwYWNlKCpvbmVsaW5lKSAmJiAqb25lbGluZSAhPSAnXG4nKQoJCW9uZWxpbmUrKzsKCWxlbiA9IGVvbCAtIG9uZWxpbmU7Cgl3aGlsZSAobGVuICYmIGlzc3BhY2Uob25lbGluZVtsZW4tMV0pKQoJCWxlbi0tOwoJYnVmZmVyID0geG1lbWR1cHoob25lbGluZSwgbGVuKTsKCglpZiAoZG90MykgewoJCWludCBkb3QzbGVuID0gc3RybGVuKGRvdDMpOwoJCWlmIChkb3QzbGVuID4gNSkgewoJCQl3aGlsZSAoKHAgPSBzdHJzdHIoYnVmZmVyLCBkb3QzKSkgIT0gTlVMTCkgewoJCQkJaW50IHRhaWxsZW4gPSBzdHJsZW4ocCkgLSBkb3QzbGVuOwoJCQkJbWVtY3B5KHAsICIvLi4uLyIsIDUpOwoJCQkJbWVtbW92ZShwICsgNSwgcCArIGRvdDNsZW4sIHRhaWxsZW4gKyAxKTsKCQkJfQoJCX0KCX0KCglvbmVsaW5lcyA9IGl0ZW0tPnV0aWw7CglpZiAob25lbGluZXMtPm5yID49IG9uZWxpbmVzLT5hbGxvYykgewoJCW9uZWxpbmVzLT5hbGxvYyA9IGFsbG9jX25yKG9uZWxpbmVzLT5ucik7CgkJb25lbGluZXMtPml0ZW1zID0geHJlYWxsb2Mob25lbGluZXMtPml0ZW1zLAoJCQkJb25lbGluZXMtPmFsbG9jCgkJCQkqIHNpemVvZihzdHJ1Y3QgcGF0aF9saXN0X2l0ZW0pKTsKCX0KCglvbmVsaW5lcy0+aXRlbXNbb25lbGluZXMtPm5yXS51dGlsID0gTlVMTDsKCW9uZWxpbmVzLT5pdGVtc1tvbmVsaW5lcy0+bnIrK10ucGF0aCA9IGJ1ZmZlcjsKfQoKc3RhdGljIHZvaWQgcmVhZF9mcm9tX3N0ZGluKHN0cnVjdCBwYXRoX2xpc3QgKmxpc3QpCnsKCWNoYXIgYXV0aG9yWzEwMjRdLCBvbmVsaW5lWzEwMjRdOwoKCXdoaWxlIChmZ2V0cyhhdXRob3IsIHNpemVvZihhdXRob3IpLCBzdGRpbikgIT0gTlVMTCkgewoJCWlmICghKGF1dGhvclswXSA9PSAnQScgfHwgYXV0aG9yWzBdID09ICdhJykgfHwKCQkgICAgcHJlZml4Y21wKGF1dGhvciArIDEsICJ1dGhvcjogIikpCgkJCWNvbnRpbnVlOwoJCXdoaWxlIChmZ2V0cyhvbmVsaW5lLCBzaXplb2Yob25lbGluZSksIHN0ZGluKSAmJgoJCSAgICAgICBvbmVsaW5lWzBdICE9ICdcbicpCgkJCTsgLyogZGlzY2FyZCBoZWFkZXJzICovCgkJd2hpbGUgKGZnZXRzKG9uZWxpbmUsIHNpemVvZihvbmVsaW5lKSwgc3RkaW4pICYmCgkJICAgICAgIG9uZWxpbmVbMF0gPT0gJ1xuJykKCQkJOyAvKiBkaXNjYXJkIGJsYW5rcyAqLwoJCWluc2VydF9vbmVfcmVjb3JkKGxpc3QsIGF1dGhvciArIDgsIG9uZWxpbmUpOwoJfQp9CgpzdGF0aWMgdm9pZCBnZXRfZnJvbV9yZXYoc3RydWN0IHJldl9pbmZvICpyZXYsIHN0cnVjdCBwYXRoX2xpc3QgKmxpc3QpCnsKCXN0cnVjdCBjb21taXQgKmNvbW1pdDsKCglpZiAocHJlcGFyZV9yZXZpc2lvbl93YWxrKHJldikpCgkJZGllKCJyZXZpc2lvbiB3YWxrIHNldHVwIGZhaWxlZCIpOwoJd2hpbGUgKChjb21taXQgPSBnZXRfcmV2aXNpb24ocmV2KSkgIT0gTlVMTCkgewoJCWNvbnN0IGNoYXIgKmF1dGhvciA9IE5VTEwsICpidWZmZXI7CgoJCWJ1ZmZlciA9IGNvbW1pdC0+YnVmZmVyOwoJCXdoaWxlICgqYnVmZmVyICYmICpidWZmZXIgIT0gJ1xuJykgewoJCQljb25zdCBjaGFyICplb2wgPSBzdHJjaHIoYnVmZmVyLCAnXG4nKTsKCgkJCWlmIChlb2wgPT0gTlVMTCkKCQkJCWVvbCA9IGJ1ZmZlciArIHN0cmxlbihidWZmZXIpOwoJCQllbHNlCgkJCQllb2wrKzsKCgkJCWlmICghcHJlZml4Y21wKGJ1ZmZlciwgImF1dGhvciAiKSkKCQkJCWF1dGhvciA9IGJ1ZmZlciArIDc7CgkJCWJ1ZmZlciA9IGVvbDsKCQl9CgkJaWYgKCFhdXRob3IpCgkJCWRpZSgiTWlzc2luZyBhdXRob3I6ICVzIiwKCQkJICAgIHNoYTFfdG9faGV4KGNvbW1pdC0+b2JqZWN0LnNoYTEpKTsKCQlpZiAoKmJ1ZmZlcikKCQkJYnVmZmVyKys7CgkJaW5zZXJ0X29uZV9yZWNvcmQobGlzdCwgYXV0aG9yLCAhKmJ1ZmZlciA/ICI8bm9uZT4iIDogYnVmZmVyKTsKCX0KfQoKc3RhdGljIGludCBwYXJzZV91aW50KGNoYXIgY29uc3QgKiphcmcsIGludCBjb21tYSkKewoJdW5zaWduZWQgbG9uZyB1bDsKCWludCByZXQ7CgljaGFyICplbmRwOwoKCXVsID0gc3RydG91bCgqYXJnLCAmZW5kcCwgMTApOwoJaWYgKGVuZHAgIT0gKmFyZyAmJiAqZW5kcCAmJiAqZW5kcCAhPSBjb21tYSkKCQlyZXR1cm4gLTE7CglyZXQgPSAoaW50KSB1bDsKCWlmIChyZXQgIT0gdWwpCgkJcmV0dXJuIC0xOwoJKmFyZyA9IGVuZHA7CglpZiAoKiphcmcpCgkJKCphcmcpKys7CglyZXR1cm4gcmV0Owp9CgpzdGF0aWMgY29uc3QgY2hhciB3cmFwX2FyZ191c2FnZVtdID0gIi13Wzx3aWR0aD5bLDxpbmRlbnQxPlssPGluZGVudDI+XV1dIjsKI2RlZmluZSBERUZBVUxUX1dSQVBMRU4gNzYKI2RlZmluZSBERUZBVUxUX0lOREVOVDEgNgojZGVmaW5lIERFRkFVTFRfSU5ERU5UMiA5CgpzdGF0aWMgdm9pZCBwYXJzZV93cmFwX2FyZ3MoY29uc3QgY2hhciAqYXJnLCBpbnQgKmluMSwgaW50ICppbjIsIGludCAqd3JhcCkKewoJYXJnICs9IDI7IC8qIHNraXAgLXcgKi8KCgkqd3JhcCA9IHBhcnNlX3VpbnQoJmFyZywgJywnKTsKCWlmICgqd3JhcCA8IDApCgkJZGllKHdyYXBfYXJnX3VzYWdlKTsKCSppbjEgPSBwYXJzZV91aW50KCZhcmcsICcsJyk7CglpZiAoKmluMSA8IDApCgkJZGllKHdyYXBfYXJnX3VzYWdlKTsKCSppbjIgPSBwYXJzZV91aW50KCZhcmcsICdcMCcpOwoJaWYgKCppbjIgPCAwKQoJCWRpZSh3cmFwX2FyZ191c2FnZSk7CgoJaWYgKCEqd3JhcCkKCQkqd3JhcCA9IERFRkFVTFRfV1JBUExFTjsKCWlmICghKmluMSkKCQkqaW4xID0gREVGQVVMVF9JTkRFTlQxOwoJaWYgKCEqaW4yKQoJCSppbjIgPSBERUZBVUxUX0lOREVOVDI7CglpZiAoKndyYXAgJiYKCSAgICAoKCppbjEgJiYgKndyYXAgPD0gKmluMSkgfHwKCSAgICAgKCppbjIgJiYgKndyYXAgPD0gKmluMikpKQoJCWRpZSh3cmFwX2FyZ191c2FnZSk7Cn0KCmludCBjbWRfc2hvcnRsb2coaW50IGFyZ2MsIGNvbnN0IGNoYXIgKiphcmd2LCBjb25zdCBjaGFyICpwcmVmaXgpCnsKCXN0cnVjdCByZXZfaW5mbyByZXY7CglzdHJ1Y3QgcGF0aF9saXN0IGxpc3QgPSB7IE5VTEwsIDAsIDAsIDEgfTsKCWludCBpLCBqLCBzb3J0X2J5X251bWJlciA9IDAsIHN1bW1hcnkgPSAwOwoJaW50IHdyYXBfbGluZXMgPSAwOwoJaW50IHdyYXAgPSBERUZBVUxUX1dSQVBMRU47CglpbnQgaW4xID0gREVGQVVMVF9JTkRFTlQxOwoJaW50IGluMiA9IERFRkFVTFRfSU5ERU5UMjsKCgkvKiBzaW5jZSAtbiBpcyBhIHNoYWRvd2VkIHJldiBhcmd1bWVudCwgcGFyc2Ugb3VyIGFyZ3MgZmlyc3QgKi8KCXdoaWxlIChhcmdjID4gMSkgewoJCWlmICghc3RyY21wKGFyZ3ZbMV0sICItbiIpIHx8ICFzdHJjbXAoYXJndlsxXSwgIi0tbnVtYmVyZWQiKSkKCQkJc29ydF9ieV9udW1iZXIgPSAxOwoJCWVsc2UgaWYgKCFzdHJjbXAoYXJndlsxXSwgIi1zIikgfHwKCQkJCSFzdHJjbXAoYXJndlsxXSwgIi0tc3VtbWFyeSIpKQoJCQlzdW1tYXJ5ID0gMTsKCQllbHNlIGlmICghc3RyY21wKGFyZ3ZbMV0sICItZSIpIHx8CgkJCSAhc3RyY21wKGFyZ3ZbMV0sICItLWVtYWlsIikpCgkJCWVtYWlsID0gMTsKCQllbHNlIGlmICghcHJlZml4Y21wKGFyZ3ZbMV0sICItdyIpKSB7CgkJCXdyYXBfbGluZXMgPSAxOwoJCQlwYXJzZV93cmFwX2FyZ3MoYXJndlsxXSwgJmluMSwgJmluMiwgJndyYXApOwoJCX0KCQllbHNlIGlmICghc3RyY21wKGFyZ3ZbMV0sICItaCIpIHx8ICFzdHJjbXAoYXJndlsxXSwgIi0taGVscCIpKQoJCQl1c2FnZShzaG9ydGxvZ191c2FnZSk7CgkJZWxzZQoJCQlicmVhazsKCQlhcmd2Kys7CgkJYXJnYy0tOwoJfQoJaW5pdF9yZXZpc2lvbnMoJnJldiwgcHJlZml4KTsKCWFyZ2MgPSBzZXR1cF9yZXZpc2lvbnMoYXJnYywgYXJndiwgJnJldiwgTlVMTCk7CglpZiAoYXJnYyA+IDEpCgkJZGllICgidW5yZWNvZ25pemVkIGFyZ3VtZW50OiAlcyIsIGFyZ3ZbMV0pOwoKCXJlYWRfbWFpbG1hcCgmbWFpbG1hcCwgIi5tYWlsbWFwIiwgJmNvbW1vbl9yZXBvX3ByZWZpeCk7CgoJLyogYXNzdW1lIEhFQUQgaWYgZnJvbSBhIHR0eSAqLwoJaWYgKCFyZXYucGVuZGluZy5uciAmJiBpc2F0dHkoMCkpCgkJYWRkX2hlYWRfdG9fcGVuZGluZygmcmV2KTsKCWlmIChyZXYucGVuZGluZy5uciA9PSAwKSB7CgkJcmVhZF9mcm9tX3N0ZGluKCZsaXN0KTsKCX0KCWVsc2UKCQlnZXRfZnJvbV9yZXYoJnJldiwgJmxpc3QpOwoKCWlmIChzb3J0X2J5X251bWJlcikKCQlxc29ydChsaXN0Lml0ZW1zLCBsaXN0Lm5yLCBzaXplb2Yoc3RydWN0IHBhdGhfbGlzdF9pdGVtKSwKCQkJY29tcGFyZV9ieV9udW1iZXIpOwoKCWZvciAoaSA9IDA7IGkgPCBsaXN0Lm5yOyBpKyspIHsKCQlzdHJ1Y3QgcGF0aF9saXN0ICpvbmVsaW5lcyA9IGxpc3QuaXRlbXNbaV0udXRpbDsKCgkJaWYgKHN1bW1hcnkpIHsKCQkJcHJpbnRmKCIlNmRcdCVzXG4iLCBvbmVsaW5lcy0+bnIsIGxpc3QuaXRlbXNbaV0ucGF0aCk7CgkJfSBlbHNlIHsKCQkJcHJpbnRmKCIlcyAoJWQpOlxuIiwgbGlzdC5pdGVtc1tpXS5wYXRoLCBvbmVsaW5lcy0+bnIpOwoJCQlmb3IgKGogPSBvbmVsaW5lcy0+bnIgLSAxOyBqID49IDA7IGotLSkgewoJCQkJY29uc3QgY2hhciAqbXNnID0gb25lbGluZXMtPml0ZW1zW2pdLnBhdGg7CgoJCQkJaWYgKHdyYXBfbGluZXMpIHsKCQkJCQlpbnQgY29sID0gcHJpbnRfd3JhcHBlZF90ZXh0KG1zZywgaW4xLCBpbjIsIHdyYXApOwoJCQkJCWlmIChjb2wgIT0gd3JhcCkKCQkJCQkJcHV0Y2hhcignXG4nKTsKCQkJCX0KCQkJCWVsc2UKCQkJCQlwcmludGYoIiAgICAgICVzXG4iLCBtc2cpOwoJCQl9CgkJCXB1dGNoYXIoJ1xuJyk7CgkJfQoKCQlvbmVsaW5lcy0+c3RyZHVwX3BhdGhzID0gMTsKCQlwYXRoX2xpc3RfY2xlYXIob25lbGluZXMsIDEpOwoJCWZyZWUob25lbGluZXMpOwoJCWxpc3QuaXRlbXNbaV0udXRpbCA9IE5VTEw7Cgl9CgoJbGlzdC5zdHJkdXBfcGF0aHMgPSAxOwoJcGF0aF9saXN0X2NsZWFyKCZsaXN0LCAxKTsKCW1haWxtYXAuc3RyZHVwX3BhdGhzID0gMTsKCXBhdGhfbGlzdF9jbGVhcigmbWFpbG1hcCwgMSk7CgoJcmV0dXJuIDA7Cn0K",
    "text": "#include \"builtin.h\"\n#include \"cache.h\"\n#include \"commit.h\"\n#include \"diff.h\"\n#include \"path-list.h\"\n#include \"revision.h\"\n#include \"utf8.h\"\n#include \"mailmap.h\"\n\nstatic const char shortlog_usage[] =\n\"git-shortlog [-n] [-s] [-e] [<commit-id>... ]\";\n\nstatic char *common_repo_prefix;\nstatic int email;\n\nstatic int compare_by_number(const void *a1, const void *a2)\n{\n\tconst struct path_list_item *i1 = a1, *i2 = a2;\n\tconst struct path_list *l1 = i1->util, *l2 = i2->util;\n\n\tif (l1->nr < l2->nr)\n\t\treturn 1;\n\telse if (l1->nr == l2->nr)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}\n\nstatic struct path_list mailmap = {NULL, 0, 0, 0};\n\nstatic void insert_one_record(struct path_list *list,\n\t\t\t      const char *author,\n\t\t\t      const char *oneline)\n{\n\tconst char *dot3 = common_repo_prefix;\n\tchar *buffer, *p;\n\tstruct path_list_item *item;\n\tstruct path_list *onelines;\n\tchar namebuf[1024];\n\tsize_t len;\n\tconst char *eol;\n\tconst char *boemail, *eoemail;\n\n\tboemail = strchr(author, '<');\n\tif (!boemail)\n\t\treturn;\n\teoemail = strchr(boemail, '>');\n\tif (!eoemail)\n\t\treturn;\n\tif (!map_email(&mailmap, boemail+1, namebuf, sizeof(namebuf))) {\n\t\twhile (author < boemail && isspace(*author))\n\t\t\tauthor++;\n\t\tfor (len = 0;\n\t\t     len < sizeof(namebuf) - 1 && author + len < boemail;\n\t\t     len++)\n\t\t\tnamebuf[len] = author[len];\n\t\twhile (0 < len && isspace(namebuf[len-1]))\n\t\t\tlen--;\n\t\tnamebuf[len] = '\\0';\n\t}\n\telse\n\t\tlen = strlen(namebuf);\n\n\tif (email) {\n\t\tsize_t room = sizeof(namebuf) - len - 1;\n\t\tint maillen = eoemail - boemail + 1;\n\t\tsnprintf(namebuf + len, room, \" %.*s\", maillen, boemail);\n\t}\n\n\tbuffer = xstrdup(namebuf);\n\titem = path_list_insert(buffer, list);\n\tif (item->util == NULL)\n\t\titem->util = xcalloc(1, sizeof(struct path_list));\n\telse\n\t\tfree(buffer);\n\n\teol = strchr(oneline, '\\n');\n\tif (!eol)\n\t\teol = oneline + strlen(oneline);\n\twhile (*oneline && isspace(*oneline) && *oneline != '\\n')\n\t\toneline++;\n\tif (!prefixcmp(oneline, \"[PATCH\")) {\n\t\tchar *eob = strchr(oneline, ']');\n\t\tif (eob && (!eol || eob < eol))\n\t\t\toneline = eob + 1;\n\t}\n\twhile (*oneline && isspace(*oneline) && *oneline != '\\n')\n\t\toneline++;\n\tlen = eol - oneline;\n\twhile (len && isspace(oneline[len-1]))\n\t\tlen--;\n\tbuffer = xmemdupz(oneline, len);\n\n\tif (dot3) {\n\t\tint dot3len = strlen(dot3);\n\t\tif (dot3len > 5) {\n\t\t\twhile ((p = strstr(buffer, dot3)) != NULL) {\n\t\t\t\tint taillen = strlen(p) - dot3len;\n\t\t\t\tmemcpy(p, \"/.../\", 5);\n\t\t\t\tmemmove(p + 5, p + dot3len, taillen + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tonelines = item->util;\n\tif (onelines->nr >= onelines->alloc) {\n\t\tonelines->alloc = alloc_nr(onelines->nr);\n\t\tonelines->items = xrealloc(onelines->items,\n\t\t\t\tonelines->alloc\n\t\t\t\t* sizeof(struct path_list_item));\n\t}\n\n\tonelines->items[onelines->nr].util = NULL;\n\tonelines->items[onelines->nr++].path = buffer;\n}\n\nstatic void read_from_stdin(struct path_list *list)\n{\n\tchar author[1024], oneline[1024];\n\n\twhile (fgets(author, sizeof(author), stdin) != NULL) {\n\t\tif (!(author[0] == 'A' || author[0] == 'a') ||\n\t\t    prefixcmp(author + 1, \"uthor: \"))\n\t\t\tcontinue;\n\t\twhile (fgets(oneline, sizeof(oneline), stdin) &&\n\t\t       oneline[0] != '\\n')\n\t\t\t; /* discard headers */\n\t\twhile (fgets(oneline, sizeof(oneline), stdin) &&\n\t\t       oneline[0] == '\\n')\n\t\t\t; /* discard blanks */\n\t\tinsert_one_record(list, author + 8, oneline);\n\t}\n}\n\nstatic void get_from_rev(struct rev_info *rev, struct path_list *list)\n{\n\tstruct commit *commit;\n\n\tif (prepare_revision_walk(rev))\n\t\tdie(\"revision walk setup failed\");\n\twhile ((commit = get_revision(rev)) != NULL) {\n\t\tconst char *author = NULL, *buffer;\n\n\t\tbuffer = commit->buffer;\n\t\twhile (*buffer && *buffer != '\\n') {\n\t\t\tconst char *eol = strchr(buffer, '\\n');\n\n\t\t\tif (eol == NULL)\n\t\t\t\teol = buffer + strlen(buffer);\n\t\t\telse\n\t\t\t\teol++;\n\n\t\t\tif (!prefixcmp(buffer, \"author \"))\n\t\t\t\tauthor = buffer + 7;\n\t\t\tbuffer = eol;\n\t\t}\n\t\tif (!author)\n\t\t\tdie(\"Missing author: %s\",\n\t\t\t    sha1_to_hex(commit->object.sha1));\n\t\tif (*buffer)\n\t\t\tbuffer++;\n\t\tinsert_one_record(list, author, !*buffer ? \"<none>\" : buffer);\n\t}\n}\n\nstatic int parse_uint(char const **arg, int comma)\n{\n\tunsigned long ul;\n\tint ret;\n\tchar *endp;\n\n\tul = strtoul(*arg, &endp, 10);\n\tif (endp != *arg && *endp && *endp != comma)\n\t\treturn -1;\n\tret = (int) ul;\n\tif (ret != ul)\n\t\treturn -1;\n\t*arg = endp;\n\tif (**arg)\n\t\t(*arg)++;\n\treturn ret;\n}\n\nstatic const char wrap_arg_usage[] = \"-w[<width>[,<indent1>[,<indent2>]]]\";\n#define DEFAULT_WRAPLEN 76\n#define DEFAULT_INDENT1 6\n#define DEFAULT_INDENT2 9\n\nstatic void parse_wrap_args(const char *arg, int *in1, int *in2, int *wrap)\n{\n\targ += 2; /* skip -w */\n\n\t*wrap = parse_uint(&arg, ',');\n\tif (*wrap < 0)\n\t\tdie(wrap_arg_usage);\n\t*in1 = parse_uint(&arg, ',');\n\tif (*in1 < 0)\n\t\tdie(wrap_arg_usage);\n\t*in2 = parse_uint(&arg, '\\0');\n\tif (*in2 < 0)\n\t\tdie(wrap_arg_usage);\n\n\tif (!*wrap)\n\t\t*wrap = DEFAULT_WRAPLEN;\n\tif (!*in1)\n\t\t*in1 = DEFAULT_INDENT1;\n\tif (!*in2)\n\t\t*in2 = DEFAULT_INDENT2;\n\tif (*wrap &&\n\t    ((*in1 && *wrap <= *in1) ||\n\t     (*in2 && *wrap <= *in2)))\n\t\tdie(wrap_arg_usage);\n}\n\nint cmd_shortlog(int argc, const char **argv, const char *prefix)\n{\n\tstruct rev_info rev;\n\tstruct path_list list = { NULL, 0, 0, 1 };\n\tint i, j, sort_by_number = 0, summary = 0;\n\tint wrap_lines = 0;\n\tint wrap = DEFAULT_WRAPLEN;\n\tint in1 = DEFAULT_INDENT1;\n\tint in2 = DEFAULT_INDENT2;\n\n\t/* since -n is a shadowed rev argument, parse our args first */\n\twhile (argc > 1) {\n\t\tif (!strcmp(argv[1], \"-n\") || !strcmp(argv[1], \"--numbered\"))\n\t\t\tsort_by_number = 1;\n\t\telse if (!strcmp(argv[1], \"-s\") ||\n\t\t\t\t!strcmp(argv[1], \"--summary\"))\n\t\t\tsummary = 1;\n\t\telse if (!strcmp(argv[1], \"-e\") ||\n\t\t\t !strcmp(argv[1], \"--email\"))\n\t\t\temail = 1;\n\t\telse if (!prefixcmp(argv[1], \"-w\")) {\n\t\t\twrap_lines = 1;\n\t\t\tparse_wrap_args(argv[1], &in1, &in2, &wrap);\n\t\t}\n\t\telse if (!strcmp(argv[1], \"-h\") || !strcmp(argv[1], \"--help\"))\n\t\t\tusage(shortlog_usage);\n\t\telse\n\t\t\tbreak;\n\t\targv++;\n\t\targc--;\n\t}\n\tinit_revisions(&rev, prefix);\n\targc = setup_revisions(argc, argv, &rev, NULL);\n\tif (argc > 1)\n\t\tdie (\"unrecognized argument: %s\", argv[1]);\n\n\tread_mailmap(&mailmap, \".mailmap\", &common_repo_prefix);\n\n\t/* assume HEAD if from a tty */\n\tif (!rev.pending.nr && isatty(0))\n\t\tadd_head_to_pending(&rev);\n\tif (rev.pending.nr == 0) {\n\t\tread_from_stdin(&list);\n\t}\n\telse\n\t\tget_from_rev(&rev, &list);\n\n\tif (sort_by_number)\n\t\tqsort(list.items, list.nr, sizeof(struct path_list_item),\n\t\t\tcompare_by_number);\n\n\tfor (i = 0; i < list.nr; i++) {\n\t\tstruct path_list *onelines = list.items[i].util;\n\n\t\tif (summary) {\n\t\t\tprintf(\"%6d\\t%s\\n\", onelines->nr, list.items[i].path);\n\t\t} else {\n\t\t\tprintf(\"%s (%d):\\n\", list.items[i].path, onelines->nr);\n\t\t\tfor (j = onelines->nr - 1; j >= 0; j--) {\n\t\t\t\tconst char *msg = onelines->items[j].path;\n\n\t\t\t\tif (wrap_lines) {\n\t\t\t\t\tint col = print_wrapped_text(msg, in1, in2, wrap);\n\t\t\t\t\tif (col != wrap)\n\t\t\t\t\t\tputchar('\\n');\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tprintf(\"      %s\\n\", msg);\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\n\t\tonelines->strdup_paths = 1;\n\t\tpath_list_clear(onelines, 1);\n\t\tfree(onelines);\n\t\tlist.items[i].util = NULL;\n\t}\n\n\tlist.strdup_paths = 1;\n\tpath_list_clear(&list, 1);\n\tmailmap.strdup_paths = 1;\n\tpath_list_clear(&mailmap, 1);\n\n\treturn 0;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0055a57aeb24392de0dcf337bb93f30fceccd88f",
  "sha1_ok": true,
  "size": 7074
}
