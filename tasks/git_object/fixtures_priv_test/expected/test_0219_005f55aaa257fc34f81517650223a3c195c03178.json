{
  "content": {
    "base64": "LyoKICogQmxhbWUKICoKICogQ29weXJpZ2h0IChjKSAyMDA2LCAyMDE0IGJ5IGl0cyBhdXRob3JzCiAqIFNlZSBDT1BZSU5HIGZvciBsaWNlbnNpbmcgY29uZGl0aW9ucwogKi8KCiNpbmNsdWRlICJjYWNoZS5oIgojaW5jbHVkZSAiY29uZmlnLmgiCiNpbmNsdWRlICJidWlsdGluLmgiCiNpbmNsdWRlICJjb21taXQuaCIKI2luY2x1ZGUgImRpZmYuaCIKI2luY2x1ZGUgInJldmlzaW9uLmgiCiNpbmNsdWRlICJxdW90ZS5oIgojaW5jbHVkZSAic3RyaW5nLWxpc3QuaCIKI2luY2x1ZGUgIm1haWxtYXAuaCIKI2luY2x1ZGUgInBhcnNlLW9wdGlvbnMuaCIKI2luY2x1ZGUgInByaW8tcXVldWUuaCIKI2luY2x1ZGUgInV0ZjguaCIKI2luY2x1ZGUgInVzZXJkaWZmLmgiCiNpbmNsdWRlICJsaW5lLXJhbmdlLmgiCiNpbmNsdWRlICJsaW5lLWxvZy5oIgojaW5jbHVkZSAiZGlyLmgiCiNpbmNsdWRlICJwcm9ncmVzcy5oIgojaW5jbHVkZSAiYmxhbWUuaCIKCnN0YXRpYyBjaGFyIGJsYW1lX3VzYWdlW10gPSBOXygiZ2l0IGJsYW1lIFs8b3B0aW9ucz5dIFs8cmV2LW9wdHM+XSBbPHJldj5dIFstLV0gPGZpbGU+Iik7CgpzdGF0aWMgY29uc3QgY2hhciAqYmxhbWVfb3B0X3VzYWdlW10gPSB7CglibGFtZV91c2FnZSwKCSIiLAoJTl8oIjxyZXYtb3B0cz4gYXJlIGRvY3VtZW50ZWQgaW4gZ2l0LXJldi1saXN0KDEpIiksCglOVUxMCn07CgpzdGF0aWMgaW50IGxvbmdlc3RfZmlsZTsKc3RhdGljIGludCBsb25nZXN0X2F1dGhvcjsKc3RhdGljIGludCBtYXhfb3JpZ19kaWdpdHM7CnN0YXRpYyBpbnQgbWF4X2RpZ2l0czsKc3RhdGljIGludCBtYXhfc2NvcmVfZGlnaXRzOwpzdGF0aWMgaW50IHNob3dfcm9vdDsKc3RhdGljIGludCByZXZlcnNlOwpzdGF0aWMgaW50IGJsYW5rX2JvdW5kYXJ5OwpzdGF0aWMgaW50IGluY3JlbWVudGFsOwpzdGF0aWMgaW50IHhkbF9vcHRzOwpzdGF0aWMgaW50IGFiYnJldiA9IC0xOwpzdGF0aWMgaW50IG5vX3dob2xlX2ZpbGVfcmVuYW1lOwpzdGF0aWMgaW50IHNob3dfcHJvZ3Jlc3M7CgpzdGF0aWMgc3RydWN0IGRhdGVfbW9kZSBibGFtZV9kYXRlX21vZGUgPSB7IERBVEVfSVNPODYwMSB9OwpzdGF0aWMgc2l6ZV90IGJsYW1lX2RhdGVfd2lkdGg7CgpzdGF0aWMgc3RydWN0IHN0cmluZ19saXN0IG1haWxtYXAgPSBTVFJJTkdfTElTVF9JTklUX05PRFVQOwoKI2lmbmRlZiBERUJVRwojZGVmaW5lIERFQlVHIDAKI2VuZGlmCgpzdGF0aWMgdW5zaWduZWQgYmxhbWVfbW92ZV9zY29yZTsKc3RhdGljIHVuc2lnbmVkIGJsYW1lX2NvcHlfc2NvcmU7CgovKiBSZW1lbWJlciB0byB1cGRhdGUgb2JqZWN0IGZsYWcgYWxsb2NhdGlvbiBpbiBvYmplY3QuaCAqLwojZGVmaW5lIE1FVEFJTkZPX1NIT1dOCQkoMXU8PDEyKQojZGVmaW5lIE1PUkVfVEhBTl9PTkVfUEFUSAkoMXU8PDEzKQoKc3RydWN0IHByb2dyZXNzX2luZm8gewoJc3RydWN0IHByb2dyZXNzICpwcm9ncmVzczsKCWludCBibGFtZWRfbGluZXM7Cn07CgpzdGF0aWMgY29uc3QgY2hhciAqbnRoX2xpbmVfY2Iodm9pZCAqZGF0YSwgbG9uZyBsbm8pCnsKCXJldHVybiBibGFtZV9udGhfbGluZSgoc3RydWN0IGJsYW1lX3Njb3JlYm9hcmQgKilkYXRhLCBsbm8pOwp9CgovKgogKiBJbmZvcm1hdGlvbiBvbiBjb21taXRzLCB1c2VkIGZvciBvdXRwdXQuCiAqLwpzdHJ1Y3QgY29tbWl0X2luZm8gewoJc3RydWN0IHN0cmJ1ZiBhdXRob3I7CglzdHJ1Y3Qgc3RyYnVmIGF1dGhvcl9tYWlsOwoJdGltZXN0YW1wX3QgYXV0aG9yX3RpbWU7CglzdHJ1Y3Qgc3RyYnVmIGF1dGhvcl90ejsKCgkvKiBmaWxsZWQgb25seSB3aGVuIGFza2VkIGZvciBkZXRhaWxzICovCglzdHJ1Y3Qgc3RyYnVmIGNvbW1pdHRlcjsKCXN0cnVjdCBzdHJidWYgY29tbWl0dGVyX21haWw7Cgl0aW1lc3RhbXBfdCBjb21taXR0ZXJfdGltZTsKCXN0cnVjdCBzdHJidWYgY29tbWl0dGVyX3R6OwoKCXN0cnVjdCBzdHJidWYgc3VtbWFyeTsKfTsKCi8qCiAqIFBhcnNlIGF1dGhvci9jb21taXR0ZXIgbGluZSBpbiB0aGUgY29tbWl0IG9iamVjdCBidWZmZXIKICovCnN0YXRpYyB2b2lkIGdldF9hY19saW5lKGNvbnN0IGNoYXIgKmluYnVmLCBjb25zdCBjaGFyICp3aGF0LAoJc3RydWN0IHN0cmJ1ZiAqbmFtZSwgc3RydWN0IHN0cmJ1ZiAqbWFpbCwKCXRpbWVzdGFtcF90ICp0aW1lLCBzdHJ1Y3Qgc3RyYnVmICp0eikKewoJc3RydWN0IGlkZW50X3NwbGl0IGlkZW50OwoJc2l6ZV90IGxlbiwgbWFpbGxlbiwgbmFtZWxlbjsKCWNoYXIgKnRtcCwgKmVuZHA7Cgljb25zdCBjaGFyICpuYW1lYnVmLCAqbWFpbGJ1ZjsKCgl0bXAgPSBzdHJzdHIoaW5idWYsIHdoYXQpOwoJaWYgKCF0bXApCgkJZ290byBlcnJvcl9vdXQ7Cgl0bXAgKz0gc3RybGVuKHdoYXQpOwoJZW5kcCA9IHN0cmNocih0bXAsICdcbicpOwoJaWYgKCFlbmRwKQoJCWxlbiA9IHN0cmxlbih0bXApOwoJZWxzZQoJCWxlbiA9IGVuZHAgLSB0bXA7CgoJaWYgKHNwbGl0X2lkZW50X2xpbmUoJmlkZW50LCB0bXAsIGxlbikpIHsKCWVycm9yX291dDoKCQkvKiBVZ2ggKi8KCQl0bXAgPSAiKHVua25vd24pIjsKCQlzdHJidWZfYWRkc3RyKG5hbWUsIHRtcCk7CgkJc3RyYnVmX2FkZHN0cihtYWlsLCB0bXApOwoJCXN0cmJ1Zl9hZGRzdHIodHosIHRtcCk7CgkJKnRpbWUgPSAwOwoJCXJldHVybjsKCX0KCgluYW1lbGVuID0gaWRlbnQubmFtZV9lbmQgLSBpZGVudC5uYW1lX2JlZ2luOwoJbmFtZWJ1ZiA9IGlkZW50Lm5hbWVfYmVnaW47CgoJbWFpbGxlbiA9IGlkZW50Lm1haWxfZW5kIC0gaWRlbnQubWFpbF9iZWdpbjsKCW1haWxidWYgPSBpZGVudC5tYWlsX2JlZ2luOwoKCWlmIChpZGVudC5kYXRlX2JlZ2luICYmIGlkZW50LmRhdGVfZW5kKQoJCSp0aW1lID0gc3RydG91bChpZGVudC5kYXRlX2JlZ2luLCBOVUxMLCAxMCk7CgllbHNlCgkJKnRpbWUgPSAwOwoKCWlmIChpZGVudC50el9iZWdpbiAmJiBpZGVudC50el9lbmQpCgkJc3RyYnVmX2FkZCh0eiwgaWRlbnQudHpfYmVnaW4sIGlkZW50LnR6X2VuZCAtIGlkZW50LnR6X2JlZ2luKTsKCWVsc2UKCQlzdHJidWZfYWRkc3RyKHR6LCAiKHVua25vd24pIik7CgoJLyoKCSAqIE5vdywgY29udmVydCBib3RoIG5hbWUgYW5kIGUtbWFpbCB1c2luZyBtYWlsbWFwCgkgKi8KCW1hcF91c2VyKCZtYWlsbWFwLCAmbWFpbGJ1ZiwgJm1haWxsZW4sCgkJICZuYW1lYnVmLCAmbmFtZWxlbik7CgoJc3RyYnVmX2FkZGYobWFpbCwgIjwlLipzPiIsIChpbnQpbWFpbGxlbiwgbWFpbGJ1Zik7CglzdHJidWZfYWRkKG5hbWUsIG5hbWVidWYsIG5hbWVsZW4pOwp9CgpzdGF0aWMgdm9pZCBjb21taXRfaW5mb19pbml0KHN0cnVjdCBjb21taXRfaW5mbyAqY2kpCnsKCglzdHJidWZfaW5pdCgmY2ktPmF1dGhvciwgMCk7CglzdHJidWZfaW5pdCgmY2ktPmF1dGhvcl9tYWlsLCAwKTsKCXN0cmJ1Zl9pbml0KCZjaS0+YXV0aG9yX3R6LCAwKTsKCXN0cmJ1Zl9pbml0KCZjaS0+Y29tbWl0dGVyLCAwKTsKCXN0cmJ1Zl9pbml0KCZjaS0+Y29tbWl0dGVyX21haWwsIDApOwoJc3RyYnVmX2luaXQoJmNpLT5jb21taXR0ZXJfdHosIDApOwoJc3RyYnVmX2luaXQoJmNpLT5zdW1tYXJ5LCAwKTsKfQoKc3RhdGljIHZvaWQgY29tbWl0X2luZm9fZGVzdHJveShzdHJ1Y3QgY29tbWl0X2luZm8gKmNpKQp7CgoJc3RyYnVmX3JlbGVhc2UoJmNpLT5hdXRob3IpOwoJc3RyYnVmX3JlbGVhc2UoJmNpLT5hdXRob3JfbWFpbCk7CglzdHJidWZfcmVsZWFzZSgmY2ktPmF1dGhvcl90eik7CglzdHJidWZfcmVsZWFzZSgmY2ktPmNvbW1pdHRlcik7CglzdHJidWZfcmVsZWFzZSgmY2ktPmNvbW1pdHRlcl9tYWlsKTsKCXN0cmJ1Zl9yZWxlYXNlKCZjaS0+Y29tbWl0dGVyX3R6KTsKCXN0cmJ1Zl9yZWxlYXNlKCZjaS0+c3VtbWFyeSk7Cn0KCnN0YXRpYyB2b2lkIGdldF9jb21taXRfaW5mbyhzdHJ1Y3QgY29tbWl0ICpjb21taXQsCgkJCSAgICBzdHJ1Y3QgY29tbWl0X2luZm8gKnJldCwKCQkJICAgIGludCBkZXRhaWxlZCkKewoJaW50IGxlbjsKCWNvbnN0IGNoYXIgKnN1YmplY3QsICplbmNvZGluZzsKCWNvbnN0IGNoYXIgKm1lc3NhZ2U7CgoJY29tbWl0X2luZm9faW5pdChyZXQpOwoKCWVuY29kaW5nID0gZ2V0X2xvZ19vdXRwdXRfZW5jb2RpbmcoKTsKCW1lc3NhZ2UgPSBsb2dtc2dfcmVlbmNvZGUoY29tbWl0LCBOVUxMLCBlbmNvZGluZyk7CglnZXRfYWNfbGluZShtZXNzYWdlLCAiXG5hdXRob3IgIiwKCQkgICAgJnJldC0+YXV0aG9yLCAmcmV0LT5hdXRob3JfbWFpbCwKCQkgICAgJnJldC0+YXV0aG9yX3RpbWUsICZyZXQtPmF1dGhvcl90eik7CgoJaWYgKCFkZXRhaWxlZCkgewoJCXVudXNlX2NvbW1pdF9idWZmZXIoY29tbWl0LCBtZXNzYWdlKTsKCQlyZXR1cm47Cgl9CgoJZ2V0X2FjX2xpbmUobWVzc2FnZSwgIlxuY29tbWl0dGVyICIsCgkJICAgICZyZXQtPmNvbW1pdHRlciwgJnJldC0+Y29tbWl0dGVyX21haWwsCgkJICAgICZyZXQtPmNvbW1pdHRlcl90aW1lLCAmcmV0LT5jb21taXR0ZXJfdHopOwoKCWxlbiA9IGZpbmRfY29tbWl0X3N1YmplY3QobWVzc2FnZSwgJnN1YmplY3QpOwoJaWYgKGxlbikKCQlzdHJidWZfYWRkKCZyZXQtPnN1bW1hcnksIHN1YmplY3QsIGxlbik7CgllbHNlCgkJc3RyYnVmX2FkZGYoJnJldC0+c3VtbWFyeSwgIiglcykiLCBvaWRfdG9faGV4KCZjb21taXQtPm9iamVjdC5vaWQpKTsKCgl1bnVzZV9jb21taXRfYnVmZmVyKGNvbW1pdCwgbWVzc2FnZSk7Cn0KCi8qCiAqIFdyaXRlIG91dCBhbnkgc3VzcGVjdCBpbmZvcm1hdGlvbiB3aGljaCBkZXBlbmRzIG9uIHRoZSBwYXRoLiBUaGlzIG11c3QgYmUKICogaGFuZGxlZCBzZXBhcmF0ZWx5IGZyb20gZW1pdF9vbmVfc3VzcGVjdF9kZXRhaWwoKSwgYmVjYXVzZSBhIGdpdmVuIGNvbW1pdAogKiBtYXkgaGF2ZSBjaGFuZ2VzIGluIG11bHRpcGxlIHBhdGhzLiBTbyB0aGlzIG5lZWRzIHRvIGFwcGVhciBlYWNoIHRpbWUKICogd2UgbWVudGlvbiBhIG5ldyBncm91cC4KICoKICogVG8gYWxsb3cgTEYgYW5kIG90aGVyIG5vbnBvcnRhYmxlIGNoYXJhY3RlcnMgaW4gcGF0aG5hbWVzLAogKiB0aGV5IGFyZSBjLXN0eWxlIHF1b3RlZCBhcyBuZWVkZWQuCiAqLwpzdGF0aWMgdm9pZCB3cml0ZV9maWxlbmFtZV9pbmZvKHN0cnVjdCBibGFtZV9vcmlnaW4gKnN1c3BlY3QpCnsKCWlmIChzdXNwZWN0LT5wcmV2aW91cykgewoJCXN0cnVjdCBibGFtZV9vcmlnaW4gKnByZXYgPSBzdXNwZWN0LT5wcmV2aW91czsKCQlwcmludGYoInByZXZpb3VzICVzICIsIG9pZF90b19oZXgoJnByZXYtPmNvbW1pdC0+b2JqZWN0Lm9pZCkpOwoJCXdyaXRlX25hbWVfcXVvdGVkKHByZXYtPnBhdGgsIHN0ZG91dCwgJ1xuJyk7Cgl9CglwcmludGYoImZpbGVuYW1lICIpOwoJd3JpdGVfbmFtZV9xdW90ZWQoc3VzcGVjdC0+cGF0aCwgc3Rkb3V0LCAnXG4nKTsKfQoKLyoKICogUG9yY2VsYWluL0luY3JlbWVudGFsIGZvcm1hdCB3YW50cyB0byBzaG93IGEgbG90IG9mIGRldGFpbHMgcGVyCiAqIGNvbW1pdC4gIEluc3RlYWQgb2YgcmVwZWF0aW5nIHRoaXMgZXZlcnkgbGluZSwgZW1pdCBpdCBvbmx5IG9uY2UsCiAqIHRoZSBmaXJzdCB0aW1lIGVhY2ggY29tbWl0IGFwcGVhcnMgaW4gdGhlIG91dHB1dCAodW5sZXNzIHRoZQogKiB1c2VyIGhhcyBzcGVjaWZpY2FsbHkgYXNrZWQgZm9yIHVzIHRvIHJlcGVhdCkuCiAqLwpzdGF0aWMgaW50IGVtaXRfb25lX3N1c3BlY3RfZGV0YWlsKHN0cnVjdCBibGFtZV9vcmlnaW4gKnN1c3BlY3QsIGludCByZXBlYXQpCnsKCXN0cnVjdCBjb21taXRfaW5mbyBjaTsKCglpZiAoIXJlcGVhdCAmJiAoc3VzcGVjdC0+Y29tbWl0LT5vYmplY3QuZmxhZ3MgJiBNRVRBSU5GT19TSE9XTikpCgkJcmV0dXJuIDA7CgoJc3VzcGVjdC0+Y29tbWl0LT5vYmplY3QuZmxhZ3MgfD0gTUVUQUlORk9fU0hPV047CglnZXRfY29tbWl0X2luZm8oc3VzcGVjdC0+Y29tbWl0LCAmY2ksIDEpOwoJcHJpbnRmKCJhdXRob3IgJXNcbiIsIGNpLmF1dGhvci5idWYpOwoJcHJpbnRmKCJhdXRob3ItbWFpbCAlc1xuIiwgY2kuYXV0aG9yX21haWwuYnVmKTsKCXByaW50ZigiYXV0aG9yLXRpbWUgJSJQUkl0aW1lIlxuIiwgY2kuYXV0aG9yX3RpbWUpOwoJcHJpbnRmKCJhdXRob3ItdHogJXNcbiIsIGNpLmF1dGhvcl90ei5idWYpOwoJcHJpbnRmKCJjb21taXR0ZXIgJXNcbiIsIGNpLmNvbW1pdHRlci5idWYpOwoJcHJpbnRmKCJjb21taXR0ZXItbWFpbCAlc1xuIiwgY2kuY29tbWl0dGVyX21haWwuYnVmKTsKCXByaW50ZigiY29tbWl0dGVyLXRpbWUgJSJQUkl0aW1lIlxuIiwgY2kuY29tbWl0dGVyX3RpbWUpOwoJcHJpbnRmKCJjb21taXR0ZXItdHogJXNcbiIsIGNpLmNvbW1pdHRlcl90ei5idWYpOwoJcHJpbnRmKCJzdW1tYXJ5ICVzXG4iLCBjaS5zdW1tYXJ5LmJ1Zik7CglpZiAoc3VzcGVjdC0+Y29tbWl0LT5vYmplY3QuZmxhZ3MgJiBVTklOVEVSRVNUSU5HKQoJCXByaW50ZigiYm91bmRhcnlcbiIpOwoKCWNvbW1pdF9pbmZvX2Rlc3Ryb3koJmNpKTsKCglyZXR1cm4gMTsKfQoKLyoKICogVGhlIGJsYW1lX2VudHJ5IGlzIGZvdW5kIHRvIGJlIGd1aWx0eSBmb3IgdGhlIHJhbmdlLgogKiBTaG93IGl0IGluIGluY3JlbWVudGFsIG91dHB1dC4KICovCnN0YXRpYyB2b2lkIGZvdW5kX2d1aWx0eV9lbnRyeShzdHJ1Y3QgYmxhbWVfZW50cnkgKmVudCwgdm9pZCAqZGF0YSkKewoJc3RydWN0IHByb2dyZXNzX2luZm8gKnBpID0gKHN0cnVjdCBwcm9ncmVzc19pbmZvICopZGF0YTsKCglpZiAoaW5jcmVtZW50YWwpIHsKCQlzdHJ1Y3QgYmxhbWVfb3JpZ2luICpzdXNwZWN0ID0gZW50LT5zdXNwZWN0OwoKCQlwcmludGYoIiVzICVkICVkICVkXG4iLAoJCSAgICAgICBvaWRfdG9faGV4KCZzdXNwZWN0LT5jb21taXQtPm9iamVjdC5vaWQpLAoJCSAgICAgICBlbnQtPnNfbG5vICsgMSwgZW50LT5sbm8gKyAxLCBlbnQtPm51bV9saW5lcyk7CgkJZW1pdF9vbmVfc3VzcGVjdF9kZXRhaWwoc3VzcGVjdCwgMCk7CgkJd3JpdGVfZmlsZW5hbWVfaW5mbyhzdXNwZWN0KTsKCQltYXliZV9mbHVzaF9vcl9kaWUoc3Rkb3V0LCAic3Rkb3V0Iik7Cgl9CglwaS0+YmxhbWVkX2xpbmVzICs9IGVudC0+bnVtX2xpbmVzOwoJZGlzcGxheV9wcm9ncmVzcyhwaS0+cHJvZ3Jlc3MsIHBpLT5ibGFtZWRfbGluZXMpOwp9CgpzdGF0aWMgY29uc3QgY2hhciAqZm9ybWF0X3RpbWUodGltZXN0YW1wX3QgdGltZSwgY29uc3QgY2hhciAqdHpfc3RyLAoJCQkgICAgICAgaW50IHNob3dfcmF3X3RpbWUpCnsKCXN0YXRpYyBzdHJ1Y3Qgc3RyYnVmIHRpbWVfYnVmID0gU1RSQlVGX0lOSVQ7CgoJc3RyYnVmX3Jlc2V0KCZ0aW1lX2J1Zik7CglpZiAoc2hvd19yYXdfdGltZSkgewoJCXN0cmJ1Zl9hZGRmKCZ0aW1lX2J1ZiwgIiUiUFJJdGltZSIgJXMiLCB0aW1lLCB0el9zdHIpOwoJfQoJZWxzZSB7CgkJY29uc3QgY2hhciAqdGltZV9zdHI7CgkJc2l6ZV90IHRpbWVfd2lkdGg7CgkJaW50IHR6OwoJCXR6ID0gYXRvaSh0el9zdHIpOwoJCXRpbWVfc3RyID0gc2hvd19kYXRlKHRpbWUsIHR6LCAmYmxhbWVfZGF0ZV9tb2RlKTsKCQlzdHJidWZfYWRkc3RyKCZ0aW1lX2J1ZiwgdGltZV9zdHIpOwoJCS8qCgkJICogQWRkIHNwYWNlIHBhZGRpbmdzIHRvIHRpbWVfYnVmIHRvIGRpc3BsYXkgYSBmaXhlZCB3aWR0aAoJCSAqIHN0cmluZywgYW5kIHVzZSB0aW1lX3dpZHRoIGZvciBkaXNwbGF5IHdpZHRoIGNhbGlicmF0aW9uLgoJCSAqLwoJCWZvciAodGltZV93aWR0aCA9IHV0Zjhfc3Ryd2lkdGgodGltZV9zdHIpOwoJCSAgICAgdGltZV93aWR0aCA8IGJsYW1lX2RhdGVfd2lkdGg7CgkJICAgICB0aW1lX3dpZHRoKyspCgkJCXN0cmJ1Zl9hZGRjaCgmdGltZV9idWYsICcgJyk7Cgl9CglyZXR1cm4gdGltZV9idWYuYnVmOwp9CgojZGVmaW5lIE9VVFBVVF9BTk5PVEFURV9DT01QQVQJMDAxCiNkZWZpbmUgT1VUUFVUX0xPTkdfT0JKRUNUX05BTUUJMDAyCiNkZWZpbmUgT1VUUFVUX1JBV19USU1FU1RBTVAJMDA0CiNkZWZpbmUgT1VUUFVUX1BPUkNFTEFJTgkwMTAKI2RlZmluZSBPVVRQVVRfU0hPV19OQU1FCTAyMAojZGVmaW5lIE9VVFBVVF9TSE9XX05VTUJFUgkwNDAKI2RlZmluZSBPVVRQVVRfU0hPV19TQ09SRSAgICAgIDAxMDAKI2RlZmluZSBPVVRQVVRfTk9fQVVUSE9SICAgICAgIDAyMDAKI2RlZmluZSBPVVRQVVRfU0hPV19FTUFJTAkwNDAwCiNkZWZpbmUgT1VUUFVUX0xJTkVfUE9SQ0VMQUlOIDAxMDAwCgpzdGF0aWMgdm9pZCBlbWl0X3BvcmNlbGFpbl9kZXRhaWxzKHN0cnVjdCBibGFtZV9vcmlnaW4gKnN1c3BlY3QsIGludCByZXBlYXQpCnsKCWlmIChlbWl0X29uZV9zdXNwZWN0X2RldGFpbChzdXNwZWN0LCByZXBlYXQpIHx8CgkgICAgKHN1c3BlY3QtPmNvbW1pdC0+b2JqZWN0LmZsYWdzICYgTU9SRV9USEFOX09ORV9QQVRIKSkKCQl3cml0ZV9maWxlbmFtZV9pbmZvKHN1c3BlY3QpOwp9CgpzdGF0aWMgdm9pZCBlbWl0X3BvcmNlbGFpbihzdHJ1Y3QgYmxhbWVfc2NvcmVib2FyZCAqc2IsIHN0cnVjdCBibGFtZV9lbnRyeSAqZW50LAoJCQkgICBpbnQgb3B0KQp7CglpbnQgcmVwZWF0ID0gb3B0ICYgT1VUUFVUX0xJTkVfUE9SQ0VMQUlOOwoJaW50IGNudDsKCWNvbnN0IGNoYXIgKmNwOwoJc3RydWN0IGJsYW1lX29yaWdpbiAqc3VzcGVjdCA9IGVudC0+c3VzcGVjdDsKCWNoYXIgaGV4W0dJVF9NQVhfSEVYU1ogKyAxXTsKCglvaWRfdG9faGV4X3IoaGV4LCAmc3VzcGVjdC0+Y29tbWl0LT5vYmplY3Qub2lkKTsKCXByaW50ZigiJXMgJWQgJWQgJWRcbiIsCgkgICAgICAgaGV4LAoJICAgICAgIGVudC0+c19sbm8gKyAxLAoJICAgICAgIGVudC0+bG5vICsgMSwKCSAgICAgICBlbnQtPm51bV9saW5lcyk7CgllbWl0X3BvcmNlbGFpbl9kZXRhaWxzKHN1c3BlY3QsIHJlcGVhdCk7CgoJY3AgPSBibGFtZV9udGhfbGluZShzYiwgZW50LT5sbm8pOwoJZm9yIChjbnQgPSAwOyBjbnQgPCBlbnQtPm51bV9saW5lczsgY250KyspIHsKCQljaGFyIGNoOwoJCWlmIChjbnQpIHsKCQkJcHJpbnRmKCIlcyAlZCAlZFxuIiwgaGV4LAoJCQkgICAgICAgZW50LT5zX2xubyArIDEgKyBjbnQsCgkJCSAgICAgICBlbnQtPmxubyArIDEgKyBjbnQpOwoJCQlpZiAocmVwZWF0KQoJCQkJZW1pdF9wb3JjZWxhaW5fZGV0YWlscyhzdXNwZWN0LCAxKTsKCQl9CgkJcHV0Y2hhcignXHQnKTsKCQlkbyB7CgkJCWNoID0gKmNwKys7CgkJCXB1dGNoYXIoY2gpOwoJCX0gd2hpbGUgKGNoICE9ICdcbicgJiYKCQkJIGNwIDwgc2ItPmZpbmFsX2J1ZiArIHNiLT5maW5hbF9idWZfc2l6ZSk7Cgl9CgoJaWYgKHNiLT5maW5hbF9idWZfc2l6ZSAmJiBjcFstMV0gIT0gJ1xuJykKCQlwdXRjaGFyKCdcbicpOwp9CgpzdGF0aWMgdm9pZCBlbWl0X290aGVyKHN0cnVjdCBibGFtZV9zY29yZWJvYXJkICpzYiwgc3RydWN0IGJsYW1lX2VudHJ5ICplbnQsIGludCBvcHQpCnsKCWludCBjbnQ7Cgljb25zdCBjaGFyICpjcDsKCXN0cnVjdCBibGFtZV9vcmlnaW4gKnN1c3BlY3QgPSBlbnQtPnN1c3BlY3Q7CglzdHJ1Y3QgY29tbWl0X2luZm8gY2k7CgljaGFyIGhleFtHSVRfTUFYX0hFWFNaICsgMV07CglpbnQgc2hvd19yYXdfdGltZSA9ICEhKG9wdCAmIE9VVFBVVF9SQVdfVElNRVNUQU1QKTsKCglnZXRfY29tbWl0X2luZm8oc3VzcGVjdC0+Y29tbWl0LCAmY2ksIDEpOwoJb2lkX3RvX2hleF9yKGhleCwgJnN1c3BlY3QtPmNvbW1pdC0+b2JqZWN0Lm9pZCk7CgoJY3AgPSBibGFtZV9udGhfbGluZShzYiwgZW50LT5sbm8pOwoJZm9yIChjbnQgPSAwOyBjbnQgPCBlbnQtPm51bV9saW5lczsgY250KyspIHsKCQljaGFyIGNoOwoJCWludCBsZW5ndGggPSAob3B0ICYgT1VUUFVUX0xPTkdfT0JKRUNUX05BTUUpID8gR0lUX1NIQTFfSEVYU1ogOiBhYmJyZXY7CgoJCWlmIChzdXNwZWN0LT5jb21taXQtPm9iamVjdC5mbGFncyAmIFVOSU5URVJFU1RJTkcpIHsKCQkJaWYgKGJsYW5rX2JvdW5kYXJ5KQoJCQkJbWVtc2V0KGhleCwgJyAnLCBsZW5ndGgpOwoJCQllbHNlIGlmICghKG9wdCAmIE9VVFBVVF9BTk5PVEFURV9DT01QQVQpKSB7CgkJCQlsZW5ndGgtLTsKCQkJCXB1dGNoYXIoJ14nKTsKCQkJfQoJCX0KCgkJcHJpbnRmKCIlLipzIiwgbGVuZ3RoLCBoZXgpOwoJCWlmIChvcHQgJiBPVVRQVVRfQU5OT1RBVEVfQ09NUEFUKSB7CgkJCWNvbnN0IGNoYXIgKm5hbWU7CgkJCWlmIChvcHQgJiBPVVRQVVRfU0hPV19FTUFJTCkKCQkJCW5hbWUgPSBjaS5hdXRob3JfbWFpbC5idWY7CgkJCWVsc2UKCQkJCW5hbWUgPSBjaS5hdXRob3IuYnVmOwoJCQlwcmludGYoIlx0KCUxMHNcdCUxMHNcdCVkKSIsIG5hbWUsCgkJCSAgICAgICBmb3JtYXRfdGltZShjaS5hdXRob3JfdGltZSwgY2kuYXV0aG9yX3R6LmJ1ZiwKCQkJCQkgICBzaG93X3Jhd190aW1lKSwKCQkJICAgICAgIGVudC0+bG5vICsgMSArIGNudCk7CgkJfSBlbHNlIHsKCQkJaWYgKG9wdCAmIE9VVFBVVF9TSE9XX1NDT1JFKQoJCQkJcHJpbnRmKCIgJSpkICUwMmQiLAoJCQkJICAgICAgIG1heF9zY29yZV9kaWdpdHMsIGVudC0+c2NvcmUsCgkJCQkgICAgICAgZW50LT5zdXNwZWN0LT5yZWZjbnQpOwoJCQlpZiAob3B0ICYgT1VUUFVUX1NIT1dfTkFNRSkKCQkJCXByaW50ZigiICUtKi4qcyIsIGxvbmdlc3RfZmlsZSwgbG9uZ2VzdF9maWxlLAoJCQkJICAgICAgIHN1c3BlY3QtPnBhdGgpOwoJCQlpZiAob3B0ICYgT1VUUFVUX1NIT1dfTlVNQkVSKQoJCQkJcHJpbnRmKCIgJSpkIiwgbWF4X29yaWdfZGlnaXRzLAoJCQkJICAgICAgIGVudC0+c19sbm8gKyAxICsgY250KTsKCgkJCWlmICghKG9wdCAmIE9VVFBVVF9OT19BVVRIT1IpKSB7CgkJCQljb25zdCBjaGFyICpuYW1lOwoJCQkJaW50IHBhZDsKCQkJCWlmIChvcHQgJiBPVVRQVVRfU0hPV19FTUFJTCkKCQkJCQluYW1lID0gY2kuYXV0aG9yX21haWwuYnVmOwoJCQkJZWxzZQoJCQkJCW5hbWUgPSBjaS5hdXRob3IuYnVmOwoJCQkJcGFkID0gbG9uZ2VzdF9hdXRob3IgLSB1dGY4X3N0cndpZHRoKG5hbWUpOwoJCQkJcHJpbnRmKCIgKCVzJSpzICUxMHMiLAoJCQkJICAgICAgIG5hbWUsIHBhZCwgIiIsCgkJCQkgICAgICAgZm9ybWF0X3RpbWUoY2kuYXV0aG9yX3RpbWUsCgkJCQkJCSAgIGNpLmF1dGhvcl90ei5idWYsCgkJCQkJCSAgIHNob3dfcmF3X3RpbWUpKTsKCQkJfQoJCQlwcmludGYoIiAlKmQpICIsCgkJCSAgICAgICBtYXhfZGlnaXRzLCBlbnQtPmxubyArIDEgKyBjbnQpOwoJCX0KCQlkbyB7CgkJCWNoID0gKmNwKys7CgkJCXB1dGNoYXIoY2gpOwoJCX0gd2hpbGUgKGNoICE9ICdcbicgJiYKCQkJIGNwIDwgc2ItPmZpbmFsX2J1ZiArIHNiLT5maW5hbF9idWZfc2l6ZSk7Cgl9CgoJaWYgKHNiLT5maW5hbF9idWZfc2l6ZSAmJiBjcFstMV0gIT0gJ1xuJykKCQlwdXRjaGFyKCdcbicpOwoKCWNvbW1pdF9pbmZvX2Rlc3Ryb3koJmNpKTsKfQoKc3RhdGljIHZvaWQgb3V0cHV0KHN0cnVjdCBibGFtZV9zY29yZWJvYXJkICpzYiwgaW50IG9wdGlvbikKewoJc3RydWN0IGJsYW1lX2VudHJ5ICplbnQ7CgoJaWYgKG9wdGlvbiAmIE9VVFBVVF9QT1JDRUxBSU4pIHsKCQlmb3IgKGVudCA9IHNiLT5lbnQ7IGVudDsgZW50ID0gZW50LT5uZXh0KSB7CgkJCWludCBjb3VudCA9IDA7CgkJCXN0cnVjdCBibGFtZV9vcmlnaW4gKnN1c3BlY3Q7CgkJCXN0cnVjdCBjb21taXQgKmNvbW1pdCA9IGVudC0+c3VzcGVjdC0+Y29tbWl0OwoJCQlpZiAoY29tbWl0LT5vYmplY3QuZmxhZ3MgJiBNT1JFX1RIQU5fT05FX1BBVEgpCgkJCQljb250aW51ZTsKCQkJZm9yIChzdXNwZWN0ID0gY29tbWl0LT51dGlsOyBzdXNwZWN0OyBzdXNwZWN0ID0gc3VzcGVjdC0+bmV4dCkgewoJCQkJaWYgKHN1c3BlY3QtPmd1aWx0eSAmJiBjb3VudCsrKSB7CgkJCQkJY29tbWl0LT5vYmplY3QuZmxhZ3MgfD0gTU9SRV9USEFOX09ORV9QQVRIOwoJCQkJCWJyZWFrOwoJCQkJfQoJCQl9CgkJfQoJfQoKCWZvciAoZW50ID0gc2ItPmVudDsgZW50OyBlbnQgPSBlbnQtPm5leHQpIHsKCQlpZiAob3B0aW9uICYgT1VUUFVUX1BPUkNFTEFJTikKCQkJZW1pdF9wb3JjZWxhaW4oc2IsIGVudCwgb3B0aW9uKTsKCQllbHNlIHsKCQkJZW1pdF9vdGhlcihzYiwgZW50LCBvcHRpb24pOwoJCX0KCX0KfQoKLyoKICogQWRkIHBob255IGdyYWZ0cyBmb3IgdXNlIHdpdGggLVM7IHRoaXMgaXMgcHJpbWFyaWx5IHRvCiAqIHN1cHBvcnQgZ2l0J3MgY3Zzc2VydmVyIHRoYXQgd2FudHMgdG8gZ2l2ZSBhIGxpbmVhciBoaXN0b3J5CiAqIHRvIGl0cyBjbGllbnRzLgogKi8Kc3RhdGljIGludCByZWFkX2FuY2VzdHJ5KGNvbnN0IGNoYXIgKmdyYWZ0X2ZpbGUpCnsKCUZJTEUgKmZwID0gZm9wZW5fb3Jfd2FybihncmFmdF9maWxlLCAiciIpOwoJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCWlmICghZnApCgkJcmV0dXJuIC0xOwoJd2hpbGUgKCFzdHJidWZfZ2V0d2hvbGVsaW5lKCZidWYsIGZwLCAnXG4nKSkgewoJCS8qIFRoZSBmb3JtYXQgaXMganVzdCAiQ29tbWl0IFBhcmVudDEgUGFyZW50MiAuLi5cbiIgKi8KCQlzdHJ1Y3QgY29tbWl0X2dyYWZ0ICpncmFmdCA9IHJlYWRfZ3JhZnRfbGluZSgmYnVmKTsKCQlpZiAoZ3JhZnQpCgkJCXJlZ2lzdGVyX2NvbW1pdF9ncmFmdChncmFmdCwgMCk7Cgl9CglmY2xvc2UoZnApOwoJc3RyYnVmX3JlbGVhc2UoJmJ1Zik7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCB1cGRhdGVfYXV0b19hYmJyZXYoaW50IGF1dG9fYWJicmV2LCBzdHJ1Y3QgYmxhbWVfb3JpZ2luICpzdXNwZWN0KQp7Cgljb25zdCBjaGFyICp1bmlxID0gZmluZF91bmlxdWVfYWJicmV2KHN1c3BlY3QtPmNvbW1pdC0+b2JqZWN0Lm9pZC5oYXNoLAoJCQkJCSAgICAgIGF1dG9fYWJicmV2KTsKCWludCBsZW4gPSBzdHJsZW4odW5pcSk7CglpZiAoYXV0b19hYmJyZXYgPCBsZW4pCgkJcmV0dXJuIGxlbjsKCXJldHVybiBhdXRvX2FiYnJldjsKfQoKLyoKICogSG93IG1hbnkgY29sdW1ucyBkbyB3ZSBuZWVkIHRvIHNob3cgbGluZSBudW1iZXJzLCBhdXRob3JzLAogKiBhbmQgZmlsZW5hbWVzPwogKi8Kc3RhdGljIHZvaWQgZmluZF9hbGlnbm1lbnQoc3RydWN0IGJsYW1lX3Njb3JlYm9hcmQgKnNiLCBpbnQgKm9wdGlvbikKewoJaW50IGxvbmdlc3Rfc3JjX2xpbmVzID0gMDsKCWludCBsb25nZXN0X2RzdF9saW5lcyA9IDA7Cgl1bnNpZ25lZCBsYXJnZXN0X3Njb3JlID0gMDsKCXN0cnVjdCBibGFtZV9lbnRyeSAqZTsKCWludCBjb21wdXRlX2F1dG9fYWJicmV2ID0gKGFiYnJldiA8IDApOwoJaW50IGF1dG9fYWJicmV2ID0gREVGQVVMVF9BQkJSRVY7CgoJZm9yIChlID0gc2ItPmVudDsgZTsgZSA9IGUtPm5leHQpIHsKCQlzdHJ1Y3QgYmxhbWVfb3JpZ2luICpzdXNwZWN0ID0gZS0+c3VzcGVjdDsKCQlpbnQgbnVtOwoKCQlpZiAoY29tcHV0ZV9hdXRvX2FiYnJldikKCQkJYXV0b19hYmJyZXYgPSB1cGRhdGVfYXV0b19hYmJyZXYoYXV0b19hYmJyZXYsIHN1c3BlY3QpOwoJCWlmIChzdHJjbXAoc3VzcGVjdC0+cGF0aCwgc2ItPnBhdGgpKQoJCQkqb3B0aW9uIHw9IE9VVFBVVF9TSE9XX05BTUU7CgkJbnVtID0gc3RybGVuKHN1c3BlY3QtPnBhdGgpOwoJCWlmIChsb25nZXN0X2ZpbGUgPCBudW0pCgkJCWxvbmdlc3RfZmlsZSA9IG51bTsKCQlpZiAoIShzdXNwZWN0LT5jb21taXQtPm9iamVjdC5mbGFncyAmIE1FVEFJTkZPX1NIT1dOKSkgewoJCQlzdHJ1Y3QgY29tbWl0X2luZm8gY2k7CgkJCXN1c3BlY3QtPmNvbW1pdC0+b2JqZWN0LmZsYWdzIHw9IE1FVEFJTkZPX1NIT1dOOwoJCQlnZXRfY29tbWl0X2luZm8oc3VzcGVjdC0+Y29tbWl0LCAmY2ksIDEpOwoJCQlpZiAoKm9wdGlvbiAmIE9VVFBVVF9TSE9XX0VNQUlMKQoJCQkJbnVtID0gdXRmOF9zdHJ3aWR0aChjaS5hdXRob3JfbWFpbC5idWYpOwoJCQllbHNlCgkJCQludW0gPSB1dGY4X3N0cndpZHRoKGNpLmF1dGhvci5idWYpOwoJCQlpZiAobG9uZ2VzdF9hdXRob3IgPCBudW0pCgkJCQlsb25nZXN0X2F1dGhvciA9IG51bTsKCQkJY29tbWl0X2luZm9fZGVzdHJveSgmY2kpOwoJCX0KCQludW0gPSBlLT5zX2xubyArIGUtPm51bV9saW5lczsKCQlpZiAobG9uZ2VzdF9zcmNfbGluZXMgPCBudW0pCgkJCWxvbmdlc3Rfc3JjX2xpbmVzID0gbnVtOwoJCW51bSA9IGUtPmxubyArIGUtPm51bV9saW5lczsKCQlpZiAobG9uZ2VzdF9kc3RfbGluZXMgPCBudW0pCgkJCWxvbmdlc3RfZHN0X2xpbmVzID0gbnVtOwoJCWlmIChsYXJnZXN0X3Njb3JlIDwgYmxhbWVfZW50cnlfc2NvcmUoc2IsIGUpKQoJCQlsYXJnZXN0X3Njb3JlID0gYmxhbWVfZW50cnlfc2NvcmUoc2IsIGUpOwoJfQoJbWF4X29yaWdfZGlnaXRzID0gZGVjaW1hbF93aWR0aChsb25nZXN0X3NyY19saW5lcyk7CgltYXhfZGlnaXRzID0gZGVjaW1hbF93aWR0aChsb25nZXN0X2RzdF9saW5lcyk7CgltYXhfc2NvcmVfZGlnaXRzID0gZGVjaW1hbF93aWR0aChsYXJnZXN0X3Njb3JlKTsKCglpZiAoY29tcHV0ZV9hdXRvX2FiYnJldikKCQkvKiBvbmUgbW9yZSBhYmJyZXYgbGVuZ3RoIGlzIG5lZWRlZCBmb3IgdGhlIGJvdW5kYXJ5IGNvbW1pdCAqLwoJCWFiYnJldiA9IGF1dG9fYWJicmV2ICsgMTsKfQoKc3RhdGljIHZvaWQgc2FuaXR5X2NoZWNrX29uX2ZhaWwoc3RydWN0IGJsYW1lX3Njb3JlYm9hcmQgKnNiLCBpbnQgYmFhKQp7CglpbnQgb3B0ID0gT1VUUFVUX1NIT1dfU0NPUkUgfCBPVVRQVVRfU0hPV19OVU1CRVIgfCBPVVRQVVRfU0hPV19OQU1FOwoJZmluZF9hbGlnbm1lbnQoc2IsICZvcHQpOwoJb3V0cHV0KHNiLCBvcHQpOwoJZGllKCJCYWEgJWQhIiwgYmFhKTsKfQoKc3RhdGljIHVuc2lnbmVkIHBhcnNlX3Njb3JlKGNvbnN0IGNoYXIgKmFyZykKewoJY2hhciAqZW5kOwoJdW5zaWduZWQgbG9uZyBzY29yZSA9IHN0cnRvdWwoYXJnLCAmZW5kLCAxMCk7CglpZiAoKmVuZCkKCQlyZXR1cm4gMDsKCXJldHVybiBzY29yZTsKfQoKc3RhdGljIGNvbnN0IGNoYXIgKmFkZF9wcmVmaXgoY29uc3QgY2hhciAqcHJlZml4LCBjb25zdCBjaGFyICpwYXRoKQp7CglyZXR1cm4gcHJlZml4X3BhdGgocHJlZml4LCBwcmVmaXggPyBzdHJsZW4ocHJlZml4KSA6IDAsIHBhdGgpOwp9CgpzdGF0aWMgaW50IGdpdF9ibGFtZV9jb25maWcoY29uc3QgY2hhciAqdmFyLCBjb25zdCBjaGFyICp2YWx1ZSwgdm9pZCAqY2IpCnsKCWlmICghc3RyY21wKHZhciwgImJsYW1lLnNob3dyb290IikpIHsKCQlzaG93X3Jvb3QgPSBnaXRfY29uZmlnX2Jvb2wodmFyLCB2YWx1ZSk7CgkJcmV0dXJuIDA7Cgl9CglpZiAoIXN0cmNtcCh2YXIsICJibGFtZS5ibGFua2JvdW5kYXJ5IikpIHsKCQlibGFua19ib3VuZGFyeSA9IGdpdF9jb25maWdfYm9vbCh2YXIsIHZhbHVlKTsKCQlyZXR1cm4gMDsKCX0KCWlmICghc3RyY21wKHZhciwgImJsYW1lLnNob3dlbWFpbCIpKSB7CgkJaW50ICpvdXRwdXRfb3B0aW9uID0gY2I7CgkJaWYgKGdpdF9jb25maWdfYm9vbCh2YXIsIHZhbHVlKSkKCQkJKm91dHB1dF9vcHRpb24gfD0gT1VUUFVUX1NIT1dfRU1BSUw7CgkJZWxzZQoJCQkqb3V0cHV0X29wdGlvbiAmPSB+T1VUUFVUX1NIT1dfRU1BSUw7CgkJcmV0dXJuIDA7Cgl9CglpZiAoIXN0cmNtcCh2YXIsICJibGFtZS5kYXRlIikpIHsKCQlpZiAoIXZhbHVlKQoJCQlyZXR1cm4gY29uZmlnX2Vycm9yX25vbmJvb2wodmFyKTsKCQlwYXJzZV9kYXRlX2Zvcm1hdCh2YWx1ZSwgJmJsYW1lX2RhdGVfbW9kZSk7CgkJcmV0dXJuIDA7Cgl9CgoJaWYgKGdpdF9kaWZmX2hldXJpc3RpY19jb25maWcodmFyLCB2YWx1ZSwgY2IpIDwgMCkKCQlyZXR1cm4gLTE7CglpZiAodXNlcmRpZmZfY29uZmlnKHZhciwgdmFsdWUpIDwgMCkKCQlyZXR1cm4gLTE7CgoJcmV0dXJuIGdpdF9kZWZhdWx0X2NvbmZpZyh2YXIsIHZhbHVlLCBjYik7Cn0KCnN0YXRpYyBpbnQgYmxhbWVfY29weV9jYWxsYmFjayhjb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHRpb24sIGNvbnN0IGNoYXIgKmFyZywgaW50IHVuc2V0KQp7CglpbnQgKm9wdCA9IG9wdGlvbi0+dmFsdWU7CgoJLyoKCSAqIC1DIGVuYWJsZXMgY29weSBmcm9tIHJlbW92ZWQgZmlsZXM7CgkgKiAtQyAtQyBlbmFibGVzIGNvcHkgZnJvbSBleGlzdGluZyBmaWxlcywgYnV0IG9ubHkKCSAqICAgICAgIHdoZW4gYmxhbWluZyBhIG5ldyBmaWxlOwoJICogLUMgLUMgLUMgZW5hYmxlcyBjb3B5IGZyb20gZXhpc3RpbmcgZmlsZXMgZm9yCgkgKiAgICAgICAgICBldmVyeWJvZHkKCSAqLwoJaWYgKCpvcHQgJiBQSUNLQVhFX0JMQU1FX0NPUFlfSEFSREVSKQoJCSpvcHQgfD0gUElDS0FYRV9CTEFNRV9DT1BZX0hBUkRFU1Q7CglpZiAoKm9wdCAmIFBJQ0tBWEVfQkxBTUVfQ09QWSkKCQkqb3B0IHw9IFBJQ0tBWEVfQkxBTUVfQ09QWV9IQVJERVI7Cgkqb3B0IHw9IFBJQ0tBWEVfQkxBTUVfQ09QWSB8IFBJQ0tBWEVfQkxBTUVfTU9WRTsKCglpZiAoYXJnKQoJCWJsYW1lX2NvcHlfc2NvcmUgPSBwYXJzZV9zY29yZShhcmcpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgYmxhbWVfbW92ZV9jYWxsYmFjayhjb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHRpb24sIGNvbnN0IGNoYXIgKmFyZywgaW50IHVuc2V0KQp7CglpbnQgKm9wdCA9IG9wdGlvbi0+dmFsdWU7CgoJKm9wdCB8PSBQSUNLQVhFX0JMQU1FX01PVkU7CgoJaWYgKGFyZykKCQlibGFtZV9tb3ZlX3Njb3JlID0gcGFyc2Vfc2NvcmUoYXJnKTsKCXJldHVybiAwOwp9CgppbnQgY21kX2JsYW1lKGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndiwgY29uc3QgY2hhciAqcHJlZml4KQp7CglzdHJ1Y3QgcmV2X2luZm8gcmV2czsKCWNvbnN0IGNoYXIgKnBhdGg7CglzdHJ1Y3QgYmxhbWVfc2NvcmVib2FyZCBzYjsKCXN0cnVjdCBibGFtZV9vcmlnaW4gKm87CglzdHJ1Y3QgYmxhbWVfZW50cnkgKmVudCA9IE5VTEw7Cglsb25nIGRhc2hkYXNoX3BvcywgbG5vOwoJc3RydWN0IHByb2dyZXNzX2luZm8gcGkgPSB7IE5VTEwsIDAgfTsKCglzdHJ1Y3Qgc3RyaW5nX2xpc3QgcmFuZ2VfbGlzdCA9IFNUUklOR19MSVNUX0lOSVRfTk9EVVA7CglpbnQgb3V0cHV0X29wdGlvbiA9IDAsIG9wdCA9IDA7CglpbnQgc2hvd19zdGF0cyA9IDA7Cgljb25zdCBjaGFyICpyZXZzX2ZpbGUgPSBOVUxMOwoJY29uc3QgY2hhciAqY29udGVudHNfZnJvbSA9IE5VTEw7Cgljb25zdCBzdHJ1Y3Qgb3B0aW9uIG9wdGlvbnNbXSA9IHsKCQlPUFRfQk9PTCgwLCAiaW5jcmVtZW50YWwiLCAmaW5jcmVtZW50YWwsIE5fKCJTaG93IGJsYW1lIGVudHJpZXMgYXMgd2UgZmluZCB0aGVtLCBpbmNyZW1lbnRhbGx5IikpLAoJCU9QVF9CT09MKCdiJywgTlVMTCwgJmJsYW5rX2JvdW5kYXJ5LCBOXygiU2hvdyBibGFuayBTSEEtMSBmb3IgYm91bmRhcnkgY29tbWl0cyAoRGVmYXVsdDogb2ZmKSIpKSwKCQlPUFRfQk9PTCgwLCAicm9vdCIsICZzaG93X3Jvb3QsIE5fKCJEbyBub3QgdHJlYXQgcm9vdCBjb21taXRzIGFzIGJvdW5kYXJpZXMgKERlZmF1bHQ6IG9mZikiKSksCgkJT1BUX0JPT0woMCwgInNob3ctc3RhdHMiLCAmc2hvd19zdGF0cywgTl8oIlNob3cgd29yayBjb3N0IHN0YXRpc3RpY3MiKSksCgkJT1BUX0JPT0woMCwgInByb2dyZXNzIiwgJnNob3dfcHJvZ3Jlc3MsIE5fKCJGb3JjZSBwcm9ncmVzcyByZXBvcnRpbmciKSksCgkJT1BUX0JJVCgwLCAic2NvcmUtZGVidWciLCAmb3V0cHV0X29wdGlvbiwgTl8oIlNob3cgb3V0cHV0IHNjb3JlIGZvciBibGFtZSBlbnRyaWVzIiksIE9VVFBVVF9TSE9XX1NDT1JFKSwKCQlPUFRfQklUKCdmJywgInNob3ctbmFtZSIsICZvdXRwdXRfb3B0aW9uLCBOXygiU2hvdyBvcmlnaW5hbCBmaWxlbmFtZSAoRGVmYXVsdDogYXV0bykiKSwgT1VUUFVUX1NIT1dfTkFNRSksCgkJT1BUX0JJVCgnbicsICJzaG93LW51bWJlciIsICZvdXRwdXRfb3B0aW9uLCBOXygiU2hvdyBvcmlnaW5hbCBsaW5lbnVtYmVyIChEZWZhdWx0OiBvZmYpIiksIE9VVFBVVF9TSE9XX05VTUJFUiksCgkJT1BUX0JJVCgncCcsICJwb3JjZWxhaW4iLCAmb3V0cHV0X29wdGlvbiwgTl8oIlNob3cgaW4gYSBmb3JtYXQgZGVzaWduZWQgZm9yIG1hY2hpbmUgY29uc3VtcHRpb24iKSwgT1VUUFVUX1BPUkNFTEFJTiksCgkJT1BUX0JJVCgwLCAibGluZS1wb3JjZWxhaW4iLCAmb3V0cHV0X29wdGlvbiwgTl8oIlNob3cgcG9yY2VsYWluIGZvcm1hdCB3aXRoIHBlci1saW5lIGNvbW1pdCBpbmZvcm1hdGlvbiIpLCBPVVRQVVRfUE9SQ0VMQUlOfE9VVFBVVF9MSU5FX1BPUkNFTEFJTiksCgkJT1BUX0JJVCgnYycsIE5VTEwsICZvdXRwdXRfb3B0aW9uLCBOXygiVXNlIHRoZSBzYW1lIG91dHB1dCBtb2RlIGFzIGdpdC1hbm5vdGF0ZSAoRGVmYXVsdDogb2ZmKSIpLCBPVVRQVVRfQU5OT1RBVEVfQ09NUEFUKSwKCQlPUFRfQklUKCd0JywgTlVMTCwgJm91dHB1dF9vcHRpb24sIE5fKCJTaG93IHJhdyB0aW1lc3RhbXAgKERlZmF1bHQ6IG9mZikiKSwgT1VUUFVUX1JBV19USU1FU1RBTVApLAoJCU9QVF9CSVQoJ2wnLCBOVUxMLCAmb3V0cHV0X29wdGlvbiwgTl8oIlNob3cgbG9uZyBjb21taXQgU0hBMSAoRGVmYXVsdDogb2ZmKSIpLCBPVVRQVVRfTE9OR19PQkpFQ1RfTkFNRSksCgkJT1BUX0JJVCgncycsIE5VTEwsICZvdXRwdXRfb3B0aW9uLCBOXygiU3VwcHJlc3MgYXV0aG9yIG5hbWUgYW5kIHRpbWVzdGFtcCAoRGVmYXVsdDogb2ZmKSIpLCBPVVRQVVRfTk9fQVVUSE9SKSwKCQlPUFRfQklUKCdlJywgInNob3ctZW1haWwiLCAmb3V0cHV0X29wdGlvbiwgTl8oIlNob3cgYXV0aG9yIGVtYWlsIGluc3RlYWQgb2YgbmFtZSAoRGVmYXVsdDogb2ZmKSIpLCBPVVRQVVRfU0hPV19FTUFJTCksCgkJT1BUX0JJVCgndycsIE5VTEwsICZ4ZGxfb3B0cywgTl8oIklnbm9yZSB3aGl0ZXNwYWNlIGRpZmZlcmVuY2VzIiksIFhERl9JR05PUkVfV0hJVEVTUEFDRSksCgoJCS8qCgkJICogVGhlIGZvbGxvd2luZyB0d28gb3B0aW9ucyBhcmUgcGFyc2VkIGJ5IHBhcnNlX3JldmlzaW9uX29wdCgpCgkJICogYW5kIGFyZSBvbmx5IGluY2x1ZGVkIGhlcmUgdG8gZ2V0IGluY2x1ZGVkIGluIHRoZSAiLWgiCgkJICogb3V0cHV0OgoJCSAqLwoJCXsgT1BUSU9OX0xPV0xFVkVMX0NBTExCQUNLLCAwLCAiaW5kZW50LWhldXJpc3RpYyIsIE5VTEwsIE5VTEwsIE5fKCJVc2UgYW4gZXhwZXJpbWVudGFsIGhldXJpc3RpYyB0byBpbXByb3ZlIGRpZmZzIiksIFBBUlNFX09QVF9OT0FSRywgcGFyc2Vfb3B0X3Vua25vd25fY2IgfSwKCgkJT1BUX0JJVCgwLCAibWluaW1hbCIsICZ4ZGxfb3B0cywgTl8oIlNwZW5kIGV4dHJhIGN5Y2xlcyB0byBmaW5kIGJldHRlciBtYXRjaCIpLCBYREZfTkVFRF9NSU5JTUFMKSwKCQlPUFRfU1RSSU5HKCdTJywgTlVMTCwgJnJldnNfZmlsZSwgTl8oImZpbGUiKSwgTl8oIlVzZSByZXZpc2lvbnMgZnJvbSA8ZmlsZT4gaW5zdGVhZCBvZiBjYWxsaW5nIGdpdC1yZXYtbGlzdCIpKSwKCQlPUFRfU1RSSU5HKDAsICJjb250ZW50cyIsICZjb250ZW50c19mcm9tLCBOXygiZmlsZSIpLCBOXygiVXNlIDxmaWxlPidzIGNvbnRlbnRzIGFzIHRoZSBmaW5hbCBpbWFnZSIpKSwKCQl7IE9QVElPTl9DQUxMQkFDSywgJ0MnLCBOVUxMLCAmb3B0LCBOXygic2NvcmUiKSwgTl8oIkZpbmQgbGluZSBjb3BpZXMgd2l0aGluIGFuZCBhY3Jvc3MgZmlsZXMiKSwgUEFSU0VfT1BUX09QVEFSRywgYmxhbWVfY29weV9jYWxsYmFjayB9LAoJCXsgT1BUSU9OX0NBTExCQUNLLCAnTScsIE5VTEwsICZvcHQsIE5fKCJzY29yZSIpLCBOXygiRmluZCBsaW5lIG1vdmVtZW50cyB3aXRoaW4gYW5kIGFjcm9zcyBmaWxlcyIpLCBQQVJTRV9PUFRfT1BUQVJHLCBibGFtZV9tb3ZlX2NhbGxiYWNrIH0sCgkJT1BUX1NUUklOR19MSVNUKCdMJywgTlVMTCwgJnJhbmdlX2xpc3QsIE5fKCJuLG0iKSwgTl8oIlByb2Nlc3Mgb25seSBsaW5lIHJhbmdlIG4sbSwgY291bnRpbmcgZnJvbSAxIikpLAoJCU9QVF9fQUJCUkVWKCZhYmJyZXYpLAoJCU9QVF9FTkQoKQoJfTsKCglzdHJ1Y3QgcGFyc2Vfb3B0X2N0eF90IGN0eDsKCWludCBjbWRfaXNfYW5ub3RhdGUgPSAhc3RyY21wKGFyZ3ZbMF0sICJhbm5vdGF0ZSIpOwoJc3RydWN0IHJhbmdlX3NldCByYW5nZXM7Cgl1bnNpZ25lZCBpbnQgcmFuZ2VfaTsKCWxvbmcgYW5jaG9yOwoKCWdpdF9jb25maWcoZ2l0X2JsYW1lX2NvbmZpZywgJm91dHB1dF9vcHRpb24pOwoJaW5pdF9yZXZpc2lvbnMoJnJldnMsIE5VTEwpOwoJcmV2cy5kYXRlX21vZGUgPSBibGFtZV9kYXRlX21vZGU7CglyZXZzLmRpZmZvcHQuZmxhZ3MuYWxsb3dfdGV4dGNvbnYgPSAxOwoJcmV2cy5kaWZmb3B0LmZsYWdzLmZvbGxvd19yZW5hbWVzID0gMTsKCglzYXZlX2NvbW1pdF9idWZmZXIgPSAwOwoJZGFzaGRhc2hfcG9zID0gMDsKCXNob3dfcHJvZ3Jlc3MgPSAtMTsKCglwYXJzZV9vcHRpb25zX3N0YXJ0KCZjdHgsIGFyZ2MsIGFyZ3YsIHByZWZpeCwgb3B0aW9ucywKCQkJICAgIFBBUlNFX09QVF9LRUVQX0RBU0hEQVNIIHwgUEFSU0VfT1BUX0tFRVBfQVJHVjApOwoJZm9yICg7OykgewoJCXN3aXRjaCAocGFyc2Vfb3B0aW9uc19zdGVwKCZjdHgsIG9wdGlvbnMsIGJsYW1lX29wdF91c2FnZSkpIHsKCQljYXNlIFBBUlNFX09QVF9IRUxQOgoJCQlleGl0KDEyOSk7CgkJY2FzZSBQQVJTRV9PUFRfRE9ORToKCQkJaWYgKGN0eC5hcmd2WzBdKQoJCQkJZGFzaGRhc2hfcG9zID0gY3R4LmNwaWR4OwoJCQlnb3RvIHBhcnNlX2RvbmU7CgkJfQoKCQlpZiAoIXN0cmNtcChjdHguYXJndlswXSwgIi0tcmV2ZXJzZSIpKSB7CgkJCWN0eC5hcmd2WzBdID0gIi0tY2hpbGRyZW4iOwoJCQlyZXZlcnNlID0gMTsKCQl9CgkJcGFyc2VfcmV2aXNpb25fb3B0KCZyZXZzLCAmY3R4LCBvcHRpb25zLCBibGFtZV9vcHRfdXNhZ2UpOwoJfQpwYXJzZV9kb25lOgoJbm9fd2hvbGVfZmlsZV9yZW5hbWUgPSAhcmV2cy5kaWZmb3B0LmZsYWdzLmZvbGxvd19yZW5hbWVzOwoJeGRsX29wdHMgfD0gcmV2cy5kaWZmb3B0LnhkbF9vcHRzICYgWERGX0lOREVOVF9IRVVSSVNUSUM7CglyZXZzLmRpZmZvcHQuZmxhZ3MuZm9sbG93X3JlbmFtZXMgPSAwOwoJYXJnYyA9IHBhcnNlX29wdGlvbnNfZW5kKCZjdHgpOwoKCWlmIChpbmNyZW1lbnRhbCB8fCAob3V0cHV0X29wdGlvbiAmIE9VVFBVVF9QT1JDRUxBSU4pKSB7CgkJaWYgKHNob3dfcHJvZ3Jlc3MgPiAwKQoJCQlkaWUoXygiLS1wcm9ncmVzcyBjYW4ndCBiZSB1c2VkIHdpdGggLS1pbmNyZW1lbnRhbCBvciBwb3JjZWxhaW4gZm9ybWF0cyIpKTsKCQlzaG93X3Byb2dyZXNzID0gMDsKCX0gZWxzZSBpZiAoc2hvd19wcm9ncmVzcyA8IDApCgkJc2hvd19wcm9ncmVzcyA9IGlzYXR0eSgyKTsKCglpZiAoMCA8IGFiYnJldiAmJiBhYmJyZXYgPCBHSVRfU0hBMV9IRVhTWikKCQkvKiBvbmUgbW9yZSBhYmJyZXYgbGVuZ3RoIGlzIG5lZWRlZCBmb3IgdGhlIGJvdW5kYXJ5IGNvbW1pdCAqLwoJCWFiYnJldisrOwoJZWxzZSBpZiAoIWFiYnJldikKCQlhYmJyZXYgPSBHSVRfU0hBMV9IRVhTWjsKCglpZiAocmV2c19maWxlICYmIHJlYWRfYW5jZXN0cnkocmV2c19maWxlKSkKCQlkaWVfZXJybm8oInJlYWRpbmcgZ3JhZnQgZmlsZSAnJXMnIGZhaWxlZCIsIHJldnNfZmlsZSk7CgoJaWYgKGNtZF9pc19hbm5vdGF0ZSkgewoJCW91dHB1dF9vcHRpb24gfD0gT1VUUFVUX0FOTk9UQVRFX0NPTVBBVDsKCQlibGFtZV9kYXRlX21vZGUudHlwZSA9IERBVEVfSVNPODYwMTsKCX0gZWxzZSB7CgkJYmxhbWVfZGF0ZV9tb2RlID0gcmV2cy5kYXRlX21vZGU7Cgl9CgoJLyogVGhlIG1heGltdW0gd2lkdGggdXNlZCB0byBzaG93IHRoZSBkYXRlcyAqLwoJc3dpdGNoIChibGFtZV9kYXRlX21vZGUudHlwZSkgewoJY2FzZSBEQVRFX1JGQzI4MjI6CgkJYmxhbWVfZGF0ZV93aWR0aCA9IHNpemVvZigiVGh1LCAxOSBPY3QgMjAwNiAxNjowMDowNCAtMDcwMCIpOwoJCWJyZWFrOwoJY2FzZSBEQVRFX0lTTzg2MDFfU1RSSUNUOgoJCWJsYW1lX2RhdGVfd2lkdGggPSBzaXplb2YoIjIwMDYtMTAtMTlUMTY6MDA6MDQtMDc6MDAiKTsKCQlicmVhazsKCWNhc2UgREFURV9JU084NjAxOgoJCWJsYW1lX2RhdGVfd2lkdGggPSBzaXplb2YoIjIwMDYtMTAtMTkgMTY6MDA6MDQgLTA3MDAiKTsKCQlicmVhazsKCWNhc2UgREFURV9SQVc6CgkJYmxhbWVfZGF0ZV93aWR0aCA9IHNpemVvZigiMTE2MTI5ODgwNCAtMDcwMCIpOwoJCWJyZWFrOwoJY2FzZSBEQVRFX1VOSVg6CgkJYmxhbWVfZGF0ZV93aWR0aCA9IHNpemVvZigiMTE2MTI5ODgwNCIpOwoJCWJyZWFrOwoJY2FzZSBEQVRFX1NIT1JUOgoJCWJsYW1lX2RhdGVfd2lkdGggPSBzaXplb2YoIjIwMDYtMTAtMTkiKTsKCQlicmVhazsKCWNhc2UgREFURV9SRUxBVElWRToKCQkvKgoJCSAqIFRSQU5TTEFUT1JTOiBUaGlzIHN0cmluZyBpcyB1c2VkIHRvIHRlbGwgdXMgdGhlCgkJICogbWF4aW11bSBkaXNwbGF5IHdpZHRoIGZvciBhIHJlbGF0aXZlIHRpbWVzdGFtcCBpbgoJCSAqICJnaXQgYmxhbWUiIG91dHB1dC4gIEZvciBDIGxvY2FsZSwgIjQgeWVhcnMsIDExCgkJICogbW9udGhzIGFnbyIsIHdoaWNoIHRha2VzIDIyIHBsYWNlcywgaXMgdGhlIGxvbmdlc3QKCQkgKiBhbW9uZyB2YXJpb3VzIGZvcm1zIG9mIHJlbGF0aXZlIHRpbWVzdGFtcHMsIGJ1dAoJCSAqIHlvdXIgbGFuZ3VhZ2UgbWF5IG5lZWQgbW9yZSBvciBmZXdlciBkaXNwbGF5CgkJICogY29sdW1ucy4KCQkgKi8KCQlibGFtZV9kYXRlX3dpZHRoID0gdXRmOF9zdHJ3aWR0aChfKCI0IHllYXJzLCAxMSBtb250aHMgYWdvIikpICsgMTsgLyogYWRkIHRoZSBudWxsICovCgkJYnJlYWs7CgljYXNlIERBVEVfTk9STUFMOgoJCWJsYW1lX2RhdGVfd2lkdGggPSBzaXplb2YoIlRodSBPY3QgMTkgMTY6MDA6MDQgMjAwNiAtMDcwMCIpOwoJCWJyZWFrOwoJY2FzZSBEQVRFX1NUUkZUSU1FOgoJCWJsYW1lX2RhdGVfd2lkdGggPSBzdHJsZW4oc2hvd19kYXRlKDAsIDAsICZibGFtZV9kYXRlX21vZGUpKSArIDE7IC8qIGFkZCB0aGUgbnVsbCAqLwoJCWJyZWFrOwoJfQoJYmxhbWVfZGF0ZV93aWR0aCAtPSAxOyAvKiBzdHJpcCB0aGUgbnVsbCAqLwoKCWlmIChyZXZzLmRpZmZvcHQuZmxhZ3MuZmluZF9jb3BpZXNfaGFyZGVyKQoJCW9wdCB8PSAoUElDS0FYRV9CTEFNRV9DT1BZIHwgUElDS0FYRV9CTEFNRV9NT1ZFIHwKCQkJUElDS0FYRV9CTEFNRV9DT1BZX0hBUkRFUik7CgoJLyoKCSAqIFdlIGhhdmUgY29sbGVjdGVkIG9wdGlvbnMgdW5rbm93biB0byB1cyBpbiBhcmd2WzEuLnVua10KCSAqIHdoaWNoIGFyZSB0byBiZSBwYXNzZWQgdG8gcmV2aXNpb24gbWFjaGluZXJ5IGlmIHdlIGFyZQoJICogZ29pbmcgdG8gZG8gdGhlICJib3R0b20iIHByb2Nlc3NpbmcuCgkgKgoJICogVGhlIHJlbWFpbmluZyBhcmU6CgkgKgoJICogKDEpIGlmIGRhc2hkYXNoX3BvcyAhPSAwLCBpdCBpcyBlaXRoZXIKCSAqICAgICAiYmxhbWUgW3JldmlzaW9uc10gLS0gPHBhdGg+IiBvcgoJICogICAgICJibGFtZSAtLSA8cGF0aD4gPHJldj4iCgkgKgoJICogKDIpIG90aGVyd2lzZSwgaXQgaXMgb25lIG9mIHRoZSB0d286CgkgKiAgICAgImJsYW1lIFtyZXZpc2lvbnNdIDxwYXRoPiIKCSAqICAgICAiYmxhbWUgPHBhdGg+IDxyZXY+IgoJICoKCSAqIE5vdGUgdGhhdCB3ZSBtdXN0IHN0cmlwIG91dCA8cGF0aD4gZnJvbSB0aGUgYXJndW1lbnRzOiB3ZSBkbyBub3QKCSAqIHdhbnQgdGhlIHBhdGggcHJ1bmluZyBidXQgd2UgbWF5IHdhbnQgImJvdHRvbSIgcHJvY2Vzc2luZy4KCSAqLwoJaWYgKGRhc2hkYXNoX3BvcykgewoJCXN3aXRjaCAoYXJnYyAtIGRhc2hkYXNoX3BvcyAtIDEpIHsKCQljYXNlIDI6IC8qICgxYikgKi8KCQkJaWYgKGFyZ2MgIT0gNCkKCQkJCXVzYWdlX3dpdGhfb3B0aW9ucyhibGFtZV9vcHRfdXNhZ2UsIG9wdGlvbnMpOwoJCQkvKiByZW9yZGVyIGZvciB0aGUgbmV3IHdheTogPHJldj4gLS0gPHBhdGg+ICovCgkJCWFyZ3ZbMV0gPSBhcmd2WzNdOwoJCQlhcmd2WzNdID0gYXJndlsyXTsKCQkJYXJndlsyXSA9ICItLSI7CgkJCS8qIEZBTExUSFJPVUdIICovCgkJY2FzZSAxOiAvKiAoMWEpICovCgkJCXBhdGggPSBhZGRfcHJlZml4KHByZWZpeCwgYXJndlstLWFyZ2NdKTsKCQkJYXJndlthcmdjXSA9IE5VTEw7CgkJCWJyZWFrOwoJCWRlZmF1bHQ6CgkJCXVzYWdlX3dpdGhfb3B0aW9ucyhibGFtZV9vcHRfdXNhZ2UsIG9wdGlvbnMpOwoJCX0KCX0gZWxzZSB7CgkJaWYgKGFyZ2MgPCAyKQoJCQl1c2FnZV93aXRoX29wdGlvbnMoYmxhbWVfb3B0X3VzYWdlLCBvcHRpb25zKTsKCQlwYXRoID0gYWRkX3ByZWZpeChwcmVmaXgsIGFyZ3ZbYXJnYyAtIDFdKTsKCQlpZiAoYXJnYyA9PSAzICYmICFmaWxlX2V4aXN0cyhwYXRoKSkgeyAvKiAoMmIpICovCgkJCXBhdGggPSBhZGRfcHJlZml4KHByZWZpeCwgYXJndlsxXSk7CgkJCWFyZ3ZbMV0gPSBhcmd2WzJdOwoJCX0KCQlhcmd2W2FyZ2MgLSAxXSA9ICItLSI7CgoJCXNldHVwX3dvcmtfdHJlZSgpOwoJCWlmICghZmlsZV9leGlzdHMocGF0aCkpCgkJCWRpZV9lcnJubygiY2Fubm90IHN0YXQgcGF0aCAnJXMnIiwgcGF0aCk7Cgl9CgoJcmV2cy5kaXNhYmxlX3N0ZGluID0gMTsKCXNldHVwX3JldmlzaW9ucyhhcmdjLCBhcmd2LCAmcmV2cywgTlVMTCk7CgoJaW5pdF9zY29yZWJvYXJkKCZzYik7CglzYi5yZXZzID0gJnJldnM7CglzYi5jb250ZW50c19mcm9tID0gY29udGVudHNfZnJvbTsKCXNiLnJldmVyc2UgPSByZXZlcnNlOwoJc2V0dXBfc2NvcmVib2FyZCgmc2IsIHBhdGgsICZvKTsKCWxubyA9IHNiLm51bV9saW5lczsKCglpZiAobG5vICYmICFyYW5nZV9saXN0Lm5yKQoJCXN0cmluZ19saXN0X2FwcGVuZCgmcmFuZ2VfbGlzdCwgIjEiKTsKCglhbmNob3IgPSAxOwoJcmFuZ2Vfc2V0X2luaXQoJnJhbmdlcywgcmFuZ2VfbGlzdC5ucik7Cglmb3IgKHJhbmdlX2kgPSAwOyByYW5nZV9pIDwgcmFuZ2VfbGlzdC5ucjsgKytyYW5nZV9pKSB7CgkJbG9uZyBib3R0b20sIHRvcDsKCQlpZiAocGFyc2VfcmFuZ2VfYXJnKHJhbmdlX2xpc3QuaXRlbXNbcmFuZ2VfaV0uc3RyaW5nLAoJCQkJICAgIG50aF9saW5lX2NiLCAmc2IsIGxubywgYW5jaG9yLAoJCQkJICAgICZib3R0b20sICZ0b3AsIHNiLnBhdGgpKQoJCQl1c2FnZShibGFtZV91c2FnZSk7CgkJaWYgKGxubyA8IHRvcCB8fCAoKGxubyB8fCBib3R0b20pICYmIGxubyA8IGJvdHRvbSkpCgkJCWRpZShRXygiZmlsZSAlcyBoYXMgb25seSAlbHUgbGluZSIsCgkJCSAgICAgICAiZmlsZSAlcyBoYXMgb25seSAlbHUgbGluZXMiLAoJCQkgICAgICAgbG5vKSwgcGF0aCwgbG5vKTsKCQlpZiAoYm90dG9tIDwgMSkKCQkJYm90dG9tID0gMTsKCQlpZiAodG9wIDwgMSkKCQkJdG9wID0gbG5vOwoJCWJvdHRvbS0tOwoJCXJhbmdlX3NldF9hcHBlbmRfdW5zYWZlKCZyYW5nZXMsIGJvdHRvbSwgdG9wKTsKCQlhbmNob3IgPSB0b3AgKyAxOwoJfQoJc29ydF9hbmRfbWVyZ2VfcmFuZ2Vfc2V0KCZyYW5nZXMpOwoKCWZvciAocmFuZ2VfaSA9IHJhbmdlcy5ucjsgcmFuZ2VfaSA+IDA7IC0tcmFuZ2VfaSkgewoJCWNvbnN0IHN0cnVjdCByYW5nZSAqciA9ICZyYW5nZXMucmFuZ2VzW3JhbmdlX2kgLSAxXTsKCQllbnQgPSBibGFtZV9lbnRyeV9wcmVwZW5kKGVudCwgci0+c3RhcnQsIHItPmVuZCwgbyk7Cgl9CgoJby0+c3VzcGVjdHMgPSBlbnQ7CglwcmlvX3F1ZXVlX3B1dCgmc2IuY29tbWl0cywgby0+Y29tbWl0KTsKCglibGFtZV9vcmlnaW5fZGVjcmVmKG8pOwoKCXJhbmdlX3NldF9yZWxlYXNlKCZyYW5nZXMpOwoJc3RyaW5nX2xpc3RfY2xlYXIoJnJhbmdlX2xpc3QsIDApOwoKCXNiLmVudCA9IE5VTEw7CglzYi5wYXRoID0gcGF0aDsKCglpZiAoYmxhbWVfbW92ZV9zY29yZSkKCQlzYi5tb3ZlX3Njb3JlID0gYmxhbWVfbW92ZV9zY29yZTsKCWlmIChibGFtZV9jb3B5X3Njb3JlKQoJCXNiLmNvcHlfc2NvcmUgPSBibGFtZV9jb3B5X3Njb3JlOwoKCXNiLmRlYnVnID0gREVCVUc7CglzYi5vbl9zYW5pdHlfZmFpbCA9ICZzYW5pdHlfY2hlY2tfb25fZmFpbDsKCglzYi5zaG93X3Jvb3QgPSBzaG93X3Jvb3Q7CglzYi54ZGxfb3B0cyA9IHhkbF9vcHRzOwoJc2Iubm9fd2hvbGVfZmlsZV9yZW5hbWUgPSBub193aG9sZV9maWxlX3JlbmFtZTsKCglyZWFkX21haWxtYXAoJm1haWxtYXAsIE5VTEwpOwoKCXNiLmZvdW5kX2d1aWx0eV9lbnRyeSA9ICZmb3VuZF9ndWlsdHlfZW50cnk7CglzYi5mb3VuZF9ndWlsdHlfZW50cnlfZGF0YSA9ICZwaTsKCWlmIChzaG93X3Byb2dyZXNzKQoJCXBpLnByb2dyZXNzID0gc3RhcnRfZGVsYXllZF9wcm9ncmVzcyhfKCJCbGFtaW5nIGxpbmVzIiksIHNiLm51bV9saW5lcyk7CgoJYXNzaWduX2JsYW1lKCZzYiwgb3B0KTsKCglzdG9wX3Byb2dyZXNzKCZwaS5wcm9ncmVzcyk7CgoJaWYgKCFpbmNyZW1lbnRhbCkKCQlzZXR1cF9wYWdlcigpOwoJZWxzZQoJCXJldHVybiAwOwoKCWJsYW1lX3NvcnRfZmluYWwoJnNiKTsKCglibGFtZV9jb2FsZXNjZSgmc2IpOwoKCWlmICghKG91dHB1dF9vcHRpb24gJiBPVVRQVVRfUE9SQ0VMQUlOKSkKCQlmaW5kX2FsaWdubWVudCgmc2IsICZvdXRwdXRfb3B0aW9uKTsKCglvdXRwdXQoJnNiLCBvdXRwdXRfb3B0aW9uKTsKCWZyZWUoKHZvaWQgKilzYi5maW5hbF9idWYpOwoJZm9yIChlbnQgPSBzYi5lbnQ7IGVudDsgKSB7CgkJc3RydWN0IGJsYW1lX2VudHJ5ICplID0gZW50LT5uZXh0OwoJCWZyZWUoZW50KTsKCQllbnQgPSBlOwoJfQoKCWlmIChzaG93X3N0YXRzKSB7CgkJcHJpbnRmKCJudW0gcmVhZCBibG9iOiAlZFxuIiwgc2IubnVtX3JlYWRfYmxvYik7CgkJcHJpbnRmKCJudW0gZ2V0IHBhdGNoOiAlZFxuIiwgc2IubnVtX2dldF9wYXRjaCk7CgkJcHJpbnRmKCJudW0gY29tbWl0czogJWRcbiIsIHNiLm51bV9jb21taXRzKTsKCX0KCXJldHVybiAwOwp9Cg==",
    "text": "/*\n * Blame\n *\n * Copyright (c) 2006, 2014 by its authors\n * See COPYING for licensing conditions\n */\n\n#include \"cache.h\"\n#include \"config.h\"\n#include \"builtin.h\"\n#include \"commit.h\"\n#include \"diff.h\"\n#include \"revision.h\"\n#include \"quote.h\"\n#include \"string-list.h\"\n#include \"mailmap.h\"\n#include \"parse-options.h\"\n#include \"prio-queue.h\"\n#include \"utf8.h\"\n#include \"userdiff.h\"\n#include \"line-range.h\"\n#include \"line-log.h\"\n#include \"dir.h\"\n#include \"progress.h\"\n#include \"blame.h\"\n\nstatic char blame_usage[] = N_(\"git blame [<options>] [<rev-opts>] [<rev>] [--] <file>\");\n\nstatic const char *blame_opt_usage[] = {\n\tblame_usage,\n\t\"\",\n\tN_(\"<rev-opts> are documented in git-rev-list(1)\"),\n\tNULL\n};\n\nstatic int longest_file;\nstatic int longest_author;\nstatic int max_orig_digits;\nstatic int max_digits;\nstatic int max_score_digits;\nstatic int show_root;\nstatic int reverse;\nstatic int blank_boundary;\nstatic int incremental;\nstatic int xdl_opts;\nstatic int abbrev = -1;\nstatic int no_whole_file_rename;\nstatic int show_progress;\n\nstatic struct date_mode blame_date_mode = { DATE_ISO8601 };\nstatic size_t blame_date_width;\n\nstatic struct string_list mailmap = STRING_LIST_INIT_NODUP;\n\n#ifndef DEBUG\n#define DEBUG 0\n#endif\n\nstatic unsigned blame_move_score;\nstatic unsigned blame_copy_score;\n\n/* Remember to update object flag allocation in object.h */\n#define METAINFO_SHOWN\t\t(1u<<12)\n#define MORE_THAN_ONE_PATH\t(1u<<13)\n\nstruct progress_info {\n\tstruct progress *progress;\n\tint blamed_lines;\n};\n\nstatic const char *nth_line_cb(void *data, long lno)\n{\n\treturn blame_nth_line((struct blame_scoreboard *)data, lno);\n}\n\n/*\n * Information on commits, used for output.\n */\nstruct commit_info {\n\tstruct strbuf author;\n\tstruct strbuf author_mail;\n\ttimestamp_t author_time;\n\tstruct strbuf author_tz;\n\n\t/* filled only when asked for details */\n\tstruct strbuf committer;\n\tstruct strbuf committer_mail;\n\ttimestamp_t committer_time;\n\tstruct strbuf committer_tz;\n\n\tstruct strbuf summary;\n};\n\n/*\n * Parse author/committer line in the commit object buffer\n */\nstatic void get_ac_line(const char *inbuf, const char *what,\n\tstruct strbuf *name, struct strbuf *mail,\n\ttimestamp_t *time, struct strbuf *tz)\n{\n\tstruct ident_split ident;\n\tsize_t len, maillen, namelen;\n\tchar *tmp, *endp;\n\tconst char *namebuf, *mailbuf;\n\n\ttmp = strstr(inbuf, what);\n\tif (!tmp)\n\t\tgoto error_out;\n\ttmp += strlen(what);\n\tendp = strchr(tmp, '\\n');\n\tif (!endp)\n\t\tlen = strlen(tmp);\n\telse\n\t\tlen = endp - tmp;\n\n\tif (split_ident_line(&ident, tmp, len)) {\n\terror_out:\n\t\t/* Ugh */\n\t\ttmp = \"(unknown)\";\n\t\tstrbuf_addstr(name, tmp);\n\t\tstrbuf_addstr(mail, tmp);\n\t\tstrbuf_addstr(tz, tmp);\n\t\t*time = 0;\n\t\treturn;\n\t}\n\n\tnamelen = ident.name_end - ident.name_begin;\n\tnamebuf = ident.name_begin;\n\n\tmaillen = ident.mail_end - ident.mail_begin;\n\tmailbuf = ident.mail_begin;\n\n\tif (ident.date_begin && ident.date_end)\n\t\t*time = strtoul(ident.date_begin, NULL, 10);\n\telse\n\t\t*time = 0;\n\n\tif (ident.tz_begin && ident.tz_end)\n\t\tstrbuf_add(tz, ident.tz_begin, ident.tz_end - ident.tz_begin);\n\telse\n\t\tstrbuf_addstr(tz, \"(unknown)\");\n\n\t/*\n\t * Now, convert both name and e-mail using mailmap\n\t */\n\tmap_user(&mailmap, &mailbuf, &maillen,\n\t\t &namebuf, &namelen);\n\n\tstrbuf_addf(mail, \"<%.*s>\", (int)maillen, mailbuf);\n\tstrbuf_add(name, namebuf, namelen);\n}\n\nstatic void commit_info_init(struct commit_info *ci)\n{\n\n\tstrbuf_init(&ci->author, 0);\n\tstrbuf_init(&ci->author_mail, 0);\n\tstrbuf_init(&ci->author_tz, 0);\n\tstrbuf_init(&ci->committer, 0);\n\tstrbuf_init(&ci->committer_mail, 0);\n\tstrbuf_init(&ci->committer_tz, 0);\n\tstrbuf_init(&ci->summary, 0);\n}\n\nstatic void commit_info_destroy(struct commit_info *ci)\n{\n\n\tstrbuf_release(&ci->author);\n\tstrbuf_release(&ci->author_mail);\n\tstrbuf_release(&ci->author_tz);\n\tstrbuf_release(&ci->committer);\n\tstrbuf_release(&ci->committer_mail);\n\tstrbuf_release(&ci->committer_tz);\n\tstrbuf_release(&ci->summary);\n}\n\nstatic void get_commit_info(struct commit *commit,\n\t\t\t    struct commit_info *ret,\n\t\t\t    int detailed)\n{\n\tint len;\n\tconst char *subject, *encoding;\n\tconst char *message;\n\n\tcommit_info_init(ret);\n\n\tencoding = get_log_output_encoding();\n\tmessage = logmsg_reencode(commit, NULL, encoding);\n\tget_ac_line(message, \"\\nauthor \",\n\t\t    &ret->author, &ret->author_mail,\n\t\t    &ret->author_time, &ret->author_tz);\n\n\tif (!detailed) {\n\t\tunuse_commit_buffer(commit, message);\n\t\treturn;\n\t}\n\n\tget_ac_line(message, \"\\ncommitter \",\n\t\t    &ret->committer, &ret->committer_mail,\n\t\t    &ret->committer_time, &ret->committer_tz);\n\n\tlen = find_commit_subject(message, &subject);\n\tif (len)\n\t\tstrbuf_add(&ret->summary, subject, len);\n\telse\n\t\tstrbuf_addf(&ret->summary, \"(%s)\", oid_to_hex(&commit->object.oid));\n\n\tunuse_commit_buffer(commit, message);\n}\n\n/*\n * Write out any suspect information which depends on the path. This must be\n * handled separately from emit_one_suspect_detail(), because a given commit\n * may have changes in multiple paths. So this needs to appear each time\n * we mention a new group.\n *\n * To allow LF and other nonportable characters in pathnames,\n * they are c-style quoted as needed.\n */\nstatic void write_filename_info(struct blame_origin *suspect)\n{\n\tif (suspect->previous) {\n\t\tstruct blame_origin *prev = suspect->previous;\n\t\tprintf(\"previous %s \", oid_to_hex(&prev->commit->object.oid));\n\t\twrite_name_quoted(prev->path, stdout, '\\n');\n\t}\n\tprintf(\"filename \");\n\twrite_name_quoted(suspect->path, stdout, '\\n');\n}\n\n/*\n * Porcelain/Incremental format wants to show a lot of details per\n * commit.  Instead of repeating this every line, emit it only once,\n * the first time each commit appears in the output (unless the\n * user has specifically asked for us to repeat).\n */\nstatic int emit_one_suspect_detail(struct blame_origin *suspect, int repeat)\n{\n\tstruct commit_info ci;\n\n\tif (!repeat && (suspect->commit->object.flags & METAINFO_SHOWN))\n\t\treturn 0;\n\n\tsuspect->commit->object.flags |= METAINFO_SHOWN;\n\tget_commit_info(suspect->commit, &ci, 1);\n\tprintf(\"author %s\\n\", ci.author.buf);\n\tprintf(\"author-mail %s\\n\", ci.author_mail.buf);\n\tprintf(\"author-time %\"PRItime\"\\n\", ci.author_time);\n\tprintf(\"author-tz %s\\n\", ci.author_tz.buf);\n\tprintf(\"committer %s\\n\", ci.committer.buf);\n\tprintf(\"committer-mail %s\\n\", ci.committer_mail.buf);\n\tprintf(\"committer-time %\"PRItime\"\\n\", ci.committer_time);\n\tprintf(\"committer-tz %s\\n\", ci.committer_tz.buf);\n\tprintf(\"summary %s\\n\", ci.summary.buf);\n\tif (suspect->commit->object.flags & UNINTERESTING)\n\t\tprintf(\"boundary\\n\");\n\n\tcommit_info_destroy(&ci);\n\n\treturn 1;\n}\n\n/*\n * The blame_entry is found to be guilty for the range.\n * Show it in incremental output.\n */\nstatic void found_guilty_entry(struct blame_entry *ent, void *data)\n{\n\tstruct progress_info *pi = (struct progress_info *)data;\n\n\tif (incremental) {\n\t\tstruct blame_origin *suspect = ent->suspect;\n\n\t\tprintf(\"%s %d %d %d\\n\",\n\t\t       oid_to_hex(&suspect->commit->object.oid),\n\t\t       ent->s_lno + 1, ent->lno + 1, ent->num_lines);\n\t\temit_one_suspect_detail(suspect, 0);\n\t\twrite_filename_info(suspect);\n\t\tmaybe_flush_or_die(stdout, \"stdout\");\n\t}\n\tpi->blamed_lines += ent->num_lines;\n\tdisplay_progress(pi->progress, pi->blamed_lines);\n}\n\nstatic const char *format_time(timestamp_t time, const char *tz_str,\n\t\t\t       int show_raw_time)\n{\n\tstatic struct strbuf time_buf = STRBUF_INIT;\n\n\tstrbuf_reset(&time_buf);\n\tif (show_raw_time) {\n\t\tstrbuf_addf(&time_buf, \"%\"PRItime\" %s\", time, tz_str);\n\t}\n\telse {\n\t\tconst char *time_str;\n\t\tsize_t time_width;\n\t\tint tz;\n\t\ttz = atoi(tz_str);\n\t\ttime_str = show_date(time, tz, &blame_date_mode);\n\t\tstrbuf_addstr(&time_buf, time_str);\n\t\t/*\n\t\t * Add space paddings to time_buf to display a fixed width\n\t\t * string, and use time_width for display width calibration.\n\t\t */\n\t\tfor (time_width = utf8_strwidth(time_str);\n\t\t     time_width < blame_date_width;\n\t\t     time_width++)\n\t\t\tstrbuf_addch(&time_buf, ' ');\n\t}\n\treturn time_buf.buf;\n}\n\n#define OUTPUT_ANNOTATE_COMPAT\t001\n#define OUTPUT_LONG_OBJECT_NAME\t002\n#define OUTPUT_RAW_TIMESTAMP\t004\n#define OUTPUT_PORCELAIN\t010\n#define OUTPUT_SHOW_NAME\t020\n#define OUTPUT_SHOW_NUMBER\t040\n#define OUTPUT_SHOW_SCORE      0100\n#define OUTPUT_NO_AUTHOR       0200\n#define OUTPUT_SHOW_EMAIL\t0400\n#define OUTPUT_LINE_PORCELAIN 01000\n\nstatic void emit_porcelain_details(struct blame_origin *suspect, int repeat)\n{\n\tif (emit_one_suspect_detail(suspect, repeat) ||\n\t    (suspect->commit->object.flags & MORE_THAN_ONE_PATH))\n\t\twrite_filename_info(suspect);\n}\n\nstatic void emit_porcelain(struct blame_scoreboard *sb, struct blame_entry *ent,\n\t\t\t   int opt)\n{\n\tint repeat = opt & OUTPUT_LINE_PORCELAIN;\n\tint cnt;\n\tconst char *cp;\n\tstruct blame_origin *suspect = ent->suspect;\n\tchar hex[GIT_MAX_HEXSZ + 1];\n\n\toid_to_hex_r(hex, &suspect->commit->object.oid);\n\tprintf(\"%s %d %d %d\\n\",\n\t       hex,\n\t       ent->s_lno + 1,\n\t       ent->lno + 1,\n\t       ent->num_lines);\n\temit_porcelain_details(suspect, repeat);\n\n\tcp = blame_nth_line(sb, ent->lno);\n\tfor (cnt = 0; cnt < ent->num_lines; cnt++) {\n\t\tchar ch;\n\t\tif (cnt) {\n\t\t\tprintf(\"%s %d %d\\n\", hex,\n\t\t\t       ent->s_lno + 1 + cnt,\n\t\t\t       ent->lno + 1 + cnt);\n\t\t\tif (repeat)\n\t\t\t\temit_porcelain_details(suspect, 1);\n\t\t}\n\t\tputchar('\\t');\n\t\tdo {\n\t\t\tch = *cp++;\n\t\t\tputchar(ch);\n\t\t} while (ch != '\\n' &&\n\t\t\t cp < sb->final_buf + sb->final_buf_size);\n\t}\n\n\tif (sb->final_buf_size && cp[-1] != '\\n')\n\t\tputchar('\\n');\n}\n\nstatic void emit_other(struct blame_scoreboard *sb, struct blame_entry *ent, int opt)\n{\n\tint cnt;\n\tconst char *cp;\n\tstruct blame_origin *suspect = ent->suspect;\n\tstruct commit_info ci;\n\tchar hex[GIT_MAX_HEXSZ + 1];\n\tint show_raw_time = !!(opt & OUTPUT_RAW_TIMESTAMP);\n\n\tget_commit_info(suspect->commit, &ci, 1);\n\toid_to_hex_r(hex, &suspect->commit->object.oid);\n\n\tcp = blame_nth_line(sb, ent->lno);\n\tfor (cnt = 0; cnt < ent->num_lines; cnt++) {\n\t\tchar ch;\n\t\tint length = (opt & OUTPUT_LONG_OBJECT_NAME) ? GIT_SHA1_HEXSZ : abbrev;\n\n\t\tif (suspect->commit->object.flags & UNINTERESTING) {\n\t\t\tif (blank_boundary)\n\t\t\t\tmemset(hex, ' ', length);\n\t\t\telse if (!(opt & OUTPUT_ANNOTATE_COMPAT)) {\n\t\t\t\tlength--;\n\t\t\t\tputchar('^');\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%.*s\", length, hex);\n\t\tif (opt & OUTPUT_ANNOTATE_COMPAT) {\n\t\t\tconst char *name;\n\t\t\tif (opt & OUTPUT_SHOW_EMAIL)\n\t\t\t\tname = ci.author_mail.buf;\n\t\t\telse\n\t\t\t\tname = ci.author.buf;\n\t\t\tprintf(\"\\t(%10s\\t%10s\\t%d)\", name,\n\t\t\t       format_time(ci.author_time, ci.author_tz.buf,\n\t\t\t\t\t   show_raw_time),\n\t\t\t       ent->lno + 1 + cnt);\n\t\t} else {\n\t\t\tif (opt & OUTPUT_SHOW_SCORE)\n\t\t\t\tprintf(\" %*d %02d\",\n\t\t\t\t       max_score_digits, ent->score,\n\t\t\t\t       ent->suspect->refcnt);\n\t\t\tif (opt & OUTPUT_SHOW_NAME)\n\t\t\t\tprintf(\" %-*.*s\", longest_file, longest_file,\n\t\t\t\t       suspect->path);\n\t\t\tif (opt & OUTPUT_SHOW_NUMBER)\n\t\t\t\tprintf(\" %*d\", max_orig_digits,\n\t\t\t\t       ent->s_lno + 1 + cnt);\n\n\t\t\tif (!(opt & OUTPUT_NO_AUTHOR)) {\n\t\t\t\tconst char *name;\n\t\t\t\tint pad;\n\t\t\t\tif (opt & OUTPUT_SHOW_EMAIL)\n\t\t\t\t\tname = ci.author_mail.buf;\n\t\t\t\telse\n\t\t\t\t\tname = ci.author.buf;\n\t\t\t\tpad = longest_author - utf8_strwidth(name);\n\t\t\t\tprintf(\" (%s%*s %10s\",\n\t\t\t\t       name, pad, \"\",\n\t\t\t\t       format_time(ci.author_time,\n\t\t\t\t\t\t   ci.author_tz.buf,\n\t\t\t\t\t\t   show_raw_time));\n\t\t\t}\n\t\t\tprintf(\" %*d) \",\n\t\t\t       max_digits, ent->lno + 1 + cnt);\n\t\t}\n\t\tdo {\n\t\t\tch = *cp++;\n\t\t\tputchar(ch);\n\t\t} while (ch != '\\n' &&\n\t\t\t cp < sb->final_buf + sb->final_buf_size);\n\t}\n\n\tif (sb->final_buf_size && cp[-1] != '\\n')\n\t\tputchar('\\n');\n\n\tcommit_info_destroy(&ci);\n}\n\nstatic void output(struct blame_scoreboard *sb, int option)\n{\n\tstruct blame_entry *ent;\n\n\tif (option & OUTPUT_PORCELAIN) {\n\t\tfor (ent = sb->ent; ent; ent = ent->next) {\n\t\t\tint count = 0;\n\t\t\tstruct blame_origin *suspect;\n\t\t\tstruct commit *commit = ent->suspect->commit;\n\t\t\tif (commit->object.flags & MORE_THAN_ONE_PATH)\n\t\t\t\tcontinue;\n\t\t\tfor (suspect = commit->util; suspect; suspect = suspect->next) {\n\t\t\t\tif (suspect->guilty && count++) {\n\t\t\t\t\tcommit->object.flags |= MORE_THAN_ONE_PATH;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (ent = sb->ent; ent; ent = ent->next) {\n\t\tif (option & OUTPUT_PORCELAIN)\n\t\t\temit_porcelain(sb, ent, option);\n\t\telse {\n\t\t\temit_other(sb, ent, option);\n\t\t}\n\t}\n}\n\n/*\n * Add phony grafts for use with -S; this is primarily to\n * support git's cvsserver that wants to give a linear history\n * to its clients.\n */\nstatic int read_ancestry(const char *graft_file)\n{\n\tFILE *fp = fopen_or_warn(graft_file, \"r\");\n\tstruct strbuf buf = STRBUF_INIT;\n\tif (!fp)\n\t\treturn -1;\n\twhile (!strbuf_getwholeline(&buf, fp, '\\n')) {\n\t\t/* The format is just \"Commit Parent1 Parent2 ...\\n\" */\n\t\tstruct commit_graft *graft = read_graft_line(&buf);\n\t\tif (graft)\n\t\t\tregister_commit_graft(graft, 0);\n\t}\n\tfclose(fp);\n\tstrbuf_release(&buf);\n\treturn 0;\n}\n\nstatic int update_auto_abbrev(int auto_abbrev, struct blame_origin *suspect)\n{\n\tconst char *uniq = find_unique_abbrev(suspect->commit->object.oid.hash,\n\t\t\t\t\t      auto_abbrev);\n\tint len = strlen(uniq);\n\tif (auto_abbrev < len)\n\t\treturn len;\n\treturn auto_abbrev;\n}\n\n/*\n * How many columns do we need to show line numbers, authors,\n * and filenames?\n */\nstatic void find_alignment(struct blame_scoreboard *sb, int *option)\n{\n\tint longest_src_lines = 0;\n\tint longest_dst_lines = 0;\n\tunsigned largest_score = 0;\n\tstruct blame_entry *e;\n\tint compute_auto_abbrev = (abbrev < 0);\n\tint auto_abbrev = DEFAULT_ABBREV;\n\n\tfor (e = sb->ent; e; e = e->next) {\n\t\tstruct blame_origin *suspect = e->suspect;\n\t\tint num;\n\n\t\tif (compute_auto_abbrev)\n\t\t\tauto_abbrev = update_auto_abbrev(auto_abbrev, suspect);\n\t\tif (strcmp(suspect->path, sb->path))\n\t\t\t*option |= OUTPUT_SHOW_NAME;\n\t\tnum = strlen(suspect->path);\n\t\tif (longest_file < num)\n\t\t\tlongest_file = num;\n\t\tif (!(suspect->commit->object.flags & METAINFO_SHOWN)) {\n\t\t\tstruct commit_info ci;\n\t\t\tsuspect->commit->object.flags |= METAINFO_SHOWN;\n\t\t\tget_commit_info(suspect->commit, &ci, 1);\n\t\t\tif (*option & OUTPUT_SHOW_EMAIL)\n\t\t\t\tnum = utf8_strwidth(ci.author_mail.buf);\n\t\t\telse\n\t\t\t\tnum = utf8_strwidth(ci.author.buf);\n\t\t\tif (longest_author < num)\n\t\t\t\tlongest_author = num;\n\t\t\tcommit_info_destroy(&ci);\n\t\t}\n\t\tnum = e->s_lno + e->num_lines;\n\t\tif (longest_src_lines < num)\n\t\t\tlongest_src_lines = num;\n\t\tnum = e->lno + e->num_lines;\n\t\tif (longest_dst_lines < num)\n\t\t\tlongest_dst_lines = num;\n\t\tif (largest_score < blame_entry_score(sb, e))\n\t\t\tlargest_score = blame_entry_score(sb, e);\n\t}\n\tmax_orig_digits = decimal_width(longest_src_lines);\n\tmax_digits = decimal_width(longest_dst_lines);\n\tmax_score_digits = decimal_width(largest_score);\n\n\tif (compute_auto_abbrev)\n\t\t/* one more abbrev length is needed for the boundary commit */\n\t\tabbrev = auto_abbrev + 1;\n}\n\nstatic void sanity_check_on_fail(struct blame_scoreboard *sb, int baa)\n{\n\tint opt = OUTPUT_SHOW_SCORE | OUTPUT_SHOW_NUMBER | OUTPUT_SHOW_NAME;\n\tfind_alignment(sb, &opt);\n\toutput(sb, opt);\n\tdie(\"Baa %d!\", baa);\n}\n\nstatic unsigned parse_score(const char *arg)\n{\n\tchar *end;\n\tunsigned long score = strtoul(arg, &end, 10);\n\tif (*end)\n\t\treturn 0;\n\treturn score;\n}\n\nstatic const char *add_prefix(const char *prefix, const char *path)\n{\n\treturn prefix_path(prefix, prefix ? strlen(prefix) : 0, path);\n}\n\nstatic int git_blame_config(const char *var, const char *value, void *cb)\n{\n\tif (!strcmp(var, \"blame.showroot\")) {\n\t\tshow_root = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\tif (!strcmp(var, \"blame.blankboundary\")) {\n\t\tblank_boundary = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\tif (!strcmp(var, \"blame.showemail\")) {\n\t\tint *output_option = cb;\n\t\tif (git_config_bool(var, value))\n\t\t\t*output_option |= OUTPUT_SHOW_EMAIL;\n\t\telse\n\t\t\t*output_option &= ~OUTPUT_SHOW_EMAIL;\n\t\treturn 0;\n\t}\n\tif (!strcmp(var, \"blame.date\")) {\n\t\tif (!value)\n\t\t\treturn config_error_nonbool(var);\n\t\tparse_date_format(value, &blame_date_mode);\n\t\treturn 0;\n\t}\n\n\tif (git_diff_heuristic_config(var, value, cb) < 0)\n\t\treturn -1;\n\tif (userdiff_config(var, value) < 0)\n\t\treturn -1;\n\n\treturn git_default_config(var, value, cb);\n}\n\nstatic int blame_copy_callback(const struct option *option, const char *arg, int unset)\n{\n\tint *opt = option->value;\n\n\t/*\n\t * -C enables copy from removed files;\n\t * -C -C enables copy from existing files, but only\n\t *       when blaming a new file;\n\t * -C -C -C enables copy from existing files for\n\t *          everybody\n\t */\n\tif (*opt & PICKAXE_BLAME_COPY_HARDER)\n\t\t*opt |= PICKAXE_BLAME_COPY_HARDEST;\n\tif (*opt & PICKAXE_BLAME_COPY)\n\t\t*opt |= PICKAXE_BLAME_COPY_HARDER;\n\t*opt |= PICKAXE_BLAME_COPY | PICKAXE_BLAME_MOVE;\n\n\tif (arg)\n\t\tblame_copy_score = parse_score(arg);\n\treturn 0;\n}\n\nstatic int blame_move_callback(const struct option *option, const char *arg, int unset)\n{\n\tint *opt = option->value;\n\n\t*opt |= PICKAXE_BLAME_MOVE;\n\n\tif (arg)\n\t\tblame_move_score = parse_score(arg);\n\treturn 0;\n}\n\nint cmd_blame(int argc, const char **argv, const char *prefix)\n{\n\tstruct rev_info revs;\n\tconst char *path;\n\tstruct blame_scoreboard sb;\n\tstruct blame_origin *o;\n\tstruct blame_entry *ent = NULL;\n\tlong dashdash_pos, lno;\n\tstruct progress_info pi = { NULL, 0 };\n\n\tstruct string_list range_list = STRING_LIST_INIT_NODUP;\n\tint output_option = 0, opt = 0;\n\tint show_stats = 0;\n\tconst char *revs_file = NULL;\n\tconst char *contents_from = NULL;\n\tconst struct option options[] = {\n\t\tOPT_BOOL(0, \"incremental\", &incremental, N_(\"Show blame entries as we find them, incrementally\")),\n\t\tOPT_BOOL('b', NULL, &blank_boundary, N_(\"Show blank SHA-1 for boundary commits (Default: off)\")),\n\t\tOPT_BOOL(0, \"root\", &show_root, N_(\"Do not treat root commits as boundaries (Default: off)\")),\n\t\tOPT_BOOL(0, \"show-stats\", &show_stats, N_(\"Show work cost statistics\")),\n\t\tOPT_BOOL(0, \"progress\", &show_progress, N_(\"Force progress reporting\")),\n\t\tOPT_BIT(0, \"score-debug\", &output_option, N_(\"Show output score for blame entries\"), OUTPUT_SHOW_SCORE),\n\t\tOPT_BIT('f', \"show-name\", &output_option, N_(\"Show original filename (Default: auto)\"), OUTPUT_SHOW_NAME),\n\t\tOPT_BIT('n', \"show-number\", &output_option, N_(\"Show original linenumber (Default: off)\"), OUTPUT_SHOW_NUMBER),\n\t\tOPT_BIT('p', \"porcelain\", &output_option, N_(\"Show in a format designed for machine consumption\"), OUTPUT_PORCELAIN),\n\t\tOPT_BIT(0, \"line-porcelain\", &output_option, N_(\"Show porcelain format with per-line commit information\"), OUTPUT_PORCELAIN|OUTPUT_LINE_PORCELAIN),\n\t\tOPT_BIT('c', NULL, &output_option, N_(\"Use the same output mode as git-annotate (Default: off)\"), OUTPUT_ANNOTATE_COMPAT),\n\t\tOPT_BIT('t', NULL, &output_option, N_(\"Show raw timestamp (Default: off)\"), OUTPUT_RAW_TIMESTAMP),\n\t\tOPT_BIT('l', NULL, &output_option, N_(\"Show long commit SHA1 (Default: off)\"), OUTPUT_LONG_OBJECT_NAME),\n\t\tOPT_BIT('s', NULL, &output_option, N_(\"Suppress author name and timestamp (Default: off)\"), OUTPUT_NO_AUTHOR),\n\t\tOPT_BIT('e', \"show-email\", &output_option, N_(\"Show author email instead of name (Default: off)\"), OUTPUT_SHOW_EMAIL),\n\t\tOPT_BIT('w', NULL, &xdl_opts, N_(\"Ignore whitespace differences\"), XDF_IGNORE_WHITESPACE),\n\n\t\t/*\n\t\t * The following two options are parsed by parse_revision_opt()\n\t\t * and are only included here to get included in the \"-h\"\n\t\t * output:\n\t\t */\n\t\t{ OPTION_LOWLEVEL_CALLBACK, 0, \"indent-heuristic\", NULL, NULL, N_(\"Use an experimental heuristic to improve diffs\"), PARSE_OPT_NOARG, parse_opt_unknown_cb },\n\n\t\tOPT_BIT(0, \"minimal\", &xdl_opts, N_(\"Spend extra cycles to find better match\"), XDF_NEED_MINIMAL),\n\t\tOPT_STRING('S', NULL, &revs_file, N_(\"file\"), N_(\"Use revisions from <file> instead of calling git-rev-list\")),\n\t\tOPT_STRING(0, \"contents\", &contents_from, N_(\"file\"), N_(\"Use <file>'s contents as the final image\")),\n\t\t{ OPTION_CALLBACK, 'C', NULL, &opt, N_(\"score\"), N_(\"Find line copies within and across files\"), PARSE_OPT_OPTARG, blame_copy_callback },\n\t\t{ OPTION_CALLBACK, 'M', NULL, &opt, N_(\"score\"), N_(\"Find line movements within and across files\"), PARSE_OPT_OPTARG, blame_move_callback },\n\t\tOPT_STRING_LIST('L', NULL, &range_list, N_(\"n,m\"), N_(\"Process only line range n,m, counting from 1\")),\n\t\tOPT__ABBREV(&abbrev),\n\t\tOPT_END()\n\t};\n\n\tstruct parse_opt_ctx_t ctx;\n\tint cmd_is_annotate = !strcmp(argv[0], \"annotate\");\n\tstruct range_set ranges;\n\tunsigned int range_i;\n\tlong anchor;\n\n\tgit_config(git_blame_config, &output_option);\n\tinit_revisions(&revs, NULL);\n\trevs.date_mode = blame_date_mode;\n\trevs.diffopt.flags.allow_textconv = 1;\n\trevs.diffopt.flags.follow_renames = 1;\n\n\tsave_commit_buffer = 0;\n\tdashdash_pos = 0;\n\tshow_progress = -1;\n\n\tparse_options_start(&ctx, argc, argv, prefix, options,\n\t\t\t    PARSE_OPT_KEEP_DASHDASH | PARSE_OPT_KEEP_ARGV0);\n\tfor (;;) {\n\t\tswitch (parse_options_step(&ctx, options, blame_opt_usage)) {\n\t\tcase PARSE_OPT_HELP:\n\t\t\texit(129);\n\t\tcase PARSE_OPT_DONE:\n\t\t\tif (ctx.argv[0])\n\t\t\t\tdashdash_pos = ctx.cpidx;\n\t\t\tgoto parse_done;\n\t\t}\n\n\t\tif (!strcmp(ctx.argv[0], \"--reverse\")) {\n\t\t\tctx.argv[0] = \"--children\";\n\t\t\treverse = 1;\n\t\t}\n\t\tparse_revision_opt(&revs, &ctx, options, blame_opt_usage);\n\t}\nparse_done:\n\tno_whole_file_rename = !revs.diffopt.flags.follow_renames;\n\txdl_opts |= revs.diffopt.xdl_opts & XDF_INDENT_HEURISTIC;\n\trevs.diffopt.flags.follow_renames = 0;\n\targc = parse_options_end(&ctx);\n\n\tif (incremental || (output_option & OUTPUT_PORCELAIN)) {\n\t\tif (show_progress > 0)\n\t\t\tdie(_(\"--progress can't be used with --incremental or porcelain formats\"));\n\t\tshow_progress = 0;\n\t} else if (show_progress < 0)\n\t\tshow_progress = isatty(2);\n\n\tif (0 < abbrev && abbrev < GIT_SHA1_HEXSZ)\n\t\t/* one more abbrev length is needed for the boundary commit */\n\t\tabbrev++;\n\telse if (!abbrev)\n\t\tabbrev = GIT_SHA1_HEXSZ;\n\n\tif (revs_file && read_ancestry(revs_file))\n\t\tdie_errno(\"reading graft file '%s' failed\", revs_file);\n\n\tif (cmd_is_annotate) {\n\t\toutput_option |= OUTPUT_ANNOTATE_COMPAT;\n\t\tblame_date_mode.type = DATE_ISO8601;\n\t} else {\n\t\tblame_date_mode = revs.date_mode;\n\t}\n\n\t/* The maximum width used to show the dates */\n\tswitch (blame_date_mode.type) {\n\tcase DATE_RFC2822:\n\t\tblame_date_width = sizeof(\"Thu, 19 Oct 2006 16:00:04 -0700\");\n\t\tbreak;\n\tcase DATE_ISO8601_STRICT:\n\t\tblame_date_width = sizeof(\"2006-10-19T16:00:04-07:00\");\n\t\tbreak;\n\tcase DATE_ISO8601:\n\t\tblame_date_width = sizeof(\"2006-10-19 16:00:04 -0700\");\n\t\tbreak;\n\tcase DATE_RAW:\n\t\tblame_date_width = sizeof(\"1161298804 -0700\");\n\t\tbreak;\n\tcase DATE_UNIX:\n\t\tblame_date_width = sizeof(\"1161298804\");\n\t\tbreak;\n\tcase DATE_SHORT:\n\t\tblame_date_width = sizeof(\"2006-10-19\");\n\t\tbreak;\n\tcase DATE_RELATIVE:\n\t\t/*\n\t\t * TRANSLATORS: This string is used to tell us the\n\t\t * maximum display width for a relative timestamp in\n\t\t * \"git blame\" output.  For C locale, \"4 years, 11\n\t\t * months ago\", which takes 22 places, is the longest\n\t\t * among various forms of relative timestamps, but\n\t\t * your language may need more or fewer display\n\t\t * columns.\n\t\t */\n\t\tblame_date_width = utf8_strwidth(_(\"4 years, 11 months ago\")) + 1; /* add the null */\n\t\tbreak;\n\tcase DATE_NORMAL:\n\t\tblame_date_width = sizeof(\"Thu Oct 19 16:00:04 2006 -0700\");\n\t\tbreak;\n\tcase DATE_STRFTIME:\n\t\tblame_date_width = strlen(show_date(0, 0, &blame_date_mode)) + 1; /* add the null */\n\t\tbreak;\n\t}\n\tblame_date_width -= 1; /* strip the null */\n\n\tif (revs.diffopt.flags.find_copies_harder)\n\t\topt |= (PICKAXE_BLAME_COPY | PICKAXE_BLAME_MOVE |\n\t\t\tPICKAXE_BLAME_COPY_HARDER);\n\n\t/*\n\t * We have collected options unknown to us in argv[1..unk]\n\t * which are to be passed to revision machinery if we are\n\t * going to do the \"bottom\" processing.\n\t *\n\t * The remaining are:\n\t *\n\t * (1) if dashdash_pos != 0, it is either\n\t *     \"blame [revisions] -- <path>\" or\n\t *     \"blame -- <path> <rev>\"\n\t *\n\t * (2) otherwise, it is one of the two:\n\t *     \"blame [revisions] <path>\"\n\t *     \"blame <path> <rev>\"\n\t *\n\t * Note that we must strip out <path> from the arguments: we do not\n\t * want the path pruning but we may want \"bottom\" processing.\n\t */\n\tif (dashdash_pos) {\n\t\tswitch (argc - dashdash_pos - 1) {\n\t\tcase 2: /* (1b) */\n\t\t\tif (argc != 4)\n\t\t\t\tusage_with_options(blame_opt_usage, options);\n\t\t\t/* reorder for the new way: <rev> -- <path> */\n\t\t\targv[1] = argv[3];\n\t\t\targv[3] = argv[2];\n\t\t\targv[2] = \"--\";\n\t\t\t/* FALLTHROUGH */\n\t\tcase 1: /* (1a) */\n\t\t\tpath = add_prefix(prefix, argv[--argc]);\n\t\t\targv[argc] = NULL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage_with_options(blame_opt_usage, options);\n\t\t}\n\t} else {\n\t\tif (argc < 2)\n\t\t\tusage_with_options(blame_opt_usage, options);\n\t\tpath = add_prefix(prefix, argv[argc - 1]);\n\t\tif (argc == 3 && !file_exists(path)) { /* (2b) */\n\t\t\tpath = add_prefix(prefix, argv[1]);\n\t\t\targv[1] = argv[2];\n\t\t}\n\t\targv[argc - 1] = \"--\";\n\n\t\tsetup_work_tree();\n\t\tif (!file_exists(path))\n\t\t\tdie_errno(\"cannot stat path '%s'\", path);\n\t}\n\n\trevs.disable_stdin = 1;\n\tsetup_revisions(argc, argv, &revs, NULL);\n\n\tinit_scoreboard(&sb);\n\tsb.revs = &revs;\n\tsb.contents_from = contents_from;\n\tsb.reverse = reverse;\n\tsetup_scoreboard(&sb, path, &o);\n\tlno = sb.num_lines;\n\n\tif (lno && !range_list.nr)\n\t\tstring_list_append(&range_list, \"1\");\n\n\tanchor = 1;\n\trange_set_init(&ranges, range_list.nr);\n\tfor (range_i = 0; range_i < range_list.nr; ++range_i) {\n\t\tlong bottom, top;\n\t\tif (parse_range_arg(range_list.items[range_i].string,\n\t\t\t\t    nth_line_cb, &sb, lno, anchor,\n\t\t\t\t    &bottom, &top, sb.path))\n\t\t\tusage(blame_usage);\n\t\tif (lno < top || ((lno || bottom) && lno < bottom))\n\t\t\tdie(Q_(\"file %s has only %lu line\",\n\t\t\t       \"file %s has only %lu lines\",\n\t\t\t       lno), path, lno);\n\t\tif (bottom < 1)\n\t\t\tbottom = 1;\n\t\tif (top < 1)\n\t\t\ttop = lno;\n\t\tbottom--;\n\t\trange_set_append_unsafe(&ranges, bottom, top);\n\t\tanchor = top + 1;\n\t}\n\tsort_and_merge_range_set(&ranges);\n\n\tfor (range_i = ranges.nr; range_i > 0; --range_i) {\n\t\tconst struct range *r = &ranges.ranges[range_i - 1];\n\t\tent = blame_entry_prepend(ent, r->start, r->end, o);\n\t}\n\n\to->suspects = ent;\n\tprio_queue_put(&sb.commits, o->commit);\n\n\tblame_origin_decref(o);\n\n\trange_set_release(&ranges);\n\tstring_list_clear(&range_list, 0);\n\n\tsb.ent = NULL;\n\tsb.path = path;\n\n\tif (blame_move_score)\n\t\tsb.move_score = blame_move_score;\n\tif (blame_copy_score)\n\t\tsb.copy_score = blame_copy_score;\n\n\tsb.debug = DEBUG;\n\tsb.on_sanity_fail = &sanity_check_on_fail;\n\n\tsb.show_root = show_root;\n\tsb.xdl_opts = xdl_opts;\n\tsb.no_whole_file_rename = no_whole_file_rename;\n\n\tread_mailmap(&mailmap, NULL);\n\n\tsb.found_guilty_entry = &found_guilty_entry;\n\tsb.found_guilty_entry_data = &pi;\n\tif (show_progress)\n\t\tpi.progress = start_delayed_progress(_(\"Blaming lines\"), sb.num_lines);\n\n\tassign_blame(&sb, opt);\n\n\tstop_progress(&pi.progress);\n\n\tif (!incremental)\n\t\tsetup_pager();\n\telse\n\t\treturn 0;\n\n\tblame_sort_final(&sb);\n\n\tblame_coalesce(&sb);\n\n\tif (!(output_option & OUTPUT_PORCELAIN))\n\t\tfind_alignment(&sb, &output_option);\n\n\toutput(&sb, output_option);\n\tfree((void *)sb.final_buf);\n\tfor (ent = sb.ent; ent; ) {\n\t\tstruct blame_entry *e = ent->next;\n\t\tfree(ent);\n\t\tent = e;\n\t}\n\n\tif (show_stats) {\n\t\tprintf(\"num read blob: %d\\n\", sb.num_read_blob);\n\t\tprintf(\"num get patch: %d\\n\", sb.num_get_patch);\n\t\tprintf(\"num commits: %d\\n\", sb.num_commits);\n\t}\n\treturn 0;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "005f55aaa257fc34f81517650223a3c195c03178",
  "sha1_ok": true,
  "size": 26713
}
