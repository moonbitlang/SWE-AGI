{
  "content": {
    "base64": "LyoKICogQnVpbHRpbiAiZ2l0IGRpZmYiCiAqCiAqIENvcHlyaWdodCAoYykgMjAwNiBKdW5pbyBDIEhhbWFubwogKi8KI2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJjb25maWcuaCIKI2luY2x1ZGUgImxvY2tmaWxlLmgiCiNpbmNsdWRlICJjb2xvci5oIgojaW5jbHVkZSAiY29tbWl0LmgiCiNpbmNsdWRlICJibG9iLmgiCiNpbmNsdWRlICJ0YWcuaCIKI2luY2x1ZGUgImRpZmYuaCIKI2luY2x1ZGUgImRpZmZjb3JlLmgiCiNpbmNsdWRlICJyZXZpc2lvbi5oIgojaW5jbHVkZSAibG9nLXRyZWUuaCIKI2luY2x1ZGUgImJ1aWx0aW4uaCIKI2luY2x1ZGUgInN1Ym1vZHVsZS5oIgojaW5jbHVkZSAic2hhMS1hcnJheS5oIgoKI2RlZmluZSBESUZGX05PX0lOREVYX0VYUExJQ0lUIDEKI2RlZmluZSBESUZGX05PX0lOREVYX0lNUExJQ0lUIDIKCnN0YXRpYyBjb25zdCBjaGFyIGJ1aWx0aW5fZGlmZl91c2FnZVtdID0KImdpdCBkaWZmIFs8b3B0aW9ucz5dIFs8Y29tbWl0PiBbPGNvbW1pdD5dXSBbLS1dIFs8cGF0aD4uLi5dIjsKCnN0YXRpYyBjb25zdCBjaGFyICpibG9iX3BhdGgoc3RydWN0IG9iamVjdF9hcnJheV9lbnRyeSAqZW50cnkpCnsKCXJldHVybiBlbnRyeS0+cGF0aCA/IGVudHJ5LT5wYXRoIDogZW50cnktPm5hbWU7Cn0KCnN0YXRpYyB2b2lkIHN0dWZmX2NoYW5nZShzdHJ1Y3QgZGlmZl9vcHRpb25zICpvcHQsCgkJCSB1bnNpZ25lZCBvbGRfbW9kZSwgdW5zaWduZWQgbmV3X21vZGUsCgkJCSBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvbGRfb2lkLAoJCQkgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqbmV3X29pZCwKCQkJIGludCBvbGRfb2lkX3ZhbGlkLAoJCQkgaW50IG5ld19vaWRfdmFsaWQsCgkJCSBjb25zdCBjaGFyICpvbGRfcGF0aCwKCQkJIGNvbnN0IGNoYXIgKm5ld19wYXRoKQp7CglzdHJ1Y3QgZGlmZl9maWxlc3BlYyAqb25lLCAqdHdvOwoKCWlmICghaXNfbnVsbF9vaWQob2xkX29pZCkgJiYgIWlzX251bGxfb2lkKG5ld19vaWQpICYmCgkgICAgIW9pZGNtcChvbGRfb2lkLCBuZXdfb2lkKSAmJiAob2xkX21vZGUgPT0gbmV3X21vZGUpKQoJCXJldHVybjsKCglpZiAob3B0LT5mbGFncy5yZXZlcnNlX2RpZmYpIHsKCQlTV0FQKG9sZF9tb2RlLCBuZXdfbW9kZSk7CgkJU1dBUChvbGRfb2lkLCBuZXdfb2lkKTsKCQlTV0FQKG9sZF9wYXRoLCBuZXdfcGF0aCk7Cgl9CgoJaWYgKG9wdC0+cHJlZml4ICYmCgkgICAgKHN0cm5jbXAob2xkX3BhdGgsIG9wdC0+cHJlZml4LCBvcHQtPnByZWZpeF9sZW5ndGgpIHx8CgkgICAgIHN0cm5jbXAobmV3X3BhdGgsIG9wdC0+cHJlZml4LCBvcHQtPnByZWZpeF9sZW5ndGgpKSkKCQlyZXR1cm47CgoJb25lID0gYWxsb2NfZmlsZXNwZWMob2xkX3BhdGgpOwoJdHdvID0gYWxsb2NfZmlsZXNwZWMobmV3X3BhdGgpOwoJZmlsbF9maWxlc3BlYyhvbmUsIG9sZF9vaWQsIG9sZF9vaWRfdmFsaWQsIG9sZF9tb2RlKTsKCWZpbGxfZmlsZXNwZWModHdvLCBuZXdfb2lkLCBuZXdfb2lkX3ZhbGlkLCBuZXdfbW9kZSk7CgoJZGlmZl9xdWV1ZSgmZGlmZl9xdWV1ZWRfZGlmZiwgb25lLCB0d28pOwp9CgpzdGF0aWMgaW50IGJ1aWx0aW5fZGlmZl9iX2Yoc3RydWN0IHJldl9pbmZvICpyZXZzLAoJCQkgICAgaW50IGFyZ2MsIGNvbnN0IGNoYXIgKiphcmd2LAoJCQkgICAgc3RydWN0IG9iamVjdF9hcnJheV9lbnRyeSAqKmJsb2IpCnsKCS8qIEJsb2IgdnMgZmlsZSBpbiB0aGUgd29ya2luZyB0cmVlKi8KCXN0cnVjdCBzdGF0IHN0OwoJY29uc3QgY2hhciAqcGF0aDsKCglpZiAoYXJnYyA+IDEpCgkJdXNhZ2UoYnVpbHRpbl9kaWZmX3VzYWdlKTsKCglHVUFSRF9QQVRIU1BFQygmcmV2cy0+cHJ1bmVfZGF0YSwgUEFUSFNQRUNfRlJPTVRPUCB8IFBBVEhTUEVDX0xJVEVSQUwpOwoJcGF0aCA9IHJldnMtPnBydW5lX2RhdGEuaXRlbXNbMF0ubWF0Y2g7CgoJaWYgKGxzdGF0KHBhdGgsICZzdCkpCgkJZGllX2Vycm5vKF8oImZhaWxlZCB0byBzdGF0ICclcyciKSwgcGF0aCk7CglpZiAoIShTX0lTUkVHKHN0LnN0X21vZGUpIHx8IFNfSVNMTksoc3Quc3RfbW9kZSkpKQoJCWRpZShfKCInJXMnOiBub3QgYSByZWd1bGFyIGZpbGUgb3Igc3ltbGluayIpLCBwYXRoKTsKCglkaWZmX3NldF9tbmVtb25pY19wcmVmaXgoJnJldnMtPmRpZmZvcHQsICJvLyIsICJ3LyIpOwoKCWlmIChibG9iWzBdLT5tb2RlID09IFNfSUZJTlZBTElEKQoJCWJsb2JbMF0tPm1vZGUgPSBjYW5vbl9tb2RlKHN0LnN0X21vZGUpOwoKCXN0dWZmX2NoYW5nZSgmcmV2cy0+ZGlmZm9wdCwKCQkgICAgIGJsb2JbMF0tPm1vZGUsIGNhbm9uX21vZGUoc3Quc3RfbW9kZSksCgkJICAgICAmYmxvYlswXS0+aXRlbS0+b2lkLCAmbnVsbF9vaWQsCgkJICAgICAxLCAwLAoJCSAgICAgYmxvYlswXS0+cGF0aCA/IGJsb2JbMF0tPnBhdGggOiBwYXRoLAoJCSAgICAgcGF0aCk7CglkaWZmY29yZV9zdGQoJnJldnMtPmRpZmZvcHQpOwoJZGlmZl9mbHVzaCgmcmV2cy0+ZGlmZm9wdCk7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBidWlsdGluX2RpZmZfYmxvYnMoc3RydWN0IHJldl9pbmZvICpyZXZzLAoJCQkgICAgICBpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsCgkJCSAgICAgIHN0cnVjdCBvYmplY3RfYXJyYXlfZW50cnkgKipibG9iKQp7Cgl1bnNpZ25lZCBtb2RlID0gY2Fub25fbW9kZShTX0lGUkVHIHwgMDY0NCk7CgoJaWYgKGFyZ2MgPiAxKQoJCXVzYWdlKGJ1aWx0aW5fZGlmZl91c2FnZSk7CgoJaWYgKGJsb2JbMF0tPm1vZGUgPT0gU19JRklOVkFMSUQpCgkJYmxvYlswXS0+bW9kZSA9IG1vZGU7CgoJaWYgKGJsb2JbMV0tPm1vZGUgPT0gU19JRklOVkFMSUQpCgkJYmxvYlsxXS0+bW9kZSA9IG1vZGU7CgoJc3R1ZmZfY2hhbmdlKCZyZXZzLT5kaWZmb3B0LAoJCSAgICAgYmxvYlswXS0+bW9kZSwgYmxvYlsxXS0+bW9kZSwKCQkgICAgICZibG9iWzBdLT5pdGVtLT5vaWQsICZibG9iWzFdLT5pdGVtLT5vaWQsCgkJICAgICAxLCAxLAoJCSAgICAgYmxvYl9wYXRoKGJsb2JbMF0pLCBibG9iX3BhdGgoYmxvYlsxXSkpOwoJZGlmZmNvcmVfc3RkKCZyZXZzLT5kaWZmb3B0KTsKCWRpZmZfZmx1c2goJnJldnMtPmRpZmZvcHQpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgYnVpbHRpbl9kaWZmX2luZGV4KHN0cnVjdCByZXZfaW5mbyAqcmV2cywKCQkJICAgICAgaW50IGFyZ2MsIGNvbnN0IGNoYXIgKiphcmd2KQp7CglpbnQgY2FjaGVkID0gMDsKCXdoaWxlICgxIDwgYXJnYykgewoJCWNvbnN0IGNoYXIgKmFyZyA9IGFyZ3ZbMV07CgkJaWYgKCFzdHJjbXAoYXJnLCAiLS1jYWNoZWQiKSB8fCAhc3RyY21wKGFyZywgIi0tc3RhZ2VkIikpCgkJCWNhY2hlZCA9IDE7CgkJZWxzZQoJCQl1c2FnZShidWlsdGluX2RpZmZfdXNhZ2UpOwoJCWFyZ3YrKzsgYXJnYy0tOwoJfQoJLyoKCSAqIE1ha2Ugc3VyZSB0aGVyZSBpcyBvbmUgcmV2aXNpb24gKGkuZS4gcGVuZGluZyBvYmplY3QpLAoJICogYW5kIHRoZXJlIGlzIG5vIHJldmlzaW9uIGZpbHRlcmluZyBwYXJhbWV0ZXJzLgoJICovCglpZiAocmV2cy0+cGVuZGluZy5uciAhPSAxIHx8CgkgICAgcmV2cy0+bWF4X2NvdW50ICE9IC0xIHx8IHJldnMtPm1pbl9hZ2UgIT0gLTEgfHwKCSAgICByZXZzLT5tYXhfYWdlICE9IC0xKQoJCXVzYWdlKGJ1aWx0aW5fZGlmZl91c2FnZSk7CglpZiAoIWNhY2hlZCkgewoJCXNldHVwX3dvcmtfdHJlZSgpOwoJCWlmIChyZWFkX2NhY2hlX3ByZWxvYWQoJnJldnMtPmRpZmZvcHQucGF0aHNwZWMpIDwgMCkgewoJCQlwZXJyb3IoInJlYWRfY2FjaGVfcHJlbG9hZCIpOwoJCQlyZXR1cm4gLTE7CgkJfQoJfSBlbHNlIGlmIChyZWFkX2NhY2hlKCkgPCAwKSB7CgkJcGVycm9yKCJyZWFkX2NhY2hlIik7CgkJcmV0dXJuIC0xOwoJfQoJcmV0dXJuIHJ1bl9kaWZmX2luZGV4KHJldnMsIGNhY2hlZCk7Cn0KCnN0YXRpYyBpbnQgYnVpbHRpbl9kaWZmX3RyZWUoc3RydWN0IHJldl9pbmZvICpyZXZzLAoJCQkgICAgIGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndiwKCQkJICAgICBzdHJ1Y3Qgb2JqZWN0X2FycmF5X2VudHJ5ICplbnQwLAoJCQkgICAgIHN0cnVjdCBvYmplY3RfYXJyYXlfZW50cnkgKmVudDEpCnsKCWNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKihvaWRbMl0pOwoJaW50IHN3YXAgPSAwOwoKCWlmIChhcmdjID4gMSkKCQl1c2FnZShidWlsdGluX2RpZmZfdXNhZ2UpOwoKCS8qCgkgKiBXZSBzYXcgdHdvIHRyZWVzLCBlbnQwIGFuZCBlbnQxLiAgSWYgZW50MSBpcyB1bmludGVyZXN0aW5nLAoJICogc3dhcCB0aGVtLgoJICovCglpZiAoZW50MS0+aXRlbS0+ZmxhZ3MgJiBVTklOVEVSRVNUSU5HKQoJCXN3YXAgPSAxOwoJb2lkW3N3YXBdID0gJmVudDAtPml0ZW0tPm9pZDsKCW9pZFsxIC0gc3dhcF0gPSAmZW50MS0+aXRlbS0+b2lkOwoJZGlmZl90cmVlX29pZChvaWRbMF0sIG9pZFsxXSwgIiIsICZyZXZzLT5kaWZmb3B0KTsKCWxvZ190cmVlX2RpZmZfZmx1c2gocmV2cyk7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBidWlsdGluX2RpZmZfY29tYmluZWQoc3RydWN0IHJldl9pbmZvICpyZXZzLAoJCQkJIGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndiwKCQkJCSBzdHJ1Y3Qgb2JqZWN0X2FycmF5X2VudHJ5ICplbnQsCgkJCQkgaW50IGVudHMpCnsKCXN0cnVjdCBvaWRfYXJyYXkgcGFyZW50cyA9IE9JRF9BUlJBWV9JTklUOwoJaW50IGk7CgoJaWYgKGFyZ2MgPiAxKQoJCXVzYWdlKGJ1aWx0aW5fZGlmZl91c2FnZSk7CgoJaWYgKCFyZXZzLT5kZW5zZV9jb21iaW5lZF9tZXJnZXMgJiYgIXJldnMtPmNvbWJpbmVfbWVyZ2VzKQoJCXJldnMtPmRlbnNlX2NvbWJpbmVkX21lcmdlcyA9IHJldnMtPmNvbWJpbmVfbWVyZ2VzID0gMTsKCWZvciAoaSA9IDE7IGkgPCBlbnRzOyBpKyspCgkJb2lkX2FycmF5X2FwcGVuZCgmcGFyZW50cywgJmVudFtpXS5pdGVtLT5vaWQpOwoJZGlmZl90cmVlX2NvbWJpbmVkKCZlbnRbMF0uaXRlbS0+b2lkLCAmcGFyZW50cywKCQkJICAgcmV2cy0+ZGVuc2VfY29tYmluZWRfbWVyZ2VzLCByZXZzKTsKCW9pZF9hcnJheV9jbGVhcigmcGFyZW50cyk7CglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgcmVmcmVzaF9pbmRleF9xdWlldGx5KHZvaWQpCnsKCXN0cnVjdCBsb2NrX2ZpbGUgbG9ja19maWxlID0gTE9DS19JTklUOwoJaW50IGZkOwoKCWZkID0gaG9sZF9sb2NrZWRfaW5kZXgoJmxvY2tfZmlsZSwgMCk7CglpZiAoZmQgPCAwKQoJCXJldHVybjsKCWRpc2NhcmRfY2FjaGUoKTsKCXJlYWRfY2FjaGUoKTsKCXJlZnJlc2hfY2FjaGUoUkVGUkVTSF9RVUlFVHxSRUZSRVNIX1VOTUVSR0VEKTsKCXVwZGF0ZV9pbmRleF9pZl9hYmxlKCZ0aGVfaW5kZXgsICZsb2NrX2ZpbGUpOwp9CgpzdGF0aWMgaW50IGJ1aWx0aW5fZGlmZl9maWxlcyhzdHJ1Y3QgcmV2X2luZm8gKnJldnMsIGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndikKewoJdW5zaWduZWQgaW50IG9wdGlvbnMgPSAwOwoKCXdoaWxlICgxIDwgYXJnYyAmJiBhcmd2WzFdWzBdID09ICctJykgewoJCWlmICghc3RyY21wKGFyZ3ZbMV0sICItLWJhc2UiKSkKCQkJcmV2cy0+bWF4X2NvdW50ID0gMTsKCQllbHNlIGlmICghc3RyY21wKGFyZ3ZbMV0sICItLW91cnMiKSkKCQkJcmV2cy0+bWF4X2NvdW50ID0gMjsKCQllbHNlIGlmICghc3RyY21wKGFyZ3ZbMV0sICItLXRoZWlycyIpKQoJCQlyZXZzLT5tYXhfY291bnQgPSAzOwoJCWVsc2UgaWYgKCFzdHJjbXAoYXJndlsxXSwgIi1xIikpCgkJCW9wdGlvbnMgfD0gRElGRl9TSUxFTlRfT05fUkVNT1ZFRDsKCQllbHNlIGlmICghc3RyY21wKGFyZ3ZbMV0sICItaCIpKQoJCQl1c2FnZShidWlsdGluX2RpZmZfdXNhZ2UpOwoJCWVsc2UKCQkJcmV0dXJuIGVycm9yKF8oImludmFsaWQgb3B0aW9uOiAlcyIpLCBhcmd2WzFdKTsKCQlhcmd2Kys7IGFyZ2MtLTsKCX0KCgkvKgoJICogImRpZmYgLS1iYXNlIiBzaG91bGQgbm90IGNvbWJpbmUgbWVyZ2VzIGJlY2F1c2UgaXQgd2FzIG5vdAoJICogYXNrZWQgdG8uICAiZGlmZiAtYyIgc2hvdWxkIG5vdCBkZW5zaWZ5IChpZiB0aGUgdXNlciB3YW50cwoJICogZGVuc2Ugb25lLCAtLWNjIGNhbiBiZSBleHBsaWNpdGx5IGFza2VkIGZvciwgb3IganVzdCByZWx5CgkgKiBvbiB0aGUgZGVmYXVsdCkuCgkgKi8KCWlmIChyZXZzLT5tYXhfY291bnQgPT0gLTEgJiYgIXJldnMtPmNvbWJpbmVfbWVyZ2VzICYmCgkgICAgKHJldnMtPmRpZmZvcHQub3V0cHV0X2Zvcm1hdCAmIERJRkZfRk9STUFUX1BBVENIKSkKCQlyZXZzLT5jb21iaW5lX21lcmdlcyA9IHJldnMtPmRlbnNlX2NvbWJpbmVkX21lcmdlcyA9IDE7CgoJc2V0dXBfd29ya190cmVlKCk7CglpZiAocmVhZF9jYWNoZV9wcmVsb2FkKCZyZXZzLT5kaWZmb3B0LnBhdGhzcGVjKSA8IDApIHsKCQlwZXJyb3IoInJlYWRfY2FjaGVfcHJlbG9hZCIpOwoJCXJldHVybiAtMTsKCX0KCXJldHVybiBydW5fZGlmZl9maWxlcyhyZXZzLCBvcHRpb25zKTsKfQoKaW50IGNtZF9kaWZmKGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndiwgY29uc3QgY2hhciAqcHJlZml4KQp7CglpbnQgaTsKCXN0cnVjdCByZXZfaW5mbyByZXY7CglzdHJ1Y3Qgb2JqZWN0X2FycmF5IGVudCA9IE9CSkVDVF9BUlJBWV9JTklUOwoJaW50IGJsb2JzID0gMCwgcGF0aHMgPSAwOwoJc3RydWN0IG9iamVjdF9hcnJheV9lbnRyeSAqYmxvYlsyXTsKCWludCBub25naXQgPSAwLCBub19pbmRleCA9IDA7CglpbnQgcmVzdWx0ID0gMDsKCgkvKgoJICogV2UgY291bGQgZ2V0IE4gdHJlZS1pc2ggaW4gdGhlIHJldi5wZW5kaW5nX29iamVjdHMgbGlzdC4KCSAqIEFsc28gdGhlcmUgY291bGQgYmUgTSBibG9icyB0aGVyZSwgYW5kIFAgcGF0aHNwZWNzLgoJICoKCSAqIE49MCwgTT0wOgoJICoJY2FjaGUgdnMgZmlsZXMgKGRpZmYtZmlsZXMpCgkgKiBOPTAsIE09MjoKCSAqICAgICAgY29tcGFyZSB0d28gcmFuZG9tIGJsb2JzLiAgUCBtdXN0IGJlIHplcm8uCgkgKiBOPTAsIE09MSwgUD0xOgoJICoJY29tcGFyZSBhIGJsb2Igd2l0aCBhIHdvcmtpbmcgdHJlZSBmaWxlLgoJICoKCSAqIE49MSwgTT0wOgoJICogICAgICB0cmVlIHZzIGNhY2hlIChkaWZmLWluZGV4IC0tY2FjaGVkKQoJICoKCSAqIE49MiwgTT0wOgoJICogICAgICB0cmVlIHZzIHRyZWUgKGRpZmYtdHJlZSkKCSAqCgkgKiBOPTAsIE09MCwgUD0yOgoJICogICAgICBjb21wYXJlIHR3byBmaWxlc3lzdGVtIGVudGl0aWVzIChha2EgLS1uby1pbmRleCkuCgkgKgoJICogT3RoZXIgY2FzZXMgYXJlIGVycm9ycy4KCSAqLwoKCS8qIFdlcmUgd2UgYXNrZWQgdG8gZG8gLS1uby1pbmRleCBleHBsaWNpdGx5PyAqLwoJZm9yIChpID0gMTsgaSA8IGFyZ2M7IGkrKykgewoJCWlmICghc3RyY21wKGFyZ3ZbaV0sICItLSIpKSB7CgkJCWkrKzsKCQkJYnJlYWs7CgkJfQoJCWlmICghc3RyY21wKGFyZ3ZbaV0sICItLW5vLWluZGV4IikpCgkJCW5vX2luZGV4ID0gRElGRl9OT19JTkRFWF9FWFBMSUNJVDsKCQlpZiAoYXJndltpXVswXSAhPSAnLScpCgkJCWJyZWFrOwoJfQoKCXByZWZpeCA9IHNldHVwX2dpdF9kaXJlY3RvcnlfZ2VudGx5KCZub25naXQpOwoKCWlmICghbm9faW5kZXgpIHsKCQkvKgoJCSAqIFRyZWF0IGdpdCBkaWZmIHdpdGggYXQgbGVhc3Qgb25lIHBhdGggb3V0c2lkZSBvZiB0aGUKCQkgKiByZXBvIHRoZSBzYW1lIGFzIGlmIHRoZSBjb21tYW5kIHdvdWxkIGhhdmUgYmVlbiBleGVjdXRlZAoJCSAqIG91dHNpZGUgb2YgYSBnaXQgcmVwb3NpdG9yeS4gIEluIHRoaXMgY2FzZSBpdCBiZWhhdmVzCgkJICogdGhlIHNhbWUgd2F5IGFzICJnaXQgZGlmZiAtLW5vLWluZGV4IDxhPiA8Yj4iLCB3aGljaCBhY3RzCgkJICogYXMgYSBjb2xvdXJmdWwgImRpZmYiIHJlcGxhY2VtZW50LgoJCSAqLwoJCWlmIChub25naXQgfHwgKChhcmdjID09IGkgKyAyKSAmJgoJCQkgICAgICAgKCFwYXRoX2luc2lkZV9yZXBvKHByZWZpeCwgYXJndltpXSkgfHwKCQkJCSFwYXRoX2luc2lkZV9yZXBvKHByZWZpeCwgYXJndltpICsgMV0pKSkpCgkJCW5vX2luZGV4ID0gRElGRl9OT19JTkRFWF9JTVBMSUNJVDsKCX0KCglpbml0X2RpZmZfdWlfZGVmYXVsdHMoKTsKCWdpdF9jb25maWcoZ2l0X2RpZmZfdWlfY29uZmlnLCBOVUxMKTsKCXByZWNvbXBvc2VfYXJndihhcmdjLCBhcmd2KTsKCglpbml0X3JldmlzaW9ucygmcmV2LCBwcmVmaXgpOwoKCWlmIChub19pbmRleCAmJiBhcmdjICE9IGkgKyAyKSB7CgkJaWYgKG5vX2luZGV4ID09IERJRkZfTk9fSU5ERVhfSU1QTElDSVQpIHsKCQkJLyoKCQkJICogVGhlcmUgd2FzIG5vIC0tbm8taW5kZXggYW5kIHRoZXJlIHdlcmUgbm90IHR3bwoJCQkgKiBwYXRocy4gSXQgaXMgcG9zc2libGUgdGhhdCB0aGUgdXNlciBpbnRlbmRlZAoJCQkgKiB0byBkbyBhbiBpbnNpZGUtcmVwb3NpdG9yeSBvcGVyYXRpb24uCgkJCSAqLwoJCQlmcHJpbnRmKHN0ZGVyciwgIk5vdCBhIGdpdCByZXBvc2l0b3J5XG4iKTsKCQkJZnByaW50ZihzdGRlcnIsCgkJCQkiVG8gY29tcGFyZSB0d28gcGF0aHMgb3V0c2lkZSBhIHdvcmtpbmcgdHJlZTpcbiIpOwoJCX0KCQkvKiBHaXZlIHRoZSB1c2FnZSBtZXNzYWdlIGZvciBub24tcmVwb3NpdG9yeSB1c2FnZSBhbmQgZXhpdC4gKi8KCQl1c2FnZWYoImdpdCBkaWZmICVzIDxwYXRoPiA8cGF0aD4iLAoJCSAgICAgICBub19pbmRleCA9PSBESUZGX05PX0lOREVYX0VYUExJQ0lUID8KCQkgICAgICAgIi0tbm8taW5kZXgiIDogIlstLW5vLWluZGV4XSIpOwoKCX0KCWlmIChub19pbmRleCkKCQkvKiBJZiB0aGlzIGlzIGEgbm8taW5kZXggZGlmZiwganVzdCBydW4gaXQgYW5kIGV4aXQgdGhlcmUuICovCgkJZGlmZl9ub19pbmRleCgmcmV2LCBhcmdjLCBhcmd2KTsKCgkvKiBPdGhlcndpc2UsIHdlIGFyZSBkb2luZyB0aGUgdXN1YWwgImdpdCIgZGlmZiAqLwoJcmV2LmRpZmZvcHQuc2tpcF9zdGF0X3VubWF0Y2ggPSAhIWRpZmZfYXV0b19yZWZyZXNoX2luZGV4OwoKCS8qIFNjYWxlIHRvIHJlYWwgdGVybWluYWwgc2l6ZSBhbmQgcmVzcGVjdCBzdGF0R3JhcGhXaWR0aCBjb25maWcgKi8KCXJldi5kaWZmb3B0LnN0YXRfd2lkdGggPSAtMTsKCXJldi5kaWZmb3B0LnN0YXRfZ3JhcGhfd2lkdGggPSAtMTsKCgkvKiBEZWZhdWx0IHRvIGxldCBleHRlcm5hbCBhbmQgdGV4dGNvbnYgYmUgdXNlZCAqLwoJcmV2LmRpZmZvcHQuZmxhZ3MuYWxsb3dfZXh0ZXJuYWwgPSAxOwoJcmV2LmRpZmZvcHQuZmxhZ3MuYWxsb3dfdGV4dGNvbnYgPSAxOwoKCS8qCgkgKiBEZWZhdWx0IHRvIGludGVudC10by1hZGQgZW50cmllcyBpbnZpc2libGUgaW4gdGhlCgkgKiBpbmRleC4gVGhpcyBtYWtlcyB0aGVtIHNob3cgdXAgYXMgbmV3IGZpbGVzIGluIGRpZmYtZmlsZXMKCSAqIGFuZCBub3QgYXQgYWxsIGluIGRpZmYtY2FjaGVkLgoJICovCglyZXYuZGlmZm9wdC5pdGFfaW52aXNpYmxlX2luX2luZGV4ID0gMTsKCglpZiAobm9uZ2l0KQoJCWRpZShfKCJOb3QgYSBnaXQgcmVwb3NpdG9yeSIpKTsKCWFyZ2MgPSBzZXR1cF9yZXZpc2lvbnMoYXJnYywgYXJndiwgJnJldiwgTlVMTCk7CglpZiAoIXJldi5kaWZmb3B0Lm91dHB1dF9mb3JtYXQpIHsKCQlyZXYuZGlmZm9wdC5vdXRwdXRfZm9ybWF0ID0gRElGRl9GT1JNQVRfUEFUQ0g7CgkJZGlmZl9zZXR1cF9kb25lKCZyZXYuZGlmZm9wdCk7Cgl9CgoJcmV2LmRpZmZvcHQuZmxhZ3MucmVjdXJzaXZlID0gMTsKCglzZXR1cF9kaWZmX3BhZ2VyKCZyZXYuZGlmZm9wdCk7CgoJLyoKCSAqIERvIHdlIGhhdmUgLS1jYWNoZWQgYW5kIG5vdCBoYXZlIGEgcGVuZGluZyBvYmplY3QsIHRoZW4KCSAqIGRlZmF1bHQgdG8gSEVBRCBieSBoYW5kLiAgRWVrLgoJICovCglpZiAoIXJldi5wZW5kaW5nLm5yKSB7CgkJaW50IGk7CgkJZm9yIChpID0gMTsgaSA8IGFyZ2M7IGkrKykgewoJCQljb25zdCBjaGFyICphcmcgPSBhcmd2W2ldOwoJCQlpZiAoIXN0cmNtcChhcmcsICItLSIpKQoJCQkJYnJlYWs7CgkJCWVsc2UgaWYgKCFzdHJjbXAoYXJnLCAiLS1jYWNoZWQiKSB8fAoJCQkJICFzdHJjbXAoYXJnLCAiLS1zdGFnZWQiKSkgewoJCQkJYWRkX2hlYWRfdG9fcGVuZGluZygmcmV2KTsKCQkJCWlmICghcmV2LnBlbmRpbmcubnIpIHsKCQkJCQlzdHJ1Y3QgdHJlZSAqdHJlZTsKCQkJCQl0cmVlID0gbG9va3VwX3RyZWUodGhlX2hhc2hfYWxnby0+ZW1wdHlfdHJlZSk7CgkJCQkJYWRkX3BlbmRpbmdfb2JqZWN0KCZyZXYsICZ0cmVlLT5vYmplY3QsICJIRUFEIik7CgkJCQl9CgkJCQlicmVhazsKCQkJfQoJCX0KCX0KCglmb3IgKGkgPSAwOyBpIDwgcmV2LnBlbmRpbmcubnI7IGkrKykgewoJCXN0cnVjdCBvYmplY3RfYXJyYXlfZW50cnkgKmVudHJ5ID0gJnJldi5wZW5kaW5nLm9iamVjdHNbaV07CgkJc3RydWN0IG9iamVjdCAqb2JqID0gZW50cnktPml0ZW07CgkJY29uc3QgY2hhciAqbmFtZSA9IGVudHJ5LT5uYW1lOwoJCWludCBmbGFncyA9IChvYmotPmZsYWdzICYgVU5JTlRFUkVTVElORyk7CgkJaWYgKCFvYmotPnBhcnNlZCkKCQkJb2JqID0gcGFyc2Vfb2JqZWN0KCZvYmotPm9pZCk7CgkJb2JqID0gZGVyZWZfdGFnKG9iaiwgTlVMTCwgMCk7CgkJaWYgKCFvYmopCgkJCWRpZShfKCJpbnZhbGlkIG9iamVjdCAnJXMnIGdpdmVuLiIpLCBuYW1lKTsKCQlpZiAob2JqLT50eXBlID09IE9CSl9DT01NSVQpCgkJCW9iaiA9ICYoKHN0cnVjdCBjb21taXQgKilvYmopLT50cmVlLT5vYmplY3Q7CgoJCWlmIChvYmotPnR5cGUgPT0gT0JKX1RSRUUpIHsKCQkJb2JqLT5mbGFncyB8PSBmbGFnczsKCQkJYWRkX29iamVjdF9hcnJheShvYmosIG5hbWUsICZlbnQpOwoJCX0gZWxzZSBpZiAob2JqLT50eXBlID09IE9CSl9CTE9CKSB7CgkJCWlmICgyIDw9IGJsb2JzKQoJCQkJZGllKF8oIm1vcmUgdGhhbiB0d28gYmxvYnMgZ2l2ZW46ICclcyciKSwgbmFtZSk7CgkJCWJsb2JbYmxvYnNdID0gZW50cnk7CgkJCWJsb2JzKys7CgoJCX0gZWxzZSB7CgkJCWRpZShfKCJ1bmhhbmRsZWQgb2JqZWN0ICclcycgZ2l2ZW4uIiksIG5hbWUpOwoJCX0KCX0KCWlmIChyZXYucHJ1bmVfZGF0YS5ucikKCQlwYXRocyArPSByZXYucHJ1bmVfZGF0YS5ucjsKCgkvKgoJICogTm93LCBkbyB0aGUgYXJndW1lbnRzIGxvb2sgcmVhc29uYWJsZT8KCSAqLwoJaWYgKCFlbnQubnIpIHsKCQlzd2l0Y2ggKGJsb2JzKSB7CgkJY2FzZSAwOgoJCQlyZXN1bHQgPSBidWlsdGluX2RpZmZfZmlsZXMoJnJldiwgYXJnYywgYXJndik7CgkJCWJyZWFrOwoJCWNhc2UgMToKCQkJaWYgKHBhdGhzICE9IDEpCgkJCQl1c2FnZShidWlsdGluX2RpZmZfdXNhZ2UpOwoJCQlyZXN1bHQgPSBidWlsdGluX2RpZmZfYl9mKCZyZXYsIGFyZ2MsIGFyZ3YsIGJsb2IpOwoJCQlicmVhazsKCQljYXNlIDI6CgkJCWlmIChwYXRocykKCQkJCXVzYWdlKGJ1aWx0aW5fZGlmZl91c2FnZSk7CgkJCXJlc3VsdCA9IGJ1aWx0aW5fZGlmZl9ibG9icygmcmV2LCBhcmdjLCBhcmd2LCBibG9iKTsKCQkJYnJlYWs7CgkJZGVmYXVsdDoKCQkJdXNhZ2UoYnVpbHRpbl9kaWZmX3VzYWdlKTsKCQl9Cgl9CgllbHNlIGlmIChibG9icykKCQl1c2FnZShidWlsdGluX2RpZmZfdXNhZ2UpOwoJZWxzZSBpZiAoZW50Lm5yID09IDEpCgkJcmVzdWx0ID0gYnVpbHRpbl9kaWZmX2luZGV4KCZyZXYsIGFyZ2MsIGFyZ3YpOwoJZWxzZSBpZiAoZW50Lm5yID09IDIpCgkJcmVzdWx0ID0gYnVpbHRpbl9kaWZmX3RyZWUoJnJldiwgYXJnYywgYXJndiwKCQkJCQkgICAmZW50Lm9iamVjdHNbMF0sICZlbnQub2JqZWN0c1sxXSk7CgllbHNlIGlmIChlbnQub2JqZWN0c1swXS5pdGVtLT5mbGFncyAmIFVOSU5URVJFU1RJTkcpIHsKCQkvKgoJCSAqIGRpZmYgQS4uLkIgd2hlcmUgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIG1lcmdlIGJhc2UKCQkgKiBiZXR3ZWVuIEEgYW5kIEIuICBXZSBoYXZlIGVudC5vYmplY3RzWzBdID09CgkJICogbWVyZ2UtYmFzZSwgZW50Lm9iamVjdHNbZW50cy0yXSA9PSBBLCBhbmQKCQkgKiBlbnQub2JqZWN0c1tlbnRzLTFdID09IEIuICBTaG93IGRpZmYgYmV0d2VlbiB0aGUKCQkgKiBiYXNlIGFuZCBCLiAgTm90ZSB0aGF0IHdlIHBpY2sgb25lIG1lcmdlIGJhc2UgYXQKCQkgKiByYW5kb20gaWYgdGhlcmUgYXJlIG1vcmUgdGhhbiBvbmUuCgkJICovCgkJcmVzdWx0ID0gYnVpbHRpbl9kaWZmX3RyZWUoJnJldiwgYXJnYywgYXJndiwKCQkJCQkgICAmZW50Lm9iamVjdHNbMF0sCgkJCQkJICAgJmVudC5vYmplY3RzW2VudC5uci0xXSk7Cgl9IGVsc2UKCQlyZXN1bHQgPSBidWlsdGluX2RpZmZfY29tYmluZWQoJnJldiwgYXJnYywgYXJndiwKCQkJCQkgICAgICAgZW50Lm9iamVjdHMsIGVudC5ucik7CglyZXN1bHQgPSBkaWZmX3Jlc3VsdF9jb2RlKCZyZXYuZGlmZm9wdCwgcmVzdWx0KTsKCWlmICgxIDwgcmV2LmRpZmZvcHQuc2tpcF9zdGF0X3VubWF0Y2gpCgkJcmVmcmVzaF9pbmRleF9xdWlldGx5KCk7CglVTkxFQUsocmV2KTsKCVVOTEVBSyhlbnQpOwoJVU5MRUFLKGJsb2IpOwoJcmV0dXJuIHJlc3VsdDsKfQo=",
    "text": "/*\n * Builtin \"git diff\"\n *\n * Copyright (c) 2006 Junio C Hamano\n */\n#include \"cache.h\"\n#include \"config.h\"\n#include \"lockfile.h\"\n#include \"color.h\"\n#include \"commit.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"diff.h\"\n#include \"diffcore.h\"\n#include \"revision.h\"\n#include \"log-tree.h\"\n#include \"builtin.h\"\n#include \"submodule.h\"\n#include \"sha1-array.h\"\n\n#define DIFF_NO_INDEX_EXPLICIT 1\n#define DIFF_NO_INDEX_IMPLICIT 2\n\nstatic const char builtin_diff_usage[] =\n\"git diff [<options>] [<commit> [<commit>]] [--] [<path>...]\";\n\nstatic const char *blob_path(struct object_array_entry *entry)\n{\n\treturn entry->path ? entry->path : entry->name;\n}\n\nstatic void stuff_change(struct diff_options *opt,\n\t\t\t unsigned old_mode, unsigned new_mode,\n\t\t\t const struct object_id *old_oid,\n\t\t\t const struct object_id *new_oid,\n\t\t\t int old_oid_valid,\n\t\t\t int new_oid_valid,\n\t\t\t const char *old_path,\n\t\t\t const char *new_path)\n{\n\tstruct diff_filespec *one, *two;\n\n\tif (!is_null_oid(old_oid) && !is_null_oid(new_oid) &&\n\t    !oidcmp(old_oid, new_oid) && (old_mode == new_mode))\n\t\treturn;\n\n\tif (opt->flags.reverse_diff) {\n\t\tSWAP(old_mode, new_mode);\n\t\tSWAP(old_oid, new_oid);\n\t\tSWAP(old_path, new_path);\n\t}\n\n\tif (opt->prefix &&\n\t    (strncmp(old_path, opt->prefix, opt->prefix_length) ||\n\t     strncmp(new_path, opt->prefix, opt->prefix_length)))\n\t\treturn;\n\n\tone = alloc_filespec(old_path);\n\ttwo = alloc_filespec(new_path);\n\tfill_filespec(one, old_oid, old_oid_valid, old_mode);\n\tfill_filespec(two, new_oid, new_oid_valid, new_mode);\n\n\tdiff_queue(&diff_queued_diff, one, two);\n}\n\nstatic int builtin_diff_b_f(struct rev_info *revs,\n\t\t\t    int argc, const char **argv,\n\t\t\t    struct object_array_entry **blob)\n{\n\t/* Blob vs file in the working tree*/\n\tstruct stat st;\n\tconst char *path;\n\n\tif (argc > 1)\n\t\tusage(builtin_diff_usage);\n\n\tGUARD_PATHSPEC(&revs->prune_data, PATHSPEC_FROMTOP | PATHSPEC_LITERAL);\n\tpath = revs->prune_data.items[0].match;\n\n\tif (lstat(path, &st))\n\t\tdie_errno(_(\"failed to stat '%s'\"), path);\n\tif (!(S_ISREG(st.st_mode) || S_ISLNK(st.st_mode)))\n\t\tdie(_(\"'%s': not a regular file or symlink\"), path);\n\n\tdiff_set_mnemonic_prefix(&revs->diffopt, \"o/\", \"w/\");\n\n\tif (blob[0]->mode == S_IFINVALID)\n\t\tblob[0]->mode = canon_mode(st.st_mode);\n\n\tstuff_change(&revs->diffopt,\n\t\t     blob[0]->mode, canon_mode(st.st_mode),\n\t\t     &blob[0]->item->oid, &null_oid,\n\t\t     1, 0,\n\t\t     blob[0]->path ? blob[0]->path : path,\n\t\t     path);\n\tdiffcore_std(&revs->diffopt);\n\tdiff_flush(&revs->diffopt);\n\treturn 0;\n}\n\nstatic int builtin_diff_blobs(struct rev_info *revs,\n\t\t\t      int argc, const char **argv,\n\t\t\t      struct object_array_entry **blob)\n{\n\tunsigned mode = canon_mode(S_IFREG | 0644);\n\n\tif (argc > 1)\n\t\tusage(builtin_diff_usage);\n\n\tif (blob[0]->mode == S_IFINVALID)\n\t\tblob[0]->mode = mode;\n\n\tif (blob[1]->mode == S_IFINVALID)\n\t\tblob[1]->mode = mode;\n\n\tstuff_change(&revs->diffopt,\n\t\t     blob[0]->mode, blob[1]->mode,\n\t\t     &blob[0]->item->oid, &blob[1]->item->oid,\n\t\t     1, 1,\n\t\t     blob_path(blob[0]), blob_path(blob[1]));\n\tdiffcore_std(&revs->diffopt);\n\tdiff_flush(&revs->diffopt);\n\treturn 0;\n}\n\nstatic int builtin_diff_index(struct rev_info *revs,\n\t\t\t      int argc, const char **argv)\n{\n\tint cached = 0;\n\twhile (1 < argc) {\n\t\tconst char *arg = argv[1];\n\t\tif (!strcmp(arg, \"--cached\") || !strcmp(arg, \"--staged\"))\n\t\t\tcached = 1;\n\t\telse\n\t\t\tusage(builtin_diff_usage);\n\t\targv++; argc--;\n\t}\n\t/*\n\t * Make sure there is one revision (i.e. pending object),\n\t * and there is no revision filtering parameters.\n\t */\n\tif (revs->pending.nr != 1 ||\n\t    revs->max_count != -1 || revs->min_age != -1 ||\n\t    revs->max_age != -1)\n\t\tusage(builtin_diff_usage);\n\tif (!cached) {\n\t\tsetup_work_tree();\n\t\tif (read_cache_preload(&revs->diffopt.pathspec) < 0) {\n\t\t\tperror(\"read_cache_preload\");\n\t\t\treturn -1;\n\t\t}\n\t} else if (read_cache() < 0) {\n\t\tperror(\"read_cache\");\n\t\treturn -1;\n\t}\n\treturn run_diff_index(revs, cached);\n}\n\nstatic int builtin_diff_tree(struct rev_info *revs,\n\t\t\t     int argc, const char **argv,\n\t\t\t     struct object_array_entry *ent0,\n\t\t\t     struct object_array_entry *ent1)\n{\n\tconst struct object_id *(oid[2]);\n\tint swap = 0;\n\n\tif (argc > 1)\n\t\tusage(builtin_diff_usage);\n\n\t/*\n\t * We saw two trees, ent0 and ent1.  If ent1 is uninteresting,\n\t * swap them.\n\t */\n\tif (ent1->item->flags & UNINTERESTING)\n\t\tswap = 1;\n\toid[swap] = &ent0->item->oid;\n\toid[1 - swap] = &ent1->item->oid;\n\tdiff_tree_oid(oid[0], oid[1], \"\", &revs->diffopt);\n\tlog_tree_diff_flush(revs);\n\treturn 0;\n}\n\nstatic int builtin_diff_combined(struct rev_info *revs,\n\t\t\t\t int argc, const char **argv,\n\t\t\t\t struct object_array_entry *ent,\n\t\t\t\t int ents)\n{\n\tstruct oid_array parents = OID_ARRAY_INIT;\n\tint i;\n\n\tif (argc > 1)\n\t\tusage(builtin_diff_usage);\n\n\tif (!revs->dense_combined_merges && !revs->combine_merges)\n\t\trevs->dense_combined_merges = revs->combine_merges = 1;\n\tfor (i = 1; i < ents; i++)\n\t\toid_array_append(&parents, &ent[i].item->oid);\n\tdiff_tree_combined(&ent[0].item->oid, &parents,\n\t\t\t   revs->dense_combined_merges, revs);\n\toid_array_clear(&parents);\n\treturn 0;\n}\n\nstatic void refresh_index_quietly(void)\n{\n\tstruct lock_file lock_file = LOCK_INIT;\n\tint fd;\n\n\tfd = hold_locked_index(&lock_file, 0);\n\tif (fd < 0)\n\t\treturn;\n\tdiscard_cache();\n\tread_cache();\n\trefresh_cache(REFRESH_QUIET|REFRESH_UNMERGED);\n\tupdate_index_if_able(&the_index, &lock_file);\n}\n\nstatic int builtin_diff_files(struct rev_info *revs, int argc, const char **argv)\n{\n\tunsigned int options = 0;\n\n\twhile (1 < argc && argv[1][0] == '-') {\n\t\tif (!strcmp(argv[1], \"--base\"))\n\t\t\trevs->max_count = 1;\n\t\telse if (!strcmp(argv[1], \"--ours\"))\n\t\t\trevs->max_count = 2;\n\t\telse if (!strcmp(argv[1], \"--theirs\"))\n\t\t\trevs->max_count = 3;\n\t\telse if (!strcmp(argv[1], \"-q\"))\n\t\t\toptions |= DIFF_SILENT_ON_REMOVED;\n\t\telse if (!strcmp(argv[1], \"-h\"))\n\t\t\tusage(builtin_diff_usage);\n\t\telse\n\t\t\treturn error(_(\"invalid option: %s\"), argv[1]);\n\t\targv++; argc--;\n\t}\n\n\t/*\n\t * \"diff --base\" should not combine merges because it was not\n\t * asked to.  \"diff -c\" should not densify (if the user wants\n\t * dense one, --cc can be explicitly asked for, or just rely\n\t * on the default).\n\t */\n\tif (revs->max_count == -1 && !revs->combine_merges &&\n\t    (revs->diffopt.output_format & DIFF_FORMAT_PATCH))\n\t\trevs->combine_merges = revs->dense_combined_merges = 1;\n\n\tsetup_work_tree();\n\tif (read_cache_preload(&revs->diffopt.pathspec) < 0) {\n\t\tperror(\"read_cache_preload\");\n\t\treturn -1;\n\t}\n\treturn run_diff_files(revs, options);\n}\n\nint cmd_diff(int argc, const char **argv, const char *prefix)\n{\n\tint i;\n\tstruct rev_info rev;\n\tstruct object_array ent = OBJECT_ARRAY_INIT;\n\tint blobs = 0, paths = 0;\n\tstruct object_array_entry *blob[2];\n\tint nongit = 0, no_index = 0;\n\tint result = 0;\n\n\t/*\n\t * We could get N tree-ish in the rev.pending_objects list.\n\t * Also there could be M blobs there, and P pathspecs.\n\t *\n\t * N=0, M=0:\n\t *\tcache vs files (diff-files)\n\t * N=0, M=2:\n\t *      compare two random blobs.  P must be zero.\n\t * N=0, M=1, P=1:\n\t *\tcompare a blob with a working tree file.\n\t *\n\t * N=1, M=0:\n\t *      tree vs cache (diff-index --cached)\n\t *\n\t * N=2, M=0:\n\t *      tree vs tree (diff-tree)\n\t *\n\t * N=0, M=0, P=2:\n\t *      compare two filesystem entities (aka --no-index).\n\t *\n\t * Other cases are errors.\n\t */\n\n\t/* Were we asked to do --no-index explicitly? */\n\tfor (i = 1; i < argc; i++) {\n\t\tif (!strcmp(argv[i], \"--\")) {\n\t\t\ti++;\n\t\t\tbreak;\n\t\t}\n\t\tif (!strcmp(argv[i], \"--no-index\"))\n\t\t\tno_index = DIFF_NO_INDEX_EXPLICIT;\n\t\tif (argv[i][0] != '-')\n\t\t\tbreak;\n\t}\n\n\tprefix = setup_git_directory_gently(&nongit);\n\n\tif (!no_index) {\n\t\t/*\n\t\t * Treat git diff with at least one path outside of the\n\t\t * repo the same as if the command would have been executed\n\t\t * outside of a git repository.  In this case it behaves\n\t\t * the same way as \"git diff --no-index <a> <b>\", which acts\n\t\t * as a colourful \"diff\" replacement.\n\t\t */\n\t\tif (nongit || ((argc == i + 2) &&\n\t\t\t       (!path_inside_repo(prefix, argv[i]) ||\n\t\t\t\t!path_inside_repo(prefix, argv[i + 1]))))\n\t\t\tno_index = DIFF_NO_INDEX_IMPLICIT;\n\t}\n\n\tinit_diff_ui_defaults();\n\tgit_config(git_diff_ui_config, NULL);\n\tprecompose_argv(argc, argv);\n\n\tinit_revisions(&rev, prefix);\n\n\tif (no_index && argc != i + 2) {\n\t\tif (no_index == DIFF_NO_INDEX_IMPLICIT) {\n\t\t\t/*\n\t\t\t * There was no --no-index and there were not two\n\t\t\t * paths. It is possible that the user intended\n\t\t\t * to do an inside-repository operation.\n\t\t\t */\n\t\t\tfprintf(stderr, \"Not a git repository\\n\");\n\t\t\tfprintf(stderr,\n\t\t\t\t\"To compare two paths outside a working tree:\\n\");\n\t\t}\n\t\t/* Give the usage message for non-repository usage and exit. */\n\t\tusagef(\"git diff %s <path> <path>\",\n\t\t       no_index == DIFF_NO_INDEX_EXPLICIT ?\n\t\t       \"--no-index\" : \"[--no-index]\");\n\n\t}\n\tif (no_index)\n\t\t/* If this is a no-index diff, just run it and exit there. */\n\t\tdiff_no_index(&rev, argc, argv);\n\n\t/* Otherwise, we are doing the usual \"git\" diff */\n\trev.diffopt.skip_stat_unmatch = !!diff_auto_refresh_index;\n\n\t/* Scale to real terminal size and respect statGraphWidth config */\n\trev.diffopt.stat_width = -1;\n\trev.diffopt.stat_graph_width = -1;\n\n\t/* Default to let external and textconv be used */\n\trev.diffopt.flags.allow_external = 1;\n\trev.diffopt.flags.allow_textconv = 1;\n\n\t/*\n\t * Default to intent-to-add entries invisible in the\n\t * index. This makes them show up as new files in diff-files\n\t * and not at all in diff-cached.\n\t */\n\trev.diffopt.ita_invisible_in_index = 1;\n\n\tif (nongit)\n\t\tdie(_(\"Not a git repository\"));\n\targc = setup_revisions(argc, argv, &rev, NULL);\n\tif (!rev.diffopt.output_format) {\n\t\trev.diffopt.output_format = DIFF_FORMAT_PATCH;\n\t\tdiff_setup_done(&rev.diffopt);\n\t}\n\n\trev.diffopt.flags.recursive = 1;\n\n\tsetup_diff_pager(&rev.diffopt);\n\n\t/*\n\t * Do we have --cached and not have a pending object, then\n\t * default to HEAD by hand.  Eek.\n\t */\n\tif (!rev.pending.nr) {\n\t\tint i;\n\t\tfor (i = 1; i < argc; i++) {\n\t\t\tconst char *arg = argv[i];\n\t\t\tif (!strcmp(arg, \"--\"))\n\t\t\t\tbreak;\n\t\t\telse if (!strcmp(arg, \"--cached\") ||\n\t\t\t\t !strcmp(arg, \"--staged\")) {\n\t\t\t\tadd_head_to_pending(&rev);\n\t\t\t\tif (!rev.pending.nr) {\n\t\t\t\t\tstruct tree *tree;\n\t\t\t\t\ttree = lookup_tree(the_hash_algo->empty_tree);\n\t\t\t\t\tadd_pending_object(&rev, &tree->object, \"HEAD\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < rev.pending.nr; i++) {\n\t\tstruct object_array_entry *entry = &rev.pending.objects[i];\n\t\tstruct object *obj = entry->item;\n\t\tconst char *name = entry->name;\n\t\tint flags = (obj->flags & UNINTERESTING);\n\t\tif (!obj->parsed)\n\t\t\tobj = parse_object(&obj->oid);\n\t\tobj = deref_tag(obj, NULL, 0);\n\t\tif (!obj)\n\t\t\tdie(_(\"invalid object '%s' given.\"), name);\n\t\tif (obj->type == OBJ_COMMIT)\n\t\t\tobj = &((struct commit *)obj)->tree->object;\n\n\t\tif (obj->type == OBJ_TREE) {\n\t\t\tobj->flags |= flags;\n\t\t\tadd_object_array(obj, name, &ent);\n\t\t} else if (obj->type == OBJ_BLOB) {\n\t\t\tif (2 <= blobs)\n\t\t\t\tdie(_(\"more than two blobs given: '%s'\"), name);\n\t\t\tblob[blobs] = entry;\n\t\t\tblobs++;\n\n\t\t} else {\n\t\t\tdie(_(\"unhandled object '%s' given.\"), name);\n\t\t}\n\t}\n\tif (rev.prune_data.nr)\n\t\tpaths += rev.prune_data.nr;\n\n\t/*\n\t * Now, do the arguments look reasonable?\n\t */\n\tif (!ent.nr) {\n\t\tswitch (blobs) {\n\t\tcase 0:\n\t\t\tresult = builtin_diff_files(&rev, argc, argv);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (paths != 1)\n\t\t\t\tusage(builtin_diff_usage);\n\t\t\tresult = builtin_diff_b_f(&rev, argc, argv, blob);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (paths)\n\t\t\t\tusage(builtin_diff_usage);\n\t\t\tresult = builtin_diff_blobs(&rev, argc, argv, blob);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage(builtin_diff_usage);\n\t\t}\n\t}\n\telse if (blobs)\n\t\tusage(builtin_diff_usage);\n\telse if (ent.nr == 1)\n\t\tresult = builtin_diff_index(&rev, argc, argv);\n\telse if (ent.nr == 2)\n\t\tresult = builtin_diff_tree(&rev, argc, argv,\n\t\t\t\t\t   &ent.objects[0], &ent.objects[1]);\n\telse if (ent.objects[0].item->flags & UNINTERESTING) {\n\t\t/*\n\t\t * diff A...B where there is at least one merge base\n\t\t * between A and B.  We have ent.objects[0] ==\n\t\t * merge-base, ent.objects[ents-2] == A, and\n\t\t * ent.objects[ents-1] == B.  Show diff between the\n\t\t * base and B.  Note that we pick one merge base at\n\t\t * random if there are more than one.\n\t\t */\n\t\tresult = builtin_diff_tree(&rev, argc, argv,\n\t\t\t\t\t   &ent.objects[0],\n\t\t\t\t\t   &ent.objects[ent.nr-1]);\n\t} else\n\t\tresult = builtin_diff_combined(&rev, argc, argv,\n\t\t\t\t\t       ent.objects, ent.nr);\n\tresult = diff_result_code(&rev.diffopt, result);\n\tif (1 < rev.diffopt.skip_stat_unmatch)\n\t\trefresh_index_quietly();\n\tUNLEAK(rev);\n\tUNLEAK(ent);\n\tUNLEAK(blob);\n\treturn result;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00424c296d19e3812115659cdc3dc82a68359e85",
  "sha1_ok": true,
  "size": 12434
}
