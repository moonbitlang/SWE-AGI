{
  "content": {
    "base64": "IyEvdXNyL2Jpbi9wZXJsIC13CiMKIyBDb3B5cmlnaHQgMjAwMiwyMDA1IEdyZWcgS3JvYWgtSGFydG1hbiA8Z3JlZ0Brcm9haC5jb20+CiMgQ29weXJpZ2h0IDIwMDUgUnlhbiBBbmRlcnNvbiA8cnlhbkBtaWNob25saW5lLmNvbT4KIwojIEdQTCB2MiAoU2VlIENPUFlJTkcpCiMKIyBQb3J0ZWQgdG8gc3VwcG9ydCBnaXQgIm1ib3giIGZvcm1hdCBmaWxlcyBieSBSeWFuIEFuZGVyc29uIDxyeWFuQG1pY2hvbmxpbmUuY29tPgojCiMgU2VuZHMgYSBjb2xsZWN0aW9uIG9mIGVtYWlscyB0byB0aGUgZ2l2ZW4gZW1haWwgYWRkcmVzc2VzLCBkaXN0dXJiaW5nbHkgZmFzdC4KIwojIFN1cHBvcnRzIHR3byBmb3JtYXRzOgojIDEuIG1ib3ggZm9ybWF0IGZpbGVzIChpZ25vcmluZyBtb3N0IGhlYWRlcnMgYW5kIE1JTUUgZm9ybWF0dGluZyAtIHRoaXMgaXMgZGVzaWduZWQgZm9yIHNlbmRpbmcgcGF0Y2hlcykKIyAyLiBUaGUgb3JpZ2luYWwgZm9ybWF0IHN1cHBvcnQgYnkgR3JlZydzIHNjcmlwdDoKIyAgICBmaXJzdCBsaW5lIG9mIHRoZSBtZXNzYWdlIGlzIHdobyB0byBDQywKIyAgICBhbmQgc2Vjb25kIGxpbmUgaXMgdGhlIHN1YmplY3Qgb2YgdGhlIG1lc3NhZ2UuCiMKCnVzZSBzdHJpY3Q7CnVzZSB3YXJuaW5nczsKdXNlIFRlcm06OlJlYWRMaW5lOwp1c2UgR2V0b3B0OjpMb25nOwp1c2UgVGV4dDo6UGFyc2VXb3JkczsKdXNlIERhdGE6OkR1bXBlcjsKdXNlIFRlcm06OkFOU0lDb2xvcjsKdXNlIEZpbGU6OlRlbXAgcXcvIHRlbXBkaXIgdGVtcGZpbGUgLzsKdXNlIEVycm9yIHF3KDp0cnkpOwp1c2UgR2l0OwoKR2V0b3B0OjpMb25nOjpDb25maWd1cmUgcXcvIHBhc3NfdGhyb3VnaCAvOwoKcGFja2FnZSBGYWtlVGVybTsKc3ViIG5ldyB7CglteSAoJGNsYXNzLCAkcmVhc29uKSA9IEBfOwoJcmV0dXJuIGJsZXNzIFwkcmVhc29uLCBzaGlmdDsKfQpzdWIgcmVhZGxpbmUgewoJbXkgJHNlbGYgPSBzaGlmdDsKCWRpZSAiQ2Fubm90IHVzZSByZWFkbGluZSBvbiBGYWtlVGVybTogJCRzZWxmIjsKfQpwYWNrYWdlIG1haW47CgoKc3ViIHVzYWdlIHsKCXByaW50IDw8RU9UOwpnaXQgc2VuZC1lbWFpbCBbb3B0aW9uc10gPGZpbGUgfCBkaXJlY3RvcnkgfCByZXYtbGlzdCBvcHRpb25zID4KCiAgQ29tcG9zaW5nOgogICAgLS1mcm9tICAgICAgICAgICAgICAgICAgPHN0cj4gICogRW1haWwgRnJvbToKICAgIC0tW25vLV10byAgICAgICAgICAgICAgIDxzdHI+ICAqIEVtYWlsIFRvOgogICAgLS1bbm8tXWNjICAgICAgICAgICAgICAgPHN0cj4gICogRW1haWwgQ2M6CiAgICAtLVtuby1dYmNjICAgICAgICAgICAgICA8c3RyPiAgKiBFbWFpbCBCY2M6CiAgICAtLXN1YmplY3QgICAgICAgICAgICAgICA8c3RyPiAgKiBFbWFpbCAiU3ViamVjdDoiCiAgICAtLWluLXJlcGx5LXRvICAgICAgICAgICA8c3RyPiAgKiBFbWFpbCAiSW4tUmVwbHktVG86IgogICAgLS1hbm5vdGF0ZSAgICAgICAgICAgICAgICAgICAgICogUmV2aWV3IGVhY2ggcGF0Y2ggdGhhdCB3aWxsIGJlIHNlbnQgaW4gYW4gZWRpdG9yLgogICAgLS1jb21wb3NlICAgICAgICAgICAgICAgICAgICAgICogT3BlbiBhbiBlZGl0b3IgZm9yIGludHJvZHVjdGlvbi4KICAgIC0tOGJpdC1lbmNvZGluZyAgICAgICAgIDxzdHI+ICAqIEVuY29kaW5nIHRvIGFzc3VtZSA4Yml0IG1haWxzIGlmIHVuZGVjbGFyZWQKCiAgU2VuZGluZzoKICAgIC0tZW52ZWxvcGUtc2VuZGVyICAgICAgIDxzdHI+ICAqIEVtYWlsIGVudmVsb3BlIHNlbmRlci4KICAgIC0tc210cC1zZXJ2ZXIgICAgICAgPHN0cjppbnQ+ICAqIE91dGdvaW5nIFNNVFAgc2VydmVyIHRvIHVzZS4gVGhlIHBvcnQKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIG9wdGlvbmFsLiBEZWZhdWx0ICdsb2NhbGhvc3QnLgogICAgLS1zbXRwLXNlcnZlci1wb3J0ICAgICAgPGludD4gICogT3V0Z29pbmcgU01UUCBzZXJ2ZXIgcG9ydC4KICAgIC0tc210cC11c2VyICAgICAgICAgICAgIDxzdHI+ICAqIFVzZXJuYW1lIGZvciBTTVRQLUFVVEguCiAgICAtLXNtdHAtcGFzcyAgICAgICAgICAgICA8c3RyPiAgKiBQYXNzd29yZCBmb3IgU01UUC1BVVRIOyBub3QgbmVjZXNzYXJ5LgogICAgLS1zbXRwLWVuY3J5cHRpb24gICAgICAgPHN0cj4gICogdGxzIG9yIHNzbDsgYW55dGhpbmcgZWxzZSBkaXNhYmxlcy4KICAgIC0tc210cC1zc2wgICAgICAgICAgICAgICAgICAgICAqIERlcHJlY2F0ZWQuIFVzZSAnLS1zbXRwLWVuY3J5cHRpb24gc3NsJy4KICAgIC0tc210cC1kb21haW4gICAgICAgICAgIDxzdHI+ICAqIFRoZSBkb21haW4gbmFtZSBzZW50IHRvIEhFTE8vRUhMTyBoYW5kc2hha2UKICAgIC0tc210cC1kZWJ1ZyAgICAgICAgICAgIDwwfDE+ICAqIERpc2FibGUsIGVuYWJsZSBOZXQ6OlNNVFAgZGVidWcuCgogIEF1dG9tYXRpbmc6CiAgICAtLWlkZW50aXR5ICAgICAgICAgICAgICA8c3RyPiAgKiBVc2UgdGhlIHNlbmRlbWFpbC48aWQ+IG9wdGlvbnMuCiAgICAtLWNjLWNtZCAgICAgICAgICAgICAgICA8c3RyPiAgKiBFbWFpbCBDYzogdmlhIGA8c3RyPiBcJHBhdGNoX3BhdGhgCiAgICAtLXN1cHByZXNzLWNjICAgICAgICAgICA8c3RyPiAgKiBhdXRob3IsIHNlbGYsIHNvYiwgY2MsIGNjY21kLCBib2R5LCBib2R5Y2MsIGFsbC4KICAgIC0tW25vLV1zaWduZWQtb2ZmLWJ5LWNjICAgICAgICAqIFNlbmQgdG8gU2lnbmVkLW9mZi1ieTogYWRkcmVzc2VzLiBEZWZhdWx0IG9uLgogICAgLS1bbm8tXXN1cHByZXNzLWZyb20gICAgICAgICAgICogU2VuZCB0byBzZWxmLiBEZWZhdWx0IG9mZi4KICAgIC0tW25vLV1jaGFpbi1yZXBseS10byAgICAgICAgICAqIENoYWluIEluLVJlcGx5LVRvOiBmaWVsZHMuIERlZmF1bHQgb2ZmLgogICAgLS1bbm8tXXRocmVhZCAgICAgICAgICAgICAgICAgICogVXNlIEluLVJlcGx5LVRvOiBmaWVsZC4gRGVmYXVsdCBvbi4KCiAgQWRtaW5pc3RlcmluZzoKICAgIC0tY29uZmlybSAgICAgICAgICAgICAgIDxzdHI+ICAqIENvbmZpcm0gcmVjaXBpZW50cyBiZWZvcmUgc2VuZGluZzsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dG8sIGNjLCBjb21wb3NlLCBhbHdheXMsIG9yIG5ldmVyLgogICAgLS1xdWlldCAgICAgICAgICAgICAgICAgICAgICAgICogT3V0cHV0IG9uZSBsaW5lIG9mIGluZm8gcGVyIGVtYWlsLgogICAgLS1kcnktcnVuICAgICAgICAgICAgICAgICAgICAgICogRG9uJ3QgYWN0dWFsbHkgc2VuZCB0aGUgZW1haWxzLgogICAgLS1bbm8tXXZhbGlkYXRlICAgICAgICAgICAgICAgICogUGVyZm9ybSBwYXRjaCBzYW5pdHkgY2hlY2tzLiBEZWZhdWx0IG9uLgogICAgLS1bbm8tXWZvcm1hdC1wYXRjaCAgICAgICAgICAgICogdW5kZXJzdGFuZCBhbnkgbm9uIG9wdGlvbmFsIGFyZ3VtZW50cyBhcwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGdpdCBmb3JtYXQtcGF0Y2hgIG9uZXMuCgpFT1QKCWV4aXQoMSk7Cn0KCiMgbW9zdCBtYWlsIHNlcnZlcnMgZ2VuZXJhdGUgdGhlIERhdGU6IGhlYWRlciwgYnV0IG5vdCBhbGwuLi4Kc3ViIGZvcm1hdF8yODIyX3RpbWUgewoJbXkgKCR0aW1lKSA9IEBfOwoJbXkgQGxvY2FsdG0gPSBsb2NhbHRpbWUoJHRpbWUpOwoJbXkgQGdtdHRtID0gZ210aW1lKCR0aW1lKTsKCW15ICRsb2NhbG1pbiA9ICRsb2NhbHRtWzFdICsgJGxvY2FsdG1bMl0gKiA2MDsKCW15ICRnbXRtaW4gPSAkZ210dG1bMV0gKyAkZ210dG1bMl0gKiA2MDsKCWlmICgkbG9jYWx0bVswXSAhPSAkZ210dG1bMF0pIHsKCQlkaWUgImxvY2FsIHpvbmUgZGlmZmVycyBmcm9tIEdNVCBieSBhIG5vbi1taW51dGUgaW50ZXJ2YWxcbiI7Cgl9CglpZiAoKCgkZ210dG1bNl0gKyAxKSAlIDcpID09ICRsb2NhbHRtWzZdKSB7CgkJJGxvY2FsbWluICs9IDE0NDA7Cgl9IGVsc2lmICgoKCRnbXR0bVs2XSAtIDEpICUgNykgPT0gJGxvY2FsdG1bNl0pIHsKCQkkbG9jYWxtaW4gLT0gMTQ0MDsKCX0gZWxzaWYgKCRnbXR0bVs2XSAhPSAkbG9jYWx0bVs2XSkgewoJCWRpZSAibG9jYWwgdGltZSBvZmZzZXQgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDI0IGhvdXJzXG4iOwoJfQoJbXkgJG9mZnNldCA9ICRsb2NhbG1pbiAtICRnbXRtaW47CglteSAkb2ZmaG91ciA9ICRvZmZzZXQgLyA2MDsKCW15ICRvZmZtaW4gPSBhYnMoJG9mZnNldCAlIDYwKTsKCWlmIChhYnMoJG9mZmhvdXIpID49IDI0KSB7CgkJZGllICgibG9jYWwgdGltZSBvZmZzZXQgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDI0IGhvdXJzXG4iKTsKCX0KCglyZXR1cm4gc3ByaW50ZigiJXMsICUyZCAlcyAlZCAlMDJkOiUwMmQ6JTAyZCAlcyUwMmQlMDJkIiwKCQkgICAgICAgcXcoU3VuIE1vbiBUdWUgV2VkIFRodSBGcmkgU2F0KVskbG9jYWx0bVs2XV0sCgkJICAgICAgICRsb2NhbHRtWzNdLAoJCSAgICAgICBxdyhKYW4gRmViIE1hciBBcHIgTWF5IEp1bgoJCQkgIEp1bCBBdWcgU2VwIE9jdCBOb3YgRGVjKVskbG9jYWx0bVs0XV0sCgkJICAgICAgICRsb2NhbHRtWzVdKzE5MDAsCgkJICAgICAgICRsb2NhbHRtWzJdLAoJCSAgICAgICAkbG9jYWx0bVsxXSwKCQkgICAgICAgJGxvY2FsdG1bMF0sCgkJICAgICAgICgkb2Zmc2V0ID49IDApID8gJysnIDogJy0nLAoJCSAgICAgICBhYnMoJG9mZmhvdXIpLAoJCSAgICAgICAkb2ZmbWluLAoJCSAgICAgICApOwp9CgpteSAkaGF2ZV9lbWFpbF92YWxpZCA9IGV2YWwgeyByZXF1aXJlIEVtYWlsOjpWYWxpZDsgMSB9OwpteSAkaGF2ZV9tYWlsX2FkZHJlc3MgPSBldmFsIHsgcmVxdWlyZSBNYWlsOjpBZGRyZXNzOyAxIH07Cm15ICRzbXRwOwpteSAkYXV0aDsKCnN1YiB1bmlxdWVfZW1haWxfbGlzdChAKTsKc3ViIGNsZWFudXBfY29tcG9zZV9maWxlcygpOwoKIyBWYXJpYWJsZXMgd2UgZmlsbCBpbiBhdXRvbWF0aWNhbGx5LCBvciB2aWEgcHJvbXB0aW5nOgpteSAoQHRvLCRub190byxAY2MsJG5vX2NjLEBpbml0aWFsX2NjLEBiY2NsaXN0LCRub19iY2MsQHhoLAoJJGluaXRpYWxfcmVwbHlfdG8sJGluaXRpYWxfc3ViamVjdCxAZmlsZXMsCgkkYXV0aG9yLCRzZW5kZXIsJHNtdHBfYXV0aHBhc3MsJGFubm90YXRlLCRjb21wb3NlLCR0aW1lKTsKCm15ICRlbnZlbG9wZV9zZW5kZXI7CgojIEV4YW1wbGUgcmVwbHkgdG86CiMkaW5pdGlhbF9yZXBseV90byA9ICcnOyAjPDIwMDUwMjAzMTczMjA4LkdBMjM5NjRAZm9vYmFyLmNvbT4nOwoKbXkgJHJlcG8gPSBldmFsIHsgR2l0LT5yZXBvc2l0b3J5KCkgfTsKbXkgQHJlcG8gPSAkcmVwbyA/ICgkcmVwbykgOiAoKTsKbXkgJHRlcm0gPSBldmFsIHsKCSRFTlZ7IkdJVF9TRU5EX0VNQUlMX05PVFRZIn0KCQk/IG5ldyBUZXJtOjpSZWFkTGluZSAnZ2l0LXNlbmQtZW1haWwnLCBcKlNURElOLCBcKlNURE9VVAoJCTogbmV3IFRlcm06OlJlYWRMaW5lICdnaXQtc2VuZC1lbWFpbCc7Cn07CmlmICgkQCkgewoJJHRlcm0gPSBuZXcgRmFrZVRlcm0gIiRAOiBnb2luZyBub24taW50ZXJhY3RpdmUiOwp9CgojIEJlaGF2aW9yIG1vZGlmaWNhdGlvbiB2YXJpYWJsZXMKbXkgKCRxdWlldCwgJGRyeV9ydW4pID0gKDAsIDApOwpteSAkZm9ybWF0X3BhdGNoOwpteSAkY29tcG9zZV9maWxlbmFtZTsKCiMgSGFuZGxlIGludGVyYWN0aXZlIGVkaXRpb24gb2YgZmlsZXMuCm15ICRtdWx0aWVkaXQ7Cm15ICRlZGl0b3I7CgpzdWIgZG9fZWRpdCB7CglpZiAoIWRlZmluZWQoJGVkaXRvcikpIHsKCQkkZWRpdG9yID0gR2l0Ojpjb21tYW5kX29uZWxpbmUoJ3ZhcicsICdHSVRfRURJVE9SJyk7Cgl9CglpZiAoZGVmaW5lZCgkbXVsdGllZGl0KSAmJiAhJG11bHRpZWRpdCkgewoJCW1hcCB7CgkJCXN5c3RlbSgnc2gnLCAnLWMnLCAkZWRpdG9yLicgIiRAIicsICRlZGl0b3IsICRfKTsKCQkJaWYgKCgkPyAmIDEyNykgfHwgKCQ/ID4+IDgpKSB7CgkJCQlkaWUoInRoZSBlZGl0b3IgZXhpdGVkIHVuY2xlYW5seSwgYWJvcnRpbmcgZXZlcnl0aGluZyIpOwoJCQl9CgkJfSBAXzsKCX0gZWxzZSB7CgkJc3lzdGVtKCdzaCcsICctYycsICRlZGl0b3IuJyAiJEAiJywgJGVkaXRvciwgQF8pOwoJCWlmICgoJD8gJiAxMjcpIHx8ICgkPyA+PiA4KSkgewoJCQlkaWUoInRoZSBlZGl0b3IgZXhpdGVkIHVuY2xlYW5seSwgYWJvcnRpbmcgZXZlcnl0aGluZyIpOwoJCX0KCX0KfQoKIyBWYXJpYWJsZXMgd2l0aCBjb3JyZXNwb25kaW5nIGNvbmZpZyBzZXR0aW5ncwpteSAoJHRocmVhZCwgJGNoYWluX3JlcGx5X3RvLCAkc3VwcHJlc3NfZnJvbSwgJHNpZ25lZF9vZmZfYnlfY2MsICRjY19jbWQpOwpteSAoJHNtdHBfc2VydmVyLCAkc210cF9zZXJ2ZXJfcG9ydCwgJHNtdHBfYXV0aHVzZXIsICRzbXRwX2VuY3J5cHRpb24pOwpteSAoJGlkZW50aXR5LCAkYWxpYXNmaWxldHlwZSwgQGFsaWFzX2ZpbGVzLCBAc210cF9ob3N0X3BhcnRzLCAkc210cF9kb21haW4pOwpteSAoJHZhbGlkYXRlLCAkY29uZmlybSk7Cm15IChAc3VwcHJlc3NfY2MpOwpteSAoJGF1dG9fOGJpdF9lbmNvZGluZyk7CgpteSAoJGRlYnVnX25ldF9zbXRwKSA9IDA7CQkjIE5ldDo6U01UUCwgc2VlIHNlbmRfbWVzc2FnZSgpCgpteSAkbm90X3NldF9ieV91c2VyID0gInRydWUgYnV0IG5vdCBzZXQgYnkgdGhlIHVzZXIiOwoKbXkgJWNvbmZpZ19ib29sX3NldHRpbmdzID0gKAogICAgInRocmVhZCIgPT4gW1wkdGhyZWFkLCAxXSwKICAgICJjaGFpbnJlcGx5dG8iID0+IFtcJGNoYWluX3JlcGx5X3RvLCAkbm90X3NldF9ieV91c2VyXSwKICAgICJzdXBwcmVzc2Zyb20iID0+IFtcJHN1cHByZXNzX2Zyb20sIHVuZGVmXSwKICAgICJzaWduZWRvZmZieWNjIiA9PiBbXCRzaWduZWRfb2ZmX2J5X2NjLCB1bmRlZl0sCiAgICAic2lnbmVkb2ZmY2MiID0+IFtcJHNpZ25lZF9vZmZfYnlfY2MsIHVuZGVmXSwgICAgICAjIERlcHJlY2F0ZWQKICAgICJ2YWxpZGF0ZSIgPT4gW1wkdmFsaWRhdGUsIDFdLAopOwoKbXkgJWNvbmZpZ19zZXR0aW5ncyA9ICgKICAgICJzbXRwc2VydmVyIiA9PiBcJHNtdHBfc2VydmVyLAogICAgInNtdHBzZXJ2ZXJwb3J0IiA9PiBcJHNtdHBfc2VydmVyX3BvcnQsCiAgICAic210cHVzZXIiID0+IFwkc210cF9hdXRodXNlciwKICAgICJzbXRwcGFzcyIgPT4gXCRzbXRwX2F1dGhwYXNzLAogICAgInNtdHBkb21haW4iID0+IFwkc210cF9kb21haW4sCiAgICAidG8iID0+IFxAdG8sCiAgICAiY2MiID0+IFxAaW5pdGlhbF9jYywKICAgICJjY2NtZCIgPT4gXCRjY19jbWQsCiAgICAiYWxpYXNmaWxldHlwZSIgPT4gXCRhbGlhc2ZpbGV0eXBlLAogICAgImJjYyIgPT4gXEBiY2NsaXN0LAogICAgImFsaWFzZXNmaWxlIiA9PiBcQGFsaWFzX2ZpbGVzLAogICAgInN1cHByZXNzY2MiID0+IFxAc3VwcHJlc3NfY2MsCiAgICAiZW52ZWxvcGVzZW5kZXIiID0+IFwkZW52ZWxvcGVfc2VuZGVyLAogICAgIm11bHRpZWRpdCIgPT4gXCRtdWx0aWVkaXQsCiAgICAiY29uZmlybSIgICA9PiBcJGNvbmZpcm0sCiAgICAiZnJvbSIgPT4gXCRzZW5kZXIsCiAgICAiYXNzdW1lOGJpdGVuY29kaW5nIiA9PiBcJGF1dG9fOGJpdF9lbmNvZGluZywKKTsKCiMgSGVscCB1c2VycyBwcmVwYXJlIGZvciAxLjcuMApzdWIgY2hhaW5fcmVwbHlfdG8gewoJaWYgKGRlZmluZWQgJGNoYWluX3JlcGx5X3RvICYmCgkgICAgJGNoYWluX3JlcGx5X3RvIGVxICRub3Rfc2V0X2J5X3VzZXIpIHsKCQlwcmludCBTVERFUlIKCQkgICAgIkluIGdpdCAxLjcuMCwgdGhlIGRlZmF1bHQgaGFzIGNoYW5nZWQgdG8gLS1uby1jaGFpbi1yZXBseS10b1xuIiAuCgkJICAgICJTZXQgc2VuZGVtYWlsLmNoYWlucmVwbHl0byBjb25maWd1cmF0aW9uIHZhcmlhYmxlIHRvIHRydWUgaWZcbiIgLgoJCSAgICAieW91IHdhbnQgdG8ga2VlcCAtLWNoYWluLXJlcGx5LXRvIGFzIHlvdXIgZGVmYXVsdC5cbiI7CgkJJGNoYWluX3JlcGx5X3RvID0gMDsKCX0KCXJldHVybiAkY2hhaW5fcmVwbHlfdG87Cn0KCiMgSGFuZGxlIFVuY291dGggVGVybWluYXRpb24Kc3ViIHNpZ25hbF9oYW5kbGVyIHsKCgkjIE1ha2UgdGV4dCBub3JtYWwKCXByaW50IGNvbG9yKCJyZXNldCIpLCAiXG4iOwoKCSMgU01UUCBwYXNzd29yZCBtYXNrZWQKCXN5c3RlbSAic3R0eSBlY2hvIjsKCgkjIHRtcCBmaWxlcyBmcm9tIC0tY29tcG9zZQoJaWYgKGRlZmluZWQgJGNvbXBvc2VfZmlsZW5hbWUpIHsKCQlpZiAoLWUgJGNvbXBvc2VfZmlsZW5hbWUpIHsKCQkJcHJpbnQgIickY29tcG9zZV9maWxlbmFtZScgY29udGFpbnMgYW4gaW50ZXJtZWRpYXRlIHZlcnNpb24gb2YgdGhlIGVtYWlsIHlvdSB3ZXJlIGNvbXBvc2luZy5cbiI7CgkJfQoJCWlmICgtZSAoJGNvbXBvc2VfZmlsZW5hbWUgLiAiLmZpbmFsIikpIHsKCQkJcHJpbnQgIickY29tcG9zZV9maWxlbmFtZS5maW5hbCcgY29udGFpbnMgdGhlIGNvbXBvc2VkIGVtYWlsLlxuIgoJCX0KCX0KCglleGl0Owp9OwoKJFNJR3tURVJNfSA9IFwmc2lnbmFsX2hhbmRsZXI7CiRTSUd7SU5UfSAgPSBcJnNpZ25hbF9oYW5kbGVyOwoKIyBCZWdpbiBieSBhY2N1bXVsYXRpbmcgYWxsIHRoZSB2YXJpYWJsZXMgKGRlZmluZWQgYWJvdmUpLCB0aGF0IHdlIHdpbGwgZW5kIHVwCiMgbmVlZGluZywgZmlyc3QsIGZyb20gdGhlIGNvbW1hbmQgbGluZToKCm15ICRyYyA9IEdldE9wdGlvbnMoInNlbmRlcnxmcm9tPXMiID0+IFwkc2VuZGVyLAogICAgICAgICAgICAgICAgICAgICJpbi1yZXBseS10bz1zIiA9PiBcJGluaXRpYWxfcmVwbHlfdG8sCgkJICAgICJzdWJqZWN0PXMiID0+IFwkaW5pdGlhbF9zdWJqZWN0LAoJCSAgICAidG89cyIgPT4gXEB0bywKCQkgICAgIm5vLXRvIiA9PiBcJG5vX3RvLAoJCSAgICAiY2M9cyIgPT4gXEBpbml0aWFsX2NjLAoJCSAgICAibm8tY2MiID0+IFwkbm9fY2MsCgkJICAgICJiY2M9cyIgPT4gXEBiY2NsaXN0LAoJCSAgICAibm8tYmNjIiA9PiBcJG5vX2JjYywKCQkgICAgImNoYWluLXJlcGx5LXRvISIgPT4gXCRjaGFpbl9yZXBseV90bywKCQkgICAgInNtdHAtc2VydmVyPXMiID0+IFwkc210cF9zZXJ2ZXIsCgkJICAgICJzbXRwLXNlcnZlci1wb3J0PXMiID0+IFwkc210cF9zZXJ2ZXJfcG9ydCwKCQkgICAgInNtdHAtdXNlcj1zIiA9PiBcJHNtdHBfYXV0aHVzZXIsCgkJICAgICJzbXRwLXBhc3M6cyIgPT4gXCRzbXRwX2F1dGhwYXNzLAoJCSAgICAic210cC1zc2wiID0+IHN1YiB7ICRzbXRwX2VuY3J5cHRpb24gPSAnc3NsJyB9LAoJCSAgICAic210cC1lbmNyeXB0aW9uPXMiID0+IFwkc210cF9lbmNyeXB0aW9uLAoJCSAgICAic210cC1kZWJ1ZzppIiA9PiBcJGRlYnVnX25ldF9zbXRwLAoJCSAgICAic210cC1kb21haW46cyIgPT4gXCRzbXRwX2RvbWFpbiwKCQkgICAgImlkZW50aXR5PXMiID0+IFwkaWRlbnRpdHksCgkJICAgICJhbm5vdGF0ZSIgPT4gXCRhbm5vdGF0ZSwKCQkgICAgImNvbXBvc2UiID0+IFwkY29tcG9zZSwKCQkgICAgInF1aWV0IiA9PiBcJHF1aWV0LAoJCSAgICAiY2MtY21kPXMiID0+IFwkY2NfY21kLAoJCSAgICAic3VwcHJlc3MtZnJvbSEiID0+IFwkc3VwcHJlc3NfZnJvbSwKCQkgICAgInN1cHByZXNzLWNjPXMiID0+IFxAc3VwcHJlc3NfY2MsCgkJICAgICJzaWduZWQtb2ZmLWNjfHNpZ25lZC1vZmYtYnktY2MhIiA9PiBcJHNpZ25lZF9vZmZfYnlfY2MsCgkJICAgICJjb25maXJtPXMiID0+IFwkY29uZmlybSwKCQkgICAgImRyeS1ydW4iID0+IFwkZHJ5X3J1biwKCQkgICAgImVudmVsb3BlLXNlbmRlcj1zIiA9PiBcJGVudmVsb3BlX3NlbmRlciwKCQkgICAgInRocmVhZCEiID0+IFwkdGhyZWFkLAoJCSAgICAidmFsaWRhdGUhIiA9PiBcJHZhbGlkYXRlLAoJCSAgICAiZm9ybWF0LXBhdGNoISIgPT4gXCRmb3JtYXRfcGF0Y2gsCgkJICAgICI4Yml0LWVuY29kaW5nPXMiID0+IFwkYXV0b184Yml0X2VuY29kaW5nLAoJICk7Cgp1bmxlc3MgKCRyYykgewogICAgdXNhZ2UoKTsKfQoKZGllICJDYW5ub3QgcnVuIGdpdCBmb3JtYXQtcGF0Y2ggZnJvbSBvdXRzaWRlIGEgcmVwb3NpdG9yeVxuIgoJaWYgJGZvcm1hdF9wYXRjaCBhbmQgbm90ICRyZXBvOwoKIyBOb3csIGxldCdzIGZpbGwgYW55IHRoYXQgYXJlbid0IHNldCBpbiB3aXRoIGRlZmF1bHRzOgoKc3ViIHJlYWRfY29uZmlnIHsKCW15ICgkcHJlZml4KSA9IEBfOwoKCWZvcmVhY2ggbXkgJHNldHRpbmcgKGtleXMgJWNvbmZpZ19ib29sX3NldHRpbmdzKSB7CgkJbXkgJHRhcmdldCA9ICRjb25maWdfYm9vbF9zZXR0aW5nc3skc2V0dGluZ30tPlswXTsKCQkkJHRhcmdldCA9IEdpdDo6Y29uZmlnX2Jvb2woQHJlcG8sICIkcHJlZml4LiRzZXR0aW5nIikgdW5sZXNzIChkZWZpbmVkICQkdGFyZ2V0KTsKCX0KCglmb3JlYWNoIG15ICRzZXR0aW5nIChrZXlzICVjb25maWdfc2V0dGluZ3MpIHsKCQlteSAkdGFyZ2V0ID0gJGNvbmZpZ19zZXR0aW5nc3skc2V0dGluZ307CgkJbmV4dCBpZiAkc2V0dGluZyBlcSAidG8iIGFuZCBkZWZpbmVkICRub190bzsKCQluZXh0IGlmICRzZXR0aW5nIGVxICJjYyIgYW5kIGRlZmluZWQgJG5vX2NjOwoJCW5leHQgaWYgJHNldHRpbmcgZXEgImJjYyIgYW5kIGRlZmluZWQgJG5vX2JjYzsKCQlpZiAocmVmKCR0YXJnZXQpIGVxICJBUlJBWSIpIHsKCQkJdW5sZXNzIChAJHRhcmdldCkgewoJCQkJbXkgQHZhbHVlcyA9IEdpdDo6Y29uZmlnKEByZXBvLCAiJHByZWZpeC4kc2V0dGluZyIpOwoJCQkJQCR0YXJnZXQgPSBAdmFsdWVzIGlmIChAdmFsdWVzICYmIGRlZmluZWQgJHZhbHVlc1swXSk7CgkJCX0KCQl9CgkJZWxzZSB7CgkJCSQkdGFyZ2V0ID0gR2l0Ojpjb25maWcoQHJlcG8sICIkcHJlZml4LiRzZXR0aW5nIikgdW5sZXNzIChkZWZpbmVkICQkdGFyZ2V0KTsKCQl9Cgl9CgoJaWYgKCFkZWZpbmVkICRzbXRwX2VuY3J5cHRpb24pIHsKCQlteSAkZW5jID0gR2l0Ojpjb25maWcoQHJlcG8sICIkcHJlZml4LnNtdHBlbmNyeXB0aW9uIik7CgkJaWYgKGRlZmluZWQgJGVuYykgewoJCQkkc210cF9lbmNyeXB0aW9uID0gJGVuYzsKCQl9IGVsc2lmIChHaXQ6OmNvbmZpZ19ib29sKEByZXBvLCAiJHByZWZpeC5zbXRwc3NsIikpIHsKCQkJJHNtdHBfZW5jcnlwdGlvbiA9ICdzc2wnOwoJCX0KCX0KfQoKIyByZWFkIGNvbmZpZ3VyYXRpb24gZnJvbSBbc2VuZGVtYWlsICIkaWRlbnRpdHkiXSwgZmFsbCBiYWNrIG9uIFtzZW5kZW1haWxdCiRpZGVudGl0eSA9IEdpdDo6Y29uZmlnKEByZXBvLCAic2VuZGVtYWlsLmlkZW50aXR5IikgdW5sZXNzIChkZWZpbmVkICRpZGVudGl0eSk7CnJlYWRfY29uZmlnKCJzZW5kZW1haWwuJGlkZW50aXR5IikgaWYgKGRlZmluZWQgJGlkZW50aXR5KTsKcmVhZF9jb25maWcoInNlbmRlbWFpbCIpOwoKIyBmYWxsIGJhY2sgb24gYnVpbHRpbiBib29sIGRlZmF1bHRzCmZvcmVhY2ggbXkgJHNldHRpbmcgKHZhbHVlcyAlY29uZmlnX2Jvb2xfc2V0dGluZ3MpIHsKCSR7JHNldHRpbmctPlswXX0gPSAkc2V0dGluZy0+WzFdIHVubGVzcyAoZGVmaW5lZCAoJHskc2V0dGluZy0+WzBdfSkpOwp9CgojICdkZWZhdWx0JyBlbmNyeXB0aW9uIGlzIG5vbmUgLS0gdGhpcyBvbmx5IHByZXZlbnRzIGEgd2FybmluZwokc210cF9lbmNyeXB0aW9uID0gJycgdW5sZXNzIChkZWZpbmVkICRzbXRwX2VuY3J5cHRpb24pOwoKIyBTZXQgQ0Mgc3VwcHJlc3Npb25zCm15KCVzdXBwcmVzc19jYyk7CmlmIChAc3VwcHJlc3NfY2MpIHsKCWZvcmVhY2ggbXkgJGVudHJ5IChAc3VwcHJlc3NfY2MpIHsKCQlkaWUgIlVua25vd24gLS1zdXBwcmVzcy1jYyBmaWVsZDogJyRlbnRyeSdcbiIKCQkJdW5sZXNzICRlbnRyeSA9fiAvXihhbGx8Y2NjbWR8Y2N8YXV0aG9yfHNlbGZ8c29ifGJvZHl8Ym9keWNjKSQvOwoJCSRzdXBwcmVzc19jY3skZW50cnl9ID0gMTsKCX0KfQoKaWYgKCRzdXBwcmVzc19jY3snYWxsJ30pIHsKCWZvcmVhY2ggbXkgJGVudHJ5IChxdyAoY2NjbWQgY2MgYXV0aG9yIHNlbGYgc29iIGJvZHkgYm9keWNjKSkgewoJCSRzdXBwcmVzc19jY3skZW50cnl9ID0gMTsKCX0KCWRlbGV0ZSAkc3VwcHJlc3NfY2N7J2FsbCd9Owp9CgojIElmIGV4cGxpY2l0IG9sZC1zdHlsZSBvbmVzIGFyZSBzcGVjaWZpZWQsIHRoZXkgdHJ1bXAgLS1zdXBwcmVzcy1jYy4KJHN1cHByZXNzX2NjeydzZWxmJ30gPSAkc3VwcHJlc3NfZnJvbSBpZiBkZWZpbmVkICRzdXBwcmVzc19mcm9tOwokc3VwcHJlc3NfY2N7J3NvYid9ID0gISRzaWduZWRfb2ZmX2J5X2NjIGlmIGRlZmluZWQgJHNpZ25lZF9vZmZfYnlfY2M7CgppZiAoJHN1cHByZXNzX2Njeydib2R5J30pIHsKCWZvcmVhY2ggbXkgJGVudHJ5IChxdyAoc29iIGJvZHljYykpIHsKCQkkc3VwcHJlc3NfY2N7JGVudHJ5fSA9IDE7Cgl9CglkZWxldGUgJHN1cHByZXNzX2Njeydib2R5J307Cn0KCiMgU2V0IGNvbmZpcm0ncyBkZWZhdWx0IHZhbHVlCm15ICRjb25maXJtX3VuY29uZmlndXJlZCA9ICFkZWZpbmVkICRjb25maXJtOwppZiAoJGNvbmZpcm1fdW5jb25maWd1cmVkKSB7CgkkY29uZmlybSA9IHNjYWxhciAlc3VwcHJlc3NfY2MgPyAnY29tcG9zZScgOiAnYXV0byc7Cn07CmRpZSAiVW5rbm93biAtLWNvbmZpcm0gc2V0dGluZzogJyRjb25maXJtJ1xuIgoJdW5sZXNzICRjb25maXJtID1+IC9eKD86YXV0b3xjY3xjb21wb3NlfGFsd2F5c3xuZXZlcikvOwoKIyBEZWJ1Z2dpbmcsIHByaW50IG91dCB0aGUgc3VwcHJlc3Npb25zLgppZiAoMCkgewoJcHJpbnQgInN1cHByZXNzaW9uczpcbiI7Cglmb3JlYWNoIG15ICRlbnRyeSAoa2V5cyAlc3VwcHJlc3NfY2MpIHsKCQlwcmludGYgIiAgJS01cyAtPiAkc3VwcHJlc3NfY2N7JGVudHJ5fVxuIiwgJGVudHJ5OwoJfQp9CgpteSAoJHJlcG9hdXRob3IsICRyZXBvY29tbWl0dGVyKTsKKCRyZXBvYXV0aG9yKSA9IEdpdDo6aWRlbnRfcGVyc29uKEByZXBvLCAnYXV0aG9yJyk7CigkcmVwb2NvbW1pdHRlcikgPSBHaXQ6OmlkZW50X3BlcnNvbihAcmVwbywgJ2NvbW1pdHRlcicpOwoKIyBWZXJpZnkgdGhlIHVzZXIgaW5wdXQKCmZvcmVhY2ggbXkgJGVudHJ5IChAdG8pIHsKCWRpZSAiQ29tbWEgaW4gLS10byBlbnRyeTogJGVudHJ5J1xuIiB1bmxlc3MgJGVudHJ5ICF+IG0vLC87Cn0KCmZvcmVhY2ggbXkgJGVudHJ5IChAaW5pdGlhbF9jYykgewoJZGllICJDb21tYSBpbiAtLWNjIGVudHJ5OiAkZW50cnknXG4iIHVubGVzcyAkZW50cnkgIX4gbS8sLzsKfQoKZm9yZWFjaCBteSAkZW50cnkgKEBiY2NsaXN0KSB7CglkaWUgIkNvbW1hIGluIC0tYmNjbGlzdCBlbnRyeTogJGVudHJ5J1xuIiB1bmxlc3MgJGVudHJ5ICF+IG0vLC87Cn0KCnN1YiBwYXJzZV9hZGRyZXNzX2xpbmUgewoJaWYgKCRoYXZlX21haWxfYWRkcmVzcykgewoJCXJldHVybiBtYXAgeyAkXy0+Zm9ybWF0IH0gTWFpbDo6QWRkcmVzcy0+cGFyc2UoJF9bMF0pOwoJfSBlbHNlIHsKCQlyZXR1cm4gc3BsaXRfYWRkcnMoJF9bMF0pOwoJfQp9CgpzdWIgc3BsaXRfYWRkcnMgewoJcmV0dXJuIHF1b3Rld29yZHMoJ1xzKixccyonLCAxLCBAXyk7Cn0KCm15ICVhbGlhc2VzOwpteSAlcGFyc2VfYWxpYXMgPSAoCgkjIG11bHRpbGluZSBmb3JtYXRzIGNhbiBiZSBzdXBwb3J0ZWQgaW4gdGhlIGZ1dHVyZQoJbXV0dCA9PiBzdWIgeyBteSAkZmggPSBzaGlmdDsgd2hpbGUgKDwkZmg+KSB7CgkJaWYgKC9eXHMqYWxpYXNccysoPzotZ3JvdXBccytcUytccyspKihcUyspXHMrKC4qKSQvKSB7CgkJCW15ICgkYWxpYXMsICRhZGRyKSA9ICgkMSwgJDIpOwoJCQkkYWRkciA9fiBzLyMuKiQvLzsgIyBtdXR0IGFsbG93cyAjIGNvbW1lbnRzCgkJCSAjIGNvbW1hcyBkZWxpbWl0IG11bHRpcGxlIGFkZHJlc3NlcwoJCQkkYWxpYXNlc3skYWxpYXN9ID0gWyBzcGxpdF9hZGRycygkYWRkcikgXTsKCQl9fX0sCgltYWlscmMgPT4gc3ViIHsgbXkgJGZoID0gc2hpZnQ7IHdoaWxlICg8JGZoPikgewoJCWlmICgvXmFsaWFzXHMrKFxTKylccysoLiopJC8pIHsKCQkJIyBzcGFjZXMgZGVsaW1pdCBtdWx0aXBsZSBhZGRyZXNzZXMKCQkJJGFsaWFzZXN7JDF9ID0gWyBxdW90ZXdvcmRzKCdccysnLCAwLCAkMikgXTsKCQl9fX0sCglwaW5lID0+IHN1YiB7IG15ICRmaCA9IHNoaWZ0OyBteSAkZj0nXHRbXlx0XSonOwoJICAgICAgICBmb3IgKG15ICR4ID0gJyc7IGRlZmluZWQoJHgpOyAkeCA9ICRfKSB7CgkJCWNob21wICR4OwoJCSAgICAgICAgJHggLj0gJDEgd2hpbGUoZGVmaW5lZCgkXyA9IDwkZmg+KSAmJiAvXiArKC4qKSQvKTsKCQkJJHggPX4gL14oXFMrKSRmXHRcKD8oW15cdF0rPylcKT8oOj8kZil7MCwyfSQvIG9yIG5leHQ7CgkJCSRhbGlhc2VzeyQxfSA9IFsgc3BsaXRfYWRkcnMoJDIpIF07CgkJfX0sCgllbG0gPT4gc3ViICB7IG15ICRmaCA9IHNoaWZ0OwoJCSAgICAgIHdoaWxlICg8JGZoPikgewoJCQkgIGlmICgvXihcUyspXHMrPVxzK1tePV0rPVxzKFxTKykvKSB7CgkJCSAgICAgIG15ICgkYWxpYXMsICRhZGRyKSA9ICgkMSwgJDIpOwoJCQkgICAgICAgJGFsaWFzZXN7JGFsaWFzfSA9IFsgc3BsaXRfYWRkcnMoJGFkZHIpIF07CgkJCSAgfQoJCSAgICAgIH0gfSwKCglnbnVzID0+IHN1YiB7IG15ICRmaCA9IHNoaWZ0OyB3aGlsZSAoPCRmaD4pIHsKCQlpZiAoL1woZGVmaW5lLW1haWwtYWxpYXNccysiKFxTKz8pIlxzKyIoXFMrPykiXCkvKSB7CgkJCSRhbGlhc2VzeyQxfSA9IFsgJDIgXTsKCQl9fX0KKTsKCmlmIChAYWxpYXNfZmlsZXMgYW5kICRhbGlhc2ZpbGV0eXBlIGFuZCBkZWZpbmVkICRwYXJzZV9hbGlhc3skYWxpYXNmaWxldHlwZX0pIHsKCWZvcmVhY2ggbXkgJGZpbGUgKEBhbGlhc19maWxlcykgewoJCW9wZW4gbXkgJGZoLCAnPCcsICRmaWxlIG9yIGRpZSAib3BlbmluZyAkZmlsZTogJCFcbiI7CgkJJHBhcnNlX2FsaWFzeyRhbGlhc2ZpbGV0eXBlfS0+KCRmaCk7CgkJY2xvc2UgJGZoOwoJfQp9CgooJHNlbmRlcikgPSBleHBhbmRfYWxpYXNlcygkc2VuZGVyKSBpZiBkZWZpbmVkICRzZW5kZXI7CgojIHJldHVybnMgMSBpZiB0aGUgY29uZmxpY3QgbXVzdCBiZSBzb2x2ZWQgdXNpbmcgaXQgYXMgYSBmb3JtYXQtcGF0Y2ggYXJndW1lbnQKc3ViIGNoZWNrX2ZpbGVfcmV2X2NvbmZsaWN0KCQpIHsKCXJldHVybiB1bmxlc3MgJHJlcG87CglteSAkZiA9IHNoaWZ0OwoJdHJ5IHsKCQkkcmVwby0+Y29tbWFuZCgncmV2LXBhcnNlJywgJy0tdmVyaWZ5JywgJy0tcXVpZXQnLCAkZik7CgkJaWYgKGRlZmluZWQoJGZvcm1hdF9wYXRjaCkpIHsKCQkJcmV0dXJuICRmb3JtYXRfcGF0Y2g7CgkJfQoJCWRpZSg8PEVPRik7CkZpbGUgJyRmJyBleGlzdHMgYnV0IGl0IGNvdWxkIGFsc28gYmUgdGhlIHJhbmdlIG9mIGNvbW1pdHMKdG8gcHJvZHVjZSBwYXRjaGVzIGZvci4gIFBsZWFzZSBkaXNhbWJpZ3VhdGUgYnkuLi4KCiAgICAqIFNheWluZyAiLi8kZiIgaWYgeW91IG1lYW4gYSBmaWxlOyBvcgogICAgKiBHaXZpbmcgLS1mb3JtYXQtcGF0Y2ggb3B0aW9uIGlmIHlvdSBtZWFuIGEgcmFuZ2UuCkVPRgoJfSBjYXRjaCBHaXQ6OkVycm9yOjpDb21tYW5kIHdpdGggewoJCXJldHVybiAwOwoJfQp9CgojIE5vdyB0aGF0IGFsbCB0aGUgZGVmYXVsdHMgYXJlIHNldCwgcHJvY2VzcyB0aGUgcmVzdCBvZiB0aGUgY29tbWFuZCBsaW5lCiMgYXJndW1lbnRzIGFuZCBjb2xsZWN0IHVwIHRoZSBmaWxlcyB0aGF0IG5lZWQgdG8gYmUgcHJvY2Vzc2VkLgpteSBAcmV2X2xpc3Rfb3B0czsKd2hpbGUgKGRlZmluZWQobXkgJGYgPSBzaGlmdCBAQVJHVikpIHsKCWlmICgkZiBlcSAiLS0iKSB7CgkJcHVzaCBAcmV2X2xpc3Rfb3B0cywgIi0tIiwgQEFSR1Y7CgkJQEFSR1YgPSAoKTsKCX0gZWxzaWYgKC1kICRmIGFuZCAhY2hlY2tfZmlsZV9yZXZfY29uZmxpY3QoJGYpKSB7CgkJb3BlbmRpcihESCwkZikKCQkJb3IgZGllICJGYWlsZWQgdG8gb3BlbmRpciAkZjogJCEiOwoKCQlwdXNoIEBmaWxlcywgZ3JlcCB7IC1mICRfIH0gbWFwIHsgKyRmIC4gIi8iIC4gJF8gfQoJCQkJc29ydCByZWFkZGlyKERIKTsKCQljbG9zZWRpcihESCk7Cgl9IGVsc2lmICgoLWYgJGYgb3IgLXAgJGYpIGFuZCAhY2hlY2tfZmlsZV9yZXZfY29uZmxpY3QoJGYpKSB7CgkJcHVzaCBAZmlsZXMsICRmOwoJfSBlbHNlIHsKCQlwdXNoIEByZXZfbGlzdF9vcHRzLCAkZjsKCX0KfQoKaWYgKEByZXZfbGlzdF9vcHRzKSB7CglkaWUgIkNhbm5vdCBydW4gZ2l0IGZvcm1hdC1wYXRjaCBmcm9tIG91dHNpZGUgYSByZXBvc2l0b3J5XG4iCgkJdW5sZXNzICRyZXBvOwoJcHVzaCBAZmlsZXMsICRyZXBvLT5jb21tYW5kKCdmb3JtYXQtcGF0Y2gnLCAnLW8nLCB0ZW1wZGlyKENMRUFOVVAgPT4gMSksIEByZXZfbGlzdF9vcHRzKTsKfQoKaWYgKCR2YWxpZGF0ZSkgewoJZm9yZWFjaCBteSAkZiAoQGZpbGVzKSB7CgkJdW5sZXNzICgtcCAkZikgewoJCQlteSAkZXJyb3IgPSB2YWxpZGF0ZV9wYXRjaCgkZik7CgkJCSRlcnJvciBhbmQgZGllICJmYXRhbDogJGY6ICRlcnJvclxud2FybmluZzogbm8gcGF0Y2hlcyB3ZXJlIHNlbnRcbiI7CgkJfQoJfQp9CgppZiAoQGZpbGVzKSB7Cgl1bmxlc3MgKCRxdWlldCkgewoJCXByaW50ICRfLCJcbiIgZm9yIChAZmlsZXMpOwoJfQp9IGVsc2UgewoJcHJpbnQgU1RERVJSICJcbk5vIHBhdGNoIGZpbGVzIHNwZWNpZmllZCFcblxuIjsKCXVzYWdlKCk7Cn0KCnN1YiBnZXRfcGF0Y2hfc3ViamVjdCgkKSB7CglteSAkZm4gPSBzaGlmdDsKCW9wZW4gKG15ICRmaCwgJzwnLCAkZm4pOwoJd2hpbGUgKG15ICRsaW5lID0gPCRmaD4pIHsKCQluZXh0IHVubGVzcyAoJGxpbmUgPX4gL15TdWJqZWN0OiAoLiopJC8pOwoJCWNsb3NlICRmaDsKCQlyZXR1cm4gIkdJVDogJDFcbiI7Cgl9CgljbG9zZSAkZmg7CglkaWUgIk5vIHN1YmplY3QgbGluZSBpbiAkZm4gPyI7Cn0KCmlmICgkY29tcG9zZSkgewoJIyBOb3RlIHRoYXQgdGhpcyBkb2VzIG5vdCBuZWVkIHRvIGJlIHNlY3VyZSwgYnV0IHdlIHdpbGwgbWFrZSBhIHNtYWxsCgkjIGVmZm9ydCB0byBoYXZlIGl0IGJlIHVuaXF1ZQoJJGNvbXBvc2VfZmlsZW5hbWUgPSAoJHJlcG8gPwoJCXRlbXBmaWxlKCIuZ2l0c2VuZGVtYWlsLm1zZy5YWFhYWFgiLCBESVIgPT4gJHJlcG8tPnJlcG9fcGF0aCgpKSA6CgkJdGVtcGZpbGUoIi5naXRzZW5kZW1haWwubXNnLlhYWFhYWCIsIERJUiA9PiAiLiIpKVsxXTsKCW9wZW4oQywiPiIsJGNvbXBvc2VfZmlsZW5hbWUpCgkJb3IgZGllICJGYWlsZWQgdG8gb3BlbiBmb3Igd3JpdGluZyAkY29tcG9zZV9maWxlbmFtZTogJCEiOwoKCglteSAkdHBsX3NlbmRlciA9ICRzZW5kZXIgfHwgJHJlcG9hdXRob3IgfHwgJHJlcG9jb21taXR0ZXIgfHwgJyc7CglteSAkdHBsX3N1YmplY3QgPSAkaW5pdGlhbF9zdWJqZWN0IHx8ICcnOwoJbXkgJHRwbF9yZXBseV90byA9ICRpbml0aWFsX3JlcGx5X3RvIHx8ICcnOwoKCXByaW50IEMgPDxFT1Q7CkZyb20gJHRwbF9zZW5kZXIgIyBUaGlzIGxpbmUgaXMgaWdub3JlZC4KR0lUOiBMaW5lcyBiZWdpbm5pbmcgaW4gIkdJVDoiIHdpbGwgYmUgcmVtb3ZlZC4KR0lUOiBDb25zaWRlciBpbmNsdWRpbmcgYW4gb3ZlcmFsbCBkaWZmc3RhdCBvciB0YWJsZSBvZiBjb250ZW50cwpHSVQ6IGZvciB0aGUgcGF0Y2ggeW91IGFyZSB3cml0aW5nLgpHSVQ6CkdJVDogQ2xlYXIgdGhlIGJvZHkgY29udGVudCBpZiB5b3UgZG9uJ3Qgd2lzaCB0byBzZW5kIGEgc3VtbWFyeS4KRnJvbTogJHRwbF9zZW5kZXIKU3ViamVjdDogJHRwbF9zdWJqZWN0CkluLVJlcGx5LVRvOiAkdHBsX3JlcGx5X3RvCgpFT1QKCWZvciBteSAkZiAoQGZpbGVzKSB7CgkJcHJpbnQgQyBnZXRfcGF0Y2hfc3ViamVjdCgkZik7Cgl9CgljbG9zZShDKTsKCglpZiAoJGFubm90YXRlKSB7CgkJZG9fZWRpdCgkY29tcG9zZV9maWxlbmFtZSwgQGZpbGVzKTsKCX0gZWxzZSB7CgkJZG9fZWRpdCgkY29tcG9zZV9maWxlbmFtZSk7Cgl9CgoJb3BlbihDMiwiPiIsJGNvbXBvc2VfZmlsZW5hbWUgLiAiLmZpbmFsIikKCQlvciBkaWUgIkZhaWxlZCB0byBvcGVuICRjb21wb3NlX2ZpbGVuYW1lLmZpbmFsIDogIiAuICQhOwoKCW9wZW4oQywiPCIsJGNvbXBvc2VfZmlsZW5hbWUpCgkJb3IgZGllICJGYWlsZWQgdG8gb3BlbiAkY29tcG9zZV9maWxlbmFtZSA6ICIgLiAkITsKCglteSAkbmVlZF84Yml0X2N0ZSA9IGZpbGVfaGFzX25vbmFzY2lpKCRjb21wb3NlX2ZpbGVuYW1lKTsKCW15ICRpbl9ib2R5ID0gMDsKCW15ICRzdW1tYXJ5X2VtcHR5ID0gMTsKCXdoaWxlKDxDPikgewoJCW5leHQgaWYgbS9eR0lUOi87CgkJaWYgKCRpbl9ib2R5KSB7CgkJCSRzdW1tYXJ5X2VtcHR5ID0gMCB1bmxlc3MgKC9eXG4kLyk7CgkJfSBlbHNpZiAoL15cbiQvKSB7CgkJCSRpbl9ib2R5ID0gMTsKCQkJaWYgKCRuZWVkXzhiaXRfY3RlKSB7CgkJCQlwcmludCBDMiAiTUlNRS1WZXJzaW9uOiAxLjBcbiIsCgkJCQkJICJDb250ZW50LVR5cGU6IHRleHQvcGxhaW47ICIsCgkJCQkJICAgImNoYXJzZXQ9VVRGLThcbiIsCgkJCQkJICJDb250ZW50LVRyYW5zZmVyLUVuY29kaW5nOiA4Yml0XG4iOwoJCQl9CgkJfSBlbHNpZiAoL15NSU1FLVZlcnNpb246L2kpIHsKCQkJJG5lZWRfOGJpdF9jdGUgPSAwOwoJCX0gZWxzaWYgKC9eU3ViamVjdDpccyooLispXHMqJC9pKSB7CgkJCSRpbml0aWFsX3N1YmplY3QgPSAkMTsKCQkJbXkgJHN1YmplY3QgPSAkaW5pdGlhbF9zdWJqZWN0OwoJCQkkXyA9ICJTdWJqZWN0OiAiIC4KCQkJCSgkc3ViamVjdCA9fiAvW15bOmFzY2lpOl1dLyA/CgkJCQkgcXVvdGVfcmZjMjA0Nygkc3ViamVjdCkgOgoJCQkJICRzdWJqZWN0KSAuCgkJCQkiXG4iOwoJCX0gZWxzaWYgKC9eSW4tUmVwbHktVG86XHMqKC4rKVxzKiQvaSkgewoJCQkkaW5pdGlhbF9yZXBseV90byA9ICQxOwoJCQluZXh0OwoJCX0gZWxzaWYgKC9eRnJvbTpccyooLispXHMqJC9pKSB7CgkJCSRzZW5kZXIgPSAkMTsKCQkJbmV4dDsKCQl9IGVsc2lmICgvXig/OlRvfENjfEJjYyk6L2kpIHsKCQkJcHJpbnQgIlRvL0NjL0JjYyBmaWVsZHMgYXJlIG5vdCBpbnRlcnByZXRlZCB5ZXQsIHRoZXkgaGF2ZSBiZWVuIGlnbm9yZWRcbiI7CgkJCW5leHQ7CgkJfQoJCXByaW50IEMyICRfOwoJfQoJY2xvc2UoQyk7CgljbG9zZShDMik7CgoJaWYgKCRzdW1tYXJ5X2VtcHR5KSB7CgkJcHJpbnQgIlN1bW1hcnkgZW1haWwgaXMgZW1wdHksIHNraXBwaW5nIGl0XG4iOwoJCSRjb21wb3NlID0gLTE7Cgl9Cn0gZWxzaWYgKCRhbm5vdGF0ZSkgewoJZG9fZWRpdChAZmlsZXMpOwp9CgpzdWIgYXNrIHsKCW15ICgkcHJvbXB0LCAlYXJnKSA9IEBfOwoJbXkgJHZhbGlkX3JlID0gJGFyZ3t2YWxpZF9yZX07CglteSAkZGVmYXVsdCA9ICRhcmd7ZGVmYXVsdH07CglteSAkcmVzcDsKCW15ICRpID0gMDsKCXJldHVybiBkZWZpbmVkICRkZWZhdWx0ID8gJGRlZmF1bHQgOiB1bmRlZgoJCXVubGVzcyBkZWZpbmVkICR0ZXJtLT5JTiBhbmQgZGVmaW5lZCBmaWxlbm8oJHRlcm0tPklOKSBhbmQKCQkgICAgICAgZGVmaW5lZCAkdGVybS0+T1VUIGFuZCBkZWZpbmVkIGZpbGVubygkdGVybS0+T1VUKTsKCXdoaWxlICgkaSsrIDwgMTApIHsKCQkkcmVzcCA9ICR0ZXJtLT5yZWFkbGluZSgkcHJvbXB0KTsKCQlpZiAoIWRlZmluZWQgJHJlc3ApIHsgIyBFT0YKCQkJcHJpbnQgIlxuIjsKCQkJcmV0dXJuIGRlZmluZWQgJGRlZmF1bHQgPyAkZGVmYXVsdCA6IHVuZGVmOwoJCX0KCQlpZiAoJHJlc3AgZXEgJycgYW5kIGRlZmluZWQgJGRlZmF1bHQpIHsKCQkJcmV0dXJuICRkZWZhdWx0OwoJCX0KCQlpZiAoIWRlZmluZWQgJHZhbGlkX3JlIG9yICRyZXNwID1+IC8kdmFsaWRfcmUvKSB7CgkJCXJldHVybiAkcmVzcDsKCQl9Cgl9CglyZXR1cm4gdW5kZWY7Cn0KCm15ICVicm9rZW5fZW5jb2Rpbmc7CgpzdWIgZmlsZV9kZWNsYXJlc184Yml0X2N0ZSgkKSB7CglteSAkZm4gPSBzaGlmdDsKCW9wZW4gKG15ICRmaCwgJzwnLCAkZm4pOwoJd2hpbGUgKG15ICRsaW5lID0gPCRmaD4pIHsKCQlsYXN0IGlmICgkbGluZSA9fiAvXiQvKTsKCQlyZXR1cm4gMSBpZiAoJGxpbmUgPX4gL15Db250ZW50LVRyYW5zZmVyLUVuY29kaW5nOiAuKjhiaXQuKiQvKTsKCX0KCWNsb3NlICRmaDsKCXJldHVybiAwOwp9Cgpmb3JlYWNoIG15ICRmIChAZmlsZXMpIHsKCW5leHQgdW5sZXNzIChib2R5X29yX3N1YmplY3RfaGFzX25vbmFzY2lpKCRmKQoJCSAgICAgJiYgIWZpbGVfZGVjbGFyZXNfOGJpdF9jdGUoJGYpKTsKCSRicm9rZW5fZW5jb2Rpbmd7JGZ9ID0gMTsKfQoKaWYgKCFkZWZpbmVkICRhdXRvXzhiaXRfZW5jb2RpbmcgJiYgc2NhbGFyICVicm9rZW5fZW5jb2RpbmcpIHsKCXByaW50ICJUaGUgZm9sbG93aW5nIGZpbGVzIGFyZSA4Yml0LCBidXQgZG8gbm90IGRlY2xhcmUgIiAuCgkJImEgQ29udGVudC1UcmFuc2Zlci1FbmNvZGluZy5cbiI7Cglmb3JlYWNoIG15ICRmIChzb3J0IGtleXMgJWJyb2tlbl9lbmNvZGluZykgewoJCXByaW50ICIgICAgJGZcbiI7Cgl9CgkkYXV0b184Yml0X2VuY29kaW5nID0gYXNrKCJXaGljaCA4Yml0IGVuY29kaW5nIHNob3VsZCBJIGRlY2xhcmUgW1VURi04XT8gIiwKCQkJCSAgZGVmYXVsdCA9PiAiVVRGLTgiKTsKfQoKbXkgJHByb21wdGluZyA9IDA7CmlmICghZGVmaW5lZCAkc2VuZGVyKSB7Cgkkc2VuZGVyID0gJHJlcG9hdXRob3IgfHwgJHJlcG9jb21taXR0ZXIgfHwgJyc7Cgkkc2VuZGVyID0gYXNrKCJXaG8gc2hvdWxkIHRoZSBlbWFpbHMgYXBwZWFyIHRvIGJlIGZyb20/IFskc2VuZGVyXSAiLAoJICAgICAgICAgICAgICBkZWZhdWx0ID0+ICRzZW5kZXIpOwoJcHJpbnQgIkVtYWlscyB3aWxsIGJlIHNlbnQgZnJvbTogIiwgJHNlbmRlciwgIlxuIjsKCSRwcm9tcHRpbmcrKzsKfQoKaWYgKCFAdG8pIHsKCW15ICR0byA9IGFzaygiV2hvIHNob3VsZCB0aGUgZW1haWxzIGJlIHNlbnQgdG8/ICIpOwoJcHVzaCBAdG8sIHBhcnNlX2FkZHJlc3NfbGluZSgkdG8pIGlmIGRlZmluZWQgJHRvOyAjIHNhbml0aXplZC92YWxpZGF0ZWQgbGF0ZXIKCSRwcm9tcHRpbmcrKzsKfQoKc3ViIGV4cGFuZF9hbGlhc2VzIHsKCXJldHVybiBtYXAgeyBleHBhbmRfb25lX2FsaWFzKCRfKSB9IEBfOwp9CgpteSAlRVhQQU5ERURfQUxJQVNFUzsKc3ViIGV4cGFuZF9vbmVfYWxpYXMgewoJbXkgJGFsaWFzID0gc2hpZnQ7CglpZiAoJEVYUEFOREVEX0FMSUFTRVN7JGFsaWFzfSkgewoJCWRpZSAiZmF0YWw6IGFsaWFzICckYWxpYXMnIGV4cGFuZHMgdG8gaXRzZWxmXG4iOwoJfQoJbG9jYWwgJEVYUEFOREVEX0FMSUFTRVN7JGFsaWFzfSA9IDE7CglyZXR1cm4gJGFsaWFzZXN7JGFsaWFzfSA/IGV4cGFuZF9hbGlhc2VzKEB7JGFsaWFzZXN7JGFsaWFzfX0pIDogJGFsaWFzOwp9CgpAdG8gPSBleHBhbmRfYWxpYXNlcyhAdG8pOwpAdG8gPSAobWFwIHsgc2FuaXRpemVfYWRkcmVzcygkXykgfSBAdG8pOwpAaW5pdGlhbF9jYyA9IGV4cGFuZF9hbGlhc2VzKEBpbml0aWFsX2NjKTsKQGJjY2xpc3QgPSBleHBhbmRfYWxpYXNlcyhAYmNjbGlzdCk7CgppZiAoJHRocmVhZCAmJiAhZGVmaW5lZCAkaW5pdGlhbF9yZXBseV90byAmJiAkcHJvbXB0aW5nKSB7CgkkaW5pdGlhbF9yZXBseV90byA9IGFzaygKCQkiTWVzc2FnZS1JRCB0byBiZSB1c2VkIGFzIEluLVJlcGx5LVRvIGZvciB0aGUgZmlyc3QgZW1haWw/ICIpOwp9CmlmIChkZWZpbmVkICRpbml0aWFsX3JlcGx5X3RvKSB7CgkkaW5pdGlhbF9yZXBseV90byA9fiBzL15ccyo8Py8vOwoJJGluaXRpYWxfcmVwbHlfdG8gPX4gcy8+P1xzKiQvLzsKCSRpbml0aWFsX3JlcGx5X3RvID0gIjwkaW5pdGlhbF9yZXBseV90bz4iIGlmICRpbml0aWFsX3JlcGx5X3RvIG5lICcnOwp9CgppZiAoIWRlZmluZWQgJHNtdHBfc2VydmVyKSB7Cglmb3JlYWNoIChxdyggL3Vzci9zYmluL3NlbmRtYWlsIC91c3IvbGliL3NlbmRtYWlsICkpIHsKCQlpZiAoLXggJF8pIHsKCQkJJHNtdHBfc2VydmVyID0gJF87CgkJCWxhc3Q7CgkJfQoJfQoJJHNtdHBfc2VydmVyIHx8PSAnbG9jYWxob3N0JzsgIyBjb3VsZCBiZSAxMjcuMC4wLjEsIHRvby4uLiAqc2hydWcqCn0KCmlmICgkY29tcG9zZSAmJiAkY29tcG9zZSA+IDApIHsKCUBmaWxlcyA9ICgkY29tcG9zZV9maWxlbmFtZSAuICIuZmluYWwiLCBAZmlsZXMpOwp9CgojIFZhcmlhYmxlcyB3ZSBzZXQgYXMgcGFydCBvZiB0aGUgbG9vcCBvdmVyIGZpbGVzCm91ciAoJG1lc3NhZ2VfaWQsICVtYWlsLCAkc3ViamVjdCwgJHJlcGx5X3RvLCAkcmVmZXJlbmNlcywgJG1lc3NhZ2UsCgkkbmVlZHNfY29uZmlybSwgJG1lc3NhZ2VfbnVtLCAkYXNrX2RlZmF1bHQpOwoKc3ViIGV4dHJhY3RfdmFsaWRfYWRkcmVzcyB7CglteSAkYWRkcmVzcyA9IHNoaWZ0OwoJbXkgJGxvY2FsX3BhcnRfcmVnZXhwID0gJ1tePD4iXHNAXSsnOwoJbXkgJGRvbWFpbl9yZWdleHAgPSAnW14uPD4iXHNAXSsoPzpcLlteLjw+IlxzQF0rKSsnOwoKCSMgY2hlY2sgZm9yIGEgbG9jYWwgYWRkcmVzczoKCXJldHVybiAkYWRkcmVzcyBpZiAoJGFkZHJlc3MgPX4gL14oJGxvY2FsX3BhcnRfcmVnZXhwKSQvKTsKCgkkYWRkcmVzcyA9fiBzL15ccyo8KC4qKT5ccyokLyQxLzsKCWlmICgkaGF2ZV9lbWFpbF92YWxpZCkgewoJCXJldHVybiBzY2FsYXIgRW1haWw6OlZhbGlkLT5hZGRyZXNzKCRhZGRyZXNzKTsKCX0gZWxzZSB7CgkJIyBsZXNzIHJvYnVzdC9jb3JyZWN0IHRoYW4gdGhlIG1vbnN0ZXIgcmVnZXhwIGluIEVtYWlsOjpWYWxpZCwKCQkjIGJ1dCBzdGlsbCBkb2VzIGEgOTklIGpvYiwgYW5kIG9uZSBsZXNzIGRlcGVuZGVuY3kKCQkkYWRkcmVzcyA9fiAvKCRsb2NhbF9wYXJ0X3JlZ2V4cFxAJGRvbWFpbl9yZWdleHApLzsKCQlyZXR1cm4gJDE7Cgl9Cn0KCiMgVXN1YWxseSBkb24ndCBuZWVkIHRvIGNoYW5nZSBhbnl0aGluZyBiZWxvdyBoZXJlLgoKIyB3ZSBtYWtlIGEgImZha2UiIG1lc3NhZ2UgaWQgYnkgdGFraW5nIHRoZSBjdXJyZW50IG51bWJlcgojIG9mIHNlY29uZHMgc2luY2UgdGhlIGJlZ2lubmluZyBvZiBVbml4IHRpbWUgYW5kIHRhY2tpbmcgb24KIyBhIHJhbmRvbSBudW1iZXIgdG8gdGhlIGVuZCwgaW4gY2FzZSB3ZSBhcmUgY2FsbGVkIHF1aWNrZXIgdGhhbgojIDEgc2Vjb25kIHNpbmNlIHRoZSBsYXN0IHRpbWUgd2Ugd2VyZSBjYWxsZWQuCgojIFdlJ2xsIHNldHVwIGEgdGVtcGxhdGUgZm9yIHRoZSBtZXNzYWdlIGlkLCB1c2luZyB0aGUgImZyb20iIGFkZHJlc3M6CgpteSAoJG1lc3NhZ2VfaWRfc3RhbXAsICRtZXNzYWdlX2lkX3NlcmlhbCk7CnN1YiBtYWtlX21lc3NhZ2VfaWQgewoJbXkgJHVuaXE7CglpZiAoIWRlZmluZWQgJG1lc3NhZ2VfaWRfc3RhbXApIHsKCQkkbWVzc2FnZV9pZF9zdGFtcCA9IHNwcmludGYoIiVzLSVzIiwgdGltZSwgJCQpOwoJCSRtZXNzYWdlX2lkX3NlcmlhbCA9IDA7Cgl9CgkkbWVzc2FnZV9pZF9zZXJpYWwrKzsKCSR1bmlxID0gIiRtZXNzYWdlX2lkX3N0YW1wLSRtZXNzYWdlX2lkX3NlcmlhbCI7CgoJbXkgJGR1X3BhcnQ7Cglmb3IgKCRzZW5kZXIsICRyZXBvY29tbWl0dGVyLCAkcmVwb2F1dGhvcikgewoJCSRkdV9wYXJ0ID0gZXh0cmFjdF92YWxpZF9hZGRyZXNzKHNhbml0aXplX2FkZHJlc3MoJF8pKTsKCQlsYXN0IGlmIChkZWZpbmVkICRkdV9wYXJ0IGFuZCAkZHVfcGFydCBuZSAnJyk7Cgl9CglpZiAobm90IGRlZmluZWQgJGR1X3BhcnQgb3IgJGR1X3BhcnQgZXEgJycpIHsKCQl1c2UgU3lzOjpIb3N0bmFtZSBxdygpOwoJCSRkdV9wYXJ0ID0gJ3VzZXJAJyAuIFN5czo6SG9zdG5hbWU6Omhvc3RuYW1lKCk7Cgl9CglteSAkbWVzc2FnZV9pZF90ZW1wbGF0ZSA9ICI8JXMtZ2l0LXNlbmQtZW1haWwtJXM+IjsKCSRtZXNzYWdlX2lkID0gc3ByaW50ZigkbWVzc2FnZV9pZF90ZW1wbGF0ZSwgJHVuaXEsICRkdV9wYXJ0KTsKCSNwcmludCAibmV3IG1lc3NhZ2UgaWQgPSAkbWVzc2FnZV9pZFxuIjsgIyBXYXMgdXNlZnVsIGZvciBkZWJ1Z2dpbmcKfQoKCgokdGltZSA9IHRpbWUgLSBzY2FsYXIgJCNmaWxlczsKCnN1YiB1bnF1b3RlX3JmYzIwNDcgewoJbG9jYWwgKCRfKSA9IEBfOwoJbXkgJGVuY29kaW5nOwoJaWYgKHMvPVw/KFteP10rKVw/cVw/KC4qKVw/PS8kMi9nKSB7CgkJJGVuY29kaW5nID0gJDE7CgkJcy9fLyAvZzsKCQlzLz0oWzAtOUEtRl17Mn0pL2NocihoZXgoJDEpKS9lZzsKCX0KCXJldHVybiB3YW50YXJyYXkgPyAoJF8sICRlbmNvZGluZykgOiAkXzsKfQoKc3ViIHF1b3RlX3JmYzIwNDcgewoJbG9jYWwgJF8gPSBzaGlmdDsKCW15ICRlbmNvZGluZyA9IHNoaWZ0IHx8ICdVVEYtOCc7CglzLyhbXi1hLXpBLVowLTkhKitcL10pL3NwcmludGYoIj0lMDJYIiwgb3JkKCQxKSkvZWc7CglzLyguKikvPVw/JGVuY29kaW5nXD9xXD8kMVw/PS87CglyZXR1cm4gJF87Cn0KCnN1YiBpc19yZmMyMDQ3X3F1b3RlZCB7CglteSAkcyA9IHNoaWZ0OwoJbXkgJHRva2VuID0gJ1teXVsoKTw+QCw7OiJcLz8uPSBcMDAwLVwwMzdcMTc3LVwzNzddKyc7CglteSAkZW5jb2RlZF90ZXh0ID0gJ1shLT5ALX5dKyc7CglsZW5ndGgoJHMpIDw9IDc1ICYmCgkkcyA9fiBtL14oPzoiW1s6YXNjaWk6XV0qInw9XD8kdG9rZW5cPyR0b2tlblw/JGVuY29kZWRfdGV4dFw/PSkkL287Cn0KCiMgdXNlIHRoZSBzaW1wbGVzdCBxdW90aW5nIGJlaW5nIGFibGUgdG8gaGFuZGxlIHRoZSByZWNpcGllbnQKc3ViIHNhbml0aXplX2FkZHJlc3MgewoJbXkgKCRyZWNpcGllbnQpID0gQF87CglteSAoJHJlY2lwaWVudF9uYW1lLCAkcmVjaXBpZW50X2FkZHIpID0gKCRyZWNpcGllbnQgPX4gL14oLio/KVxzKig8LiopLyk7CgoJaWYgKG5vdCAkcmVjaXBpZW50X25hbWUpIHsKCQlyZXR1cm4gIiRyZWNpcGllbnQiOwoJfQoKCSMgaWYgcmVjaXBpZW50X25hbWUgaXMgYWxyZWFkeSBxdW90ZWQsIGRvIG5vdGhpbmcKCWlmIChpc19yZmMyMDQ3X3F1b3RlZCgkcmVjaXBpZW50X25hbWUpKSB7CgkJcmV0dXJuICRyZWNpcGllbnQ7Cgl9CgoJIyByZmMyMDQ3IGlzIG5lZWRlZCBpZiBhIG5vbi1hc2NpaSBjaGFyIGlzIGluY2x1ZGVkCglpZiAoJHJlY2lwaWVudF9uYW1lID1+IC9bXls6YXNjaWk6XV0vKSB7CgkJJHJlY2lwaWVudF9uYW1lID1+IHMvXiIoLiopIiQvJDEvOwoJCSRyZWNpcGllbnRfbmFtZSA9IHF1b3RlX3JmYzIwNDcoJHJlY2lwaWVudF9uYW1lKTsKCX0KCgkjIGRvdWJsZSBxdW90ZXMgYXJlIG5lZWRlZCBpZiBzcGVjaWFscyBvciBDVExzIGFyZSBpbmNsdWRlZAoJZWxzaWYgKCRyZWNpcGllbnRfbmFtZSA9fiAvW11bKCk8PkAsOzpcXCIuXDAwMC1cMDM3XDE3N10vKSB7CgkJJHJlY2lwaWVudF9uYW1lID1+IHMvKFsiXFxccl0pL1xcJDEvZzsKCQkkcmVjaXBpZW50X25hbWUgPSAiXCIkcmVjaXBpZW50X25hbWVcIiI7Cgl9CgoJcmV0dXJuICIkcmVjaXBpZW50X25hbWUgJHJlY2lwaWVudF9hZGRyIjsKCn0KCiMgUmV0dXJucyB0aGUgbG9jYWwgRnVsbHkgUXVhbGlmaWVkIERvbWFpbiBOYW1lIChGUUROKSBpZiBhdmFpbGFibGUuCiMKIyBUaWdodGx5IGNvbmZpZ3VyZWQgTVRBYSByZXF1aXJlIHRoYXQgYSBjYWxsZXIgc2VuZHMgYSByZWFsIEROUwojIGRvbWFpbiBuYW1lIHRoYXQgY29ycmVzcG9uZHMgdGhlIElQIGFkZHJlc3MgaW4gdGhlIEhFTE8vRUhMTwojIGhhbmRzaGFrZS4gVGhpcyBpcyB1c2VkIHRvIHZlcmlmeSB0aGUgY29ubmVjdGlvbiBhbmQgcHJldmVudAojIHNwYW1tZXJzIGZyb20gdHJ5aW5nIHRvIGhpZGUgdGhlaXIgaWRlbnRpdHkuIElmIHRoZSBETlMgYW5kIElQIGRvbid0CiMgbWF0Y2gsIHRoZSByZWNlaXZlaW5nIE1UQSBtYXkgZGVueSB0aGUgY29ubmVjdGlvbi4KIwojIEhlcmUgaXMgYSBkZW55IGV4YW1wbGUgb2YgTmV0OjpTTVRQIHdpdGggdGhlIGRlZmF1bHQgImxvY2FsaG9zdC5sb2NhbGRvbWFpbiIKIwojIE5ldDo6U01UUD1HTE9CKDB4MjY3ZWMyOCk+Pj4gRUhMTyBsb2NhbGhvc3QubG9jYWxkb21haW4KIyBOZXQ6OlNNVFA9R0xPQigweDI2N2VjMjgpPDw8IDU1MCBFSExPIGFyZ3VtZW50IGRvZXMgbm90IG1hdGNoIGNhbGxpbmcgaG9zdAojCiMgVGhpcyBtYWlsZG9tYWluKigpIGNvZGUgaXMgYmFzZWQgb24gaWRlYXMgaW4gUGVybCBsaWJyYXJ5IFRlc3Q6OlJlcG9ydGVyCiMgL3Vzci9zaGFyZS9wZXJsNS9UZXN0L1JlcG9ydGVyL01haWwvVXRpbC5wbSA9PT4gc3ViIF9tYWlsZG9tYWluICgpCgpzdWIgdmFsaWRfZnFkbiB7CglteSAkZG9tYWluID0gc2hpZnQ7CglyZXR1cm4gISgkXk8gZXEgJ2RhcndpbicgJiYgJGRvbWFpbiA9fiAvXC5sb2NhbCQvKSAmJiAkZG9tYWluID1+IC9cLi87Cn0KCnN1YiBtYWlsZG9tYWluX25ldCB7CglteSAkbWFpbGRvbWFpbjsKCglpZiAoZXZhbCB7IHJlcXVpcmUgTmV0OjpEb21haW47IDEgfSkgewoJCW15ICRkb21haW4gPSBOZXQ6OkRvbWFpbjo6ZG9tYWlubmFtZSgpOwoJCSRtYWlsZG9tYWluID0gJGRvbWFpbiBpZiB2YWxpZF9mcWRuKCRkb21haW4pOwoJfQoKCXJldHVybiAkbWFpbGRvbWFpbjsKfQoKc3ViIG1haWxkb21haW5fbXRhIHsKCW15ICRtYWlsZG9tYWluOwoKCWlmIChldmFsIHsgcmVxdWlyZSBOZXQ6OlNNVFA7IDEgfSkgewoJCWZvciBteSAkaG9zdCAocXcobWFpbGhvc3QgbG9jYWxob3N0KSkgewoJCQlteSAkc210cCA9IE5ldDo6U01UUC0+bmV3KCRob3N0KTsKCQkJaWYgKGRlZmluZWQgJHNtdHApIHsKCQkJCW15ICRkb21haW4gPSAkc210cC0+ZG9tYWluOwoJCQkJJHNtdHAtPnF1aXQ7CgoJCQkJJG1haWxkb21haW4gPSAkZG9tYWluIGlmIHZhbGlkX2ZxZG4oJGRvbWFpbik7CgoJCQkJbGFzdCBpZiAkbWFpbGRvbWFpbjsKCQkJfQoJCX0KCX0KCglyZXR1cm4gJG1haWxkb21haW47Cn0KCnN1YiBtYWlsZG9tYWluIHsKCXJldHVybiBtYWlsZG9tYWluX25ldCgpIHx8IG1haWxkb21haW5fbXRhKCkgfHwgJ2xvY2FsaG9zdC5sb2NhbGRvbWFpbic7Cn0KCiMgUmV0dXJucyAxIGlmIHRoZSBtZXNzYWdlIHdhcyBzZW50LCBhbmQgMCBvdGhlcndpc2UuCiMgSW4gYWN0dWFsaXR5LCB0aGUgd2hvbGUgcHJvZ3JhbSBkaWVzIHdoZW4gdGhlcmUKIyBpcyBhbiBlcnJvciBzZW5kaW5nIGEgbWVzc2FnZS4KCnN1YiBzZW5kX21lc3NhZ2UgewoJbXkgQHJlY2lwaWVudHMgPSB1bmlxdWVfZW1haWxfbGlzdChAdG8pOwoJQGNjID0gKGdyZXAgeyBteSAkY2MgPSBleHRyYWN0X3ZhbGlkX2FkZHJlc3MoJF8pOwoJCSAgICAgIG5vdCBncmVwIHsgJGNjIGVxICRfIH0gQHJlY2lwaWVudHMKCQkgICAgfQoJICAgICAgIG1hcCB7IHNhbml0aXplX2FkZHJlc3MoJF8pIH0KCSAgICAgICBAY2MpOwoJbXkgJHRvID0gam9pbiAoIixcblx0IiwgQHJlY2lwaWVudHMpOwoJQHJlY2lwaWVudHMgPSB1bmlxdWVfZW1haWxfbGlzdChAcmVjaXBpZW50cyxAY2MsQGJjY2xpc3QpOwoJQHJlY2lwaWVudHMgPSAobWFwIHsgZXh0cmFjdF92YWxpZF9hZGRyZXNzKCRfKSB9IEByZWNpcGllbnRzKTsKCW15ICRkYXRlID0gZm9ybWF0XzI4MjJfdGltZSgkdGltZSsrKTsKCW15ICRnaXR2ZXJzaW9uID0gJ0BAR0lUX1ZFUlNJT05AQCc7CglpZiAoJGdpdHZlcnNpb24gPX4gbS8uLkdJVF9WRVJTSU9OLi4vKSB7CgkgICAgJGdpdHZlcnNpb24gPSBHaXQ6OnZlcnNpb24oKTsKCX0KCglteSAkY2MgPSBqb2luKCIsXG5cdCIsIHVuaXF1ZV9lbWFpbF9saXN0KEBjYykpOwoJbXkgJGNjbGluZSA9ICIiOwoJaWYgKCRjYyBuZSAnJykgewoJCSRjY2xpbmUgPSAiXG5DYzogJGNjIjsKCX0KCW15ICRzYW5pdGl6ZWRfc2VuZGVyID0gc2FuaXRpemVfYWRkcmVzcygkc2VuZGVyKTsKCW1ha2VfbWVzc2FnZV9pZCgpIHVubGVzcyBkZWZpbmVkKCRtZXNzYWdlX2lkKTsKCglteSAkaGVhZGVyID0gIkZyb206ICRzYW5pdGl6ZWRfc2VuZGVyClRvOiAkdG8ke2NjbGluZX0KU3ViamVjdDogJHN1YmplY3QKRGF0ZTogJGRhdGUKTWVzc2FnZS1JZDogJG1lc3NhZ2VfaWQKWC1NYWlsZXI6IGdpdC1zZW5kLWVtYWlsICRnaXR2ZXJzaW9uCiI7CglpZiAoJHJlcGx5X3RvKSB7CgoJCSRoZWFkZXIgLj0gIkluLVJlcGx5LVRvOiAkcmVwbHlfdG9cbiI7CgkJJGhlYWRlciAuPSAiUmVmZXJlbmNlczogJHJlZmVyZW5jZXNcbiI7Cgl9CglpZiAoQHhoKSB7CgkJJGhlYWRlciAuPSBqb2luKCJcbiIsIEB4aCkgLiAiXG4iOwoJfQoKCW15IEBzZW5kbWFpbF9wYXJhbWV0ZXJzID0gKCctaScsIEByZWNpcGllbnRzKTsKCW15ICRyYXdfZnJvbSA9ICRzYW5pdGl6ZWRfc2VuZGVyOwoJaWYgKGRlZmluZWQgJGVudmVsb3BlX3NlbmRlciAmJiAkZW52ZWxvcGVfc2VuZGVyIG5lICJhdXRvIikgewoJCSRyYXdfZnJvbSA9ICRlbnZlbG9wZV9zZW5kZXI7Cgl9CgkkcmF3X2Zyb20gPSBleHRyYWN0X3ZhbGlkX2FkZHJlc3MoJHJhd19mcm9tKTsKCXVuc2hpZnQgKEBzZW5kbWFpbF9wYXJhbWV0ZXJzLAoJCQknLWYnLCAkcmF3X2Zyb20pIGlmKGRlZmluZWQgJGVudmVsb3BlX3NlbmRlcik7CgoJaWYgKCRuZWVkc19jb25maXJtICYmICEkZHJ5X3J1bikgewoJCXByaW50ICJcbiRoZWFkZXJcbiI7CgkJaWYgKCRuZWVkc19jb25maXJtIGVxICJpbmZvcm0iKSB7CgkJCSRjb25maXJtX3VuY29uZmlndXJlZCA9IDA7ICMgc3F1ZWxjaCB0aGlzIG1lc3NhZ2UgZm9yIHRoZSByZXN0IG9mIHRoaXMgcnVuCgkJCSRhc2tfZGVmYXVsdCA9ICJ5IjsgIyBhc3N1bWUgeWVzIG9uIEVPRiBzaW5jZSB1c2VyIGhhc24ndCBleHBsaWNpdGx5IGFza2VkIGZvciBjb25maXJtYXRpb24KCQkJcHJpbnQgIiAgICBUaGUgQ2MgbGlzdCBhYm92ZSBoYXMgYmVlbiBleHBhbmRlZCBieSBhZGRpdGlvbmFsXG4iOwoJCQlwcmludCAiICAgIGFkZHJlc3NlcyBmb3VuZCBpbiB0aGUgcGF0Y2ggY29tbWl0IG1lc3NhZ2UuIEJ5IGRlZmF1bHRcbiI7CgkJCXByaW50ICIgICAgc2VuZC1lbWFpbCBwcm9tcHRzIGJlZm9yZSBzZW5kaW5nIHdoZW5ldmVyIHRoaXMgb2NjdXJzLlxuIjsKCQkJcHJpbnQgIiAgICBUaGlzIGJlaGF2aW9yIGlzIGNvbnRyb2xsZWQgYnkgdGhlIHNlbmRlbWFpbC5jb25maXJtXG4iOwoJCQlwcmludCAiICAgIGNvbmZpZ3VyYXRpb24gc2V0dGluZy5cbiI7CgkJCXByaW50ICJcbiI7CgkJCXByaW50ICIgICAgRm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24sIHJ1biAnZ2l0IHNlbmQtZW1haWwgLS1oZWxwJy5cbiI7CgkJCXByaW50ICIgICAgVG8gcmV0YWluIHRoZSBjdXJyZW50IGJlaGF2aW9yLCBidXQgc3F1ZWxjaCB0aGlzIG1lc3NhZ2UsXG4iOwoJCQlwcmludCAiICAgIHJ1biAnZ2l0IGNvbmZpZyAtLWdsb2JhbCBzZW5kZW1haWwuY29uZmlybSBhdXRvJy5cblxuIjsKCQl9CgkJJF8gPSBhc2soIlNlbmQgdGhpcyBlbWFpbD8gKFt5XWVzfFtuXW98W3FddWl0fFthXWxsKTogIiwKCQkgICAgICAgICB2YWxpZF9yZSA9PiBxci9eKD86eWVzfHl8bm98bnxxdWl0fHF8YWxsfGEpL2ksCgkJICAgICAgICAgZGVmYXVsdCA9PiAkYXNrX2RlZmF1bHQpOwoJCWRpZSAiU2VuZCB0aGlzIGVtYWlsIHJlcGx5IHJlcXVpcmVkIiB1bmxlc3MgZGVmaW5lZCAkXzsKCQlpZiAoL15uL2kpIHsKCQkJcmV0dXJuIDA7CgkJfSBlbHNpZiAoL15xL2kpIHsKCQkJY2xlYW51cF9jb21wb3NlX2ZpbGVzKCk7CgkJCWV4aXQoMCk7CgkJfSBlbHNpZiAoL15hL2kpIHsKCQkJJGNvbmZpcm0gPSAnbmV2ZXInOwoJCX0KCX0KCglpZiAoJGRyeV9ydW4pIHsKCQkjIFdlIGRvbid0IHdhbnQgdG8gc2VuZCB0aGUgZW1haWwuCgl9IGVsc2lmICgkc210cF9zZXJ2ZXIgPX4gbSNeLyMpIHsKCQlteSAkcGlkID0gb3BlbiBteSAkc20sICd8LSc7CgkJZGVmaW5lZCAkcGlkIG9yIGRpZSAkITsKCQlpZiAoISRwaWQpIHsKCQkJZXhlYygkc210cF9zZXJ2ZXIsIEBzZW5kbWFpbF9wYXJhbWV0ZXJzKSBvciBkaWUgJCE7CgkJfQoJCXByaW50ICRzbSAiJGhlYWRlclxuJG1lc3NhZ2UiOwoJCWNsb3NlICRzbSBvciBkaWUgJD87Cgl9IGVsc2UgewoKCQlpZiAoIWRlZmluZWQgJHNtdHBfc2VydmVyKSB7CgkJCWRpZSAiVGhlIHJlcXVpcmVkIFNNVFAgc2VydmVyIGlzIG5vdCBwcm9wZXJseSBkZWZpbmVkLiIKCQl9CgoJCWlmICgkc210cF9lbmNyeXB0aW9uIGVxICdzc2wnKSB7CgkJCSRzbXRwX3NlcnZlcl9wb3J0IHx8PSA0NjU7ICMgc3NtdHAKCQkJcmVxdWlyZSBOZXQ6OlNNVFA6OlNTTDsKCQkJJHNtdHBfZG9tYWluIHx8PSBtYWlsZG9tYWluKCk7CgkJCSRzbXRwIHx8PSBOZXQ6OlNNVFA6OlNTTC0+bmV3KCRzbXRwX3NlcnZlciwKCQkJCQkJICAgICAgSGVsbG8gPT4gJHNtdHBfZG9tYWluLAoJCQkJCQkgICAgICBQb3J0ID0+ICRzbXRwX3NlcnZlcl9wb3J0KTsKCQl9CgkJZWxzZSB7CgkJCXJlcXVpcmUgTmV0OjpTTVRQOwoJCQkkc210cF9kb21haW4gfHw9IG1haWxkb21haW4oKTsKCQkJJHNtdHAgfHw9IE5ldDo6U01UUC0+bmV3KChkZWZpbmVkICRzbXRwX3NlcnZlcl9wb3J0KQoJCQkJCQkgPyAiJHNtdHBfc2VydmVyOiRzbXRwX3NlcnZlcl9wb3J0IgoJCQkJCQkgOiAkc210cF9zZXJ2ZXIsCgkJCQkJCSBIZWxsbyA9PiAkc210cF9kb21haW4sCgkJCQkJCSBEZWJ1ZyA9PiAkZGVidWdfbmV0X3NtdHApOwoJCQlpZiAoJHNtdHBfZW5jcnlwdGlvbiBlcSAndGxzJyAmJiAkc210cCkgewoJCQkJcmVxdWlyZSBOZXQ6OlNNVFA6OlNTTDsKCQkJCSRzbXRwLT5jb21tYW5kKCdTVEFSVFRMUycpOwoJCQkJJHNtdHAtPnJlc3BvbnNlKCk7CgkJCQlpZiAoJHNtdHAtPmNvZGUgPT0gMjIwKSB7CgkJCQkJJHNtdHAgPSBOZXQ6OlNNVFA6OlNTTC0+c3RhcnRfU1NMKCRzbXRwKQoJCQkJCQlvciBkaWUgIlNUQVJUVExTIGZhaWxlZCEgIi4kc210cC0+bWVzc2FnZTsKCQkJCQkkc210cF9lbmNyeXB0aW9uID0gJyc7CgkJCQkJIyBTZW5kIEVITE8gYWdhaW4gdG8gcmVjZWl2ZSBmcmVzaAoJCQkJCSMgc3VwcG9ydGVkIGNvbW1hbmRzCgkJCQkJJHNtdHAtPmhlbGxvKCk7CgkJCQl9IGVsc2UgewoJCQkJCWRpZSAiU2VydmVyIGRvZXMgbm90IHN1cHBvcnQgU1RBUlRUTFMhICIuJHNtdHAtPm1lc3NhZ2U7CgkJCQl9CgkJCX0KCQl9CgoJCWlmICghJHNtdHApIHsKCQkJZGllICJVbmFibGUgdG8gaW5pdGlhbGl6ZSBTTVRQIHByb3Blcmx5LiBDaGVjayBjb25maWcgYW5kIHVzZSAtLXNtdHAtZGVidWcuICIsCgkJCSAgICAiVkFMVUVTOiBzZXJ2ZXI9JHNtdHBfc2VydmVyICIsCgkJCSAgICAiZW5jcnlwdGlvbj0kc210cF9lbmNyeXB0aW9uICIsCgkJCSAgICAiaGVsbG89JHNtdHBfZG9tYWluIiwKCQkJICAgIGRlZmluZWQgJHNtdHBfc2VydmVyX3BvcnQgPyAicG9ydD0kc210cF9zZXJ2ZXJfcG9ydCIgOiAiIjsKCQl9CgoJCWlmIChkZWZpbmVkICRzbXRwX2F1dGh1c2VyKSB7CgoJCQlpZiAoIWRlZmluZWQgJHNtdHBfYXV0aHBhc3MpIHsKCgkJCQlzeXN0ZW0gInN0dHkgLWVjaG8iOwoKCQkJCWRvIHsKCQkJCQlwcmludCAiUGFzc3dvcmQ6ICI7CgkJCQkJJF8gPSA8U1RESU4+OwoJCQkJCXByaW50ICJcbiI7CgkJCQl9IHdoaWxlICghZGVmaW5lZCAkXyk7CgoJCQkJY2hvbXAoJHNtdHBfYXV0aHBhc3MgPSAkXyk7CgoJCQkJc3lzdGVtICJzdHR5IGVjaG8iOwoJCQl9CgoJCQkkYXV0aCB8fD0gJHNtdHAtPmF1dGgoICRzbXRwX2F1dGh1c2VyLCAkc210cF9hdXRocGFzcyApIG9yIGRpZSAkc210cC0+bWVzc2FnZTsKCQl9CgoJCSRzbXRwLT5tYWlsKCAkcmF3X2Zyb20gKSBvciBkaWUgJHNtdHAtPm1lc3NhZ2U7CgkJJHNtdHAtPnRvKCBAcmVjaXBpZW50cyApIG9yIGRpZSAkc210cC0+bWVzc2FnZTsKCQkkc210cC0+ZGF0YSBvciBkaWUgJHNtdHAtPm1lc3NhZ2U7CgkJJHNtdHAtPmRhdGFzZW5kKCIkaGVhZGVyXG4kbWVzc2FnZSIpIG9yIGRpZSAkc210cC0+bWVzc2FnZTsKCQkkc210cC0+ZGF0YWVuZCgpIG9yIGRpZSAkc210cC0+bWVzc2FnZTsKCQkkc210cC0+Y29kZSA9fiAvMjUwfDIwMC8gb3IgZGllICJGYWlsZWQgdG8gc2VuZCAkc3ViamVjdFxuIi4kc210cC0+bWVzc2FnZTsKCX0KCWlmICgkcXVpZXQpIHsKCQlwcmludGYgKCgkZHJ5X3J1biA/ICJEcnktIiA6ICIiKS4iU2VudCAlc1xuIiwgJHN1YmplY3QpOwoJfSBlbHNlIHsKCQlwcmludCAoKCRkcnlfcnVuID8gIkRyeS0iIDogIiIpLiJPSy4gTG9nIHNheXM6XG4iKTsKCQlpZiAoJHNtdHBfc2VydmVyICF+IG0jXi8jKSB7CgkJCXByaW50ICJTZXJ2ZXI6ICRzbXRwX3NlcnZlclxuIjsKCQkJcHJpbnQgIk1BSUwgRlJPTTo8JHJhd19mcm9tPlxuIjsKCQkJZm9yZWFjaCBteSAkZW50cnkgKEByZWNpcGllbnRzKSB7CgkJCSAgICBwcmludCAiUkNQVCBUTzo8JGVudHJ5PlxuIjsKCQkJfQoJCX0gZWxzZSB7CgkJCXByaW50ICJTZW5kbWFpbDogJHNtdHBfc2VydmVyICIuam9pbignICcsQHNlbmRtYWlsX3BhcmFtZXRlcnMpLiJcbiI7CgkJfQoJCXByaW50ICRoZWFkZXIsICJcbiI7CgkJaWYgKCRzbXRwKSB7CgkJCXByaW50ICJSZXN1bHQ6ICIsICRzbXRwLT5jb2RlLCAnICcsCgkJCQkoJHNtdHAtPm1lc3NhZ2UgPX4gL1xuKFteXG5dK1xuKSQvcyksICJcbiI7CgkJfSBlbHNlIHsKCQkJcHJpbnQgIlJlc3VsdDogT0tcbiI7CgkJfQoJfQoKCXJldHVybiAxOwp9CgokcmVwbHlfdG8gPSAkaW5pdGlhbF9yZXBseV90bzsKJHJlZmVyZW5jZXMgPSAkaW5pdGlhbF9yZXBseV90byB8fCAnJzsKJHN1YmplY3QgPSAkaW5pdGlhbF9zdWJqZWN0OwokbWVzc2FnZV9udW0gPSAwOwoKZm9yZWFjaCBteSAkdCAoQGZpbGVzKSB7CglvcGVuKEYsIjwiLCR0KSBvciBkaWUgImNhbid0IG9wZW4gZmlsZSAkdCI7CgoJbXkgJGF1dGhvciA9IHVuZGVmOwoJbXkgJGF1dGhvcl9lbmNvZGluZzsKCW15ICRoYXNfY29udGVudF90eXBlOwoJbXkgJGJvZHlfZW5jb2Rpbmc7CglAY2MgPSAoKTsKCUB4aCA9ICgpOwoJbXkgJGlucHV0X2Zvcm1hdCA9IHVuZGVmOwoJbXkgQGhlYWRlciA9ICgpOwoJJG1lc3NhZ2UgPSAiIjsKCSRtZXNzYWdlX251bSsrOwoJIyBGaXJzdCB1bmZvbGQgbXVsdGlsaW5lIGhlYWRlciBmaWVsZHMKCXdoaWxlKDxGPikgewoJCWxhc3QgaWYgL15ccyokLzsKCQlpZiAoL15ccytcUy8gYW5kIEBoZWFkZXIpIHsKCQkJY2hvbXAoJGhlYWRlclskI2hlYWRlcl0pOwoJCQlzL15ccysvIC87CgkJCSRoZWFkZXJbJCNoZWFkZXJdIC49ICRfOwoJICAgIH0gZWxzZSB7CgkJCXB1c2goQGhlYWRlciwgJF8pOwoJCX0KCX0KCSMgTm93IHBhcnNlIHRoZSBoZWFkZXIKCWZvcmVhY2goQGhlYWRlcikgewoJCWlmICgvXkZyb20gLykgewoJCQkkaW5wdXRfZm9ybWF0ID0gJ21ib3gnOwoJCQluZXh0OwoJCX0KCQljaG9tcDsKCQlpZiAoIWRlZmluZWQgJGlucHV0X2Zvcm1hdCAmJiAvXlstQS1aYS16XSs6XHMvKSB7CgkJCSRpbnB1dF9mb3JtYXQgPSAnbWJveCc7CgkJfQoKCQlpZiAoZGVmaW5lZCAkaW5wdXRfZm9ybWF0ICYmICRpbnB1dF9mb3JtYXQgZXEgJ21ib3gnKSB7CgkJCWlmICgvXlN1YmplY3Q6XHMrKC4qKSQvKSB7CgkJCQkkc3ViamVjdCA9ICQxOwoJCQl9CgkJCWVsc2lmICgvXkZyb206XHMrKC4qKSQvKSB7CgkJCQkoJGF1dGhvciwgJGF1dGhvcl9lbmNvZGluZykgPSB1bnF1b3RlX3JmYzIwNDcoJDEpOwoJCQkJbmV4dCBpZiAkc3VwcHJlc3NfY2N7J2F1dGhvcid9OwoJCQkJbmV4dCBpZiAkc3VwcHJlc3NfY2N7J3NlbGYnfSBhbmQgJGF1dGhvciBlcSAkc2VuZGVyOwoJCQkJcHJpbnRmKCIobWJveCkgQWRkaW5nIGNjOiAlcyBmcm9tIGxpbmUgJyVzJ1xuIiwKCQkJCQkkMSwgJF8pIHVubGVzcyAkcXVpZXQ7CgkJCQlwdXNoIEBjYywgJDE7CgkJCX0KCQkJZWxzaWYgKC9eQ2M6XHMrKC4qKSQvKSB7CgkJCQlmb3JlYWNoIG15ICRhZGRyIChwYXJzZV9hZGRyZXNzX2xpbmUoJDEpKSB7CgkJCQkJaWYgKHVucXVvdGVfcmZjMjA0NygkYWRkcikgZXEgJHNlbmRlcikgewoJCQkJCQluZXh0IGlmICgkc3VwcHJlc3NfY2N7J3NlbGYnfSk7CgkJCQkJfSBlbHNlIHsKCQkJCQkJbmV4dCBpZiAoJHN1cHByZXNzX2NjeydjYyd9KTsKCQkJCQl9CgkJCQkJcHJpbnRmKCIobWJveCkgQWRkaW5nIGNjOiAlcyBmcm9tIGxpbmUgJyVzJ1xuIiwKCQkJCQkJJGFkZHIsICRfKSB1bmxlc3MgJHF1aWV0OwoJCQkJCXB1c2ggQGNjLCAkYWRkcjsKCQkJCX0KCQkJfQoJCQllbHNpZiAoL15Db250ZW50LXR5cGU6L2kpIHsKCQkJCSRoYXNfY29udGVudF90eXBlID0gMTsKCQkJCWlmICgvY2hhcnNldD0iPyhbXiAiXSspLykgewoJCQkJCSRib2R5X2VuY29kaW5nID0gJDE7CgkJCQl9CgkJCQlwdXNoIEB4aCwgJF87CgkJCX0KCQkJZWxzaWYgKC9eTWVzc2FnZS1JZDogKC4qKS9pKSB7CgkJCQkkbWVzc2FnZV9pZCA9ICQxOwoJCQl9CgkJCWVsc2lmICghL15EYXRlOlxzLyAmJiAvXlstQS1aYS16XSs6XHMrXFMvKSB7CgkJCQlwdXNoIEB4aCwgJF87CgkJCX0KCgkJfSBlbHNlIHsKCQkJIyBJbiB0aGUgdHJhZGl0aW9uYWwKCQkJIyAic2VuZCBsb3RzIG9mIGVtYWlsIiBmb3JtYXQsCgkJCSMgbGluZSAxID0gY2MKCQkJIyBsaW5lIDIgPSBzdWJqZWN0CgkJCSMgU28gbGV0J3Mgc3VwcG9ydCB0aGF0LCB0b28uCgkJCSRpbnB1dF9mb3JtYXQgPSAnbG90cyc7CgkJCWlmIChAY2MgPT0gMCAmJiAhJHN1cHByZXNzX2NjeydjYyd9KSB7CgkJCQlwcmludGYoIihub24tbWJveCkgQWRkaW5nIGNjOiAlcyBmcm9tIGxpbmUgJyVzJ1xuIiwKCQkJCQkkXywgJF8pIHVubGVzcyAkcXVpZXQ7CgkJCQlwdXNoIEBjYywgJF87CgkJCX0gZWxzaWYgKCFkZWZpbmVkICRzdWJqZWN0KSB7CgkJCQkkc3ViamVjdCA9ICRfOwoJCQl9CgkJfQoJfQoJIyBOb3cgcGFyc2UgdGhlIG1lc3NhZ2UgYm9keQoJd2hpbGUoPEY+KSB7CgkJJG1lc3NhZ2UgLj0gICRfOwoJCWlmICgvXihTaWduZWQtb2ZmLWJ5fENjKTogKC4qKSQvaSkgewoJCQljaG9tcDsKCQkJbXkgKCR3aGF0LCAkYykgPSAoJDEsICQyKTsKCQkJY2hvbXAgJGM7CgkJCWlmICgkYyBlcSAkc2VuZGVyKSB7CgkJCQluZXh0IGlmICgkc3VwcHJlc3NfY2N7J3NlbGYnfSk7CgkJCX0gZWxzZSB7CgkJCQluZXh0IGlmICRzdXBwcmVzc19jY3snc29iJ30gYW5kICR3aGF0ID1+IC9TaWduZWQtb2ZmLWJ5L2k7CgkJCQluZXh0IGlmICRzdXBwcmVzc19jY3snYm9keWNjJ30gYW5kICR3aGF0ID1+IC9DYy9pOwoJCQl9CgkJCXB1c2ggQGNjLCAkYzsKCQkJcHJpbnRmKCIoYm9keSkgQWRkaW5nIGNjOiAlcyBmcm9tIGxpbmUgJyVzJ1xuIiwKCQkJCSRjLCAkXykgdW5sZXNzICRxdWlldDsKCQl9Cgl9CgljbG9zZSBGOwoKCWlmIChkZWZpbmVkICRjY19jbWQgJiYgISRzdXBwcmVzc19jY3snY2NjbWQnfSkgewoJCW9wZW4oRiwgIiRjY19jbWQgXFEkdFxFIHwiKQoJCQlvciBkaWUgIihjYy1jbWQpIENvdWxkIG5vdCBleGVjdXRlICckY2NfY21kJyI7CgkJd2hpbGUoPEY+KSB7CgkJCW15ICRjID0gJF87CgkJCSRjID1+IHMvXlxzKi8vZzsKCQkJJGMgPX4gcy9cbiQvL2c7CgkJCW5leHQgaWYgKCRjIGVxICRzZW5kZXIgYW5kICRzdXBwcmVzc19mcm9tKTsKCQkJcHVzaCBAY2MsICRjOwoJCQlwcmludGYoIihjYy1jbWQpIEFkZGluZyBjYzogJXMgZnJvbTogJyVzJ1xuIiwKCQkJCSRjLCAkY2NfY21kKSB1bmxlc3MgJHF1aWV0OwoJCX0KCQljbG9zZSBGCgkJCW9yIGRpZSAiKGNjLWNtZCkgZmFpbGVkIHRvIGNsb3NlIHBpcGUgdG8gJyRjY19jbWQnIjsKCX0KCglpZiAoJGJyb2tlbl9lbmNvZGluZ3skdH0gJiYgISRoYXNfY29udGVudF90eXBlKSB7CgkJJGhhc19jb250ZW50X3R5cGUgPSAxOwoJCXB1c2ggQHhoLCAiTUlNRS1WZXJzaW9uOiAxLjAiLAoJCQkiQ29udGVudC1UeXBlOiB0ZXh0L3BsYWluOyBjaGFyc2V0PSRhdXRvXzhiaXRfZW5jb2RpbmciLAoJCQkiQ29udGVudC1UcmFuc2Zlci1FbmNvZGluZzogOGJpdCI7CgkJJGJvZHlfZW5jb2RpbmcgPSAkYXV0b184Yml0X2VuY29kaW5nOwoJfQoKCWlmICgkYnJva2VuX2VuY29kaW5neyR0fSAmJiAhaXNfcmZjMjA0N19xdW90ZWQoJHN1YmplY3QpKSB7CgkJJHN1YmplY3QgPSBxdW90ZV9yZmMyMDQ3KCRzdWJqZWN0LCAkYXV0b184Yml0X2VuY29kaW5nKTsKCX0KCglpZiAoZGVmaW5lZCAkYXV0aG9yIGFuZCAkYXV0aG9yIG5lICRzZW5kZXIpIHsKCQkkbWVzc2FnZSA9ICJGcm9tOiAkYXV0aG9yXG5cbiRtZXNzYWdlIjsKCQlpZiAoZGVmaW5lZCAkYXV0aG9yX2VuY29kaW5nKSB7CgkJCWlmICgkaGFzX2NvbnRlbnRfdHlwZSkgewoJCQkJaWYgKCRib2R5X2VuY29kaW5nIGVxICRhdXRob3JfZW5jb2RpbmcpIHsKCQkJCQkjIG9rLCB3ZSBhbHJlYWR5IGhhdmUgdGhlIHJpZ2h0IGVuY29kaW5nCgkJCQl9CgkJCQllbHNlIHsKCQkJCQkjIHVoIG9oLCB3ZSBzaG91bGQgcmUtZW5jb2RlCgkJCQl9CgkJCX0KCQkJZWxzZSB7CgkJCQkkaGFzX2NvbnRlbnRfdHlwZSA9IDE7CgkJCQlwdXNoIEB4aCwKCQkJCSAgJ01JTUUtVmVyc2lvbjogMS4wJywKCQkJCSAgIkNvbnRlbnQtVHlwZTogdGV4dC9wbGFpbjsgY2hhcnNldD0kYXV0aG9yX2VuY29kaW5nIiwKCQkJCSAgJ0NvbnRlbnQtVHJhbnNmZXItRW5jb2Rpbmc6IDhiaXQnOwoJCQl9CgkJfQoJfQoKCSRuZWVkc19jb25maXJtID0gKAoJCSRjb25maXJtIGVxICJhbHdheXMiIG9yCgkJKCRjb25maXJtID1+IC9eKD86YXV0b3xjYykkLyAmJiBAY2MpIG9yCgkJKCRjb25maXJtID1+IC9eKD86YXV0b3xjb21wb3NlKSQvICYmICRjb21wb3NlICYmICRtZXNzYWdlX251bSA9PSAxKSk7CgkkbmVlZHNfY29uZmlybSA9ICJpbmZvcm0iIGlmICgkbmVlZHNfY29uZmlybSAmJiAkY29uZmlybV91bmNvbmZpZ3VyZWQgJiYgQGNjKTsKCglAY2MgPSAoQGluaXRpYWxfY2MsIEBjYyk7CgoJbXkgJG1lc3NhZ2Vfd2FzX3NlbnQgPSBzZW5kX21lc3NhZ2UoKTsKCgkjIHNldCB1cCBmb3IgdGhlIG5leHQgbWVzc2FnZQoJaWYgKCR0aHJlYWQgJiYgJG1lc3NhZ2Vfd2FzX3NlbnQgJiYKCQkoY2hhaW5fcmVwbHlfdG8oKSB8fCAhZGVmaW5lZCAkcmVwbHlfdG8gfHwgbGVuZ3RoKCRyZXBseV90bykgPT0gMCkpIHsKCQkkcmVwbHlfdG8gPSAkbWVzc2FnZV9pZDsKCQlpZiAobGVuZ3RoICRyZWZlcmVuY2VzID4gMCkgewoJCQkkcmVmZXJlbmNlcyAuPSAiXG4gJG1lc3NhZ2VfaWQiOwoJCX0gZWxzZSB7CgkJCSRyZWZlcmVuY2VzID0gIiRtZXNzYWdlX2lkIjsKCQl9Cgl9CgkkbWVzc2FnZV9pZCA9IHVuZGVmOwp9CgpjbGVhbnVwX2NvbXBvc2VfZmlsZXMoKTsKCnN1YiBjbGVhbnVwX2NvbXBvc2VfZmlsZXMoKSB7Cgl1bmxpbmsoJGNvbXBvc2VfZmlsZW5hbWUsICRjb21wb3NlX2ZpbGVuYW1lIC4gIi5maW5hbCIpIGlmICRjb21wb3NlOwp9Cgokc210cC0+cXVpdCBpZiAkc210cDsKCnN1YiB1bmlxdWVfZW1haWxfbGlzdChAKSB7CglteSAlc2VlbjsKCW15IEBlbWFpbHM7CgoJZm9yZWFjaCBteSAkZW50cnkgKEBfKSB7CgkJaWYgKG15ICRjbGVhbiA9IGV4dHJhY3RfdmFsaWRfYWRkcmVzcygkZW50cnkpKSB7CgkJCSRzZWVueyRjbGVhbn0gfHw9IDA7CgkJCW5leHQgaWYgJHNlZW57JGNsZWFufSsrOwoJCQlwdXNoIEBlbWFpbHMsICRlbnRyeTsKCQl9IGVsc2UgewoJCQlwcmludCBTVERFUlIgIlc6IHVuYWJsZSB0byBleHRyYWN0IGEgdmFsaWQgYWRkcmVzcyIsCgkJCQkJIiBmcm9tOiAkZW50cnlcbiI7CgkJfQoJfQoJcmV0dXJuIEBlbWFpbHM7Cn0KCnN1YiB2YWxpZGF0ZV9wYXRjaCB7CglteSAkZm4gPSBzaGlmdDsKCW9wZW4obXkgJGZoLCAnPCcsICRmbikKCQlvciBkaWUgInVuYWJsZSB0byBvcGVuICRmbjogJCFcbiI7Cgl3aGlsZSAobXkgJGxpbmUgPSA8JGZoPikgewoJCWlmIChsZW5ndGgoJGxpbmUpID4gOTk4KSB7CgkJCXJldHVybiAiJC46IHBhdGNoIGNvbnRhaW5zIGEgbGluZSBsb25nZXIgdGhhbiA5OTggY2hhcmFjdGVycyI7CgkJfQoJfQoJcmV0dXJuIHVuZGVmOwp9CgpzdWIgZmlsZV9oYXNfbm9uYXNjaWkgewoJbXkgJGZuID0gc2hpZnQ7CglvcGVuKG15ICRmaCwgJzwnLCAkZm4pCgkJb3IgZGllICJ1bmFibGUgdG8gb3BlbiAkZm46ICQhXG4iOwoJd2hpbGUgKG15ICRsaW5lID0gPCRmaD4pIHsKCQlyZXR1cm4gMSBpZiAkbGluZSA9fiAvW15bOmFzY2lpOl1dLzsKCX0KCXJldHVybiAwOwp9CgpzdWIgYm9keV9vcl9zdWJqZWN0X2hhc19ub25hc2NpaSB7CglteSAkZm4gPSBzaGlmdDsKCW9wZW4obXkgJGZoLCAnPCcsICRmbikKCQlvciBkaWUgInVuYWJsZSB0byBvcGVuICRmbjogJCFcbiI7Cgl3aGlsZSAobXkgJGxpbmUgPSA8JGZoPikgewoJCWxhc3QgaWYgJGxpbmUgPX4gL14kLzsKCQlyZXR1cm4gMSBpZiAkbGluZSA9fiAvXlN1YmplY3QuKlteWzphc2NpaTpdXS87Cgl9Cgl3aGlsZSAobXkgJGxpbmUgPSA8JGZoPikgewoJCXJldHVybiAxIGlmICRsaW5lID1+IC9bXls6YXNjaWk6XV0vOwoJfQoJcmV0dXJuIDA7Cn0K",
    "text": "#!/usr/bin/perl -w\n#\n# Copyright 2002,2005 Greg Kroah-Hartman <greg@kroah.com>\n# Copyright 2005 Ryan Anderson <ryan@michonline.com>\n#\n# GPL v2 (See COPYING)\n#\n# Ported to support git \"mbox\" format files by Ryan Anderson <ryan@michonline.com>\n#\n# Sends a collection of emails to the given email addresses, disturbingly fast.\n#\n# Supports two formats:\n# 1. mbox format files (ignoring most headers and MIME formatting - this is designed for sending patches)\n# 2. The original format support by Greg's script:\n#    first line of the message is who to CC,\n#    and second line is the subject of the message.\n#\n\nuse strict;\nuse warnings;\nuse Term::ReadLine;\nuse Getopt::Long;\nuse Text::ParseWords;\nuse Data::Dumper;\nuse Term::ANSIColor;\nuse File::Temp qw/ tempdir tempfile /;\nuse Error qw(:try);\nuse Git;\n\nGetopt::Long::Configure qw/ pass_through /;\n\npackage FakeTerm;\nsub new {\n\tmy ($class, $reason) = @_;\n\treturn bless \\$reason, shift;\n}\nsub readline {\n\tmy $self = shift;\n\tdie \"Cannot use readline on FakeTerm: $$self\";\n}\npackage main;\n\n\nsub usage {\n\tprint <<EOT;\ngit send-email [options] <file | directory | rev-list options >\n\n  Composing:\n    --from                  <str>  * Email From:\n    --[no-]to               <str>  * Email To:\n    --[no-]cc               <str>  * Email Cc:\n    --[no-]bcc              <str>  * Email Bcc:\n    --subject               <str>  * Email \"Subject:\"\n    --in-reply-to           <str>  * Email \"In-Reply-To:\"\n    --annotate                     * Review each patch that will be sent in an editor.\n    --compose                      * Open an editor for introduction.\n    --8bit-encoding         <str>  * Encoding to assume 8bit mails if undeclared\n\n  Sending:\n    --envelope-sender       <str>  * Email envelope sender.\n    --smtp-server       <str:int>  * Outgoing SMTP server to use. The port\n                                     is optional. Default 'localhost'.\n    --smtp-server-port      <int>  * Outgoing SMTP server port.\n    --smtp-user             <str>  * Username for SMTP-AUTH.\n    --smtp-pass             <str>  * Password for SMTP-AUTH; not necessary.\n    --smtp-encryption       <str>  * tls or ssl; anything else disables.\n    --smtp-ssl                     * Deprecated. Use '--smtp-encryption ssl'.\n    --smtp-domain           <str>  * The domain name sent to HELO/EHLO handshake\n    --smtp-debug            <0|1>  * Disable, enable Net::SMTP debug.\n\n  Automating:\n    --identity              <str>  * Use the sendemail.<id> options.\n    --cc-cmd                <str>  * Email Cc: via `<str> \\$patch_path`\n    --suppress-cc           <str>  * author, self, sob, cc, cccmd, body, bodycc, all.\n    --[no-]signed-off-by-cc        * Send to Signed-off-by: addresses. Default on.\n    --[no-]suppress-from           * Send to self. Default off.\n    --[no-]chain-reply-to          * Chain In-Reply-To: fields. Default off.\n    --[no-]thread                  * Use In-Reply-To: field. Default on.\n\n  Administering:\n    --confirm               <str>  * Confirm recipients before sending;\n                                     auto, cc, compose, always, or never.\n    --quiet                        * Output one line of info per email.\n    --dry-run                      * Don't actually send the emails.\n    --[no-]validate                * Perform patch sanity checks. Default on.\n    --[no-]format-patch            * understand any non optional arguments as\n                                     `git format-patch` ones.\n\nEOT\n\texit(1);\n}\n\n# most mail servers generate the Date: header, but not all...\nsub format_2822_time {\n\tmy ($time) = @_;\n\tmy @localtm = localtime($time);\n\tmy @gmttm = gmtime($time);\n\tmy $localmin = $localtm[1] + $localtm[2] * 60;\n\tmy $gmtmin = $gmttm[1] + $gmttm[2] * 60;\n\tif ($localtm[0] != $gmttm[0]) {\n\t\tdie \"local zone differs from GMT by a non-minute interval\\n\";\n\t}\n\tif ((($gmttm[6] + 1) % 7) == $localtm[6]) {\n\t\t$localmin += 1440;\n\t} elsif ((($gmttm[6] - 1) % 7) == $localtm[6]) {\n\t\t$localmin -= 1440;\n\t} elsif ($gmttm[6] != $localtm[6]) {\n\t\tdie \"local time offset greater than or equal to 24 hours\\n\";\n\t}\n\tmy $offset = $localmin - $gmtmin;\n\tmy $offhour = $offset / 60;\n\tmy $offmin = abs($offset % 60);\n\tif (abs($offhour) >= 24) {\n\t\tdie (\"local time offset greater than or equal to 24 hours\\n\");\n\t}\n\n\treturn sprintf(\"%s, %2d %s %d %02d:%02d:%02d %s%02d%02d\",\n\t\t       qw(Sun Mon Tue Wed Thu Fri Sat)[$localtm[6]],\n\t\t       $localtm[3],\n\t\t       qw(Jan Feb Mar Apr May Jun\n\t\t\t  Jul Aug Sep Oct Nov Dec)[$localtm[4]],\n\t\t       $localtm[5]+1900,\n\t\t       $localtm[2],\n\t\t       $localtm[1],\n\t\t       $localtm[0],\n\t\t       ($offset >= 0) ? '+' : '-',\n\t\t       abs($offhour),\n\t\t       $offmin,\n\t\t       );\n}\n\nmy $have_email_valid = eval { require Email::Valid; 1 };\nmy $have_mail_address = eval { require Mail::Address; 1 };\nmy $smtp;\nmy $auth;\n\nsub unique_email_list(@);\nsub cleanup_compose_files();\n\n# Variables we fill in automatically, or via prompting:\nmy (@to,$no_to,@cc,$no_cc,@initial_cc,@bcclist,$no_bcc,@xh,\n\t$initial_reply_to,$initial_subject,@files,\n\t$author,$sender,$smtp_authpass,$annotate,$compose,$time);\n\nmy $envelope_sender;\n\n# Example reply to:\n#$initial_reply_to = ''; #<20050203173208.GA23964@foobar.com>';\n\nmy $repo = eval { Git->repository() };\nmy @repo = $repo ? ($repo) : ();\nmy $term = eval {\n\t$ENV{\"GIT_SEND_EMAIL_NOTTY\"}\n\t\t? new Term::ReadLine 'git-send-email', \\*STDIN, \\*STDOUT\n\t\t: new Term::ReadLine 'git-send-email';\n};\nif ($@) {\n\t$term = new FakeTerm \"$@: going non-interactive\";\n}\n\n# Behavior modification variables\nmy ($quiet, $dry_run) = (0, 0);\nmy $format_patch;\nmy $compose_filename;\n\n# Handle interactive edition of files.\nmy $multiedit;\nmy $editor;\n\nsub do_edit {\n\tif (!defined($editor)) {\n\t\t$editor = Git::command_oneline('var', 'GIT_EDITOR');\n\t}\n\tif (defined($multiedit) && !$multiedit) {\n\t\tmap {\n\t\t\tsystem('sh', '-c', $editor.' \"$@\"', $editor, $_);\n\t\t\tif (($? & 127) || ($? >> 8)) {\n\t\t\t\tdie(\"the editor exited uncleanly, aborting everything\");\n\t\t\t}\n\t\t} @_;\n\t} else {\n\t\tsystem('sh', '-c', $editor.' \"$@\"', $editor, @_);\n\t\tif (($? & 127) || ($? >> 8)) {\n\t\t\tdie(\"the editor exited uncleanly, aborting everything\");\n\t\t}\n\t}\n}\n\n# Variables with corresponding config settings\nmy ($thread, $chain_reply_to, $suppress_from, $signed_off_by_cc, $cc_cmd);\nmy ($smtp_server, $smtp_server_port, $smtp_authuser, $smtp_encryption);\nmy ($identity, $aliasfiletype, @alias_files, @smtp_host_parts, $smtp_domain);\nmy ($validate, $confirm);\nmy (@suppress_cc);\nmy ($auto_8bit_encoding);\n\nmy ($debug_net_smtp) = 0;\t\t# Net::SMTP, see send_message()\n\nmy $not_set_by_user = \"true but not set by the user\";\n\nmy %config_bool_settings = (\n    \"thread\" => [\\$thread, 1],\n    \"chainreplyto\" => [\\$chain_reply_to, $not_set_by_user],\n    \"suppressfrom\" => [\\$suppress_from, undef],\n    \"signedoffbycc\" => [\\$signed_off_by_cc, undef],\n    \"signedoffcc\" => [\\$signed_off_by_cc, undef],      # Deprecated\n    \"validate\" => [\\$validate, 1],\n);\n\nmy %config_settings = (\n    \"smtpserver\" => \\$smtp_server,\n    \"smtpserverport\" => \\$smtp_server_port,\n    \"smtpuser\" => \\$smtp_authuser,\n    \"smtppass\" => \\$smtp_authpass,\n    \"smtpdomain\" => \\$smtp_domain,\n    \"to\" => \\@to,\n    \"cc\" => \\@initial_cc,\n    \"cccmd\" => \\$cc_cmd,\n    \"aliasfiletype\" => \\$aliasfiletype,\n    \"bcc\" => \\@bcclist,\n    \"aliasesfile\" => \\@alias_files,\n    \"suppresscc\" => \\@suppress_cc,\n    \"envelopesender\" => \\$envelope_sender,\n    \"multiedit\" => \\$multiedit,\n    \"confirm\"   => \\$confirm,\n    \"from\" => \\$sender,\n    \"assume8bitencoding\" => \\$auto_8bit_encoding,\n);\n\n# Help users prepare for 1.7.0\nsub chain_reply_to {\n\tif (defined $chain_reply_to &&\n\t    $chain_reply_to eq $not_set_by_user) {\n\t\tprint STDERR\n\t\t    \"In git 1.7.0, the default has changed to --no-chain-reply-to\\n\" .\n\t\t    \"Set sendemail.chainreplyto configuration variable to true if\\n\" .\n\t\t    \"you want to keep --chain-reply-to as your default.\\n\";\n\t\t$chain_reply_to = 0;\n\t}\n\treturn $chain_reply_to;\n}\n\n# Handle Uncouth Termination\nsub signal_handler {\n\n\t# Make text normal\n\tprint color(\"reset\"), \"\\n\";\n\n\t# SMTP password masked\n\tsystem \"stty echo\";\n\n\t# tmp files from --compose\n\tif (defined $compose_filename) {\n\t\tif (-e $compose_filename) {\n\t\t\tprint \"'$compose_filename' contains an intermediate version of the email you were composing.\\n\";\n\t\t}\n\t\tif (-e ($compose_filename . \".final\")) {\n\t\t\tprint \"'$compose_filename.final' contains the composed email.\\n\"\n\t\t}\n\t}\n\n\texit;\n};\n\n$SIG{TERM} = \\&signal_handler;\n$SIG{INT}  = \\&signal_handler;\n\n# Begin by accumulating all the variables (defined above), that we will end up\n# needing, first, from the command line:\n\nmy $rc = GetOptions(\"sender|from=s\" => \\$sender,\n                    \"in-reply-to=s\" => \\$initial_reply_to,\n\t\t    \"subject=s\" => \\$initial_subject,\n\t\t    \"to=s\" => \\@to,\n\t\t    \"no-to\" => \\$no_to,\n\t\t    \"cc=s\" => \\@initial_cc,\n\t\t    \"no-cc\" => \\$no_cc,\n\t\t    \"bcc=s\" => \\@bcclist,\n\t\t    \"no-bcc\" => \\$no_bcc,\n\t\t    \"chain-reply-to!\" => \\$chain_reply_to,\n\t\t    \"smtp-server=s\" => \\$smtp_server,\n\t\t    \"smtp-server-port=s\" => \\$smtp_server_port,\n\t\t    \"smtp-user=s\" => \\$smtp_authuser,\n\t\t    \"smtp-pass:s\" => \\$smtp_authpass,\n\t\t    \"smtp-ssl\" => sub { $smtp_encryption = 'ssl' },\n\t\t    \"smtp-encryption=s\" => \\$smtp_encryption,\n\t\t    \"smtp-debug:i\" => \\$debug_net_smtp,\n\t\t    \"smtp-domain:s\" => \\$smtp_domain,\n\t\t    \"identity=s\" => \\$identity,\n\t\t    \"annotate\" => \\$annotate,\n\t\t    \"compose\" => \\$compose,\n\t\t    \"quiet\" => \\$quiet,\n\t\t    \"cc-cmd=s\" => \\$cc_cmd,\n\t\t    \"suppress-from!\" => \\$suppress_from,\n\t\t    \"suppress-cc=s\" => \\@suppress_cc,\n\t\t    \"signed-off-cc|signed-off-by-cc!\" => \\$signed_off_by_cc,\n\t\t    \"confirm=s\" => \\$confirm,\n\t\t    \"dry-run\" => \\$dry_run,\n\t\t    \"envelope-sender=s\" => \\$envelope_sender,\n\t\t    \"thread!\" => \\$thread,\n\t\t    \"validate!\" => \\$validate,\n\t\t    \"format-patch!\" => \\$format_patch,\n\t\t    \"8bit-encoding=s\" => \\$auto_8bit_encoding,\n\t );\n\nunless ($rc) {\n    usage();\n}\n\ndie \"Cannot run git format-patch from outside a repository\\n\"\n\tif $format_patch and not $repo;\n\n# Now, let's fill any that aren't set in with defaults:\n\nsub read_config {\n\tmy ($prefix) = @_;\n\n\tforeach my $setting (keys %config_bool_settings) {\n\t\tmy $target = $config_bool_settings{$setting}->[0];\n\t\t$$target = Git::config_bool(@repo, \"$prefix.$setting\") unless (defined $$target);\n\t}\n\n\tforeach my $setting (keys %config_settings) {\n\t\tmy $target = $config_settings{$setting};\n\t\tnext if $setting eq \"to\" and defined $no_to;\n\t\tnext if $setting eq \"cc\" and defined $no_cc;\n\t\tnext if $setting eq \"bcc\" and defined $no_bcc;\n\t\tif (ref($target) eq \"ARRAY\") {\n\t\t\tunless (@$target) {\n\t\t\t\tmy @values = Git::config(@repo, \"$prefix.$setting\");\n\t\t\t\t@$target = @values if (@values && defined $values[0]);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t$$target = Git::config(@repo, \"$prefix.$setting\") unless (defined $$target);\n\t\t}\n\t}\n\n\tif (!defined $smtp_encryption) {\n\t\tmy $enc = Git::config(@repo, \"$prefix.smtpencryption\");\n\t\tif (defined $enc) {\n\t\t\t$smtp_encryption = $enc;\n\t\t} elsif (Git::config_bool(@repo, \"$prefix.smtpssl\")) {\n\t\t\t$smtp_encryption = 'ssl';\n\t\t}\n\t}\n}\n\n# read configuration from [sendemail \"$identity\"], fall back on [sendemail]\n$identity = Git::config(@repo, \"sendemail.identity\") unless (defined $identity);\nread_config(\"sendemail.$identity\") if (defined $identity);\nread_config(\"sendemail\");\n\n# fall back on builtin bool defaults\nforeach my $setting (values %config_bool_settings) {\n\t${$setting->[0]} = $setting->[1] unless (defined (${$setting->[0]}));\n}\n\n# 'default' encryption is none -- this only prevents a warning\n$smtp_encryption = '' unless (defined $smtp_encryption);\n\n# Set CC suppressions\nmy(%suppress_cc);\nif (@suppress_cc) {\n\tforeach my $entry (@suppress_cc) {\n\t\tdie \"Unknown --suppress-cc field: '$entry'\\n\"\n\t\t\tunless $entry =~ /^(all|cccmd|cc|author|self|sob|body|bodycc)$/;\n\t\t$suppress_cc{$entry} = 1;\n\t}\n}\n\nif ($suppress_cc{'all'}) {\n\tforeach my $entry (qw (cccmd cc author self sob body bodycc)) {\n\t\t$suppress_cc{$entry} = 1;\n\t}\n\tdelete $suppress_cc{'all'};\n}\n\n# If explicit old-style ones are specified, they trump --suppress-cc.\n$suppress_cc{'self'} = $suppress_from if defined $suppress_from;\n$suppress_cc{'sob'} = !$signed_off_by_cc if defined $signed_off_by_cc;\n\nif ($suppress_cc{'body'}) {\n\tforeach my $entry (qw (sob bodycc)) {\n\t\t$suppress_cc{$entry} = 1;\n\t}\n\tdelete $suppress_cc{'body'};\n}\n\n# Set confirm's default value\nmy $confirm_unconfigured = !defined $confirm;\nif ($confirm_unconfigured) {\n\t$confirm = scalar %suppress_cc ? 'compose' : 'auto';\n};\ndie \"Unknown --confirm setting: '$confirm'\\n\"\n\tunless $confirm =~ /^(?:auto|cc|compose|always|never)/;\n\n# Debugging, print out the suppressions.\nif (0) {\n\tprint \"suppressions:\\n\";\n\tforeach my $entry (keys %suppress_cc) {\n\t\tprintf \"  %-5s -> $suppress_cc{$entry}\\n\", $entry;\n\t}\n}\n\nmy ($repoauthor, $repocommitter);\n($repoauthor) = Git::ident_person(@repo, 'author');\n($repocommitter) = Git::ident_person(@repo, 'committer');\n\n# Verify the user input\n\nforeach my $entry (@to) {\n\tdie \"Comma in --to entry: $entry'\\n\" unless $entry !~ m/,/;\n}\n\nforeach my $entry (@initial_cc) {\n\tdie \"Comma in --cc entry: $entry'\\n\" unless $entry !~ m/,/;\n}\n\nforeach my $entry (@bcclist) {\n\tdie \"Comma in --bcclist entry: $entry'\\n\" unless $entry !~ m/,/;\n}\n\nsub parse_address_line {\n\tif ($have_mail_address) {\n\t\treturn map { $_->format } Mail::Address->parse($_[0]);\n\t} else {\n\t\treturn split_addrs($_[0]);\n\t}\n}\n\nsub split_addrs {\n\treturn quotewords('\\s*,\\s*', 1, @_);\n}\n\nmy %aliases;\nmy %parse_alias = (\n\t# multiline formats can be supported in the future\n\tmutt => sub { my $fh = shift; while (<$fh>) {\n\t\tif (/^\\s*alias\\s+(?:-group\\s+\\S+\\s+)*(\\S+)\\s+(.*)$/) {\n\t\t\tmy ($alias, $addr) = ($1, $2);\n\t\t\t$addr =~ s/#.*$//; # mutt allows # comments\n\t\t\t # commas delimit multiple addresses\n\t\t\t$aliases{$alias} = [ split_addrs($addr) ];\n\t\t}}},\n\tmailrc => sub { my $fh = shift; while (<$fh>) {\n\t\tif (/^alias\\s+(\\S+)\\s+(.*)$/) {\n\t\t\t# spaces delimit multiple addresses\n\t\t\t$aliases{$1} = [ quotewords('\\s+', 0, $2) ];\n\t\t}}},\n\tpine => sub { my $fh = shift; my $f='\\t[^\\t]*';\n\t        for (my $x = ''; defined($x); $x = $_) {\n\t\t\tchomp $x;\n\t\t        $x .= $1 while(defined($_ = <$fh>) && /^ +(.*)$/);\n\t\t\t$x =~ /^(\\S+)$f\\t\\(?([^\\t]+?)\\)?(:?$f){0,2}$/ or next;\n\t\t\t$aliases{$1} = [ split_addrs($2) ];\n\t\t}},\n\telm => sub  { my $fh = shift;\n\t\t      while (<$fh>) {\n\t\t\t  if (/^(\\S+)\\s+=\\s+[^=]+=\\s(\\S+)/) {\n\t\t\t      my ($alias, $addr) = ($1, $2);\n\t\t\t       $aliases{$alias} = [ split_addrs($addr) ];\n\t\t\t  }\n\t\t      } },\n\n\tgnus => sub { my $fh = shift; while (<$fh>) {\n\t\tif (/\\(define-mail-alias\\s+\"(\\S+?)\"\\s+\"(\\S+?)\"\\)/) {\n\t\t\t$aliases{$1} = [ $2 ];\n\t\t}}}\n);\n\nif (@alias_files and $aliasfiletype and defined $parse_alias{$aliasfiletype}) {\n\tforeach my $file (@alias_files) {\n\t\topen my $fh, '<', $file or die \"opening $file: $!\\n\";\n\t\t$parse_alias{$aliasfiletype}->($fh);\n\t\tclose $fh;\n\t}\n}\n\n($sender) = expand_aliases($sender) if defined $sender;\n\n# returns 1 if the conflict must be solved using it as a format-patch argument\nsub check_file_rev_conflict($) {\n\treturn unless $repo;\n\tmy $f = shift;\n\ttry {\n\t\t$repo->command('rev-parse', '--verify', '--quiet', $f);\n\t\tif (defined($format_patch)) {\n\t\t\treturn $format_patch;\n\t\t}\n\t\tdie(<<EOF);\nFile '$f' exists but it could also be the range of commits\nto produce patches for.  Please disambiguate by...\n\n    * Saying \"./$f\" if you mean a file; or\n    * Giving --format-patch option if you mean a range.\nEOF\n\t} catch Git::Error::Command with {\n\t\treturn 0;\n\t}\n}\n\n# Now that all the defaults are set, process the rest of the command line\n# arguments and collect up the files that need to be processed.\nmy @rev_list_opts;\nwhile (defined(my $f = shift @ARGV)) {\n\tif ($f eq \"--\") {\n\t\tpush @rev_list_opts, \"--\", @ARGV;\n\t\t@ARGV = ();\n\t} elsif (-d $f and !check_file_rev_conflict($f)) {\n\t\topendir(DH,$f)\n\t\t\tor die \"Failed to opendir $f: $!\";\n\n\t\tpush @files, grep { -f $_ } map { +$f . \"/\" . $_ }\n\t\t\t\tsort readdir(DH);\n\t\tclosedir(DH);\n\t} elsif ((-f $f or -p $f) and !check_file_rev_conflict($f)) {\n\t\tpush @files, $f;\n\t} else {\n\t\tpush @rev_list_opts, $f;\n\t}\n}\n\nif (@rev_list_opts) {\n\tdie \"Cannot run git format-patch from outside a repository\\n\"\n\t\tunless $repo;\n\tpush @files, $repo->command('format-patch', '-o', tempdir(CLEANUP => 1), @rev_list_opts);\n}\n\nif ($validate) {\n\tforeach my $f (@files) {\n\t\tunless (-p $f) {\n\t\t\tmy $error = validate_patch($f);\n\t\t\t$error and die \"fatal: $f: $error\\nwarning: no patches were sent\\n\";\n\t\t}\n\t}\n}\n\nif (@files) {\n\tunless ($quiet) {\n\t\tprint $_,\"\\n\" for (@files);\n\t}\n} else {\n\tprint STDERR \"\\nNo patch files specified!\\n\\n\";\n\tusage();\n}\n\nsub get_patch_subject($) {\n\tmy $fn = shift;\n\topen (my $fh, '<', $fn);\n\twhile (my $line = <$fh>) {\n\t\tnext unless ($line =~ /^Subject: (.*)$/);\n\t\tclose $fh;\n\t\treturn \"GIT: $1\\n\";\n\t}\n\tclose $fh;\n\tdie \"No subject line in $fn ?\";\n}\n\nif ($compose) {\n\t# Note that this does not need to be secure, but we will make a small\n\t# effort to have it be unique\n\t$compose_filename = ($repo ?\n\t\ttempfile(\".gitsendemail.msg.XXXXXX\", DIR => $repo->repo_path()) :\n\t\ttempfile(\".gitsendemail.msg.XXXXXX\", DIR => \".\"))[1];\n\topen(C,\">\",$compose_filename)\n\t\tor die \"Failed to open for writing $compose_filename: $!\";\n\n\n\tmy $tpl_sender = $sender || $repoauthor || $repocommitter || '';\n\tmy $tpl_subject = $initial_subject || '';\n\tmy $tpl_reply_to = $initial_reply_to || '';\n\n\tprint C <<EOT;\nFrom $tpl_sender # This line is ignored.\nGIT: Lines beginning in \"GIT:\" will be removed.\nGIT: Consider including an overall diffstat or table of contents\nGIT: for the patch you are writing.\nGIT:\nGIT: Clear the body content if you don't wish to send a summary.\nFrom: $tpl_sender\nSubject: $tpl_subject\nIn-Reply-To: $tpl_reply_to\n\nEOT\n\tfor my $f (@files) {\n\t\tprint C get_patch_subject($f);\n\t}\n\tclose(C);\n\n\tif ($annotate) {\n\t\tdo_edit($compose_filename, @files);\n\t} else {\n\t\tdo_edit($compose_filename);\n\t}\n\n\topen(C2,\">\",$compose_filename . \".final\")\n\t\tor die \"Failed to open $compose_filename.final : \" . $!;\n\n\topen(C,\"<\",$compose_filename)\n\t\tor die \"Failed to open $compose_filename : \" . $!;\n\n\tmy $need_8bit_cte = file_has_nonascii($compose_filename);\n\tmy $in_body = 0;\n\tmy $summary_empty = 1;\n\twhile(<C>) {\n\t\tnext if m/^GIT:/;\n\t\tif ($in_body) {\n\t\t\t$summary_empty = 0 unless (/^\\n$/);\n\t\t} elsif (/^\\n$/) {\n\t\t\t$in_body = 1;\n\t\t\tif ($need_8bit_cte) {\n\t\t\t\tprint C2 \"MIME-Version: 1.0\\n\",\n\t\t\t\t\t \"Content-Type: text/plain; \",\n\t\t\t\t\t   \"charset=UTF-8\\n\",\n\t\t\t\t\t \"Content-Transfer-Encoding: 8bit\\n\";\n\t\t\t}\n\t\t} elsif (/^MIME-Version:/i) {\n\t\t\t$need_8bit_cte = 0;\n\t\t} elsif (/^Subject:\\s*(.+)\\s*$/i) {\n\t\t\t$initial_subject = $1;\n\t\t\tmy $subject = $initial_subject;\n\t\t\t$_ = \"Subject: \" .\n\t\t\t\t($subject =~ /[^[:ascii:]]/ ?\n\t\t\t\t quote_rfc2047($subject) :\n\t\t\t\t $subject) .\n\t\t\t\t\"\\n\";\n\t\t} elsif (/^In-Reply-To:\\s*(.+)\\s*$/i) {\n\t\t\t$initial_reply_to = $1;\n\t\t\tnext;\n\t\t} elsif (/^From:\\s*(.+)\\s*$/i) {\n\t\t\t$sender = $1;\n\t\t\tnext;\n\t\t} elsif (/^(?:To|Cc|Bcc):/i) {\n\t\t\tprint \"To/Cc/Bcc fields are not interpreted yet, they have been ignored\\n\";\n\t\t\tnext;\n\t\t}\n\t\tprint C2 $_;\n\t}\n\tclose(C);\n\tclose(C2);\n\n\tif ($summary_empty) {\n\t\tprint \"Summary email is empty, skipping it\\n\";\n\t\t$compose = -1;\n\t}\n} elsif ($annotate) {\n\tdo_edit(@files);\n}\n\nsub ask {\n\tmy ($prompt, %arg) = @_;\n\tmy $valid_re = $arg{valid_re};\n\tmy $default = $arg{default};\n\tmy $resp;\n\tmy $i = 0;\n\treturn defined $default ? $default : undef\n\t\tunless defined $term->IN and defined fileno($term->IN) and\n\t\t       defined $term->OUT and defined fileno($term->OUT);\n\twhile ($i++ < 10) {\n\t\t$resp = $term->readline($prompt);\n\t\tif (!defined $resp) { # EOF\n\t\t\tprint \"\\n\";\n\t\t\treturn defined $default ? $default : undef;\n\t\t}\n\t\tif ($resp eq '' and defined $default) {\n\t\t\treturn $default;\n\t\t}\n\t\tif (!defined $valid_re or $resp =~ /$valid_re/) {\n\t\t\treturn $resp;\n\t\t}\n\t}\n\treturn undef;\n}\n\nmy %broken_encoding;\n\nsub file_declares_8bit_cte($) {\n\tmy $fn = shift;\n\topen (my $fh, '<', $fn);\n\twhile (my $line = <$fh>) {\n\t\tlast if ($line =~ /^$/);\n\t\treturn 1 if ($line =~ /^Content-Transfer-Encoding: .*8bit.*$/);\n\t}\n\tclose $fh;\n\treturn 0;\n}\n\nforeach my $f (@files) {\n\tnext unless (body_or_subject_has_nonascii($f)\n\t\t     && !file_declares_8bit_cte($f));\n\t$broken_encoding{$f} = 1;\n}\n\nif (!defined $auto_8bit_encoding && scalar %broken_encoding) {\n\tprint \"The following files are 8bit, but do not declare \" .\n\t\t\"a Content-Transfer-Encoding.\\n\";\n\tforeach my $f (sort keys %broken_encoding) {\n\t\tprint \"    $f\\n\";\n\t}\n\t$auto_8bit_encoding = ask(\"Which 8bit encoding should I declare [UTF-8]? \",\n\t\t\t\t  default => \"UTF-8\");\n}\n\nmy $prompting = 0;\nif (!defined $sender) {\n\t$sender = $repoauthor || $repocommitter || '';\n\t$sender = ask(\"Who should the emails appear to be from? [$sender] \",\n\t              default => $sender);\n\tprint \"Emails will be sent from: \", $sender, \"\\n\";\n\t$prompting++;\n}\n\nif (!@to) {\n\tmy $to = ask(\"Who should the emails be sent to? \");\n\tpush @to, parse_address_line($to) if defined $to; # sanitized/validated later\n\t$prompting++;\n}\n\nsub expand_aliases {\n\treturn map { expand_one_alias($_) } @_;\n}\n\nmy %EXPANDED_ALIASES;\nsub expand_one_alias {\n\tmy $alias = shift;\n\tif ($EXPANDED_ALIASES{$alias}) {\n\t\tdie \"fatal: alias '$alias' expands to itself\\n\";\n\t}\n\tlocal $EXPANDED_ALIASES{$alias} = 1;\n\treturn $aliases{$alias} ? expand_aliases(@{$aliases{$alias}}) : $alias;\n}\n\n@to = expand_aliases(@to);\n@to = (map { sanitize_address($_) } @to);\n@initial_cc = expand_aliases(@initial_cc);\n@bcclist = expand_aliases(@bcclist);\n\nif ($thread && !defined $initial_reply_to && $prompting) {\n\t$initial_reply_to = ask(\n\t\t\"Message-ID to be used as In-Reply-To for the first email? \");\n}\nif (defined $initial_reply_to) {\n\t$initial_reply_to =~ s/^\\s*<?//;\n\t$initial_reply_to =~ s/>?\\s*$//;\n\t$initial_reply_to = \"<$initial_reply_to>\" if $initial_reply_to ne '';\n}\n\nif (!defined $smtp_server) {\n\tforeach (qw( /usr/sbin/sendmail /usr/lib/sendmail )) {\n\t\tif (-x $_) {\n\t\t\t$smtp_server = $_;\n\t\t\tlast;\n\t\t}\n\t}\n\t$smtp_server ||= 'localhost'; # could be 127.0.0.1, too... *shrug*\n}\n\nif ($compose && $compose > 0) {\n\t@files = ($compose_filename . \".final\", @files);\n}\n\n# Variables we set as part of the loop over files\nour ($message_id, %mail, $subject, $reply_to, $references, $message,\n\t$needs_confirm, $message_num, $ask_default);\n\nsub extract_valid_address {\n\tmy $address = shift;\n\tmy $local_part_regexp = '[^<>\"\\s@]+';\n\tmy $domain_regexp = '[^.<>\"\\s@]+(?:\\.[^.<>\"\\s@]+)+';\n\n\t# check for a local address:\n\treturn $address if ($address =~ /^($local_part_regexp)$/);\n\n\t$address =~ s/^\\s*<(.*)>\\s*$/$1/;\n\tif ($have_email_valid) {\n\t\treturn scalar Email::Valid->address($address);\n\t} else {\n\t\t# less robust/correct than the monster regexp in Email::Valid,\n\t\t# but still does a 99% job, and one less dependency\n\t\t$address =~ /($local_part_regexp\\@$domain_regexp)/;\n\t\treturn $1;\n\t}\n}\n\n# Usually don't need to change anything below here.\n\n# we make a \"fake\" message id by taking the current number\n# of seconds since the beginning of Unix time and tacking on\n# a random number to the end, in case we are called quicker than\n# 1 second since the last time we were called.\n\n# We'll setup a template for the message id, using the \"from\" address:\n\nmy ($message_id_stamp, $message_id_serial);\nsub make_message_id {\n\tmy $uniq;\n\tif (!defined $message_id_stamp) {\n\t\t$message_id_stamp = sprintf(\"%s-%s\", time, $$);\n\t\t$message_id_serial = 0;\n\t}\n\t$message_id_serial++;\n\t$uniq = \"$message_id_stamp-$message_id_serial\";\n\n\tmy $du_part;\n\tfor ($sender, $repocommitter, $repoauthor) {\n\t\t$du_part = extract_valid_address(sanitize_address($_));\n\t\tlast if (defined $du_part and $du_part ne '');\n\t}\n\tif (not defined $du_part or $du_part eq '') {\n\t\tuse Sys::Hostname qw();\n\t\t$du_part = 'user@' . Sys::Hostname::hostname();\n\t}\n\tmy $message_id_template = \"<%s-git-send-email-%s>\";\n\t$message_id = sprintf($message_id_template, $uniq, $du_part);\n\t#print \"new message id = $message_id\\n\"; # Was useful for debugging\n}\n\n\n\n$time = time - scalar $#files;\n\nsub unquote_rfc2047 {\n\tlocal ($_) = @_;\n\tmy $encoding;\n\tif (s/=\\?([^?]+)\\?q\\?(.*)\\?=/$2/g) {\n\t\t$encoding = $1;\n\t\ts/_/ /g;\n\t\ts/=([0-9A-F]{2})/chr(hex($1))/eg;\n\t}\n\treturn wantarray ? ($_, $encoding) : $_;\n}\n\nsub quote_rfc2047 {\n\tlocal $_ = shift;\n\tmy $encoding = shift || 'UTF-8';\n\ts/([^-a-zA-Z0-9!*+\\/])/sprintf(\"=%02X\", ord($1))/eg;\n\ts/(.*)/=\\?$encoding\\?q\\?$1\\?=/;\n\treturn $_;\n}\n\nsub is_rfc2047_quoted {\n\tmy $s = shift;\n\tmy $token = '[^][()<>@,;:\"\\/?.= \\000-\\037\\177-\\377]+';\n\tmy $encoded_text = '[!->@-~]+';\n\tlength($s) <= 75 &&\n\t$s =~ m/^(?:\"[[:ascii:]]*\"|=\\?$token\\?$token\\?$encoded_text\\?=)$/o;\n}\n\n# use the simplest quoting being able to handle the recipient\nsub sanitize_address {\n\tmy ($recipient) = @_;\n\tmy ($recipient_name, $recipient_addr) = ($recipient =~ /^(.*?)\\s*(<.*)/);\n\n\tif (not $recipient_name) {\n\t\treturn \"$recipient\";\n\t}\n\n\t# if recipient_name is already quoted, do nothing\n\tif (is_rfc2047_quoted($recipient_name)) {\n\t\treturn $recipient;\n\t}\n\n\t# rfc2047 is needed if a non-ascii char is included\n\tif ($recipient_name =~ /[^[:ascii:]]/) {\n\t\t$recipient_name =~ s/^\"(.*)\"$/$1/;\n\t\t$recipient_name = quote_rfc2047($recipient_name);\n\t}\n\n\t# double quotes are needed if specials or CTLs are included\n\telsif ($recipient_name =~ /[][()<>@,;:\\\\\".\\000-\\037\\177]/) {\n\t\t$recipient_name =~ s/([\"\\\\\\r])/\\\\$1/g;\n\t\t$recipient_name = \"\\\"$recipient_name\\\"\";\n\t}\n\n\treturn \"$recipient_name $recipient_addr\";\n\n}\n\n# Returns the local Fully Qualified Domain Name (FQDN) if available.\n#\n# Tightly configured MTAa require that a caller sends a real DNS\n# domain name that corresponds the IP address in the HELO/EHLO\n# handshake. This is used to verify the connection and prevent\n# spammers from trying to hide their identity. If the DNS and IP don't\n# match, the receiveing MTA may deny the connection.\n#\n# Here is a deny example of Net::SMTP with the default \"localhost.localdomain\"\n#\n# Net::SMTP=GLOB(0x267ec28)>>> EHLO localhost.localdomain\n# Net::SMTP=GLOB(0x267ec28)<<< 550 EHLO argument does not match calling host\n#\n# This maildomain*() code is based on ideas in Perl library Test::Reporter\n# /usr/share/perl5/Test/Reporter/Mail/Util.pm ==> sub _maildomain ()\n\nsub valid_fqdn {\n\tmy $domain = shift;\n\treturn !($^O eq 'darwin' && $domain =~ /\\.local$/) && $domain =~ /\\./;\n}\n\nsub maildomain_net {\n\tmy $maildomain;\n\n\tif (eval { require Net::Domain; 1 }) {\n\t\tmy $domain = Net::Domain::domainname();\n\t\t$maildomain = $domain if valid_fqdn($domain);\n\t}\n\n\treturn $maildomain;\n}\n\nsub maildomain_mta {\n\tmy $maildomain;\n\n\tif (eval { require Net::SMTP; 1 }) {\n\t\tfor my $host (qw(mailhost localhost)) {\n\t\t\tmy $smtp = Net::SMTP->new($host);\n\t\t\tif (defined $smtp) {\n\t\t\t\tmy $domain = $smtp->domain;\n\t\t\t\t$smtp->quit;\n\n\t\t\t\t$maildomain = $domain if valid_fqdn($domain);\n\n\t\t\t\tlast if $maildomain;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn $maildomain;\n}\n\nsub maildomain {\n\treturn maildomain_net() || maildomain_mta() || 'localhost.localdomain';\n}\n\n# Returns 1 if the message was sent, and 0 otherwise.\n# In actuality, the whole program dies when there\n# is an error sending a message.\n\nsub send_message {\n\tmy @recipients = unique_email_list(@to);\n\t@cc = (grep { my $cc = extract_valid_address($_);\n\t\t      not grep { $cc eq $_ } @recipients\n\t\t    }\n\t       map { sanitize_address($_) }\n\t       @cc);\n\tmy $to = join (\",\\n\\t\", @recipients);\n\t@recipients = unique_email_list(@recipients,@cc,@bcclist);\n\t@recipients = (map { extract_valid_address($_) } @recipients);\n\tmy $date = format_2822_time($time++);\n\tmy $gitversion = '@@GIT_VERSION@@';\n\tif ($gitversion =~ m/..GIT_VERSION../) {\n\t    $gitversion = Git::version();\n\t}\n\n\tmy $cc = join(\",\\n\\t\", unique_email_list(@cc));\n\tmy $ccline = \"\";\n\tif ($cc ne '') {\n\t\t$ccline = \"\\nCc: $cc\";\n\t}\n\tmy $sanitized_sender = sanitize_address($sender);\n\tmake_message_id() unless defined($message_id);\n\n\tmy $header = \"From: $sanitized_sender\nTo: $to${ccline}\nSubject: $subject\nDate: $date\nMessage-Id: $message_id\nX-Mailer: git-send-email $gitversion\n\";\n\tif ($reply_to) {\n\n\t\t$header .= \"In-Reply-To: $reply_to\\n\";\n\t\t$header .= \"References: $references\\n\";\n\t}\n\tif (@xh) {\n\t\t$header .= join(\"\\n\", @xh) . \"\\n\";\n\t}\n\n\tmy @sendmail_parameters = ('-i', @recipients);\n\tmy $raw_from = $sanitized_sender;\n\tif (defined $envelope_sender && $envelope_sender ne \"auto\") {\n\t\t$raw_from = $envelope_sender;\n\t}\n\t$raw_from = extract_valid_address($raw_from);\n\tunshift (@sendmail_parameters,\n\t\t\t'-f', $raw_from) if(defined $envelope_sender);\n\n\tif ($needs_confirm && !$dry_run) {\n\t\tprint \"\\n$header\\n\";\n\t\tif ($needs_confirm eq \"inform\") {\n\t\t\t$confirm_unconfigured = 0; # squelch this message for the rest of this run\n\t\t\t$ask_default = \"y\"; # assume yes on EOF since user hasn't explicitly asked for confirmation\n\t\t\tprint \"    The Cc list above has been expanded by additional\\n\";\n\t\t\tprint \"    addresses found in the patch commit message. By default\\n\";\n\t\t\tprint \"    send-email prompts before sending whenever this occurs.\\n\";\n\t\t\tprint \"    This behavior is controlled by the sendemail.confirm\\n\";\n\t\t\tprint \"    configuration setting.\\n\";\n\t\t\tprint \"\\n\";\n\t\t\tprint \"    For additional information, run 'git send-email --help'.\\n\";\n\t\t\tprint \"    To retain the current behavior, but squelch this message,\\n\";\n\t\t\tprint \"    run 'git config --global sendemail.confirm auto'.\\n\\n\";\n\t\t}\n\t\t$_ = ask(\"Send this email? ([y]es|[n]o|[q]uit|[a]ll): \",\n\t\t         valid_re => qr/^(?:yes|y|no|n|quit|q|all|a)/i,\n\t\t         default => $ask_default);\n\t\tdie \"Send this email reply required\" unless defined $_;\n\t\tif (/^n/i) {\n\t\t\treturn 0;\n\t\t} elsif (/^q/i) {\n\t\t\tcleanup_compose_files();\n\t\t\texit(0);\n\t\t} elsif (/^a/i) {\n\t\t\t$confirm = 'never';\n\t\t}\n\t}\n\n\tif ($dry_run) {\n\t\t# We don't want to send the email.\n\t} elsif ($smtp_server =~ m#^/#) {\n\t\tmy $pid = open my $sm, '|-';\n\t\tdefined $pid or die $!;\n\t\tif (!$pid) {\n\t\t\texec($smtp_server, @sendmail_parameters) or die $!;\n\t\t}\n\t\tprint $sm \"$header\\n$message\";\n\t\tclose $sm or die $?;\n\t} else {\n\n\t\tif (!defined $smtp_server) {\n\t\t\tdie \"The required SMTP server is not properly defined.\"\n\t\t}\n\n\t\tif ($smtp_encryption eq 'ssl') {\n\t\t\t$smtp_server_port ||= 465; # ssmtp\n\t\t\trequire Net::SMTP::SSL;\n\t\t\t$smtp_domain ||= maildomain();\n\t\t\t$smtp ||= Net::SMTP::SSL->new($smtp_server,\n\t\t\t\t\t\t      Hello => $smtp_domain,\n\t\t\t\t\t\t      Port => $smtp_server_port);\n\t\t}\n\t\telse {\n\t\t\trequire Net::SMTP;\n\t\t\t$smtp_domain ||= maildomain();\n\t\t\t$smtp ||= Net::SMTP->new((defined $smtp_server_port)\n\t\t\t\t\t\t ? \"$smtp_server:$smtp_server_port\"\n\t\t\t\t\t\t : $smtp_server,\n\t\t\t\t\t\t Hello => $smtp_domain,\n\t\t\t\t\t\t Debug => $debug_net_smtp);\n\t\t\tif ($smtp_encryption eq 'tls' && $smtp) {\n\t\t\t\trequire Net::SMTP::SSL;\n\t\t\t\t$smtp->command('STARTTLS');\n\t\t\t\t$smtp->response();\n\t\t\t\tif ($smtp->code == 220) {\n\t\t\t\t\t$smtp = Net::SMTP::SSL->start_SSL($smtp)\n\t\t\t\t\t\tor die \"STARTTLS failed! \".$smtp->message;\n\t\t\t\t\t$smtp_encryption = '';\n\t\t\t\t\t# Send EHLO again to receive fresh\n\t\t\t\t\t# supported commands\n\t\t\t\t\t$smtp->hello();\n\t\t\t\t} else {\n\t\t\t\t\tdie \"Server does not support STARTTLS! \".$smtp->message;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!$smtp) {\n\t\t\tdie \"Unable to initialize SMTP properly. Check config and use --smtp-debug. \",\n\t\t\t    \"VALUES: server=$smtp_server \",\n\t\t\t    \"encryption=$smtp_encryption \",\n\t\t\t    \"hello=$smtp_domain\",\n\t\t\t    defined $smtp_server_port ? \"port=$smtp_server_port\" : \"\";\n\t\t}\n\n\t\tif (defined $smtp_authuser) {\n\n\t\t\tif (!defined $smtp_authpass) {\n\n\t\t\t\tsystem \"stty -echo\";\n\n\t\t\t\tdo {\n\t\t\t\t\tprint \"Password: \";\n\t\t\t\t\t$_ = <STDIN>;\n\t\t\t\t\tprint \"\\n\";\n\t\t\t\t} while (!defined $_);\n\n\t\t\t\tchomp($smtp_authpass = $_);\n\n\t\t\t\tsystem \"stty echo\";\n\t\t\t}\n\n\t\t\t$auth ||= $smtp->auth( $smtp_authuser, $smtp_authpass ) or die $smtp->message;\n\t\t}\n\n\t\t$smtp->mail( $raw_from ) or die $smtp->message;\n\t\t$smtp->to( @recipients ) or die $smtp->message;\n\t\t$smtp->data or die $smtp->message;\n\t\t$smtp->datasend(\"$header\\n$message\") or die $smtp->message;\n\t\t$smtp->dataend() or die $smtp->message;\n\t\t$smtp->code =~ /250|200/ or die \"Failed to send $subject\\n\".$smtp->message;\n\t}\n\tif ($quiet) {\n\t\tprintf (($dry_run ? \"Dry-\" : \"\").\"Sent %s\\n\", $subject);\n\t} else {\n\t\tprint (($dry_run ? \"Dry-\" : \"\").\"OK. Log says:\\n\");\n\t\tif ($smtp_server !~ m#^/#) {\n\t\t\tprint \"Server: $smtp_server\\n\";\n\t\t\tprint \"MAIL FROM:<$raw_from>\\n\";\n\t\t\tforeach my $entry (@recipients) {\n\t\t\t    print \"RCPT TO:<$entry>\\n\";\n\t\t\t}\n\t\t} else {\n\t\t\tprint \"Sendmail: $smtp_server \".join(' ',@sendmail_parameters).\"\\n\";\n\t\t}\n\t\tprint $header, \"\\n\";\n\t\tif ($smtp) {\n\t\t\tprint \"Result: \", $smtp->code, ' ',\n\t\t\t\t($smtp->message =~ /\\n([^\\n]+\\n)$/s), \"\\n\";\n\t\t} else {\n\t\t\tprint \"Result: OK\\n\";\n\t\t}\n\t}\n\n\treturn 1;\n}\n\n$reply_to = $initial_reply_to;\n$references = $initial_reply_to || '';\n$subject = $initial_subject;\n$message_num = 0;\n\nforeach my $t (@files) {\n\topen(F,\"<\",$t) or die \"can't open file $t\";\n\n\tmy $author = undef;\n\tmy $author_encoding;\n\tmy $has_content_type;\n\tmy $body_encoding;\n\t@cc = ();\n\t@xh = ();\n\tmy $input_format = undef;\n\tmy @header = ();\n\t$message = \"\";\n\t$message_num++;\n\t# First unfold multiline header fields\n\twhile(<F>) {\n\t\tlast if /^\\s*$/;\n\t\tif (/^\\s+\\S/ and @header) {\n\t\t\tchomp($header[$#header]);\n\t\t\ts/^\\s+/ /;\n\t\t\t$header[$#header] .= $_;\n\t    } else {\n\t\t\tpush(@header, $_);\n\t\t}\n\t}\n\t# Now parse the header\n\tforeach(@header) {\n\t\tif (/^From /) {\n\t\t\t$input_format = 'mbox';\n\t\t\tnext;\n\t\t}\n\t\tchomp;\n\t\tif (!defined $input_format && /^[-A-Za-z]+:\\s/) {\n\t\t\t$input_format = 'mbox';\n\t\t}\n\n\t\tif (defined $input_format && $input_format eq 'mbox') {\n\t\t\tif (/^Subject:\\s+(.*)$/) {\n\t\t\t\t$subject = $1;\n\t\t\t}\n\t\t\telsif (/^From:\\s+(.*)$/) {\n\t\t\t\t($author, $author_encoding) = unquote_rfc2047($1);\n\t\t\t\tnext if $suppress_cc{'author'};\n\t\t\t\tnext if $suppress_cc{'self'} and $author eq $sender;\n\t\t\t\tprintf(\"(mbox) Adding cc: %s from line '%s'\\n\",\n\t\t\t\t\t$1, $_) unless $quiet;\n\t\t\t\tpush @cc, $1;\n\t\t\t}\n\t\t\telsif (/^Cc:\\s+(.*)$/) {\n\t\t\t\tforeach my $addr (parse_address_line($1)) {\n\t\t\t\t\tif (unquote_rfc2047($addr) eq $sender) {\n\t\t\t\t\t\tnext if ($suppress_cc{'self'});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnext if ($suppress_cc{'cc'});\n\t\t\t\t\t}\n\t\t\t\t\tprintf(\"(mbox) Adding cc: %s from line '%s'\\n\",\n\t\t\t\t\t\t$addr, $_) unless $quiet;\n\t\t\t\t\tpush @cc, $addr;\n\t\t\t\t}\n\t\t\t}\n\t\t\telsif (/^Content-type:/i) {\n\t\t\t\t$has_content_type = 1;\n\t\t\t\tif (/charset=\"?([^ \"]+)/) {\n\t\t\t\t\t$body_encoding = $1;\n\t\t\t\t}\n\t\t\t\tpush @xh, $_;\n\t\t\t}\n\t\t\telsif (/^Message-Id: (.*)/i) {\n\t\t\t\t$message_id = $1;\n\t\t\t}\n\t\t\telsif (!/^Date:\\s/ && /^[-A-Za-z]+:\\s+\\S/) {\n\t\t\t\tpush @xh, $_;\n\t\t\t}\n\n\t\t} else {\n\t\t\t# In the traditional\n\t\t\t# \"send lots of email\" format,\n\t\t\t# line 1 = cc\n\t\t\t# line 2 = subject\n\t\t\t# So let's support that, too.\n\t\t\t$input_format = 'lots';\n\t\t\tif (@cc == 0 && !$suppress_cc{'cc'}) {\n\t\t\t\tprintf(\"(non-mbox) Adding cc: %s from line '%s'\\n\",\n\t\t\t\t\t$_, $_) unless $quiet;\n\t\t\t\tpush @cc, $_;\n\t\t\t} elsif (!defined $subject) {\n\t\t\t\t$subject = $_;\n\t\t\t}\n\t\t}\n\t}\n\t# Now parse the message body\n\twhile(<F>) {\n\t\t$message .=  $_;\n\t\tif (/^(Signed-off-by|Cc): (.*)$/i) {\n\t\t\tchomp;\n\t\t\tmy ($what, $c) = ($1, $2);\n\t\t\tchomp $c;\n\t\t\tif ($c eq $sender) {\n\t\t\t\tnext if ($suppress_cc{'self'});\n\t\t\t} else {\n\t\t\t\tnext if $suppress_cc{'sob'} and $what =~ /Signed-off-by/i;\n\t\t\t\tnext if $suppress_cc{'bodycc'} and $what =~ /Cc/i;\n\t\t\t}\n\t\t\tpush @cc, $c;\n\t\t\tprintf(\"(body) Adding cc: %s from line '%s'\\n\",\n\t\t\t\t$c, $_) unless $quiet;\n\t\t}\n\t}\n\tclose F;\n\n\tif (defined $cc_cmd && !$suppress_cc{'cccmd'}) {\n\t\topen(F, \"$cc_cmd \\Q$t\\E |\")\n\t\t\tor die \"(cc-cmd) Could not execute '$cc_cmd'\";\n\t\twhile(<F>) {\n\t\t\tmy $c = $_;\n\t\t\t$c =~ s/^\\s*//g;\n\t\t\t$c =~ s/\\n$//g;\n\t\t\tnext if ($c eq $sender and $suppress_from);\n\t\t\tpush @cc, $c;\n\t\t\tprintf(\"(cc-cmd) Adding cc: %s from: '%s'\\n\",\n\t\t\t\t$c, $cc_cmd) unless $quiet;\n\t\t}\n\t\tclose F\n\t\t\tor die \"(cc-cmd) failed to close pipe to '$cc_cmd'\";\n\t}\n\n\tif ($broken_encoding{$t} && !$has_content_type) {\n\t\t$has_content_type = 1;\n\t\tpush @xh, \"MIME-Version: 1.0\",\n\t\t\t\"Content-Type: text/plain; charset=$auto_8bit_encoding\",\n\t\t\t\"Content-Transfer-Encoding: 8bit\";\n\t\t$body_encoding = $auto_8bit_encoding;\n\t}\n\n\tif ($broken_encoding{$t} && !is_rfc2047_quoted($subject)) {\n\t\t$subject = quote_rfc2047($subject, $auto_8bit_encoding);\n\t}\n\n\tif (defined $author and $author ne $sender) {\n\t\t$message = \"From: $author\\n\\n$message\";\n\t\tif (defined $author_encoding) {\n\t\t\tif ($has_content_type) {\n\t\t\t\tif ($body_encoding eq $author_encoding) {\n\t\t\t\t\t# ok, we already have the right encoding\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t# uh oh, we should re-encode\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$has_content_type = 1;\n\t\t\t\tpush @xh,\n\t\t\t\t  'MIME-Version: 1.0',\n\t\t\t\t  \"Content-Type: text/plain; charset=$author_encoding\",\n\t\t\t\t  'Content-Transfer-Encoding: 8bit';\n\t\t\t}\n\t\t}\n\t}\n\n\t$needs_confirm = (\n\t\t$confirm eq \"always\" or\n\t\t($confirm =~ /^(?:auto|cc)$/ && @cc) or\n\t\t($confirm =~ /^(?:auto|compose)$/ && $compose && $message_num == 1));\n\t$needs_confirm = \"inform\" if ($needs_confirm && $confirm_unconfigured && @cc);\n\n\t@cc = (@initial_cc, @cc);\n\n\tmy $message_was_sent = send_message();\n\n\t# set up for the next message\n\tif ($thread && $message_was_sent &&\n\t\t(chain_reply_to() || !defined $reply_to || length($reply_to) == 0)) {\n\t\t$reply_to = $message_id;\n\t\tif (length $references > 0) {\n\t\t\t$references .= \"\\n $message_id\";\n\t\t} else {\n\t\t\t$references = \"$message_id\";\n\t\t}\n\t}\n\t$message_id = undef;\n}\n\ncleanup_compose_files();\n\nsub cleanup_compose_files() {\n\tunlink($compose_filename, $compose_filename . \".final\") if $compose;\n}\n\n$smtp->quit if $smtp;\n\nsub unique_email_list(@) {\n\tmy %seen;\n\tmy @emails;\n\n\tforeach my $entry (@_) {\n\t\tif (my $clean = extract_valid_address($entry)) {\n\t\t\t$seen{$clean} ||= 0;\n\t\t\tnext if $seen{$clean}++;\n\t\t\tpush @emails, $entry;\n\t\t} else {\n\t\t\tprint STDERR \"W: unable to extract a valid address\",\n\t\t\t\t\t\" from: $entry\\n\";\n\t\t}\n\t}\n\treturn @emails;\n}\n\nsub validate_patch {\n\tmy $fn = shift;\n\topen(my $fh, '<', $fn)\n\t\tor die \"unable to open $fn: $!\\n\";\n\twhile (my $line = <$fh>) {\n\t\tif (length($line) > 998) {\n\t\t\treturn \"$.: patch contains a line longer than 998 characters\";\n\t\t}\n\t}\n\treturn undef;\n}\n\nsub file_has_nonascii {\n\tmy $fn = shift;\n\topen(my $fh, '<', $fn)\n\t\tor die \"unable to open $fn: $!\\n\";\n\twhile (my $line = <$fh>) {\n\t\treturn 1 if $line =~ /[^[:ascii:]]/;\n\t}\n\treturn 0;\n}\n\nsub body_or_subject_has_nonascii {\n\tmy $fn = shift;\n\topen(my $fh, '<', $fn)\n\t\tor die \"unable to open $fn: $!\\n\";\n\twhile (my $line = <$fh>) {\n\t\tlast if $line =~ /^$/;\n\t\treturn 1 if $line =~ /^Subject.*[^[:ascii:]]/;\n\t}\n\twhile (my $line = <$fh>) {\n\t\treturn 1 if $line =~ /[^[:ascii:]]/;\n\t}\n\treturn 0;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0063606b55e5a3757810647447b523af665eff3a",
  "sha1_ok": true,
  "size": 37998
}
