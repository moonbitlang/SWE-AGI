{
  "content": {
    "base64": "I2lmbmRlZiBUUkFOU1BPUlRfSU5URVJOQUxfSAojZGVmaW5lIFRSQU5TUE9SVF9JTlRFUk5BTF9ICgpzdHJ1Y3QgcmVmOwpzdHJ1Y3QgdHJhbnNwb3J0OwpzdHJ1Y3QgYXJndl9hcnJheTsKCnN0cnVjdCB0cmFuc3BvcnRfdnRhYmxlIHsKCS8qKgoJICogVGhpcyB0cmFuc3BvcnQgc3VwcG9ydHMgdGhlIGZldGNoKCkgZnVuY3Rpb24gYmVpbmcgY2FsbGVkCgkgKiB3aXRob3V0IGdldF9yZWZzX2xpc3QoKSBmaXJzdCBiZWluZyBjYWxsZWQuCgkgKi8KCXVuc2lnbmVkIGZldGNoX3dpdGhvdXRfbGlzdCA6IDE7CgoJLyoqCgkgKiBSZXR1cm5zIDAgaWYgc3VjY2Vzc2Z1bCwgcG9zaXRpdmUgaWYgdGhlIG9wdGlvbiBpcyBub3QKCSAqIHJlY29nbml6ZWQgb3IgaXMgaW5hcHBsaWNhYmxlLCBhbmQgbmVnYXRpdmUgaWYgdGhlIG9wdGlvbgoJICogaXMgYXBwbGljYWJsZSBidXQgdGhlIHZhbHVlIGlzIGludmFsaWQuCgkgKiovCglpbnQgKCpzZXRfb3B0aW9uKShzdHJ1Y3QgdHJhbnNwb3J0ICpjb25uZWN0aW9uLCBjb25zdCBjaGFyICpuYW1lLAoJCQkgIGNvbnN0IGNoYXIgKnZhbHVlKTsKCS8qKgoJICogUmV0dXJucyBhIGxpc3Qgb2YgdGhlIHJlbW90ZSBzaWRlJ3MgcmVmcy4gSW4gb3JkZXIgdG8gYWxsb3cKCSAqIHRoZSB0cmFuc3BvcnQgdG8gdHJ5IHRvIHNoYXJlIGNvbm5lY3Rpb25zLCBmb3JfcHVzaCBpcyBhCgkgKiBoaW50IGFzIHRvIHdoZXRoZXIgdGhlIHVsdGltYXRlIG9wZXJhdGlvbiBpcyBhIHB1c2ggb3IgYSBmZXRjaC4KCSAqCgkgKiBJZiBjb21tdW5pY2F0aW5nIHVzaW5nIHByb3RvY29sIHYyIGEgbGlzdCBvZiBwcmVmaXhlcyBjYW4gYmUKCSAqIHByb3ZpZGVkIHRvIGJlIHNlbnQgdG8gdGhlIHNlcnZlciB0byBlbmFibGUgaXQgdG8gbGltaXQgdGhlIHJlZgoJICogYWR2ZXJ0aXNlbWVudC4gIFNpbmNlIHJlZiBmaWx0ZXJpbmcgaXMgZG9uZSBvbiB0aGUgc2VydmVyJ3MgZW5kLCBhbmQKCSAqIG9ubHkgd2hlbiB1c2luZyBwcm90b2NvbCB2MiwgdGhpcyBsaXN0IHdpbGwgYmUgaWdub3JlZCB3aGVuIG5vdAoJICogdXNpbmcgcHJvdG9jb2wgdjIgbWVhbmluZyB0aGlzIGZ1bmN0aW9uIGNhbiByZXR1cm4gcmVmcyB3aGljaCBkb24ndAoJICogbWF0Y2ggdGhlIHByb3ZpZGVkIHJlZl9wcmVmaXhlcy4KCSAqCgkgKiBJZiB0aGUgdHJhbnNwb3J0IGlzIGFibGUgdG8gZGV0ZXJtaW5lIHRoZSByZW1vdGUgaGFzaCBmb3IKCSAqIHRoZSByZWYgd2l0aG91dCBhIGh1Z2UgYW1vdW50IG9mIGVmZm9ydCwgaXQgc2hvdWxkIHN0b3JlIGl0CgkgKiBpbiB0aGUgcmVmJ3Mgb2xkX3NoYTEgZmllbGQ7IG90aGVyd2lzZSBpdCBzaG91bGQgYmUgYWxsIDAuCgkgKiovCglzdHJ1Y3QgcmVmICooKmdldF9yZWZzX2xpc3QpKHN0cnVjdCB0cmFuc3BvcnQgKnRyYW5zcG9ydCwgaW50IGZvcl9wdXNoLAoJCQkJICAgICBjb25zdCBzdHJ1Y3QgYXJndl9hcnJheSAqcmVmX3ByZWZpeGVzKTsKCgkvKioKCSAqIEZldGNoIHRoZSBvYmplY3RzIGZvciB0aGUgZ2l2ZW4gcmVmcy4gTm90ZSB0aGF0IHRoaXMgZ2V0cwoJICogYW4gYXJyYXksIGFuZCBzaG91bGQgaWdub3JlIHRoZSBsaXN0IHN0cnVjdHVyZS4KCSAqCgkgKiBJZiB0aGUgdHJhbnNwb3J0IGRpZCBub3QgZ2V0IGhhc2hlcyBmb3IgcmVmcyBpbgoJICogZ2V0X3JlZnNfbGlzdCgpLCBpdCBzaG91bGQgc2V0IHRoZSBvbGRfc2hhMSBmaWVsZHMgaW4gdGhlCgkgKiBwcm92aWRlZCByZWZzIG5vdy4KCSAqKi8KCWludCAoKmZldGNoKShzdHJ1Y3QgdHJhbnNwb3J0ICp0cmFuc3BvcnQsIGludCByZWZzX25yLCBzdHJ1Y3QgcmVmICoqcmVmcyk7CgoJLyoqCgkgKiBQdXNoIHRoZSBvYmplY3RzIGFuZCByZWZzLiBTZW5kIHRoZSBuZWNlc3Nhcnkgb2JqZWN0cywgYW5kCgkgKiB0aGVuLCBmb3IgYW55IHJlZnMgd2hlcmUgcGVlcl9yZWYgaXMgc2V0IGFuZAoJICogcGVlcl9yZWYtPm5ld19vaWQgaXMgZGlmZmVyZW50IGZyb20gb2xkX29pZCwgdGVsbCB0aGUKCSAqIHJlbW90ZSBzaWRlIHRvIHVwZGF0ZSBlYWNoIHJlZiBpbiB0aGUgbGlzdCBmcm9tIG9sZF9vaWQgdG8KCSAqIHBlZXJfcmVmLT5uZXdfb2lkLgoJICoKCSAqIFdoZXJlIHBvc3NpYmxlLCBzZXQgdGhlIHN0YXR1cyBmb3IgZWFjaCByZWYgYXBwcm9wcmlhdGVseS4KCSAqCgkgKiBUaGUgdHJhbnNwb3J0IG11c3QgbW9kaWZ5IG5ld19zaGExIGluIHRoZSByZWYgdG8gdGhlIG5ldwoJICogdmFsdWUgaWYgdGhlIHJlbW90ZSBhY2NlcHRlZCB0aGUgY2hhbmdlLiBOb3RlIHRoYXQgdGhpcwoJICogY291bGQgYmUgYSBkaWZmZXJlbnQgdmFsdWUgZnJvbSBwZWVyX3JlZi0+bmV3X29pZCBpZiB0aGUKCSAqIHByb2Nlc3MgaW52b2x2ZWQgZ2VuZXJhdGluZyBuZXcgY29tbWl0cy4KCSAqKi8KCWludCAoKnB1c2hfcmVmcykoc3RydWN0IHRyYW5zcG9ydCAqdHJhbnNwb3J0LCBzdHJ1Y3QgcmVmICpyZWZzLCBpbnQgZmxhZ3MpOwoJaW50ICgqY29ubmVjdCkoc3RydWN0IHRyYW5zcG9ydCAqY29ubmVjdGlvbiwgY29uc3QgY2hhciAqbmFtZSwKCQkgICAgICAgY29uc3QgY2hhciAqZXhlY3V0YWJsZSwgaW50IGZkWzJdKTsKCgkvKiogZ2V0X3JlZnNfbGlzdCgpLCBmZXRjaCgpLCBhbmQgcHVzaF9yZWZzKCkgY2FuIGtlZXAKCSAqIHJlc291cmNlcyAoc3VjaCBhcyBhIGNvbm5lY3Rpb24pIHJlc2VydmVkIGZvciBmdXJ0aGVyCgkgKiB1c2UuIGRpc2Nvbm5lY3QoKSByZWxlYXNlcyB0aGVzZSByZXNvdXJjZXMuCgkgKiovCglpbnQgKCpkaXNjb25uZWN0KShzdHJ1Y3QgdHJhbnNwb3J0ICpjb25uZWN0aW9uKTsKfTsKCiNlbmRpZgo=",
    "text": "#ifndef TRANSPORT_INTERNAL_H\n#define TRANSPORT_INTERNAL_H\n\nstruct ref;\nstruct transport;\nstruct argv_array;\n\nstruct transport_vtable {\n\t/**\n\t * This transport supports the fetch() function being called\n\t * without get_refs_list() first being called.\n\t */\n\tunsigned fetch_without_list : 1;\n\n\t/**\n\t * Returns 0 if successful, positive if the option is not\n\t * recognized or is inapplicable, and negative if the option\n\t * is applicable but the value is invalid.\n\t **/\n\tint (*set_option)(struct transport *connection, const char *name,\n\t\t\t  const char *value);\n\t/**\n\t * Returns a list of the remote side's refs. In order to allow\n\t * the transport to try to share connections, for_push is a\n\t * hint as to whether the ultimate operation is a push or a fetch.\n\t *\n\t * If communicating using protocol v2 a list of prefixes can be\n\t * provided to be sent to the server to enable it to limit the ref\n\t * advertisement.  Since ref filtering is done on the server's end, and\n\t * only when using protocol v2, this list will be ignored when not\n\t * using protocol v2 meaning this function can return refs which don't\n\t * match the provided ref_prefixes.\n\t *\n\t * If the transport is able to determine the remote hash for\n\t * the ref without a huge amount of effort, it should store it\n\t * in the ref's old_sha1 field; otherwise it should be all 0.\n\t **/\n\tstruct ref *(*get_refs_list)(struct transport *transport, int for_push,\n\t\t\t\t     const struct argv_array *ref_prefixes);\n\n\t/**\n\t * Fetch the objects for the given refs. Note that this gets\n\t * an array, and should ignore the list structure.\n\t *\n\t * If the transport did not get hashes for refs in\n\t * get_refs_list(), it should set the old_sha1 fields in the\n\t * provided refs now.\n\t **/\n\tint (*fetch)(struct transport *transport, int refs_nr, struct ref **refs);\n\n\t/**\n\t * Push the objects and refs. Send the necessary objects, and\n\t * then, for any refs where peer_ref is set and\n\t * peer_ref->new_oid is different from old_oid, tell the\n\t * remote side to update each ref in the list from old_oid to\n\t * peer_ref->new_oid.\n\t *\n\t * Where possible, set the status for each ref appropriately.\n\t *\n\t * The transport must modify new_sha1 in the ref to the new\n\t * value if the remote accepted the change. Note that this\n\t * could be a different value from peer_ref->new_oid if the\n\t * process involved generating new commits.\n\t **/\n\tint (*push_refs)(struct transport *transport, struct ref *refs, int flags);\n\tint (*connect)(struct transport *connection, const char *name,\n\t\t       const char *executable, int fd[2]);\n\n\t/** get_refs_list(), fetch(), and push_refs() can keep\n\t * resources (such as a connection) reserved for further\n\t * use. disconnect() releases these resources.\n\t **/\n\tint (*disconnect)(struct transport *connection);\n};\n\n#endif\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "004bee5e368f24963d925af997aec051189e1acf",
  "sha1_ok": true,
  "size": 2789
}
