{
  "content": {
    "base64": "LyoKICogQ29weXJpZ2h0IChDKSAyMDA1IEp1bmlvIEMgSGFtYW5vCiAqLwojaW5jbHVkZSAiY2FjaGUuaCIKI2luY2x1ZGUgImRpZmYuaCIKI2luY2x1ZGUgImRpZmZjb3JlLmgiCiNpbmNsdWRlICJoYXNoLmgiCiNpbmNsdWRlICJwcm9ncmVzcy5oIgoKLyogVGFibGUgb2YgcmVuYW1lL2NvcHkgZGVzdGluYXRpb25zICovCgpzdGF0aWMgc3RydWN0IGRpZmZfcmVuYW1lX2RzdCB7CglzdHJ1Y3QgZGlmZl9maWxlc3BlYyAqdHdvOwoJc3RydWN0IGRpZmZfZmlsZXBhaXIgKnBhaXI7Cn0gKnJlbmFtZV9kc3Q7CnN0YXRpYyBpbnQgcmVuYW1lX2RzdF9uciwgcmVuYW1lX2RzdF9hbGxvYzsKCnN0YXRpYyBzdHJ1Y3QgZGlmZl9yZW5hbWVfZHN0ICpsb2NhdGVfcmVuYW1lX2RzdChzdHJ1Y3QgZGlmZl9maWxlc3BlYyAqdHdvLAoJCQkJCQkgaW50IGluc2VydF9vaykKewoJaW50IGZpcnN0LCBsYXN0OwoKCWZpcnN0ID0gMDsKCWxhc3QgPSByZW5hbWVfZHN0X25yOwoJd2hpbGUgKGxhc3QgPiBmaXJzdCkgewoJCWludCBuZXh0ID0gKGxhc3QgKyBmaXJzdCkgPj4gMTsKCQlzdHJ1Y3QgZGlmZl9yZW5hbWVfZHN0ICpkc3QgPSAmKHJlbmFtZV9kc3RbbmV4dF0pOwoJCWludCBjbXAgPSBzdHJjbXAodHdvLT5wYXRoLCBkc3QtPnR3by0+cGF0aCk7CgkJaWYgKCFjbXApCgkJCXJldHVybiBkc3Q7CgkJaWYgKGNtcCA8IDApIHsKCQkJbGFzdCA9IG5leHQ7CgkJCWNvbnRpbnVlOwoJCX0KCQlmaXJzdCA9IG5leHQrMTsKCX0KCS8qIG5vdCBmb3VuZCAqLwoJaWYgKCFpbnNlcnRfb2spCgkJcmV0dXJuIE5VTEw7CgkvKiBpbnNlcnQgdG8gbWFrZSBpdCBhdCAiZmlyc3QiICovCglpZiAocmVuYW1lX2RzdF9hbGxvYyA8PSByZW5hbWVfZHN0X25yKSB7CgkJcmVuYW1lX2RzdF9hbGxvYyA9IGFsbG9jX25yKHJlbmFtZV9kc3RfYWxsb2MpOwoJCXJlbmFtZV9kc3QgPSB4cmVhbGxvYyhyZW5hbWVfZHN0LAoJCQkJICAgICAgcmVuYW1lX2RzdF9hbGxvYyAqIHNpemVvZigqcmVuYW1lX2RzdCkpOwoJfQoJcmVuYW1lX2RzdF9ucisrOwoJaWYgKGZpcnN0IDwgcmVuYW1lX2RzdF9ucikKCQltZW1tb3ZlKHJlbmFtZV9kc3QgKyBmaXJzdCArIDEsIHJlbmFtZV9kc3QgKyBmaXJzdCwKCQkJKHJlbmFtZV9kc3RfbnIgLSBmaXJzdCAtIDEpICogc2l6ZW9mKCpyZW5hbWVfZHN0KSk7CglyZW5hbWVfZHN0W2ZpcnN0XS50d28gPSBhbGxvY19maWxlc3BlYyh0d28tPnBhdGgpOwoJZmlsbF9maWxlc3BlYyhyZW5hbWVfZHN0W2ZpcnN0XS50d28sIHR3by0+c2hhMSwgdHdvLT5zaGExX3ZhbGlkLCB0d28tPm1vZGUpOwoJcmVuYW1lX2RzdFtmaXJzdF0ucGFpciA9IE5VTEw7CglyZXR1cm4gJihyZW5hbWVfZHN0W2ZpcnN0XSk7Cn0KCi8qIFRhYmxlIG9mIHJlbmFtZS9jb3B5IHNyYyBmaWxlcyAqLwpzdGF0aWMgc3RydWN0IGRpZmZfcmVuYW1lX3NyYyB7CglzdHJ1Y3QgZGlmZl9maWxlcGFpciAqcDsKCXVuc2lnbmVkIHNob3J0IHNjb3JlOyAvKiB0byByZW1lbWJlciB0aGUgYnJlYWsgc2NvcmUgKi8KfSAqcmVuYW1lX3NyYzsKc3RhdGljIGludCByZW5hbWVfc3JjX25yLCByZW5hbWVfc3JjX2FsbG9jOwoKc3RhdGljIHN0cnVjdCBkaWZmX3JlbmFtZV9zcmMgKnJlZ2lzdGVyX3JlbmFtZV9zcmMoc3RydWN0IGRpZmZfZmlsZXBhaXIgKnApCnsKCWludCBmaXJzdCwgbGFzdDsKCXN0cnVjdCBkaWZmX2ZpbGVzcGVjICpvbmUgPSBwLT5vbmU7Cgl1bnNpZ25lZCBzaG9ydCBzY29yZSA9IHAtPnNjb3JlOwoKCWZpcnN0ID0gMDsKCWxhc3QgPSByZW5hbWVfc3JjX25yOwoJd2hpbGUgKGxhc3QgPiBmaXJzdCkgewoJCWludCBuZXh0ID0gKGxhc3QgKyBmaXJzdCkgPj4gMTsKCQlzdHJ1Y3QgZGlmZl9yZW5hbWVfc3JjICpzcmMgPSAmKHJlbmFtZV9zcmNbbmV4dF0pOwoJCWludCBjbXAgPSBzdHJjbXAob25lLT5wYXRoLCBzcmMtPnAtPm9uZS0+cGF0aCk7CgkJaWYgKCFjbXApCgkJCXJldHVybiBzcmM7CgkJaWYgKGNtcCA8IDApIHsKCQkJbGFzdCA9IG5leHQ7CgkJCWNvbnRpbnVlOwoJCX0KCQlmaXJzdCA9IG5leHQrMTsKCX0KCgkvKiBpbnNlcnQgdG8gbWFrZSBpdCBhdCAiZmlyc3QiICovCglpZiAocmVuYW1lX3NyY19hbGxvYyA8PSByZW5hbWVfc3JjX25yKSB7CgkJcmVuYW1lX3NyY19hbGxvYyA9IGFsbG9jX25yKHJlbmFtZV9zcmNfYWxsb2MpOwoJCXJlbmFtZV9zcmMgPSB4cmVhbGxvYyhyZW5hbWVfc3JjLAoJCQkJICAgICAgcmVuYW1lX3NyY19hbGxvYyAqIHNpemVvZigqcmVuYW1lX3NyYykpOwoJfQoJcmVuYW1lX3NyY19ucisrOwoJaWYgKGZpcnN0IDwgcmVuYW1lX3NyY19ucikKCQltZW1tb3ZlKHJlbmFtZV9zcmMgKyBmaXJzdCArIDEsIHJlbmFtZV9zcmMgKyBmaXJzdCwKCQkJKHJlbmFtZV9zcmNfbnIgLSBmaXJzdCAtIDEpICogc2l6ZW9mKCpyZW5hbWVfc3JjKSk7CglyZW5hbWVfc3JjW2ZpcnN0XS5wID0gcDsKCXJlbmFtZV9zcmNbZmlyc3RdLnNjb3JlID0gc2NvcmU7CglyZXR1cm4gJihyZW5hbWVfc3JjW2ZpcnN0XSk7Cn0KCnN0YXRpYyBpbnQgYmFzZW5hbWVfc2FtZShzdHJ1Y3QgZGlmZl9maWxlc3BlYyAqc3JjLCBzdHJ1Y3QgZGlmZl9maWxlc3BlYyAqZHN0KQp7CglpbnQgc3JjX2xlbiA9IHN0cmxlbihzcmMtPnBhdGgpLCBkc3RfbGVuID0gc3RybGVuKGRzdC0+cGF0aCk7Cgl3aGlsZSAoc3JjX2xlbiAmJiBkc3RfbGVuKSB7CgkJY2hhciBjMSA9IHNyYy0+cGF0aFstLXNyY19sZW5dOwoJCWNoYXIgYzIgPSBkc3QtPnBhdGhbLS1kc3RfbGVuXTsKCQlpZiAoYzEgIT0gYzIpCgkJCXJldHVybiAwOwoJCWlmIChjMSA9PSAnLycpCgkJCXJldHVybiAxOwoJfQoJcmV0dXJuICghc3JjX2xlbiB8fCBzcmMtPnBhdGhbc3JjX2xlbiAtIDFdID09ICcvJykgJiYKCQkoIWRzdF9sZW4gfHwgZHN0LT5wYXRoW2RzdF9sZW4gLSAxXSA9PSAnLycpOwp9CgpzdHJ1Y3QgZGlmZl9zY29yZSB7CglpbnQgc3JjOyAvKiBpbmRleCBpbiByZW5hbWVfc3JjICovCglpbnQgZHN0OyAvKiBpbmRleCBpbiByZW5hbWVfZHN0ICovCgl1bnNpZ25lZCBzaG9ydCBzY29yZTsKCXNob3J0IG5hbWVfc2NvcmU7Cn07CgpzdGF0aWMgaW50IGVzdGltYXRlX3NpbWlsYXJpdHkoc3RydWN0IGRpZmZfZmlsZXNwZWMgKnNyYywKCQkJICAgICAgIHN0cnVjdCBkaWZmX2ZpbGVzcGVjICpkc3QsCgkJCSAgICAgICBpbnQgbWluaW11bV9zY29yZSkKewoJLyogc3JjIHBvaW50cyBhdCBhIGZpbGUgdGhhdCBleGlzdGVkIGluIHRoZSBvcmlnaW5hbCB0cmVlIChvcgoJICogb3B0aW9uYWxseSBhIGZpbGUgaW4gdGhlIGRlc3RpbmF0aW9uIHRyZWUpIGFuZCBkc3QgcG9pbnRzCgkgKiBhdCBhIG5ld2x5IGNyZWF0ZWQgZmlsZS4gIFRoZXkgbWF5IGJlIHF1aXRlIHNpbWlsYXIsIGluIHdoaWNoCgkgKiBjYXNlIHdlIHdhbnQgdG8gc2F5IHNyYyBpcyByZW5hbWVkIHRvIGRzdCBvciBzcmMgaXMgY29waWVkIGludG8KCSAqIGRzdCwgYW5kIHRoZW4gc29tZSBlZGl0IGhhcyBiZWVuIGFwcGxpZWQgdG8gZHN0LgoJICoKCSAqIENvbXBhcmUgdGhlbSBhbmQgcmV0dXJuIGhvdyBzaW1pbGFyIHRoZXkgYXJlLCByZXByZXNlbnRpbmcKCSAqIHRoZSBzY29yZSBhcyBhbiBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgTUFYX1NDT1JFLgoJICoKCSAqIFdoZW4gdGhlcmUgaXMgYW4gZXhhY3QgbWF0Y2gsIGl0IGlzIGNvbnNpZGVyZWQgYSBiZXR0ZXIKCSAqIG1hdGNoIHRoYW4gYW55dGhpbmcgZWxzZTsgdGhlIGRlc3RpbmF0aW9uIGRvZXMgbm90IGV2ZW4KCSAqIGNhbGwgaW50byB0aGlzIGZ1bmN0aW9uIGluIHRoYXQgY2FzZS4KCSAqLwoJdW5zaWduZWQgbG9uZyBtYXhfc2l6ZSwgZGVsdGFfc2l6ZSwgYmFzZV9zaXplLCBzcmNfY29waWVkLCBsaXRlcmFsX2FkZGVkOwoJdW5zaWduZWQgbG9uZyBkZWx0YV9saW1pdDsKCWludCBzY29yZTsKCgkvKiBXZSBkZWFsIG9ubHkgd2l0aCByZWd1bGFyIGZpbGVzLiAgU3ltbGluayByZW5hbWVzIGFyZSBoYW5kbGVkCgkgKiBvbmx5IHdoZW4gdGhleSBhcmUgZXhhY3QgbWF0Y2hlcyAtLS0gaW4gb3RoZXIgd29yZHMsIG5vIGVkaXRzCgkgKiBhZnRlciByZW5hbWluZy4KCSAqLwoJaWYgKCFTX0lTUkVHKHNyYy0+bW9kZSkgfHwgIVNfSVNSRUcoZHN0LT5tb2RlKSkKCQlyZXR1cm4gMDsKCgkvKgoJICogTmVlZCB0byBjaGVjayB0aGF0IHNvdXJjZSBhbmQgZGVzdGluYXRpb24gc2l6ZXMgYXJlCgkgKiBmaWxsZWQgaW4gYmVmb3JlIGNvbXBhcmluZyB0aGVtLgoJICoKCSAqIElmIHdlIGFscmVhZHkgaGF2ZSAiY250X2RhdGEiIGZpbGxlZCBpbiwgd2Uga25vdyBpdCdzCgkgKiBhbGwgZ29vZCAoYXZvaWQgY2hlY2tpbmcgdGhlIHNpemUgZm9yIHplcm8sIGFzIHRoYXQKCSAqIGlzIGEgcG9zc2libGUgc2l6ZSAtIHdlIHJlYWxseSBzaG91bGQgaGF2ZSBhIGZsYWcgdG8KCSAqIHNheSB3aGV0aGVyIHRoZSBzaXplIGlzIHZhbGlkIG9yIG5vdCEpCgkgKi8KCWlmICghc3JjLT5jbnRfZGF0YSAmJiBkaWZmX3BvcHVsYXRlX2ZpbGVzcGVjKHNyYywgMSkpCgkJcmV0dXJuIDA7CglpZiAoIWRzdC0+Y250X2RhdGEgJiYgZGlmZl9wb3B1bGF0ZV9maWxlc3BlYyhkc3QsIDEpKQoJCXJldHVybiAwOwoKCW1heF9zaXplID0gKChzcmMtPnNpemUgPiBkc3QtPnNpemUpID8gc3JjLT5zaXplIDogZHN0LT5zaXplKTsKCWJhc2Vfc2l6ZSA9ICgoc3JjLT5zaXplIDwgZHN0LT5zaXplKSA/IHNyYy0+c2l6ZSA6IGRzdC0+c2l6ZSk7CglkZWx0YV9zaXplID0gbWF4X3NpemUgLSBiYXNlX3NpemU7CgoJLyogV2Ugd291bGQgbm90IGNvbnNpZGVyIGVkaXRzIHRoYXQgY2hhbmdlIHRoZSBmaWxlIHNpemUgc28KCSAqIGRyYXN0aWNhbGx5LiAgZGVsdGFfc2l6ZSBtdXN0IGJlIHNtYWxsZXIgdGhhbgoJICogKE1BWF9TQ09SRS1taW5pbXVtX3Njb3JlKS9NQVhfU0NPUkUgKiBtaW4oc3JjLT5zaXplLCBkc3QtPnNpemUpLgoJICoKCSAqIE5vdGUgdGhhdCBiYXNlX3NpemUgPT0gMCBjYXNlIGlzIGhhbmRsZWQgaGVyZSBhbHJlYWR5CgkgKiBhbmQgdGhlIGZpbmFsIHNjb3JlIGNvbXB1dGF0aW9uIGJlbG93IHdvdWxkIG5vdCBoYXZlIGEKCSAqIGRpdmlkZS1ieS16ZXJvIGlzc3VlLgoJICovCglpZiAobWF4X3NpemUgKiAoTUFYX1NDT1JFLW1pbmltdW1fc2NvcmUpIDwgZGVsdGFfc2l6ZSAqIE1BWF9TQ09SRSkKCQlyZXR1cm4gMDsKCglpZiAoIXNyYy0+Y250X2RhdGEgJiYgZGlmZl9wb3B1bGF0ZV9maWxlc3BlYyhzcmMsIDApKQoJCXJldHVybiAwOwoJaWYgKCFkc3QtPmNudF9kYXRhICYmIGRpZmZfcG9wdWxhdGVfZmlsZXNwZWMoZHN0LCAwKSkKCQlyZXR1cm4gMDsKCglkZWx0YV9saW1pdCA9ICh1bnNpZ25lZCBsb25nKQoJCShiYXNlX3NpemUgKiAoTUFYX1NDT1JFLW1pbmltdW1fc2NvcmUpIC8gTUFYX1NDT1JFKTsKCWlmIChkaWZmY29yZV9jb3VudF9jaGFuZ2VzKHNyYywgZHN0LAoJCQkJICAgJnNyYy0+Y250X2RhdGEsICZkc3QtPmNudF9kYXRhLAoJCQkJICAgZGVsdGFfbGltaXQsCgkJCQkgICAmc3JjX2NvcGllZCwgJmxpdGVyYWxfYWRkZWQpKQoJCXJldHVybiAwOwoKCS8qIEhvdyBzaW1pbGFyIGFyZSB0aGV5PwoJICogd2hhdCBwZXJjZW50YWdlIG9mIG1hdGVyaWFsIGluIGRzdCBhcmUgZnJvbSBzb3VyY2U/CgkgKi8KCWlmICghZHN0LT5zaXplKQoJCXNjb3JlID0gMDsgLyogc2hvdWxkIG5vdCBoYXBwZW4gKi8KCWVsc2UKCQlzY29yZSA9IChpbnQpKHNyY19jb3BpZWQgKiBNQVhfU0NPUkUgLyBtYXhfc2l6ZSk7CglyZXR1cm4gc2NvcmU7Cn0KCnN0YXRpYyB2b2lkIHJlY29yZF9yZW5hbWVfcGFpcihpbnQgZHN0X2luZGV4LCBpbnQgc3JjX2luZGV4LCBpbnQgc2NvcmUpCnsKCXN0cnVjdCBkaWZmX2ZpbGVzcGVjICpzcmMsICpkc3Q7CglzdHJ1Y3QgZGlmZl9maWxlcGFpciAqZHA7CgoJaWYgKHJlbmFtZV9kc3RbZHN0X2luZGV4XS5wYWlyKQoJCWRpZSgiaW50ZXJuYWwgZXJyb3I6IGRzdCBhbHJlYWR5IG1hdGNoZWQuIik7CgoJc3JjID0gcmVuYW1lX3NyY1tzcmNfaW5kZXhdLnAtPm9uZTsKCXNyYy0+cmVuYW1lX3VzZWQrKzsKCXNyYy0+Y291bnQrKzsKCglkc3QgPSByZW5hbWVfZHN0W2RzdF9pbmRleF0udHdvOwoJZHN0LT5jb3VudCsrOwoKCWRwID0gZGlmZl9xdWV1ZShOVUxMLCBzcmMsIGRzdCk7CglkcC0+cmVuYW1lZF9wYWlyID0gMTsKCWlmICghc3RyY21wKHNyYy0+cGF0aCwgZHN0LT5wYXRoKSkKCQlkcC0+c2NvcmUgPSByZW5hbWVfc3JjW3NyY19pbmRleF0uc2NvcmU7CgllbHNlCgkJZHAtPnNjb3JlID0gc2NvcmU7CglyZW5hbWVfZHN0W2RzdF9pbmRleF0ucGFpciA9IGRwOwp9CgovKgogKiBXZSBzb3J0IHRoZSByZW5hbWUgc2ltaWxhcml0eSBtYXRyaXggd2l0aCB0aGUgc2NvcmUsIGluIGRlc2NlbmRpbmcKICogb3JkZXIgKHRoZSBtb3N0IHNpbWlsYXIgZmlyc3QpLgogKi8Kc3RhdGljIGludCBzY29yZV9jb21wYXJlKGNvbnN0IHZvaWQgKmFfLCBjb25zdCB2b2lkICpiXykKewoJY29uc3Qgc3RydWN0IGRpZmZfc2NvcmUgKmEgPSBhXywgKmIgPSBiXzsKCgkvKiBzaW5rIHRoZSB1bnVzZWQgb25lcyB0byB0aGUgYm90dG9tICovCglpZiAoYS0+ZHN0IDwgMCkKCQlyZXR1cm4gKDAgPD0gYi0+ZHN0KTsKCWVsc2UgaWYgKGItPmRzdCA8IDApCgkJcmV0dXJuIC0xOwoKCWlmIChhLT5zY29yZSA9PSBiLT5zY29yZSkKCQlyZXR1cm4gYi0+bmFtZV9zY29yZSAtIGEtPm5hbWVfc2NvcmU7CgoJcmV0dXJuIGItPnNjb3JlIC0gYS0+c2NvcmU7Cn0KCnN0cnVjdCBmaWxlX3NpbWlsYXJpdHkgewoJaW50IHNyY19kc3QsIGluZGV4OwoJc3RydWN0IGRpZmZfZmlsZXNwZWMgKmZpbGVzcGVjOwoJc3RydWN0IGZpbGVfc2ltaWxhcml0eSAqbmV4dDsKfTsKCnN0YXRpYyB1bnNpZ25lZCBpbnQgaGFzaF9maWxlc3BlYyhzdHJ1Y3QgZGlmZl9maWxlc3BlYyAqZmlsZXNwZWMpCnsKCXVuc2lnbmVkIGludCBoYXNoOwoJaWYgKCFmaWxlc3BlYy0+c2hhMV92YWxpZCkgewoJCWlmIChkaWZmX3BvcHVsYXRlX2ZpbGVzcGVjKGZpbGVzcGVjLCAwKSkKCQkJcmV0dXJuIDA7CgkJaGFzaF9zaGExX2ZpbGUoZmlsZXNwZWMtPmRhdGEsIGZpbGVzcGVjLT5zaXplLCAiYmxvYiIsIGZpbGVzcGVjLT5zaGExKTsKCX0KCW1lbWNweSgmaGFzaCwgZmlsZXNwZWMtPnNoYTEsIHNpemVvZihoYXNoKSk7CglyZXR1cm4gaGFzaDsKfQoKc3RhdGljIGludCBmaW5kX2lkZW50aWNhbF9maWxlcyhzdHJ1Y3QgZmlsZV9zaW1pbGFyaXR5ICpzcmMsCgkJCQlzdHJ1Y3QgZmlsZV9zaW1pbGFyaXR5ICpkc3QsCgkJCQlzdHJ1Y3QgZGlmZl9vcHRpb25zICpvcHRpb25zKQp7CglpbnQgcmVuYW1lcyA9IDA7CgoJLyoKCSAqIFdhbGsgb3ZlciBhbGwgdGhlIGRlc3RpbmF0aW9ucyAuLi4KCSAqLwoJZG8gewoJc3RydWN0IGRpZmZfZmlsZXNwZWMgKnRhcmdldCA9IGRzdC0+ZmlsZXNwZWM7CglzdHJ1Y3QgZmlsZV9zaW1pbGFyaXR5ICpwLCAqYmVzdDsKCWludCBpID0gMTAwLCBiZXN0X3Njb3JlID0gLTE7CgoJLyoKCSAqIC4uIHRvIGZpbmQgdGhlIGJlc3Qgc291cmNlIG1hdGNoCgkgKi8KCWJlc3QgPSBOVUxMOwoJZm9yIChwID0gc3JjOyBwOyBwID0gcC0+bmV4dCkgewoJCWludCBzY29yZTsKCQlzdHJ1Y3QgZGlmZl9maWxlc3BlYyAqc291cmNlID0gcC0+ZmlsZXNwZWM7CgoJCS8qIEZhbHNlIGhhc2ggY29sbGlzaW9uPyAqLwoJCWlmIChoYXNoY21wKHNvdXJjZS0+c2hhMSwgdGFyZ2V0LT5zaGExKSkKCQkJY29udGludWU7CgkJLyogTm9uLXJlZ3VsYXIgZmlsZXM/IElmIHNvLCB0aGUgbW9kZXMgbXVzdCBtYXRjaCEgKi8KCQlpZiAoIVNfSVNSRUcoc291cmNlLT5tb2RlKSB8fCAhU19JU1JFRyh0YXJnZXQtPm1vZGUpKSB7CgkJCWlmIChzb3VyY2UtPm1vZGUgIT0gdGFyZ2V0LT5tb2RlKQoJCQkJY29udGludWU7CgkJfQoJCS8qIEdpdmUgaGlnaGVyIHNjb3JlcyB0byBzb3VyY2VzIHRoYXQgaGF2ZW4ndCBiZWVuIHVzZWQgYWxyZWFkeSAqLwoJCXNjb3JlID0gIXNvdXJjZS0+cmVuYW1lX3VzZWQ7CgkJaWYgKHNvdXJjZS0+cmVuYW1lX3VzZWQgJiYgb3B0aW9ucy0+ZGV0ZWN0X3JlbmFtZSAhPSBESUZGX0RFVEVDVF9DT1BZKQoJCQljb250aW51ZTsKCQlzY29yZSArPSBiYXNlbmFtZV9zYW1lKHNvdXJjZSwgdGFyZ2V0KTsKCQlpZiAoc2NvcmUgPiBiZXN0X3Njb3JlKSB7CgkJCWJlc3QgPSBwOwoJCQliZXN0X3Njb3JlID0gc2NvcmU7CgkJCWlmIChzY29yZSA9PSAyKQoJCQkJYnJlYWs7CgkJfQoKCQkvKiBUb28gbWFueSBpZGVudGljYWwgYWx0ZXJuYXRpdmVzPyBQaWNrIG9uZSAqLwoJCWlmICghLS1pKQoJCQlicmVhazsKCX0KCWlmIChiZXN0KSB7CgkJcmVjb3JkX3JlbmFtZV9wYWlyKGRzdC0+aW5kZXgsIGJlc3QtPmluZGV4LCBNQVhfU0NPUkUpOwoJCXJlbmFtZXMrKzsKCX0KCX0gd2hpbGUgKChkc3QgPSBkc3QtPm5leHQpICE9IE5VTEwpOwoJcmV0dXJuIHJlbmFtZXM7Cn0KCnN0YXRpYyB2b2lkIGZyZWVfc2ltaWxhcml0eV9saXN0KHN0cnVjdCBmaWxlX3NpbWlsYXJpdHkgKnApCnsKCXdoaWxlIChwKSB7CgkJc3RydWN0IGZpbGVfc2ltaWxhcml0eSAqZW50cnkgPSBwOwoJCXAgPSBwLT5uZXh0OwoJCWZyZWUoZW50cnkpOwoJfQp9CgpzdGF0aWMgaW50IGZpbmRfc2FtZV9maWxlcyh2b2lkICpwdHIsIHZvaWQgKmRhdGEpCnsKCWludCByZXQ7CglzdHJ1Y3QgZmlsZV9zaW1pbGFyaXR5ICpwID0gcHRyOwoJc3RydWN0IGZpbGVfc2ltaWxhcml0eSAqc3JjID0gTlVMTCwgKmRzdCA9IE5VTEw7CglzdHJ1Y3QgZGlmZl9vcHRpb25zICpvcHRpb25zID0gZGF0YTsKCgkvKiBTcGxpdCB0aGUgaGFzaCBsaXN0IHVwIGludG8gc291cmNlcyBhbmQgZGVzdGluYXRpb25zICovCglkbyB7CgkJc3RydWN0IGZpbGVfc2ltaWxhcml0eSAqZW50cnkgPSBwOwoJCXAgPSBwLT5uZXh0OwoJCWlmIChlbnRyeS0+c3JjX2RzdCA8IDApIHsKCQkJZW50cnktPm5leHQgPSBzcmM7CgkJCXNyYyA9IGVudHJ5OwoJCX0gZWxzZSB7CgkJCWVudHJ5LT5uZXh0ID0gZHN0OwoJCQlkc3QgPSBlbnRyeTsKCQl9Cgl9IHdoaWxlIChwKTsKCgkvKgoJICogSWYgd2UgaGF2ZSBib3RoIHNvdXJjZXMgKmFuZCogZGVzdGluYXRpb25zLCBzZWUgaWYKCSAqIHdlIGNhbiBtYXRjaCB0aGVtIHVwCgkgKi8KCXJldCA9IChzcmMgJiYgZHN0KSA/IGZpbmRfaWRlbnRpY2FsX2ZpbGVzKHNyYywgZHN0LCBvcHRpb25zKSA6IDA7CgoJLyogRnJlZSB0aGUgaGFzaGVzIGFuZCByZXR1cm4gdGhlIG51bWJlciBvZiByZW5hbWVzIGZvdW5kICovCglmcmVlX3NpbWlsYXJpdHlfbGlzdChzcmMpOwoJZnJlZV9zaW1pbGFyaXR5X2xpc3QoZHN0KTsKCXJldHVybiByZXQ7Cn0KCnN0YXRpYyB2b2lkIGluc2VydF9maWxlX3RhYmxlKHN0cnVjdCBoYXNoX3RhYmxlICp0YWJsZSwgaW50IHNyY19kc3QsIGludCBpbmRleCwgc3RydWN0IGRpZmZfZmlsZXNwZWMgKmZpbGVzcGVjKQp7Cgl2b2lkICoqcG9zOwoJdW5zaWduZWQgaW50IGhhc2g7CglzdHJ1Y3QgZmlsZV9zaW1pbGFyaXR5ICplbnRyeSA9IHhtYWxsb2Moc2l6ZW9mKCplbnRyeSkpOwoKCWVudHJ5LT5zcmNfZHN0ID0gc3JjX2RzdDsKCWVudHJ5LT5pbmRleCA9IGluZGV4OwoJZW50cnktPmZpbGVzcGVjID0gZmlsZXNwZWM7CgllbnRyeS0+bmV4dCA9IE5VTEw7CgoJaGFzaCA9IGhhc2hfZmlsZXNwZWMoZmlsZXNwZWMpOwoJcG9zID0gaW5zZXJ0X2hhc2goaGFzaCwgZW50cnksIHRhYmxlKTsKCgkvKiBXZSBhbHJlYWR5IGhhZCBhbiBlbnRyeSB0aGVyZT8gKi8KCWlmIChwb3MpIHsKCQllbnRyeS0+bmV4dCA9ICpwb3M7CgkJKnBvcyA9IGVudHJ5OwoJfQp9CgovKgogKiBGaW5kIGV4YWN0IHJlbmFtZXMgZmlyc3QuCiAqCiAqIFRoZSBmaXJzdCByb3VuZCBtYXRjaGVzIHVwIHRoZSB1cC10by1kYXRlIGVudHJpZXMsCiAqIGFuZCB0aGVuIGR1cmluZyB0aGUgc2Vjb25kIHJvdW5kIHdlIHRyeSB0byBtYXRjaAogKiBjYWNoZS1kaXJ0eSBlbnRyaWVzIGFzIHdlbGwuCiAqLwpzdGF0aWMgaW50IGZpbmRfZXhhY3RfcmVuYW1lcyhzdHJ1Y3QgZGlmZl9vcHRpb25zICpvcHRpb25zKQp7CglpbnQgaTsKCXN0cnVjdCBoYXNoX3RhYmxlIGZpbGVfdGFibGU7CgoJaW5pdF9oYXNoKCZmaWxlX3RhYmxlKTsKCXByZWFsbG9jYXRlX2hhc2goJmZpbGVfdGFibGUsIHJlbmFtZV9zcmNfbnIgKyByZW5hbWVfZHN0X25yKTsKCWZvciAoaSA9IDA7IGkgPCByZW5hbWVfc3JjX25yOyBpKyspCgkJaW5zZXJ0X2ZpbGVfdGFibGUoJmZpbGVfdGFibGUsIC0xLCBpLCByZW5hbWVfc3JjW2ldLnAtPm9uZSk7CgoJZm9yIChpID0gMDsgaSA8IHJlbmFtZV9kc3RfbnI7IGkrKykKCQlpbnNlcnRfZmlsZV90YWJsZSgmZmlsZV90YWJsZSwgMSwgaSwgcmVuYW1lX2RzdFtpXS50d28pOwoKCS8qIEZpbmQgdGhlIHJlbmFtZXMgKi8KCWkgPSBmb3JfZWFjaF9oYXNoKCZmaWxlX3RhYmxlLCBmaW5kX3NhbWVfZmlsZXMsIG9wdGlvbnMpOwoKCS8qIC4uIGFuZCBmcmVlIHRoZSBoYXNoIGRhdGEgc3RydWN0dXJlICovCglmcmVlX2hhc2goJmZpbGVfdGFibGUpOwoKCXJldHVybiBpOwp9CgojZGVmaW5lIE5VTV9DQU5ESURBVEVfUEVSX0RTVCA0CnN0YXRpYyB2b2lkIHJlY29yZF9pZl9iZXR0ZXIoc3RydWN0IGRpZmZfc2NvcmUgbVtdLCBzdHJ1Y3QgZGlmZl9zY29yZSAqbykKewoJaW50IGksIHdvcnN0OwoKCS8qIGZpbmQgdGhlIHdvcnN0IG9uZSAqLwoJd29yc3QgPSAwOwoJZm9yIChpID0gMTsgaSA8IE5VTV9DQU5ESURBVEVfUEVSX0RTVDsgaSsrKQoJCWlmIChzY29yZV9jb21wYXJlKCZtW2ldLCAmbVt3b3JzdF0pID4gMCkKCQkJd29yc3QgPSBpOwoKCS8qIGlzIGl0IGJldHRlciB0aGFuIHRoZSB3b3JzdCBvbmU/ICovCglpZiAoc2NvcmVfY29tcGFyZSgmbVt3b3JzdF0sIG8pID4gMCkKCQltW3dvcnN0XSA9ICpvOwp9CgovKgogKiBSZXR1cm5zOgogKiAwIGlmIHdlIGFyZSB1bmRlciB0aGUgbGltaXQ7CiAqIDEgaWYgd2UgbmVlZCB0byBkaXNhYmxlIGluZXhhY3QgcmVuYW1lIGRldGVjdGlvbjsKICogMiBpZiB3ZSB3b3VsZCBiZSB1bmRlciB0aGUgbGltaXQgaWYgd2Ugd2VyZSBnaXZlbiAtQyBpbnN0ZWFkIG9mIC1DIC1DLgogKi8Kc3RhdGljIGludCB0b29fbWFueV9yZW5hbWVfY2FuZGlkYXRlcyhpbnQgbnVtX2NyZWF0ZSwKCQkJCSAgICAgIHN0cnVjdCBkaWZmX29wdGlvbnMgKm9wdGlvbnMpCnsKCWludCByZW5hbWVfbGltaXQgPSBvcHRpb25zLT5yZW5hbWVfbGltaXQ7CglpbnQgbnVtX3NyYyA9IHJlbmFtZV9zcmNfbnI7CglpbnQgaTsKCglvcHRpb25zLT5uZWVkZWRfcmVuYW1lX2xpbWl0ID0gMDsKCgkvKgoJICogVGhpcyBiYXNpY2FsbHkgZG9lcyBhIHRlc3QgZm9yIHRoZSByZW5hbWUgbWF0cml4IG5vdAoJICogZ3Jvd2luZyBsYXJnZXIgdGhhbiBhICJyZW5hbWVfbGltaXQiIHNxdWFyZSBtYXRyaXgsIGllOgoJICoKCSAqICAgIG51bV9jcmVhdGUgKiBudW1fc3JjID4gcmVuYW1lX2xpbWl0ICogcmVuYW1lX2xpbWl0CgkgKgoJICogYnV0IGhhbmRsZXMgdGhlIHBvdGVudGlhbCBvdmVyZmxvdyBjYXNlIHNwZWNpYWxseSAoYW5kIHdlCgkgKiBhc3N1bWUgYXQgbGVhc3QgMzItYml0IGludGVnZXJzKQoJICovCglpZiAocmVuYW1lX2xpbWl0IDw9IDAgfHwgcmVuYW1lX2xpbWl0ID4gMzI3NjcpCgkJcmVuYW1lX2xpbWl0ID0gMzI3Njc7CglpZiAoKG51bV9jcmVhdGUgPD0gcmVuYW1lX2xpbWl0IHx8IG51bV9zcmMgPD0gcmVuYW1lX2xpbWl0KSAmJgoJICAgIChudW1fY3JlYXRlICogbnVtX3NyYyA8PSByZW5hbWVfbGltaXQgKiByZW5hbWVfbGltaXQpKQoJCXJldHVybiAwOwoKCW9wdGlvbnMtPm5lZWRlZF9yZW5hbWVfbGltaXQgPQoJCW51bV9zcmMgPiBudW1fY3JlYXRlID8gbnVtX3NyYyA6IG51bV9jcmVhdGU7CgoJLyogQXJlIHdlIHJ1bm5pbmcgdW5kZXIgLUMgLUM/ICovCglpZiAoIURJRkZfT1BUX1RTVChvcHRpb25zLCBGSU5EX0NPUElFU19IQVJERVIpKQoJCXJldHVybiAxOwoKCS8qIFdvdWxkIHdlIGJ1c3QgdGhlIGxpbWl0IGlmIHdlIHdlcmUgcnVubmluZyB1bmRlciAtQz8gKi8KCWZvciAobnVtX3NyYyA9IGkgPSAwOyBpIDwgcmVuYW1lX3NyY19ucjsgaSsrKSB7CgkJaWYgKGRpZmZfdW5tb2RpZmllZF9wYWlyKHJlbmFtZV9zcmNbaV0ucCkpCgkJCWNvbnRpbnVlOwoJCW51bV9zcmMrKzsKCX0KCWlmICgobnVtX2NyZWF0ZSA8PSByZW5hbWVfbGltaXQgfHwgbnVtX3NyYyA8PSByZW5hbWVfbGltaXQpICYmCgkgICAgKG51bV9jcmVhdGUgKiBudW1fc3JjIDw9IHJlbmFtZV9saW1pdCAqIHJlbmFtZV9saW1pdCkpCgkJcmV0dXJuIDI7CglyZXR1cm4gMTsKfQoKc3RhdGljIGludCBmaW5kX3JlbmFtZXMoc3RydWN0IGRpZmZfc2NvcmUgKm14LCBpbnQgZHN0X2NudCwgaW50IG1pbmltdW1fc2NvcmUsIGludCBjb3BpZXMpCnsKCWludCBjb3VudCA9IDAsIGk7CgoJZm9yIChpID0gMDsgaSA8IGRzdF9jbnQgKiBOVU1fQ0FORElEQVRFX1BFUl9EU1Q7IGkrKykgewoJCXN0cnVjdCBkaWZmX3JlbmFtZV9kc3QgKmRzdDsKCgkJaWYgKChteFtpXS5kc3QgPCAwKSB8fAoJCSAgICAobXhbaV0uc2NvcmUgPCBtaW5pbXVtX3Njb3JlKSkKCQkJYnJlYWs7IC8qIHRoZXJlIGlzIG5vIG1vcmUgdXNhYmxlIHBhaXIuICovCgkJZHN0ID0gJnJlbmFtZV9kc3RbbXhbaV0uZHN0XTsKCQlpZiAoZHN0LT5wYWlyKQoJCQljb250aW51ZTsgLyogYWxyZWFkeSBkb25lLCBlaXRoZXIgZXhhY3Qgb3IgZnV6enkuICovCgkJaWYgKCFjb3BpZXMgJiYgcmVuYW1lX3NyY1tteFtpXS5zcmNdLnAtPm9uZS0+cmVuYW1lX3VzZWQpCgkJCWNvbnRpbnVlOwoJCXJlY29yZF9yZW5hbWVfcGFpcihteFtpXS5kc3QsIG14W2ldLnNyYywgbXhbaV0uc2NvcmUpOwoJCWNvdW50Kys7Cgl9CglyZXR1cm4gY291bnQ7Cn0KCnZvaWQgZGlmZmNvcmVfcmVuYW1lKHN0cnVjdCBkaWZmX29wdGlvbnMgKm9wdGlvbnMpCnsKCWludCBkZXRlY3RfcmVuYW1lID0gb3B0aW9ucy0+ZGV0ZWN0X3JlbmFtZTsKCWludCBtaW5pbXVtX3Njb3JlID0gb3B0aW9ucy0+cmVuYW1lX3Njb3JlOwoJc3RydWN0IGRpZmZfcXVldWVfc3RydWN0ICpxID0gJmRpZmZfcXVldWVkX2RpZmY7CglzdHJ1Y3QgZGlmZl9xdWV1ZV9zdHJ1Y3Qgb3V0cTsKCXN0cnVjdCBkaWZmX3Njb3JlICpteDsKCWludCBpLCBqLCByZW5hbWVfY291bnQsIHNraXBfdW5tb2RpZmllZCA9IDA7CglpbnQgbnVtX2NyZWF0ZSwgZHN0X2NudDsKCXN0cnVjdCBwcm9ncmVzcyAqcHJvZ3Jlc3MgPSBOVUxMOwoKCWlmICghbWluaW11bV9zY29yZSkKCQltaW5pbXVtX3Njb3JlID0gREVGQVVMVF9SRU5BTUVfU0NPUkU7CgoJZm9yIChpID0gMDsgaSA8IHEtPm5yOyBpKyspIHsKCQlzdHJ1Y3QgZGlmZl9maWxlcGFpciAqcCA9IHEtPnF1ZXVlW2ldOwoJCWlmICghRElGRl9GSUxFX1ZBTElEKHAtPm9uZSkpIHsKCQkJaWYgKCFESUZGX0ZJTEVfVkFMSUQocC0+dHdvKSkKCQkJCWNvbnRpbnVlOyAvKiB1bm1lcmdlZCAqLwoJCQllbHNlIGlmIChvcHRpb25zLT5zaW5nbGVfZm9sbG93ICYmCgkJCQkgc3RyY21wKG9wdGlvbnMtPnNpbmdsZV9mb2xsb3csIHAtPnR3by0+cGF0aCkpCgkJCQljb250aW51ZTsgLyogbm90IGludGVyZXN0ZWQgKi8KCQkJZWxzZSBpZiAoIURJRkZfT1BUX1RTVChvcHRpb25zLCBSRU5BTUVfRU1QVFkpICYmCgkJCQkgaXNfZW1wdHlfYmxvYl9zaGExKHAtPnR3by0+c2hhMSkpCgkJCQljb250aW51ZTsKCQkJZWxzZQoJCQkJbG9jYXRlX3JlbmFtZV9kc3QocC0+dHdvLCAxKTsKCQl9CgkJZWxzZSBpZiAoIURJRkZfT1BUX1RTVChvcHRpb25zLCBSRU5BTUVfRU1QVFkpICYmCgkJCSBpc19lbXB0eV9ibG9iX3NoYTEocC0+b25lLT5zaGExKSkKCQkJY29udGludWU7CgkJZWxzZSBpZiAoIURJRkZfUEFJUl9VTk1FUkdFRChwKSAmJiAhRElGRl9GSUxFX1ZBTElEKHAtPnR3bykpIHsKCQkJLyoKCQkJICogSWYgdGhlIHNvdXJjZSBpcyBhIGJyb2tlbiAiZGVsZXRlIiwgYW5kCgkJCSAqIHRoZXkgZGlkIG5vdCByZWFsbHkgd2FudCB0byBnZXQgYnJva2VuLAoJCQkgKiB0aGF0IG1lYW5zIHRoZSBzb3VyY2UgYWN0dWFsbHkgc3RheXMuCgkJCSAqIFNvIHdlIGluY3JlbWVudCB0aGUgInJlbmFtZV91c2VkIiBzY29yZQoJCQkgKiBieSBvbmUsIHRvIGluZGljYXRlIG91cnNlbHZlcyBhcyBhIHVzZXIKCQkJICovCgkJCWlmIChwLT5icm9rZW5fcGFpciAmJiAhcC0+c2NvcmUpCgkJCQlwLT5vbmUtPnJlbmFtZV91c2VkKys7CgkJCXJlZ2lzdGVyX3JlbmFtZV9zcmMocCk7CgkJfQoJCWVsc2UgaWYgKGRldGVjdF9yZW5hbWUgPT0gRElGRl9ERVRFQ1RfQ09QWSkgewoJCQkvKgoJCQkgKiBJbmNyZW1lbnQgdGhlICJyZW5hbWVfdXNlZCIgc2NvcmUgYnkKCQkJICogb25lLCB0byBpbmRpY2F0ZSBvdXJzZWx2ZXMgYXMgYSB1c2VyLgoJCQkgKi8KCQkJcC0+b25lLT5yZW5hbWVfdXNlZCsrOwoJCQlyZWdpc3Rlcl9yZW5hbWVfc3JjKHApOwoJCX0KCX0KCWlmIChyZW5hbWVfZHN0X25yID09IDAgfHwgcmVuYW1lX3NyY19uciA9PSAwKQoJCWdvdG8gY2xlYW51cDsgLyogbm90aGluZyB0byBkbyAqLwoKCS8qCgkgKiBXZSByZWFsbHkgd2FudCB0byBjdWxsIHRoZSBjYW5kaWRhdGVzIGxpc3QgZWFybHkKCSAqIHdpdGggY2hlYXAgdGVzdHMgaW4gb3JkZXIgdG8gYXZvaWQgZG9pbmcgZGVsdGFzLgoJICovCglyZW5hbWVfY291bnQgPSBmaW5kX2V4YWN0X3JlbmFtZXMob3B0aW9ucyk7CgoJLyogRGlkIHdlIG9ubHkgd2FudCBleGFjdCByZW5hbWVzPyAqLwoJaWYgKG1pbmltdW1fc2NvcmUgPT0gTUFYX1NDT1JFKQoJCWdvdG8gY2xlYW51cDsKCgkvKgoJICogQ2FsY3VsYXRlIGhvdyBtYW55IHJlbmFtZXMgYXJlIGxlZnQgKGJ1dCBhbGwgdGhlIHNvdXJjZQoJICogZmlsZXMgc3RpbGwgcmVtYWluIGFzIG9wdGlvbnMgZm9yIHJlbmFtZS9jb3BpZXMhKQoJICovCgludW1fY3JlYXRlID0gKHJlbmFtZV9kc3RfbnIgLSByZW5hbWVfY291bnQpOwoKCS8qIEFsbCBkb25lPyAqLwoJaWYgKCFudW1fY3JlYXRlKQoJCWdvdG8gY2xlYW51cDsKCglzd2l0Y2ggKHRvb19tYW55X3JlbmFtZV9jYW5kaWRhdGVzKG51bV9jcmVhdGUsIG9wdGlvbnMpKSB7CgljYXNlIDE6CgkJZ290byBjbGVhbnVwOwoJY2FzZSAyOgoJCW9wdGlvbnMtPmRlZ3JhZGVkX2NjX3RvX2MgPSAxOwoJCXNraXBfdW5tb2RpZmllZCA9IDE7CgkJYnJlYWs7CglkZWZhdWx0OgoJCWJyZWFrOwoJfQoKCWlmIChvcHRpb25zLT5zaG93X3JlbmFtZV9wcm9ncmVzcykgewoJCXByb2dyZXNzID0gc3RhcnRfcHJvZ3Jlc3NfZGVsYXkoCgkJCQkiUGVyZm9ybWluZyBpbmV4YWN0IHJlbmFtZSBkZXRlY3Rpb24iLAoJCQkJcmVuYW1lX2RzdF9uciAqIHJlbmFtZV9zcmNfbnIsIDUwLCAxKTsKCX0KCglteCA9IHhjYWxsb2MobnVtX2NyZWF0ZSAqIE5VTV9DQU5ESURBVEVfUEVSX0RTVCwgc2l6ZW9mKCpteCkpOwoJZm9yIChkc3RfY250ID0gaSA9IDA7IGkgPCByZW5hbWVfZHN0X25yOyBpKyspIHsKCQlzdHJ1Y3QgZGlmZl9maWxlc3BlYyAqdHdvID0gcmVuYW1lX2RzdFtpXS50d287CgkJc3RydWN0IGRpZmZfc2NvcmUgKm07CgoJCWlmIChyZW5hbWVfZHN0W2ldLnBhaXIpCgkJCWNvbnRpbnVlOyAvKiBkZWFsdCB3aXRoIGV4YWN0IG1hdGNoIGFscmVhZHkuICovCgoJCW0gPSAmbXhbZHN0X2NudCAqIE5VTV9DQU5ESURBVEVfUEVSX0RTVF07CgkJZm9yIChqID0gMDsgaiA8IE5VTV9DQU5ESURBVEVfUEVSX0RTVDsgaisrKQoJCQltW2pdLmRzdCA9IC0xOwoKCQlmb3IgKGogPSAwOyBqIDwgcmVuYW1lX3NyY19ucjsgaisrKSB7CgkJCXN0cnVjdCBkaWZmX2ZpbGVzcGVjICpvbmUgPSByZW5hbWVfc3JjW2pdLnAtPm9uZTsKCQkJc3RydWN0IGRpZmZfc2NvcmUgdGhpc19zcmM7CgoJCQlpZiAoc2tpcF91bm1vZGlmaWVkICYmCgkJCSAgICBkaWZmX3VubW9kaWZpZWRfcGFpcihyZW5hbWVfc3JjW2pdLnApKQoJCQkJY29udGludWU7CgoJCQl0aGlzX3NyYy5zY29yZSA9IGVzdGltYXRlX3NpbWlsYXJpdHkob25lLCB0d28sCgkJCQkJCQkgICAgIG1pbmltdW1fc2NvcmUpOwoJCQl0aGlzX3NyYy5uYW1lX3Njb3JlID0gYmFzZW5hbWVfc2FtZShvbmUsIHR3byk7CgkJCXRoaXNfc3JjLmRzdCA9IGk7CgkJCXRoaXNfc3JjLnNyYyA9IGo7CgkJCXJlY29yZF9pZl9iZXR0ZXIobSwgJnRoaXNfc3JjKTsKCQkJLyoKCQkJICogT25jZSB3ZSBydW4gZXN0aW1hdGVfc2ltaWxhcml0eSwKCQkJICogV2UgZG8gbm90IG5lZWQgdGhlIHRleHQgYW55bW9yZS4KCQkJICovCgkJCWRpZmZfZnJlZV9maWxlc3BlY19ibG9iKG9uZSk7CgkJCWRpZmZfZnJlZV9maWxlc3BlY19ibG9iKHR3byk7CgkJfQoJCWRzdF9jbnQrKzsKCQlkaXNwbGF5X3Byb2dyZXNzKHByb2dyZXNzLCAoaSsxKSpyZW5hbWVfc3JjX25yKTsKCX0KCXN0b3BfcHJvZ3Jlc3MoJnByb2dyZXNzKTsKCgkvKiBjb3N0IG1hdHJpeCBzb3J0ZWQgYnkgbW9zdCB0byBsZWFzdCBzaW1pbGFyIHBhaXIgKi8KCXFzb3J0KG14LCBkc3RfY250ICogTlVNX0NBTkRJREFURV9QRVJfRFNULCBzaXplb2YoKm14KSwgc2NvcmVfY29tcGFyZSk7CgoJcmVuYW1lX2NvdW50ICs9IGZpbmRfcmVuYW1lcyhteCwgZHN0X2NudCwgbWluaW11bV9zY29yZSwgMCk7CglpZiAoZGV0ZWN0X3JlbmFtZSA9PSBESUZGX0RFVEVDVF9DT1BZKQoJCXJlbmFtZV9jb3VudCArPSBmaW5kX3JlbmFtZXMobXgsIGRzdF9jbnQsIG1pbmltdW1fc2NvcmUsIDEpOwoJZnJlZShteCk7CgogY2xlYW51cDoKCS8qIEF0IHRoaXMgcG9pbnQsIHdlIGhhdmUgZm91bmQgc29tZSByZW5hbWVzIGFuZCBjb3BpZXMgYW5kIHRoZXkKCSAqIGFyZSByZWNvcmRlZCBpbiByZW5hbWVfZHN0LiAgVGhlIG9yaWdpbmFsIGxpc3QgaXMgc3RpbGwgaW4gKnEuCgkgKi8KCURJRkZfUVVFVUVfQ0xFQVIoJm91dHEpOwoJZm9yIChpID0gMDsgaSA8IHEtPm5yOyBpKyspIHsKCQlzdHJ1Y3QgZGlmZl9maWxlcGFpciAqcCA9IHEtPnF1ZXVlW2ldOwoJCXN0cnVjdCBkaWZmX2ZpbGVwYWlyICpwYWlyX3RvX2ZyZWUgPSBOVUxMOwoKCQlpZiAoRElGRl9QQUlSX1VOTUVSR0VEKHApKSB7CgkJCWRpZmZfcSgmb3V0cSwgcCk7CgkJfQoJCWVsc2UgaWYgKCFESUZGX0ZJTEVfVkFMSUQocC0+b25lKSAmJiBESUZGX0ZJTEVfVkFMSUQocC0+dHdvKSkgewoJCQkvKgoJCQkgKiBDcmVhdGlvbgoJCQkgKgoJCQkgKiBXZSB3b3VsZCBvdXRwdXQgdGhpcyBjcmVhdGUgcmVjb3JkIGlmIGl0IGhhcwoJCQkgKiBub3QgYmVlbiB0dXJuZWQgaW50byBhIHJlbmFtZS9jb3B5IGFscmVhZHkuCgkJCSAqLwoJCQlzdHJ1Y3QgZGlmZl9yZW5hbWVfZHN0ICpkc3QgPQoJCQkJbG9jYXRlX3JlbmFtZV9kc3QocC0+dHdvLCAwKTsKCQkJaWYgKGRzdCAmJiBkc3QtPnBhaXIpIHsKCQkJCWRpZmZfcSgmb3V0cSwgZHN0LT5wYWlyKTsKCQkJCXBhaXJfdG9fZnJlZSA9IHA7CgkJCX0KCQkJZWxzZQoJCQkJLyogbm8gbWF0Y2hpbmcgcmVuYW1lL2NvcHkgc291cmNlLCBzbwoJCQkJICogcmVjb3JkIHRoaXMgYXMgYSBjcmVhdGlvbi4KCQkJCSAqLwoJCQkJZGlmZl9xKCZvdXRxLCBwKTsKCQl9CgkJZWxzZSBpZiAoRElGRl9GSUxFX1ZBTElEKHAtPm9uZSkgJiYgIURJRkZfRklMRV9WQUxJRChwLT50d28pKSB7CgkJCS8qCgkJCSAqIERlbGV0aW9uCgkJCSAqCgkJCSAqIFdlIHdvdWxkIG91dHB1dCB0aGlzIGRlbGV0ZSByZWNvcmQgaWY6CgkJCSAqCgkJCSAqICgxKSB0aGlzIGlzIGEgYnJva2VuIGRlbGV0ZSBhbmQgdGhlIGNvdW50ZXJwYXJ0CgkJCSAqICAgICBicm9rZW4gY3JlYXRlIHJlbWFpbnMgaW4gdGhlIG91dHB1dDsgb3IKCQkJICogKDIpIHRoaXMgaXMgbm90IGEgYnJva2VuIGRlbGV0ZSwgYW5kIHJlbmFtZV9kc3QKCQkJICogICAgIGRvZXMgbm90IGhhdmUgYSByZW5hbWUvY29weSB0byBtb3ZlIHAtPm9uZS0+cGF0aAoJCQkgKiAgICAgb3V0IG9mIGV4aXN0ZW5jZS4KCQkJICoKCQkJICogT3RoZXJ3aXNlLCB0aGUgY291bnRlcnBhcnQgYnJva2VuIGNyZWF0ZQoJCQkgKiBoYXMgYmVlbiB0dXJuZWQgaW50byBhIHJlbmFtZS1lZGl0OyBvcgoJCQkgKiBkZWxldGUgZGlkIG5vdCBoYXZlIGEgbWF0Y2hpbmcgY3JlYXRlIHRvCgkJCSAqIGJlZ2luIHdpdGguCgkJCSAqLwoJCQlpZiAoRElGRl9QQUlSX0JST0tFTihwKSkgewoJCQkJLyogYnJva2VuIGRlbGV0ZSAqLwoJCQkJc3RydWN0IGRpZmZfcmVuYW1lX2RzdCAqZHN0ID0KCQkJCQlsb2NhdGVfcmVuYW1lX2RzdChwLT5vbmUsIDApOwoJCQkJaWYgKGRzdCAmJiBkc3QtPnBhaXIpCgkJCQkJLyogY291bnRlcnBhcnQgaXMgbm93IHJlbmFtZS9jb3B5ICovCgkJCQkJcGFpcl90b19mcmVlID0gcDsKCQkJfQoJCQllbHNlIHsKCQkJCWlmIChwLT5vbmUtPnJlbmFtZV91c2VkKQoJCQkJCS8qIHRoaXMgcGF0aCByZW1haW5zICovCgkJCQkJcGFpcl90b19mcmVlID0gcDsKCQkJfQoKCQkJaWYgKHBhaXJfdG9fZnJlZSkKCQkJCTsKCQkJZWxzZQoJCQkJZGlmZl9xKCZvdXRxLCBwKTsKCQl9CgkJZWxzZSBpZiAoIWRpZmZfdW5tb2RpZmllZF9wYWlyKHApKQoJCQkvKiBhbGwgdGhlIHVzdWFsIG9uZXMgbmVlZCB0byBiZSBrZXB0ICovCgkJCWRpZmZfcSgmb3V0cSwgcCk7CgkJZWxzZQoJCQkvKiBubyBuZWVkIHRvIGtlZXAgdW5tb2RpZmllZCBwYWlycyAqLwoJCQlwYWlyX3RvX2ZyZWUgPSBwOwoKCQlpZiAocGFpcl90b19mcmVlKQoJCQlkaWZmX2ZyZWVfZmlsZXBhaXIocGFpcl90b19mcmVlKTsKCX0KCWRpZmZfZGVidWdfcXVldWUoImRvbmUgY29weWluZyBvcmlnaW5hbCIsICZvdXRxKTsKCglmcmVlKHEtPnF1ZXVlKTsKCSpxID0gb3V0cTsKCWRpZmZfZGVidWdfcXVldWUoImRvbmUgY29sbGFwc2luZyIsIHEpOwoKCWZvciAoaSA9IDA7IGkgPCByZW5hbWVfZHN0X25yOyBpKyspCgkJZnJlZV9maWxlc3BlYyhyZW5hbWVfZHN0W2ldLnR3byk7CgoJZnJlZShyZW5hbWVfZHN0KTsKCXJlbmFtZV9kc3QgPSBOVUxMOwoJcmVuYW1lX2RzdF9uciA9IHJlbmFtZV9kc3RfYWxsb2MgPSAwOwoJZnJlZShyZW5hbWVfc3JjKTsKCXJlbmFtZV9zcmMgPSBOVUxMOwoJcmVuYW1lX3NyY19uciA9IHJlbmFtZV9zcmNfYWxsb2MgPSAwOwoJcmV0dXJuOwp9Cg==",
    "text": "/*\n * Copyright (C) 2005 Junio C Hamano\n */\n#include \"cache.h\"\n#include \"diff.h\"\n#include \"diffcore.h\"\n#include \"hash.h\"\n#include \"progress.h\"\n\n/* Table of rename/copy destinations */\n\nstatic struct diff_rename_dst {\n\tstruct diff_filespec *two;\n\tstruct diff_filepair *pair;\n} *rename_dst;\nstatic int rename_dst_nr, rename_dst_alloc;\n\nstatic struct diff_rename_dst *locate_rename_dst(struct diff_filespec *two,\n\t\t\t\t\t\t int insert_ok)\n{\n\tint first, last;\n\n\tfirst = 0;\n\tlast = rename_dst_nr;\n\twhile (last > first) {\n\t\tint next = (last + first) >> 1;\n\t\tstruct diff_rename_dst *dst = &(rename_dst[next]);\n\t\tint cmp = strcmp(two->path, dst->two->path);\n\t\tif (!cmp)\n\t\t\treturn dst;\n\t\tif (cmp < 0) {\n\t\t\tlast = next;\n\t\t\tcontinue;\n\t\t}\n\t\tfirst = next+1;\n\t}\n\t/* not found */\n\tif (!insert_ok)\n\t\treturn NULL;\n\t/* insert to make it at \"first\" */\n\tif (rename_dst_alloc <= rename_dst_nr) {\n\t\trename_dst_alloc = alloc_nr(rename_dst_alloc);\n\t\trename_dst = xrealloc(rename_dst,\n\t\t\t\t      rename_dst_alloc * sizeof(*rename_dst));\n\t}\n\trename_dst_nr++;\n\tif (first < rename_dst_nr)\n\t\tmemmove(rename_dst + first + 1, rename_dst + first,\n\t\t\t(rename_dst_nr - first - 1) * sizeof(*rename_dst));\n\trename_dst[first].two = alloc_filespec(two->path);\n\tfill_filespec(rename_dst[first].two, two->sha1, two->sha1_valid, two->mode);\n\trename_dst[first].pair = NULL;\n\treturn &(rename_dst[first]);\n}\n\n/* Table of rename/copy src files */\nstatic struct diff_rename_src {\n\tstruct diff_filepair *p;\n\tunsigned short score; /* to remember the break score */\n} *rename_src;\nstatic int rename_src_nr, rename_src_alloc;\n\nstatic struct diff_rename_src *register_rename_src(struct diff_filepair *p)\n{\n\tint first, last;\n\tstruct diff_filespec *one = p->one;\n\tunsigned short score = p->score;\n\n\tfirst = 0;\n\tlast = rename_src_nr;\n\twhile (last > first) {\n\t\tint next = (last + first) >> 1;\n\t\tstruct diff_rename_src *src = &(rename_src[next]);\n\t\tint cmp = strcmp(one->path, src->p->one->path);\n\t\tif (!cmp)\n\t\t\treturn src;\n\t\tif (cmp < 0) {\n\t\t\tlast = next;\n\t\t\tcontinue;\n\t\t}\n\t\tfirst = next+1;\n\t}\n\n\t/* insert to make it at \"first\" */\n\tif (rename_src_alloc <= rename_src_nr) {\n\t\trename_src_alloc = alloc_nr(rename_src_alloc);\n\t\trename_src = xrealloc(rename_src,\n\t\t\t\t      rename_src_alloc * sizeof(*rename_src));\n\t}\n\trename_src_nr++;\n\tif (first < rename_src_nr)\n\t\tmemmove(rename_src + first + 1, rename_src + first,\n\t\t\t(rename_src_nr - first - 1) * sizeof(*rename_src));\n\trename_src[first].p = p;\n\trename_src[first].score = score;\n\treturn &(rename_src[first]);\n}\n\nstatic int basename_same(struct diff_filespec *src, struct diff_filespec *dst)\n{\n\tint src_len = strlen(src->path), dst_len = strlen(dst->path);\n\twhile (src_len && dst_len) {\n\t\tchar c1 = src->path[--src_len];\n\t\tchar c2 = dst->path[--dst_len];\n\t\tif (c1 != c2)\n\t\t\treturn 0;\n\t\tif (c1 == '/')\n\t\t\treturn 1;\n\t}\n\treturn (!src_len || src->path[src_len - 1] == '/') &&\n\t\t(!dst_len || dst->path[dst_len - 1] == '/');\n}\n\nstruct diff_score {\n\tint src; /* index in rename_src */\n\tint dst; /* index in rename_dst */\n\tunsigned short score;\n\tshort name_score;\n};\n\nstatic int estimate_similarity(struct diff_filespec *src,\n\t\t\t       struct diff_filespec *dst,\n\t\t\t       int minimum_score)\n{\n\t/* src points at a file that existed in the original tree (or\n\t * optionally a file in the destination tree) and dst points\n\t * at a newly created file.  They may be quite similar, in which\n\t * case we want to say src is renamed to dst or src is copied into\n\t * dst, and then some edit has been applied to dst.\n\t *\n\t * Compare them and return how similar they are, representing\n\t * the score as an integer between 0 and MAX_SCORE.\n\t *\n\t * When there is an exact match, it is considered a better\n\t * match than anything else; the destination does not even\n\t * call into this function in that case.\n\t */\n\tunsigned long max_size, delta_size, base_size, src_copied, literal_added;\n\tunsigned long delta_limit;\n\tint score;\n\n\t/* We deal only with regular files.  Symlink renames are handled\n\t * only when they are exact matches --- in other words, no edits\n\t * after renaming.\n\t */\n\tif (!S_ISREG(src->mode) || !S_ISREG(dst->mode))\n\t\treturn 0;\n\n\t/*\n\t * Need to check that source and destination sizes are\n\t * filled in before comparing them.\n\t *\n\t * If we already have \"cnt_data\" filled in, we know it's\n\t * all good (avoid checking the size for zero, as that\n\t * is a possible size - we really should have a flag to\n\t * say whether the size is valid or not!)\n\t */\n\tif (!src->cnt_data && diff_populate_filespec(src, 1))\n\t\treturn 0;\n\tif (!dst->cnt_data && diff_populate_filespec(dst, 1))\n\t\treturn 0;\n\n\tmax_size = ((src->size > dst->size) ? src->size : dst->size);\n\tbase_size = ((src->size < dst->size) ? src->size : dst->size);\n\tdelta_size = max_size - base_size;\n\n\t/* We would not consider edits that change the file size so\n\t * drastically.  delta_size must be smaller than\n\t * (MAX_SCORE-minimum_score)/MAX_SCORE * min(src->size, dst->size).\n\t *\n\t * Note that base_size == 0 case is handled here already\n\t * and the final score computation below would not have a\n\t * divide-by-zero issue.\n\t */\n\tif (max_size * (MAX_SCORE-minimum_score) < delta_size * MAX_SCORE)\n\t\treturn 0;\n\n\tif (!src->cnt_data && diff_populate_filespec(src, 0))\n\t\treturn 0;\n\tif (!dst->cnt_data && diff_populate_filespec(dst, 0))\n\t\treturn 0;\n\n\tdelta_limit = (unsigned long)\n\t\t(base_size * (MAX_SCORE-minimum_score) / MAX_SCORE);\n\tif (diffcore_count_changes(src, dst,\n\t\t\t\t   &src->cnt_data, &dst->cnt_data,\n\t\t\t\t   delta_limit,\n\t\t\t\t   &src_copied, &literal_added))\n\t\treturn 0;\n\n\t/* How similar are they?\n\t * what percentage of material in dst are from source?\n\t */\n\tif (!dst->size)\n\t\tscore = 0; /* should not happen */\n\telse\n\t\tscore = (int)(src_copied * MAX_SCORE / max_size);\n\treturn score;\n}\n\nstatic void record_rename_pair(int dst_index, int src_index, int score)\n{\n\tstruct diff_filespec *src, *dst;\n\tstruct diff_filepair *dp;\n\n\tif (rename_dst[dst_index].pair)\n\t\tdie(\"internal error: dst already matched.\");\n\n\tsrc = rename_src[src_index].p->one;\n\tsrc->rename_used++;\n\tsrc->count++;\n\n\tdst = rename_dst[dst_index].two;\n\tdst->count++;\n\n\tdp = diff_queue(NULL, src, dst);\n\tdp->renamed_pair = 1;\n\tif (!strcmp(src->path, dst->path))\n\t\tdp->score = rename_src[src_index].score;\n\telse\n\t\tdp->score = score;\n\trename_dst[dst_index].pair = dp;\n}\n\n/*\n * We sort the rename similarity matrix with the score, in descending\n * order (the most similar first).\n */\nstatic int score_compare(const void *a_, const void *b_)\n{\n\tconst struct diff_score *a = a_, *b = b_;\n\n\t/* sink the unused ones to the bottom */\n\tif (a->dst < 0)\n\t\treturn (0 <= b->dst);\n\telse if (b->dst < 0)\n\t\treturn -1;\n\n\tif (a->score == b->score)\n\t\treturn b->name_score - a->name_score;\n\n\treturn b->score - a->score;\n}\n\nstruct file_similarity {\n\tint src_dst, index;\n\tstruct diff_filespec *filespec;\n\tstruct file_similarity *next;\n};\n\nstatic unsigned int hash_filespec(struct diff_filespec *filespec)\n{\n\tunsigned int hash;\n\tif (!filespec->sha1_valid) {\n\t\tif (diff_populate_filespec(filespec, 0))\n\t\t\treturn 0;\n\t\thash_sha1_file(filespec->data, filespec->size, \"blob\", filespec->sha1);\n\t}\n\tmemcpy(&hash, filespec->sha1, sizeof(hash));\n\treturn hash;\n}\n\nstatic int find_identical_files(struct file_similarity *src,\n\t\t\t\tstruct file_similarity *dst,\n\t\t\t\tstruct diff_options *options)\n{\n\tint renames = 0;\n\n\t/*\n\t * Walk over all the destinations ...\n\t */\n\tdo {\n\tstruct diff_filespec *target = dst->filespec;\n\tstruct file_similarity *p, *best;\n\tint i = 100, best_score = -1;\n\n\t/*\n\t * .. to find the best source match\n\t */\n\tbest = NULL;\n\tfor (p = src; p; p = p->next) {\n\t\tint score;\n\t\tstruct diff_filespec *source = p->filespec;\n\n\t\t/* False hash collision? */\n\t\tif (hashcmp(source->sha1, target->sha1))\n\t\t\tcontinue;\n\t\t/* Non-regular files? If so, the modes must match! */\n\t\tif (!S_ISREG(source->mode) || !S_ISREG(target->mode)) {\n\t\t\tif (source->mode != target->mode)\n\t\t\t\tcontinue;\n\t\t}\n\t\t/* Give higher scores to sources that haven't been used already */\n\t\tscore = !source->rename_used;\n\t\tif (source->rename_used && options->detect_rename != DIFF_DETECT_COPY)\n\t\t\tcontinue;\n\t\tscore += basename_same(source, target);\n\t\tif (score > best_score) {\n\t\t\tbest = p;\n\t\t\tbest_score = score;\n\t\t\tif (score == 2)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Too many identical alternatives? Pick one */\n\t\tif (!--i)\n\t\t\tbreak;\n\t}\n\tif (best) {\n\t\trecord_rename_pair(dst->index, best->index, MAX_SCORE);\n\t\trenames++;\n\t}\n\t} while ((dst = dst->next) != NULL);\n\treturn renames;\n}\n\nstatic void free_similarity_list(struct file_similarity *p)\n{\n\twhile (p) {\n\t\tstruct file_similarity *entry = p;\n\t\tp = p->next;\n\t\tfree(entry);\n\t}\n}\n\nstatic int find_same_files(void *ptr, void *data)\n{\n\tint ret;\n\tstruct file_similarity *p = ptr;\n\tstruct file_similarity *src = NULL, *dst = NULL;\n\tstruct diff_options *options = data;\n\n\t/* Split the hash list up into sources and destinations */\n\tdo {\n\t\tstruct file_similarity *entry = p;\n\t\tp = p->next;\n\t\tif (entry->src_dst < 0) {\n\t\t\tentry->next = src;\n\t\t\tsrc = entry;\n\t\t} else {\n\t\t\tentry->next = dst;\n\t\t\tdst = entry;\n\t\t}\n\t} while (p);\n\n\t/*\n\t * If we have both sources *and* destinations, see if\n\t * we can match them up\n\t */\n\tret = (src && dst) ? find_identical_files(src, dst, options) : 0;\n\n\t/* Free the hashes and return the number of renames found */\n\tfree_similarity_list(src);\n\tfree_similarity_list(dst);\n\treturn ret;\n}\n\nstatic void insert_file_table(struct hash_table *table, int src_dst, int index, struct diff_filespec *filespec)\n{\n\tvoid **pos;\n\tunsigned int hash;\n\tstruct file_similarity *entry = xmalloc(sizeof(*entry));\n\n\tentry->src_dst = src_dst;\n\tentry->index = index;\n\tentry->filespec = filespec;\n\tentry->next = NULL;\n\n\thash = hash_filespec(filespec);\n\tpos = insert_hash(hash, entry, table);\n\n\t/* We already had an entry there? */\n\tif (pos) {\n\t\tentry->next = *pos;\n\t\t*pos = entry;\n\t}\n}\n\n/*\n * Find exact renames first.\n *\n * The first round matches up the up-to-date entries,\n * and then during the second round we try to match\n * cache-dirty entries as well.\n */\nstatic int find_exact_renames(struct diff_options *options)\n{\n\tint i;\n\tstruct hash_table file_table;\n\n\tinit_hash(&file_table);\n\tpreallocate_hash(&file_table, rename_src_nr + rename_dst_nr);\n\tfor (i = 0; i < rename_src_nr; i++)\n\t\tinsert_file_table(&file_table, -1, i, rename_src[i].p->one);\n\n\tfor (i = 0; i < rename_dst_nr; i++)\n\t\tinsert_file_table(&file_table, 1, i, rename_dst[i].two);\n\n\t/* Find the renames */\n\ti = for_each_hash(&file_table, find_same_files, options);\n\n\t/* .. and free the hash data structure */\n\tfree_hash(&file_table);\n\n\treturn i;\n}\n\n#define NUM_CANDIDATE_PER_DST 4\nstatic void record_if_better(struct diff_score m[], struct diff_score *o)\n{\n\tint i, worst;\n\n\t/* find the worst one */\n\tworst = 0;\n\tfor (i = 1; i < NUM_CANDIDATE_PER_DST; i++)\n\t\tif (score_compare(&m[i], &m[worst]) > 0)\n\t\t\tworst = i;\n\n\t/* is it better than the worst one? */\n\tif (score_compare(&m[worst], o) > 0)\n\t\tm[worst] = *o;\n}\n\n/*\n * Returns:\n * 0 if we are under the limit;\n * 1 if we need to disable inexact rename detection;\n * 2 if we would be under the limit if we were given -C instead of -C -C.\n */\nstatic int too_many_rename_candidates(int num_create,\n\t\t\t\t      struct diff_options *options)\n{\n\tint rename_limit = options->rename_limit;\n\tint num_src = rename_src_nr;\n\tint i;\n\n\toptions->needed_rename_limit = 0;\n\n\t/*\n\t * This basically does a test for the rename matrix not\n\t * growing larger than a \"rename_limit\" square matrix, ie:\n\t *\n\t *    num_create * num_src > rename_limit * rename_limit\n\t *\n\t * but handles the potential overflow case specially (and we\n\t * assume at least 32-bit integers)\n\t */\n\tif (rename_limit <= 0 || rename_limit > 32767)\n\t\trename_limit = 32767;\n\tif ((num_create <= rename_limit || num_src <= rename_limit) &&\n\t    (num_create * num_src <= rename_limit * rename_limit))\n\t\treturn 0;\n\n\toptions->needed_rename_limit =\n\t\tnum_src > num_create ? num_src : num_create;\n\n\t/* Are we running under -C -C? */\n\tif (!DIFF_OPT_TST(options, FIND_COPIES_HARDER))\n\t\treturn 1;\n\n\t/* Would we bust the limit if we were running under -C? */\n\tfor (num_src = i = 0; i < rename_src_nr; i++) {\n\t\tif (diff_unmodified_pair(rename_src[i].p))\n\t\t\tcontinue;\n\t\tnum_src++;\n\t}\n\tif ((num_create <= rename_limit || num_src <= rename_limit) &&\n\t    (num_create * num_src <= rename_limit * rename_limit))\n\t\treturn 2;\n\treturn 1;\n}\n\nstatic int find_renames(struct diff_score *mx, int dst_cnt, int minimum_score, int copies)\n{\n\tint count = 0, i;\n\n\tfor (i = 0; i < dst_cnt * NUM_CANDIDATE_PER_DST; i++) {\n\t\tstruct diff_rename_dst *dst;\n\n\t\tif ((mx[i].dst < 0) ||\n\t\t    (mx[i].score < minimum_score))\n\t\t\tbreak; /* there is no more usable pair. */\n\t\tdst = &rename_dst[mx[i].dst];\n\t\tif (dst->pair)\n\t\t\tcontinue; /* already done, either exact or fuzzy. */\n\t\tif (!copies && rename_src[mx[i].src].p->one->rename_used)\n\t\t\tcontinue;\n\t\trecord_rename_pair(mx[i].dst, mx[i].src, mx[i].score);\n\t\tcount++;\n\t}\n\treturn count;\n}\n\nvoid diffcore_rename(struct diff_options *options)\n{\n\tint detect_rename = options->detect_rename;\n\tint minimum_score = options->rename_score;\n\tstruct diff_queue_struct *q = &diff_queued_diff;\n\tstruct diff_queue_struct outq;\n\tstruct diff_score *mx;\n\tint i, j, rename_count, skip_unmodified = 0;\n\tint num_create, dst_cnt;\n\tstruct progress *progress = NULL;\n\n\tif (!minimum_score)\n\t\tminimum_score = DEFAULT_RENAME_SCORE;\n\n\tfor (i = 0; i < q->nr; i++) {\n\t\tstruct diff_filepair *p = q->queue[i];\n\t\tif (!DIFF_FILE_VALID(p->one)) {\n\t\t\tif (!DIFF_FILE_VALID(p->two))\n\t\t\t\tcontinue; /* unmerged */\n\t\t\telse if (options->single_follow &&\n\t\t\t\t strcmp(options->single_follow, p->two->path))\n\t\t\t\tcontinue; /* not interested */\n\t\t\telse if (!DIFF_OPT_TST(options, RENAME_EMPTY) &&\n\t\t\t\t is_empty_blob_sha1(p->two->sha1))\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tlocate_rename_dst(p->two, 1);\n\t\t}\n\t\telse if (!DIFF_OPT_TST(options, RENAME_EMPTY) &&\n\t\t\t is_empty_blob_sha1(p->one->sha1))\n\t\t\tcontinue;\n\t\telse if (!DIFF_PAIR_UNMERGED(p) && !DIFF_FILE_VALID(p->two)) {\n\t\t\t/*\n\t\t\t * If the source is a broken \"delete\", and\n\t\t\t * they did not really want to get broken,\n\t\t\t * that means the source actually stays.\n\t\t\t * So we increment the \"rename_used\" score\n\t\t\t * by one, to indicate ourselves as a user\n\t\t\t */\n\t\t\tif (p->broken_pair && !p->score)\n\t\t\t\tp->one->rename_used++;\n\t\t\tregister_rename_src(p);\n\t\t}\n\t\telse if (detect_rename == DIFF_DETECT_COPY) {\n\t\t\t/*\n\t\t\t * Increment the \"rename_used\" score by\n\t\t\t * one, to indicate ourselves as a user.\n\t\t\t */\n\t\t\tp->one->rename_used++;\n\t\t\tregister_rename_src(p);\n\t\t}\n\t}\n\tif (rename_dst_nr == 0 || rename_src_nr == 0)\n\t\tgoto cleanup; /* nothing to do */\n\n\t/*\n\t * We really want to cull the candidates list early\n\t * with cheap tests in order to avoid doing deltas.\n\t */\n\trename_count = find_exact_renames(options);\n\n\t/* Did we only want exact renames? */\n\tif (minimum_score == MAX_SCORE)\n\t\tgoto cleanup;\n\n\t/*\n\t * Calculate how many renames are left (but all the source\n\t * files still remain as options for rename/copies!)\n\t */\n\tnum_create = (rename_dst_nr - rename_count);\n\n\t/* All done? */\n\tif (!num_create)\n\t\tgoto cleanup;\n\n\tswitch (too_many_rename_candidates(num_create, options)) {\n\tcase 1:\n\t\tgoto cleanup;\n\tcase 2:\n\t\toptions->degraded_cc_to_c = 1;\n\t\tskip_unmodified = 1;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (options->show_rename_progress) {\n\t\tprogress = start_progress_delay(\n\t\t\t\t\"Performing inexact rename detection\",\n\t\t\t\trename_dst_nr * rename_src_nr, 50, 1);\n\t}\n\n\tmx = xcalloc(num_create * NUM_CANDIDATE_PER_DST, sizeof(*mx));\n\tfor (dst_cnt = i = 0; i < rename_dst_nr; i++) {\n\t\tstruct diff_filespec *two = rename_dst[i].two;\n\t\tstruct diff_score *m;\n\n\t\tif (rename_dst[i].pair)\n\t\t\tcontinue; /* dealt with exact match already. */\n\n\t\tm = &mx[dst_cnt * NUM_CANDIDATE_PER_DST];\n\t\tfor (j = 0; j < NUM_CANDIDATE_PER_DST; j++)\n\t\t\tm[j].dst = -1;\n\n\t\tfor (j = 0; j < rename_src_nr; j++) {\n\t\t\tstruct diff_filespec *one = rename_src[j].p->one;\n\t\t\tstruct diff_score this_src;\n\n\t\t\tif (skip_unmodified &&\n\t\t\t    diff_unmodified_pair(rename_src[j].p))\n\t\t\t\tcontinue;\n\n\t\t\tthis_src.score = estimate_similarity(one, two,\n\t\t\t\t\t\t\t     minimum_score);\n\t\t\tthis_src.name_score = basename_same(one, two);\n\t\t\tthis_src.dst = i;\n\t\t\tthis_src.src = j;\n\t\t\trecord_if_better(m, &this_src);\n\t\t\t/*\n\t\t\t * Once we run estimate_similarity,\n\t\t\t * We do not need the text anymore.\n\t\t\t */\n\t\t\tdiff_free_filespec_blob(one);\n\t\t\tdiff_free_filespec_blob(two);\n\t\t}\n\t\tdst_cnt++;\n\t\tdisplay_progress(progress, (i+1)*rename_src_nr);\n\t}\n\tstop_progress(&progress);\n\n\t/* cost matrix sorted by most to least similar pair */\n\tqsort(mx, dst_cnt * NUM_CANDIDATE_PER_DST, sizeof(*mx), score_compare);\n\n\trename_count += find_renames(mx, dst_cnt, minimum_score, 0);\n\tif (detect_rename == DIFF_DETECT_COPY)\n\t\trename_count += find_renames(mx, dst_cnt, minimum_score, 1);\n\tfree(mx);\n\n cleanup:\n\t/* At this point, we have found some renames and copies and they\n\t * are recorded in rename_dst.  The original list is still in *q.\n\t */\n\tDIFF_QUEUE_CLEAR(&outq);\n\tfor (i = 0; i < q->nr; i++) {\n\t\tstruct diff_filepair *p = q->queue[i];\n\t\tstruct diff_filepair *pair_to_free = NULL;\n\n\t\tif (DIFF_PAIR_UNMERGED(p)) {\n\t\t\tdiff_q(&outq, p);\n\t\t}\n\t\telse if (!DIFF_FILE_VALID(p->one) && DIFF_FILE_VALID(p->two)) {\n\t\t\t/*\n\t\t\t * Creation\n\t\t\t *\n\t\t\t * We would output this create record if it has\n\t\t\t * not been turned into a rename/copy already.\n\t\t\t */\n\t\t\tstruct diff_rename_dst *dst =\n\t\t\t\tlocate_rename_dst(p->two, 0);\n\t\t\tif (dst && dst->pair) {\n\t\t\t\tdiff_q(&outq, dst->pair);\n\t\t\t\tpair_to_free = p;\n\t\t\t}\n\t\t\telse\n\t\t\t\t/* no matching rename/copy source, so\n\t\t\t\t * record this as a creation.\n\t\t\t\t */\n\t\t\t\tdiff_q(&outq, p);\n\t\t}\n\t\telse if (DIFF_FILE_VALID(p->one) && !DIFF_FILE_VALID(p->two)) {\n\t\t\t/*\n\t\t\t * Deletion\n\t\t\t *\n\t\t\t * We would output this delete record if:\n\t\t\t *\n\t\t\t * (1) this is a broken delete and the counterpart\n\t\t\t *     broken create remains in the output; or\n\t\t\t * (2) this is not a broken delete, and rename_dst\n\t\t\t *     does not have a rename/copy to move p->one->path\n\t\t\t *     out of existence.\n\t\t\t *\n\t\t\t * Otherwise, the counterpart broken create\n\t\t\t * has been turned into a rename-edit; or\n\t\t\t * delete did not have a matching create to\n\t\t\t * begin with.\n\t\t\t */\n\t\t\tif (DIFF_PAIR_BROKEN(p)) {\n\t\t\t\t/* broken delete */\n\t\t\t\tstruct diff_rename_dst *dst =\n\t\t\t\t\tlocate_rename_dst(p->one, 0);\n\t\t\t\tif (dst && dst->pair)\n\t\t\t\t\t/* counterpart is now rename/copy */\n\t\t\t\t\tpair_to_free = p;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (p->one->rename_used)\n\t\t\t\t\t/* this path remains */\n\t\t\t\t\tpair_to_free = p;\n\t\t\t}\n\n\t\t\tif (pair_to_free)\n\t\t\t\t;\n\t\t\telse\n\t\t\t\tdiff_q(&outq, p);\n\t\t}\n\t\telse if (!diff_unmodified_pair(p))\n\t\t\t/* all the usual ones need to be kept */\n\t\t\tdiff_q(&outq, p);\n\t\telse\n\t\t\t/* no need to keep unmodified pairs */\n\t\t\tpair_to_free = p;\n\n\t\tif (pair_to_free)\n\t\t\tdiff_free_filepair(pair_to_free);\n\t}\n\tdiff_debug_queue(\"done copying original\", &outq);\n\n\tfree(q->queue);\n\t*q = outq;\n\tdiff_debug_queue(\"done collapsing\", q);\n\n\tfor (i = 0; i < rename_dst_nr; i++)\n\t\tfree_filespec(rename_dst[i].two);\n\n\tfree(rename_dst);\n\trename_dst = NULL;\n\trename_dst_nr = rename_dst_alloc = 0;\n\tfree(rename_src);\n\trename_src = NULL;\n\trename_src_nr = rename_src_alloc = 0;\n\treturn;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "008a60c09dde780580c8eee7d2b08400a8c42b4d",
  "sha1_ok": true,
  "size": 19006
}
