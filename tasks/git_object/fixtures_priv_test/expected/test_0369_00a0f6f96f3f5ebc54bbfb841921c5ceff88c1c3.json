{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJhZGQtaW50ZXJhY3RpdmUuaCIKI2luY2x1ZGUgImNvbG9yLmgiCiNpbmNsdWRlICJjb25maWcuaCIKI2luY2x1ZGUgImRpZmZjb3JlLmgiCiNpbmNsdWRlICJyZXZpc2lvbi5oIgojaW5jbHVkZSAicmVmcy5oIgojaW5jbHVkZSAic3RyaW5nLWxpc3QuaCIKI2luY2x1ZGUgImxvY2tmaWxlLmgiCiNpbmNsdWRlICJkaXIuaCIKI2luY2x1ZGUgInJ1bi1jb21tYW5kLmgiCiNpbmNsdWRlICJwcm9tcHQuaCIKCnN0YXRpYyB2b2lkIGluaXRfY29sb3Ioc3RydWN0IHJlcG9zaXRvcnkgKnIsIHN0cnVjdCBhZGRfaV9zdGF0ZSAqcywKCQkgICAgICAgY29uc3QgY2hhciAqc2VjdGlvbl9hbmRfc2xvdCwgY2hhciAqZHN0LAoJCSAgICAgICBjb25zdCBjaGFyICpkZWZhdWx0X2NvbG9yKQp7CgljaGFyICprZXkgPSB4c3RyZm10KCJjb2xvci4lcyIsIHNlY3Rpb25fYW5kX3Nsb3QpOwoJY29uc3QgY2hhciAqdmFsdWU7CgoJaWYgKCFzLT51c2VfY29sb3IpCgkJZHN0WzBdID0gJ1wwJzsKCWVsc2UgaWYgKHJlcG9fY29uZmlnX2dldF92YWx1ZShyLCBrZXksICZ2YWx1ZSkgfHwKCQkgY29sb3JfcGFyc2UodmFsdWUsIGRzdCkpCgkJc3RybGNweShkc3QsIGRlZmF1bHRfY29sb3IsIENPTE9SX01BWExFTik7CgoJZnJlZShrZXkpOwp9Cgp2b2lkIGluaXRfYWRkX2lfc3RhdGUoc3RydWN0IGFkZF9pX3N0YXRlICpzLCBzdHJ1Y3QgcmVwb3NpdG9yeSAqcikKewoJY29uc3QgY2hhciAqdmFsdWU7CgoJcy0+ciA9IHI7CgoJaWYgKHJlcG9fY29uZmlnX2dldF92YWx1ZShyLCAiY29sb3IuaW50ZXJhY3RpdmUiLCAmdmFsdWUpKQoJCXMtPnVzZV9jb2xvciA9IC0xOwoJZWxzZQoJCXMtPnVzZV9jb2xvciA9CgkJCWdpdF9jb25maWdfY29sb3Jib29sKCJjb2xvci5pbnRlcmFjdGl2ZSIsIHZhbHVlKTsKCXMtPnVzZV9jb2xvciA9IHdhbnRfY29sb3Iocy0+dXNlX2NvbG9yKTsKCglpbml0X2NvbG9yKHIsIHMsICJpbnRlcmFjdGl2ZS5oZWFkZXIiLCBzLT5oZWFkZXJfY29sb3IsIEdJVF9DT0xPUl9CT0xEKTsKCWluaXRfY29sb3IociwgcywgImludGVyYWN0aXZlLmhlbHAiLCBzLT5oZWxwX2NvbG9yLCBHSVRfQ09MT1JfQk9MRF9SRUQpOwoJaW5pdF9jb2xvcihyLCBzLCAiaW50ZXJhY3RpdmUucHJvbXB0Iiwgcy0+cHJvbXB0X2NvbG9yLAoJCSAgIEdJVF9DT0xPUl9CT0xEX0JMVUUpOwoJaW5pdF9jb2xvcihyLCBzLCAiaW50ZXJhY3RpdmUuZXJyb3IiLCBzLT5lcnJvcl9jb2xvciwKCQkgICBHSVRfQ09MT1JfQk9MRF9SRUQpOwoKCWluaXRfY29sb3IociwgcywgImRpZmYuZnJhZyIsIHMtPmZyYWdpbmZvX2NvbG9yLAoJCSAgIGRpZmZfZ2V0X2NvbG9yKHMtPnVzZV9jb2xvciwgRElGRl9GUkFHSU5GTykpOwoJaW5pdF9jb2xvcihyLCBzLCAiZGlmZi5jb250ZXh0Iiwgcy0+Y29udGV4dF9jb2xvciwgImZhbGwgYmFjayIpOwoJaWYgKCFzdHJjbXAocy0+Y29udGV4dF9jb2xvciwgImZhbGwgYmFjayIpKQoJCWluaXRfY29sb3IociwgcywgImRpZmYucGxhaW4iLCBzLT5jb250ZXh0X2NvbG9yLAoJCQkgICBkaWZmX2dldF9jb2xvcihzLT51c2VfY29sb3IsIERJRkZfQ09OVEVYVCkpOwoJaW5pdF9jb2xvcihyLCBzLCAiZGlmZi5vbGQiLCBzLT5maWxlX29sZF9jb2xvciwKCQlkaWZmX2dldF9jb2xvcihzLT51c2VfY29sb3IsIERJRkZfRklMRV9PTEQpKTsKCWluaXRfY29sb3IociwgcywgImRpZmYubmV3Iiwgcy0+ZmlsZV9uZXdfY29sb3IsCgkJZGlmZl9nZXRfY29sb3Iocy0+dXNlX2NvbG9yLCBESUZGX0ZJTEVfTkVXKSk7CgoJc3RybGNweShzLT5yZXNldF9jb2xvciwKCQlzLT51c2VfY29sb3IgPyBHSVRfQ09MT1JfUkVTRVQgOiAiIiwgQ09MT1JfTUFYTEVOKTsKCglGUkVFX0FORF9OVUxMKHMtPmludGVyYWN0aXZlX2RpZmZfZmlsdGVyKTsKCWdpdF9jb25maWdfZ2V0X3N0cmluZygiaW50ZXJhY3RpdmUuZGlmZmZpbHRlciIsCgkJCSAgICAgICZzLT5pbnRlcmFjdGl2ZV9kaWZmX2ZpbHRlcik7CgoJRlJFRV9BTkRfTlVMTChzLT5pbnRlcmFjdGl2ZV9kaWZmX2FsZ29yaXRobSk7CglnaXRfY29uZmlnX2dldF9zdHJpbmcoImRpZmYuYWxnb3JpdGhtIiwKCQkJICAgICAgJnMtPmludGVyYWN0aXZlX2RpZmZfYWxnb3JpdGhtKTsKCglnaXRfY29uZmlnX2dldF9ib29sKCJpbnRlcmFjdGl2ZS5zaW5nbGVrZXkiLCAmcy0+dXNlX3NpbmdsZV9rZXkpOwoJaWYgKHMtPnVzZV9zaW5nbGVfa2V5KQoJCXNldGJ1ZihzdGRpbiwgTlVMTCk7Cn0KCnZvaWQgY2xlYXJfYWRkX2lfc3RhdGUoc3RydWN0IGFkZF9pX3N0YXRlICpzKQp7CglGUkVFX0FORF9OVUxMKHMtPmludGVyYWN0aXZlX2RpZmZfZmlsdGVyKTsKCUZSRUVfQU5EX05VTEwocy0+aW50ZXJhY3RpdmVfZGlmZl9hbGdvcml0aG0pOwoJbWVtc2V0KHMsIDAsIHNpemVvZigqcykpOwoJcy0+dXNlX2NvbG9yID0gLTE7Cn0KCi8qCiAqIEEgInByZWZpeCBpdGVtIGxpc3QiIGlzIGEgbGlzdCBvZiBpdGVtcyB0aGF0IGFyZSBpZGVudGlmaWVkIGJ5IGEgc3RyaW5nLCBhbmQKICogYSB1bmlxdWUgcHJlZml4IChpZiBhbnkpIGlzIGRldGVybWluZWQgZm9yIGVhY2ggaXRlbS4KICoKICogSXQgaXMgaW1wbGVtZW50ZWQgaW4gdGhlIGZvcm0gb2YgYSBwYWlyIG9mIGBzdHJpbmdfbGlzdGBzLCB0aGUgZmlyc3Qgb25lCiAqIGR1cGxpY2F0aW5nIHRoZSBzdHJpbmdzLCB3aXRoIHRoZSBgdXRpbGAgZmllbGQgcG9pbnRpbmcgYXQgYSBzdHJ1Y3R1cmUgd2hvc2UKICogZmlyc3QgZmllbGQgbXVzdCBiZSBgc2l6ZV90IHByZWZpeF9sZW5ndGhgLgogKgogKiBUaGF0IGBwcmVmaXhfbGVuZ3RoYCBmaWVsZCB3aWxsIGJlIGNvbXB1dGVkIGJ5IGBmaW5kX3VuaXF1ZV9wcmVmaXhlcygpYDsgSXQKICogd2lsbCBiZSBzZXQgdG8gemVybyBpZiBubyB2YWxpZCwgdW5pcXVlIHByZWZpeCBjb3VsZCBiZSBmb3VuZC4KICoKICogVGhlIHNlY29uZCBgc3RyaW5nX2xpc3RgIGlzIGNhbGxlZCBgc29ydGVkYCBhbmQgZG9lcyBfbm90XyBkdXBsaWNhdGUgdGhlCiAqIHN0cmluZ3MgYnV0IHNpbXBseSByZXVzZXMgdGhlIGZpcnN0IG9uZSdzLCB3aXRoIHRoZSBgdXRpbGAgZmllbGQgcG9pbnRpbmcgYXQKICogdGhlIGBzdHJpbmdfaXRlbV9saXN0YCBvZiB0aGUgZmlyc3QgYHN0cmluZ19saXN0YC4gSXQgIHdpbGwgYmUgcG9wdWxhdGVkIGFuZAogKiBzb3J0ZWQgYnkgYGZpbmRfdW5pcXVlX3ByZWZpeGVzKClgLgogKi8Kc3RydWN0IHByZWZpeF9pdGVtX2xpc3QgewoJc3RydWN0IHN0cmluZ19saXN0IGl0ZW1zOwoJc3RydWN0IHN0cmluZ19saXN0IHNvcnRlZDsKCWludCAqc2VsZWN0ZWQ7IC8qIGZvciBtdWx0aS1zZWxlY3Rpb25zICovCglzaXplX3QgbWluX2xlbmd0aCwgbWF4X2xlbmd0aDsKfTsKI2RlZmluZSBQUkVGSVhfSVRFTV9MSVNUX0lOSVQgeyBcCgkuaXRlbXMgPSBTVFJJTkdfTElTVF9JTklUX0RVUCwgXAoJLnNvcnRlZCA9IFNUUklOR19MSVNUX0lOSVRfTk9EVVAsIFwKCS5taW5fbGVuZ3RoID0gMSwgXAoJLm1heF9sZW5ndGggPSA0LCBcCn0KCnN0YXRpYyB2b2lkIHByZWZpeF9pdGVtX2xpc3RfY2xlYXIoc3RydWN0IHByZWZpeF9pdGVtX2xpc3QgKmxpc3QpCnsKCXN0cmluZ19saXN0X2NsZWFyKCZsaXN0LT5pdGVtcywgMSk7CglzdHJpbmdfbGlzdF9jbGVhcigmbGlzdC0+c29ydGVkLCAwKTsKCUZSRUVfQU5EX05VTEwobGlzdC0+c2VsZWN0ZWQpOwp9CgpzdGF0aWMgdm9pZCBleHRlbmRfcHJlZml4X2xlbmd0aChzdHJ1Y3Qgc3RyaW5nX2xpc3RfaXRlbSAqcCwKCQkJCSBjb25zdCBjaGFyICpvdGhlcl9zdHJpbmcsIHNpemVfdCBtYXhfbGVuZ3RoKQp7CglzaXplX3QgKmxlbiA9IHAtPnV0aWw7CgoJaWYgKCEqbGVuIHx8IG1lbWNtcChwLT5zdHJpbmcsIG90aGVyX3N0cmluZywgKmxlbikpCgkJcmV0dXJuOwoKCWZvciAoOzspIHsKCQljaGFyIGMgPSBwLT5zdHJpbmdbKmxlbl07CgoJCS8qCgkJICogSXMgYHBgIGEgc3RyaWN0IHByZWZpeCBvZiBgb3RoZXJgPyBPciBoYXZlIHdlIGV4aGF1c3RlZCB0aGUKCQkgKiBtYXhpbWFsIGxlbmd0aCBvZiB0aGUgcHJlZml4PyBPciBpcyB0aGUgY3VycmVudCBjaGFyYWN0ZXIgYQoJCSAqIG11bHRpLWJ5dGUgVVRGLTggb25lPyBJZiBzbywgdGhlcmUgaXMgbm8gdmFsaWQsIHVuaXF1ZQoJCSAqIHByZWZpeC4KCQkgKi8KCQlpZiAoIWMgfHwgKysqbGVuID4gbWF4X2xlbmd0aCB8fCAhaXNhc2NpaShjKSkgewoJCQkqbGVuID0gMDsKCQkJYnJlYWs7CgkJfQoKCQlpZiAoYyAhPSBvdGhlcl9zdHJpbmdbKmxlbiAtIDFdKQoJCQlicmVhazsKCX0KfQoKc3RhdGljIHZvaWQgZmluZF91bmlxdWVfcHJlZml4ZXMoc3RydWN0IHByZWZpeF9pdGVtX2xpc3QgKmxpc3QpCnsKCXNpemVfdCBpOwoKCWlmIChsaXN0LT5zb3J0ZWQubnIgPT0gbGlzdC0+aXRlbXMubnIpCgkJcmV0dXJuOwoKCXN0cmluZ19saXN0X2NsZWFyKCZsaXN0LT5zb3J0ZWQsIDApOwoJLyogQXZvaWQgcmVhbGxvY2F0aW5nIGluY3JlbWVudGFsbHkgKi8KCWxpc3QtPnNvcnRlZC5pdGVtcyA9IHhtYWxsb2Moc3RfbXVsdChzaXplb2YoKmxpc3QtPnNvcnRlZC5pdGVtcyksCgkJCQkJICAgICBsaXN0LT5pdGVtcy5ucikpOwoJbGlzdC0+c29ydGVkLm5yID0gbGlzdC0+c29ydGVkLmFsbG9jID0gbGlzdC0+aXRlbXMubnI7CgoJZm9yIChpID0gMDsgaSA8IGxpc3QtPml0ZW1zLm5yOyBpKyspIHsKCQlsaXN0LT5zb3J0ZWQuaXRlbXNbaV0uc3RyaW5nID0gbGlzdC0+aXRlbXMuaXRlbXNbaV0uc3RyaW5nOwoJCWxpc3QtPnNvcnRlZC5pdGVtc1tpXS51dGlsID0gbGlzdC0+aXRlbXMuaXRlbXMgKyBpOwoJfQoKCXN0cmluZ19saXN0X3NvcnQoJmxpc3QtPnNvcnRlZCk7CgoJZm9yIChpID0gMDsgaSA8IGxpc3QtPnNvcnRlZC5ucjsgaSsrKSB7CgkJc3RydWN0IHN0cmluZ19saXN0X2l0ZW0gKnNvcnRlZF9pdGVtID0gbGlzdC0+c29ydGVkLml0ZW1zICsgaTsKCQlzdHJ1Y3Qgc3RyaW5nX2xpc3RfaXRlbSAqaXRlbSA9IHNvcnRlZF9pdGVtLT51dGlsOwoJCXNpemVfdCAqbGVuID0gaXRlbS0+dXRpbDsKCgkJKmxlbiA9IDA7CgkJd2hpbGUgKCpsZW4gPCBsaXN0LT5taW5fbGVuZ3RoKSB7CgkJCWNoYXIgYyA9IGl0ZW0tPnN0cmluZ1soKmxlbikrK107CgoJCQlpZiAoIWMgfHwgIWlzYXNjaWkoYykpIHsKCQkJCSpsZW4gPSAwOwoJCQkJYnJlYWs7CgkJCX0KCQl9CgoJCWlmIChpID4gMCkKCQkJZXh0ZW5kX3ByZWZpeF9sZW5ndGgoaXRlbSwgc29ydGVkX2l0ZW1bLTFdLnN0cmluZywKCQkJCQkgICAgIGxpc3QtPm1heF9sZW5ndGgpOwoJCWlmIChpICsgMSA8IGxpc3QtPnNvcnRlZC5ucikKCQkJZXh0ZW5kX3ByZWZpeF9sZW5ndGgoaXRlbSwgc29ydGVkX2l0ZW1bMV0uc3RyaW5nLAoJCQkJCSAgICAgbGlzdC0+bWF4X2xlbmd0aCk7Cgl9Cn0KCnN0YXRpYyBzc2l6ZV90IGZpbmRfdW5pcXVlKGNvbnN0IGNoYXIgKnN0cmluZywgc3RydWN0IHByZWZpeF9pdGVtX2xpc3QgKmxpc3QpCnsKCWludCBpbmRleCA9IHN0cmluZ19saXN0X2ZpbmRfaW5zZXJ0X2luZGV4KCZsaXN0LT5zb3J0ZWQsIHN0cmluZywgMSk7CglzdHJ1Y3Qgc3RyaW5nX2xpc3RfaXRlbSAqaXRlbTsKCglpZiAobGlzdC0+aXRlbXMubnIgIT0gbGlzdC0+c29ydGVkLm5yKQoJCUJVRygicHJlZml4X2l0ZW1fbGlzdCBpbiBpbmNvbnNpc3RlbnQgc3RhdGUgKCUiUFJJdU1BWAoJCSAgICAiIHZzICUiUFJJdU1BWCIpIiwKCQkgICAgKHVpbnRtYXhfdClsaXN0LT5pdGVtcy5uciwgKHVpbnRtYXhfdClsaXN0LT5zb3J0ZWQubnIpOwoKCWlmIChpbmRleCA8IDApCgkJaXRlbSA9IGxpc3QtPnNvcnRlZC5pdGVtc1stMSAtIGluZGV4XS51dGlsOwoJZWxzZSBpZiAoaW5kZXggPiAwICYmCgkJIHN0YXJ0c193aXRoKGxpc3QtPnNvcnRlZC5pdGVtc1tpbmRleCAtIDFdLnN0cmluZywgc3RyaW5nKSkKCQlyZXR1cm4gLTE7CgllbHNlIGlmIChpbmRleCArIDEgPCBsaXN0LT5zb3J0ZWQubnIgJiYKCQkgc3RhcnRzX3dpdGgobGlzdC0+c29ydGVkLml0ZW1zW2luZGV4ICsgMV0uc3RyaW5nLCBzdHJpbmcpKQoJCXJldHVybiAtMTsKCWVsc2UgaWYgKGluZGV4IDwgbGlzdC0+c29ydGVkLm5yICYmCgkJIHN0YXJ0c193aXRoKGxpc3QtPnNvcnRlZC5pdGVtc1tpbmRleF0uc3RyaW5nLCBzdHJpbmcpKQoJCWl0ZW0gPSBsaXN0LT5zb3J0ZWQuaXRlbXNbaW5kZXhdLnV0aWw7CgllbHNlCgkJcmV0dXJuIC0xOwoJcmV0dXJuIGl0ZW0gLSBsaXN0LT5pdGVtcy5pdGVtczsKfQoKc3RydWN0IGxpc3Rfb3B0aW9ucyB7CglpbnQgY29sdW1uczsKCWNvbnN0IGNoYXIgKmhlYWRlcjsKCXZvaWQgKCpwcmludF9pdGVtKShpbnQgaSwgaW50IHNlbGVjdGVkLCBzdHJ1Y3Qgc3RyaW5nX2xpc3RfaXRlbSAqaXRlbSwKCQkJICAgdm9pZCAqcHJpbnRfaXRlbV9kYXRhKTsKCXZvaWQgKnByaW50X2l0ZW1fZGF0YTsKfTsKCnN0YXRpYyB2b2lkIGxpc3Qoc3RydWN0IGFkZF9pX3N0YXRlICpzLCBzdHJ1Y3Qgc3RyaW5nX2xpc3QgKmxpc3QsIGludCAqc2VsZWN0ZWQsCgkJIHN0cnVjdCBsaXN0X29wdGlvbnMgKm9wdHMpCnsKCWludCBpLCBsYXN0X2xmID0gMDsKCglpZiAoIWxpc3QtPm5yKQoJCXJldHVybjsKCglpZiAob3B0cy0+aGVhZGVyKQoJCWNvbG9yX2ZwcmludGZfbG4oc3Rkb3V0LCBzLT5oZWFkZXJfY29sb3IsCgkJCQkgIiVzIiwgb3B0cy0+aGVhZGVyKTsKCglmb3IgKGkgPSAwOyBpIDwgbGlzdC0+bnI7IGkrKykgewoJCW9wdHMtPnByaW50X2l0ZW0oaSwgc2VsZWN0ZWQgPyBzZWxlY3RlZFtpXSA6IDAsIGxpc3QtPml0ZW1zICsgaSwKCQkJCSBvcHRzLT5wcmludF9pdGVtX2RhdGEpOwoKCQlpZiAoKG9wdHMtPmNvbHVtbnMpICYmICgoaSArIDEpICUgKG9wdHMtPmNvbHVtbnMpKSkgewoJCQlwdXRjaGFyKCdcdCcpOwoJCQlsYXN0X2xmID0gMDsKCQl9CgkJZWxzZSB7CgkJCXB1dGNoYXIoJ1xuJyk7CgkJCWxhc3RfbGYgPSAxOwoJCX0KCX0KCglpZiAoIWxhc3RfbGYpCgkJcHV0Y2hhcignXG4nKTsKfQpzdHJ1Y3QgbGlzdF9hbmRfY2hvb3NlX29wdGlvbnMgewoJc3RydWN0IGxpc3Rfb3B0aW9ucyBsaXN0X29wdHM7CgoJY29uc3QgY2hhciAqcHJvbXB0OwoJZW51bSB7CgkJU0lOR0xFVE9OID0gKDE8PDApLAoJCUlNTUVESUFURSA9ICgxPDwxKSwKCX0gZmxhZ3M7Cgl2b2lkICgqcHJpbnRfaGVscCkoc3RydWN0IGFkZF9pX3N0YXRlICpzKTsKfTsKCiNkZWZpbmUgTElTVF9BTkRfQ0hPT1NFX0VSUk9SICgtMSkKI2RlZmluZSBMSVNUX0FORF9DSE9PU0VfUVVJVCAgKC0yKQoKLyoKICogUmV0dXJucyB0aGUgc2VsZWN0ZWQgaW5kZXggaW4gc2luZ2xldG9uIG1vZGUsIHRoZSBudW1iZXIgb2Ygc2VsZWN0ZWQgaXRlbXMKICogb3RoZXJ3aXNlLgogKgogKiBJZiBhbiBlcnJvciBvY2N1cnJlZCwgcmV0dXJucyBgTElTVF9BTkRfQ0hPT1NFX0VSUk9SYC4gVXBvbiBFT0YsCiAqIGBMSVNUX0FORF9DSE9PU0VfUVVJVGAgaXMgcmV0dXJuZWQuCiAqLwpzdGF0aWMgc3NpemVfdCBsaXN0X2FuZF9jaG9vc2Uoc3RydWN0IGFkZF9pX3N0YXRlICpzLAoJCQkgICAgICAgc3RydWN0IHByZWZpeF9pdGVtX2xpc3QgKml0ZW1zLAoJCQkgICAgICAgc3RydWN0IGxpc3RfYW5kX2Nob29zZV9vcHRpb25zICpvcHRzKQp7CglpbnQgc2luZ2xldG9uID0gb3B0cy0+ZmxhZ3MgJiBTSU5HTEVUT047CglpbnQgaW1tZWRpYXRlID0gb3B0cy0+ZmxhZ3MgJiBJTU1FRElBVEU7CgoJc3RydWN0IHN0cmJ1ZiBpbnB1dCA9IFNUUkJVRl9JTklUOwoJc3NpemVfdCByZXMgPSBzaW5nbGV0b24gPyBMSVNUX0FORF9DSE9PU0VfRVJST1IgOiAwOwoKCWlmICghc2luZ2xldG9uKSB7CgkJZnJlZShpdGVtcy0+c2VsZWN0ZWQpOwoJCUNBTExPQ19BUlJBWShpdGVtcy0+c2VsZWN0ZWQsIGl0ZW1zLT5pdGVtcy5ucik7Cgl9CgoJaWYgKHNpbmdsZXRvbiAmJiAhaW1tZWRpYXRlKQoJCUJVRygic2luZ2xldG9uIHJlcXVpcmVzIGltbWVkaWF0ZSIpOwoKCWZpbmRfdW5pcXVlX3ByZWZpeGVzKGl0ZW1zKTsKCglmb3IgKDs7KSB7CgkJY2hhciAqcDsKCgkJc3RyYnVmX3Jlc2V0KCZpbnB1dCk7CgoJCWxpc3QocywgJml0ZW1zLT5pdGVtcywgaXRlbXMtPnNlbGVjdGVkLCAmb3B0cy0+bGlzdF9vcHRzKTsKCgkJY29sb3JfZnByaW50ZihzdGRvdXQsIHMtPnByb21wdF9jb2xvciwgIiVzIiwgb3B0cy0+cHJvbXB0KTsKCQlmcHV0cyhzaW5nbGV0b24gPyAiPiAiIDogIj4+ICIsIHN0ZG91dCk7CgkJZmZsdXNoKHN0ZG91dCk7CgoJCWlmIChnaXRfcmVhZF9saW5lX2ludGVyYWN0aXZlbHkoJmlucHV0KSA9PSBFT0YpIHsKCQkJcHV0Y2hhcignXG4nKTsKCQkJaWYgKGltbWVkaWF0ZSkKCQkJCXJlcyA9IExJU1RfQU5EX0NIT09TRV9RVUlUOwoJCQlicmVhazsKCQl9CgoJCWlmICghaW5wdXQubGVuKQoJCQlicmVhazsKCgkJaWYgKCFzdHJjbXAoaW5wdXQuYnVmLCAiPyIpKSB7CgkJCW9wdHMtPnByaW50X2hlbHAocyk7CgkJCWNvbnRpbnVlOwoJCX0KCgkJcCA9IGlucHV0LmJ1ZjsKCQlmb3IgKDs7KSB7CgkJCXNpemVfdCBzZXAgPSBzdHJjc3BuKHAsICIgXHRcclxuLCIpOwoJCQlpbnQgY2hvb3NlID0gMTsKCQkJLyogYGZyb21gIGlzIGluY2x1c2l2ZSwgYHRvYCBpcyBleGNsdXNpdmUgKi8KCQkJc3NpemVfdCBmcm9tID0gLTEsIHRvID0gLTE7CgoJCQlpZiAoIXNlcCkgewoJCQkJaWYgKCEqcCkKCQkJCQlicmVhazsKCQkJCXArKzsKCQkJCWNvbnRpbnVlOwoJCQl9CgoJCQkvKiBJbnB1dCB0aGF0IGJlZ2lucyB3aXRoICctJzsgZGUtc2VsZWN0ICovCgkJCWlmICgqcCA9PSAnLScpIHsKCQkJCWNob29zZSA9IDA7CgkJCQlwKys7CgkJCQlzZXAtLTsKCQkJfQoKCQkJaWYgKHNlcCA9PSAxICYmICpwID09ICcqJykgewoJCQkJZnJvbSA9IDA7CgkJCQl0byA9IGl0ZW1zLT5pdGVtcy5ucjsKCQkJfSBlbHNlIGlmIChpc2RpZ2l0KCpwKSkgewoJCQkJY2hhciAqZW5kcDsKCQkJCS8qCgkJCQkgKiBBIHJhbmdlIGNhbiBiZSBzcGVjaWZpZWQgbGlrZSA1LTcgb3IgNS0uCgkJCQkgKgoJCQkJICogTm90ZTogYGZyb21gIGlzIDAtYmFzZWQgd2hpbGUgdGhlIHVzZXIgaW5wdXQKCQkJCSAqIGlzIDEtYmFzZWQsIGhlbmNlIHdlIGhhdmUgdG8gZGVjcmVtZW50IGJ5CgkJCQkgKiBvbmUuIFdlIGRvIG5vdCBoYXZlIHRvIGRlY3JlbWVudCBgdG9gIGV2ZW4KCQkJCSAqIGlmIGl0IGlzIDAtYmFzZWQgYmVjYXVzZSBpdCBpcyBhbiBleGNsdXNpdmUKCQkJCSAqIGJvdW5kYXJ5LgoJCQkJICovCgkJCQlmcm9tID0gc3RydG91bChwLCAmZW5kcCwgMTApIC0gMTsKCQkJCWlmIChlbmRwID09IHAgKyBzZXApCgkJCQkJdG8gPSBmcm9tICsgMTsKCQkJCWVsc2UgaWYgKCplbmRwID09ICctJykgewoJCQkJCWlmIChpc2RpZ2l0KCooKytlbmRwKSkpCgkJCQkJCXRvID0gc3RydG91bChlbmRwLCAmZW5kcCwgMTApOwoJCQkJCWVsc2UKCQkJCQkJdG8gPSBpdGVtcy0+aXRlbXMubnI7CgkJCQkJLyogZXh0cmEgY2hhcmFjdGVycyBhZnRlciB0aGUgcmFuZ2U/ICovCgkJCQkJaWYgKGVuZHAgIT0gcCArIHNlcCkKCQkJCQkJZnJvbSA9IC0xOwoJCQkJfQoJCQl9CgoJCQlpZiAocFtzZXBdKQoJCQkJcFtzZXArK10gPSAnXDAnOwoJCQlpZiAoZnJvbSA8IDApIHsKCQkJCWZyb20gPSBmaW5kX3VuaXF1ZShwLCBpdGVtcyk7CgkJCQlpZiAoZnJvbSA+PSAwKQoJCQkJCXRvID0gZnJvbSArIDE7CgkJCX0KCgkJCWlmIChmcm9tIDwgMCB8fCBmcm9tID49IGl0ZW1zLT5pdGVtcy5uciB8fAoJCQkgICAgKHNpbmdsZXRvbiAmJiBmcm9tICsgMSAhPSB0bykpIHsKCQkJCWNvbG9yX2ZwcmludGZfbG4oc3RkZXJyLCBzLT5lcnJvcl9jb2xvciwKCQkJCQkJIF8oIkh1aCAoJXMpPyIpLCBwKTsKCQkJCWJyZWFrOwoJCQl9IGVsc2UgaWYgKHNpbmdsZXRvbikgewoJCQkJcmVzID0gZnJvbTsKCQkJCWJyZWFrOwoJCQl9CgoJCQlpZiAodG8gPiBpdGVtcy0+aXRlbXMubnIpCgkJCQl0byA9IGl0ZW1zLT5pdGVtcy5ucjsKCgkJCWZvciAoOyBmcm9tIDwgdG87IGZyb20rKykKCQkJCWlmIChpdGVtcy0+c2VsZWN0ZWRbZnJvbV0gIT0gY2hvb3NlKSB7CgkJCQkJaXRlbXMtPnNlbGVjdGVkW2Zyb21dID0gY2hvb3NlOwoJCQkJCXJlcyArPSBjaG9vc2UgPyArMSA6IC0xOwoJCQkJfQoKCQkJcCArPSBzZXA7CgkJfQoKCQlpZiAoKGltbWVkaWF0ZSAmJiByZXMgIT0gTElTVF9BTkRfQ0hPT1NFX0VSUk9SKSB8fAoJCSAgICAhc3RyY21wKGlucHV0LmJ1ZiwgIioiKSkKCQkJYnJlYWs7Cgl9CgoJc3RyYnVmX3JlbGVhc2UoJmlucHV0KTsKCXJldHVybiByZXM7Cn0KCnN0cnVjdCBhZGRkZWwgewoJdWludG1heF90IGFkZCwgZGVsOwoJdW5zaWduZWQgc2VlbjoxLCB1bm1lcmdlZDoxLCBiaW5hcnk6MTsKfTsKCnN0cnVjdCBmaWxlX2l0ZW0gewoJc2l6ZV90IHByZWZpeF9sZW5ndGg7CglzdHJ1Y3QgYWRkZGVsIGluZGV4LCB3b3JrdHJlZTsKfTsKCnN0YXRpYyB2b2lkIGFkZF9maWxlX2l0ZW0oc3RydWN0IHN0cmluZ19saXN0ICpmaWxlcywgY29uc3QgY2hhciAqbmFtZSkKewoJc3RydWN0IGZpbGVfaXRlbSAqaXRlbSA9IHhjYWxsb2MoMSwgc2l6ZW9mKCppdGVtKSk7CgoJc3RyaW5nX2xpc3RfYXBwZW5kKGZpbGVzLCBuYW1lKS0+dXRpbCA9IGl0ZW07Cn0KCnN0cnVjdCBwYXRobmFtZV9lbnRyeSB7CglzdHJ1Y3QgaGFzaG1hcF9lbnRyeSBlbnQ7Cgljb25zdCBjaGFyICpuYW1lOwoJc3RydWN0IGZpbGVfaXRlbSAqaXRlbTsKfTsKCnN0YXRpYyBpbnQgcGF0aG5hbWVfZW50cnlfY21wKGNvbnN0IHZvaWQgKmNtcF9kYXRhIFVOVVNFRCwKCQkJICAgICAgY29uc3Qgc3RydWN0IGhhc2htYXBfZW50cnkgKmhlMSwKCQkJICAgICAgY29uc3Qgc3RydWN0IGhhc2htYXBfZW50cnkgKmhlMiwKCQkJICAgICAgY29uc3Qgdm9pZCAqbmFtZSkKewoJY29uc3Qgc3RydWN0IHBhdGhuYW1lX2VudHJ5ICplMSA9CgkJY29udGFpbmVyX29mKGhlMSwgY29uc3Qgc3RydWN0IHBhdGhuYW1lX2VudHJ5LCBlbnQpOwoJY29uc3Qgc3RydWN0IHBhdGhuYW1lX2VudHJ5ICplMiA9CgkJY29udGFpbmVyX29mKGhlMiwgY29uc3Qgc3RydWN0IHBhdGhuYW1lX2VudHJ5LCBlbnQpOwoKCXJldHVybiBzdHJjbXAoZTEtPm5hbWUsIG5hbWUgPyAoY29uc3QgY2hhciAqKW5hbWUgOiBlMi0+bmFtZSk7Cn0KCnN0cnVjdCBjb2xsZWN0aW9uX3N0YXR1cyB7CgllbnVtIHsgRlJPTV9XT1JLVFJFRSA9IDAsIEZST01fSU5ERVggPSAxIH0gbW9kZTsKCgljb25zdCBjaGFyICpyZWZlcmVuY2U7CgoJdW5zaWduZWQgc2tpcF91bnNlZW46MTsKCXNpemVfdCB1bm1lcmdlZF9jb3VudCwgYmluYXJ5X2NvdW50OwoJc3RydWN0IHN0cmluZ19saXN0ICpmaWxlczsKCXN0cnVjdCBoYXNobWFwIGZpbGVfbWFwOwp9OwoKc3RhdGljIHZvaWQgY29sbGVjdF9jaGFuZ2VzX2NiKHN0cnVjdCBkaWZmX3F1ZXVlX3N0cnVjdCAqcSwKCQkJICAgICAgIHN0cnVjdCBkaWZmX29wdGlvbnMgKm9wdGlvbnMsCgkJCSAgICAgICB2b2lkICpkYXRhKQp7CglzdHJ1Y3QgY29sbGVjdGlvbl9zdGF0dXMgKnMgPSBkYXRhOwoJc3RydWN0IGRpZmZzdGF0X3Qgc3RhdCA9IHsgMCB9OwoJaW50IGk7CgoJaWYgKCFxLT5ucikKCQlyZXR1cm47CgoJY29tcHV0ZV9kaWZmc3RhdChvcHRpb25zLCAmc3RhdCwgcSk7CgoJZm9yIChpID0gMDsgaSA8IHN0YXQubnI7IGkrKykgewoJCWNvbnN0IGNoYXIgKm5hbWUgPSBzdGF0LmZpbGVzW2ldLT5uYW1lOwoJCWludCBoYXNoID0gc3RyaGFzaChuYW1lKTsKCQlzdHJ1Y3QgcGF0aG5hbWVfZW50cnkgKmVudHJ5OwoJCXN0cnVjdCBmaWxlX2l0ZW0gKmZpbGVfaXRlbTsKCQlzdHJ1Y3QgYWRkZGVsICphZGRkZWwsICpvdGhlcl9hZGRkZWw7CgoJCWVudHJ5ID0gaGFzaG1hcF9nZXRfZW50cnlfZnJvbV9oYXNoKCZzLT5maWxlX21hcCwgaGFzaCwgbmFtZSwKCQkJCQkJICAgIHN0cnVjdCBwYXRobmFtZV9lbnRyeSwgZW50KTsKCQlpZiAoIWVudHJ5KSB7CgkJCWlmIChzLT5za2lwX3Vuc2VlbikKCQkJCWNvbnRpbnVlOwoKCQkJYWRkX2ZpbGVfaXRlbShzLT5maWxlcywgbmFtZSk7CgoJCQlDQUxMT0NfQVJSQVkoZW50cnksIDEpOwoJCQloYXNobWFwX2VudHJ5X2luaXQoJmVudHJ5LT5lbnQsIGhhc2gpOwoJCQllbnRyeS0+bmFtZSA9IHMtPmZpbGVzLT5pdGVtc1tzLT5maWxlcy0+bnIgLSAxXS5zdHJpbmc7CgkJCWVudHJ5LT5pdGVtID0gcy0+ZmlsZXMtPml0ZW1zW3MtPmZpbGVzLT5uciAtIDFdLnV0aWw7CgkJCWhhc2htYXBfYWRkKCZzLT5maWxlX21hcCwgJmVudHJ5LT5lbnQpOwoJCX0KCgkJZmlsZV9pdGVtID0gZW50cnktPml0ZW07CgkJYWRkZGVsID0gcy0+bW9kZSA9PSBGUk9NX0lOREVYID8KCQkJJmZpbGVfaXRlbS0+aW5kZXggOiAmZmlsZV9pdGVtLT53b3JrdHJlZTsKCQlvdGhlcl9hZGRkZWwgPSBzLT5tb2RlID09IEZST01fSU5ERVggPwoJCQkmZmlsZV9pdGVtLT53b3JrdHJlZSA6ICZmaWxlX2l0ZW0tPmluZGV4OwoJCWFkZGRlbC0+c2VlbiA9IDE7CgkJYWRkZGVsLT5hZGQgPSBzdGF0LmZpbGVzW2ldLT5hZGRlZDsKCQlhZGRkZWwtPmRlbCA9IHN0YXQuZmlsZXNbaV0tPmRlbGV0ZWQ7CgkJaWYgKHN0YXQuZmlsZXNbaV0tPmlzX2JpbmFyeSkgewoJCQlpZiAoIW90aGVyX2FkZGRlbC0+YmluYXJ5KQoJCQkJcy0+YmluYXJ5X2NvdW50Kys7CgkJCWFkZGRlbC0+YmluYXJ5ID0gMTsKCQl9CgkJaWYgKHN0YXQuZmlsZXNbaV0tPmlzX3VubWVyZ2VkKSB7CgkJCWlmICghb3RoZXJfYWRkZGVsLT51bm1lcmdlZCkKCQkJCXMtPnVubWVyZ2VkX2NvdW50Kys7CgkJCWFkZGRlbC0+dW5tZXJnZWQgPSAxOwoJCX0KCX0KCWZyZWVfZGlmZnN0YXRfaW5mbygmc3RhdCk7Cn0KCmVudW0gbW9kaWZpZWRfZmlsZXNfZmlsdGVyIHsKCU5PX0ZJTFRFUiA9IDAsCglXT1JLVFJFRV9PTkxZID0gMSwKCUlOREVYX09OTFkgPSAyLAp9OwoKc3RhdGljIGludCBnZXRfbW9kaWZpZWRfZmlsZXMoc3RydWN0IHJlcG9zaXRvcnkgKnIsCgkJCSAgICAgIGVudW0gbW9kaWZpZWRfZmlsZXNfZmlsdGVyIGZpbHRlciwKCQkJICAgICAgc3RydWN0IHByZWZpeF9pdGVtX2xpc3QgKmZpbGVzLAoJCQkgICAgICBjb25zdCBzdHJ1Y3QgcGF0aHNwZWMgKnBzLAoJCQkgICAgICBzaXplX3QgKnVubWVyZ2VkX2NvdW50LAoJCQkgICAgICBzaXplX3QgKmJpbmFyeV9jb3VudCkKewoJc3RydWN0IG9iamVjdF9pZCBoZWFkX29pZDsKCWludCBpc19pbml0aWFsID0gIXJlc29sdmVfcmVmX3Vuc2FmZSgiSEVBRCIsIFJFU09MVkVfUkVGX1JFQURJTkcsCgkJCQkJICAgICAmaGVhZF9vaWQsIE5VTEwpOwoJc3RydWN0IGNvbGxlY3Rpb25fc3RhdHVzIHMgPSB7IDAgfTsKCWludCBpOwoKCWRpc2NhcmRfaW5kZXgoci0+aW5kZXgpOwoJaWYgKHJlcG9fcmVhZF9pbmRleF9wcmVsb2FkKHIsIHBzLCAwKSA8IDApCgkJcmV0dXJuIGVycm9yKF8oImNvdWxkIG5vdCByZWFkIGluZGV4IikpOwoKCXByZWZpeF9pdGVtX2xpc3RfY2xlYXIoZmlsZXMpOwoJcy5maWxlcyA9ICZmaWxlcy0+aXRlbXM7CgloYXNobWFwX2luaXQoJnMuZmlsZV9tYXAsIHBhdGhuYW1lX2VudHJ5X2NtcCwgTlVMTCwgMCk7CgoJZm9yIChpID0gMDsgaSA8IDI7IGkrKykgewoJCXN0cnVjdCByZXZfaW5mbyByZXY7CgkJc3RydWN0IHNldHVwX3JldmlzaW9uX29wdCBvcHQgPSB7IDAgfTsKCgkJaWYgKGZpbHRlciA9PSBJTkRFWF9PTkxZKQoJCQlzLm1vZGUgPSAoaSA9PSAwKSA/IEZST01fSU5ERVggOiBGUk9NX1dPUktUUkVFOwoJCWVsc2UKCQkJcy5tb2RlID0gKGkgPT0gMCkgPyBGUk9NX1dPUktUUkVFIDogRlJPTV9JTkRFWDsKCQlzLnNraXBfdW5zZWVuID0gZmlsdGVyICYmIGk7CgoJCW9wdC5kZWYgPSBpc19pbml0aWFsID8KCQkJZW1wdHlfdHJlZV9vaWRfaGV4KCkgOiBvaWRfdG9faGV4KCZoZWFkX29pZCk7CgoJCWluaXRfcmV2aXNpb25zKCZyZXYsIE5VTEwpOwoJCXNldHVwX3JldmlzaW9ucygwLCBOVUxMLCAmcmV2LCAmb3B0KTsKCgkJcmV2LmRpZmZvcHQub3V0cHV0X2Zvcm1hdCA9IERJRkZfRk9STUFUX0NBTExCQUNLOwoJCXJldi5kaWZmb3B0LmZvcm1hdF9jYWxsYmFjayA9IGNvbGxlY3RfY2hhbmdlc19jYjsKCQlyZXYuZGlmZm9wdC5mb3JtYXRfY2FsbGJhY2tfZGF0YSA9ICZzOwoKCQlpZiAocHMpCgkJCWNvcHlfcGF0aHNwZWMoJnJldi5wcnVuZV9kYXRhLCBwcyk7CgoJCWlmIChzLm1vZGUgPT0gRlJPTV9JTkRFWCkKCQkJcnVuX2RpZmZfaW5kZXgoJnJldiwgMSk7CgkJZWxzZSB7CgkJCXJldi5kaWZmb3B0LmZsYWdzLmlnbm9yZV9kaXJ0eV9zdWJtb2R1bGVzID0gMTsKCQkJcnVuX2RpZmZfZmlsZXMoJnJldiwgMCk7CgkJfQoKCQlyZWxlYXNlX3JldmlzaW9ucygmcmV2KTsKCX0KCWhhc2htYXBfY2xlYXJfYW5kX2ZyZWUoJnMuZmlsZV9tYXAsIHN0cnVjdCBwYXRobmFtZV9lbnRyeSwgZW50KTsKCWlmICh1bm1lcmdlZF9jb3VudCkKCQkqdW5tZXJnZWRfY291bnQgPSBzLnVubWVyZ2VkX2NvdW50OwoJaWYgKGJpbmFyeV9jb3VudCkKCQkqYmluYXJ5X2NvdW50ID0gcy5iaW5hcnlfY291bnQ7CgoJLyogV2hpbGUgdGhlIGRpZmZzIGFyZSBvcmRlcmVkIGFscmVhZHksIHdlIHJhbiAqdHdvKiBkaWZmcy4uLiAqLwoJc3RyaW5nX2xpc3Rfc29ydCgmZmlsZXMtPml0ZW1zKTsKCglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgcmVuZGVyX2FkZGRlbChzdHJ1Y3Qgc3RyYnVmICpidWYsCgkJCQlzdHJ1Y3QgYWRkZGVsICphZCwgY29uc3QgY2hhciAqbm9fY2hhbmdlcykKewoJaWYgKGFkLT5iaW5hcnkpCgkJc3RyYnVmX2FkZHN0cihidWYsIF8oImJpbmFyeSIpKTsKCWVsc2UgaWYgKGFkLT5zZWVuKQoJCXN0cmJ1Zl9hZGRmKGJ1ZiwgIislIlBSSXVNQVgiLy0lIlBSSXVNQVgsCgkJCSAgICAodWludG1heF90KWFkLT5hZGQsICh1aW50bWF4X3QpYWQtPmRlbCk7CgllbHNlCgkJc3RyYnVmX2FkZHN0cihidWYsIG5vX2NoYW5nZXMpOwp9CgovKiBmaWx0ZXJzIG91dCBwcmVmaXhlcyB3aGljaCBoYXZlIHNwZWNpYWwgbWVhbmluZyB0byBsaXN0X2FuZF9jaG9vc2UoKSAqLwpzdGF0aWMgaW50IGlzX3ZhbGlkX3ByZWZpeChjb25zdCBjaGFyICpwcmVmaXgsIHNpemVfdCBwcmVmaXhfbGVuKQp7CglyZXR1cm4gcHJlZml4X2xlbiAmJiBwcmVmaXggJiYKCQkvKgoJCSAqIFdlIGV4cGVjdCBgcHJlZml4YCB0byBiZSBOVUwgdGVybWluYXRlZCwgdGhlcmVmb3JlIHRoaXMKCQkgKiBgc3RyY3NwbigpYCBjYWxsIGlzIG9rYXksIGV2ZW4gaWYgaXQgbWlnaHQgZG8gbXVjaCBtb3JlCgkJICogd29yayB0aGFuIHN0cmljdGx5IG5lY2Vzc2FyeS4KCQkgKi8KCQlzdHJjc3BuKHByZWZpeCwgIiBcdFxyXG4sIikgPj0gcHJlZml4X2xlbiAmJgkvKiBzZXBhcmF0b3JzICovCgkJKnByZWZpeCAhPSAnLScgJiYJCQkJLyogZGVzZWxlY3Rpb24gKi8KCQkhaXNkaWdpdCgqcHJlZml4KSAmJgkJCQkvKiBzZWxlY3Rpb24gKi8KCQkocHJlZml4X2xlbiAhPSAxIHx8CgkJICgqcHJlZml4ICE9ICcqJyAmJgkJCQkvKiAiYWxsIiB3aWxkY2FyZCAqLwoJCSAgKnByZWZpeCAhPSAnPycpKTsJCQkJLyogcHJvbXB0IGhlbHAgKi8KfQoKc3RydWN0IHByaW50X2ZpbGVfaXRlbV9kYXRhIHsKCWNvbnN0IGNoYXIgKm1vZGlmaWVkX2ZtdCwgKmNvbG9yLCAqcmVzZXQ7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiwgbmFtZSwgaW5kZXgsIHdvcmt0cmVlOwoJdW5zaWduZWQgb25seV9uYW1lczoxOwp9OwoKc3RhdGljIHZvaWQgcHJpbnRfZmlsZV9pdGVtKGludCBpLCBpbnQgc2VsZWN0ZWQsIHN0cnVjdCBzdHJpbmdfbGlzdF9pdGVtICppdGVtLAoJCQkgICAgdm9pZCAqcHJpbnRfZmlsZV9pdGVtX2RhdGEpCnsKCXN0cnVjdCBmaWxlX2l0ZW0gKmMgPSBpdGVtLT51dGlsOwoJc3RydWN0IHByaW50X2ZpbGVfaXRlbV9kYXRhICpkID0gcHJpbnRfZmlsZV9pdGVtX2RhdGE7Cgljb25zdCBjaGFyICpoaWdobGlnaHRlZCA9IE5VTEw7CgoJc3RyYnVmX3Jlc2V0KCZkLT5pbmRleCk7CglzdHJidWZfcmVzZXQoJmQtPndvcmt0cmVlKTsKCXN0cmJ1Zl9yZXNldCgmZC0+YnVmKTsKCgkvKiBGb3JtYXQgdGhlIGl0ZW0gd2l0aCB0aGUgcHJlZml4IGhpZ2hsaWdodGVkLiAqLwoJaWYgKGMtPnByZWZpeF9sZW5ndGggPiAwICYmCgkgICAgaXNfdmFsaWRfcHJlZml4KGl0ZW0tPnN0cmluZywgYy0+cHJlZml4X2xlbmd0aCkpIHsKCQlzdHJidWZfcmVzZXQoJmQtPm5hbWUpOwoJCXN0cmJ1Zl9hZGRmKCZkLT5uYW1lLCAiJXMlLipzJXMlcyIsIGQtPmNvbG9yLAoJCQkgICAgKGludCljLT5wcmVmaXhfbGVuZ3RoLCBpdGVtLT5zdHJpbmcsIGQtPnJlc2V0LAoJCQkgICAgaXRlbS0+c3RyaW5nICsgYy0+cHJlZml4X2xlbmd0aCk7CgkJaGlnaGxpZ2h0ZWQgPSBkLT5uYW1lLmJ1ZjsKCX0KCglpZiAoZC0+b25seV9uYW1lcykgewoJCXByaW50ZigiJWMlMmQ6ICVzIiwgc2VsZWN0ZWQgPyAnKicgOiAnICcsIGkgKyAxLAoJCSAgICAgICBoaWdobGlnaHRlZCA/IGhpZ2hsaWdodGVkIDogaXRlbS0+c3RyaW5nKTsKCQlyZXR1cm47Cgl9CgoJcmVuZGVyX2FkZGRlbCgmZC0+d29ya3RyZWUsICZjLT53b3JrdHJlZSwgXygibm90aGluZyIpKTsKCXJlbmRlcl9hZGRkZWwoJmQtPmluZGV4LCAmYy0+aW5kZXgsIF8oInVuY2hhbmdlZCIpKTsKCglzdHJidWZfYWRkZigmZC0+YnVmLCBkLT5tb2RpZmllZF9mbXQsIGQtPmluZGV4LmJ1ZiwgZC0+d29ya3RyZWUuYnVmLAoJCSAgICBoaWdobGlnaHRlZCA/IGhpZ2hsaWdodGVkIDogaXRlbS0+c3RyaW5nKTsKCglwcmludGYoIiVjJTJkOiAlcyIsIHNlbGVjdGVkID8gJyonIDogJyAnLCBpICsgMSwgZC0+YnVmLmJ1Zik7Cn0KCnN0YXRpYyBpbnQgcnVuX3N0YXR1cyhzdHJ1Y3QgYWRkX2lfc3RhdGUgKnMsIGNvbnN0IHN0cnVjdCBwYXRoc3BlYyAqcHMsCgkJICAgICAgc3RydWN0IHByZWZpeF9pdGVtX2xpc3QgKmZpbGVzLAoJCSAgICAgIHN0cnVjdCBsaXN0X2FuZF9jaG9vc2Vfb3B0aW9ucyAqb3B0cykKewoJaWYgKGdldF9tb2RpZmllZF9maWxlcyhzLT5yLCBOT19GSUxURVIsIGZpbGVzLCBwcywgTlVMTCwgTlVMTCkgPCAwKQoJCXJldHVybiAtMTsKCglsaXN0KHMsICZmaWxlcy0+aXRlbXMsIE5VTEwsICZvcHRzLT5saXN0X29wdHMpOwoJcHV0Y2hhcignXG4nKTsKCglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBydW5fdXBkYXRlKHN0cnVjdCBhZGRfaV9zdGF0ZSAqcywgY29uc3Qgc3RydWN0IHBhdGhzcGVjICpwcywKCQkgICAgICBzdHJ1Y3QgcHJlZml4X2l0ZW1fbGlzdCAqZmlsZXMsCgkJICAgICAgc3RydWN0IGxpc3RfYW5kX2Nob29zZV9vcHRpb25zICpvcHRzKQp7CglpbnQgcmVzID0gMCwgZmQ7CglzaXplX3QgY291bnQsIGk7CglzdHJ1Y3QgbG9ja19maWxlIGluZGV4X2xvY2s7CgoJaWYgKGdldF9tb2RpZmllZF9maWxlcyhzLT5yLCBXT1JLVFJFRV9PTkxZLCBmaWxlcywgcHMsIE5VTEwsIE5VTEwpIDwgMCkKCQlyZXR1cm4gLTE7CgoJaWYgKCFmaWxlcy0+aXRlbXMubnIpIHsKCQlwdXRjaGFyKCdcbicpOwoJCXJldHVybiAwOwoJfQoKCW9wdHMtPnByb21wdCA9IE5fKCJVcGRhdGUiKTsKCWNvdW50ID0gbGlzdF9hbmRfY2hvb3NlKHMsIGZpbGVzLCBvcHRzKTsKCWlmIChjb3VudCA8PSAwKSB7CgkJcHV0Y2hhcignXG4nKTsKCQlyZXR1cm4gMDsKCX0KCglmZCA9IHJlcG9faG9sZF9sb2NrZWRfaW5kZXgocy0+ciwgJmluZGV4X2xvY2ssIExPQ0tfUkVQT1JUX09OX0VSUk9SKTsKCWlmIChmZCA8IDApIHsKCQlwdXRjaGFyKCdcbicpOwoJCXJldHVybiAtMTsKCX0KCglmb3IgKGkgPSAwOyBpIDwgZmlsZXMtPml0ZW1zLm5yOyBpKyspIHsKCQljb25zdCBjaGFyICpuYW1lID0gZmlsZXMtPml0ZW1zLml0ZW1zW2ldLnN0cmluZzsKCQlzdHJ1Y3Qgc3RhdCBzdDsKCgkJaWYgKCFmaWxlcy0+c2VsZWN0ZWRbaV0pCgkJCWNvbnRpbnVlOwoJCWlmIChsc3RhdChuYW1lLCAmc3QpICYmIGlzX21pc3NpbmdfZmlsZV9lcnJvcihlcnJubykpIHsKCQkJaWYgKHJlbW92ZV9maWxlX2Zyb21faW5kZXgocy0+ci0+aW5kZXgsIG5hbWUpIDwgMCkgewoJCQkJcmVzID0gZXJyb3IoXygiY291bGQgbm90IHN0YWdlICclcyciKSwgbmFtZSk7CgkJCQlicmVhazsKCQkJfQoJCX0gZWxzZSBpZiAoYWRkX2ZpbGVfdG9faW5kZXgocy0+ci0+aW5kZXgsIG5hbWUsIDApIDwgMCkgewoJCQlyZXMgPSBlcnJvcihfKCJjb3VsZCBub3Qgc3RhZ2UgJyVzJyIpLCBuYW1lKTsKCQkJYnJlYWs7CgkJfQoJfQoKCWlmICghcmVzICYmIHdyaXRlX2xvY2tlZF9pbmRleChzLT5yLT5pbmRleCwgJmluZGV4X2xvY2ssIENPTU1JVF9MT0NLKSA8IDApCgkJcmVzID0gZXJyb3IoXygiY291bGQgbm90IHdyaXRlIGluZGV4IikpOwoKCWlmICghcmVzKQoJCXByaW50ZihRXygidXBkYXRlZCAlZCBwYXRoXG4iLAoJCQkgICJ1cGRhdGVkICVkIHBhdGhzXG4iLCBjb3VudCksIChpbnQpY291bnQpOwoKCXB1dGNoYXIoJ1xuJyk7CglyZXR1cm4gcmVzOwp9CgpzdGF0aWMgdm9pZCByZXZlcnRfZnJvbV9kaWZmKHN0cnVjdCBkaWZmX3F1ZXVlX3N0cnVjdCAqcSwKCQkJICAgICBzdHJ1Y3QgZGlmZl9vcHRpb25zICpvcHQsIHZvaWQgKmRhdGEgVU5VU0VEKQp7CglpbnQgaSwgYWRkX2ZsYWdzID0gQUREX0NBQ0hFX09LX1RPX0FERCB8IEFERF9DQUNIRV9PS19UT19SRVBMQUNFOwoKCWZvciAoaSA9IDA7IGkgPCBxLT5ucjsgaSsrKSB7CgkJc3RydWN0IGRpZmZfZmlsZXNwZWMgKm9uZSA9IHEtPnF1ZXVlW2ldLT5vbmU7CgkJc3RydWN0IGNhY2hlX2VudHJ5ICpjZTsKCgkJaWYgKCEob25lLT5tb2RlICYmICFpc19udWxsX29pZCgmb25lLT5vaWQpKSkgewoJCQlyZW1vdmVfZmlsZV9mcm9tX2luZGV4KG9wdC0+cmVwby0+aW5kZXgsIG9uZS0+cGF0aCk7CgkJCXByaW50ZihfKCJub3RlOiAlcyBpcyB1bnRyYWNrZWQgbm93LlxuIiksIG9uZS0+cGF0aCk7CgkJfSBlbHNlIHsKCQkJY2UgPSBtYWtlX2NhY2hlX2VudHJ5KG9wdC0+cmVwby0+aW5kZXgsIG9uZS0+bW9kZSwKCQkJCQkgICAgICAmb25lLT5vaWQsIG9uZS0+cGF0aCwgMCwgMCk7CgkJCWlmICghY2UpCgkJCQlkaWUoXygibWFrZV9jYWNoZV9lbnRyeSBmYWlsZWQgZm9yIHBhdGggJyVzJyIpLAoJCQkJICAgIG9uZS0+cGF0aCk7CgkJCWFkZF9pbmRleF9lbnRyeShvcHQtPnJlcG8tPmluZGV4LCBjZSwgYWRkX2ZsYWdzKTsKCQl9Cgl9Cn0KCnN0YXRpYyBpbnQgcnVuX3JldmVydChzdHJ1Y3QgYWRkX2lfc3RhdGUgKnMsIGNvbnN0IHN0cnVjdCBwYXRoc3BlYyAqcHMsCgkJICAgICAgc3RydWN0IHByZWZpeF9pdGVtX2xpc3QgKmZpbGVzLAoJCSAgICAgIHN0cnVjdCBsaXN0X2FuZF9jaG9vc2Vfb3B0aW9ucyAqb3B0cykKewoJaW50IHJlcyA9IDAsIGZkOwoJc2l6ZV90IGNvdW50LCBpLCBqOwoKCXN0cnVjdCBvYmplY3RfaWQgb2lkOwoJaW50IGlzX2luaXRpYWwgPSAhcmVzb2x2ZV9yZWZfdW5zYWZlKCJIRUFEIiwgUkVTT0xWRV9SRUZfUkVBRElORywgJm9pZCwKCQkJCQkgICAgIE5VTEwpOwoJc3RydWN0IGxvY2tfZmlsZSBpbmRleF9sb2NrOwoJY29uc3QgY2hhciAqKnBhdGhzOwoJc3RydWN0IHRyZWUgKnRyZWU7CglzdHJ1Y3QgZGlmZl9vcHRpb25zIGRpZmZvcHQgPSB7IE5VTEwgfTsKCglpZiAoZ2V0X21vZGlmaWVkX2ZpbGVzKHMtPnIsIElOREVYX09OTFksIGZpbGVzLCBwcywgTlVMTCwgTlVMTCkgPCAwKQoJCXJldHVybiAtMTsKCglpZiAoIWZpbGVzLT5pdGVtcy5ucikgewoJCXB1dGNoYXIoJ1xuJyk7CgkJcmV0dXJuIDA7Cgl9CgoJb3B0cy0+cHJvbXB0ID0gTl8oIlJldmVydCIpOwoJY291bnQgPSBsaXN0X2FuZF9jaG9vc2UocywgZmlsZXMsIG9wdHMpOwoJaWYgKGNvdW50IDw9IDApCgkJZ290byBmaW5pc2hfcmV2ZXJ0OwoKCWZkID0gcmVwb19ob2xkX2xvY2tlZF9pbmRleChzLT5yLCAmaW5kZXhfbG9jaywgTE9DS19SRVBPUlRfT05fRVJST1IpOwoJaWYgKGZkIDwgMCkgewoJCXJlcyA9IC0xOwoJCWdvdG8gZmluaXNoX3JldmVydDsKCX0KCglpZiAoaXNfaW5pdGlhbCkKCQlvaWRjcHkoJm9pZCwgcy0+ci0+aGFzaF9hbGdvLT5lbXB0eV90cmVlKTsKCWVsc2UgewoJCXRyZWUgPSBwYXJzZV90cmVlX2luZGlyZWN0KCZvaWQpOwoJCWlmICghdHJlZSkgewoJCQlyZXMgPSBlcnJvcihfKCJDb3VsZCBub3QgcGFyc2UgSEVBRF57dHJlZX0iKSk7CgkJCWdvdG8gZmluaXNoX3JldmVydDsKCQl9CgkJb2lkY3B5KCZvaWQsICZ0cmVlLT5vYmplY3Qub2lkKTsKCX0KCglBTExPQ19BUlJBWShwYXRocywgY291bnQgKyAxKTsKCWZvciAoaSA9IGogPSAwOyBpIDwgZmlsZXMtPml0ZW1zLm5yOyBpKyspCgkJaWYgKGZpbGVzLT5zZWxlY3RlZFtpXSkKCQkJcGF0aHNbaisrXSA9IGZpbGVzLT5pdGVtcy5pdGVtc1tpXS5zdHJpbmc7CglwYXRoc1tqXSA9IE5VTEw7CgoJcGFyc2VfcGF0aHNwZWMoJmRpZmZvcHQucGF0aHNwZWMsIDAsCgkJICAgICAgIFBBVEhTUEVDX1BSRUZFUl9GVUxMIHwgUEFUSFNQRUNfTElURVJBTF9QQVRILAoJCSAgICAgICBOVUxMLCBwYXRocyk7CgoJZGlmZm9wdC5vdXRwdXRfZm9ybWF0ID0gRElGRl9GT1JNQVRfQ0FMTEJBQ0s7CglkaWZmb3B0LmZvcm1hdF9jYWxsYmFjayA9IHJldmVydF9mcm9tX2RpZmY7CglkaWZmb3B0LmZsYWdzLm92ZXJyaWRlX3N1Ym1vZHVsZV9jb25maWcgPSAxOwoJZGlmZm9wdC5yZXBvID0gcy0+cjsKCglpZiAoZG9fZGlmZl9jYWNoZSgmb2lkLCAmZGlmZm9wdCkpIHsKCQlkaWZmX2ZyZWUoJmRpZmZvcHQpOwoJCXJlcyA9IC0xOwoJfSBlbHNlIHsKCQlkaWZmY29yZV9zdGQoJmRpZmZvcHQpOwoJCWRpZmZfZmx1c2goJmRpZmZvcHQpOwoJfQoJZnJlZShwYXRocyk7CgoJaWYgKCFyZXMgJiYgd3JpdGVfbG9ja2VkX2luZGV4KHMtPnItPmluZGV4LCAmaW5kZXhfbG9jaywKCQkJCSAgICAgICBDT01NSVRfTE9DSykgPCAwKQoJCXJlcyA9IC0xOwoJZWxzZQoJCXJlcyA9IHJlcG9fcmVmcmVzaF9hbmRfd3JpdGVfaW5kZXgocy0+ciwgUkVGUkVTSF9RVUlFVCwgMCwgMSwKCQkJCQkJICAgTlVMTCwgTlVMTCwgTlVMTCk7CgoJaWYgKCFyZXMpCgkJcHJpbnRmKFFfKCJyZXZlcnRlZCAlZCBwYXRoXG4iLAoJCQkgICJyZXZlcnRlZCAlZCBwYXRoc1xuIiwgY291bnQpLCAoaW50KWNvdW50KTsKCmZpbmlzaF9yZXZlcnQ6CglwdXRjaGFyKCdcbicpOwoJcmV0dXJuIHJlczsKfQoKc3RhdGljIGludCBnZXRfdW50cmFja2VkX2ZpbGVzKHN0cnVjdCByZXBvc2l0b3J5ICpyLAoJCQkgICAgICAgc3RydWN0IHByZWZpeF9pdGVtX2xpc3QgKmZpbGVzLAoJCQkgICAgICAgY29uc3Qgc3RydWN0IHBhdGhzcGVjICpwcykKewoJc3RydWN0IGRpcl9zdHJ1Y3QgZGlyID0geyAwIH07CglzaXplX3QgaTsKCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7CgoJaWYgKHJlcG9fcmVhZF9pbmRleChyKSA8IDApCgkJcmV0dXJuIGVycm9yKF8oImNvdWxkIG5vdCByZWFkIGluZGV4IikpOwoKCXByZWZpeF9pdGVtX2xpc3RfY2xlYXIoZmlsZXMpOwoJc2V0dXBfc3RhbmRhcmRfZXhjbHVkZXMoJmRpcik7CglhZGRfcGF0dGVybl9saXN0KCZkaXIsIEVYQ19DTURMLCAiLS1leGNsdWRlIG9wdGlvbiIpOwoJZmlsbF9kaXJlY3RvcnkoJmRpciwgci0+aW5kZXgsIHBzKTsKCglmb3IgKGkgPSAwOyBpIDwgZGlyLm5yOyBpKyspIHsKCQlzdHJ1Y3QgZGlyX2VudHJ5ICplbnQgPSBkaXIuZW50cmllc1tpXTsKCgkJaWYgKGluZGV4X25hbWVfaXNfb3RoZXIoci0+aW5kZXgsIGVudC0+bmFtZSwgZW50LT5sZW4pKSB7CgkJCXN0cmJ1Zl9yZXNldCgmYnVmKTsKCQkJc3RyYnVmX2FkZCgmYnVmLCBlbnQtPm5hbWUsIGVudC0+bGVuKTsKCQkJYWRkX2ZpbGVfaXRlbSgmZmlsZXMtPml0ZW1zLCBidWYuYnVmKTsKCQl9Cgl9CgoJc3RyYnVmX3JlbGVhc2UoJmJ1Zik7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBydW5fYWRkX3VudHJhY2tlZChzdHJ1Y3QgYWRkX2lfc3RhdGUgKnMsIGNvbnN0IHN0cnVjdCBwYXRoc3BlYyAqcHMsCgkJICAgICAgc3RydWN0IHByZWZpeF9pdGVtX2xpc3QgKmZpbGVzLAoJCSAgICAgIHN0cnVjdCBsaXN0X2FuZF9jaG9vc2Vfb3B0aW9ucyAqb3B0cykKewoJc3RydWN0IHByaW50X2ZpbGVfaXRlbV9kYXRhICpkID0gb3B0cy0+bGlzdF9vcHRzLnByaW50X2l0ZW1fZGF0YTsKCWludCByZXMgPSAwLCBmZDsKCXNpemVfdCBjb3VudCwgaTsKCXN0cnVjdCBsb2NrX2ZpbGUgaW5kZXhfbG9jazsKCglpZiAoZ2V0X3VudHJhY2tlZF9maWxlcyhzLT5yLCBmaWxlcywgcHMpIDwgMCkKCQlyZXR1cm4gLTE7CgoJaWYgKCFmaWxlcy0+aXRlbXMubnIpIHsKCQlwcmludGYoXygiTm8gdW50cmFja2VkIGZpbGVzLlxuIikpOwoJCWdvdG8gZmluaXNoX2FkZF91bnRyYWNrZWQ7Cgl9CgoJb3B0cy0+cHJvbXB0ID0gTl8oIkFkZCB1bnRyYWNrZWQiKTsKCWQtPm9ubHlfbmFtZXMgPSAxOwoJY291bnQgPSBsaXN0X2FuZF9jaG9vc2UocywgZmlsZXMsIG9wdHMpOwoJZC0+b25seV9uYW1lcyA9IDA7CglpZiAoY291bnQgPD0gMCkKCQlnb3RvIGZpbmlzaF9hZGRfdW50cmFja2VkOwoKCWZkID0gcmVwb19ob2xkX2xvY2tlZF9pbmRleChzLT5yLCAmaW5kZXhfbG9jaywgTE9DS19SRVBPUlRfT05fRVJST1IpOwoJaWYgKGZkIDwgMCkgewoJCXJlcyA9IC0xOwoJCWdvdG8gZmluaXNoX2FkZF91bnRyYWNrZWQ7Cgl9CgoJZm9yIChpID0gMDsgaSA8IGZpbGVzLT5pdGVtcy5ucjsgaSsrKSB7CgkJY29uc3QgY2hhciAqbmFtZSA9IGZpbGVzLT5pdGVtcy5pdGVtc1tpXS5zdHJpbmc7CgkJaWYgKGZpbGVzLT5zZWxlY3RlZFtpXSAmJgoJCSAgICBhZGRfZmlsZV90b19pbmRleChzLT5yLT5pbmRleCwgbmFtZSwgMCkgPCAwKSB7CgkJCXJlcyA9IGVycm9yKF8oImNvdWxkIG5vdCBzdGFnZSAnJXMnIiksIG5hbWUpOwoJCQlicmVhazsKCQl9Cgl9CgoJaWYgKCFyZXMgJiYKCSAgICB3cml0ZV9sb2NrZWRfaW5kZXgocy0+ci0+aW5kZXgsICZpbmRleF9sb2NrLCBDT01NSVRfTE9DSykgPCAwKQoJCXJlcyA9IGVycm9yKF8oImNvdWxkIG5vdCB3cml0ZSBpbmRleCIpKTsKCglpZiAoIXJlcykKCQlwcmludGYoUV8oImFkZGVkICVkIHBhdGhcbiIsCgkJCSAgImFkZGVkICVkIHBhdGhzXG4iLCBjb3VudCksIChpbnQpY291bnQpOwoKZmluaXNoX2FkZF91bnRyYWNrZWQ6CglwdXRjaGFyKCdcbicpOwoJcmV0dXJuIHJlczsKfQoKc3RhdGljIGludCBydW5fcGF0Y2goc3RydWN0IGFkZF9pX3N0YXRlICpzLCBjb25zdCBzdHJ1Y3QgcGF0aHNwZWMgKnBzLAoJCSAgICAgc3RydWN0IHByZWZpeF9pdGVtX2xpc3QgKmZpbGVzLAoJCSAgICAgc3RydWN0IGxpc3RfYW5kX2Nob29zZV9vcHRpb25zICpvcHRzKQp7CglpbnQgcmVzID0gMDsKCXNzaXplX3QgY291bnQsIGksIGo7CglzaXplX3QgdW5tZXJnZWRfY291bnQgPSAwLCBiaW5hcnlfY291bnQgPSAwOwoKCWlmIChnZXRfbW9kaWZpZWRfZmlsZXMocy0+ciwgV09SS1RSRUVfT05MWSwgZmlsZXMsIHBzLAoJCQkgICAgICAgJnVubWVyZ2VkX2NvdW50LCAmYmluYXJ5X2NvdW50KSA8IDApCgkJcmV0dXJuIC0xOwoKCWlmICh1bm1lcmdlZF9jb3VudCB8fCBiaW5hcnlfY291bnQpIHsKCQlmb3IgKGkgPSBqID0gMDsgaSA8IGZpbGVzLT5pdGVtcy5ucjsgaSsrKSB7CgkJCXN0cnVjdCBmaWxlX2l0ZW0gKml0ZW0gPSBmaWxlcy0+aXRlbXMuaXRlbXNbaV0udXRpbDsKCgkJCWlmIChpdGVtLT5pbmRleC5iaW5hcnkgfHwgaXRlbS0+d29ya3RyZWUuYmluYXJ5KSB7CgkJCQlmcmVlKGl0ZW0pOwoJCQkJZnJlZShmaWxlcy0+aXRlbXMuaXRlbXNbaV0uc3RyaW5nKTsKCQkJfSBlbHNlIGlmIChpdGVtLT5pbmRleC51bm1lcmdlZCB8fAoJCQkJIGl0ZW0tPndvcmt0cmVlLnVubWVyZ2VkKSB7CgkJCQljb2xvcl9mcHJpbnRmX2xuKHN0ZGVyciwgcy0+ZXJyb3JfY29sb3IsCgkJCQkJCSBfKCJpZ25vcmluZyB1bm1lcmdlZDogJXMiKSwKCQkJCQkJIGZpbGVzLT5pdGVtcy5pdGVtc1tpXS5zdHJpbmcpOwoJCQkJZnJlZShpdGVtKTsKCQkJCWZyZWUoZmlsZXMtPml0ZW1zLml0ZW1zW2ldLnN0cmluZyk7CgkJCX0gZWxzZQoJCQkJZmlsZXMtPml0ZW1zLml0ZW1zW2orK10gPSBmaWxlcy0+aXRlbXMuaXRlbXNbaV07CgkJfQoJCWZpbGVzLT5pdGVtcy5uciA9IGo7Cgl9CgoJaWYgKCFmaWxlcy0+aXRlbXMubnIpIHsKCQlpZiAoYmluYXJ5X2NvdW50KQoJCQlmcHJpbnRmKHN0ZGVyciwgXygiT25seSBiaW5hcnkgZmlsZXMgY2hhbmdlZC5cbiIpKTsKCQllbHNlCgkJCWZwcmludGYoc3RkZXJyLCBfKCJObyBjaGFuZ2VzLlxuIikpOwoJCXJldHVybiAwOwoJfQoKCW9wdHMtPnByb21wdCA9IE5fKCJQYXRjaCB1cGRhdGUiKTsKCWNvdW50ID0gbGlzdF9hbmRfY2hvb3NlKHMsIGZpbGVzLCBvcHRzKTsKCWlmIChjb3VudCA+IDApIHsKCQlzdHJ1Y3Qgc3RydmVjIGFyZ3MgPSBTVFJWRUNfSU5JVDsKCQlzdHJ1Y3QgcGF0aHNwZWMgcHNfc2VsZWN0ZWQgPSB7IDAgfTsKCgkJZm9yIChpID0gMDsgaSA8IGZpbGVzLT5pdGVtcy5ucjsgaSsrKQoJCQlpZiAoZmlsZXMtPnNlbGVjdGVkW2ldKQoJCQkJc3RydmVjX3B1c2goJmFyZ3MsCgkJCQkJICAgIGZpbGVzLT5pdGVtcy5pdGVtc1tpXS5zdHJpbmcpOwoJCXBhcnNlX3BhdGhzcGVjKCZwc19zZWxlY3RlZCwKCQkJICAgICAgIFBBVEhTUEVDX0FMTF9NQUdJQyAmIH5QQVRIU1BFQ19MSVRFUkFMLAoJCQkgICAgICAgUEFUSFNQRUNfTElURVJBTF9QQVRILCAiIiwgYXJncy52KTsKCQlyZXMgPSBydW5fYWRkX3Aocy0+ciwgQUREX1BfQURELCBOVUxMLCAmcHNfc2VsZWN0ZWQpOwoJCXN0cnZlY19jbGVhcigmYXJncyk7CgkJY2xlYXJfcGF0aHNwZWMoJnBzX3NlbGVjdGVkKTsKCX0KCglyZXR1cm4gcmVzOwp9CgpzdGF0aWMgaW50IHJ1bl9kaWZmKHN0cnVjdCBhZGRfaV9zdGF0ZSAqcywgY29uc3Qgc3RydWN0IHBhdGhzcGVjICpwcywKCQkgICAgc3RydWN0IHByZWZpeF9pdGVtX2xpc3QgKmZpbGVzLAoJCSAgICBzdHJ1Y3QgbGlzdF9hbmRfY2hvb3NlX29wdGlvbnMgKm9wdHMpCnsKCWludCByZXMgPSAwOwoJc3NpemVfdCBjb3VudCwgaTsKCglzdHJ1Y3Qgb2JqZWN0X2lkIG9pZDsKCWludCBpc19pbml0aWFsID0gIXJlc29sdmVfcmVmX3Vuc2FmZSgiSEVBRCIsIFJFU09MVkVfUkVGX1JFQURJTkcsICZvaWQsCgkJCQkJICAgICBOVUxMKTsKCWlmIChnZXRfbW9kaWZpZWRfZmlsZXMocy0+ciwgSU5ERVhfT05MWSwgZmlsZXMsIHBzLCBOVUxMLCBOVUxMKSA8IDApCgkJcmV0dXJuIC0xOwoKCWlmICghZmlsZXMtPml0ZW1zLm5yKSB7CgkJcHV0Y2hhcignXG4nKTsKCQlyZXR1cm4gMDsKCX0KCglvcHRzLT5wcm9tcHQgPSBOXygiUmV2aWV3IGRpZmYiKTsKCW9wdHMtPmZsYWdzID0gSU1NRURJQVRFOwoJY291bnQgPSBsaXN0X2FuZF9jaG9vc2UocywgZmlsZXMsIG9wdHMpOwoJb3B0cy0+ZmxhZ3MgPSAwOwoJaWYgKGNvdW50ID4gMCkgewoJCXN0cnVjdCBjaGlsZF9wcm9jZXNzIGNtZCA9IENISUxEX1BST0NFU1NfSU5JVDsKCgkJc3RydmVjX3B1c2hsKCZjbWQuYXJncywgImdpdCIsICJkaWZmIiwgIi1wIiwgIi0tY2FjaGVkIiwKCQkJICAgICBvaWRfdG9faGV4KCFpc19pbml0aWFsID8gJm9pZCA6CgkJCQkJcy0+ci0+aGFzaF9hbGdvLT5lbXB0eV90cmVlKSwKCQkJICAgICAiLS0iLCBOVUxMKTsKCQlmb3IgKGkgPSAwOyBpIDwgZmlsZXMtPml0ZW1zLm5yOyBpKyspCgkJCWlmIChmaWxlcy0+c2VsZWN0ZWRbaV0pCgkJCQlzdHJ2ZWNfcHVzaCgmY21kLmFyZ3MsCgkJCQkJICAgIGZpbGVzLT5pdGVtcy5pdGVtc1tpXS5zdHJpbmcpOwoJCXJlcyA9IHJ1bl9jb21tYW5kKCZjbWQpOwoJfQoKCXB1dGNoYXIoJ1xuJyk7CglyZXR1cm4gcmVzOwp9CgpzdGF0aWMgaW50IHJ1bl9oZWxwKHN0cnVjdCBhZGRfaV9zdGF0ZSAqcywgY29uc3Qgc3RydWN0IHBhdGhzcGVjICp1bnVzZWRfcHMsCgkJICAgIHN0cnVjdCBwcmVmaXhfaXRlbV9saXN0ICp1bnVzZWRfZmlsZXMsCgkJICAgIHN0cnVjdCBsaXN0X2FuZF9jaG9vc2Vfb3B0aW9ucyAqdW51c2VkX29wdHMpCnsKCWNvbG9yX2ZwcmludGZfbG4oc3Rkb3V0LCBzLT5oZWxwX2NvbG9yLCAic3RhdHVzICAgICAgICAtICVzIiwKCQkJIF8oInNob3cgcGF0aHMgd2l0aCBjaGFuZ2VzIikpOwoJY29sb3JfZnByaW50Zl9sbihzdGRvdXQsIHMtPmhlbHBfY29sb3IsICJ1cGRhdGUgICAgICAgIC0gJXMiLAoJCQkgXygiYWRkIHdvcmtpbmcgdHJlZSBzdGF0ZSB0byB0aGUgc3RhZ2VkIHNldCBvZiBjaGFuZ2VzIikpOwoJY29sb3JfZnByaW50Zl9sbihzdGRvdXQsIHMtPmhlbHBfY29sb3IsICJyZXZlcnQgICAgICAgIC0gJXMiLAoJCQkgXygicmV2ZXJ0IHN0YWdlZCBzZXQgb2YgY2hhbmdlcyBiYWNrIHRvIHRoZSBIRUFEIHZlcnNpb24iKSk7Cgljb2xvcl9mcHJpbnRmX2xuKHN0ZG91dCwgcy0+aGVscF9jb2xvciwgInBhdGNoICAgICAgICAgLSAlcyIsCgkJCSBfKCJwaWNrIGh1bmtzIGFuZCB1cGRhdGUgc2VsZWN0aXZlbHkiKSk7Cgljb2xvcl9mcHJpbnRmX2xuKHN0ZG91dCwgcy0+aGVscF9jb2xvciwgImRpZmYgICAgICAgICAgLSAlcyIsCgkJCSBfKCJ2aWV3IGRpZmYgYmV0d2VlbiBIRUFEIGFuZCBpbmRleCIpKTsKCWNvbG9yX2ZwcmludGZfbG4oc3Rkb3V0LCBzLT5oZWxwX2NvbG9yLCAiYWRkIHVudHJhY2tlZCAtICVzIiwKCQkJIF8oImFkZCBjb250ZW50cyBvZiB1bnRyYWNrZWQgZmlsZXMgdG8gdGhlIHN0YWdlZCBzZXQgb2YgY2hhbmdlcyIpKTsKCglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgY2hvb3NlX3Byb21wdF9oZWxwKHN0cnVjdCBhZGRfaV9zdGF0ZSAqcykKewoJY29sb3JfZnByaW50Zl9sbihzdGRvdXQsIHMtPmhlbHBfY29sb3IsICIlcyIsCgkJCSBfKCJQcm9tcHQgaGVscDoiKSk7Cgljb2xvcl9mcHJpbnRmX2xuKHN0ZG91dCwgcy0+aGVscF9jb2xvciwgIjEgICAgICAgICAgLSAlcyIsCgkJCSBfKCJzZWxlY3QgYSBzaW5nbGUgaXRlbSIpKTsKCWNvbG9yX2ZwcmludGZfbG4oc3Rkb3V0LCBzLT5oZWxwX2NvbG9yLCAiMy01ICAgICAgICAtICVzIiwKCQkJIF8oInNlbGVjdCBhIHJhbmdlIG9mIGl0ZW1zIikpOwoJY29sb3JfZnByaW50Zl9sbihzdGRvdXQsIHMtPmhlbHBfY29sb3IsICIyLTMsNi05ICAgIC0gJXMiLAoJCQkgXygic2VsZWN0IG11bHRpcGxlIHJhbmdlcyIpKTsKCWNvbG9yX2ZwcmludGZfbG4oc3Rkb3V0LCBzLT5oZWxwX2NvbG9yLCAiZm9vICAgICAgICAtICVzIiwKCQkJIF8oInNlbGVjdCBpdGVtIGJhc2VkIG9uIHVuaXF1ZSBwcmVmaXgiKSk7Cgljb2xvcl9mcHJpbnRmX2xuKHN0ZG91dCwgcy0+aGVscF9jb2xvciwgIi0uLi4gICAgICAgLSAlcyIsCgkJCSBfKCJ1bnNlbGVjdCBzcGVjaWZpZWQgaXRlbXMiKSk7Cgljb2xvcl9mcHJpbnRmX2xuKHN0ZG91dCwgcy0+aGVscF9jb2xvciwgIiogICAgICAgICAgLSAlcyIsCgkJCSBfKCJjaG9vc2UgYWxsIGl0ZW1zIikpOwoJY29sb3JfZnByaW50Zl9sbihzdGRvdXQsIHMtPmhlbHBfY29sb3IsICIgICAgICAgICAgIC0gJXMiLAoJCQkgXygiKGVtcHR5KSBmaW5pc2ggc2VsZWN0aW5nIikpOwp9Cgp0eXBlZGVmIGludCAoKmNvbW1hbmRfdCkoc3RydWN0IGFkZF9pX3N0YXRlICpzLCBjb25zdCBzdHJ1Y3QgcGF0aHNwZWMgKnBzLAoJCQkgc3RydWN0IHByZWZpeF9pdGVtX2xpc3QgKmZpbGVzLAoJCQkgc3RydWN0IGxpc3RfYW5kX2Nob29zZV9vcHRpb25zICpvcHRzKTsKCnN0cnVjdCBjb21tYW5kX2l0ZW0gewoJc2l6ZV90IHByZWZpeF9sZW5ndGg7Cgljb21tYW5kX3QgY29tbWFuZDsKfTsKCnN0cnVjdCBwcmludF9jb21tYW5kX2l0ZW1fZGF0YSB7Cgljb25zdCBjaGFyICpjb2xvciwgKnJlc2V0Owp9OwoKc3RhdGljIHZvaWQgcHJpbnRfY29tbWFuZF9pdGVtKGludCBpLCBpbnQgc2VsZWN0ZWQsCgkJCSAgICAgICBzdHJ1Y3Qgc3RyaW5nX2xpc3RfaXRlbSAqaXRlbSwKCQkJICAgICAgIHZvaWQgKnByaW50X2NvbW1hbmRfaXRlbV9kYXRhKQp7CglzdHJ1Y3QgcHJpbnRfY29tbWFuZF9pdGVtX2RhdGEgKmQgPSBwcmludF9jb21tYW5kX2l0ZW1fZGF0YTsKCXN0cnVjdCBjb21tYW5kX2l0ZW0gKnV0aWwgPSBpdGVtLT51dGlsOwoKCWlmICghdXRpbC0+cHJlZml4X2xlbmd0aCB8fAoJICAgICFpc192YWxpZF9wcmVmaXgoaXRlbS0+c3RyaW5nLCB1dGlsLT5wcmVmaXhfbGVuZ3RoKSkKCQlwcmludGYoIiAlMmQ6ICVzIiwgaSArIDEsIGl0ZW0tPnN0cmluZyk7CgllbHNlCgkJcHJpbnRmKCIgJTJkOiAlcyUuKnMlcyVzIiwgaSArIDEsCgkJICAgICAgIGQtPmNvbG9yLCAoaW50KXV0aWwtPnByZWZpeF9sZW5ndGgsIGl0ZW0tPnN0cmluZywKCQkgICAgICAgZC0+cmVzZXQsIGl0ZW0tPnN0cmluZyArIHV0aWwtPnByZWZpeF9sZW5ndGgpOwp9CgpzdGF0aWMgdm9pZCBjb21tYW5kX3Byb21wdF9oZWxwKHN0cnVjdCBhZGRfaV9zdGF0ZSAqcykKewoJY29uc3QgY2hhciAqaGVscF9jb2xvciA9IHMtPmhlbHBfY29sb3I7Cgljb2xvcl9mcHJpbnRmX2xuKHN0ZG91dCwgaGVscF9jb2xvciwgIiVzIiwgXygiUHJvbXB0IGhlbHA6IikpOwoJY29sb3JfZnByaW50Zl9sbihzdGRvdXQsIGhlbHBfY29sb3IsICIxICAgICAgICAgIC0gJXMiLAoJCQkgXygic2VsZWN0IGEgbnVtYmVyZWQgaXRlbSIpKTsKCWNvbG9yX2ZwcmludGZfbG4oc3Rkb3V0LCBoZWxwX2NvbG9yLCAiZm9vICAgICAgICAtICVzIiwKCQkJIF8oInNlbGVjdCBpdGVtIGJhc2VkIG9uIHVuaXF1ZSBwcmVmaXgiKSk7Cgljb2xvcl9mcHJpbnRmX2xuKHN0ZG91dCwgaGVscF9jb2xvciwgIiAgICAgICAgICAgLSAlcyIsCgkJCSBfKCIoZW1wdHkpIHNlbGVjdCBub3RoaW5nIikpOwp9CgppbnQgcnVuX2FkZF9pKHN0cnVjdCByZXBvc2l0b3J5ICpyLCBjb25zdCBzdHJ1Y3QgcGF0aHNwZWMgKnBzKQp7CglzdHJ1Y3QgYWRkX2lfc3RhdGUgcyA9IHsgTlVMTCB9OwoJc3RydWN0IHByaW50X2NvbW1hbmRfaXRlbV9kYXRhIGRhdGEgPSB7ICJbIiwgIl0iIH07CglzdHJ1Y3QgbGlzdF9hbmRfY2hvb3NlX29wdGlvbnMgbWFpbl9sb29wX29wdHMgPSB7CgkJeyA0LCBOXygiKioqIENvbW1hbmRzICoqKiIpLCBwcmludF9jb21tYW5kX2l0ZW0sICZkYXRhIH0sCgkJTl8oIldoYXQgbm93IiksIFNJTkdMRVRPTiB8IElNTUVESUFURSwgY29tbWFuZF9wcm9tcHRfaGVscAoJfTsKCXN0cnVjdCB7CgkJY29uc3QgY2hhciAqc3RyaW5nOwoJCWNvbW1hbmRfdCBjb21tYW5kOwoJfSBjb21tYW5kX2xpc3RbXSA9IHsKCQl7ICJzdGF0dXMiLCBydW5fc3RhdHVzIH0sCgkJeyAidXBkYXRlIiwgcnVuX3VwZGF0ZSB9LAoJCXsgInJldmVydCIsIHJ1bl9yZXZlcnQgfSwKCQl7ICJhZGQgdW50cmFja2VkIiwgcnVuX2FkZF91bnRyYWNrZWQgfSwKCQl7ICJwYXRjaCIsIHJ1bl9wYXRjaCB9LAoJCXsgImRpZmYiLCBydW5fZGlmZiB9LAoJCXsgInF1aXQiLCBOVUxMIH0sCgkJeyAiaGVscCIsIHJ1bl9oZWxwIH0sCgl9OwoJc3RydWN0IHByZWZpeF9pdGVtX2xpc3QgY29tbWFuZHMgPSBQUkVGSVhfSVRFTV9MSVNUX0lOSVQ7CgoJc3RydWN0IHByaW50X2ZpbGVfaXRlbV9kYXRhIHByaW50X2ZpbGVfaXRlbV9kYXRhID0gewoJCSIlMTJzICUxMnMgJXMiLCBOVUxMLCBOVUxMLAoJCVNUUkJVRl9JTklULCBTVFJCVUZfSU5JVCwgU1RSQlVGX0lOSVQsIFNUUkJVRl9JTklUCgl9OwoJc3RydWN0IGxpc3RfYW5kX2Nob29zZV9vcHRpb25zIG9wdHMgPSB7CgkJeyAwLCBOVUxMLCBwcmludF9maWxlX2l0ZW0sICZwcmludF9maWxlX2l0ZW1fZGF0YSB9LAoJCU5VTEwsIDAsIGNob29zZV9wcm9tcHRfaGVscAoJfTsKCXN0cnVjdCBzdHJidWYgaGVhZGVyID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3QgcHJlZml4X2l0ZW1fbGlzdCBmaWxlcyA9IFBSRUZJWF9JVEVNX0xJU1RfSU5JVDsKCXNzaXplX3QgaTsKCWludCByZXMgPSAwOwoKCWZvciAoaSA9IDA7IGkgPCBBUlJBWV9TSVpFKGNvbW1hbmRfbGlzdCk7IGkrKykgewoJCXN0cnVjdCBjb21tYW5kX2l0ZW0gKnV0aWwgPSB4Y2FsbG9jKDEsIHNpemVvZigqdXRpbCkpOwoJCXV0aWwtPmNvbW1hbmQgPSBjb21tYW5kX2xpc3RbaV0uY29tbWFuZDsKCQlzdHJpbmdfbGlzdF9hcHBlbmQoJmNvbW1hbmRzLml0ZW1zLCBjb21tYW5kX2xpc3RbaV0uc3RyaW5nKQoJCQktPnV0aWwgPSB1dGlsOwoJfQoKCWluaXRfYWRkX2lfc3RhdGUoJnMsIHIpOwoKCS8qCgkgKiBXaGVuIGNvbG9yIHdhcyBhc2tlZCBmb3IsIHVzZSB0aGUgcHJvbXB0IGNvbG9yIGZvcgoJICogaGlnaGxpZ2h0aW5nLCBvdGhlcndpc2UgdXNlIHNxdWFyZSBicmFja2V0cy4KCSAqLwoJaWYgKHMudXNlX2NvbG9yKSB7CgkJZGF0YS5jb2xvciA9IHMucHJvbXB0X2NvbG9yOwoJCWRhdGEucmVzZXQgPSBzLnJlc2V0X2NvbG9yOwoJfQoJcHJpbnRfZmlsZV9pdGVtX2RhdGEuY29sb3IgPSBkYXRhLmNvbG9yOwoJcHJpbnRfZmlsZV9pdGVtX2RhdGEucmVzZXQgPSBkYXRhLnJlc2V0OwoKCXN0cmJ1Zl9hZGRzdHIoJmhlYWRlciwgIiAgICAgIik7CglzdHJidWZfYWRkZigmaGVhZGVyLCBwcmludF9maWxlX2l0ZW1fZGF0YS5tb2RpZmllZF9mbXQsCgkJICAgIF8oInN0YWdlZCIpLCBfKCJ1bnN0YWdlZCIpLCBfKCJwYXRoIikpOwoJb3B0cy5saXN0X29wdHMuaGVhZGVyID0gaGVhZGVyLmJ1ZjsKCglkaXNjYXJkX2luZGV4KHItPmluZGV4KTsKCWlmIChyZXBvX3JlYWRfaW5kZXgocikgPCAwIHx8CgkgICAgcmVwb19yZWZyZXNoX2FuZF93cml0ZV9pbmRleChyLCBSRUZSRVNIX1FVSUVULCAwLCAxLAoJCQkJCSBOVUxMLCBOVUxMLCBOVUxMKSA8IDApCgkJd2FybmluZyhfKCJjb3VsZCBub3QgcmVmcmVzaCBpbmRleCIpKTsKCglyZXMgPSBydW5fc3RhdHVzKCZzLCBwcywgJmZpbGVzLCAmb3B0cyk7CgoJZm9yICg7OykgewoJCXN0cnVjdCBjb21tYW5kX2l0ZW0gKnV0aWw7CgoJCWkgPSBsaXN0X2FuZF9jaG9vc2UoJnMsICZjb21tYW5kcywgJm1haW5fbG9vcF9vcHRzKTsKCQlpZiAoaSA8IDAgfHwgaSA+PSBjb21tYW5kcy5pdGVtcy5ucikKCQkJdXRpbCA9IE5VTEw7CgkJZWxzZQoJCQl1dGlsID0gY29tbWFuZHMuaXRlbXMuaXRlbXNbaV0udXRpbDsKCgkJaWYgKGkgPT0gTElTVF9BTkRfQ0hPT1NFX1FVSVQgfHwgKHV0aWwgJiYgIXV0aWwtPmNvbW1hbmQpKSB7CgkJCXByaW50ZihfKCJCeWUuXG4iKSk7CgkJCXJlcyA9IDA7CgkJCWJyZWFrOwoJCX0KCgkJaWYgKHV0aWwpCgkJCXJlcyA9IHV0aWwtPmNvbW1hbmQoJnMsIHBzLCAmZmlsZXMsICZvcHRzKTsKCX0KCglwcmVmaXhfaXRlbV9saXN0X2NsZWFyKCZmaWxlcyk7CglzdHJidWZfcmVsZWFzZSgmcHJpbnRfZmlsZV9pdGVtX2RhdGEuYnVmKTsKCXN0cmJ1Zl9yZWxlYXNlKCZwcmludF9maWxlX2l0ZW1fZGF0YS5uYW1lKTsKCXN0cmJ1Zl9yZWxlYXNlKCZwcmludF9maWxlX2l0ZW1fZGF0YS5pbmRleCk7CglzdHJidWZfcmVsZWFzZSgmcHJpbnRfZmlsZV9pdGVtX2RhdGEud29ya3RyZWUpOwoJc3RyYnVmX3JlbGVhc2UoJmhlYWRlcik7CglwcmVmaXhfaXRlbV9saXN0X2NsZWFyKCZjb21tYW5kcyk7CgljbGVhcl9hZGRfaV9zdGF0ZSgmcyk7CgoJcmV0dXJuIHJlczsKfQo=",
    "text": "#include \"cache.h\"\n#include \"add-interactive.h\"\n#include \"color.h\"\n#include \"config.h\"\n#include \"diffcore.h\"\n#include \"revision.h\"\n#include \"refs.h\"\n#include \"string-list.h\"\n#include \"lockfile.h\"\n#include \"dir.h\"\n#include \"run-command.h\"\n#include \"prompt.h\"\n\nstatic void init_color(struct repository *r, struct add_i_state *s,\n\t\t       const char *section_and_slot, char *dst,\n\t\t       const char *default_color)\n{\n\tchar *key = xstrfmt(\"color.%s\", section_and_slot);\n\tconst char *value;\n\n\tif (!s->use_color)\n\t\tdst[0] = '\\0';\n\telse if (repo_config_get_value(r, key, &value) ||\n\t\t color_parse(value, dst))\n\t\tstrlcpy(dst, default_color, COLOR_MAXLEN);\n\n\tfree(key);\n}\n\nvoid init_add_i_state(struct add_i_state *s, struct repository *r)\n{\n\tconst char *value;\n\n\ts->r = r;\n\n\tif (repo_config_get_value(r, \"color.interactive\", &value))\n\t\ts->use_color = -1;\n\telse\n\t\ts->use_color =\n\t\t\tgit_config_colorbool(\"color.interactive\", value);\n\ts->use_color = want_color(s->use_color);\n\n\tinit_color(r, s, \"interactive.header\", s->header_color, GIT_COLOR_BOLD);\n\tinit_color(r, s, \"interactive.help\", s->help_color, GIT_COLOR_BOLD_RED);\n\tinit_color(r, s, \"interactive.prompt\", s->prompt_color,\n\t\t   GIT_COLOR_BOLD_BLUE);\n\tinit_color(r, s, \"interactive.error\", s->error_color,\n\t\t   GIT_COLOR_BOLD_RED);\n\n\tinit_color(r, s, \"diff.frag\", s->fraginfo_color,\n\t\t   diff_get_color(s->use_color, DIFF_FRAGINFO));\n\tinit_color(r, s, \"diff.context\", s->context_color, \"fall back\");\n\tif (!strcmp(s->context_color, \"fall back\"))\n\t\tinit_color(r, s, \"diff.plain\", s->context_color,\n\t\t\t   diff_get_color(s->use_color, DIFF_CONTEXT));\n\tinit_color(r, s, \"diff.old\", s->file_old_color,\n\t\tdiff_get_color(s->use_color, DIFF_FILE_OLD));\n\tinit_color(r, s, \"diff.new\", s->file_new_color,\n\t\tdiff_get_color(s->use_color, DIFF_FILE_NEW));\n\n\tstrlcpy(s->reset_color,\n\t\ts->use_color ? GIT_COLOR_RESET : \"\", COLOR_MAXLEN);\n\n\tFREE_AND_NULL(s->interactive_diff_filter);\n\tgit_config_get_string(\"interactive.difffilter\",\n\t\t\t      &s->interactive_diff_filter);\n\n\tFREE_AND_NULL(s->interactive_diff_algorithm);\n\tgit_config_get_string(\"diff.algorithm\",\n\t\t\t      &s->interactive_diff_algorithm);\n\n\tgit_config_get_bool(\"interactive.singlekey\", &s->use_single_key);\n\tif (s->use_single_key)\n\t\tsetbuf(stdin, NULL);\n}\n\nvoid clear_add_i_state(struct add_i_state *s)\n{\n\tFREE_AND_NULL(s->interactive_diff_filter);\n\tFREE_AND_NULL(s->interactive_diff_algorithm);\n\tmemset(s, 0, sizeof(*s));\n\ts->use_color = -1;\n}\n\n/*\n * A \"prefix item list\" is a list of items that are identified by a string, and\n * a unique prefix (if any) is determined for each item.\n *\n * It is implemented in the form of a pair of `string_list`s, the first one\n * duplicating the strings, with the `util` field pointing at a structure whose\n * first field must be `size_t prefix_length`.\n *\n * That `prefix_length` field will be computed by `find_unique_prefixes()`; It\n * will be set to zero if no valid, unique prefix could be found.\n *\n * The second `string_list` is called `sorted` and does _not_ duplicate the\n * strings but simply reuses the first one's, with the `util` field pointing at\n * the `string_item_list` of the first `string_list`. It  will be populated and\n * sorted by `find_unique_prefixes()`.\n */\nstruct prefix_item_list {\n\tstruct string_list items;\n\tstruct string_list sorted;\n\tint *selected; /* for multi-selections */\n\tsize_t min_length, max_length;\n};\n#define PREFIX_ITEM_LIST_INIT { \\\n\t.items = STRING_LIST_INIT_DUP, \\\n\t.sorted = STRING_LIST_INIT_NODUP, \\\n\t.min_length = 1, \\\n\t.max_length = 4, \\\n}\n\nstatic void prefix_item_list_clear(struct prefix_item_list *list)\n{\n\tstring_list_clear(&list->items, 1);\n\tstring_list_clear(&list->sorted, 0);\n\tFREE_AND_NULL(list->selected);\n}\n\nstatic void extend_prefix_length(struct string_list_item *p,\n\t\t\t\t const char *other_string, size_t max_length)\n{\n\tsize_t *len = p->util;\n\n\tif (!*len || memcmp(p->string, other_string, *len))\n\t\treturn;\n\n\tfor (;;) {\n\t\tchar c = p->string[*len];\n\n\t\t/*\n\t\t * Is `p` a strict prefix of `other`? Or have we exhausted the\n\t\t * maximal length of the prefix? Or is the current character a\n\t\t * multi-byte UTF-8 one? If so, there is no valid, unique\n\t\t * prefix.\n\t\t */\n\t\tif (!c || ++*len > max_length || !isascii(c)) {\n\t\t\t*len = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (c != other_string[*len - 1])\n\t\t\tbreak;\n\t}\n}\n\nstatic void find_unique_prefixes(struct prefix_item_list *list)\n{\n\tsize_t i;\n\n\tif (list->sorted.nr == list->items.nr)\n\t\treturn;\n\n\tstring_list_clear(&list->sorted, 0);\n\t/* Avoid reallocating incrementally */\n\tlist->sorted.items = xmalloc(st_mult(sizeof(*list->sorted.items),\n\t\t\t\t\t     list->items.nr));\n\tlist->sorted.nr = list->sorted.alloc = list->items.nr;\n\n\tfor (i = 0; i < list->items.nr; i++) {\n\t\tlist->sorted.items[i].string = list->items.items[i].string;\n\t\tlist->sorted.items[i].util = list->items.items + i;\n\t}\n\n\tstring_list_sort(&list->sorted);\n\n\tfor (i = 0; i < list->sorted.nr; i++) {\n\t\tstruct string_list_item *sorted_item = list->sorted.items + i;\n\t\tstruct string_list_item *item = sorted_item->util;\n\t\tsize_t *len = item->util;\n\n\t\t*len = 0;\n\t\twhile (*len < list->min_length) {\n\t\t\tchar c = item->string[(*len)++];\n\n\t\t\tif (!c || !isascii(c)) {\n\t\t\t\t*len = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (i > 0)\n\t\t\textend_prefix_length(item, sorted_item[-1].string,\n\t\t\t\t\t     list->max_length);\n\t\tif (i + 1 < list->sorted.nr)\n\t\t\textend_prefix_length(item, sorted_item[1].string,\n\t\t\t\t\t     list->max_length);\n\t}\n}\n\nstatic ssize_t find_unique(const char *string, struct prefix_item_list *list)\n{\n\tint index = string_list_find_insert_index(&list->sorted, string, 1);\n\tstruct string_list_item *item;\n\n\tif (list->items.nr != list->sorted.nr)\n\t\tBUG(\"prefix_item_list in inconsistent state (%\"PRIuMAX\n\t\t    \" vs %\"PRIuMAX\")\",\n\t\t    (uintmax_t)list->items.nr, (uintmax_t)list->sorted.nr);\n\n\tif (index < 0)\n\t\titem = list->sorted.items[-1 - index].util;\n\telse if (index > 0 &&\n\t\t starts_with(list->sorted.items[index - 1].string, string))\n\t\treturn -1;\n\telse if (index + 1 < list->sorted.nr &&\n\t\t starts_with(list->sorted.items[index + 1].string, string))\n\t\treturn -1;\n\telse if (index < list->sorted.nr &&\n\t\t starts_with(list->sorted.items[index].string, string))\n\t\titem = list->sorted.items[index].util;\n\telse\n\t\treturn -1;\n\treturn item - list->items.items;\n}\n\nstruct list_options {\n\tint columns;\n\tconst char *header;\n\tvoid (*print_item)(int i, int selected, struct string_list_item *item,\n\t\t\t   void *print_item_data);\n\tvoid *print_item_data;\n};\n\nstatic void list(struct add_i_state *s, struct string_list *list, int *selected,\n\t\t struct list_options *opts)\n{\n\tint i, last_lf = 0;\n\n\tif (!list->nr)\n\t\treturn;\n\n\tif (opts->header)\n\t\tcolor_fprintf_ln(stdout, s->header_color,\n\t\t\t\t \"%s\", opts->header);\n\n\tfor (i = 0; i < list->nr; i++) {\n\t\topts->print_item(i, selected ? selected[i] : 0, list->items + i,\n\t\t\t\t opts->print_item_data);\n\n\t\tif ((opts->columns) && ((i + 1) % (opts->columns))) {\n\t\t\tputchar('\\t');\n\t\t\tlast_lf = 0;\n\t\t}\n\t\telse {\n\t\t\tputchar('\\n');\n\t\t\tlast_lf = 1;\n\t\t}\n\t}\n\n\tif (!last_lf)\n\t\tputchar('\\n');\n}\nstruct list_and_choose_options {\n\tstruct list_options list_opts;\n\n\tconst char *prompt;\n\tenum {\n\t\tSINGLETON = (1<<0),\n\t\tIMMEDIATE = (1<<1),\n\t} flags;\n\tvoid (*print_help)(struct add_i_state *s);\n};\n\n#define LIST_AND_CHOOSE_ERROR (-1)\n#define LIST_AND_CHOOSE_QUIT  (-2)\n\n/*\n * Returns the selected index in singleton mode, the number of selected items\n * otherwise.\n *\n * If an error occurred, returns `LIST_AND_CHOOSE_ERROR`. Upon EOF,\n * `LIST_AND_CHOOSE_QUIT` is returned.\n */\nstatic ssize_t list_and_choose(struct add_i_state *s,\n\t\t\t       struct prefix_item_list *items,\n\t\t\t       struct list_and_choose_options *opts)\n{\n\tint singleton = opts->flags & SINGLETON;\n\tint immediate = opts->flags & IMMEDIATE;\n\n\tstruct strbuf input = STRBUF_INIT;\n\tssize_t res = singleton ? LIST_AND_CHOOSE_ERROR : 0;\n\n\tif (!singleton) {\n\t\tfree(items->selected);\n\t\tCALLOC_ARRAY(items->selected, items->items.nr);\n\t}\n\n\tif (singleton && !immediate)\n\t\tBUG(\"singleton requires immediate\");\n\n\tfind_unique_prefixes(items);\n\n\tfor (;;) {\n\t\tchar *p;\n\n\t\tstrbuf_reset(&input);\n\n\t\tlist(s, &items->items, items->selected, &opts->list_opts);\n\n\t\tcolor_fprintf(stdout, s->prompt_color, \"%s\", opts->prompt);\n\t\tfputs(singleton ? \"> \" : \">> \", stdout);\n\t\tfflush(stdout);\n\n\t\tif (git_read_line_interactively(&input) == EOF) {\n\t\t\tputchar('\\n');\n\t\t\tif (immediate)\n\t\t\t\tres = LIST_AND_CHOOSE_QUIT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!input.len)\n\t\t\tbreak;\n\n\t\tif (!strcmp(input.buf, \"?\")) {\n\t\t\topts->print_help(s);\n\t\t\tcontinue;\n\t\t}\n\n\t\tp = input.buf;\n\t\tfor (;;) {\n\t\t\tsize_t sep = strcspn(p, \" \\t\\r\\n,\");\n\t\t\tint choose = 1;\n\t\t\t/* `from` is inclusive, `to` is exclusive */\n\t\t\tssize_t from = -1, to = -1;\n\n\t\t\tif (!sep) {\n\t\t\t\tif (!*p)\n\t\t\t\t\tbreak;\n\t\t\t\tp++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Input that begins with '-'; de-select */\n\t\t\tif (*p == '-') {\n\t\t\t\tchoose = 0;\n\t\t\t\tp++;\n\t\t\t\tsep--;\n\t\t\t}\n\n\t\t\tif (sep == 1 && *p == '*') {\n\t\t\t\tfrom = 0;\n\t\t\t\tto = items->items.nr;\n\t\t\t} else if (isdigit(*p)) {\n\t\t\t\tchar *endp;\n\t\t\t\t/*\n\t\t\t\t * A range can be specified like 5-7 or 5-.\n\t\t\t\t *\n\t\t\t\t * Note: `from` is 0-based while the user input\n\t\t\t\t * is 1-based, hence we have to decrement by\n\t\t\t\t * one. We do not have to decrement `to` even\n\t\t\t\t * if it is 0-based because it is an exclusive\n\t\t\t\t * boundary.\n\t\t\t\t */\n\t\t\t\tfrom = strtoul(p, &endp, 10) - 1;\n\t\t\t\tif (endp == p + sep)\n\t\t\t\t\tto = from + 1;\n\t\t\t\telse if (*endp == '-') {\n\t\t\t\t\tif (isdigit(*(++endp)))\n\t\t\t\t\t\tto = strtoul(endp, &endp, 10);\n\t\t\t\t\telse\n\t\t\t\t\t\tto = items->items.nr;\n\t\t\t\t\t/* extra characters after the range? */\n\t\t\t\t\tif (endp != p + sep)\n\t\t\t\t\t\tfrom = -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (p[sep])\n\t\t\t\tp[sep++] = '\\0';\n\t\t\tif (from < 0) {\n\t\t\t\tfrom = find_unique(p, items);\n\t\t\t\tif (from >= 0)\n\t\t\t\t\tto = from + 1;\n\t\t\t}\n\n\t\t\tif (from < 0 || from >= items->items.nr ||\n\t\t\t    (singleton && from + 1 != to)) {\n\t\t\t\tcolor_fprintf_ln(stderr, s->error_color,\n\t\t\t\t\t\t _(\"Huh (%s)?\"), p);\n\t\t\t\tbreak;\n\t\t\t} else if (singleton) {\n\t\t\t\tres = from;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (to > items->items.nr)\n\t\t\t\tto = items->items.nr;\n\n\t\t\tfor (; from < to; from++)\n\t\t\t\tif (items->selected[from] != choose) {\n\t\t\t\t\titems->selected[from] = choose;\n\t\t\t\t\tres += choose ? +1 : -1;\n\t\t\t\t}\n\n\t\t\tp += sep;\n\t\t}\n\n\t\tif ((immediate && res != LIST_AND_CHOOSE_ERROR) ||\n\t\t    !strcmp(input.buf, \"*\"))\n\t\t\tbreak;\n\t}\n\n\tstrbuf_release(&input);\n\treturn res;\n}\n\nstruct adddel {\n\tuintmax_t add, del;\n\tunsigned seen:1, unmerged:1, binary:1;\n};\n\nstruct file_item {\n\tsize_t prefix_length;\n\tstruct adddel index, worktree;\n};\n\nstatic void add_file_item(struct string_list *files, const char *name)\n{\n\tstruct file_item *item = xcalloc(1, sizeof(*item));\n\n\tstring_list_append(files, name)->util = item;\n}\n\nstruct pathname_entry {\n\tstruct hashmap_entry ent;\n\tconst char *name;\n\tstruct file_item *item;\n};\n\nstatic int pathname_entry_cmp(const void *cmp_data UNUSED,\n\t\t\t      const struct hashmap_entry *he1,\n\t\t\t      const struct hashmap_entry *he2,\n\t\t\t      const void *name)\n{\n\tconst struct pathname_entry *e1 =\n\t\tcontainer_of(he1, const struct pathname_entry, ent);\n\tconst struct pathname_entry *e2 =\n\t\tcontainer_of(he2, const struct pathname_entry, ent);\n\n\treturn strcmp(e1->name, name ? (const char *)name : e2->name);\n}\n\nstruct collection_status {\n\tenum { FROM_WORKTREE = 0, FROM_INDEX = 1 } mode;\n\n\tconst char *reference;\n\n\tunsigned skip_unseen:1;\n\tsize_t unmerged_count, binary_count;\n\tstruct string_list *files;\n\tstruct hashmap file_map;\n};\n\nstatic void collect_changes_cb(struct diff_queue_struct *q,\n\t\t\t       struct diff_options *options,\n\t\t\t       void *data)\n{\n\tstruct collection_status *s = data;\n\tstruct diffstat_t stat = { 0 };\n\tint i;\n\n\tif (!q->nr)\n\t\treturn;\n\n\tcompute_diffstat(options, &stat, q);\n\n\tfor (i = 0; i < stat.nr; i++) {\n\t\tconst char *name = stat.files[i]->name;\n\t\tint hash = strhash(name);\n\t\tstruct pathname_entry *entry;\n\t\tstruct file_item *file_item;\n\t\tstruct adddel *adddel, *other_adddel;\n\n\t\tentry = hashmap_get_entry_from_hash(&s->file_map, hash, name,\n\t\t\t\t\t\t    struct pathname_entry, ent);\n\t\tif (!entry) {\n\t\t\tif (s->skip_unseen)\n\t\t\t\tcontinue;\n\n\t\t\tadd_file_item(s->files, name);\n\n\t\t\tCALLOC_ARRAY(entry, 1);\n\t\t\thashmap_entry_init(&entry->ent, hash);\n\t\t\tentry->name = s->files->items[s->files->nr - 1].string;\n\t\t\tentry->item = s->files->items[s->files->nr - 1].util;\n\t\t\thashmap_add(&s->file_map, &entry->ent);\n\t\t}\n\n\t\tfile_item = entry->item;\n\t\tadddel = s->mode == FROM_INDEX ?\n\t\t\t&file_item->index : &file_item->worktree;\n\t\tother_adddel = s->mode == FROM_INDEX ?\n\t\t\t&file_item->worktree : &file_item->index;\n\t\tadddel->seen = 1;\n\t\tadddel->add = stat.files[i]->added;\n\t\tadddel->del = stat.files[i]->deleted;\n\t\tif (stat.files[i]->is_binary) {\n\t\t\tif (!other_adddel->binary)\n\t\t\t\ts->binary_count++;\n\t\t\tadddel->binary = 1;\n\t\t}\n\t\tif (stat.files[i]->is_unmerged) {\n\t\t\tif (!other_adddel->unmerged)\n\t\t\t\ts->unmerged_count++;\n\t\t\tadddel->unmerged = 1;\n\t\t}\n\t}\n\tfree_diffstat_info(&stat);\n}\n\nenum modified_files_filter {\n\tNO_FILTER = 0,\n\tWORKTREE_ONLY = 1,\n\tINDEX_ONLY = 2,\n};\n\nstatic int get_modified_files(struct repository *r,\n\t\t\t      enum modified_files_filter filter,\n\t\t\t      struct prefix_item_list *files,\n\t\t\t      const struct pathspec *ps,\n\t\t\t      size_t *unmerged_count,\n\t\t\t      size_t *binary_count)\n{\n\tstruct object_id head_oid;\n\tint is_initial = !resolve_ref_unsafe(\"HEAD\", RESOLVE_REF_READING,\n\t\t\t\t\t     &head_oid, NULL);\n\tstruct collection_status s = { 0 };\n\tint i;\n\n\tdiscard_index(r->index);\n\tif (repo_read_index_preload(r, ps, 0) < 0)\n\t\treturn error(_(\"could not read index\"));\n\n\tprefix_item_list_clear(files);\n\ts.files = &files->items;\n\thashmap_init(&s.file_map, pathname_entry_cmp, NULL, 0);\n\n\tfor (i = 0; i < 2; i++) {\n\t\tstruct rev_info rev;\n\t\tstruct setup_revision_opt opt = { 0 };\n\n\t\tif (filter == INDEX_ONLY)\n\t\t\ts.mode = (i == 0) ? FROM_INDEX : FROM_WORKTREE;\n\t\telse\n\t\t\ts.mode = (i == 0) ? FROM_WORKTREE : FROM_INDEX;\n\t\ts.skip_unseen = filter && i;\n\n\t\topt.def = is_initial ?\n\t\t\tempty_tree_oid_hex() : oid_to_hex(&head_oid);\n\n\t\tinit_revisions(&rev, NULL);\n\t\tsetup_revisions(0, NULL, &rev, &opt);\n\n\t\trev.diffopt.output_format = DIFF_FORMAT_CALLBACK;\n\t\trev.diffopt.format_callback = collect_changes_cb;\n\t\trev.diffopt.format_callback_data = &s;\n\n\t\tif (ps)\n\t\t\tcopy_pathspec(&rev.prune_data, ps);\n\n\t\tif (s.mode == FROM_INDEX)\n\t\t\trun_diff_index(&rev, 1);\n\t\telse {\n\t\t\trev.diffopt.flags.ignore_dirty_submodules = 1;\n\t\t\trun_diff_files(&rev, 0);\n\t\t}\n\n\t\trelease_revisions(&rev);\n\t}\n\thashmap_clear_and_free(&s.file_map, struct pathname_entry, ent);\n\tif (unmerged_count)\n\t\t*unmerged_count = s.unmerged_count;\n\tif (binary_count)\n\t\t*binary_count = s.binary_count;\n\n\t/* While the diffs are ordered already, we ran *two* diffs... */\n\tstring_list_sort(&files->items);\n\n\treturn 0;\n}\n\nstatic void render_adddel(struct strbuf *buf,\n\t\t\t\tstruct adddel *ad, const char *no_changes)\n{\n\tif (ad->binary)\n\t\tstrbuf_addstr(buf, _(\"binary\"));\n\telse if (ad->seen)\n\t\tstrbuf_addf(buf, \"+%\"PRIuMAX\"/-%\"PRIuMAX,\n\t\t\t    (uintmax_t)ad->add, (uintmax_t)ad->del);\n\telse\n\t\tstrbuf_addstr(buf, no_changes);\n}\n\n/* filters out prefixes which have special meaning to list_and_choose() */\nstatic int is_valid_prefix(const char *prefix, size_t prefix_len)\n{\n\treturn prefix_len && prefix &&\n\t\t/*\n\t\t * We expect `prefix` to be NUL terminated, therefore this\n\t\t * `strcspn()` call is okay, even if it might do much more\n\t\t * work than strictly necessary.\n\t\t */\n\t\tstrcspn(prefix, \" \\t\\r\\n,\") >= prefix_len &&\t/* separators */\n\t\t*prefix != '-' &&\t\t\t\t/* deselection */\n\t\t!isdigit(*prefix) &&\t\t\t\t/* selection */\n\t\t(prefix_len != 1 ||\n\t\t (*prefix != '*' &&\t\t\t\t/* \"all\" wildcard */\n\t\t  *prefix != '?'));\t\t\t\t/* prompt help */\n}\n\nstruct print_file_item_data {\n\tconst char *modified_fmt, *color, *reset;\n\tstruct strbuf buf, name, index, worktree;\n\tunsigned only_names:1;\n};\n\nstatic void print_file_item(int i, int selected, struct string_list_item *item,\n\t\t\t    void *print_file_item_data)\n{\n\tstruct file_item *c = item->util;\n\tstruct print_file_item_data *d = print_file_item_data;\n\tconst char *highlighted = NULL;\n\n\tstrbuf_reset(&d->index);\n\tstrbuf_reset(&d->worktree);\n\tstrbuf_reset(&d->buf);\n\n\t/* Format the item with the prefix highlighted. */\n\tif (c->prefix_length > 0 &&\n\t    is_valid_prefix(item->string, c->prefix_length)) {\n\t\tstrbuf_reset(&d->name);\n\t\tstrbuf_addf(&d->name, \"%s%.*s%s%s\", d->color,\n\t\t\t    (int)c->prefix_length, item->string, d->reset,\n\t\t\t    item->string + c->prefix_length);\n\t\thighlighted = d->name.buf;\n\t}\n\n\tif (d->only_names) {\n\t\tprintf(\"%c%2d: %s\", selected ? '*' : ' ', i + 1,\n\t\t       highlighted ? highlighted : item->string);\n\t\treturn;\n\t}\n\n\trender_adddel(&d->worktree, &c->worktree, _(\"nothing\"));\n\trender_adddel(&d->index, &c->index, _(\"unchanged\"));\n\n\tstrbuf_addf(&d->buf, d->modified_fmt, d->index.buf, d->worktree.buf,\n\t\t    highlighted ? highlighted : item->string);\n\n\tprintf(\"%c%2d: %s\", selected ? '*' : ' ', i + 1, d->buf.buf);\n}\n\nstatic int run_status(struct add_i_state *s, const struct pathspec *ps,\n\t\t      struct prefix_item_list *files,\n\t\t      struct list_and_choose_options *opts)\n{\n\tif (get_modified_files(s->r, NO_FILTER, files, ps, NULL, NULL) < 0)\n\t\treturn -1;\n\n\tlist(s, &files->items, NULL, &opts->list_opts);\n\tputchar('\\n');\n\n\treturn 0;\n}\n\nstatic int run_update(struct add_i_state *s, const struct pathspec *ps,\n\t\t      struct prefix_item_list *files,\n\t\t      struct list_and_choose_options *opts)\n{\n\tint res = 0, fd;\n\tsize_t count, i;\n\tstruct lock_file index_lock;\n\n\tif (get_modified_files(s->r, WORKTREE_ONLY, files, ps, NULL, NULL) < 0)\n\t\treturn -1;\n\n\tif (!files->items.nr) {\n\t\tputchar('\\n');\n\t\treturn 0;\n\t}\n\n\topts->prompt = N_(\"Update\");\n\tcount = list_and_choose(s, files, opts);\n\tif (count <= 0) {\n\t\tputchar('\\n');\n\t\treturn 0;\n\t}\n\n\tfd = repo_hold_locked_index(s->r, &index_lock, LOCK_REPORT_ON_ERROR);\n\tif (fd < 0) {\n\t\tputchar('\\n');\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < files->items.nr; i++) {\n\t\tconst char *name = files->items.items[i].string;\n\t\tstruct stat st;\n\n\t\tif (!files->selected[i])\n\t\t\tcontinue;\n\t\tif (lstat(name, &st) && is_missing_file_error(errno)) {\n\t\t\tif (remove_file_from_index(s->r->index, name) < 0) {\n\t\t\t\tres = error(_(\"could not stage '%s'\"), name);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (add_file_to_index(s->r->index, name, 0) < 0) {\n\t\t\tres = error(_(\"could not stage '%s'\"), name);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!res && write_locked_index(s->r->index, &index_lock, COMMIT_LOCK) < 0)\n\t\tres = error(_(\"could not write index\"));\n\n\tif (!res)\n\t\tprintf(Q_(\"updated %d path\\n\",\n\t\t\t  \"updated %d paths\\n\", count), (int)count);\n\n\tputchar('\\n');\n\treturn res;\n}\n\nstatic void revert_from_diff(struct diff_queue_struct *q,\n\t\t\t     struct diff_options *opt, void *data UNUSED)\n{\n\tint i, add_flags = ADD_CACHE_OK_TO_ADD | ADD_CACHE_OK_TO_REPLACE;\n\n\tfor (i = 0; i < q->nr; i++) {\n\t\tstruct diff_filespec *one = q->queue[i]->one;\n\t\tstruct cache_entry *ce;\n\n\t\tif (!(one->mode && !is_null_oid(&one->oid))) {\n\t\t\tremove_file_from_index(opt->repo->index, one->path);\n\t\t\tprintf(_(\"note: %s is untracked now.\\n\"), one->path);\n\t\t} else {\n\t\t\tce = make_cache_entry(opt->repo->index, one->mode,\n\t\t\t\t\t      &one->oid, one->path, 0, 0);\n\t\t\tif (!ce)\n\t\t\t\tdie(_(\"make_cache_entry failed for path '%s'\"),\n\t\t\t\t    one->path);\n\t\t\tadd_index_entry(opt->repo->index, ce, add_flags);\n\t\t}\n\t}\n}\n\nstatic int run_revert(struct add_i_state *s, const struct pathspec *ps,\n\t\t      struct prefix_item_list *files,\n\t\t      struct list_and_choose_options *opts)\n{\n\tint res = 0, fd;\n\tsize_t count, i, j;\n\n\tstruct object_id oid;\n\tint is_initial = !resolve_ref_unsafe(\"HEAD\", RESOLVE_REF_READING, &oid,\n\t\t\t\t\t     NULL);\n\tstruct lock_file index_lock;\n\tconst char **paths;\n\tstruct tree *tree;\n\tstruct diff_options diffopt = { NULL };\n\n\tif (get_modified_files(s->r, INDEX_ONLY, files, ps, NULL, NULL) < 0)\n\t\treturn -1;\n\n\tif (!files->items.nr) {\n\t\tputchar('\\n');\n\t\treturn 0;\n\t}\n\n\topts->prompt = N_(\"Revert\");\n\tcount = list_and_choose(s, files, opts);\n\tif (count <= 0)\n\t\tgoto finish_revert;\n\n\tfd = repo_hold_locked_index(s->r, &index_lock, LOCK_REPORT_ON_ERROR);\n\tif (fd < 0) {\n\t\tres = -1;\n\t\tgoto finish_revert;\n\t}\n\n\tif (is_initial)\n\t\toidcpy(&oid, s->r->hash_algo->empty_tree);\n\telse {\n\t\ttree = parse_tree_indirect(&oid);\n\t\tif (!tree) {\n\t\t\tres = error(_(\"Could not parse HEAD^{tree}\"));\n\t\t\tgoto finish_revert;\n\t\t}\n\t\toidcpy(&oid, &tree->object.oid);\n\t}\n\n\tALLOC_ARRAY(paths, count + 1);\n\tfor (i = j = 0; i < files->items.nr; i++)\n\t\tif (files->selected[i])\n\t\t\tpaths[j++] = files->items.items[i].string;\n\tpaths[j] = NULL;\n\n\tparse_pathspec(&diffopt.pathspec, 0,\n\t\t       PATHSPEC_PREFER_FULL | PATHSPEC_LITERAL_PATH,\n\t\t       NULL, paths);\n\n\tdiffopt.output_format = DIFF_FORMAT_CALLBACK;\n\tdiffopt.format_callback = revert_from_diff;\n\tdiffopt.flags.override_submodule_config = 1;\n\tdiffopt.repo = s->r;\n\n\tif (do_diff_cache(&oid, &diffopt)) {\n\t\tdiff_free(&diffopt);\n\t\tres = -1;\n\t} else {\n\t\tdiffcore_std(&diffopt);\n\t\tdiff_flush(&diffopt);\n\t}\n\tfree(paths);\n\n\tif (!res && write_locked_index(s->r->index, &index_lock,\n\t\t\t\t       COMMIT_LOCK) < 0)\n\t\tres = -1;\n\telse\n\t\tres = repo_refresh_and_write_index(s->r, REFRESH_QUIET, 0, 1,\n\t\t\t\t\t\t   NULL, NULL, NULL);\n\n\tif (!res)\n\t\tprintf(Q_(\"reverted %d path\\n\",\n\t\t\t  \"reverted %d paths\\n\", count), (int)count);\n\nfinish_revert:\n\tputchar('\\n');\n\treturn res;\n}\n\nstatic int get_untracked_files(struct repository *r,\n\t\t\t       struct prefix_item_list *files,\n\t\t\t       const struct pathspec *ps)\n{\n\tstruct dir_struct dir = { 0 };\n\tsize_t i;\n\tstruct strbuf buf = STRBUF_INIT;\n\n\tif (repo_read_index(r) < 0)\n\t\treturn error(_(\"could not read index\"));\n\n\tprefix_item_list_clear(files);\n\tsetup_standard_excludes(&dir);\n\tadd_pattern_list(&dir, EXC_CMDL, \"--exclude option\");\n\tfill_directory(&dir, r->index, ps);\n\n\tfor (i = 0; i < dir.nr; i++) {\n\t\tstruct dir_entry *ent = dir.entries[i];\n\n\t\tif (index_name_is_other(r->index, ent->name, ent->len)) {\n\t\t\tstrbuf_reset(&buf);\n\t\t\tstrbuf_add(&buf, ent->name, ent->len);\n\t\t\tadd_file_item(&files->items, buf.buf);\n\t\t}\n\t}\n\n\tstrbuf_release(&buf);\n\treturn 0;\n}\n\nstatic int run_add_untracked(struct add_i_state *s, const struct pathspec *ps,\n\t\t      struct prefix_item_list *files,\n\t\t      struct list_and_choose_options *opts)\n{\n\tstruct print_file_item_data *d = opts->list_opts.print_item_data;\n\tint res = 0, fd;\n\tsize_t count, i;\n\tstruct lock_file index_lock;\n\n\tif (get_untracked_files(s->r, files, ps) < 0)\n\t\treturn -1;\n\n\tif (!files->items.nr) {\n\t\tprintf(_(\"No untracked files.\\n\"));\n\t\tgoto finish_add_untracked;\n\t}\n\n\topts->prompt = N_(\"Add untracked\");\n\td->only_names = 1;\n\tcount = list_and_choose(s, files, opts);\n\td->only_names = 0;\n\tif (count <= 0)\n\t\tgoto finish_add_untracked;\n\n\tfd = repo_hold_locked_index(s->r, &index_lock, LOCK_REPORT_ON_ERROR);\n\tif (fd < 0) {\n\t\tres = -1;\n\t\tgoto finish_add_untracked;\n\t}\n\n\tfor (i = 0; i < files->items.nr; i++) {\n\t\tconst char *name = files->items.items[i].string;\n\t\tif (files->selected[i] &&\n\t\t    add_file_to_index(s->r->index, name, 0) < 0) {\n\t\t\tres = error(_(\"could not stage '%s'\"), name);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!res &&\n\t    write_locked_index(s->r->index, &index_lock, COMMIT_LOCK) < 0)\n\t\tres = error(_(\"could not write index\"));\n\n\tif (!res)\n\t\tprintf(Q_(\"added %d path\\n\",\n\t\t\t  \"added %d paths\\n\", count), (int)count);\n\nfinish_add_untracked:\n\tputchar('\\n');\n\treturn res;\n}\n\nstatic int run_patch(struct add_i_state *s, const struct pathspec *ps,\n\t\t     struct prefix_item_list *files,\n\t\t     struct list_and_choose_options *opts)\n{\n\tint res = 0;\n\tssize_t count, i, j;\n\tsize_t unmerged_count = 0, binary_count = 0;\n\n\tif (get_modified_files(s->r, WORKTREE_ONLY, files, ps,\n\t\t\t       &unmerged_count, &binary_count) < 0)\n\t\treturn -1;\n\n\tif (unmerged_count || binary_count) {\n\t\tfor (i = j = 0; i < files->items.nr; i++) {\n\t\t\tstruct file_item *item = files->items.items[i].util;\n\n\t\t\tif (item->index.binary || item->worktree.binary) {\n\t\t\t\tfree(item);\n\t\t\t\tfree(files->items.items[i].string);\n\t\t\t} else if (item->index.unmerged ||\n\t\t\t\t item->worktree.unmerged) {\n\t\t\t\tcolor_fprintf_ln(stderr, s->error_color,\n\t\t\t\t\t\t _(\"ignoring unmerged: %s\"),\n\t\t\t\t\t\t files->items.items[i].string);\n\t\t\t\tfree(item);\n\t\t\t\tfree(files->items.items[i].string);\n\t\t\t} else\n\t\t\t\tfiles->items.items[j++] = files->items.items[i];\n\t\t}\n\t\tfiles->items.nr = j;\n\t}\n\n\tif (!files->items.nr) {\n\t\tif (binary_count)\n\t\t\tfprintf(stderr, _(\"Only binary files changed.\\n\"));\n\t\telse\n\t\t\tfprintf(stderr, _(\"No changes.\\n\"));\n\t\treturn 0;\n\t}\n\n\topts->prompt = N_(\"Patch update\");\n\tcount = list_and_choose(s, files, opts);\n\tif (count > 0) {\n\t\tstruct strvec args = STRVEC_INIT;\n\t\tstruct pathspec ps_selected = { 0 };\n\n\t\tfor (i = 0; i < files->items.nr; i++)\n\t\t\tif (files->selected[i])\n\t\t\t\tstrvec_push(&args,\n\t\t\t\t\t    files->items.items[i].string);\n\t\tparse_pathspec(&ps_selected,\n\t\t\t       PATHSPEC_ALL_MAGIC & ~PATHSPEC_LITERAL,\n\t\t\t       PATHSPEC_LITERAL_PATH, \"\", args.v);\n\t\tres = run_add_p(s->r, ADD_P_ADD, NULL, &ps_selected);\n\t\tstrvec_clear(&args);\n\t\tclear_pathspec(&ps_selected);\n\t}\n\n\treturn res;\n}\n\nstatic int run_diff(struct add_i_state *s, const struct pathspec *ps,\n\t\t    struct prefix_item_list *files,\n\t\t    struct list_and_choose_options *opts)\n{\n\tint res = 0;\n\tssize_t count, i;\n\n\tstruct object_id oid;\n\tint is_initial = !resolve_ref_unsafe(\"HEAD\", RESOLVE_REF_READING, &oid,\n\t\t\t\t\t     NULL);\n\tif (get_modified_files(s->r, INDEX_ONLY, files, ps, NULL, NULL) < 0)\n\t\treturn -1;\n\n\tif (!files->items.nr) {\n\t\tputchar('\\n');\n\t\treturn 0;\n\t}\n\n\topts->prompt = N_(\"Review diff\");\n\topts->flags = IMMEDIATE;\n\tcount = list_and_choose(s, files, opts);\n\topts->flags = 0;\n\tif (count > 0) {\n\t\tstruct child_process cmd = CHILD_PROCESS_INIT;\n\n\t\tstrvec_pushl(&cmd.args, \"git\", \"diff\", \"-p\", \"--cached\",\n\t\t\t     oid_to_hex(!is_initial ? &oid :\n\t\t\t\t\ts->r->hash_algo->empty_tree),\n\t\t\t     \"--\", NULL);\n\t\tfor (i = 0; i < files->items.nr; i++)\n\t\t\tif (files->selected[i])\n\t\t\t\tstrvec_push(&cmd.args,\n\t\t\t\t\t    files->items.items[i].string);\n\t\tres = run_command(&cmd);\n\t}\n\n\tputchar('\\n');\n\treturn res;\n}\n\nstatic int run_help(struct add_i_state *s, const struct pathspec *unused_ps,\n\t\t    struct prefix_item_list *unused_files,\n\t\t    struct list_and_choose_options *unused_opts)\n{\n\tcolor_fprintf_ln(stdout, s->help_color, \"status        - %s\",\n\t\t\t _(\"show paths with changes\"));\n\tcolor_fprintf_ln(stdout, s->help_color, \"update        - %s\",\n\t\t\t _(\"add working tree state to the staged set of changes\"));\n\tcolor_fprintf_ln(stdout, s->help_color, \"revert        - %s\",\n\t\t\t _(\"revert staged set of changes back to the HEAD version\"));\n\tcolor_fprintf_ln(stdout, s->help_color, \"patch         - %s\",\n\t\t\t _(\"pick hunks and update selectively\"));\n\tcolor_fprintf_ln(stdout, s->help_color, \"diff          - %s\",\n\t\t\t _(\"view diff between HEAD and index\"));\n\tcolor_fprintf_ln(stdout, s->help_color, \"add untracked - %s\",\n\t\t\t _(\"add contents of untracked files to the staged set of changes\"));\n\n\treturn 0;\n}\n\nstatic void choose_prompt_help(struct add_i_state *s)\n{\n\tcolor_fprintf_ln(stdout, s->help_color, \"%s\",\n\t\t\t _(\"Prompt help:\"));\n\tcolor_fprintf_ln(stdout, s->help_color, \"1          - %s\",\n\t\t\t _(\"select a single item\"));\n\tcolor_fprintf_ln(stdout, s->help_color, \"3-5        - %s\",\n\t\t\t _(\"select a range of items\"));\n\tcolor_fprintf_ln(stdout, s->help_color, \"2-3,6-9    - %s\",\n\t\t\t _(\"select multiple ranges\"));\n\tcolor_fprintf_ln(stdout, s->help_color, \"foo        - %s\",\n\t\t\t _(\"select item based on unique prefix\"));\n\tcolor_fprintf_ln(stdout, s->help_color, \"-...       - %s\",\n\t\t\t _(\"unselect specified items\"));\n\tcolor_fprintf_ln(stdout, s->help_color, \"*          - %s\",\n\t\t\t _(\"choose all items\"));\n\tcolor_fprintf_ln(stdout, s->help_color, \"           - %s\",\n\t\t\t _(\"(empty) finish selecting\"));\n}\n\ntypedef int (*command_t)(struct add_i_state *s, const struct pathspec *ps,\n\t\t\t struct prefix_item_list *files,\n\t\t\t struct list_and_choose_options *opts);\n\nstruct command_item {\n\tsize_t prefix_length;\n\tcommand_t command;\n};\n\nstruct print_command_item_data {\n\tconst char *color, *reset;\n};\n\nstatic void print_command_item(int i, int selected,\n\t\t\t       struct string_list_item *item,\n\t\t\t       void *print_command_item_data)\n{\n\tstruct print_command_item_data *d = print_command_item_data;\n\tstruct command_item *util = item->util;\n\n\tif (!util->prefix_length ||\n\t    !is_valid_prefix(item->string, util->prefix_length))\n\t\tprintf(\" %2d: %s\", i + 1, item->string);\n\telse\n\t\tprintf(\" %2d: %s%.*s%s%s\", i + 1,\n\t\t       d->color, (int)util->prefix_length, item->string,\n\t\t       d->reset, item->string + util->prefix_length);\n}\n\nstatic void command_prompt_help(struct add_i_state *s)\n{\n\tconst char *help_color = s->help_color;\n\tcolor_fprintf_ln(stdout, help_color, \"%s\", _(\"Prompt help:\"));\n\tcolor_fprintf_ln(stdout, help_color, \"1          - %s\",\n\t\t\t _(\"select a numbered item\"));\n\tcolor_fprintf_ln(stdout, help_color, \"foo        - %s\",\n\t\t\t _(\"select item based on unique prefix\"));\n\tcolor_fprintf_ln(stdout, help_color, \"           - %s\",\n\t\t\t _(\"(empty) select nothing\"));\n}\n\nint run_add_i(struct repository *r, const struct pathspec *ps)\n{\n\tstruct add_i_state s = { NULL };\n\tstruct print_command_item_data data = { \"[\", \"]\" };\n\tstruct list_and_choose_options main_loop_opts = {\n\t\t{ 4, N_(\"*** Commands ***\"), print_command_item, &data },\n\t\tN_(\"What now\"), SINGLETON | IMMEDIATE, command_prompt_help\n\t};\n\tstruct {\n\t\tconst char *string;\n\t\tcommand_t command;\n\t} command_list[] = {\n\t\t{ \"status\", run_status },\n\t\t{ \"update\", run_update },\n\t\t{ \"revert\", run_revert },\n\t\t{ \"add untracked\", run_add_untracked },\n\t\t{ \"patch\", run_patch },\n\t\t{ \"diff\", run_diff },\n\t\t{ \"quit\", NULL },\n\t\t{ \"help\", run_help },\n\t};\n\tstruct prefix_item_list commands = PREFIX_ITEM_LIST_INIT;\n\n\tstruct print_file_item_data print_file_item_data = {\n\t\t\"%12s %12s %s\", NULL, NULL,\n\t\tSTRBUF_INIT, STRBUF_INIT, STRBUF_INIT, STRBUF_INIT\n\t};\n\tstruct list_and_choose_options opts = {\n\t\t{ 0, NULL, print_file_item, &print_file_item_data },\n\t\tNULL, 0, choose_prompt_help\n\t};\n\tstruct strbuf header = STRBUF_INIT;\n\tstruct prefix_item_list files = PREFIX_ITEM_LIST_INIT;\n\tssize_t i;\n\tint res = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(command_list); i++) {\n\t\tstruct command_item *util = xcalloc(1, sizeof(*util));\n\t\tutil->command = command_list[i].command;\n\t\tstring_list_append(&commands.items, command_list[i].string)\n\t\t\t->util = util;\n\t}\n\n\tinit_add_i_state(&s, r);\n\n\t/*\n\t * When color was asked for, use the prompt color for\n\t * highlighting, otherwise use square brackets.\n\t */\n\tif (s.use_color) {\n\t\tdata.color = s.prompt_color;\n\t\tdata.reset = s.reset_color;\n\t}\n\tprint_file_item_data.color = data.color;\n\tprint_file_item_data.reset = data.reset;\n\n\tstrbuf_addstr(&header, \"     \");\n\tstrbuf_addf(&header, print_file_item_data.modified_fmt,\n\t\t    _(\"staged\"), _(\"unstaged\"), _(\"path\"));\n\topts.list_opts.header = header.buf;\n\n\tdiscard_index(r->index);\n\tif (repo_read_index(r) < 0 ||\n\t    repo_refresh_and_write_index(r, REFRESH_QUIET, 0, 1,\n\t\t\t\t\t NULL, NULL, NULL) < 0)\n\t\twarning(_(\"could not refresh index\"));\n\n\tres = run_status(&s, ps, &files, &opts);\n\n\tfor (;;) {\n\t\tstruct command_item *util;\n\n\t\ti = list_and_choose(&s, &commands, &main_loop_opts);\n\t\tif (i < 0 || i >= commands.items.nr)\n\t\t\tutil = NULL;\n\t\telse\n\t\t\tutil = commands.items.items[i].util;\n\n\t\tif (i == LIST_AND_CHOOSE_QUIT || (util && !util->command)) {\n\t\t\tprintf(_(\"Bye.\\n\"));\n\t\t\tres = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (util)\n\t\t\tres = util->command(&s, ps, &files, &opts);\n\t}\n\n\tprefix_item_list_clear(&files);\n\tstrbuf_release(&print_file_item_data.buf);\n\tstrbuf_release(&print_file_item_data.name);\n\tstrbuf_release(&print_file_item_data.index);\n\tstrbuf_release(&print_file_item_data.worktree);\n\tstrbuf_release(&header);\n\tprefix_item_list_clear(&commands);\n\tclear_add_i_state(&s);\n\n\treturn res;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00a0f6f96f3f5ebc54bbfb841921c5ceff88c1c3",
  "sha1_ok": true,
  "size": 31370
}
