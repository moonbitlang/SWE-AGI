{
  "content": {
    "base64": "I2lmbmRlZiBHSVRfQ09NUEFUX1VUSUxfSAojZGVmaW5lIEdJVF9DT01QQVRfVVRJTF9ICgojaWYgX19TVERDX1ZFUlNJT05fXyAtIDAgPCAxOTk5MDFMCi8qCiAqIEdpdCBpcyBpbiBhIHRlc3RpbmcgcGVyaW9kIGZvciBtYW5kYXRvcnkgQzk5IHN1cHBvcnQgaW4gdGhlIGNvbXBpbGVyLiAgSWYKICogeW91ciBjb21waWxlciBpcyByZWFzb25hYmx5IHJlY2VudCwgeW91IGNhbiB0cnkgdG8gZW5hYmxlIEM5OSBzdXBwb3J0IChvciwKICogZm9yIE1TVkMsIEMxMSBzdXBwb3J0KS4gIElmIHlvdSBlbmNvdW50ZXIgYSBwcm9ibGVtIGFuZCBjYW4ndCBlbmFibGUgQzk5CiAqIHN1cHBvcnQgd2l0aCB5b3VyIGNvbXBpbGVyIChzdWNoIGFzIHdpdGggIi1zdGQ9Z251OTkiKSBhbmQgZG9uJ3QgaGF2ZSBhY2Nlc3MKICogdG8gb25lIHdpdGggdGhpcyBzdXBwb3J0LCBzdWNoIGFzIEdDQyBvciBDbGFuZywgeW91IGNhbiByZW1vdmUgdGhpcyAjaWYKICogZGlyZWN0aXZlLCBidXQgcGxlYXNlIHJlcG9ydCB0aGUgZGV0YWlscyBvZiB5b3VyIHN5c3RlbSB0bwogKiBnaXRAdmdlci5rZXJuZWwub3JnLgogKi8KI2Vycm9yICJSZXF1aXJlZCBDOTkgc3VwcG9ydCBpcyBpbiBhIHRlc3QgcGhhc2UuICBQbGVhc2Ugc2VlIGdpdC1jb21wYXQtdXRpbC5oIGZvciBtb3JlIGRldGFpbHMuIgojZW5kaWYKCiNpZmRlZiBVU0VfTVNWQ19DUlREQkcKLyoKICogRm9yIHRoZXNlIHRvIHdvcmsgdGhleSBtdXN0IGFwcGVhciB2ZXJ5IGVhcmx5IGluIGVhY2gKICogZmlsZSAtLSBiZWZvcmUgbW9zdCBvZiB0aGUgc3RhbmRhcmQgaGVhZGVyIGZpbGVzLgogKi8KI2luY2x1ZGUgPHN0ZGxpYi5oPgojaW5jbHVkZSA8Y3J0ZGJnLmg+CiNlbmRpZgoKI2RlZmluZSBfRklMRV9PRkZTRVRfQklUUyA2NAoKCi8qIERlcml2ZWQgZnJvbSBMaW51eCAiRmVhdHVyZXMgVGVzdCBNYWNybyIgaGVhZGVyCiAqIENvbnZlbmllbmNlIG1hY3JvcyB0byB0ZXN0IHRoZSB2ZXJzaW9ucyBvZiBnY2MgKG9yCiAqIGEgY29tcGF0aWJsZSBjb21waWxlcikuCiAqIFVzZSB0aGVtIGxpa2UgdGhpczoKICogICNpZiBHSVRfR05VQ19QUkVSRVEgKDIsOCkKICogICAuLi4gY29kZSByZXF1aXJpbmcgZ2NjIDIuOCBvciBsYXRlciAuLi4KICogICNlbmRpZgoqLwojaWYgZGVmaW5lZChfX0dOVUNfXykgJiYgZGVmaW5lZChfX0dOVUNfTUlOT1JfXykKIyBkZWZpbmUgR0lUX0dOVUNfUFJFUkVRKG1haiwgbWluKSBcCgkoKF9fR05VQ19fIDw8IDE2KSArIF9fR05VQ19NSU5PUl9fID49ICgobWFqKSA8PCAxNikgKyAobWluKSkKI2Vsc2UKICNkZWZpbmUgR0lUX0dOVUNfUFJFUkVRKG1haiwgbWluKSAwCiNlbmRpZgoKCiNpZm5kZWYgRkxFWF9BUlJBWQovKgogKiBTZWUgaWYgb3VyIGNvbXBpbGVyIGlzIGtub3duIHRvIHN1cHBvcnQgZmxleGlibGUgYXJyYXkgbWVtYmVycy4KICovCgovKgogKiBDaGVjayB2ZW5kb3Igc3BlY2lmaWMgcXVpcmtzIGZpcnN0LCBiZWZvcmUgY2hlY2tpbmcgdGhlCiAqIF9fU1REQ19WRVJTSU9OX18sIGFzIHZlbmRvciBjb21waWxlcnMgY2FuIGxpZSBhbmQgd2UgbmVlZCB0byBiZQogKiBhYmxlIHRvIHdvcmsgdGhlbSBhcm91bmQuICBOb3RlIHRoYXQgYnkgbm90IGRlZmluaW5nIEZMRVhfQVJSQVkKICogaGVyZSwgd2UgY2FuIGZhbGwgYmFjayB0byB1c2UgdGhlICJzYWZlciBidXQgYSBiaXQgd2FzdGVmdWwiIG9uZQogKiBsYXRlci4KICovCiNpZiBkZWZpbmVkKF9fU1VOUFJPX0MpICYmIChfX1NVTlBST19DIDw9IDB4NTgwKQojZWxpZiBkZWZpbmVkKF9fR05VQ19fKQojIGlmIChfX0dOVUNfXyA+PSAzKQojICBkZWZpbmUgRkxFWF9BUlJBWSAvKiBlbXB0eSAqLwojIGVsc2UKIyAgZGVmaW5lIEZMRVhfQVJSQVkgMCAvKiBvbGRlciBHTlUgZXh0ZW5zaW9uICovCiMgZW5kaWYKI2VsaWYgZGVmaW5lZChfX1NURENfVkVSU0lPTl9fKSAmJiAoX19TVERDX1ZFUlNJT05fXyA+PSAxOTk5MDFMKQojIGRlZmluZSBGTEVYX0FSUkFZIC8qIGVtcHR5ICovCiNlbmRpZgoKLyoKICogT3RoZXJ3aXNlLCBkZWZhdWx0IHRvIHNhZmVyIGJ1dCBhIGJpdCB3YXN0ZWZ1bCB0cmFkaXRpb25hbCBzdHlsZQogKi8KI2lmbmRlZiBGTEVYX0FSUkFZCiMgZGVmaW5lIEZMRVhfQVJSQVkgMQojZW5kaWYKI2VuZGlmCgoKLyoKICogQlVJTERfQVNTRVJUX09SX1pFUk8gLSBhc3NlcnQgYSBidWlsZC10aW1lIGRlcGVuZGVuY3ksIGFzIGFuIGV4cHJlc3Npb24uCiAqIEBjb25kOiB0aGUgY29tcGlsZS10aW1lIGNvbmRpdGlvbiB3aGljaCBtdXN0IGJlIHRydWUuCiAqCiAqIFlvdXIgY29tcGlsZSB3aWxsIGZhaWwgaWYgdGhlIGNvbmRpdGlvbiBpc24ndCB0cnVlLCBvciBjYW4ndCBiZSBldmFsdWF0ZWQKICogYnkgdGhlIGNvbXBpbGVyLiAgVGhpcyBjYW4gYmUgdXNlZCBpbiBhbiBleHByZXNzaW9uOiBpdHMgdmFsdWUgaXMgIjAiLgogKgogKiBFeGFtcGxlOgogKgkjZGVmaW5lIGZvb190b19jaGFyKGZvbykJCQkJCVwKICoJCSAoKGNoYXIgKikoZm9vKQkJCQkJCVwKICoJCSAgKyBCVUlMRF9BU1NFUlRfT1JfWkVSTyhvZmZzZXRvZihzdHJ1Y3QgZm9vLCBzdHJpbmcpID09IDApKQogKi8KI2RlZmluZSBCVUlMRF9BU1NFUlRfT1JfWkVSTyhjb25kKSBcCgkoc2l6ZW9mKGNoYXIgWzEgLSAyKiEoY29uZCldKSAtIDEpCgojaWYgR0lUX0dOVUNfUFJFUkVRKDMsIDEpCiAvKiAmYXJyWzBdIGRlZ3JhZGVzIHRvIGEgcG9pbnRlcjogYSBkaWZmZXJlbnQgdHlwZSBmcm9tIGFuIGFycmF5ICovCiMgZGVmaW5lIEJBUkZfVU5MRVNTX0FOX0FSUkFZKGFycikJCQkJCQlcCglCVUlMRF9BU1NFUlRfT1JfWkVSTyghX19idWlsdGluX3R5cGVzX2NvbXBhdGlibGVfcChfX3R5cGVvZl9fKGFyciksIFwKCQkJCQkJCSAgIF9fdHlwZW9mX18oJihhcnIpWzBdKSkpCiNlbHNlCiMgZGVmaW5lIEJBUkZfVU5MRVNTX0FOX0FSUkFZKGFycikgMAojZW5kaWYKLyoKICogQVJSQVlfU0laRSAtIGdldCB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIGEgdmlzaWJsZSBhcnJheQogKiBAeDogdGhlIGFycmF5IHdob3NlIHNpemUgeW91IHdhbnQuCiAqCiAqIFRoaXMgZG9lcyBub3Qgd29yayBvbiBwb2ludGVycywgb3IgYXJyYXlzIGRlY2xhcmVkIGFzIFtdLCBvcgogKiBmdW5jdGlvbiBwYXJhbWV0ZXJzLiAgV2l0aCBjb3JyZWN0IGNvbXBpbGVyIHN1cHBvcnQsIHN1Y2ggdXNhZ2UKICogd2lsbCBjYXVzZSBhIGJ1aWxkIGVycm9yIChzZWUgdGhlIGJ1aWxkX2Fzc2VydF9vcl96ZXJvIG1hY3JvKS4KICovCiNkZWZpbmUgQVJSQVlfU0laRSh4KSAoc2l6ZW9mKHgpIC8gc2l6ZW9mKCh4KVswXSkgKyBCQVJGX1VOTEVTU19BTl9BUlJBWSh4KSkKCiNkZWZpbmUgYml0c2l6ZW9mKHgpICAoQ0hBUl9CSVQgKiBzaXplb2YoeCkpCgojZGVmaW5lIG1heGltdW1fc2lnbmVkX3ZhbHVlX29mX3R5cGUoYSkgXAogICAgKElOVE1BWF9NQVggPj4gKGJpdHNpemVvZihpbnRtYXhfdCkgLSBiaXRzaXplb2YoYSkpKQoKI2RlZmluZSBtYXhpbXVtX3Vuc2lnbmVkX3ZhbHVlX29mX3R5cGUoYSkgXAogICAgKFVJTlRNQVhfTUFYID4+IChiaXRzaXplb2YodWludG1heF90KSAtIGJpdHNpemVvZihhKSkpCgovKgogKiBTaWduZWQgaW50ZWdlciBvdmVyZmxvdyBpcyB1bmRlZmluZWQgaW4gQywgc28gaGVyZSdzIGEgaGVscGVyIG1hY3JvCiAqIHRvIGRldGVjdCBpZiB0aGUgc3VtIG9mIHR3byBpbnRlZ2VycyB3aWxsIG92ZXJmbG93LgogKgogKiBSZXF1aXJlczogYSA+PSAwLCB0eXBlb2YoYSkgZXF1YWxzIHR5cGVvZihiKQogKi8KI2RlZmluZSBzaWduZWRfYWRkX292ZXJmbG93cyhhLCBiKSBcCiAgICAoKGIpID4gbWF4aW11bV9zaWduZWRfdmFsdWVfb2ZfdHlwZShhKSAtIChhKSkKCiNkZWZpbmUgdW5zaWduZWRfYWRkX292ZXJmbG93cyhhLCBiKSBcCiAgICAoKGIpID4gbWF4aW11bV91bnNpZ25lZF92YWx1ZV9vZl90eXBlKGEpIC0gKGEpKQoKLyoKICogUmV0dXJucyB0cnVlIGlmIHRoZSBtdWx0aXBsaWNhdGlvbiBvZiAiYSIgYW5kICJiIiB3aWxsCiAqIG92ZXJmbG93LiBUaGUgdHlwZXMgb2YgImEiIGFuZCAiYiIgbXVzdCBtYXRjaCBhbmQgbXVzdCBiZSB1bnNpZ25lZC4KICogTm90ZSB0aGF0IHRoaXMgbWFjcm8gZXZhbHVhdGVzICJhIiB0d2ljZSEKICovCiNkZWZpbmUgdW5zaWduZWRfbXVsdF9vdmVyZmxvd3MoYSwgYikgXAogICAgKChhKSAmJiAoYikgPiBtYXhpbXVtX3Vuc2lnbmVkX3ZhbHVlX29mX3R5cGUoYSkgLyAoYSkpCgovKgogKiBSZXR1cm5zIHRydWUgaWYgdGhlIGxlZnQgc2hpZnQgb2YgImEiIGJ5ICJzaGlmdCIgYml0cyB3aWxsCiAqIG92ZXJmbG93LiBUaGUgdHlwZSBvZiAiYSIgbXVzdCBiZSB1bnNpZ25lZC4KICovCiNkZWZpbmUgdW5zaWduZWRfbGVmdF9zaGlmdF9vdmVyZmxvd3MoYSwgc2hpZnQpIFwKICAgICgoc2hpZnQpIDwgYml0c2l6ZW9mKGEpICYmIFwKICAgICAoYSkgPiBtYXhpbXVtX3Vuc2lnbmVkX3ZhbHVlX29mX3R5cGUoYSkgPj4gKHNoaWZ0KSkKCiNpZmRlZiBfX0dOVUNfXwojZGVmaW5lIFRZUEVPRih4KSAoX190eXBlb2ZfXyh4KSkKI2Vsc2UKI2RlZmluZSBUWVBFT0YoeCkKI2VuZGlmCgojZGVmaW5lIE1TQih4LCBiaXRzKSAoKHgpICYgVFlQRU9GKHgpKH4wVUxMIDw8IChiaXRzaXplb2YoeCkgLSAoYml0cykpKSkKI2RlZmluZSBIQVNfTVVMVElfQklUUyhpKSAgKChpKSAmICgoaSkgLSAxKSkgIC8qIGNoZWNrcyBpZiBhbiBpbnRlZ2VyIGhhcyBtb3JlIHRoYW4gMSBiaXQgc2V0ICovCgojZGVmaW5lIERJVl9ST1VORF9VUChuLGQpICgoKG4pICsgKGQpIC0gMSkgLyAoZCkpCgovKiBBcHByb3hpbWF0aW9uIG9mIHRoZSBsZW5ndGggb2YgdGhlIGRlY2ltYWwgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB0eXBlLiAqLwojZGVmaW5lIGRlY2ltYWxfbGVuZ3RoKHgpCSgoaW50KShzaXplb2YoeCkgKiAyLjU2ICsgMC41KSArIDEpCgojaWZkZWYgX19NSU5HVzY0X18KI2RlZmluZSBfUE9TSVhfQ19TT1VSQ0UgMQojZWxpZiBkZWZpbmVkKF9fc3VuX18pCiAvKgogICogT24gU29sYXJpcywgd2hlbiBfWE9QRU5fRVhURU5ERUQgaXMgc2V0LCBpdHMgaGVhZGVyIGZpbGUKICAqIGZvcmNlcyB0aGUgcHJvZ3JhbXMgdG8gYmUgWFBHNHYyLCBkZWZlYXRpbmcgYW55IF9YT1BFTl9TT1VSQ0UKICAqIHNldHRpbmcgdG8gc2F5IHdlIGFyZSBYUEc1IG9yIFhQRzYuICBBbHNvIG9uIFNvbGFyaXMsCiAgKiBYUEc2IHByb2dyYW1zIG11c3QgYmUgY29tcGlsZWQgd2l0aCBhIGM5OSBjb21waWxlciwgd2hpbGUKICAqIG5vbiBYUEc2IHByb2dyYW1zIG11c3QgYmUgY29tcGlsZWQgd2l0aCBhIHByZS1jOTkgY29tcGlsZXIuCiAgKi8KIyBpZiBfX1NURENfVkVSU0lPTl9fIC0gMCA+PSAxOTk5MDFMCiMgZGVmaW5lIF9YT1BFTl9TT1VSQ0UgNjAwCiMgZWxzZQojIGRlZmluZSBfWE9QRU5fU09VUkNFIDUwMAojIGVuZGlmCiNlbGlmICFkZWZpbmVkKF9fQVBQTEVfXykgJiYgIWRlZmluZWQoX19GcmVlQlNEX18pICYmICFkZWZpbmVkKF9fVVNMQ19fKSAmJiBcCiAgICAgICFkZWZpbmVkKF9NX1VOSVgpICYmICFkZWZpbmVkKF9fc2dpKSAmJiAhZGVmaW5lZChfX0RyYWdvbkZseV9fKSAmJiBcCiAgICAgICFkZWZpbmVkKF9fVEFOREVNKSAmJiAhZGVmaW5lZChfX1FOWF9fKSAmJiAhZGVmaW5lZChfX01pckJTRF9fKSAmJiBcCiAgICAgICFkZWZpbmVkKF9fQ1lHV0lOX18pCiNkZWZpbmUgX1hPUEVOX1NPVVJDRSA2MDAgLyogZ2xpYmMyIGFuZCBBSVggNS4zTCBuZWVkIDUwMCwgT3BlbkJTRCBuZWVkcyA2MDAgZm9yIFNfSVNMTksoKSAqLwojZGVmaW5lIF9YT1BFTl9TT1VSQ0VfRVhURU5ERUQgMSAvKiBBSVggNS4zTCBuZWVkcyB0aGlzICovCiNlbmRpZgojZGVmaW5lIF9BTExfU09VUkNFIDEKI2RlZmluZSBfR05VX1NPVVJDRSAxCiNkZWZpbmUgX0JTRF9TT1VSQ0UgMQojZGVmaW5lIF9ERUZBVUxUX1NPVVJDRSAxCiNkZWZpbmUgX05FVEJTRF9TT1VSQ0UgMQojZGVmaW5lIF9TR0lfU09VUkNFIDEKCiNpZiBkZWZpbmVkKFdJTjMyKSAmJiAhZGVmaW5lZChfX0NZR1dJTl9fKSAvKiBCb3RoIE1pbkdXIGFuZCBNU1ZDICovCiMgaWYgIWRlZmluZWQoX1dJTjMyX1dJTk5UKQojICBkZWZpbmUgX1dJTjMyX1dJTk5UIDB4MDYwMAojIGVuZGlmCiNkZWZpbmUgV0lOMzJfTEVBTl9BTkRfTUVBTiAgLyogc3RvcHMgd2luZG93cy5oIGluY2x1ZGluZyB3aW5zb2NrLmggKi8KI2luY2x1ZGUgPHdpbnNvY2syLmg+CiNpZm5kZWYgTk9fVU5JWF9TT0NLRVRTCiNpbmNsdWRlIDxhZnVuaXguaD4KI2VuZGlmCiNpbmNsdWRlIDx3aW5kb3dzLmg+CiNkZWZpbmUgR0lUX1dJTkRPV1NfTkFUSVZFCiNlbmRpZgoKI2luY2x1ZGUgPHVuaXN0ZC5oPgojaW5jbHVkZSA8c3RkaW8uaD4KI2luY2x1ZGUgPHN5cy9zdGF0Lmg+CiNpbmNsdWRlIDxmY250bC5oPgojaW5jbHVkZSA8c3RkZGVmLmg+CiNpbmNsdWRlIDxzdGRsaWIuaD4KI2luY2x1ZGUgPHN0ZGFyZy5oPgojaW5jbHVkZSA8c3RyaW5nLmg+CiNpZmRlZiBIQVZFX1NUUklOR1NfSAojaW5jbHVkZSA8c3RyaW5ncy5oPiAvKiBmb3Igc3RyY2FzZWNtcCgpICovCiNlbmRpZgojaW5jbHVkZSA8ZXJybm8uaD4KI2luY2x1ZGUgPGxpbWl0cy5oPgojaWZkZWYgTkVFRFNfU1lTX1BBUkFNX0gKI2luY2x1ZGUgPHN5cy9wYXJhbS5oPgojZW5kaWYKI2luY2x1ZGUgPHN5cy90eXBlcy5oPgojaW5jbHVkZSA8ZGlyZW50Lmg+CiNpbmNsdWRlIDxzeXMvdGltZS5oPgojaW5jbHVkZSA8dGltZS5oPgojaW5jbHVkZSA8c2lnbmFsLmg+CiNpbmNsdWRlIDxhc3NlcnQuaD4KI2luY2x1ZGUgPHJlZ2V4Lmg+CiNpbmNsdWRlIDx1dGltZS5oPgojaW5jbHVkZSA8c3lzbG9nLmg+CiNpZiAhZGVmaW5lZChOT19QT0xMX0gpCiNpbmNsdWRlIDxwb2xsLmg+CiNlbGlmICFkZWZpbmVkKE5PX1NZU19QT0xMX0gpCiNpbmNsdWRlIDxzeXMvcG9sbC5oPgojZWxzZQovKiBQdWxsIHRoZSBjb21wYXQgc3R1ZmYgKi8KI2luY2x1ZGUgPHBvbGwuaD4KI2VuZGlmCiNpZmRlZiBIQVZFX0JTRF9TWVNDVEwKI2luY2x1ZGUgPHN5cy9zeXNjdGwuaD4KI2VuZGlmCgojaWYgZGVmaW5lZChfX0NZR1dJTl9fKQojaW5jbHVkZSAiY29tcGF0L3dpbjMyL3BhdGgtdXRpbHMuaCIKI2VuZGlmCiNpZiBkZWZpbmVkKF9fTUlOR1czMl9fKQovKiBwdWxsIGluIFdpbmRvd3MgY29tcGF0aWJpbGl0eSBzdHVmZiAqLwojaW5jbHVkZSAiY29tcGF0L3dpbjMyL3BhdGgtdXRpbHMuaCIKI2luY2x1ZGUgImNvbXBhdC9taW5ndy5oIgojZWxpZiBkZWZpbmVkKF9NU0NfVkVSKQojaW5jbHVkZSAiY29tcGF0L3dpbjMyL3BhdGgtdXRpbHMuaCIKI2luY2x1ZGUgImNvbXBhdC9tc3ZjLmgiCiNlbHNlCiNpbmNsdWRlIDxzeXMvdXRzbmFtZS5oPgojaW5jbHVkZSA8c3lzL3dhaXQuaD4KI2luY2x1ZGUgPHN5cy9yZXNvdXJjZS5oPgojaW5jbHVkZSA8c3lzL3NvY2tldC5oPgojaW5jbHVkZSA8c3lzL2lvY3RsLmg+CiNpbmNsdWRlIDx0ZXJtaW9zLmg+CiNpZm5kZWYgTk9fU1lTX1NFTEVDVF9ICiNpbmNsdWRlIDxzeXMvc2VsZWN0Lmg+CiNlbmRpZgojaW5jbHVkZSA8bmV0aW5ldC9pbi5oPgojaW5jbHVkZSA8bmV0aW5ldC90Y3AuaD4KI2luY2x1ZGUgPGFycGEvaW5ldC5oPgojaW5jbHVkZSA8bmV0ZGIuaD4KI2luY2x1ZGUgPHB3ZC5oPgojaW5jbHVkZSA8c3lzL3VuLmg+CiNpZm5kZWYgTk9fSU5UVFlQRVNfSAojaW5jbHVkZSA8aW50dHlwZXMuaD4KI2Vsc2UKI2luY2x1ZGUgPHN0ZGludC5oPgojZW5kaWYKI2lmZGVmIEhBVkVfQVJDNFJBTkRPTV9MSUJCU0QKI2luY2x1ZGUgPGJzZC9zdGRsaWIuaD4KI2VuZGlmCiNpZmRlZiBIQVZFX0dFVFJBTkRPTQojaW5jbHVkZSA8c3lzL3JhbmRvbS5oPgojZW5kaWYKI2lmZGVmIE5PX0lOVFBUUl9UCi8qCiAqIE9uIEkxNkxQMzIsIElMUDMyIGFuZCBMUDY0ICJsb25nIiBpcyB0aGUgc2FmZSBiZXQsIGhvd2V2ZXIKICogb24gTExQODYsIElMMzNMTFA2NCBhbmQgUDY0IGl0IG5lZWRzIHRvIGJlICJsb25nIGxvbmciLAogKiB3aGlsZSBvbiBJUDE2IGFuZCBJUDE2TDMyIGl0IGlzICJpbnQiIChyZXNwLiAic2hvcnQiKQogKiBTaXplIG5lZWRzIHRvIG1hdGNoIChvciBleGNlZWQpICdzaXplb2Yodm9pZCAqKScuCiAqIFdlIGNhbid0IHRha2UgImxvbmcgbG9uZyIgaGVyZSBhcyBub3QgZXZlcnlib2R5IGhhcyBpdC4KICovCnR5cGVkZWYgbG9uZyBpbnRwdHJfdDsKdHlwZWRlZiB1bnNpZ25lZCBsb25nIHVpbnRwdHJfdDsKI2VuZGlmCiN1bmRlZiBfQUxMX1NPVVJDRSAvKiBBSVggNS4zTCBkZWZpbmVzIGEgc3RydWN0IGxpc3Qgd2l0aCBfQUxMX1NPVVJDRS4gKi8KI2luY2x1ZGUgPGdycC5oPgojZGVmaW5lIF9BTExfU09VUkNFIDEKI2VuZGlmCgovKiB1c2VkIG9uIE1hYyBPUyBYICovCiNpZmRlZiBQUkVDT01QT1NFX1VOSUNPREUKI2luY2x1ZGUgImNvbXBhdC9wcmVjb21wb3NlX3V0ZjguaCIKI2Vsc2UKc3RhdGljIGlubGluZSBjb25zdCBjaGFyICpwcmVjb21wb3NlX2FyZ3ZfcHJlZml4KGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndiwgY29uc3QgY2hhciAqcHJlZml4KQp7CglyZXR1cm4gcHJlZml4Owp9CnN0YXRpYyBpbmxpbmUgY29uc3QgY2hhciAqcHJlY29tcG9zZV9zdHJpbmdfaWZfbmVlZGVkKGNvbnN0IGNoYXIgKmluKQp7CglyZXR1cm4gaW47Cn0KCiNkZWZpbmUgcHJvYmVfdXRmOF9wYXRobmFtZV9jb21wb3NpdGlvbigpCiNlbmRpZgoKI2lmZGVmIE1LRElSX1dPX1RSQUlMSU5HX1NMQVNICiNkZWZpbmUgbWtkaXIoYSxiKSBjb21wYXRfbWtkaXJfd29fdHJhaWxpbmdfc2xhc2goKGEpLChiKSkKaW50IGNvbXBhdF9ta2Rpcl93b190cmFpbGluZ19zbGFzaChjb25zdCBjaGFyKiwgbW9kZV90KTsKI2VuZGlmCgojaWZkZWYgTk9fU1RSVUNUX0lUSU1FUlZBTApzdHJ1Y3QgaXRpbWVydmFsIHsKCXN0cnVjdCB0aW1ldmFsIGl0X2ludGVydmFsOwoJc3RydWN0IHRpbWV2YWwgaXRfdmFsdWU7Cn07CiNlbmRpZgoKI2lmZGVmIE5PX1NFVElUSU1FUgpzdGF0aWMgaW5saW5lIGludCBzZXRpdGltZXIoaW50IHdoaWNoLCBjb25zdCBzdHJ1Y3QgaXRpbWVydmFsICp2YWx1ZSwgc3RydWN0IGl0aW1lcnZhbCAqbmV3dmFsdWUpIHsKCXJldHVybiAwOyAvKiBwcmV0ZW5kIHN1Y2Nlc3MgKi8KfQojZW5kaWYKCiNpZm5kZWYgTk9fTElCR0VOX0gKI2luY2x1ZGUgPGxpYmdlbi5oPgojZWxzZQojZGVmaW5lIGJhc2VuYW1lIGdpdGJhc2VuYW1lCmNoYXIgKmdpdGJhc2VuYW1lKGNoYXIgKik7CiNkZWZpbmUgZGlybmFtZSBnaXRkaXJuYW1lCmNoYXIgKmdpdGRpcm5hbWUoY2hhciAqKTsKI2VuZGlmCgojaWZuZGVmIE5PX0lDT05WCiNpbmNsdWRlIDxpY29udi5oPgojZW5kaWYKCiNpZm5kZWYgTk9fT1BFTlNTTAojaWZkZWYgX19BUFBMRV9fCiNkZWZpbmUgX19BVkFJTEFCSUxJVFlfTUFDUk9TX1VTRVNfQVZBSUxBQklMSVRZIDAKI2luY2x1ZGUgPEF2YWlsYWJpbGl0eU1hY3Jvcy5oPgojdW5kZWYgREVQUkVDQVRFRF9BVFRSSUJVVEUKI2RlZmluZSBERVBSRUNBVEVEX0FUVFJJQlVURQojdW5kZWYgX19BVkFJTEFCSUxJVFlfTUFDUk9TX1VTRVNfQVZBSUxBQklMSVRZCiNlbmRpZgojaW5jbHVkZSA8b3BlbnNzbC9zc2wuaD4KI2luY2x1ZGUgPG9wZW5zc2wvZXJyLmg+CiNlbmRpZgoKI2lmZGVmIEhBVkVfU1lTSU5GTwojIGluY2x1ZGUgPHN5cy9zeXNpbmZvLmg+CiNlbmRpZgoKLyogT24gbW9zdCBzeXN0ZW1zIDxuZXRkYi5oPiB3b3VsZCBoYXZlIGdpdmVuIHVzIHRoaXMsIGJ1dAogKiBub3Qgb24gc29tZSBzeXN0ZW1zIChlLmcuIHovT1MpLgogKi8KI2lmbmRlZiBOSV9NQVhIT1NUCiNkZWZpbmUgTklfTUFYSE9TVCAxMDI1CiNlbmRpZgoKI2lmbmRlZiBOSV9NQVhTRVJWCiNkZWZpbmUgTklfTUFYU0VSViAzMgojZW5kaWYKCi8qIE9uIG1vc3Qgc3lzdGVtcyA8bGltaXRzLmg+IHdvdWxkIGhhdmUgZ2l2ZW4gdXMgdGhpcywgYnV0CiAqIG5vdCBvbiBzb21lIHN5c3RlbXMgKGUuZy4gR05VL0h1cmQpLgogKi8KI2lmbmRlZiBQQVRIX01BWAojZGVmaW5lIFBBVEhfTUFYIDQwOTYKI2VuZGlmCgp0eXBlZGVmIHVpbnRtYXhfdCB0aW1lc3RhbXBfdDsKI2RlZmluZSBQUkl0aW1lIFBSSXVNQVgKI2RlZmluZSBwYXJzZV90aW1lc3RhbXAgc3RydG91bWF4CiNkZWZpbmUgVElNRV9NQVggVUlOVE1BWF9NQVgKI2RlZmluZSBUSU1FX01JTiAwCgojaWZuZGVmIFBBVEhfU0VQCiNkZWZpbmUgUEFUSF9TRVAgJzonCiNlbmRpZgoKI2lmZGVmIEhBVkVfUEFUSFNfSAojaW5jbHVkZSA8cGF0aHMuaD4KI2VuZGlmCiNpZm5kZWYgX1BBVEhfREVGUEFUSAojZGVmaW5lIF9QQVRIX0RFRlBBVEggIi91c3IvbG9jYWwvYmluOi91c3IvYmluOi9iaW4iCiNlbmRpZgoKI2lmbmRlZiBwbGF0Zm9ybV9jb3JlX2NvbmZpZwpzdGF0aWMgaW5saW5lIGludCBub29wX2NvcmVfY29uZmlnKGNvbnN0IGNoYXIgKnZhciwgY29uc3QgY2hhciAqdmFsdWUsIHZvaWQgKmNiKQp7CglyZXR1cm4gMDsKfQojZGVmaW5lIHBsYXRmb3JtX2NvcmVfY29uZmlnIG5vb3BfY29yZV9jb25maWcKI2VuZGlmCgppbnQgbHN0YXRfY2FjaGVfYXdhcmVfcm1kaXIoY29uc3QgY2hhciAqcGF0aCk7CiNpZiAhZGVmaW5lZChfX01JTkdXMzJfXykgJiYgIWRlZmluZWQoX01TQ19WRVIpCiNkZWZpbmUgcm1kaXIgbHN0YXRfY2FjaGVfYXdhcmVfcm1kaXIKI2VuZGlmCgojaWZuZGVmIGhhc19kb3NfZHJpdmVfcHJlZml4CnN0YXRpYyBpbmxpbmUgaW50IGdpdF9oYXNfZG9zX2RyaXZlX3ByZWZpeChjb25zdCBjaGFyICpwYXRoKQp7CglyZXR1cm4gMDsKfQojZGVmaW5lIGhhc19kb3NfZHJpdmVfcHJlZml4IGdpdF9oYXNfZG9zX2RyaXZlX3ByZWZpeAojZW5kaWYKCiNpZm5kZWYgc2tpcF9kb3NfZHJpdmVfcHJlZml4CnN0YXRpYyBpbmxpbmUgaW50IGdpdF9za2lwX2Rvc19kcml2ZV9wcmVmaXgoY2hhciAqKnBhdGgpCnsKCXJldHVybiAwOwp9CiNkZWZpbmUgc2tpcF9kb3NfZHJpdmVfcHJlZml4IGdpdF9za2lwX2Rvc19kcml2ZV9wcmVmaXgKI2VuZGlmCgojaWZuZGVmIGlzX2Rpcl9zZXAKc3RhdGljIGlubGluZSBpbnQgZ2l0X2lzX2Rpcl9zZXAoaW50IGMpCnsKCXJldHVybiBjID09ICcvJzsKfQojZGVmaW5lIGlzX2Rpcl9zZXAgZ2l0X2lzX2Rpcl9zZXAKI2VuZGlmCgojaWZuZGVmIG9mZnNldF8xc3RfY29tcG9uZW50CnN0YXRpYyBpbmxpbmUgaW50IGdpdF9vZmZzZXRfMXN0X2NvbXBvbmVudChjb25zdCBjaGFyICpwYXRoKQp7CglyZXR1cm4gaXNfZGlyX3NlcChwYXRoWzBdKTsKfQojZGVmaW5lIG9mZnNldF8xc3RfY29tcG9uZW50IGdpdF9vZmZzZXRfMXN0X2NvbXBvbmVudAojZW5kaWYKCiNpZm5kZWYgaXNfdmFsaWRfcGF0aAojZGVmaW5lIGlzX3ZhbGlkX3BhdGgocGF0aCkgMQojZW5kaWYKCiNpZm5kZWYgZmluZF9sYXN0X2Rpcl9zZXAKc3RhdGljIGlubGluZSBjaGFyICpnaXRfZmluZF9sYXN0X2Rpcl9zZXAoY29uc3QgY2hhciAqcGF0aCkKewoJcmV0dXJuIHN0cnJjaHIocGF0aCwgJy8nKTsKfQojZGVmaW5lIGZpbmRfbGFzdF9kaXJfc2VwIGdpdF9maW5kX2xhc3RfZGlyX3NlcAojZW5kaWYKCiNpZm5kZWYgaGFzX2Rpcl9zZXAKc3RhdGljIGlubGluZSBpbnQgZ2l0X2hhc19kaXJfc2VwKGNvbnN0IGNoYXIgKnBhdGgpCnsKCXJldHVybiAhIXN0cmNocihwYXRoLCAnLycpOwp9CiNkZWZpbmUgaGFzX2Rpcl9zZXAocGF0aCkgZ2l0X2hhc19kaXJfc2VwKHBhdGgpCiNlbmRpZgoKI2lmbmRlZiBxdWVyeV91c2VyX2VtYWlsCiNkZWZpbmUgcXVlcnlfdXNlcl9lbWFpbCgpIE5VTEwKI2VuZGlmCgojaWZkZWYgX19UQU5ERU0KI2luY2x1ZGUgPGZsb3NzLmgoZmxvc3NfZXhlY2wsZmxvc3NfZXhlY2xwLGZsb3NzX2V4ZWN2LGZsb3NzX2V4ZWN2cCk+CiNpbmNsdWRlIDxmbG9zcy5oKGZsb3NzX2dldHB3dWlkKT4KI2lmbmRlZiBOU0lHCi8qCiAqIE5vblN0b3AgTlNFIGFuZCBOU1ggZG8gbm90IHByb3ZpZGUgTlNJRy4gU0lHR1VBUkRJQU4oOTkpIGlzIHRoZSBoaWdoZXN0CiAqIGtub3duLCBieSBkZXRlY3RpdmUgd29yayB1c2luZyBraWxsIC1sIGFzIGEgbGlzdCBpcyBhbGwgc2lnbmFscwogKiBpbnN0ZWFkIG9mIHNpZ25hbC5oIHdoZXJlIGl0IHNob3VsZCBiZS4KICovCiMgZGVmaW5lIE5TSUcgMTAwCiNlbmRpZgojZW5kaWYKCiNpZiBkZWZpbmVkKF9fSFBfY2MpICYmIChfX0hQX2NjID49IDYxMDAwKQojZGVmaW5lIE5PUkVUVVJOIF9fYXR0cmlidXRlX18oKG5vcmV0dXJuKSkKI2RlZmluZSBOT1JFVFVSTl9QVFIKI2VsaWYgZGVmaW5lZChfX0dOVUNfXykgJiYgIWRlZmluZWQoTk9fTk9SRVRVUk4pCiNkZWZpbmUgTk9SRVRVUk4gX19hdHRyaWJ1dGVfXygoX19ub3JldHVybl9fKSkKI2RlZmluZSBOT1JFVFVSTl9QVFIgX19hdHRyaWJ1dGVfXygoX19ub3JldHVybl9fKSkKI2VsaWYgZGVmaW5lZChfTVNDX1ZFUikKI2RlZmluZSBOT1JFVFVSTiBfX2RlY2xzcGVjKG5vcmV0dXJuKQojZGVmaW5lIE5PUkVUVVJOX1BUUgojZWxzZQojZGVmaW5lIE5PUkVUVVJOCiNkZWZpbmUgTk9SRVRVUk5fUFRSCiNpZm5kZWYgX19HTlVDX18KI2lmbmRlZiBfX2F0dHJpYnV0ZV9fCiNkZWZpbmUgX19hdHRyaWJ1dGVfXyh4KQojZW5kaWYKI2VuZGlmCiNlbmRpZgoKLyogVGhlIHNlbnRpbmVsIGF0dHJpYnV0ZSBpcyB2YWxpZCBmcm9tIGdjYyB2ZXJzaW9uIDQuMCAqLwojaWYgZGVmaW5lZChfX0dOVUNfXykgJiYgKF9fR05VQ19fID49IDQpCiNkZWZpbmUgTEFTVF9BUkdfTVVTVF9CRV9OVUxMIF9fYXR0cmlidXRlX18oKHNlbnRpbmVsKSkKI2Vsc2UKI2RlZmluZSBMQVNUX0FSR19NVVNUX0JFX05VTEwKI2VuZGlmCgojZGVmaW5lIE1BWUJFX1VOVVNFRCBfX2F0dHJpYnV0ZV9fKChfX3VudXNlZF9fKSkKCiNpbmNsdWRlICJjb21wYXQvYnN3YXAuaCIKCiNpbmNsdWRlICJ3aWxkbWF0Y2guaCIKCnN0cnVjdCBzdHJidWY7CgovKiBHZW5lcmFsIGhlbHBlciBmdW5jdGlvbnMgKi8KTk9SRVRVUk4gdm9pZCB1c2FnZShjb25zdCBjaGFyICplcnIpOwpOT1JFVFVSTiB2b2lkIHVzYWdlZihjb25zdCBjaGFyICplcnIsIC4uLikgX19hdHRyaWJ1dGVfXygoZm9ybWF0IChwcmludGYsIDEsIDIpKSk7Ck5PUkVUVVJOIHZvaWQgZGllKGNvbnN0IGNoYXIgKmVyciwgLi4uKSBfX2F0dHJpYnV0ZV9fKChmb3JtYXQgKHByaW50ZiwgMSwgMikpKTsKTk9SRVRVUk4gdm9pZCBkaWVfZXJybm8oY29uc3QgY2hhciAqZXJyLCAuLi4pIF9fYXR0cmlidXRlX18oKGZvcm1hdCAocHJpbnRmLCAxLCAyKSkpOwppbnQgZGllX21lc3NhZ2UoY29uc3QgY2hhciAqZXJyLCAuLi4pIF9fYXR0cmlidXRlX18oKGZvcm1hdCAocHJpbnRmLCAxLCAyKSkpOwppbnQgZGllX21lc3NhZ2VfZXJybm8oY29uc3QgY2hhciAqZXJyLCAuLi4pIF9fYXR0cmlidXRlX18oKGZvcm1hdCAocHJpbnRmLCAxLCAyKSkpOwppbnQgZXJyb3IoY29uc3QgY2hhciAqZXJyLCAuLi4pIF9fYXR0cmlidXRlX18oKGZvcm1hdCAocHJpbnRmLCAxLCAyKSkpOwppbnQgZXJyb3JfZXJybm8oY29uc3QgY2hhciAqZXJyLCAuLi4pIF9fYXR0cmlidXRlX18oKGZvcm1hdCAocHJpbnRmLCAxLCAyKSkpOwp2b2lkIHdhcm5pbmcoY29uc3QgY2hhciAqZXJyLCAuLi4pIF9fYXR0cmlidXRlX18oKGZvcm1hdCAocHJpbnRmLCAxLCAyKSkpOwp2b2lkIHdhcm5pbmdfZXJybm8oY29uc3QgY2hhciAqZXJyLCAuLi4pIF9fYXR0cmlidXRlX18oKGZvcm1hdCAocHJpbnRmLCAxLCAyKSkpOwoKI2lmbmRlZiBOT19PUEVOU1NMCiNpZmRlZiBBUFBMRV9DT01NT05fQ1JZUFRPCiNpbmNsdWRlICJjb21wYXQvYXBwbGUtY29tbW9uLWNyeXB0by5oIgojZWxzZQojaW5jbHVkZSA8b3BlbnNzbC9ldnAuaD4KI2luY2x1ZGUgPG9wZW5zc2wvaG1hYy5oPgojZW5kaWYgLyogQVBQTEVfQ09NTU9OX0NSWVBUTyAqLwojaW5jbHVkZSA8b3BlbnNzbC94NTA5djMuaD4KI2VuZGlmIC8qIE5PX09QRU5TU0wgKi8KCi8qCiAqIExldCBjYWxsZXJzIGJlIGF3YXJlIG9mIHRoZSBjb25zdGFudCByZXR1cm4gdmFsdWU7IHRoaXMgY2FuIGhlbHAKICogZ2NjIHdpdGggLVd1bmluaXRpYWxpemVkIGFuYWx5c2lzLiBXZSByZXN0cmljdCB0aGlzIHRyaWNrIHRvIGdjYywgdGhvdWdoLAogKiBiZWNhdXNlIHNvbWUgY29tcGlsZXJzIG1heSBub3Qgc3VwcG9ydCB2YXJpYWRpYyBtYWNyb3MuIFNpbmNlIHdlJ3JlIG9ubHkKICogdHJ5aW5nIHRvIGhlbHAgZ2NjLCBhbnl3YXksIGl0J3MgT0s7IG90aGVyIGNvbXBpbGVycyB3aWxsIGZhbGwgYmFjayB0bwogKiB1c2luZyB0aGUgZnVuY3Rpb24gYXMgdXN1YWwuCiAqLwojaWYgZGVmaW5lZChfX0dOVUNfXykKc3RhdGljIGlubGluZSBpbnQgY29uc3RfZXJyb3Iodm9pZCkKewoJcmV0dXJuIC0xOwp9CiNkZWZpbmUgZXJyb3IoLi4uKSAoZXJyb3IoX19WQV9BUkdTX18pLCBjb25zdF9lcnJvcigpKQojZGVmaW5lIGVycm9yX2Vycm5vKC4uLikgKGVycm9yX2Vycm5vKF9fVkFfQVJHU19fKSwgY29uc3RfZXJyb3IoKSkKI2VuZGlmCgp0eXBlZGVmIHZvaWQgKCpyZXBvcnRfZm4pKGNvbnN0IGNoYXIgKiwgdmFfbGlzdCBwYXJhbXMpOwoKdm9pZCBzZXRfZGllX3JvdXRpbmUoTk9SRVRVUk5fUFRSIHJlcG9ydF9mbiByb3V0aW5lKTsKcmVwb3J0X2ZuIGdldF9kaWVfbWVzc2FnZV9yb3V0aW5lKHZvaWQpOwp2b2lkIHNldF9lcnJvcl9yb3V0aW5lKHJlcG9ydF9mbiByb3V0aW5lKTsKcmVwb3J0X2ZuIGdldF9lcnJvcl9yb3V0aW5lKHZvaWQpOwp2b2lkIHNldF93YXJuX3JvdXRpbmUocmVwb3J0X2ZuIHJvdXRpbmUpOwpyZXBvcnRfZm4gZ2V0X3dhcm5fcm91dGluZSh2b2lkKTsKdm9pZCBzZXRfZGllX2lzX3JlY3Vyc2luZ19yb3V0aW5lKGludCAoKnJvdXRpbmUpKHZvaWQpKTsKCmludCBzdGFydHNfd2l0aChjb25zdCBjaGFyICpzdHIsIGNvbnN0IGNoYXIgKnByZWZpeCk7CmludCBpc3RhcnRzX3dpdGgoY29uc3QgY2hhciAqc3RyLCBjb25zdCBjaGFyICpwcmVmaXgpOwoKLyoKICogSWYgdGhlIHN0cmluZyAic3RyIiBiZWdpbnMgd2l0aCB0aGUgc3RyaW5nIGZvdW5kIGluICJwcmVmaXgiLCByZXR1cm4gMS4KICogVGhlICJvdXQiIHBhcmFtZXRlciBpcyBzZXQgdG8gInN0ciArIHN0cmxlbihwcmVmaXgpIiAoaS5lLiwgdG8gdGhlIHBvaW50IGluCiAqIHRoZSBzdHJpbmcgcmlnaHQgYWZ0ZXIgdGhlIHByZWZpeCkuCiAqCiAqIE90aGVyd2lzZSwgcmV0dXJuIDAgYW5kIGxlYXZlICJvdXQiIHVudG91Y2hlZC4KICoKICogRXhhbXBsZXM6CiAqCiAqICAgW2V4dHJhY3QgYnJhbmNoIG5hbWUsIGZhaWwgaWYgbm90IGEgYnJhbmNoXQogKiAgIGlmICghc2tpcF9wcmVmaXgocmVmLCAicmVmcy9oZWFkcy8iLCAmYnJhbmNoKQogKglyZXR1cm4gLTE7CiAqCiAqICAgW3NraXAgcHJlZml4IGlmIHByZXNlbnQsIG90aGVyd2lzZSB1c2Ugd2hvbGUgc3RyaW5nXQogKiAgIHNraXBfcHJlZml4KG5hbWUsICJyZWZzL2hlYWRzLyIsICZuYW1lKTsKICovCnN0YXRpYyBpbmxpbmUgaW50IHNraXBfcHJlZml4KGNvbnN0IGNoYXIgKnN0ciwgY29uc3QgY2hhciAqcHJlZml4LAoJCQkgICAgICBjb25zdCBjaGFyICoqb3V0KQp7CglkbyB7CgkJaWYgKCEqcHJlZml4KSB7CgkJCSpvdXQgPSBzdHI7CgkJCXJldHVybiAxOwoJCX0KCX0gd2hpbGUgKCpzdHIrKyA9PSAqcHJlZml4KyspOwoJcmV0dXJuIDA7Cn0KCi8qCiAqIElmIHRoZSBzdHJpbmcgInN0ciIgaXMgdGhlIHNhbWUgYXMgdGhlIHN0cmluZyBpbiAicHJlZml4IiwgdGhlbiB0aGUgImFyZyIKICogcGFyYW1ldGVyIGlzIHNldCB0byB0aGUgImRlZiIgcGFyYW1ldGVyIGFuZCAxIGlzIHJldHVybmVkLgogKiBJZiB0aGUgc3RyaW5nICJzdHIiIGJlZ2lucyB3aXRoIHRoZSBzdHJpbmcgZm91bmQgaW4gInByZWZpeCIgYW5kIHRoZW4gYQogKiAiPSIgc2lnbiwgdGhlbiB0aGUgImFyZyIgcGFyYW1ldGVyIGlzIHNldCB0byAic3RyICsgc3RybGVuKHByZWZpeCkgKyAxIgogKiAoaS5lLiwgdG8gdGhlIHBvaW50IGluIHRoZSBzdHJpbmcgcmlnaHQgYWZ0ZXIgdGhlIHByZWZpeCBhbmQgdGhlICI9IiBzaWduKSwKICogYW5kIDEgaXMgcmV0dXJuZWQuCiAqCiAqIE90aGVyd2lzZSwgcmV0dXJuIDAgYW5kIGxlYXZlICJhcmciIHVudG91Y2hlZC4KICoKICogV2hlbiB3ZSBhY2NlcHQgYm90aCBhICItLWtleSIgYW5kIGEgIi0ta2V5PTx2YWw+IiBvcHRpb24sIHRoaXMgZnVuY3Rpb24KICogY2FuIGJlIHVzZWQgaW5zdGVhZCBvZiAhc3RyY21wKGFyZywgIi0ta2V5IikgYW5kIHRoZW4KICogc2tpcF9wcmVmaXgoYXJnLCAiLS1rZXk9IiwgJmFyZykgdG8gcGFyc2Ugc3VjaCBhbiBvcHRpb24uCiAqLwppbnQgc2tpcF90b19vcHRpb25hbF9hcmdfZGVmYXVsdChjb25zdCBjaGFyICpzdHIsIGNvbnN0IGNoYXIgKnByZWZpeCwKCQkJCSBjb25zdCBjaGFyICoqYXJnLCBjb25zdCBjaGFyICpkZWYpOwoKc3RhdGljIGlubGluZSBpbnQgc2tpcF90b19vcHRpb25hbF9hcmcoY29uc3QgY2hhciAqc3RyLCBjb25zdCBjaGFyICpwcmVmaXgsCgkJCQkgICAgICAgY29uc3QgY2hhciAqKmFyZykKewoJcmV0dXJuIHNraXBfdG9fb3B0aW9uYWxfYXJnX2RlZmF1bHQoc3RyLCBwcmVmaXgsIGFyZywgIiIpOwp9CgovKgogKiBMaWtlIHNraXBfcHJlZml4LCBidXQgcHJvbWlzZXMgbmV2ZXIgdG8gcmVhZCBwYXN0ICJsZW4iIGJ5dGVzIG9mIHRoZSBpbnB1dAogKiBidWZmZXIsIGFuZCByZXR1cm5zIHRoZSByZW1haW5pbmcgbnVtYmVyIG9mIGJ5dGVzIGluICJvdXQiIHZpYSAib3V0bGVuIi4KICovCnN0YXRpYyBpbmxpbmUgaW50IHNraXBfcHJlZml4X21lbShjb25zdCBjaGFyICpidWYsIHNpemVfdCBsZW4sCgkJCQkgIGNvbnN0IGNoYXIgKnByZWZpeCwKCQkJCSAgY29uc3QgY2hhciAqKm91dCwgc2l6ZV90ICpvdXRsZW4pCnsKCXNpemVfdCBwcmVmaXhfbGVuID0gc3RybGVuKHByZWZpeCk7CglpZiAocHJlZml4X2xlbiA8PSBsZW4gJiYgIW1lbWNtcChidWYsIHByZWZpeCwgcHJlZml4X2xlbikpIHsKCQkqb3V0ID0gYnVmICsgcHJlZml4X2xlbjsKCQkqb3V0bGVuID0gbGVuIC0gcHJlZml4X2xlbjsKCQlyZXR1cm4gMTsKCX0KCXJldHVybiAwOwp9CgovKgogKiBJZiBidWYgZW5kcyB3aXRoIHN1ZmZpeCwgcmV0dXJuIDEgYW5kIHN1YnRyYWN0IHRoZSBsZW5ndGggb2YgdGhlIHN1ZmZpeAogKiBmcm9tICpsZW4uIE90aGVyd2lzZSwgcmV0dXJuIDAgYW5kIGxlYXZlICpsZW4gdW50b3VjaGVkLgogKi8Kc3RhdGljIGlubGluZSBpbnQgc3RyaXBfc3VmZml4X21lbShjb25zdCBjaGFyICpidWYsIHNpemVfdCAqbGVuLAoJCQkJICAgY29uc3QgY2hhciAqc3VmZml4KQp7CglzaXplX3Qgc3VmbGVuID0gc3RybGVuKHN1ZmZpeCk7CglpZiAoKmxlbiA8IHN1ZmxlbiB8fCBtZW1jbXAoYnVmICsgKCpsZW4gLSBzdWZsZW4pLCBzdWZmaXgsIHN1ZmxlbikpCgkJcmV0dXJuIDA7CgkqbGVuIC09IHN1ZmxlbjsKCXJldHVybiAxOwp9CgovKgogKiBJZiBzdHIgZW5kcyB3aXRoIHN1ZmZpeCwgcmV0dXJuIDEgYW5kIHNldCAqbGVuIHRvIHRoZSBzaXplIG9mIHRoZSBzdHJpbmcKICogd2l0aG91dCB0aGUgc3VmZml4LiBPdGhlcndpc2UsIHJldHVybiAwIGFuZCBzZXQgKmxlbiB0byB0aGUgc2l6ZSBvZiB0aGUKICogc3RyaW5nLgogKgogKiBOb3RlIHRoYXQgd2UgZG8gX25vdF8gTlVMLXRlcm1pbmF0ZSBzdHIgdG8gdGhlIG5ldyBsZW5ndGguCiAqLwpzdGF0aWMgaW5saW5lIGludCBzdHJpcF9zdWZmaXgoY29uc3QgY2hhciAqc3RyLCBjb25zdCBjaGFyICpzdWZmaXgsIHNpemVfdCAqbGVuKQp7CgkqbGVuID0gc3RybGVuKHN0cik7CglyZXR1cm4gc3RyaXBfc3VmZml4X21lbShzdHIsIGxlbiwgc3VmZml4KTsKfQoKc3RhdGljIGlubGluZSBpbnQgZW5kc193aXRoKGNvbnN0IGNoYXIgKnN0ciwgY29uc3QgY2hhciAqc3VmZml4KQp7CglzaXplX3QgbGVuOwoJcmV0dXJuIHN0cmlwX3N1ZmZpeChzdHIsIHN1ZmZpeCwgJmxlbik7Cn0KCiNkZWZpbmUgU1dBUChhLCBiKSBkbyB7CQkJCQkJXAoJdm9pZCAqX3N3YXBfYV9wdHIgPSAmKGEpOwkJCQlcCgl2b2lkICpfc3dhcF9iX3B0ciA9ICYoYik7CQkJCVwKCXVuc2lnbmVkIGNoYXIgX3N3YXBfYnVmZmVyW3NpemVvZihhKV07CQkJXAoJbWVtY3B5KF9zd2FwX2J1ZmZlciwgX3N3YXBfYV9wdHIsIHNpemVvZihhKSk7CQlcCgltZW1jcHkoX3N3YXBfYV9wdHIsIF9zd2FwX2JfcHRyLCBzaXplb2YoYSkgKwkJXAoJICAgICAgIEJVSUxEX0FTU0VSVF9PUl9aRVJPKHNpemVvZihhKSA9PSBzaXplb2YoYikpKTsJXAoJbWVtY3B5KF9zd2FwX2JfcHRyLCBfc3dhcF9idWZmZXIsIHNpemVvZihhKSk7CQlcCn0gd2hpbGUgKDApCgojaWYgZGVmaW5lZChOT19NTUFQKSB8fCBkZWZpbmVkKFVTRV9XSU4zMl9NTUFQKQoKI2lmbmRlZiBQUk9UX1JFQUQKI2RlZmluZSBQUk9UX1JFQUQgMQojZGVmaW5lIFBST1RfV1JJVEUgMgojZGVmaW5lIE1BUF9QUklWQVRFIDEKI2VuZGlmCgojZGVmaW5lIG1tYXAgZ2l0X21tYXAKI2RlZmluZSBtdW5tYXAgZ2l0X211bm1hcAp2b2lkICpnaXRfbW1hcCh2b2lkICpzdGFydCwgc2l6ZV90IGxlbmd0aCwgaW50IHByb3QsIGludCBmbGFncywgaW50IGZkLCBvZmZfdCBvZmZzZXQpOwppbnQgZ2l0X211bm1hcCh2b2lkICpzdGFydCwgc2l6ZV90IGxlbmd0aCk7CgojZWxzZSAvKiBOT19NTUFQIHx8IFVTRV9XSU4zMl9NTUFQICovCgojaW5jbHVkZSA8c3lzL21tYW4uaD4KCiNlbmRpZiAvKiBOT19NTUFQIHx8IFVTRV9XSU4zMl9NTUFQICovCgojaWZkZWYgTk9fTU1BUAoKLyogVGhpcyB2YWx1ZSBtdXN0IGJlIG11bHRpcGxlIG9mIChwYWdlc2l6ZSAqIDIpICovCiNkZWZpbmUgREVGQVVMVF9QQUNLRURfR0lUX1dJTkRPV19TSVpFICgxICogMTAyNCAqIDEwMjQpCgojZWxzZSAvKiBOT19NTUFQICovCgovKiBUaGlzIHZhbHVlIG11c3QgYmUgbXVsdGlwbGUgb2YgKHBhZ2VzaXplICogMikgKi8KI2RlZmluZSBERUZBVUxUX1BBQ0tFRF9HSVRfV0lORE9XX1NJWkUgXAoJKHNpemVvZih2b2lkKikgPj0gOCBcCgkJPyAgMSAqIDEwMjQgKiAxMDI0ICogMTAyNCBcCgkJOiAzMiAqIDEwMjQgKiAxMDI0KQoKI2VuZGlmIC8qIE5PX01NQVAgKi8KCiNpZm5kZWYgTUFQX0ZBSUxFRAojZGVmaW5lIE1BUF9GQUlMRUQgKCh2b2lkICopLTEpCiNlbmRpZgoKI2lmZGVmIE5PX1NUX0JMT0NLU19JTl9TVFJVQ1RfU1RBVAojZGVmaW5lIG9uX2Rpc2tfYnl0ZXMoc3QpICgoc3QpLnN0X3NpemUpCiNlbHNlCiNkZWZpbmUgb25fZGlza19ieXRlcyhzdCkgKChzdCkuc3RfYmxvY2tzICogNTEyKQojZW5kaWYKCiNpZmRlZiBORUVEU19NT0RFX1RSQU5TTEFUSU9OCiN1bmRlZiBTX0lGTVQKI3VuZGVmIFNfSUZSRUcKI3VuZGVmIFNfSUZESVIKI3VuZGVmIFNfSUZMTksKI3VuZGVmIFNfSUZCTEsKI3VuZGVmIFNfSUZDSFIKI3VuZGVmIFNfSUZJRk8KI3VuZGVmIFNfSUZTT0NLCiNkZWZpbmUgU19JRk1UICAgMDE3MDAwMAojZGVmaW5lIFNfSUZSRUcgIDAxMDAwMDAKI2RlZmluZSBTX0lGRElSICAwMDQwMDAwCiNkZWZpbmUgU19JRkxOSyAgMDEyMDAwMAojZGVmaW5lIFNfSUZCTEsgIDAwNjAwMDAKI2RlZmluZSBTX0lGQ0hSICAwMDIwMDAwCiNkZWZpbmUgU19JRklGTyAgMDAxMDAwMAojZGVmaW5lIFNfSUZTT0NLIDAxNDAwMDAKI2lmZGVmIHN0YXQKI3VuZGVmIHN0YXQKI2VuZGlmCiNkZWZpbmUgc3RhdChwYXRoLCBidWYpIGdpdF9zdGF0KHBhdGgsIGJ1ZikKaW50IGdpdF9zdGF0KGNvbnN0IGNoYXIgKiwgc3RydWN0IHN0YXQgKik7CiNpZmRlZiBmc3RhdAojdW5kZWYgZnN0YXQKI2VuZGlmCiNkZWZpbmUgZnN0YXQoZmQsIGJ1ZikgZ2l0X2ZzdGF0KGZkLCBidWYpCmludCBnaXRfZnN0YXQoaW50LCBzdHJ1Y3Qgc3RhdCAqKTsKI2lmZGVmIGxzdGF0CiN1bmRlZiBsc3RhdAojZW5kaWYKI2RlZmluZSBsc3RhdChwYXRoLCBidWYpIGdpdF9sc3RhdChwYXRoLCBidWYpCmludCBnaXRfbHN0YXQoY29uc3QgY2hhciAqLCBzdHJ1Y3Qgc3RhdCAqKTsKI2VuZGlmCgojZGVmaW5lIERFRkFVTFRfUEFDS0VEX0dJVF9MSU1JVCBcCgkoKDEwMjRMICogMTAyNEwpICogKHNpemVfdCkoc2l6ZW9mKHZvaWQqKSA+PSA4ID8gKDMyICogMTAyNEwgKiAxMDI0TCkgOiAyNTYpKQoKI2lmZGVmIE5PX1BSRUFECiNkZWZpbmUgcHJlYWQgZ2l0X3ByZWFkCnNzaXplX3QgZ2l0X3ByZWFkKGludCBmZCwgdm9pZCAqYnVmLCBzaXplX3QgY291bnQsIG9mZl90IG9mZnNldCk7CiNlbmRpZgovKgogKiBGb3J3YXJkIGRlY2wgdGhhdCB3aWxsIHJlbWluZCB1cyBpZiBpdHMgdHdpbiBpbiBjYWNoZS5oIGNoYW5nZXMuCiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBpbiBjb21wYXQvcHJlYWQuYy4gIEJ1dCB3ZSBjYW4ndCBpbmNsdWRlCiAqIGNhY2hlLmggdGhlcmUuCiAqLwpzc2l6ZV90IHJlYWRfaW5fZnVsbChpbnQgZmQsIHZvaWQgKmJ1Ziwgc2l6ZV90IGNvdW50KTsKCiNpZmRlZiBOT19TRVRFTlYKI2RlZmluZSBzZXRlbnYgZ2l0c2V0ZW52CmludCBnaXRzZXRlbnYoY29uc3QgY2hhciAqLCBjb25zdCBjaGFyICosIGludCk7CiNlbmRpZgoKI2lmZGVmIE5PX01LRFRFTVAKI2RlZmluZSBta2R0ZW1wIGdpdG1rZHRlbXAKY2hhciAqZ2l0bWtkdGVtcChjaGFyICopOwojZW5kaWYKCiNpZmRlZiBOT19VTlNFVEVOVgojZGVmaW5lIHVuc2V0ZW52IGdpdHVuc2V0ZW52CmludCBnaXR1bnNldGVudihjb25zdCBjaGFyICopOwojZW5kaWYKCiNpZmRlZiBOT19TVFJDQVNFU1RSCiNkZWZpbmUgc3RyY2FzZXN0ciBnaXRzdHJjYXNlc3RyCmNoYXIgKmdpdHN0cmNhc2VzdHIoY29uc3QgY2hhciAqaGF5c3RhY2ssIGNvbnN0IGNoYXIgKm5lZWRsZSk7CiNlbmRpZgoKI2lmZGVmIE5PX1NUUkxDUFkKI2RlZmluZSBzdHJsY3B5IGdpdHN0cmxjcHkKc2l6ZV90IGdpdHN0cmxjcHkoY2hhciAqLCBjb25zdCBjaGFyICosIHNpemVfdCk7CiNlbmRpZgoKI2lmZGVmIE5PX1NUUlRPVU1BWAojZGVmaW5lIHN0cnRvdW1heCBnaXRzdHJ0b3VtYXgKdWludG1heF90IGdpdHN0cnRvdW1heChjb25zdCBjaGFyICosIGNoYXIgKiosIGludCk7CiNkZWZpbmUgc3RydG9pbWF4IGdpdHN0cnRvaW1heAppbnRtYXhfdCBnaXRzdHJ0b2ltYXgoY29uc3QgY2hhciAqLCBjaGFyICoqLCBpbnQpOwojZW5kaWYKCiNpZmRlZiBOT19IU1RSRVJST1IKI2RlZmluZSBoc3RyZXJyb3IgZ2l0aHN0cmVycm9yCmNvbnN0IGNoYXIgKmdpdGhzdHJlcnJvcihpbnQgaGVycm9yKTsKI2VuZGlmCgojaWZkZWYgTk9fTUVNTUVNCiNkZWZpbmUgbWVtbWVtIGdpdG1lbW1lbQp2b2lkICpnaXRtZW1tZW0oY29uc3Qgdm9pZCAqaGF5c3RhY2ssIHNpemVfdCBoYXlzdGFja2xlbiwKCQljb25zdCB2b2lkICpuZWVkbGUsIHNpemVfdCBuZWVkbGVsZW4pOwojZW5kaWYKCiNpZmRlZiBPVkVSUklERV9TVFJEVVAKI2lmZGVmIHN0cmR1cAojdW5kZWYgc3RyZHVwCiNlbmRpZgojZGVmaW5lIHN0cmR1cCBnaXRzdHJkdXAKY2hhciAqZ2l0c3RyZHVwKGNvbnN0IGNoYXIgKnMpOwojZW5kaWYKCiNpZmRlZiBOT19HRVRQQUdFU0laRQojZGVmaW5lIGdldHBhZ2VzaXplKCkgc3lzY29uZihfU0NfUEFHRVNJWkUpCiNlbmRpZgoKI2lmbmRlZiBPX0NMT0VYRUMKI2RlZmluZSBPX0NMT0VYRUMgMAojZW5kaWYKCiNpZmRlZiBGUkVBRF9SRUFEU19ESVJFQ1RPUklFUwojIGlmICFkZWZpbmVkKFNVUFBSRVNTX0ZPUEVOX1JFREVGSU5JVElPTikKIyAgaWZkZWYgZm9wZW4KIyAgIHVuZGVmIGZvcGVuCiMgIGVuZGlmCiMgIGRlZmluZSBmb3BlbihhLGIpIGdpdF9mb3BlbihhLGIpCiMgZW5kaWYKRklMRSAqZ2l0X2ZvcGVuKGNvbnN0IGNoYXIqLCBjb25zdCBjaGFyKik7CiNlbmRpZgoKI2lmZGVmIFNOUFJJTlRGX1JFVFVSTlNfQk9HVVMKI2lmZGVmIHNucHJpbnRmCiN1bmRlZiBzbnByaW50ZgojZW5kaWYKI2RlZmluZSBzbnByaW50ZiBnaXRfc25wcmludGYKaW50IGdpdF9zbnByaW50ZihjaGFyICpzdHIsIHNpemVfdCBtYXhzaXplLAoJCSBjb25zdCBjaGFyICpmb3JtYXQsIC4uLik7CiNpZmRlZiB2c25wcmludGYKI3VuZGVmIHZzbnByaW50ZgojZW5kaWYKI2RlZmluZSB2c25wcmludGYgZ2l0X3ZzbnByaW50ZgppbnQgZ2l0X3ZzbnByaW50ZihjaGFyICpzdHIsIHNpemVfdCBtYXhzaXplLAoJCSAgY29uc3QgY2hhciAqZm9ybWF0LCB2YV9saXN0IGFwKTsKI2VuZGlmCgojaWZkZWYgT1BFTl9SRVRVUk5TX0VJTlRSCiN1bmRlZiBvcGVuCiNkZWZpbmUgb3BlbiBnaXRfb3Blbl93aXRoX3JldHJ5CmludCBnaXRfb3Blbl93aXRoX3JldHJ5KGNvbnN0IGNoYXIgKnBhdGgsIGludCBmbGFnLCAuLi4pOwojZW5kaWYKCiNpZmRlZiBfX0dMSUJDX1BSRVJFUQojaWYgX19HTElCQ19QUkVSRVEoMiwgMSkKI2RlZmluZSBIQVZFX1NUUkNIUk5VTAojZW5kaWYKI2VuZGlmCgojaWZuZGVmIEhBVkVfU1RSQ0hSTlVMCiNkZWZpbmUgc3RyY2hybnVsIGdpdHN0cmNocm51bApzdGF0aWMgaW5saW5lIGNoYXIgKmdpdHN0cmNocm51bChjb25zdCBjaGFyICpzLCBpbnQgYykKewoJd2hpbGUgKCpzICYmICpzICE9IGMpCgkJcysrOwoJcmV0dXJuIChjaGFyICopczsKfQojZW5kaWYKCiNpZmRlZiBOT19JTkVUX1BUT04KaW50IGluZXRfcHRvbihpbnQgYWYsIGNvbnN0IGNoYXIgKnNyYywgdm9pZCAqZHN0KTsKI2VuZGlmCgojaWZkZWYgTk9fSU5FVF9OVE9QCmNvbnN0IGNoYXIgKmluZXRfbnRvcChpbnQgYWYsIGNvbnN0IHZvaWQgKnNyYywgY2hhciAqZHN0LCBzaXplX3Qgc2l6ZSk7CiNlbmRpZgoKI2lmZGVmIE5PX1BUSFJFQURTCiNkZWZpbmUgYXRleGl0IGdpdF9hdGV4aXQKaW50IGdpdF9hdGV4aXQodm9pZCAoKmhhbmRsZXIpKHZvaWQpKTsKI2VuZGlmCgpzdGF0aWMgaW5saW5lIHNpemVfdCBzdF9hZGQoc2l6ZV90IGEsIHNpemVfdCBiKQp7CglpZiAodW5zaWduZWRfYWRkX292ZXJmbG93cyhhLCBiKSkKCQlkaWUoInNpemVfdCBvdmVyZmxvdzogJSJQUkl1TUFYIiArICUiUFJJdU1BWCwKCQkgICAgKHVpbnRtYXhfdClhLCAodWludG1heF90KWIpOwoJcmV0dXJuIGEgKyBiOwp9CiNkZWZpbmUgc3RfYWRkMyhhLGIsYykgICBzdF9hZGQoc3RfYWRkKChhKSwoYikpLChjKSkKI2RlZmluZSBzdF9hZGQ0KGEsYixjLGQpIHN0X2FkZChzdF9hZGQzKChhKSwoYiksKGMpKSwoZCkpCgpzdGF0aWMgaW5saW5lIHNpemVfdCBzdF9tdWx0KHNpemVfdCBhLCBzaXplX3QgYikKewoJaWYgKHVuc2lnbmVkX211bHRfb3ZlcmZsb3dzKGEsIGIpKQoJCWRpZSgic2l6ZV90IG92ZXJmbG93OiAlIlBSSXVNQVgiICogJSJQUkl1TUFYLAoJCSAgICAodWludG1heF90KWEsICh1aW50bWF4X3QpYik7CglyZXR1cm4gYSAqIGI7Cn0KCnN0YXRpYyBpbmxpbmUgc2l6ZV90IHN0X3N1YihzaXplX3QgYSwgc2l6ZV90IGIpCnsKCWlmIChhIDwgYikKCQlkaWUoInNpemVfdCB1bmRlcmZsb3c6ICUiUFJJdU1BWCIgLSAlIlBSSXVNQVgsCgkJICAgICh1aW50bWF4X3QpYSwgKHVpbnRtYXhfdCliKTsKCXJldHVybiBhIC0gYjsKfQoKc3RhdGljIGlubGluZSBzaXplX3Qgc3RfbGVmdF9zaGlmdChzaXplX3QgYSwgdW5zaWduZWQgc2hpZnQpCnsKCWlmICh1bnNpZ25lZF9sZWZ0X3NoaWZ0X292ZXJmbG93cyhhLCBzaGlmdCkpCgkJZGllKCJzaXplX3Qgb3ZlcmZsb3c6ICUiUFJJdU1BWCIgPDwgJXUiLAoJCSAgICAodWludG1heF90KWEsIHNoaWZ0KTsKCXJldHVybiBhIDw8IHNoaWZ0Owp9CgpzdGF0aWMgaW5saW5lIHVuc2lnbmVkIGxvbmcgY2FzdF9zaXplX3RfdG9fdWxvbmcoc2l6ZV90IGEpCnsKCWlmIChhICE9ICh1bnNpZ25lZCBsb25nKWEpCgkJZGllKCJvYmplY3QgdG9vIGxhcmdlIHRvIHJlYWQgb24gdGhpcyBwbGF0Zm9ybTogJSIKCQkgICAgUFJJdU1BWCIgaXMgY3V0IG9mZiB0byAlbHUiLAoJCSAgICAodWludG1heF90KWEsICh1bnNpZ25lZCBsb25nKWEpOwoJcmV0dXJuICh1bnNpZ25lZCBsb25nKWE7Cn0KCiNpZmRlZiBIQVZFX0FMTE9DQV9ICiMgaW5jbHVkZSA8YWxsb2NhLmg+CiMgZGVmaW5lIHhhbGxvY2Eoc2l6ZSkgICAgICAoYWxsb2NhKHNpemUpKQojIGRlZmluZSB4YWxsb2NhX2ZyZWUocCkgICAgZG8ge30gd2hpbGUgKDApCiNlbHNlCiMgZGVmaW5lIHhhbGxvY2Eoc2l6ZSkgICAgICAoeG1hbGxvYyhzaXplKSkKIyBkZWZpbmUgeGFsbG9jYV9mcmVlKHApICAgIChmcmVlKHApKQojZW5kaWYKY2hhciAqeHN0cmR1cChjb25zdCBjaGFyICpzdHIpOwp2b2lkICp4bWFsbG9jKHNpemVfdCBzaXplKTsKdm9pZCAqeG1hbGxvY3ooc2l6ZV90IHNpemUpOwp2b2lkICp4bWFsbG9jel9nZW50bHkoc2l6ZV90IHNpemUpOwp2b2lkICp4bWVtZHVweihjb25zdCB2b2lkICpkYXRhLCBzaXplX3QgbGVuKTsKY2hhciAqeHN0cm5kdXAoY29uc3QgY2hhciAqc3RyLCBzaXplX3QgbGVuKTsKdm9pZCAqeHJlYWxsb2Modm9pZCAqcHRyLCBzaXplX3Qgc2l6ZSk7CnZvaWQgKnhjYWxsb2Moc2l6ZV90IG5tZW1iLCBzaXplX3Qgc2l6ZSk7CnZvaWQgeHNldGVudihjb25zdCBjaGFyICpuYW1lLCBjb25zdCBjaGFyICp2YWx1ZSwgaW50IG92ZXJ3cml0ZSk7CnZvaWQgKnhtbWFwKHZvaWQgKnN0YXJ0LCBzaXplX3QgbGVuZ3RoLCBpbnQgcHJvdCwgaW50IGZsYWdzLCBpbnQgZmQsIG9mZl90IG9mZnNldCk7CmNvbnN0IGNoYXIgKm1tYXBfb3NfZXJyKHZvaWQpOwp2b2lkICp4bW1hcF9nZW50bHkodm9pZCAqc3RhcnQsIHNpemVfdCBsZW5ndGgsIGludCBwcm90LCBpbnQgZmxhZ3MsIGludCBmZCwgb2ZmX3Qgb2Zmc2V0KTsKaW50IHhvcGVuKGNvbnN0IGNoYXIgKnBhdGgsIGludCBmbGFncywgLi4uKTsKc3NpemVfdCB4cmVhZChpbnQgZmQsIHZvaWQgKmJ1Ziwgc2l6ZV90IGxlbik7CnNzaXplX3QgeHdyaXRlKGludCBmZCwgY29uc3Qgdm9pZCAqYnVmLCBzaXplX3QgbGVuKTsKc3NpemVfdCB4cHJlYWQoaW50IGZkLCB2b2lkICpidWYsIHNpemVfdCBsZW4sIG9mZl90IG9mZnNldCk7CmludCB4ZHVwKGludCBmZCk7CkZJTEUgKnhmb3Blbihjb25zdCBjaGFyICpwYXRoLCBjb25zdCBjaGFyICptb2RlKTsKRklMRSAqeGZkb3BlbihpbnQgZmQsIGNvbnN0IGNoYXIgKm1vZGUpOwppbnQgeG1rc3RlbXAoY2hhciAqdGVtcF9maWxlbmFtZSk7CmludCB4bWtzdGVtcF9tb2RlKGNoYXIgKnRlbXBfZmlsZW5hbWUsIGludCBtb2RlKTsKY2hhciAqeGdldGN3ZCh2b2lkKTsKRklMRSAqZm9wZW5fZm9yX3dyaXRpbmcoY29uc3QgY2hhciAqcGF0aCk7CkZJTEUgKmZvcGVuX29yX3dhcm4oY29uc3QgY2hhciAqcGF0aCwgY29uc3QgY2hhciAqbW9kZSk7CgovKgogKiBMaWtlIHN0cm5jbXAsIGJ1dCBvbmx5IHJldHVybiB6ZXJvIGlmIHMgaXMgTlVMLXRlcm1pbmF0ZWQgYW5kIGV4YWN0bHkgbGVuCiAqIGNoYXJhY3RlcnMgbG9uZy4gIElmIGl0IGlzIG5vdCwgY29uc2lkZXIgaXQgZ3JlYXRlciB0aGFuIHQuCiAqLwppbnQgeHN0cm5jbXB6KGNvbnN0IGNoYXIgKnMsIGNvbnN0IGNoYXIgKnQsIHNpemVfdCBsZW4pOwoKLyoKICogRlJFRV9BTkRfTlVMTChwdHIpIGlzIGxpa2UgZnJlZShwdHIpIGZvbGxvd2VkIGJ5IHB0ciA9IE5VTEwuIE5vdGUKICogdGhhdCBwdHIgaXMgdXNlZCB0d2ljZSwgc28gZG9uJ3QgcGFzcyBlLmcuIHB0cisrLgogKi8KI2RlZmluZSBGUkVFX0FORF9OVUxMKHApIGRvIHsgZnJlZShwKTsgKHApID0gTlVMTDsgfSB3aGlsZSAoMCkKCiNkZWZpbmUgQUxMT0NfQVJSQVkoeCwgYWxsb2MpICh4KSA9IHhtYWxsb2Moc3RfbXVsdChzaXplb2YoKih4KSksIChhbGxvYykpKQojZGVmaW5lIENBTExPQ19BUlJBWSh4LCBhbGxvYykgKHgpID0geGNhbGxvYygoYWxsb2MpLCBzaXplb2YoKih4KSkpCiNkZWZpbmUgUkVBTExPQ19BUlJBWSh4LCBhbGxvYykgKHgpID0geHJlYWxsb2MoKHgpLCBzdF9tdWx0KHNpemVvZigqKHgpKSwgKGFsbG9jKSkpCgojZGVmaW5lIENPUFlfQVJSQVkoZHN0LCBzcmMsIG4pIGNvcHlfYXJyYXkoKGRzdCksIChzcmMpLCAobiksIHNpemVvZigqKGRzdCkpICsgXAoJQlVJTERfQVNTRVJUX09SX1pFUk8oc2l6ZW9mKCooZHN0KSkgPT0gc2l6ZW9mKCooc3JjKSkpKQpzdGF0aWMgaW5saW5lIHZvaWQgY29weV9hcnJheSh2b2lkICpkc3QsIGNvbnN0IHZvaWQgKnNyYywgc2l6ZV90IG4sIHNpemVfdCBzaXplKQp7CglpZiAobikKCQltZW1jcHkoZHN0LCBzcmMsIHN0X211bHQoc2l6ZSwgbikpOwp9CgojZGVmaW5lIE1PVkVfQVJSQVkoZHN0LCBzcmMsIG4pIG1vdmVfYXJyYXkoKGRzdCksIChzcmMpLCAobiksIHNpemVvZigqKGRzdCkpICsgXAoJQlVJTERfQVNTRVJUX09SX1pFUk8oc2l6ZW9mKCooZHN0KSkgPT0gc2l6ZW9mKCooc3JjKSkpKQpzdGF0aWMgaW5saW5lIHZvaWQgbW92ZV9hcnJheSh2b2lkICpkc3QsIGNvbnN0IHZvaWQgKnNyYywgc2l6ZV90IG4sIHNpemVfdCBzaXplKQp7CglpZiAobikKCQltZW1tb3ZlKGRzdCwgc3JjLCBzdF9tdWx0KHNpemUsIG4pKTsKfQoKLyoKICogVGhlc2UgZnVuY3Rpb25zIGhlbHAgeW91IGFsbG9jYXRlIHN0cnVjdHMgd2l0aCBmbGV4IGFycmF5cywgYW5kIGNvcHkKICogdGhlIGRhdGEgZGlyZWN0bHkgaW50byB0aGUgYXJyYXkuIEZvciBleGFtcGxlLCBpZiB5b3UgaGFkOgogKgogKiAgIHN0cnVjdCBmb28gewogKiAgICAgaW50IGJhcjsKICogICAgIGNoYXIgbmFtZVtGTEVYX0FSUkFZXTsKICogICB9OwogKgogKiB5b3UgY2FuIGRvOgogKgogKiAgIHN0cnVjdCBmb28gKmY7CiAqICAgRkxFWF9BTExPQ19NRU0oZiwgbmFtZSwgc3JjLCBsZW4pOwogKgogKiB0byBhbGxvY2F0ZSBhICJmb28iIHdpdGggdGhlIGNvbnRlbnRzIG9mICJzcmMiIGluIHRoZSAibmFtZSIgZmllbGQuCiAqIFRoZSByZXN1bHRpbmcgc3RydWN0IGlzIGF1dG9tYXRpY2FsbHkgemVybydkLCBhbmQgdGhlIGZsZXgtYXJyYXkgZmllbGQKICogaXMgTlVMLXRlcm1pbmF0ZWQgKHdoZXRoZXIgdGhlIGluY29taW5nIHNyYyBidWZmZXIgd2FzIG9yIG5vdCkuCiAqCiAqIFRoZSBGTEVYUFRSXyogdmFyaWFudHMgb3BlcmF0ZSBvbiBzdHJ1Y3RzIHRoYXQgZG9uJ3QgdXNlIGZsZXgtYXJyYXlzLAogKiBidXQgZG8gd2FudCB0byBzdG9yZSBhIHBvaW50ZXIgdG8gc29tZSBleHRyYSBkYXRhIGluIHRoZSBzYW1lIGFsbG9jYXRlZAogKiBibG9jay4gRm9yIGV4YW1wbGUsIGlmIHlvdSBoYXZlOgogKgogKiAgIHN0cnVjdCBmb28gewogKiAgICAgY2hhciAqbmFtZTsKICogICAgIGludCBiYXI7CiAqICAgfTsKICoKICogeW91IGNhbiBkbzoKICoKICogICBzdHJ1Y3QgZm9vICpmOwogKiAgIEZMRVhQVFJfQUxMT0NfU1RSKGYsIG5hbWUsIHNyYyk7CiAqCiAqIGFuZCAibmFtZSIgd2lsbCBwb2ludCB0byBhIGJsb2NrIG9mIG1lbW9yeSBhZnRlciB0aGUgc3RydWN0LCB3aGljaCB3aWxsIGJlCiAqIGZyZWVkIGFsb25nIHdpdGggdGhlIHN0cnVjdCAoYnV0IHRoZSBwb2ludGVyIGNhbiBiZSByZXBvaW50ZWQgYW55d2hlcmUpLgogKgogKiBUaGUgKl9TVFIgdmFyaWFudHMgYWNjZXB0IGEgc3RyaW5nIHBhcmFtZXRlciByYXRoZXIgdGhhbiBhIHB0ci9sZW4KICogY29tYmluYXRpb24uCiAqCiAqIE5vdGUgdGhhdCB0aGVzZSBtYWNyb3Mgd2lsbCBldmFsdWF0ZSB0aGUgZmlyc3QgcGFyYW1ldGVyIG11bHRpcGxlCiAqIHRpbWVzLCBhbmQgaXQgbXVzdCBiZSBhc3NpZ25hYmxlIGFzIGFuIGx2YWx1ZS4KICovCiNkZWZpbmUgRkxFWF9BTExPQ19NRU0oeCwgZmxleG5hbWUsIGJ1ZiwgbGVuKSBkbyB7IFwKCXNpemVfdCBmbGV4X2FycmF5X2xlbl8gPSAobGVuKTsgXAoJKHgpID0geGNhbGxvYygxLCBzdF9hZGQzKHNpemVvZigqKHgpKSwgZmxleF9hcnJheV9sZW5fLCAxKSk7IFwKCW1lbWNweSgodm9pZCAqKSh4KS0+ZmxleG5hbWUsIChidWYpLCBmbGV4X2FycmF5X2xlbl8pOyBcCn0gd2hpbGUgKDApCiNkZWZpbmUgRkxFWFBUUl9BTExPQ19NRU0oeCwgcHRybmFtZSwgYnVmLCBsZW4pIGRvIHsgXAoJc2l6ZV90IGZsZXhfYXJyYXlfbGVuXyA9IChsZW4pOyBcCgkoeCkgPSB4Y2FsbG9jKDEsIHN0X2FkZDMoc2l6ZW9mKCooeCkpLCBmbGV4X2FycmF5X2xlbl8sIDEpKTsgXAoJbWVtY3B5KCh4KSArIDEsIChidWYpLCBmbGV4X2FycmF5X2xlbl8pOyBcCgkoeCktPnB0cm5hbWUgPSAodm9pZCAqKSgoeCkrMSk7IFwKfSB3aGlsZSgwKQojZGVmaW5lIEZMRVhfQUxMT0NfU1RSKHgsIGZsZXhuYW1lLCBzdHIpIFwKCUZMRVhfQUxMT0NfTUVNKCh4KSwgZmxleG5hbWUsIChzdHIpLCBzdHJsZW4oc3RyKSkKI2RlZmluZSBGTEVYUFRSX0FMTE9DX1NUUih4LCBwdHJuYW1lLCBzdHIpIFwKCUZMRVhQVFJfQUxMT0NfTUVNKCh4KSwgcHRybmFtZSwgKHN0ciksIHN0cmxlbihzdHIpKQoKc3RhdGljIGlubGluZSBjaGFyICp4c3RyZHVwX29yX251bGwoY29uc3QgY2hhciAqc3RyKQp7CglyZXR1cm4gc3RyID8geHN0cmR1cChzdHIpIDogTlVMTDsKfQoKc3RhdGljIGlubGluZSBzaXplX3QgeHNpemVfdChvZmZfdCBsZW4pCnsKCWlmIChsZW4gPCAwIHx8ICh1aW50bWF4X3QpIGxlbiA+IFNJWkVfTUFYKQoJCWRpZSgiQ2Fubm90IGhhbmRsZSBmaWxlcyB0aGlzIGJpZyIpOwoJcmV0dXJuIChzaXplX3QpIGxlbjsKfQoKX19hdHRyaWJ1dGVfXygoZm9ybWF0IChwcmludGYsIDMsIDQpKSkKaW50IHhzbnByaW50ZihjaGFyICpkc3QsIHNpemVfdCBtYXgsIGNvbnN0IGNoYXIgKmZtdCwgLi4uKTsKCiNpZm5kZWYgSE9TVF9OQU1FX01BWAojZGVmaW5lIEhPU1RfTkFNRV9NQVggMjU2CiNlbmRpZgoKaW50IHhnZXRob3N0bmFtZShjaGFyICpidWYsIHNpemVfdCBsZW4pOwoKLyogaW4gY3R5cGUuYywgZm9yIGt3c2V0IHVzZXJzICovCmV4dGVybiBjb25zdCB1bnNpZ25lZCBjaGFyIHRvbG93ZXJfdHJhbnNfdGJsWzI1Nl07CgovKiBTYW5lIGN0eXBlIC0gbm8gbG9jYWxlLCBhbmQgd29ya3Mgd2l0aCBzaWduZWQgY2hhcnMgKi8KI3VuZGVmIGlzYXNjaWkKI3VuZGVmIGlzc3BhY2UKI3VuZGVmIGlzZGlnaXQKI3VuZGVmIGlzYWxwaGEKI3VuZGVmIGlzYWxudW0KI3VuZGVmIGlzcHJpbnQKI3VuZGVmIGlzbG93ZXIKI3VuZGVmIGlzdXBwZXIKI3VuZGVmIHRvbG93ZXIKI3VuZGVmIHRvdXBwZXIKI3VuZGVmIGlzY250cmwKI3VuZGVmIGlzcHVuY3QKI3VuZGVmIGlzeGRpZ2l0CgpleHRlcm4gY29uc3QgdW5zaWduZWQgY2hhciBzYW5lX2N0eXBlWzI1Nl07CiNkZWZpbmUgR0lUX1NQQUNFIDB4MDEKI2RlZmluZSBHSVRfRElHSVQgMHgwMgojZGVmaW5lIEdJVF9BTFBIQSAweDA0CiNkZWZpbmUgR0lUX0dMT0JfU1BFQ0lBTCAweDA4CiNkZWZpbmUgR0lUX1JFR0VYX1NQRUNJQUwgMHgxMAojZGVmaW5lIEdJVF9QQVRIU1BFQ19NQUdJQyAweDIwCiNkZWZpbmUgR0lUX0NOVFJMIDB4NDAKI2RlZmluZSBHSVRfUFVOQ1QgMHg4MAojZGVmaW5lIHNhbmVfaXN0ZXN0KHgsbWFzaykgKChzYW5lX2N0eXBlWyh1bnNpZ25lZCBjaGFyKSh4KV0gJiAobWFzaykpICE9IDApCiNkZWZpbmUgaXNhc2NpaSh4KSAoKCh4KSAmIH4weDdmKSA9PSAwKQojZGVmaW5lIGlzc3BhY2UoeCkgc2FuZV9pc3Rlc3QoeCxHSVRfU1BBQ0UpCiNkZWZpbmUgaXNkaWdpdCh4KSBzYW5lX2lzdGVzdCh4LEdJVF9ESUdJVCkKI2RlZmluZSBpc2FscGhhKHgpIHNhbmVfaXN0ZXN0KHgsR0lUX0FMUEhBKQojZGVmaW5lIGlzYWxudW0oeCkgc2FuZV9pc3Rlc3QoeCxHSVRfQUxQSEEgfCBHSVRfRElHSVQpCiNkZWZpbmUgaXNwcmludCh4KSAoKHgpID49IDB4MjAgJiYgKHgpIDw9IDB4N2UpCiNkZWZpbmUgaXNsb3dlcih4KSBzYW5lX2lzY2FzZSh4LCAxKQojZGVmaW5lIGlzdXBwZXIoeCkgc2FuZV9pc2Nhc2UoeCwgMCkKI2RlZmluZSBpc19nbG9iX3NwZWNpYWwoeCkgc2FuZV9pc3Rlc3QoeCxHSVRfR0xPQl9TUEVDSUFMKQojZGVmaW5lIGlzX3JlZ2V4X3NwZWNpYWwoeCkgc2FuZV9pc3Rlc3QoeCxHSVRfR0xPQl9TUEVDSUFMIHwgR0lUX1JFR0VYX1NQRUNJQUwpCiNkZWZpbmUgaXNjbnRybCh4KSAoc2FuZV9pc3Rlc3QoeCxHSVRfQ05UUkwpKQojZGVmaW5lIGlzcHVuY3QoeCkgc2FuZV9pc3Rlc3QoeCwgR0lUX1BVTkNUIHwgR0lUX1JFR0VYX1NQRUNJQUwgfCBcCgkJR0lUX0dMT0JfU1BFQ0lBTCB8IEdJVF9QQVRIU1BFQ19NQUdJQykKI2RlZmluZSBpc3hkaWdpdCh4KSAoaGV4dmFsX3RhYmxlWyh1bnNpZ25lZCBjaGFyKSh4KV0gIT0gLTEpCiNkZWZpbmUgdG9sb3dlcih4KSBzYW5lX2Nhc2UoKHVuc2lnbmVkIGNoYXIpKHgpLCAweDIwKQojZGVmaW5lIHRvdXBwZXIoeCkgc2FuZV9jYXNlKCh1bnNpZ25lZCBjaGFyKSh4KSwgMCkKI2RlZmluZSBpc19wYXRoc3BlY19tYWdpYyh4KSBzYW5lX2lzdGVzdCh4LEdJVF9QQVRIU1BFQ19NQUdJQykKCnN0YXRpYyBpbmxpbmUgaW50IHNhbmVfY2FzZShpbnQgeCwgaW50IGhpZ2gpCnsKCWlmIChzYW5lX2lzdGVzdCh4LCBHSVRfQUxQSEEpKQoJCXggPSAoeCAmIH4weDIwKSB8IGhpZ2g7CglyZXR1cm4geDsKfQoKc3RhdGljIGlubGluZSBpbnQgc2FuZV9pc2Nhc2UoaW50IHgsIGludCBpc19sb3dlcikKewoJaWYgKCFzYW5lX2lzdGVzdCh4LCBHSVRfQUxQSEEpKQoJCXJldHVybiAwOwoKCWlmIChpc19sb3dlcikKCQlyZXR1cm4gKHggJiAweDIwKSAhPSAwOwoJZWxzZQoJCXJldHVybiAoeCAmIDB4MjApID09IDA7Cn0KCi8qCiAqIExpa2Ugc2tpcF9wcmVmaXgsIGJ1dCBjb21wYXJlIGNhc2UtaW5zZW5zaXRpdmVseS4gTm90ZSB0aGF0IHRoZSBjb21wYXJpc29uCiAqIGlzIGRvbmUgdmlhIHRvbG93ZXIoKSwgc28gaXQgaXMgc3RyaWN0bHkgQVNDSUkgKG5vIG11bHRpLWJ5dGUgY2hhcmFjdGVycyBvcgogKiBsb2NhbGUtc3BlY2lmaWMgY29udmVyc2lvbnMpLgogKi8Kc3RhdGljIGlubGluZSBpbnQgc2tpcF9pcHJlZml4KGNvbnN0IGNoYXIgKnN0ciwgY29uc3QgY2hhciAqcHJlZml4LAoJCQkgICAgICAgY29uc3QgY2hhciAqKm91dCkKewoJZG8gewoJCWlmICghKnByZWZpeCkgewoJCQkqb3V0ID0gc3RyOwoJCQlyZXR1cm4gMTsKCQl9Cgl9IHdoaWxlICh0b2xvd2VyKCpzdHIrKykgPT0gdG9sb3dlcigqcHJlZml4KyspKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW5saW5lIGludCBzdHJ0b3VsX3VpKGNoYXIgY29uc3QgKnMsIGludCBiYXNlLCB1bnNpZ25lZCBpbnQgKnJlc3VsdCkKewoJdW5zaWduZWQgbG9uZyB1bDsKCWNoYXIgKnA7CgoJZXJybm8gPSAwOwoJLyogbmVnYXRpdmUgdmFsdWVzIHdvdWxkIGJlIGFjY2VwdGVkIGJ5IHN0cnRvdWwgKi8KCWlmIChzdHJjaHIocywgJy0nKSkKCQlyZXR1cm4gLTE7Cgl1bCA9IHN0cnRvdWwocywgJnAsIGJhc2UpOwoJaWYgKGVycm5vIHx8ICpwIHx8IHAgPT0gcyB8fCAodW5zaWduZWQgaW50KSB1bCAhPSB1bCkKCQlyZXR1cm4gLTE7CgkqcmVzdWx0ID0gdWw7CglyZXR1cm4gMDsKfQoKc3RhdGljIGlubGluZSBpbnQgc3RydG9sX2koY2hhciBjb25zdCAqcywgaW50IGJhc2UsIGludCAqcmVzdWx0KQp7Cglsb25nIHVsOwoJY2hhciAqcDsKCgllcnJubyA9IDA7Cgl1bCA9IHN0cnRvbChzLCAmcCwgYmFzZSk7CglpZiAoZXJybm8gfHwgKnAgfHwgcCA9PSBzIHx8IChpbnQpIHVsICE9IHVsKQoJCXJldHVybiAtMTsKCSpyZXN1bHQgPSB1bDsKCXJldHVybiAwOwp9Cgp2b2lkIGdpdF9zdGFibGVfcXNvcnQodm9pZCAqYmFzZSwgc2l6ZV90IG5tZW1iLCBzaXplX3Qgc2l6ZSwKCQkgICAgICBpbnQoKmNvbXBhcikoY29uc3Qgdm9pZCAqLCBjb25zdCB2b2lkICopKTsKI2lmZGVmIElOVEVSTkFMX1FTT1JUCiNkZWZpbmUgcXNvcnQgZ2l0X3N0YWJsZV9xc29ydAojZW5kaWYKCiNkZWZpbmUgUVNPUlQoYmFzZSwgbiwgY29tcGFyKSBzYW5lX3Fzb3J0KChiYXNlKSwgKG4pLCBzaXplb2YoKihiYXNlKSksIGNvbXBhcikKc3RhdGljIGlubGluZSB2b2lkIHNhbmVfcXNvcnQodm9pZCAqYmFzZSwgc2l6ZV90IG5tZW1iLCBzaXplX3Qgc2l6ZSwKCQkJICAgICAgaW50KCpjb21wYXIpKGNvbnN0IHZvaWQgKiwgY29uc3Qgdm9pZCAqKSkKewoJaWYgKG5tZW1iID4gMSkKCQlxc29ydChiYXNlLCBubWVtYiwgc2l6ZSwgY29tcGFyKTsKfQoKI2RlZmluZSBTVEFCTEVfUVNPUlQoYmFzZSwgbiwgY29tcGFyKSBcCglnaXRfc3RhYmxlX3Fzb3J0KChiYXNlKSwgKG4pLCBzaXplb2YoKihiYXNlKSksIGNvbXBhcikKCiNpZm5kZWYgSEFWRV9JU09fUVNPUlRfUwppbnQgZ2l0X3Fzb3J0X3Modm9pZCAqYmFzZSwgc2l6ZV90IG5tZW1iLCBzaXplX3Qgc2l6ZSwKCQlpbnQgKCpjb21wYXIpKGNvbnN0IHZvaWQgKiwgY29uc3Qgdm9pZCAqLCB2b2lkICopLCB2b2lkICpjdHgpOwojZGVmaW5lIHFzb3J0X3MgZ2l0X3Fzb3J0X3MKI2VuZGlmCgojZGVmaW5lIFFTT1JUX1MoYmFzZSwgbiwgY29tcGFyLCBjdHgpIGRvIHsJCQlcCglpZiAocXNvcnRfcygoYmFzZSksIChuKSwgc2l6ZW9mKCooYmFzZSkpLCBjb21wYXIsIGN0eCkpCVwKCQlCVUcoInFzb3J0X3MoKSBmYWlsZWQiKTsJCQlcCn0gd2hpbGUgKDApCgojaWZuZGVmIFJFR19TVEFSVEVORAojZXJyb3IgIkdpdCByZXF1aXJlcyBSRUdfU1RBUlRFTkQgc3VwcG9ydC4gQ29tcGlsZSB3aXRoIE5PX1JFR0VYPU5lZWRzU3RhcnRFbmQiCiNlbmRpZgoKc3RhdGljIGlubGluZSBpbnQgcmVnZXhlY19idWYoY29uc3QgcmVnZXhfdCAqcHJlZywgY29uc3QgY2hhciAqYnVmLCBzaXplX3Qgc2l6ZSwKCQkJICAgICAgc2l6ZV90IG5tYXRjaCwgcmVnbWF0Y2hfdCBwbWF0Y2hbXSwgaW50IGVmbGFncykKewoJYXNzZXJ0KG5tYXRjaCA+IDAgJiYgcG1hdGNoKTsKCXBtYXRjaFswXS5ybV9zbyA9IDA7CglwbWF0Y2hbMF0ucm1fZW8gPSBzaXplOwoJcmV0dXJuIHJlZ2V4ZWMocHJlZywgYnVmLCBubWF0Y2gsIHBtYXRjaCwgZWZsYWdzIHwgUkVHX1NUQVJURU5EKTsKfQoKI2lmbmRlZiBESVJfSEFTX0JTRF9HUk9VUF9TRU1BTlRJQ1MKIyBkZWZpbmUgRk9SQ0VfRElSX1NFVF9HSUQgU19JU0dJRAojZWxzZQojIGRlZmluZSBGT1JDRV9ESVJfU0VUX0dJRCAwCiNlbmRpZgoKI2lmZGVmIE5PX05TRUMKI3VuZGVmIFVTRV9OU0VDCiNkZWZpbmUgU1RfQ1RJTUVfTlNFQyhzdCkgMAojZGVmaW5lIFNUX01USU1FX05TRUMoc3QpIDAKI2Vsc2UKI2lmZGVmIFVTRV9TVF9USU1FU1BFQwojZGVmaW5lIFNUX0NUSU1FX05TRUMoc3QpICgodW5zaWduZWQgaW50KSgoc3QpLnN0X2N0aW1lc3BlYy50dl9uc2VjKSkKI2RlZmluZSBTVF9NVElNRV9OU0VDKHN0KSAoKHVuc2lnbmVkIGludCkoKHN0KS5zdF9tdGltZXNwZWMudHZfbnNlYykpCiNlbHNlCiNkZWZpbmUgU1RfQ1RJTUVfTlNFQyhzdCkgKCh1bnNpZ25lZCBpbnQpKChzdCkuc3RfY3RpbS50dl9uc2VjKSkKI2RlZmluZSBTVF9NVElNRV9OU0VDKHN0KSAoKHVuc2lnbmVkIGludCkoKHN0KS5zdF9tdGltLnR2X25zZWMpKQojZW5kaWYKI2VuZGlmCgojaWZkZWYgVU5SRUxJQUJMRV9GU1RBVAojZGVmaW5lIGZzdGF0X2lzX3JlbGlhYmxlKCkgMAojZWxzZQojZGVmaW5lIGZzdGF0X2lzX3JlbGlhYmxlKCkgMQojZW5kaWYKCiNpZm5kZWYgdmFfY29weQovKgogKiBTaW5jZSBhbiBvYnZpb3VzIGltcGxlbWVudGF0aW9uIG9mIHZhX2xpc3Qgd291bGQgYmUgdG8gbWFrZSBpdCBhCiAqIHBvaW50ZXIgaW50byB0aGUgc3RhY2sgZnJhbWUsIGEgc2ltcGxlIGFzc2lnbm1lbnQgd2lsbCB3b3JrIG9uCiAqIG1hbnkgc3lzdGVtcy4gIEJ1dCBsZXQncyB0cnkgdG8gYmUgbW9yZSBwb3J0YWJsZS4KICovCiNpZmRlZiBfX3ZhX2NvcHkKI2RlZmluZSB2YV9jb3B5KGRzdCwgc3JjKSBfX3ZhX2NvcHkoZHN0LCBzcmMpCiNlbHNlCiNkZWZpbmUgdmFfY29weShkc3QsIHNyYykgKChkc3QpID0gKHNyYykpCiNlbmRpZgojZW5kaWYKCi8qCiAqIFRoaXMgaXMgYWx3YXlzIGRlZmluZWQgYXMgYSBmaXJzdCBzdGVwIHRvd2FyZHMgbWFraW5nIHRoZSB1c2Ugb2YgdmFyaWFkaWMKICogbWFjcm9zIHVuY29uZGl0aW9uYWwuIElmIGl0IGNhdXNlcyBjb21waWxhdGlvbiBwcm9ibGVtcyBvbiB5b3VyIHBsYXRmb3JtLAogKiBwbGVhc2UgcmVwb3J0IGl0IHRvIHRoZSBHaXQgbWFpbGluZyBsaXN0IGF0IGdpdEB2Z2VyLmtlcm5lbC5vcmcuCiAqLwojZGVmaW5lIEhBVkVfVkFSSUFESUNfTUFDUk9TIDEKCi8qIHVzYWdlLmM6IG9ubHkgdG8gYmUgdXNlZCBmb3IgdGVzdGluZyBCVUcoKSBpbXBsZW1lbnRhdGlvbiAoc2VlIHRlc3QtdG9vbCkgKi8KZXh0ZXJuIGludCBCVUdfZXhpdF9jb2RlOwoKI2lmZGVmIEhBVkVfVkFSSUFESUNfTUFDUk9TCl9fYXR0cmlidXRlX18oKGZvcm1hdCAocHJpbnRmLCAzLCA0KSkpIE5PUkVUVVJOCnZvaWQgQlVHX2ZsKGNvbnN0IGNoYXIgKmZpbGUsIGludCBsaW5lLCBjb25zdCBjaGFyICpmbXQsIC4uLik7CiNkZWZpbmUgQlVHKC4uLikgQlVHX2ZsKF9fRklMRV9fLCBfX0xJTkVfXywgX19WQV9BUkdTX18pCiNlbHNlCl9fYXR0cmlidXRlX18oKGZvcm1hdCAocHJpbnRmLCAxLCAyKSkpIE5PUkVUVVJOCnZvaWQgQlVHKGNvbnN0IGNoYXIgKmZtdCwgLi4uKTsKI2VuZGlmCgojaWZkZWYgX19BUFBMRV9fCiNkZWZpbmUgRlNZTkNfTUVUSE9EX0RFRkFVTFQgRlNZTkNfTUVUSE9EX1dSSVRFT1VUX09OTFkKI2Vsc2UKI2RlZmluZSBGU1lOQ19NRVRIT0RfREVGQVVMVCBGU1lOQ19NRVRIT0RfRlNZTkMKI2VuZGlmCgplbnVtIGZzeW5jX2FjdGlvbiB7CglGU1lOQ19XUklURU9VVF9PTkxZLAoJRlNZTkNfSEFSRFdBUkVfRkxVU0gKfTsKCi8qCiAqIElzc3VlcyBhbiBmc3luYyBhZ2FpbnN0IHRoZSBzcGVjaWZpZWQgZmlsZSBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBtb2RlLgogKgogKiBGU1lOQ19XUklURU9VVF9PTkxZIGF0dGVtcHRzIHRvIHVzZSBpbnRlcmZhY2VzIGF2YWlsYWJsZSBvbiBzb21lIG9wZXJhdGluZwogKiBzeXN0ZW1zIHRvIGZsdXNoIHRoZSBPUyBjYWNoZSB3aXRob3V0IGlzc3VpbmcgYSBmbHVzaCBjb21tYW5kIHRvIHRoZSBzdG9yYWdlCiAqIGNvbnRyb2xsZXIuIElmIHRob3NlIGludGVyZmFjZXMgYXJlIHVuYXZhaWxhYmxlLCB0aGUgZnVuY3Rpb24gZmFpbHMgd2l0aAogKiBFTk9TWVMuCiAqCiAqIEZTWU5DX0hBUkRXQVJFX0ZMVVNIIGRvZXMgYW4gT1Mgd3JpdGVvdXQgYW5kIGhhcmR3YXJlIGZsdXNoIHRvIGVuc3VyZSB0aGF0CiAqIGNoYW5nZXMgYXJlIGR1cmFibGUuIEl0IGlzIG5vdCBleHBlY3RlZCB0byBmYWlsLgogKi8KaW50IGdpdF9mc3luYyhpbnQgZmQsIGVudW0gZnN5bmNfYWN0aW9uIGFjdGlvbik7CgovKgogKiBQcmVzZXJ2ZXMgZXJybm8sIHByaW50cyBhIG1lc3NhZ2UsIGJ1dCBnaXZlcyBubyB3YXJuaW5nIGZvciBFTk9FTlQuCiAqIFJldHVybnMgMCBvbiBzdWNjZXNzLCB3aGljaCBpbmNsdWRlcyB0cnlpbmcgdG8gdW5saW5rIGFuIG9iamVjdCB0aGF0IGRvZXMKICogbm90IGV4aXN0LgogKi8KaW50IHVubGlua19vcl93YXJuKGNvbnN0IGNoYXIgKnBhdGgpOwogLyoKICAqIFRyaWVzIHRvIHVubGluayBmaWxlLiAgUmV0dXJucyAwIGlmIHVubGluayBzdWNjZWVkZWQKICAqIG9yIHRoZSBmaWxlIGFscmVhZHkgZGlkbid0IGV4aXN0LiAgUmV0dXJucyAtMSBhbmQKICAqIGFwcGVuZHMgYSBtZXNzYWdlIHRvIGVyciBzdWl0YWJsZSBmb3IKICAqICdlcnJvcigiJXMiLCBlcnItPmJ1ZiknIG9uIGVycm9yLgogICovCmludCB1bmxpbmtfb3JfbXNnKGNvbnN0IGNoYXIgKmZpbGUsIHN0cnVjdCBzdHJidWYgKmVycik7Ci8qCiAqIFByZXNlcnZlcyBlcnJubywgcHJpbnRzIGEgbWVzc2FnZSwgYnV0IGdpdmVzIG5vIHdhcm5pbmcgZm9yIEVOT0VOVC4KICogUmV0dXJucyAwIG9uIHN1Y2Nlc3MsIHdoaWNoIGluY2x1ZGVzIHRyeWluZyB0byByZW1vdmUgYSBkaXJlY3RvcnkgdGhhdCBkb2VzCiAqIG5vdCBleGlzdC4KICovCmludCBybWRpcl9vcl93YXJuKGNvbnN0IGNoYXIgKnBhdGgpOwovKgogKiBDYWxscyB0aGUgY29ycmVjdCBmdW5jdGlvbiBvdXQgb2Yge3VubGluayxybWRpcn1fb3Jfd2FybiBiYXNlZCBvbgogKiB0aGUgc3VwcGxpZWQgZmlsZSBtb2RlLgogKi8KaW50IHJlbW92ZV9vcl93YXJuKHVuc2lnbmVkIGludCBtb2RlLCBjb25zdCBjaGFyICpwYXRoKTsKCi8qCiAqIENhbGwgYWNjZXNzKDIpLCBidXQgd2FybiBmb3IgYW55IGVycm9yIGV4Y2VwdCAibWlzc2luZyBmaWxlIgogKiAoRU5PRU5UIG9yIEVOT1RESVIpLgogKi8KI2RlZmluZSBBQ0NFU1NfRUFDQ0VTX09LICgxVSA8PCAwKQppbnQgYWNjZXNzX29yX3dhcm4oY29uc3QgY2hhciAqcGF0aCwgaW50IG1vZGUsIHVuc2lnbmVkIGZsYWcpOwppbnQgYWNjZXNzX29yX2RpZShjb25zdCBjaGFyICpwYXRoLCBpbnQgbW9kZSwgdW5zaWduZWQgZmxhZyk7CgovKiBXYXJuIG9uIGFuIGluYWNjZXNzaWJsZSBmaWxlIGlmIGVycm5vIGluZGljYXRlcyB0aGlzIGlzIGFuIGVycm9yICovCmludCB3YXJuX29uX2ZvcGVuX2Vycm9ycyhjb25zdCBjaGFyICpwYXRoKTsKCi8qCiAqIE9wZW4gd2l0aCBPX05PRk9MTE9XLCBvciBlcXVpdmFsZW50LiBOb3RlIHRoYXQgdGhlIGZhbGxiYWNrIGVxdWl2YWxlbnQKICogbWF5IGJlIHJhY3kuIERvIG5vdCB1c2UgdGhpcyBhcyBwcm90ZWN0aW9uIGFnYWluc3QgYW4gYXR0YWNrZXIgd2hvIGNhbgogKiBzaW11bHRhbmVvdXNseSBjcmVhdGUgcGF0aHMuCiAqLwppbnQgb3Blbl9ub2ZvbGxvdyhjb25zdCBjaGFyICpwYXRoLCBpbnQgZmxhZ3MpOwoKI2lmbmRlZiBTSEVMTF9QQVRICiMgZGVmaW5lIFNIRUxMX1BBVEggIi9iaW4vc2giCiNlbmRpZgoKI2lmbmRlZiBfUE9TSVhfVEhSRUFEX1NBRkVfRlVOQ1RJT05TCnN0YXRpYyBpbmxpbmUgdm9pZCBmbG9ja2ZpbGUoRklMRSAqZmgpCnsKCTsgLyogbm90aGluZyAqLwp9CnN0YXRpYyBpbmxpbmUgdm9pZCBmdW5sb2NrZmlsZShGSUxFICpmaCkKewoJOyAvKiBub3RoaW5nICovCn0KI2RlZmluZSBnZXRjX3VubG9ja2VkKGZoKSBnZXRjKGZoKQojZW5kaWYKCiNpZmRlZiBGSUxFTk9fSVNfQV9NQUNSTwppbnQgZ2l0X2ZpbGVubyhGSUxFICpzdHJlYW0pOwojIGlmbmRlZiBDT01QQVRfQ09ERV9GSUxFTk8KIyAgdW5kZWYgZmlsZW5vCiMgIGRlZmluZSBmaWxlbm8ocCkgZ2l0X2ZpbGVubyhwKQojIGVuZGlmCiNlbmRpZgoKI2lmZGVmIE5FRURfQUNDRVNTX1JPT1RfSEFORExFUgppbnQgZ2l0X2FjY2Vzcyhjb25zdCBjaGFyICpwYXRoLCBpbnQgbW9kZSk7CiMgaWZuZGVmIENPTVBBVF9DT0RFX0FDQ0VTUwojICBpZmRlZiBhY2Nlc3MKIyAgdW5kZWYgYWNjZXNzCiMgIGVuZGlmCiMgIGRlZmluZSBhY2Nlc3MocGF0aCwgbW9kZSkgZ2l0X2FjY2VzcyhwYXRoLCBtb2RlKQojIGVuZGlmCiNlbmRpZgoKLyoKICogT3VyIGNvZGUgb2Z0ZW4gb3BlbnMgYSBwYXRoIHRvIGFuIG9wdGlvbmFsIGZpbGUsIHRvIHdvcmsgb24gaXRzCiAqIGNvbnRlbnRzIHdoZW4gd2UgY2FuIHN1Y2Nlc3NmdWxseSBvcGVuIGl0LiAgV2UgY2FuIGlnbm9yZSBhIGZhaWx1cmUKICogdG8gb3BlbiBpZiBzdWNoIGFuIG9wdGlvbmFsIGZpbGUgZG9lcyBub3QgZXhpc3QsIGJ1dCB3ZSBkbyB3YW50IHRvCiAqIHJlcG9ydCBhIGZhaWx1cmUgaW4gb3BlbmluZyBmb3Igb3RoZXIgcmVhc29ucyAoZS5nLiB3ZSBnb3QgYW4gSS9PCiAqIGVycm9yLCBvciB0aGUgZmlsZSBpcyB0aGVyZSwgYnV0IHdlIGxhY2sgdGhlIHBlcm1pc3Npb24gdG8gb3BlbikuCiAqCiAqIENhbGwgdGhpcyBmdW5jdGlvbiBhZnRlciBzZWVpbmcgYW4gZXJyb3IgZnJvbSBvcGVuKCkgb3IgZm9wZW4oKSB0bwogKiBzZWUgaWYgdGhlIGVycm5vIGluZGljYXRlcyBhIG1pc3NpbmcgZmlsZSB0aGF0IHdlIGNhbiBzYWZlbHkgaWdub3JlLgogKi8Kc3RhdGljIGlubGluZSBpbnQgaXNfbWlzc2luZ19maWxlX2Vycm9yKGludCBlcnJub18pCnsKCXJldHVybiAoZXJybm9fID09IEVOT0VOVCB8fCBlcnJub18gPT0gRU5PVERJUik7Cn0KCmludCBjbWRfbWFpbihpbnQsIGNvbnN0IGNoYXIgKiopOwoKLyoKICogSW50ZXJjZXB0IGFsbCBjYWxscyB0byBleGl0KCkgYW5kIHJvdXRlIHRoZW0gdG8gdHJhY2UyIHRvCiAqIG9wdGlvbmFsbHkgZW1pdCBhIG1lc3NhZ2UgYmVmb3JlIGNhbGxpbmcgdGhlIHJlYWwgZXhpdCgpLgogKi8KaW50IHRyYWNlMl9jbWRfZXhpdF9mbChjb25zdCBjaGFyICpmaWxlLCBpbnQgbGluZSwgaW50IGNvZGUpOwojZGVmaW5lIGV4aXQoY29kZSkgZXhpdCh0cmFjZTJfY21kX2V4aXRfZmwoX19GSUxFX18sIF9fTElORV9fLCAoY29kZSkpKQoKLyoKICogWW91IGNhbiBtYXJrIGEgc3RhY2sgdmFyaWFibGUgd2l0aCBVTkxFQUsodmFyKSB0byBhdm9pZCBpdCBiZWluZwogKiByZXBvcnRlZCBhcyBhIGxlYWsgYnkgdG9vbHMgbGlrZSBMU0FOIG9yIHZhbGdyaW5kLiBUaGUgYXJndW1lbnQKICogc2hvdWxkIGdlbmVyYWxseSBiZSB0aGUgdmFyaWFibGUgaXRzZWxmIChub3QgaXRzIGFkZHJlc3MgYW5kIG5vdCB3aGF0CiAqIGl0IHBvaW50cyB0bykuIEl0J3Mgc2FmZSB0byB1c2UgdGhpcyBvbiBwb2ludGVycyB3aGljaCBtYXkgYWxyZWFkeQogKiBoYXZlIGJlZW4gZnJlZWQsIG9yIG9uIHBvaW50ZXJzIHdoaWNoIG1heSBzdGlsbCBiZSBpbiB1c2UuCiAqCiAqIFVzZSB0aGlzIF9vbmx5XyBmb3IgYSB2YXJpYWJsZSB0aGF0IGxlYWtzIGJ5IGdvaW5nIG91dCBvZiBzY29wZSBhdAogKiBwcm9ncmFtIGV4aXQgKHNvIG9ubHkgZnJvbSBjbWRfKiBmdW5jdGlvbnMgb3IgdGhlaXIgZGlyZWN0IGhlbHBlcnMpLgogKiBOb3JtYWwgZnVuY3Rpb25zLCBlc3BlY2lhbGx5IHRob3NlIHdoaWNoIG1heSBiZSBjYWxsZWQgbXVsdGlwbGUKICogdGltZXMsIHNob3VsZCBhY3R1YWxseSBmcmVlIHRoZWlyIG1lbW9yeS4gVGhpcyBpcyBvbmx5IG1lYW50IGFzCiAqIGFuIGFubm90YXRpb24sIGFuZCBkb2VzIG5vdGhpbmcgaW4gbm9uLWxlYWstY2hlY2tpbmcgYnVpbGRzLgogKi8KI2lmZGVmIFNVUFBSRVNTX0FOTk9UQVRFRF9MRUFLUwp2b2lkIHVubGVha19tZW1vcnkoY29uc3Qgdm9pZCAqcHRyLCBzaXplX3QgbGVuKTsKI2RlZmluZSBVTkxFQUsodmFyKSB1bmxlYWtfbWVtb3J5KCYodmFyKSwgc2l6ZW9mKHZhcikpCiNlbHNlCiNkZWZpbmUgVU5MRUFLKHZhcikgZG8ge30gd2hpbGUgKDApCiNlbmRpZgoKI2RlZmluZSB6X2NvbnN0CiNpbmNsdWRlIDx6bGliLmg+CgojaWYgWkxJQl9WRVJOVU0gPCAweDEyOTAKLyoKICogVGhpcyBpcyB1bmNvbXByZXNzMiwgd2hpY2ggaXMgb25seSBhdmFpbGFibGUgaW4gemxpYiA+PSAxLjIuOQogKiAocmVsZWFzZWQgYXMgb2YgZWFybHkgMjAxNykuIFNlZSBjb21wYXQvemxpYi11bmNvbXByZXNzMi5jLgogKi8KaW50IHVuY29tcHJlc3MyKEJ5dGVmICpkZXN0LCB1TG9uZ2YgKmRlc3RMZW4sIGNvbnN0IEJ5dGVmICpzb3VyY2UsCgkJdUxvbmcgKnNvdXJjZUxlbik7CiNlbmRpZgoKLyoKICogVGhpcyBpbmNsdWRlIG11c3QgY29tZSBhZnRlciBzeXN0ZW0gaGVhZGVycywgc2luY2UgaXQgaW50cm9kdWNlcyBtYWNyb3MgdGhhdAogKiByZXBsYWNlIHN5c3RlbSBuYW1lcy4KICovCiNpbmNsdWRlICJiYW5uZWQuaCIKCi8qCiAqIGNvbnRhaW5lcl9vZiAtIEdldCB0aGUgYWRkcmVzcyBvZiBhbiBvYmplY3QgY29udGFpbmluZyBhIGZpZWxkLgogKgogKiBAcHRyOiBwb2ludGVyIHRvIHRoZSBmaWVsZC4KICogQHR5cGU6IHR5cGUgb2YgdGhlIG9iamVjdC4KICogQG1lbWJlcjogbmFtZSBvZiB0aGUgZmllbGQgd2l0aGluIHRoZSBvYmplY3QuCiAqLwojZGVmaW5lIGNvbnRhaW5lcl9vZihwdHIsIHR5cGUsIG1lbWJlcikgXAoJKCh0eXBlICopICgoY2hhciAqKShwdHIpIC0gb2Zmc2V0b2YodHlwZSwgbWVtYmVyKSkpCgovKgogKiBoZWxwZXIgZnVuY3Rpb24gZm9yIGBjb250YWluZXJfb2Zfb3JfbnVsbCcgdG8gYXZvaWQgbXVsdGlwbGUKICogZXZhbHVhdGlvbiBvZiBAcHRyCiAqLwpzdGF0aWMgaW5saW5lIHZvaWQgKmNvbnRhaW5lcl9vZl9vcl9udWxsX29mZnNldCh2b2lkICpwdHIsIHNpemVfdCBvZmZzZXQpCnsKCXJldHVybiBwdHIgPyAoY2hhciAqKXB0ciAtIG9mZnNldCA6IE5VTEw7Cn0KCi8qCiAqIGxpa2UgYGNvbnRhaW5lcl9vZicsIGJ1dCBhbGxvd3MgcmV0dXJuZWQgdmFsdWUgdG8gYmUgTlVMTAogKi8KI2RlZmluZSBjb250YWluZXJfb2Zfb3JfbnVsbChwdHIsIHR5cGUsIG1lbWJlcikgXAoJKHR5cGUgKiljb250YWluZXJfb2Zfb3JfbnVsbF9vZmZzZXQocHRyLCBvZmZzZXRvZih0eXBlLCBtZW1iZXIpKQoKLyoKICogbGlrZSBvZmZzZXRvZigpLCBidXQgdGFrZXMgYSBwb2ludGVyIHRvIGEgdmFyaWFibGUgb2YgdHlwZSB3aGljaAogKiBjb250YWlucyBAbWVtYmVyLCBpbnN0ZWFkIG9mIGEgc3BlY2lmaWVkIHR5cGUuCiAqIEBwdHIgaXMgc3ViamVjdCB0byBtdWx0aXBsZSBldmFsdWF0aW9uIHNpbmNlIHdlIGNhbid0IHJlbHkgb24gX190eXBlb2ZfXwogKiBldmVyeXdoZXJlLgogKi8KI2lmIGRlZmluZWQoX19HTlVDX18pIC8qIGNsYW5nIHNldHMgdGhpcywgdG9vICovCiNkZWZpbmUgT0ZGU0VUT0ZfVkFSKHB0ciwgbWVtYmVyKSBvZmZzZXRvZihfX3R5cGVvZl9fKCpwdHIpLCBtZW1iZXIpCiNlbHNlIC8qICFfX0dOVUNfXyAqLwojZGVmaW5lIE9GRlNFVE9GX1ZBUihwdHIsIG1lbWJlcikgXAoJKCh1aW50cHRyX3QpJihwdHIpLT5tZW1iZXIgLSAodWludHB0cl90KShwdHIpKQojZW5kaWYgLyogIV9fR05VQ19fICovCgp2b2lkIHNsZWVwX21pbGxpc2VjKGludCBtaWxsaXNlYyk7CgovKgogKiBHZW5lcmF0ZSBsZW4gYnl0ZXMgZnJvbSB0aGUgc3lzdGVtIGNyeXB0b2dyYXBoaWNhbGx5IHNlY3VyZSBQUk5HLgogKiBSZXR1cm5zIDAgb24gc3VjY2VzcyBhbmQgLTEgb24gZXJyb3IsIHNldHRpbmcgZXJybm8uICBUaGUgaW5hYmlsaXR5IHRvCiAqIHNhdGlzZnkgdGhlIGZ1bGwgcmVxdWVzdCBpcyBhbiBlcnJvci4KICovCmludCBjc3BybmdfYnl0ZXModm9pZCAqYnVmLCBzaXplX3QgbGVuKTsKCiNlbmRpZgo=",
    "text": "#ifndef GIT_COMPAT_UTIL_H\n#define GIT_COMPAT_UTIL_H\n\n#if __STDC_VERSION__ - 0 < 199901L\n/*\n * Git is in a testing period for mandatory C99 support in the compiler.  If\n * your compiler is reasonably recent, you can try to enable C99 support (or,\n * for MSVC, C11 support).  If you encounter a problem and can't enable C99\n * support with your compiler (such as with \"-std=gnu99\") and don't have access\n * to one with this support, such as GCC or Clang, you can remove this #if\n * directive, but please report the details of your system to\n * git@vger.kernel.org.\n */\n#error \"Required C99 support is in a test phase.  Please see git-compat-util.h for more details.\"\n#endif\n\n#ifdef USE_MSVC_CRTDBG\n/*\n * For these to work they must appear very early in each\n * file -- before most of the standard header files.\n */\n#include <stdlib.h>\n#include <crtdbg.h>\n#endif\n\n#define _FILE_OFFSET_BITS 64\n\n\n/* Derived from Linux \"Features Test Macro\" header\n * Convenience macros to test the versions of gcc (or\n * a compatible compiler).\n * Use them like this:\n *  #if GIT_GNUC_PREREQ (2,8)\n *   ... code requiring gcc 2.8 or later ...\n *  #endif\n*/\n#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n# define GIT_GNUC_PREREQ(maj, min) \\\n\t((__GNUC__ << 16) + __GNUC_MINOR__ >= ((maj) << 16) + (min))\n#else\n #define GIT_GNUC_PREREQ(maj, min) 0\n#endif\n\n\n#ifndef FLEX_ARRAY\n/*\n * See if our compiler is known to support flexible array members.\n */\n\n/*\n * Check vendor specific quirks first, before checking the\n * __STDC_VERSION__, as vendor compilers can lie and we need to be\n * able to work them around.  Note that by not defining FLEX_ARRAY\n * here, we can fall back to use the \"safer but a bit wasteful\" one\n * later.\n */\n#if defined(__SUNPRO_C) && (__SUNPRO_C <= 0x580)\n#elif defined(__GNUC__)\n# if (__GNUC__ >= 3)\n#  define FLEX_ARRAY /* empty */\n# else\n#  define FLEX_ARRAY 0 /* older GNU extension */\n# endif\n#elif defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)\n# define FLEX_ARRAY /* empty */\n#endif\n\n/*\n * Otherwise, default to safer but a bit wasteful traditional style\n */\n#ifndef FLEX_ARRAY\n# define FLEX_ARRAY 1\n#endif\n#endif\n\n\n/*\n * BUILD_ASSERT_OR_ZERO - assert a build-time dependency, as an expression.\n * @cond: the compile-time condition which must be true.\n *\n * Your compile will fail if the condition isn't true, or can't be evaluated\n * by the compiler.  This can be used in an expression: its value is \"0\".\n *\n * Example:\n *\t#define foo_to_char(foo)\t\t\t\t\t\\\n *\t\t ((char *)(foo)\t\t\t\t\t\t\\\n *\t\t  + BUILD_ASSERT_OR_ZERO(offsetof(struct foo, string) == 0))\n */\n#define BUILD_ASSERT_OR_ZERO(cond) \\\n\t(sizeof(char [1 - 2*!(cond)]) - 1)\n\n#if GIT_GNUC_PREREQ(3, 1)\n /* &arr[0] degrades to a pointer: a different type from an array */\n# define BARF_UNLESS_AN_ARRAY(arr)\t\t\t\t\t\t\\\n\tBUILD_ASSERT_OR_ZERO(!__builtin_types_compatible_p(__typeof__(arr), \\\n\t\t\t\t\t\t\t   __typeof__(&(arr)[0])))\n#else\n# define BARF_UNLESS_AN_ARRAY(arr) 0\n#endif\n/*\n * ARRAY_SIZE - get the number of elements in a visible array\n * @x: the array whose size you want.\n *\n * This does not work on pointers, or arrays declared as [], or\n * function parameters.  With correct compiler support, such usage\n * will cause a build error (see the build_assert_or_zero macro).\n */\n#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]) + BARF_UNLESS_AN_ARRAY(x))\n\n#define bitsizeof(x)  (CHAR_BIT * sizeof(x))\n\n#define maximum_signed_value_of_type(a) \\\n    (INTMAX_MAX >> (bitsizeof(intmax_t) - bitsizeof(a)))\n\n#define maximum_unsigned_value_of_type(a) \\\n    (UINTMAX_MAX >> (bitsizeof(uintmax_t) - bitsizeof(a)))\n\n/*\n * Signed integer overflow is undefined in C, so here's a helper macro\n * to detect if the sum of two integers will overflow.\n *\n * Requires: a >= 0, typeof(a) equals typeof(b)\n */\n#define signed_add_overflows(a, b) \\\n    ((b) > maximum_signed_value_of_type(a) - (a))\n\n#define unsigned_add_overflows(a, b) \\\n    ((b) > maximum_unsigned_value_of_type(a) - (a))\n\n/*\n * Returns true if the multiplication of \"a\" and \"b\" will\n * overflow. The types of \"a\" and \"b\" must match and must be unsigned.\n * Note that this macro evaluates \"a\" twice!\n */\n#define unsigned_mult_overflows(a, b) \\\n    ((a) && (b) > maximum_unsigned_value_of_type(a) / (a))\n\n/*\n * Returns true if the left shift of \"a\" by \"shift\" bits will\n * overflow. The type of \"a\" must be unsigned.\n */\n#define unsigned_left_shift_overflows(a, shift) \\\n    ((shift) < bitsizeof(a) && \\\n     (a) > maximum_unsigned_value_of_type(a) >> (shift))\n\n#ifdef __GNUC__\n#define TYPEOF(x) (__typeof__(x))\n#else\n#define TYPEOF(x)\n#endif\n\n#define MSB(x, bits) ((x) & TYPEOF(x)(~0ULL << (bitsizeof(x) - (bits))))\n#define HAS_MULTI_BITS(i)  ((i) & ((i) - 1))  /* checks if an integer has more than 1 bit set */\n\n#define DIV_ROUND_UP(n,d) (((n) + (d) - 1) / (d))\n\n/* Approximation of the length of the decimal representation of this type. */\n#define decimal_length(x)\t((int)(sizeof(x) * 2.56 + 0.5) + 1)\n\n#ifdef __MINGW64__\n#define _POSIX_C_SOURCE 1\n#elif defined(__sun__)\n /*\n  * On Solaris, when _XOPEN_EXTENDED is set, its header file\n  * forces the programs to be XPG4v2, defeating any _XOPEN_SOURCE\n  * setting to say we are XPG5 or XPG6.  Also on Solaris,\n  * XPG6 programs must be compiled with a c99 compiler, while\n  * non XPG6 programs must be compiled with a pre-c99 compiler.\n  */\n# if __STDC_VERSION__ - 0 >= 199901L\n# define _XOPEN_SOURCE 600\n# else\n# define _XOPEN_SOURCE 500\n# endif\n#elif !defined(__APPLE__) && !defined(__FreeBSD__) && !defined(__USLC__) && \\\n      !defined(_M_UNIX) && !defined(__sgi) && !defined(__DragonFly__) && \\\n      !defined(__TANDEM) && !defined(__QNX__) && !defined(__MirBSD__) && \\\n      !defined(__CYGWIN__)\n#define _XOPEN_SOURCE 600 /* glibc2 and AIX 5.3L need 500, OpenBSD needs 600 for S_ISLNK() */\n#define _XOPEN_SOURCE_EXTENDED 1 /* AIX 5.3L needs this */\n#endif\n#define _ALL_SOURCE 1\n#define _GNU_SOURCE 1\n#define _BSD_SOURCE 1\n#define _DEFAULT_SOURCE 1\n#define _NETBSD_SOURCE 1\n#define _SGI_SOURCE 1\n\n#if defined(WIN32) && !defined(__CYGWIN__) /* Both MinGW and MSVC */\n# if !defined(_WIN32_WINNT)\n#  define _WIN32_WINNT 0x0600\n# endif\n#define WIN32_LEAN_AND_MEAN  /* stops windows.h including winsock.h */\n#include <winsock2.h>\n#ifndef NO_UNIX_SOCKETS\n#include <afunix.h>\n#endif\n#include <windows.h>\n#define GIT_WINDOWS_NATIVE\n#endif\n\n#include <unistd.h>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#ifdef HAVE_STRINGS_H\n#include <strings.h> /* for strcasecmp() */\n#endif\n#include <errno.h>\n#include <limits.h>\n#ifdef NEEDS_SYS_PARAM_H\n#include <sys/param.h>\n#endif\n#include <sys/types.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <time.h>\n#include <signal.h>\n#include <assert.h>\n#include <regex.h>\n#include <utime.h>\n#include <syslog.h>\n#if !defined(NO_POLL_H)\n#include <poll.h>\n#elif !defined(NO_SYS_POLL_H)\n#include <sys/poll.h>\n#else\n/* Pull the compat stuff */\n#include <poll.h>\n#endif\n#ifdef HAVE_BSD_SYSCTL\n#include <sys/sysctl.h>\n#endif\n\n#if defined(__CYGWIN__)\n#include \"compat/win32/path-utils.h\"\n#endif\n#if defined(__MINGW32__)\n/* pull in Windows compatibility stuff */\n#include \"compat/win32/path-utils.h\"\n#include \"compat/mingw.h\"\n#elif defined(_MSC_VER)\n#include \"compat/win32/path-utils.h\"\n#include \"compat/msvc.h\"\n#else\n#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <termios.h>\n#ifndef NO_SYS_SELECT_H\n#include <sys/select.h>\n#endif\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <pwd.h>\n#include <sys/un.h>\n#ifndef NO_INTTYPES_H\n#include <inttypes.h>\n#else\n#include <stdint.h>\n#endif\n#ifdef HAVE_ARC4RANDOM_LIBBSD\n#include <bsd/stdlib.h>\n#endif\n#ifdef HAVE_GETRANDOM\n#include <sys/random.h>\n#endif\n#ifdef NO_INTPTR_T\n/*\n * On I16LP32, ILP32 and LP64 \"long\" is the safe bet, however\n * on LLP86, IL33LLP64 and P64 it needs to be \"long long\",\n * while on IP16 and IP16L32 it is \"int\" (resp. \"short\")\n * Size needs to match (or exceed) 'sizeof(void *)'.\n * We can't take \"long long\" here as not everybody has it.\n */\ntypedef long intptr_t;\ntypedef unsigned long uintptr_t;\n#endif\n#undef _ALL_SOURCE /* AIX 5.3L defines a struct list with _ALL_SOURCE. */\n#include <grp.h>\n#define _ALL_SOURCE 1\n#endif\n\n/* used on Mac OS X */\n#ifdef PRECOMPOSE_UNICODE\n#include \"compat/precompose_utf8.h\"\n#else\nstatic inline const char *precompose_argv_prefix(int argc, const char **argv, const char *prefix)\n{\n\treturn prefix;\n}\nstatic inline const char *precompose_string_if_needed(const char *in)\n{\n\treturn in;\n}\n\n#define probe_utf8_pathname_composition()\n#endif\n\n#ifdef MKDIR_WO_TRAILING_SLASH\n#define mkdir(a,b) compat_mkdir_wo_trailing_slash((a),(b))\nint compat_mkdir_wo_trailing_slash(const char*, mode_t);\n#endif\n\n#ifdef NO_STRUCT_ITIMERVAL\nstruct itimerval {\n\tstruct timeval it_interval;\n\tstruct timeval it_value;\n};\n#endif\n\n#ifdef NO_SETITIMER\nstatic inline int setitimer(int which, const struct itimerval *value, struct itimerval *newvalue) {\n\treturn 0; /* pretend success */\n}\n#endif\n\n#ifndef NO_LIBGEN_H\n#include <libgen.h>\n#else\n#define basename gitbasename\nchar *gitbasename(char *);\n#define dirname gitdirname\nchar *gitdirname(char *);\n#endif\n\n#ifndef NO_ICONV\n#include <iconv.h>\n#endif\n\n#ifndef NO_OPENSSL\n#ifdef __APPLE__\n#define __AVAILABILITY_MACROS_USES_AVAILABILITY 0\n#include <AvailabilityMacros.h>\n#undef DEPRECATED_ATTRIBUTE\n#define DEPRECATED_ATTRIBUTE\n#undef __AVAILABILITY_MACROS_USES_AVAILABILITY\n#endif\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#endif\n\n#ifdef HAVE_SYSINFO\n# include <sys/sysinfo.h>\n#endif\n\n/* On most systems <netdb.h> would have given us this, but\n * not on some systems (e.g. z/OS).\n */\n#ifndef NI_MAXHOST\n#define NI_MAXHOST 1025\n#endif\n\n#ifndef NI_MAXSERV\n#define NI_MAXSERV 32\n#endif\n\n/* On most systems <limits.h> would have given us this, but\n * not on some systems (e.g. GNU/Hurd).\n */\n#ifndef PATH_MAX\n#define PATH_MAX 4096\n#endif\n\ntypedef uintmax_t timestamp_t;\n#define PRItime PRIuMAX\n#define parse_timestamp strtoumax\n#define TIME_MAX UINTMAX_MAX\n#define TIME_MIN 0\n\n#ifndef PATH_SEP\n#define PATH_SEP ':'\n#endif\n\n#ifdef HAVE_PATHS_H\n#include <paths.h>\n#endif\n#ifndef _PATH_DEFPATH\n#define _PATH_DEFPATH \"/usr/local/bin:/usr/bin:/bin\"\n#endif\n\n#ifndef platform_core_config\nstatic inline int noop_core_config(const char *var, const char *value, void *cb)\n{\n\treturn 0;\n}\n#define platform_core_config noop_core_config\n#endif\n\nint lstat_cache_aware_rmdir(const char *path);\n#if !defined(__MINGW32__) && !defined(_MSC_VER)\n#define rmdir lstat_cache_aware_rmdir\n#endif\n\n#ifndef has_dos_drive_prefix\nstatic inline int git_has_dos_drive_prefix(const char *path)\n{\n\treturn 0;\n}\n#define has_dos_drive_prefix git_has_dos_drive_prefix\n#endif\n\n#ifndef skip_dos_drive_prefix\nstatic inline int git_skip_dos_drive_prefix(char **path)\n{\n\treturn 0;\n}\n#define skip_dos_drive_prefix git_skip_dos_drive_prefix\n#endif\n\n#ifndef is_dir_sep\nstatic inline int git_is_dir_sep(int c)\n{\n\treturn c == '/';\n}\n#define is_dir_sep git_is_dir_sep\n#endif\n\n#ifndef offset_1st_component\nstatic inline int git_offset_1st_component(const char *path)\n{\n\treturn is_dir_sep(path[0]);\n}\n#define offset_1st_component git_offset_1st_component\n#endif\n\n#ifndef is_valid_path\n#define is_valid_path(path) 1\n#endif\n\n#ifndef find_last_dir_sep\nstatic inline char *git_find_last_dir_sep(const char *path)\n{\n\treturn strrchr(path, '/');\n}\n#define find_last_dir_sep git_find_last_dir_sep\n#endif\n\n#ifndef has_dir_sep\nstatic inline int git_has_dir_sep(const char *path)\n{\n\treturn !!strchr(path, '/');\n}\n#define has_dir_sep(path) git_has_dir_sep(path)\n#endif\n\n#ifndef query_user_email\n#define query_user_email() NULL\n#endif\n\n#ifdef __TANDEM\n#include <floss.h(floss_execl,floss_execlp,floss_execv,floss_execvp)>\n#include <floss.h(floss_getpwuid)>\n#ifndef NSIG\n/*\n * NonStop NSE and NSX do not provide NSIG. SIGGUARDIAN(99) is the highest\n * known, by detective work using kill -l as a list is all signals\n * instead of signal.h where it should be.\n */\n# define NSIG 100\n#endif\n#endif\n\n#if defined(__HP_cc) && (__HP_cc >= 61000)\n#define NORETURN __attribute__((noreturn))\n#define NORETURN_PTR\n#elif defined(__GNUC__) && !defined(NO_NORETURN)\n#define NORETURN __attribute__((__noreturn__))\n#define NORETURN_PTR __attribute__((__noreturn__))\n#elif defined(_MSC_VER)\n#define NORETURN __declspec(noreturn)\n#define NORETURN_PTR\n#else\n#define NORETURN\n#define NORETURN_PTR\n#ifndef __GNUC__\n#ifndef __attribute__\n#define __attribute__(x)\n#endif\n#endif\n#endif\n\n/* The sentinel attribute is valid from gcc version 4.0 */\n#if defined(__GNUC__) && (__GNUC__ >= 4)\n#define LAST_ARG_MUST_BE_NULL __attribute__((sentinel))\n#else\n#define LAST_ARG_MUST_BE_NULL\n#endif\n\n#define MAYBE_UNUSED __attribute__((__unused__))\n\n#include \"compat/bswap.h\"\n\n#include \"wildmatch.h\"\n\nstruct strbuf;\n\n/* General helper functions */\nNORETURN void usage(const char *err);\nNORETURN void usagef(const char *err, ...) __attribute__((format (printf, 1, 2)));\nNORETURN void die(const char *err, ...) __attribute__((format (printf, 1, 2)));\nNORETURN void die_errno(const char *err, ...) __attribute__((format (printf, 1, 2)));\nint die_message(const char *err, ...) __attribute__((format (printf, 1, 2)));\nint die_message_errno(const char *err, ...) __attribute__((format (printf, 1, 2)));\nint error(const char *err, ...) __attribute__((format (printf, 1, 2)));\nint error_errno(const char *err, ...) __attribute__((format (printf, 1, 2)));\nvoid warning(const char *err, ...) __attribute__((format (printf, 1, 2)));\nvoid warning_errno(const char *err, ...) __attribute__((format (printf, 1, 2)));\n\n#ifndef NO_OPENSSL\n#ifdef APPLE_COMMON_CRYPTO\n#include \"compat/apple-common-crypto.h\"\n#else\n#include <openssl/evp.h>\n#include <openssl/hmac.h>\n#endif /* APPLE_COMMON_CRYPTO */\n#include <openssl/x509v3.h>\n#endif /* NO_OPENSSL */\n\n/*\n * Let callers be aware of the constant return value; this can help\n * gcc with -Wuninitialized analysis. We restrict this trick to gcc, though,\n * because some compilers may not support variadic macros. Since we're only\n * trying to help gcc, anyway, it's OK; other compilers will fall back to\n * using the function as usual.\n */\n#if defined(__GNUC__)\nstatic inline int const_error(void)\n{\n\treturn -1;\n}\n#define error(...) (error(__VA_ARGS__), const_error())\n#define error_errno(...) (error_errno(__VA_ARGS__), const_error())\n#endif\n\ntypedef void (*report_fn)(const char *, va_list params);\n\nvoid set_die_routine(NORETURN_PTR report_fn routine);\nreport_fn get_die_message_routine(void);\nvoid set_error_routine(report_fn routine);\nreport_fn get_error_routine(void);\nvoid set_warn_routine(report_fn routine);\nreport_fn get_warn_routine(void);\nvoid set_die_is_recursing_routine(int (*routine)(void));\n\nint starts_with(const char *str, const char *prefix);\nint istarts_with(const char *str, const char *prefix);\n\n/*\n * If the string \"str\" begins with the string found in \"prefix\", return 1.\n * The \"out\" parameter is set to \"str + strlen(prefix)\" (i.e., to the point in\n * the string right after the prefix).\n *\n * Otherwise, return 0 and leave \"out\" untouched.\n *\n * Examples:\n *\n *   [extract branch name, fail if not a branch]\n *   if (!skip_prefix(ref, \"refs/heads/\", &branch)\n *\treturn -1;\n *\n *   [skip prefix if present, otherwise use whole string]\n *   skip_prefix(name, \"refs/heads/\", &name);\n */\nstatic inline int skip_prefix(const char *str, const char *prefix,\n\t\t\t      const char **out)\n{\n\tdo {\n\t\tif (!*prefix) {\n\t\t\t*out = str;\n\t\t\treturn 1;\n\t\t}\n\t} while (*str++ == *prefix++);\n\treturn 0;\n}\n\n/*\n * If the string \"str\" is the same as the string in \"prefix\", then the \"arg\"\n * parameter is set to the \"def\" parameter and 1 is returned.\n * If the string \"str\" begins with the string found in \"prefix\" and then a\n * \"=\" sign, then the \"arg\" parameter is set to \"str + strlen(prefix) + 1\"\n * (i.e., to the point in the string right after the prefix and the \"=\" sign),\n * and 1 is returned.\n *\n * Otherwise, return 0 and leave \"arg\" untouched.\n *\n * When we accept both a \"--key\" and a \"--key=<val>\" option, this function\n * can be used instead of !strcmp(arg, \"--key\") and then\n * skip_prefix(arg, \"--key=\", &arg) to parse such an option.\n */\nint skip_to_optional_arg_default(const char *str, const char *prefix,\n\t\t\t\t const char **arg, const char *def);\n\nstatic inline int skip_to_optional_arg(const char *str, const char *prefix,\n\t\t\t\t       const char **arg)\n{\n\treturn skip_to_optional_arg_default(str, prefix, arg, \"\");\n}\n\n/*\n * Like skip_prefix, but promises never to read past \"len\" bytes of the input\n * buffer, and returns the remaining number of bytes in \"out\" via \"outlen\".\n */\nstatic inline int skip_prefix_mem(const char *buf, size_t len,\n\t\t\t\t  const char *prefix,\n\t\t\t\t  const char **out, size_t *outlen)\n{\n\tsize_t prefix_len = strlen(prefix);\n\tif (prefix_len <= len && !memcmp(buf, prefix, prefix_len)) {\n\t\t*out = buf + prefix_len;\n\t\t*outlen = len - prefix_len;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*\n * If buf ends with suffix, return 1 and subtract the length of the suffix\n * from *len. Otherwise, return 0 and leave *len untouched.\n */\nstatic inline int strip_suffix_mem(const char *buf, size_t *len,\n\t\t\t\t   const char *suffix)\n{\n\tsize_t suflen = strlen(suffix);\n\tif (*len < suflen || memcmp(buf + (*len - suflen), suffix, suflen))\n\t\treturn 0;\n\t*len -= suflen;\n\treturn 1;\n}\n\n/*\n * If str ends with suffix, return 1 and set *len to the size of the string\n * without the suffix. Otherwise, return 0 and set *len to the size of the\n * string.\n *\n * Note that we do _not_ NUL-terminate str to the new length.\n */\nstatic inline int strip_suffix(const char *str, const char *suffix, size_t *len)\n{\n\t*len = strlen(str);\n\treturn strip_suffix_mem(str, len, suffix);\n}\n\nstatic inline int ends_with(const char *str, const char *suffix)\n{\n\tsize_t len;\n\treturn strip_suffix(str, suffix, &len);\n}\n\n#define SWAP(a, b) do {\t\t\t\t\t\t\\\n\tvoid *_swap_a_ptr = &(a);\t\t\t\t\\\n\tvoid *_swap_b_ptr = &(b);\t\t\t\t\\\n\tunsigned char _swap_buffer[sizeof(a)];\t\t\t\\\n\tmemcpy(_swap_buffer, _swap_a_ptr, sizeof(a));\t\t\\\n\tmemcpy(_swap_a_ptr, _swap_b_ptr, sizeof(a) +\t\t\\\n\t       BUILD_ASSERT_OR_ZERO(sizeof(a) == sizeof(b)));\t\\\n\tmemcpy(_swap_b_ptr, _swap_buffer, sizeof(a));\t\t\\\n} while (0)\n\n#if defined(NO_MMAP) || defined(USE_WIN32_MMAP)\n\n#ifndef PROT_READ\n#define PROT_READ 1\n#define PROT_WRITE 2\n#define MAP_PRIVATE 1\n#endif\n\n#define mmap git_mmap\n#define munmap git_munmap\nvoid *git_mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);\nint git_munmap(void *start, size_t length);\n\n#else /* NO_MMAP || USE_WIN32_MMAP */\n\n#include <sys/mman.h>\n\n#endif /* NO_MMAP || USE_WIN32_MMAP */\n\n#ifdef NO_MMAP\n\n/* This value must be multiple of (pagesize * 2) */\n#define DEFAULT_PACKED_GIT_WINDOW_SIZE (1 * 1024 * 1024)\n\n#else /* NO_MMAP */\n\n/* This value must be multiple of (pagesize * 2) */\n#define DEFAULT_PACKED_GIT_WINDOW_SIZE \\\n\t(sizeof(void*) >= 8 \\\n\t\t?  1 * 1024 * 1024 * 1024 \\\n\t\t: 32 * 1024 * 1024)\n\n#endif /* NO_MMAP */\n\n#ifndef MAP_FAILED\n#define MAP_FAILED ((void *)-1)\n#endif\n\n#ifdef NO_ST_BLOCKS_IN_STRUCT_STAT\n#define on_disk_bytes(st) ((st).st_size)\n#else\n#define on_disk_bytes(st) ((st).st_blocks * 512)\n#endif\n\n#ifdef NEEDS_MODE_TRANSLATION\n#undef S_IFMT\n#undef S_IFREG\n#undef S_IFDIR\n#undef S_IFLNK\n#undef S_IFBLK\n#undef S_IFCHR\n#undef S_IFIFO\n#undef S_IFSOCK\n#define S_IFMT   0170000\n#define S_IFREG  0100000\n#define S_IFDIR  0040000\n#define S_IFLNK  0120000\n#define S_IFBLK  0060000\n#define S_IFCHR  0020000\n#define S_IFIFO  0010000\n#define S_IFSOCK 0140000\n#ifdef stat\n#undef stat\n#endif\n#define stat(path, buf) git_stat(path, buf)\nint git_stat(const char *, struct stat *);\n#ifdef fstat\n#undef fstat\n#endif\n#define fstat(fd, buf) git_fstat(fd, buf)\nint git_fstat(int, struct stat *);\n#ifdef lstat\n#undef lstat\n#endif\n#define lstat(path, buf) git_lstat(path, buf)\nint git_lstat(const char *, struct stat *);\n#endif\n\n#define DEFAULT_PACKED_GIT_LIMIT \\\n\t((1024L * 1024L) * (size_t)(sizeof(void*) >= 8 ? (32 * 1024L * 1024L) : 256))\n\n#ifdef NO_PREAD\n#define pread git_pread\nssize_t git_pread(int fd, void *buf, size_t count, off_t offset);\n#endif\n/*\n * Forward decl that will remind us if its twin in cache.h changes.\n * This function is used in compat/pread.c.  But we can't include\n * cache.h there.\n */\nssize_t read_in_full(int fd, void *buf, size_t count);\n\n#ifdef NO_SETENV\n#define setenv gitsetenv\nint gitsetenv(const char *, const char *, int);\n#endif\n\n#ifdef NO_MKDTEMP\n#define mkdtemp gitmkdtemp\nchar *gitmkdtemp(char *);\n#endif\n\n#ifdef NO_UNSETENV\n#define unsetenv gitunsetenv\nint gitunsetenv(const char *);\n#endif\n\n#ifdef NO_STRCASESTR\n#define strcasestr gitstrcasestr\nchar *gitstrcasestr(const char *haystack, const char *needle);\n#endif\n\n#ifdef NO_STRLCPY\n#define strlcpy gitstrlcpy\nsize_t gitstrlcpy(char *, const char *, size_t);\n#endif\n\n#ifdef NO_STRTOUMAX\n#define strtoumax gitstrtoumax\nuintmax_t gitstrtoumax(const char *, char **, int);\n#define strtoimax gitstrtoimax\nintmax_t gitstrtoimax(const char *, char **, int);\n#endif\n\n#ifdef NO_HSTRERROR\n#define hstrerror githstrerror\nconst char *githstrerror(int herror);\n#endif\n\n#ifdef NO_MEMMEM\n#define memmem gitmemmem\nvoid *gitmemmem(const void *haystack, size_t haystacklen,\n\t\tconst void *needle, size_t needlelen);\n#endif\n\n#ifdef OVERRIDE_STRDUP\n#ifdef strdup\n#undef strdup\n#endif\n#define strdup gitstrdup\nchar *gitstrdup(const char *s);\n#endif\n\n#ifdef NO_GETPAGESIZE\n#define getpagesize() sysconf(_SC_PAGESIZE)\n#endif\n\n#ifndef O_CLOEXEC\n#define O_CLOEXEC 0\n#endif\n\n#ifdef FREAD_READS_DIRECTORIES\n# if !defined(SUPPRESS_FOPEN_REDEFINITION)\n#  ifdef fopen\n#   undef fopen\n#  endif\n#  define fopen(a,b) git_fopen(a,b)\n# endif\nFILE *git_fopen(const char*, const char*);\n#endif\n\n#ifdef SNPRINTF_RETURNS_BOGUS\n#ifdef snprintf\n#undef snprintf\n#endif\n#define snprintf git_snprintf\nint git_snprintf(char *str, size_t maxsize,\n\t\t const char *format, ...);\n#ifdef vsnprintf\n#undef vsnprintf\n#endif\n#define vsnprintf git_vsnprintf\nint git_vsnprintf(char *str, size_t maxsize,\n\t\t  const char *format, va_list ap);\n#endif\n\n#ifdef OPEN_RETURNS_EINTR\n#undef open\n#define open git_open_with_retry\nint git_open_with_retry(const char *path, int flag, ...);\n#endif\n\n#ifdef __GLIBC_PREREQ\n#if __GLIBC_PREREQ(2, 1)\n#define HAVE_STRCHRNUL\n#endif\n#endif\n\n#ifndef HAVE_STRCHRNUL\n#define strchrnul gitstrchrnul\nstatic inline char *gitstrchrnul(const char *s, int c)\n{\n\twhile (*s && *s != c)\n\t\ts++;\n\treturn (char *)s;\n}\n#endif\n\n#ifdef NO_INET_PTON\nint inet_pton(int af, const char *src, void *dst);\n#endif\n\n#ifdef NO_INET_NTOP\nconst char *inet_ntop(int af, const void *src, char *dst, size_t size);\n#endif\n\n#ifdef NO_PTHREADS\n#define atexit git_atexit\nint git_atexit(void (*handler)(void));\n#endif\n\nstatic inline size_t st_add(size_t a, size_t b)\n{\n\tif (unsigned_add_overflows(a, b))\n\t\tdie(\"size_t overflow: %\"PRIuMAX\" + %\"PRIuMAX,\n\t\t    (uintmax_t)a, (uintmax_t)b);\n\treturn a + b;\n}\n#define st_add3(a,b,c)   st_add(st_add((a),(b)),(c))\n#define st_add4(a,b,c,d) st_add(st_add3((a),(b),(c)),(d))\n\nstatic inline size_t st_mult(size_t a, size_t b)\n{\n\tif (unsigned_mult_overflows(a, b))\n\t\tdie(\"size_t overflow: %\"PRIuMAX\" * %\"PRIuMAX,\n\t\t    (uintmax_t)a, (uintmax_t)b);\n\treturn a * b;\n}\n\nstatic inline size_t st_sub(size_t a, size_t b)\n{\n\tif (a < b)\n\t\tdie(\"size_t underflow: %\"PRIuMAX\" - %\"PRIuMAX,\n\t\t    (uintmax_t)a, (uintmax_t)b);\n\treturn a - b;\n}\n\nstatic inline size_t st_left_shift(size_t a, unsigned shift)\n{\n\tif (unsigned_left_shift_overflows(a, shift))\n\t\tdie(\"size_t overflow: %\"PRIuMAX\" << %u\",\n\t\t    (uintmax_t)a, shift);\n\treturn a << shift;\n}\n\nstatic inline unsigned long cast_size_t_to_ulong(size_t a)\n{\n\tif (a != (unsigned long)a)\n\t\tdie(\"object too large to read on this platform: %\"\n\t\t    PRIuMAX\" is cut off to %lu\",\n\t\t    (uintmax_t)a, (unsigned long)a);\n\treturn (unsigned long)a;\n}\n\n#ifdef HAVE_ALLOCA_H\n# include <alloca.h>\n# define xalloca(size)      (alloca(size))\n# define xalloca_free(p)    do {} while (0)\n#else\n# define xalloca(size)      (xmalloc(size))\n# define xalloca_free(p)    (free(p))\n#endif\nchar *xstrdup(const char *str);\nvoid *xmalloc(size_t size);\nvoid *xmallocz(size_t size);\nvoid *xmallocz_gently(size_t size);\nvoid *xmemdupz(const void *data, size_t len);\nchar *xstrndup(const char *str, size_t len);\nvoid *xrealloc(void *ptr, size_t size);\nvoid *xcalloc(size_t nmemb, size_t size);\nvoid xsetenv(const char *name, const char *value, int overwrite);\nvoid *xmmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);\nconst char *mmap_os_err(void);\nvoid *xmmap_gently(void *start, size_t length, int prot, int flags, int fd, off_t offset);\nint xopen(const char *path, int flags, ...);\nssize_t xread(int fd, void *buf, size_t len);\nssize_t xwrite(int fd, const void *buf, size_t len);\nssize_t xpread(int fd, void *buf, size_t len, off_t offset);\nint xdup(int fd);\nFILE *xfopen(const char *path, const char *mode);\nFILE *xfdopen(int fd, const char *mode);\nint xmkstemp(char *temp_filename);\nint xmkstemp_mode(char *temp_filename, int mode);\nchar *xgetcwd(void);\nFILE *fopen_for_writing(const char *path);\nFILE *fopen_or_warn(const char *path, const char *mode);\n\n/*\n * Like strncmp, but only return zero if s is NUL-terminated and exactly len\n * characters long.  If it is not, consider it greater than t.\n */\nint xstrncmpz(const char *s, const char *t, size_t len);\n\n/*\n * FREE_AND_NULL(ptr) is like free(ptr) followed by ptr = NULL. Note\n * that ptr is used twice, so don't pass e.g. ptr++.\n */\n#define FREE_AND_NULL(p) do { free(p); (p) = NULL; } while (0)\n\n#define ALLOC_ARRAY(x, alloc) (x) = xmalloc(st_mult(sizeof(*(x)), (alloc)))\n#define CALLOC_ARRAY(x, alloc) (x) = xcalloc((alloc), sizeof(*(x)))\n#define REALLOC_ARRAY(x, alloc) (x) = xrealloc((x), st_mult(sizeof(*(x)), (alloc)))\n\n#define COPY_ARRAY(dst, src, n) copy_array((dst), (src), (n), sizeof(*(dst)) + \\\n\tBUILD_ASSERT_OR_ZERO(sizeof(*(dst)) == sizeof(*(src))))\nstatic inline void copy_array(void *dst, const void *src, size_t n, size_t size)\n{\n\tif (n)\n\t\tmemcpy(dst, src, st_mult(size, n));\n}\n\n#define MOVE_ARRAY(dst, src, n) move_array((dst), (src), (n), sizeof(*(dst)) + \\\n\tBUILD_ASSERT_OR_ZERO(sizeof(*(dst)) == sizeof(*(src))))\nstatic inline void move_array(void *dst, const void *src, size_t n, size_t size)\n{\n\tif (n)\n\t\tmemmove(dst, src, st_mult(size, n));\n}\n\n/*\n * These functions help you allocate structs with flex arrays, and copy\n * the data directly into the array. For example, if you had:\n *\n *   struct foo {\n *     int bar;\n *     char name[FLEX_ARRAY];\n *   };\n *\n * you can do:\n *\n *   struct foo *f;\n *   FLEX_ALLOC_MEM(f, name, src, len);\n *\n * to allocate a \"foo\" with the contents of \"src\" in the \"name\" field.\n * The resulting struct is automatically zero'd, and the flex-array field\n * is NUL-terminated (whether the incoming src buffer was or not).\n *\n * The FLEXPTR_* variants operate on structs that don't use flex-arrays,\n * but do want to store a pointer to some extra data in the same allocated\n * block. For example, if you have:\n *\n *   struct foo {\n *     char *name;\n *     int bar;\n *   };\n *\n * you can do:\n *\n *   struct foo *f;\n *   FLEXPTR_ALLOC_STR(f, name, src);\n *\n * and \"name\" will point to a block of memory after the struct, which will be\n * freed along with the struct (but the pointer can be repointed anywhere).\n *\n * The *_STR variants accept a string parameter rather than a ptr/len\n * combination.\n *\n * Note that these macros will evaluate the first parameter multiple\n * times, and it must be assignable as an lvalue.\n */\n#define FLEX_ALLOC_MEM(x, flexname, buf, len) do { \\\n\tsize_t flex_array_len_ = (len); \\\n\t(x) = xcalloc(1, st_add3(sizeof(*(x)), flex_array_len_, 1)); \\\n\tmemcpy((void *)(x)->flexname, (buf), flex_array_len_); \\\n} while (0)\n#define FLEXPTR_ALLOC_MEM(x, ptrname, buf, len) do { \\\n\tsize_t flex_array_len_ = (len); \\\n\t(x) = xcalloc(1, st_add3(sizeof(*(x)), flex_array_len_, 1)); \\\n\tmemcpy((x) + 1, (buf), flex_array_len_); \\\n\t(x)->ptrname = (void *)((x)+1); \\\n} while(0)\n#define FLEX_ALLOC_STR(x, flexname, str) \\\n\tFLEX_ALLOC_MEM((x), flexname, (str), strlen(str))\n#define FLEXPTR_ALLOC_STR(x, ptrname, str) \\\n\tFLEXPTR_ALLOC_MEM((x), ptrname, (str), strlen(str))\n\nstatic inline char *xstrdup_or_null(const char *str)\n{\n\treturn str ? xstrdup(str) : NULL;\n}\n\nstatic inline size_t xsize_t(off_t len)\n{\n\tif (len < 0 || (uintmax_t) len > SIZE_MAX)\n\t\tdie(\"Cannot handle files this big\");\n\treturn (size_t) len;\n}\n\n__attribute__((format (printf, 3, 4)))\nint xsnprintf(char *dst, size_t max, const char *fmt, ...);\n\n#ifndef HOST_NAME_MAX\n#define HOST_NAME_MAX 256\n#endif\n\nint xgethostname(char *buf, size_t len);\n\n/* in ctype.c, for kwset users */\nextern const unsigned char tolower_trans_tbl[256];\n\n/* Sane ctype - no locale, and works with signed chars */\n#undef isascii\n#undef isspace\n#undef isdigit\n#undef isalpha\n#undef isalnum\n#undef isprint\n#undef islower\n#undef isupper\n#undef tolower\n#undef toupper\n#undef iscntrl\n#undef ispunct\n#undef isxdigit\n\nextern const unsigned char sane_ctype[256];\n#define GIT_SPACE 0x01\n#define GIT_DIGIT 0x02\n#define GIT_ALPHA 0x04\n#define GIT_GLOB_SPECIAL 0x08\n#define GIT_REGEX_SPECIAL 0x10\n#define GIT_PATHSPEC_MAGIC 0x20\n#define GIT_CNTRL 0x40\n#define GIT_PUNCT 0x80\n#define sane_istest(x,mask) ((sane_ctype[(unsigned char)(x)] & (mask)) != 0)\n#define isascii(x) (((x) & ~0x7f) == 0)\n#define isspace(x) sane_istest(x,GIT_SPACE)\n#define isdigit(x) sane_istest(x,GIT_DIGIT)\n#define isalpha(x) sane_istest(x,GIT_ALPHA)\n#define isalnum(x) sane_istest(x,GIT_ALPHA | GIT_DIGIT)\n#define isprint(x) ((x) >= 0x20 && (x) <= 0x7e)\n#define islower(x) sane_iscase(x, 1)\n#define isupper(x) sane_iscase(x, 0)\n#define is_glob_special(x) sane_istest(x,GIT_GLOB_SPECIAL)\n#define is_regex_special(x) sane_istest(x,GIT_GLOB_SPECIAL | GIT_REGEX_SPECIAL)\n#define iscntrl(x) (sane_istest(x,GIT_CNTRL))\n#define ispunct(x) sane_istest(x, GIT_PUNCT | GIT_REGEX_SPECIAL | \\\n\t\tGIT_GLOB_SPECIAL | GIT_PATHSPEC_MAGIC)\n#define isxdigit(x) (hexval_table[(unsigned char)(x)] != -1)\n#define tolower(x) sane_case((unsigned char)(x), 0x20)\n#define toupper(x) sane_case((unsigned char)(x), 0)\n#define is_pathspec_magic(x) sane_istest(x,GIT_PATHSPEC_MAGIC)\n\nstatic inline int sane_case(int x, int high)\n{\n\tif (sane_istest(x, GIT_ALPHA))\n\t\tx = (x & ~0x20) | high;\n\treturn x;\n}\n\nstatic inline int sane_iscase(int x, int is_lower)\n{\n\tif (!sane_istest(x, GIT_ALPHA))\n\t\treturn 0;\n\n\tif (is_lower)\n\t\treturn (x & 0x20) != 0;\n\telse\n\t\treturn (x & 0x20) == 0;\n}\n\n/*\n * Like skip_prefix, but compare case-insensitively. Note that the comparison\n * is done via tolower(), so it is strictly ASCII (no multi-byte characters or\n * locale-specific conversions).\n */\nstatic inline int skip_iprefix(const char *str, const char *prefix,\n\t\t\t       const char **out)\n{\n\tdo {\n\t\tif (!*prefix) {\n\t\t\t*out = str;\n\t\t\treturn 1;\n\t\t}\n\t} while (tolower(*str++) == tolower(*prefix++));\n\treturn 0;\n}\n\nstatic inline int strtoul_ui(char const *s, int base, unsigned int *result)\n{\n\tunsigned long ul;\n\tchar *p;\n\n\terrno = 0;\n\t/* negative values would be accepted by strtoul */\n\tif (strchr(s, '-'))\n\t\treturn -1;\n\tul = strtoul(s, &p, base);\n\tif (errno || *p || p == s || (unsigned int) ul != ul)\n\t\treturn -1;\n\t*result = ul;\n\treturn 0;\n}\n\nstatic inline int strtol_i(char const *s, int base, int *result)\n{\n\tlong ul;\n\tchar *p;\n\n\terrno = 0;\n\tul = strtol(s, &p, base);\n\tif (errno || *p || p == s || (int) ul != ul)\n\t\treturn -1;\n\t*result = ul;\n\treturn 0;\n}\n\nvoid git_stable_qsort(void *base, size_t nmemb, size_t size,\n\t\t      int(*compar)(const void *, const void *));\n#ifdef INTERNAL_QSORT\n#define qsort git_stable_qsort\n#endif\n\n#define QSORT(base, n, compar) sane_qsort((base), (n), sizeof(*(base)), compar)\nstatic inline void sane_qsort(void *base, size_t nmemb, size_t size,\n\t\t\t      int(*compar)(const void *, const void *))\n{\n\tif (nmemb > 1)\n\t\tqsort(base, nmemb, size, compar);\n}\n\n#define STABLE_QSORT(base, n, compar) \\\n\tgit_stable_qsort((base), (n), sizeof(*(base)), compar)\n\n#ifndef HAVE_ISO_QSORT_S\nint git_qsort_s(void *base, size_t nmemb, size_t size,\n\t\tint (*compar)(const void *, const void *, void *), void *ctx);\n#define qsort_s git_qsort_s\n#endif\n\n#define QSORT_S(base, n, compar, ctx) do {\t\t\t\\\n\tif (qsort_s((base), (n), sizeof(*(base)), compar, ctx))\t\\\n\t\tBUG(\"qsort_s() failed\");\t\t\t\\\n} while (0)\n\n#ifndef REG_STARTEND\n#error \"Git requires REG_STARTEND support. Compile with NO_REGEX=NeedsStartEnd\"\n#endif\n\nstatic inline int regexec_buf(const regex_t *preg, const char *buf, size_t size,\n\t\t\t      size_t nmatch, regmatch_t pmatch[], int eflags)\n{\n\tassert(nmatch > 0 && pmatch);\n\tpmatch[0].rm_so = 0;\n\tpmatch[0].rm_eo = size;\n\treturn regexec(preg, buf, nmatch, pmatch, eflags | REG_STARTEND);\n}\n\n#ifndef DIR_HAS_BSD_GROUP_SEMANTICS\n# define FORCE_DIR_SET_GID S_ISGID\n#else\n# define FORCE_DIR_SET_GID 0\n#endif\n\n#ifdef NO_NSEC\n#undef USE_NSEC\n#define ST_CTIME_NSEC(st) 0\n#define ST_MTIME_NSEC(st) 0\n#else\n#ifdef USE_ST_TIMESPEC\n#define ST_CTIME_NSEC(st) ((unsigned int)((st).st_ctimespec.tv_nsec))\n#define ST_MTIME_NSEC(st) ((unsigned int)((st).st_mtimespec.tv_nsec))\n#else\n#define ST_CTIME_NSEC(st) ((unsigned int)((st).st_ctim.tv_nsec))\n#define ST_MTIME_NSEC(st) ((unsigned int)((st).st_mtim.tv_nsec))\n#endif\n#endif\n\n#ifdef UNRELIABLE_FSTAT\n#define fstat_is_reliable() 0\n#else\n#define fstat_is_reliable() 1\n#endif\n\n#ifndef va_copy\n/*\n * Since an obvious implementation of va_list would be to make it a\n * pointer into the stack frame, a simple assignment will work on\n * many systems.  But let's try to be more portable.\n */\n#ifdef __va_copy\n#define va_copy(dst, src) __va_copy(dst, src)\n#else\n#define va_copy(dst, src) ((dst) = (src))\n#endif\n#endif\n\n/*\n * This is always defined as a first step towards making the use of variadic\n * macros unconditional. If it causes compilation problems on your platform,\n * please report it to the Git mailing list at git@vger.kernel.org.\n */\n#define HAVE_VARIADIC_MACROS 1\n\n/* usage.c: only to be used for testing BUG() implementation (see test-tool) */\nextern int BUG_exit_code;\n\n#ifdef HAVE_VARIADIC_MACROS\n__attribute__((format (printf, 3, 4))) NORETURN\nvoid BUG_fl(const char *file, int line, const char *fmt, ...);\n#define BUG(...) BUG_fl(__FILE__, __LINE__, __VA_ARGS__)\n#else\n__attribute__((format (printf, 1, 2))) NORETURN\nvoid BUG(const char *fmt, ...);\n#endif\n\n#ifdef __APPLE__\n#define FSYNC_METHOD_DEFAULT FSYNC_METHOD_WRITEOUT_ONLY\n#else\n#define FSYNC_METHOD_DEFAULT FSYNC_METHOD_FSYNC\n#endif\n\nenum fsync_action {\n\tFSYNC_WRITEOUT_ONLY,\n\tFSYNC_HARDWARE_FLUSH\n};\n\n/*\n * Issues an fsync against the specified file according to the specified mode.\n *\n * FSYNC_WRITEOUT_ONLY attempts to use interfaces available on some operating\n * systems to flush the OS cache without issuing a flush command to the storage\n * controller. If those interfaces are unavailable, the function fails with\n * ENOSYS.\n *\n * FSYNC_HARDWARE_FLUSH does an OS writeout and hardware flush to ensure that\n * changes are durable. It is not expected to fail.\n */\nint git_fsync(int fd, enum fsync_action action);\n\n/*\n * Preserves errno, prints a message, but gives no warning for ENOENT.\n * Returns 0 on success, which includes trying to unlink an object that does\n * not exist.\n */\nint unlink_or_warn(const char *path);\n /*\n  * Tries to unlink file.  Returns 0 if unlink succeeded\n  * or the file already didn't exist.  Returns -1 and\n  * appends a message to err suitable for\n  * 'error(\"%s\", err->buf)' on error.\n  */\nint unlink_or_msg(const char *file, struct strbuf *err);\n/*\n * Preserves errno, prints a message, but gives no warning for ENOENT.\n * Returns 0 on success, which includes trying to remove a directory that does\n * not exist.\n */\nint rmdir_or_warn(const char *path);\n/*\n * Calls the correct function out of {unlink,rmdir}_or_warn based on\n * the supplied file mode.\n */\nint remove_or_warn(unsigned int mode, const char *path);\n\n/*\n * Call access(2), but warn for any error except \"missing file\"\n * (ENOENT or ENOTDIR).\n */\n#define ACCESS_EACCES_OK (1U << 0)\nint access_or_warn(const char *path, int mode, unsigned flag);\nint access_or_die(const char *path, int mode, unsigned flag);\n\n/* Warn on an inaccessible file if errno indicates this is an error */\nint warn_on_fopen_errors(const char *path);\n\n/*\n * Open with O_NOFOLLOW, or equivalent. Note that the fallback equivalent\n * may be racy. Do not use this as protection against an attacker who can\n * simultaneously create paths.\n */\nint open_nofollow(const char *path, int flags);\n\n#ifndef SHELL_PATH\n# define SHELL_PATH \"/bin/sh\"\n#endif\n\n#ifndef _POSIX_THREAD_SAFE_FUNCTIONS\nstatic inline void flockfile(FILE *fh)\n{\n\t; /* nothing */\n}\nstatic inline void funlockfile(FILE *fh)\n{\n\t; /* nothing */\n}\n#define getc_unlocked(fh) getc(fh)\n#endif\n\n#ifdef FILENO_IS_A_MACRO\nint git_fileno(FILE *stream);\n# ifndef COMPAT_CODE_FILENO\n#  undef fileno\n#  define fileno(p) git_fileno(p)\n# endif\n#endif\n\n#ifdef NEED_ACCESS_ROOT_HANDLER\nint git_access(const char *path, int mode);\n# ifndef COMPAT_CODE_ACCESS\n#  ifdef access\n#  undef access\n#  endif\n#  define access(path, mode) git_access(path, mode)\n# endif\n#endif\n\n/*\n * Our code often opens a path to an optional file, to work on its\n * contents when we can successfully open it.  We can ignore a failure\n * to open if such an optional file does not exist, but we do want to\n * report a failure in opening for other reasons (e.g. we got an I/O\n * error, or the file is there, but we lack the permission to open).\n *\n * Call this function after seeing an error from open() or fopen() to\n * see if the errno indicates a missing file that we can safely ignore.\n */\nstatic inline int is_missing_file_error(int errno_)\n{\n\treturn (errno_ == ENOENT || errno_ == ENOTDIR);\n}\n\nint cmd_main(int, const char **);\n\n/*\n * Intercept all calls to exit() and route them to trace2 to\n * optionally emit a message before calling the real exit().\n */\nint trace2_cmd_exit_fl(const char *file, int line, int code);\n#define exit(code) exit(trace2_cmd_exit_fl(__FILE__, __LINE__, (code)))\n\n/*\n * You can mark a stack variable with UNLEAK(var) to avoid it being\n * reported as a leak by tools like LSAN or valgrind. The argument\n * should generally be the variable itself (not its address and not what\n * it points to). It's safe to use this on pointers which may already\n * have been freed, or on pointers which may still be in use.\n *\n * Use this _only_ for a variable that leaks by going out of scope at\n * program exit (so only from cmd_* functions or their direct helpers).\n * Normal functions, especially those which may be called multiple\n * times, should actually free their memory. This is only meant as\n * an annotation, and does nothing in non-leak-checking builds.\n */\n#ifdef SUPPRESS_ANNOTATED_LEAKS\nvoid unleak_memory(const void *ptr, size_t len);\n#define UNLEAK(var) unleak_memory(&(var), sizeof(var))\n#else\n#define UNLEAK(var) do {} while (0)\n#endif\n\n#define z_const\n#include <zlib.h>\n\n#if ZLIB_VERNUM < 0x1290\n/*\n * This is uncompress2, which is only available in zlib >= 1.2.9\n * (released as of early 2017). See compat/zlib-uncompress2.c.\n */\nint uncompress2(Bytef *dest, uLongf *destLen, const Bytef *source,\n\t\tuLong *sourceLen);\n#endif\n\n/*\n * This include must come after system headers, since it introduces macros that\n * replace system names.\n */\n#include \"banned.h\"\n\n/*\n * container_of - Get the address of an object containing a field.\n *\n * @ptr: pointer to the field.\n * @type: type of the object.\n * @member: name of the field within the object.\n */\n#define container_of(ptr, type, member) \\\n\t((type *) ((char *)(ptr) - offsetof(type, member)))\n\n/*\n * helper function for `container_of_or_null' to avoid multiple\n * evaluation of @ptr\n */\nstatic inline void *container_of_or_null_offset(void *ptr, size_t offset)\n{\n\treturn ptr ? (char *)ptr - offset : NULL;\n}\n\n/*\n * like `container_of', but allows returned value to be NULL\n */\n#define container_of_or_null(ptr, type, member) \\\n\t(type *)container_of_or_null_offset(ptr, offsetof(type, member))\n\n/*\n * like offsetof(), but takes a pointer to a variable of type which\n * contains @member, instead of a specified type.\n * @ptr is subject to multiple evaluation since we can't rely on __typeof__\n * everywhere.\n */\n#if defined(__GNUC__) /* clang sets this, too */\n#define OFFSETOF_VAR(ptr, member) offsetof(__typeof__(*ptr), member)\n#else /* !__GNUC__ */\n#define OFFSETOF_VAR(ptr, member) \\\n\t((uintptr_t)&(ptr)->member - (uintptr_t)(ptr))\n#endif /* !__GNUC__ */\n\nvoid sleep_millisec(int millisec);\n\n/*\n * Generate len bytes from the system cryptographically secure PRNG.\n * Returns 0 on success and -1 on error, setting errno.  The inability to\n * satisfy the full request is an error.\n */\nint csprng_bytes(void *buf, size_t len);\n\n#endif\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00356476a9d1dc5ea49f1e3c8ca59015311f080a",
  "sha1_ok": true,
  "size": 40703
}
