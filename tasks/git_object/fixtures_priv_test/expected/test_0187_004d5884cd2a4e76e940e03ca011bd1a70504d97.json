{
  "content": {
    "base64": "IyEvYmluL3NoCgp0ZXN0X2Rlc2NyaXB0aW9uPSdwdWxsaW5nIGludG8gdm9pZCcKCi4gLi90ZXN0LWxpYi5zaAoKbW9kaWZ5ICgpIHsKCXNlZCAtZSAiJDEiICIkMiIgPiIkMi54IiAmJgoJbXYgIiQyLngiICIkMiIKfQoKdGVzdF9wdWxsX2F1dG9zdGFzaCAoKSB7CglnaXQgcmVzZXQgLS1oYXJkIGJlZm9yZS1yZWJhc2UgJiYKCWVjaG8gZGlydHkgPm5ld19maWxlICYmCglnaXQgYWRkIG5ld19maWxlICYmCglnaXQgcHVsbCAiJEAiIC4gY29weSAmJgoJdGVzdF9jbXBfcmV2IEhFQUReIGNvcHkgJiYKCXRlc3QgIiQoY2F0IG5ld19maWxlKSIgPSBkaXJ0eSAmJgoJdGVzdCAiJChjYXQgZmlsZSkiID0gIm1vZGlmaWVkIGFnYWluIgp9Cgp0ZXN0X3B1bGxfYXV0b3N0YXNoX2ZhaWwgKCkgewoJZ2l0IHJlc2V0IC0taGFyZCBiZWZvcmUtcmViYXNlICYmCgllY2hvIGRpcnR5ID5uZXdfZmlsZSAmJgoJZ2l0IGFkZCBuZXdfZmlsZSAmJgoJdGVzdF9tdXN0X2ZhaWwgZ2l0IHB1bGwgIiRAIiAuIGNvcHkgMj5lcnIgJiYKCXRlc3RfaTE4bmdyZXAgInVuY29tbWl0dGVkIGNoYW5nZXMuIiBlcnIKfQoKdGVzdF9leHBlY3Rfc3VjY2VzcyBzZXR1cCAnCgllY2hvIGZpbGUgPmZpbGUgJiYKCWdpdCBhZGQgZmlsZSAmJgoJZ2l0IGNvbW1pdCAtYSAtbSBvcmlnaW5hbAonCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICdwdWxsaW5nIGludG8gdm9pZCcgJwoJZ2l0IGluaXQgY2xvbmVkICYmCgkoCgkJY2QgY2xvbmVkICYmCgkJZ2l0IHB1bGwgLi4KCSkgJiYKCXRlc3RfcGF0aF9pc19maWxlIGZpbGUgJiYKCXRlc3RfcGF0aF9pc19maWxlIGNsb25lZC9maWxlICYmCgl0ZXN0X2NtcCBmaWxlIGNsb25lZC9maWxlCicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ3B1bGxpbmcgaW50byB2b2lkIHVzaW5nIG1hc3RlcjptYXN0ZXInICcKCWdpdCBpbml0IGNsb25lZC11aG8gJiYKCSgKCQljZCBjbG9uZWQtdWhvICYmCgkJZ2l0IHB1bGwgLi4gbWFzdGVyOm1hc3RlcgoJKSAmJgoJdGVzdF9wYXRoX2lzX2ZpbGUgZmlsZSAmJgoJdGVzdF9wYXRoX2lzX2ZpbGUgY2xvbmVkLXVoby9maWxlICYmCgl0ZXN0X2NtcCBmaWxlIGNsb25lZC11aG8vZmlsZQonCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICdwdWxsaW5nIGludG8gdm9pZCBkb2VzIG5vdCBvdmVyd3JpdGUgdW50cmFja2VkIGZpbGVzJyAnCglnaXQgaW5pdCBjbG9uZWQtdW50cmFja2VkICYmCgkoCgkJY2QgY2xvbmVkLXVudHJhY2tlZCAmJgoJCWVjaG8gdW50cmFja2VkID5maWxlICYmCgkJdGVzdF9tdXN0X2ZhaWwgZ2l0IHB1bGwgLi4gbWFzdGVyICYmCgkJZWNobyB1bnRyYWNrZWQgPmV4cGVjdCAmJgoJCXRlc3RfY21wIGV4cGVjdCBmaWxlCgkpCicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ3B1bGxpbmcgaW50byB2b2lkIGRvZXMgbm90IG92ZXJ3cml0ZSBzdGFnZWQgZmlsZXMnICcKCWdpdCBpbml0IGNsb25lZC1zdGFnZWQtY29sbGlkaW5nICYmCgkoCgkJY2QgY2xvbmVkLXN0YWdlZC1jb2xsaWRpbmcgJiYKCQllY2hvICJhbHRlcm5hdGUgY29udGVudCIgPmZpbGUgJiYKCQlnaXQgYWRkIGZpbGUgJiYKCQl0ZXN0X211c3RfZmFpbCBnaXQgcHVsbCAuLiBtYXN0ZXIgJiYKCQllY2hvICJhbHRlcm5hdGUgY29udGVudCIgPmV4cGVjdCAmJgoJCXRlc3RfY21wIGV4cGVjdCBmaWxlICYmCgkJZ2l0IGNhdC1maWxlIGJsb2IgOmZpbGUgPmZpbGUuaW5kZXggJiYKCQl0ZXN0X2NtcCBleHBlY3QgZmlsZS5pbmRleAoJKQonCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICdwdWxsaW5nIGludG8gdm9pZCBkb2VzIG5vdCByZW1vdmUgbmV3IHN0YWdlZCBmaWxlcycgJwoJZ2l0IGluaXQgY2xvbmVkLXN0YWdlZC1uZXcgJiYKCSgKCQljZCBjbG9uZWQtc3RhZ2VkLW5ldyAmJgoJCWVjaG8gIm5ldyB0cmFja2VkIGZpbGUiID5uZXdmaWxlICYmCgkJZ2l0IGFkZCBuZXdmaWxlICYmCgkJZ2l0IHB1bGwgLi4gbWFzdGVyICYmCgkJZWNobyAibmV3IHRyYWNrZWQgZmlsZSIgPmV4cGVjdCAmJgoJCXRlc3RfY21wIGV4cGVjdCBuZXdmaWxlICYmCgkJZ2l0IGNhdC1maWxlIGJsb2IgOm5ld2ZpbGUgPm5ld2ZpbGUuaW5kZXggJiYKCQl0ZXN0X2NtcCBleHBlY3QgbmV3ZmlsZS5pbmRleAoJKQonCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICdwdWxsaW5nIGludG8gdm9pZCBtdXN0IG5vdCBjcmVhdGUgYW4gb2N0b3B1cycgJwoJZ2l0IGluaXQgY2xvbmVkLW9jdG9wdXMgJiYKCSgKCQljZCBjbG9uZWQtb2N0b3B1cyAmJgoJCXRlc3RfbXVzdF9mYWlsIGdpdCBwdWxsIC4uIG1hc3RlciBtYXN0ZXIgJiYKCQl0ZXN0X3BhdGhfaXNfbWlzc2luZyBmaWxlCgkpCicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ3Rlc3QgLiBhcyBhIHJlbW90ZScgJwoJZ2l0IGJyYW5jaCBjb3B5IG1hc3RlciAmJgoJZ2l0IGNvbmZpZyBicmFuY2guY29weS5yZW1vdGUgLiAmJgoJZ2l0IGNvbmZpZyBicmFuY2guY29weS5tZXJnZSByZWZzL2hlYWRzL21hc3RlciAmJgoJZWNobyB1cGRhdGVkID5maWxlICYmCglnaXQgY29tbWl0IC1hIC1tIHVwZGF0ZWQgJiYKCWdpdCBjaGVja291dCBjb3B5ICYmCgl0ZXN0ICIkKGNhdCBmaWxlKSIgPSBmaWxlICYmCglnaXQgcHVsbCAmJgoJdGVzdCAiJChjYXQgZmlsZSkiID0gdXBkYXRlZCAmJgoJZ2l0IHJlZmxvZyAtMSA+cmVmbG9nLmFjdHVhbCAmJgoJc2VkICJzL15bMC05YS1mXVswLTlhLWZdKi9PQkpJRC8iIHJlZmxvZy5hY3R1YWwgPnJlZmxvZy5mdXp6eSAmJgoJZWNobyAiT0JKSUQgSEVBREB7MH06IHB1bGw6IEZhc3QtZm9yd2FyZCIgPnJlZmxvZy5leHBlY3RlZCAmJgoJdGVzdF9jbXAgcmVmbG9nLmV4cGVjdGVkIHJlZmxvZy5mdXp6eQonCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICd0aGUgZGVmYXVsdCByZW1vdGUgLiBzaG91bGQgbm90IGJyZWFrIGV4cGxpY2l0IHB1bGwnICcKCWdpdCBjaGVja291dCAtYiBzZWNvbmQgbWFzdGVyXiAmJgoJZWNobyBtb2RpZmllZCA+ZmlsZSAmJgoJZ2l0IGNvbW1pdCAtYSAtbSBtb2RpZmllZCAmJgoJZ2l0IGNoZWNrb3V0IGNvcHkgJiYKCWdpdCByZXNldCAtLWhhcmQgSEVBRF4gJiYKCXRlc3QgIiQoY2F0IGZpbGUpIiA9IGZpbGUgJiYKCWdpdCBwdWxsIC4gc2Vjb25kICYmCgl0ZXN0ICIkKGNhdCBmaWxlKSIgPSBtb2RpZmllZCAmJgoJZ2l0IHJlZmxvZyAtMSA+cmVmbG9nLmFjdHVhbCAmJgoJc2VkICJzL15bMC05YS1mXVswLTlhLWZdKi9PQkpJRC8iIHJlZmxvZy5hY3R1YWwgPnJlZmxvZy5mdXp6eSAmJgoJZWNobyAiT0JKSUQgSEVBREB7MH06IHB1bGwgLiBzZWNvbmQ6IEZhc3QtZm9yd2FyZCIgPnJlZmxvZy5leHBlY3RlZCAmJgoJdGVzdF9jbXAgcmVmbG9nLmV4cGVjdGVkIHJlZmxvZy5mdXp6eQonCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICdmYWlsIGlmIHdpbGRjYXJkIHNwZWMgZG9lcyBub3QgbWF0Y2ggYW55IHJlZnMnICcKCWdpdCBjaGVja291dCAtYiB0ZXN0IGNvcHleICYmCgl0ZXN0X3doZW5fZmluaXNoZWQgImdpdCBjaGVja291dCAtZiBjb3B5ICYmIGdpdCBicmFuY2ggLUQgdGVzdCIgJiYKCXRlc3QgIiQoY2F0IGZpbGUpIiA9IGZpbGUgJiYKCXRlc3RfbXVzdF9mYWlsIGdpdCBwdWxsIC4gInJlZnMvbm9uZXhpc3RpbmcxLyo6cmVmcy9ub25leGlzdGluZzIvKiIgMj5lcnIgJiYKCXRlc3RfaTE4bmdyZXAgIm5vIGNhbmRpZGF0ZXMgZm9yIG1lcmdpbmciIGVyciAmJgoJdGVzdCAiJChjYXQgZmlsZSkiID0gZmlsZQonCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICdmYWlsIGlmIG5vIGJyYW5jaGVzIHNwZWNpZmllZCB3aXRoIG5vbi1kZWZhdWx0IHJlbW90ZScgJwoJZ2l0IHJlbW90ZSBhZGQgdGVzdF9yZW1vdGUgLiAmJgoJdGVzdF93aGVuX2ZpbmlzaGVkICJnaXQgcmVtb3RlIHJlbW92ZSB0ZXN0X3JlbW90ZSIgJiYKCWdpdCBjaGVja291dCAtYiB0ZXN0IGNvcHleICYmCgl0ZXN0X3doZW5fZmluaXNoZWQgImdpdCBjaGVja291dCAtZiBjb3B5ICYmIGdpdCBicmFuY2ggLUQgdGVzdCIgJiYKCXRlc3QgIiQoY2F0IGZpbGUpIiA9IGZpbGUgJiYKCXRlc3RfY29uZmlnIGJyYW5jaC50ZXN0LnJlbW90ZSBvcmlnaW4gJiYKCXRlc3RfbXVzdF9mYWlsIGdpdCBwdWxsIHRlc3RfcmVtb3RlIDI+ZXJyICYmCgl0ZXN0X2kxOG5ncmVwICJzcGVjaWZ5IGEgYnJhbmNoIG9uIHRoZSBjb21tYW5kIGxpbmUiIGVyciAmJgoJdGVzdCAiJChjYXQgZmlsZSkiID0gZmlsZQonCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICdmYWlsIGlmIG5vdCBvbiBhIGJyYW5jaCcgJwoJZ2l0IHJlbW90ZSBhZGQgb3JpZ2luIC4gJiYKCXRlc3Rfd2hlbl9maW5pc2hlZCAiZ2l0IHJlbW90ZSByZW1vdmUgb3JpZ2luIiAmJgoJZ2l0IGNoZWNrb3V0IEhFQUReICYmCgl0ZXN0X3doZW5fZmluaXNoZWQgImdpdCBjaGVja291dCAtZiBjb3B5IiAmJgoJdGVzdCAiJChjYXQgZmlsZSkiID0gZmlsZSAmJgoJdGVzdF9tdXN0X2ZhaWwgZ2l0IHB1bGwgMj5lcnIgJiYKCXRlc3RfaTE4bmdyZXAgIm5vdCBjdXJyZW50bHkgb24gYSBicmFuY2giIGVyciAmJgoJdGVzdCAiJChjYXQgZmlsZSkiID0gZmlsZQonCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICdmYWlsIGlmIG5vIGNvbmZpZ3VyYXRpb24gZm9yIGN1cnJlbnQgYnJhbmNoJyAnCglnaXQgcmVtb3RlIGFkZCB0ZXN0X3JlbW90ZSAuICYmCgl0ZXN0X3doZW5fZmluaXNoZWQgImdpdCByZW1vdGUgcmVtb3ZlIHRlc3RfcmVtb3RlIiAmJgoJZ2l0IGNoZWNrb3V0IC1iIHRlc3QgY29weV4gJiYKCXRlc3Rfd2hlbl9maW5pc2hlZCAiZ2l0IGNoZWNrb3V0IC1mIGNvcHkgJiYgZ2l0IGJyYW5jaCAtRCB0ZXN0IiAmJgoJdGVzdF9jb25maWcgYnJhbmNoLnRlc3QucmVtb3RlIHRlc3RfcmVtb3RlICYmCgl0ZXN0ICIkKGNhdCBmaWxlKSIgPSBmaWxlICYmCgl0ZXN0X211c3RfZmFpbCBnaXQgcHVsbCAyPmVyciAmJgoJdGVzdF9pMThuZ3JlcCAibm8gdHJhY2tpbmcgaW5mb3JtYXRpb24iIGVyciAmJgoJdGVzdCAiJChjYXQgZmlsZSkiID0gZmlsZQonCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICdwdWxsIC0tYWxsOiBmYWlsIGlmIG5vIGNvbmZpZ3VyYXRpb24gZm9yIGN1cnJlbnQgYnJhbmNoJyAnCglnaXQgcmVtb3RlIGFkZCB0ZXN0X3JlbW90ZSAuICYmCgl0ZXN0X3doZW5fZmluaXNoZWQgImdpdCByZW1vdGUgcmVtb3ZlIHRlc3RfcmVtb3RlIiAmJgoJZ2l0IGNoZWNrb3V0IC1iIHRlc3QgY29weV4gJiYKCXRlc3Rfd2hlbl9maW5pc2hlZCAiZ2l0IGNoZWNrb3V0IC1mIGNvcHkgJiYgZ2l0IGJyYW5jaCAtRCB0ZXN0IiAmJgoJdGVzdF9jb25maWcgYnJhbmNoLnRlc3QucmVtb3RlIHRlc3RfcmVtb3RlICYmCgl0ZXN0ICIkKGNhdCBmaWxlKSIgPSBmaWxlICYmCgl0ZXN0X211c3RfZmFpbCBnaXQgcHVsbCAtLWFsbCAyPmVyciAmJgoJdGVzdF9pMThuZ3JlcCAiVGhlcmUgaXMgbm8gdHJhY2tpbmcgaW5mb3JtYXRpb24iIGVyciAmJgoJdGVzdCAiJChjYXQgZmlsZSkiID0gZmlsZQonCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICdmYWlsIGlmIHVwc3RyZWFtIGJyYW5jaCBkb2VzIG5vdCBleGlzdCcgJwoJZ2l0IGNoZWNrb3V0IC1iIHRlc3QgY29weV4gJiYKCXRlc3Rfd2hlbl9maW5pc2hlZCAiZ2l0IGNoZWNrb3V0IC1mIGNvcHkgJiYgZ2l0IGJyYW5jaCAtRCB0ZXN0IiAmJgoJdGVzdF9jb25maWcgYnJhbmNoLnRlc3QucmVtb3RlIC4gJiYKCXRlc3RfY29uZmlnIGJyYW5jaC50ZXN0Lm1lcmdlIHJlZnMvaGVhZHMvbm9uZXhpc3RpbmcgJiYKCXRlc3QgIiQoY2F0IGZpbGUpIiA9IGZpbGUgJiYKCXRlc3RfbXVzdF9mYWlsIGdpdCBwdWxsIDI+ZXJyICYmCgl0ZXN0X2kxOG5ncmVwICJubyBzdWNoIHJlZiB3YXMgZmV0Y2hlZCIgZXJyICYmCgl0ZXN0ICIkKGNhdCBmaWxlKSIgPSBmaWxlCicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ2ZhaWwgaWYgdGhlIGluZGV4IGhhcyB1bnJlc29sdmVkIGVudHJpZXMnICcKCWdpdCBjaGVja291dCAtYiB0aGlyZCBzZWNvbmReICYmCgl0ZXN0X3doZW5fZmluaXNoZWQgImdpdCBjaGVja291dCAtZiBjb3B5ICYmIGdpdCBicmFuY2ggLUQgdGhpcmQiICYmCgl0ZXN0ICIkKGNhdCBmaWxlKSIgPSBmaWxlICYmCgl0ZXN0X2NvbW1pdCBtb2RpZmllZDIgZmlsZSAmJgoJdGVzdCAteiAiJChnaXQgbHMtZmlsZXMgLXUpIiAmJgoJdGVzdF9tdXN0X2ZhaWwgZ2l0IHB1bGwgLiBzZWNvbmQgJiYKCXRlc3QgLW4gIiQoZ2l0IGxzLWZpbGVzIC11KSIgJiYKCWNwIGZpbGUgZXhwZWN0ZWQgJiYKCXRlc3RfbXVzdF9mYWlsIGdpdCBwdWxsIC4gc2Vjb25kIDI+ZXJyICYmCgl0ZXN0X2kxOG5ncmVwICJQdWxsaW5nIGlzIG5vdCBwb3NzaWJsZSBiZWNhdXNlIHlvdSBoYXZlIHVubWVyZ2VkIGZpbGVzLiIgZXJyICYmCgl0ZXN0X2NtcCBleHBlY3RlZCBmaWxlICYmCglnaXQgYWRkIGZpbGUgJiYKCXRlc3QgLXogIiQoZ2l0IGxzLWZpbGVzIC11KSIgJiYKCXRlc3RfbXVzdF9mYWlsIGdpdCBwdWxsIC4gc2Vjb25kIDI+ZXJyICYmCgl0ZXN0X2kxOG5ncmVwICJZb3UgaGF2ZSBub3QgY29uY2x1ZGVkIHlvdXIgbWVyZ2UiIGVyciAmJgoJdGVzdF9jbXAgZXhwZWN0ZWQgZmlsZQonCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICdmYXN0LWZvcndhcmRzIHdvcmtpbmcgdHJlZSBpZiBicmFuY2ggaGVhZCBpcyB1cGRhdGVkJyAnCglnaXQgY2hlY2tvdXQgLWIgdGhpcmQgc2Vjb25kXiAmJgoJdGVzdF93aGVuX2ZpbmlzaGVkICJnaXQgY2hlY2tvdXQgLWYgY29weSAmJiBnaXQgYnJhbmNoIC1EIHRoaXJkIiAmJgoJdGVzdCAiJChjYXQgZmlsZSkiID0gZmlsZSAmJgoJZ2l0IHB1bGwgLiBzZWNvbmQ6dGhpcmQgMj5lcnIgJiYKCXRlc3RfaTE4bmdyZXAgImZldGNoIHVwZGF0ZWQgdGhlIGN1cnJlbnQgYnJhbmNoIGhlYWQiIGVyciAmJgoJdGVzdCAiJChjYXQgZmlsZSkiID0gbW9kaWZpZWQgJiYKCXRlc3QgIiQoZ2l0IHJldi1wYXJzZSB0aGlyZCkiID0gIiQoZ2l0IHJldi1wYXJzZSBzZWNvbmQpIgonCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICdmYXN0LWZvcndhcmQgZmFpbHMgd2l0aCBjb25mbGljdGluZyB3b3JrIHRyZWUnICcKCWdpdCBjaGVja291dCAtYiB0aGlyZCBzZWNvbmReICYmCgl0ZXN0X3doZW5fZmluaXNoZWQgImdpdCBjaGVja291dCAtZiBjb3B5ICYmIGdpdCBicmFuY2ggLUQgdGhpcmQiICYmCgl0ZXN0ICIkKGNhdCBmaWxlKSIgPSBmaWxlICYmCgllY2hvIGNvbmZsaWN0ID5maWxlICYmCgl0ZXN0X211c3RfZmFpbCBnaXQgcHVsbCAuIHNlY29uZDp0aGlyZCAyPmVyciAmJgoJdGVzdF9pMThuZ3JlcCAiQ2Fubm90IGZhc3QtZm9yd2FyZCB5b3VyIHdvcmtpbmcgdHJlZSIgZXJyICYmCgl0ZXN0ICIkKGNhdCBmaWxlKSIgPSBjb25mbGljdCAmJgoJdGVzdCAiJChnaXQgcmV2LXBhcnNlIHRoaXJkKSIgPSAiJChnaXQgcmV2LXBhcnNlIHNlY29uZCkiCicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJy0tcmViYXNlJyAnCglnaXQgYnJhbmNoIHRvLXJlYmFzZSAmJgoJZWNobyBtb2RpZmllZCBhZ2FpbiA+IGZpbGUgJiYKCWdpdCBjb21taXQgLW0gZmlsZSBmaWxlICYmCglnaXQgY2hlY2tvdXQgdG8tcmViYXNlICYmCgllY2hvIG5ldyA+IGZpbGUyICYmCglnaXQgYWRkIGZpbGUyICYmCglnaXQgY29tbWl0IC1tICJuZXcgZmlsZSIgJiYKCWdpdCB0YWcgYmVmb3JlLXJlYmFzZSAmJgoJZ2l0IHB1bGwgLS1yZWJhc2UgLiBjb3B5ICYmCgl0ZXN0ICIkKGdpdCByZXYtcGFyc2UgSEVBRF4pIiA9ICIkKGdpdCByZXYtcGFyc2UgY29weSkiICYmCgl0ZXN0IG5ldyA9ICIkKGdpdCBzaG93IEhFQUQ6ZmlsZTIpIgonCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICctLXJlYmFzZSBmYXN0IGZvcndhcmQnICcKCWdpdCByZXNldCAtLWhhcmQgYmVmb3JlLXJlYmFzZSAmJgoJZ2l0IGNoZWNrb3V0IC1iIGZmICYmCgllY2hvIGFub3RoZXIgbW9kaWZpY2F0aW9uID5maWxlICYmCglnaXQgY29tbWl0IC1tIHRoaXJkIGZpbGUgJiYKCglnaXQgY2hlY2tvdXQgdG8tcmViYXNlICYmCglnaXQgcHVsbCAtLXJlYmFzZSAuIGZmICYmCgl0ZXN0ICIkKGdpdCByZXYtcGFyc2UgSEVBRCkiID0gIiQoZ2l0IHJldi1wYXJzZSBmZikiICYmCgoJIyBUaGUgYWJvdmUgb25seSB2YWxpZGF0ZXMgdGhlIHJlc3VsdC4gIERpZCB3ZSBhY3R1YWxseSBieXBhc3MgcmViYXNlPwoJZ2l0IHJlZmxvZyAtMSA+cmVmbG9nLmFjdHVhbCAmJgoJc2VkICJzL15bMC05YS1mXVswLTlhLWZdKi9PQkpJRC8iIHJlZmxvZy5hY3R1YWwgPnJlZmxvZy5mdXp6eSAmJgoJZWNobyAiT0JKSUQgSEVBREB7MH06IHB1bGwgLS1yZWJhc2UgLiBmZjogRmFzdC1mb3J3YXJkIiA+cmVmbG9nLmV4cGVjdGVkICYmCgl0ZXN0X2NtcCByZWZsb2cuZXhwZWN0ZWQgcmVmbG9nLmZ1enp5CicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJy0tcmViYXNlIC0tYXV0b3N0YXNoIGZhc3QgZm9yd2FyZCcgJwoJdGVzdF93aGVuX2ZpbmlzaGVkICIKCQlnaXQgcmVzZXQgLS1oYXJkCgkJZ2l0IGNoZWNrb3V0IHRvLXJlYmFzZQoJCWdpdCBicmFuY2ggLUQgdG8tcmViYXNlLWZmCgkJZ2l0IGJyYW5jaCAtRCBiZWhpbmQiICYmCglnaXQgYnJhbmNoIGJlaGluZCAmJgoJZ2l0IGNoZWNrb3V0IC1iIHRvLXJlYmFzZS1mZiAmJgoJZWNobyBhbm90aGVyIG1vZGlmaWNhdGlvbiA+PmZpbGUgJiYKCWdpdCBhZGQgZmlsZSAmJgoJZ2l0IGNvbW1pdCAtbSBtb2QgJiYKCglnaXQgY2hlY2tvdXQgYmVoaW5kICYmCgllY2hvIGRpcnR5ID5maWxlICYmCglnaXQgcHVsbCAtLXJlYmFzZSAtLWF1dG9zdGFzaCAuIHRvLXJlYmFzZS1mZiAmJgoJdGVzdCAiJChnaXQgcmV2LXBhcnNlIEhFQUQpIiA9ICIkKGdpdCByZXYtcGFyc2UgdG8tcmViYXNlLWZmKSIKJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyAnLS1yZWJhc2Ugd2l0aCBjb25mbGljdHMgc2hvd3MgYWR2aWNlJyAnCgl0ZXN0X3doZW5fZmluaXNoZWQgImdpdCByZWJhc2UgLS1hYm9ydDsgZ2l0IGNoZWNrb3V0IC1mIHRvLXJlYmFzZSIgJiYKCWdpdCBjaGVja291dCAtYiBzZXEgJiYKCXRlc3Rfc2VxIDUgPnNlcS50eHQgJiYKCWdpdCBhZGQgc2VxLnR4dCAmJgoJdGVzdF90aWNrICYmCglnaXQgY29tbWl0IC1tICJBZGQgc2VxLnR4dCIgJiYKCWVjaG8gNiA+PnNlcS50eHQgJiYKCXRlc3RfdGljayAmJgoJZ2l0IGNvbW1pdCAtbSAiQXBwZW5kIHRvIHNlcS50eHQiIHNlcS50eHQgJiYKCWdpdCBjaGVja291dCAtYiB3aXRoLWNvbmZsaWN0cyBIRUFEXiAmJgoJZWNobyBjb25mbGljdGluZyA+PnNlcS50eHQgJiYKCXRlc3RfdGljayAmJgoJZ2l0IGNvbW1pdCAtbSAiQ3JlYXRlIGNvbmZsaWN0IiBzZXEudHh0ICYmCgl0ZXN0X211c3RfZmFpbCBnaXQgcHVsbCAtLXJlYmFzZSAuIHNlcSAyPmVyciA+b3V0ICYmCgl0ZXN0X2kxOG5ncmVwICJSZXNvbHZlIGFsbCBjb25mbGljdHMgbWFudWFsbHkiIG91dAonCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICdmYWlsZWQgLS1yZWJhc2Ugc2hvd3MgYWR2aWNlJyAnCgl0ZXN0X3doZW5fZmluaXNoZWQgImdpdCByZWJhc2UgLS1hYm9ydDsgZ2l0IGNoZWNrb3V0IC1mIHRvLXJlYmFzZSIgJiYKCWdpdCBjaGVja291dCAtYiBkaXZlcmdpbmcgJiYKCXRlc3RfY29tbWl0IGF0dHJpYnV0ZXMgLmdpdGF0dHJpYnV0ZXMgIiogdGV4dD1hdXRvIiBhdHRycyAmJgoJc2hhMT0iJChwcmludGYgIjFcXHJcXG4iIHwgZ2l0IGhhc2gtb2JqZWN0IC13IC0tc3RkaW4pIiAmJgoJZ2l0IHVwZGF0ZS1pbmRleCAtLWNhY2hlaW5mbyAwNjQ0ICRzaGExIGZpbGUgJiYKCWdpdCBjb21taXQgLW0gdjEtd2l0aC1jciAmJgoJIyBmb3JjZSBjaGVja291dCBiZWNhdXNlIGBnaXQgcmVzZXQgLS1oYXJkYCB3aWxsIG5vdCBsZWF2ZSBjbGVhbiBgZmlsZWAKCWdpdCBjaGVja291dCAtZiAtYiBmYWlscy10by1yZWJhc2UgSEVBRF4gJiYKCXRlc3RfY29tbWl0IHYyLXdpdGhvdXQtY3IgZmlsZSAiMiIgZmlsZTItbGYgJiYKCXRlc3RfbXVzdF9mYWlsIGdpdCBwdWxsIC0tcmViYXNlIC4gZGl2ZXJnaW5nIDI+ZXJyID5vdXQgJiYKCXRlc3RfaTE4bmdyZXAgIlJlc29sdmUgYWxsIGNvbmZsaWN0cyBtYW51YWxseSIgb3V0CicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJy0tcmViYXNlIGZhaWxzIHdpdGggbXVsdGlwbGUgYnJhbmNoZXMnICcKCWdpdCByZXNldCAtLWhhcmQgYmVmb3JlLXJlYmFzZSAmJgoJdGVzdF9tdXN0X2ZhaWwgZ2l0IHB1bGwgLS1yZWJhc2UgLiBjb3B5IG1hc3RlciAyPmVyciAmJgoJdGVzdCAiJChnaXQgcmV2LXBhcnNlIEhFQUQpIiA9ICIkKGdpdCByZXYtcGFyc2UgYmVmb3JlLXJlYmFzZSkiICYmCgl0ZXN0X2kxOG5ncmVwICJDYW5ub3QgcmViYXNlIG9udG8gbXVsdGlwbGUgYnJhbmNoZXMiIGVyciAmJgoJdGVzdCBtb2RpZmllZCA9ICIkKGdpdCBzaG93IEhFQUQ6ZmlsZSkiCicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ3B1bGwgLS1yZWJhc2Ugc3VjY2VlZHMgd2l0aCBkaXJ0eSB3b3JraW5nIGRpcmVjdG9yeSBhbmQgcmViYXNlLmF1dG9zdGFzaCBzZXQnICcKCXRlc3RfY29uZmlnIHJlYmFzZS5hdXRvc3Rhc2ggdHJ1ZSAmJgoJdGVzdF9wdWxsX2F1dG9zdGFzaCAtLXJlYmFzZQonCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICdwdWxsIC0tcmViYXNlIC0tYXV0b3N0YXNoICYgcmViYXNlLmF1dG9zdGFzaD10cnVlJyAnCgl0ZXN0X2NvbmZpZyByZWJhc2UuYXV0b3N0YXNoIHRydWUgJiYKCXRlc3RfcHVsbF9hdXRvc3Rhc2ggLS1yZWJhc2UgLS1hdXRvc3Rhc2gKJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyAncHVsbCAtLXJlYmFzZSAtLWF1dG9zdGFzaCAmIHJlYmFzZS5hdXRvc3Rhc2g9ZmFsc2UnICcKCXRlc3RfY29uZmlnIHJlYmFzZS5hdXRvc3Rhc2ggZmFsc2UgJiYKCXRlc3RfcHVsbF9hdXRvc3Rhc2ggLS1yZWJhc2UgLS1hdXRvc3Rhc2gKJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyAncHVsbCAtLXJlYmFzZSAtLWF1dG9zdGFzaCAmIHJlYmFzZS5hdXRvc3Rhc2ggdW5zZXQnICcKCXRlc3RfdW5jb25maWcgcmViYXNlLmF1dG9zdGFzaCAmJgoJdGVzdF9wdWxsX2F1dG9zdGFzaCAtLXJlYmFzZSAtLWF1dG9zdGFzaAonCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICdwdWxsIC0tcmViYXNlIC0tbm8tYXV0b3N0YXNoICYgcmViYXNlLmF1dG9zdGFzaD10cnVlJyAnCgl0ZXN0X2NvbmZpZyByZWJhc2UuYXV0b3N0YXNoIHRydWUgJiYKCXRlc3RfcHVsbF9hdXRvc3Rhc2hfZmFpbCAtLXJlYmFzZSAtLW5vLWF1dG9zdGFzaAonCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICdwdWxsIC0tcmViYXNlIC0tbm8tYXV0b3N0YXNoICYgcmViYXNlLmF1dG9zdGFzaD1mYWxzZScgJwoJdGVzdF9jb25maWcgcmViYXNlLmF1dG9zdGFzaCBmYWxzZSAmJgoJdGVzdF9wdWxsX2F1dG9zdGFzaF9mYWlsIC0tcmViYXNlIC0tbm8tYXV0b3N0YXNoCicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ3B1bGwgLS1yZWJhc2UgLS1uby1hdXRvc3Rhc2ggJiByZWJhc2UuYXV0b3N0YXNoIHVuc2V0JyAnCgl0ZXN0X3VuY29uZmlnIHJlYmFzZS5hdXRvc3Rhc2ggJiYKCXRlc3RfcHVsbF9hdXRvc3Rhc2hfZmFpbCAtLXJlYmFzZSAtLW5vLWF1dG9zdGFzaAonCgpmb3IgaSBpbiAtLWF1dG9zdGFzaCAtLW5vLWF1dG9zdGFzaApkbwoJdGVzdF9leHBlY3Rfc3VjY2VzcyAicHVsbCAkaSAod2l0aG91dCAtLXJlYmFzZSkgaXMgaWxsZWdhbCIgJwoJCXRlc3RfbXVzdF9mYWlsIGdpdCBwdWxsICRpIC4gY29weSAyPmVyciAmJgoJCXRlc3RfaTE4bmdyZXAgIm9ubHkgdmFsaWQgd2l0aCAtLXJlYmFzZSIgZXJyCgknCmRvbmUKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ3B1bGwucmViYXNlJyAnCglnaXQgcmVzZXQgLS1oYXJkIGJlZm9yZS1yZWJhc2UgJiYKCXRlc3RfY29uZmlnIHB1bGwucmViYXNlIHRydWUgJiYKCWdpdCBwdWxsIC4gY29weSAmJgoJdGVzdCAiJChnaXQgcmV2LXBhcnNlIEhFQUReKSIgPSAiJChnaXQgcmV2LXBhcnNlIGNvcHkpIiAmJgoJdGVzdCBuZXcgPSAiJChnaXQgc2hvdyBIRUFEOmZpbGUyKSIKJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyAncHVsbCAtLWF1dG9zdGFzaCAmIHB1bGwucmViYXNlPXRydWUnICcKCXRlc3RfY29uZmlnIHB1bGwucmViYXNlIHRydWUgJiYKCXRlc3RfcHVsbF9hdXRvc3Rhc2ggLS1hdXRvc3Rhc2gKJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyAncHVsbCAtLW5vLWF1dG9zdGFzaCAmIHB1bGwucmViYXNlPXRydWUnICcKCXRlc3RfY29uZmlnIHB1bGwucmViYXNlIHRydWUgJiYKCXRlc3RfcHVsbF9hdXRvc3Rhc2hfZmFpbCAtLW5vLWF1dG9zdGFzaAonCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICdicmFuY2gudG8tcmViYXNlLnJlYmFzZScgJwoJZ2l0IHJlc2V0IC0taGFyZCBiZWZvcmUtcmViYXNlICYmCgl0ZXN0X2NvbmZpZyBicmFuY2gudG8tcmViYXNlLnJlYmFzZSB0cnVlICYmCglnaXQgcHVsbCAuIGNvcHkgJiYKCXRlc3QgIiQoZ2l0IHJldi1wYXJzZSBIRUFEXikiID0gIiQoZ2l0IHJldi1wYXJzZSBjb3B5KSIgJiYKCXRlc3QgbmV3ID0gIiQoZ2l0IHNob3cgSEVBRDpmaWxlMikiCicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ2JyYW5jaC50by1yZWJhc2UucmViYXNlIHNob3VsZCBvdmVycmlkZSBwdWxsLnJlYmFzZScgJwoJZ2l0IHJlc2V0IC0taGFyZCBiZWZvcmUtcmViYXNlICYmCgl0ZXN0X2NvbmZpZyBwdWxsLnJlYmFzZSB0cnVlICYmCgl0ZXN0X2NvbmZpZyBicmFuY2gudG8tcmViYXNlLnJlYmFzZSBmYWxzZSAmJgoJZ2l0IHB1bGwgLiBjb3B5ICYmCgl0ZXN0ICIkKGdpdCByZXYtcGFyc2UgSEVBRF4pIiAhPSAiJChnaXQgcmV2LXBhcnNlIGNvcHkpIiAmJgoJdGVzdCBuZXcgPSAiJChnaXQgc2hvdyBIRUFEOmZpbGUyKSIKJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyAncHVsbCAtLXJlYmFzZSB3YXJucyBvbiAtLXZlcmlmeS1zaWduYXR1cmVzJyAnCglnaXQgcmVzZXQgLS1oYXJkIGJlZm9yZS1yZWJhc2UgJiYKCWdpdCBwdWxsIC0tcmViYXNlIC0tdmVyaWZ5LXNpZ25hdHVyZXMgLiBjb3B5IDI+ZXJyICYmCgl0ZXN0ICIkKGdpdCByZXYtcGFyc2UgSEVBRF4pIiA9ICIkKGdpdCByZXYtcGFyc2UgY29weSkiICYmCgl0ZXN0IG5ldyA9ICIkKGdpdCBzaG93IEhFQUQ6ZmlsZTIpIiAmJgoJdGVzdF9pMThuZ3JlcCAiaWdub3JpbmcgLS12ZXJpZnktc2lnbmF0dXJlcyBmb3IgcmViYXNlIiBlcnIKJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyAncHVsbCAtLXJlYmFzZSBkb2VzIG5vdCB3YXJuIG9uIC0tbm8tdmVyaWZ5LXNpZ25hdHVyZXMnICcKCWdpdCByZXNldCAtLWhhcmQgYmVmb3JlLXJlYmFzZSAmJgoJZ2l0IHB1bGwgLS1yZWJhc2UgLS1uby12ZXJpZnktc2lnbmF0dXJlcyAuIGNvcHkgMj5lcnIgJiYKCXRlc3QgIiQoZ2l0IHJldi1wYXJzZSBIRUFEXikiID0gIiQoZ2l0IHJldi1wYXJzZSBjb3B5KSIgJiYKCXRlc3QgbmV3ID0gIiQoZ2l0IHNob3cgSEVBRDpmaWxlMikiICYmCgl0ZXN0X2kxOG5ncmVwICEgInZlcmlmeS1zaWduYXR1cmVzIiBlcnIKJwoKIyBhZGQgYSBmZWF0dXJlIGJyYW5jaCwga2VlcC1tZXJnZSwgdGhhdCBpcyBtZXJnZWQgaW50byBtYXN0ZXIsIHNvIHRoZQojIHRlc3QgY2FuIHRyeSBwcmVzZXJ2aW5nIHRoZSBtZXJnZSBjb21taXQgKG9yIG5vdCkgd2l0aCB2YXJpb3VzCiMgLS1yZWJhc2UgZmxhZ3MvcHVsbC5yZWJhc2Ugc2V0dGluZ3MuCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ3ByZXNlcnZlIG1lcmdlIHNldHVwJyAnCglnaXQgcmVzZXQgLS1oYXJkIGJlZm9yZS1yZWJhc2UgJiYKCWdpdCBjaGVja291dCAtYiBrZWVwLW1lcmdlIHNlY29uZF4gJiYKCXRlc3RfY29tbWl0IGZpbGUzICYmCglnaXQgY2hlY2tvdXQgdG8tcmViYXNlICYmCglnaXQgbWVyZ2Uga2VlcC1tZXJnZSAmJgoJZ2l0IHRhZyBiZWZvcmUtcHJlc2VydmUtcmViYXNlCicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ3B1bGwucmViYXNlPWZhbHNlIGNyZWF0ZSBhIG5ldyBtZXJnZSBjb21taXQnICcKCWdpdCByZXNldCAtLWhhcmQgYmVmb3JlLXByZXNlcnZlLXJlYmFzZSAmJgoJdGVzdF9jb25maWcgcHVsbC5yZWJhc2UgZmFsc2UgJiYKCWdpdCBwdWxsIC4gY29weSAmJgoJdGVzdCAiJChnaXQgcmV2LXBhcnNlIEhFQUReMSkiID0gIiQoZ2l0IHJldi1wYXJzZSBiZWZvcmUtcHJlc2VydmUtcmViYXNlKSIgJiYKCXRlc3QgIiQoZ2l0IHJldi1wYXJzZSBIRUFEXjIpIiA9ICIkKGdpdCByZXYtcGFyc2UgY29weSkiICYmCgl0ZXN0IGZpbGUzID0gIiQoZ2l0IHNob3cgSEVBRDpmaWxlMy50KSIKJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyAncHVsbC5yZWJhc2U9dHJ1ZSBmbGF0dGVucyBrZWVwLW1lcmdlJyAnCglnaXQgcmVzZXQgLS1oYXJkIGJlZm9yZS1wcmVzZXJ2ZS1yZWJhc2UgJiYKCXRlc3RfY29uZmlnIHB1bGwucmViYXNlIHRydWUgJiYKCWdpdCBwdWxsIC4gY29weSAmJgoJdGVzdCAiJChnaXQgcmV2LXBhcnNlIEhFQUReXikiID0gIiQoZ2l0IHJldi1wYXJzZSBjb3B5KSIgJiYKCXRlc3QgZmlsZTMgPSAiJChnaXQgc2hvdyBIRUFEOmZpbGUzLnQpIgonCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICdwdWxsLnJlYmFzZT0xIGlzIHRyZWF0ZWQgYXMgdHJ1ZSBhbmQgZmxhdHRlbnMga2VlcC1tZXJnZScgJwoJZ2l0IHJlc2V0IC0taGFyZCBiZWZvcmUtcHJlc2VydmUtcmViYXNlICYmCgl0ZXN0X2NvbmZpZyBwdWxsLnJlYmFzZSAxICYmCglnaXQgcHVsbCAuIGNvcHkgJiYKCXRlc3QgIiQoZ2l0IHJldi1wYXJzZSBIRUFEXl4pIiA9ICIkKGdpdCByZXYtcGFyc2UgY29weSkiICYmCgl0ZXN0IGZpbGUzID0gIiQoZ2l0IHNob3cgSEVBRDpmaWxlMy50KSIKJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyBSRUJBU0VfUCBcCgkncHVsbC5yZWJhc2U9cHJlc2VydmUgcmViYXNlcyBhbmQgbWVyZ2VzIGtlZXAtbWVyZ2UnICcKCWdpdCByZXNldCAtLWhhcmQgYmVmb3JlLXByZXNlcnZlLXJlYmFzZSAmJgoJdGVzdF9jb25maWcgcHVsbC5yZWJhc2UgcHJlc2VydmUgJiYKCWdpdCBwdWxsIC4gY29weSAmJgoJdGVzdCAiJChnaXQgcmV2LXBhcnNlIEhFQUReXikiID0gIiQoZ2l0IHJldi1wYXJzZSBjb3B5KSIgJiYKCXRlc3QgIiQoZ2l0IHJldi1wYXJzZSBIRUFEXjIpIiA9ICIkKGdpdCByZXYtcGFyc2Uga2VlcC1tZXJnZSkiCicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ3B1bGwucmViYXNlPWludGVyYWN0aXZlJyAnCgl3cml0ZV9zY3JpcHQgIiRUUkFTSF9ESVJFQ1RPUlkvZmFrZS1lZGl0b3IiIDw8LVxFT0YgJiYKCWVjaG8gSSB3YXMgaGVyZSA+ZmFrZS5vdXQgJiYKCWZhbHNlCglFT0YKCXRlc3Rfc2V0X2VkaXRvciAiJFRSQVNIX0RJUkVDVE9SWS9mYWtlLWVkaXRvciIgJiYKCXRlc3Rfd2hlbl9maW5pc2hlZCAidGVzdF9taWdodF9mYWlsIGdpdCByZWJhc2UgLS1hYm9ydCIgJiYKCXRlc3RfbXVzdF9mYWlsIGdpdCBwdWxsIC0tcmViYXNlPWludGVyYWN0aXZlIC4gY29weSAmJgoJdGVzdCAiSSB3YXMgaGVyZSIgPSAiJChjYXQgZmFrZS5vdXQpIgonCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICdwdWxsIC0tcmViYXNlPWknICcKCXdyaXRlX3NjcmlwdCAiJFRSQVNIX0RJUkVDVE9SWS9mYWtlLWVkaXRvciIgPDwtXEVPRiAmJgoJZWNobyBJIHdhcyBoZXJlLCB0b28gPmZha2Uub3V0ICYmCglmYWxzZQoJRU9GCgl0ZXN0X3NldF9lZGl0b3IgIiRUUkFTSF9ESVJFQ1RPUlkvZmFrZS1lZGl0b3IiICYmCgl0ZXN0X3doZW5fZmluaXNoZWQgInRlc3RfbWlnaHRfZmFpbCBnaXQgcmViYXNlIC0tYWJvcnQiICYmCgl0ZXN0X211c3RfZmFpbCBnaXQgcHVsbCAtLXJlYmFzZT1pIC4gY29weSAmJgoJdGVzdCAiSSB3YXMgaGVyZSwgdG9vIiA9ICIkKGNhdCBmYWtlLm91dCkiCicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ3B1bGwucmViYXNlPWludmFsaWQgZmFpbHMnICcKCWdpdCByZXNldCAtLWhhcmQgYmVmb3JlLXByZXNlcnZlLXJlYmFzZSAmJgoJdGVzdF9jb25maWcgcHVsbC5yZWJhc2UgaW52YWxpZCAmJgoJISBnaXQgcHVsbCAuIGNvcHkKJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyAnLS1yZWJhc2U9ZmFsc2UgY3JlYXRlIGEgbmV3IG1lcmdlIGNvbW1pdCcgJwoJZ2l0IHJlc2V0IC0taGFyZCBiZWZvcmUtcHJlc2VydmUtcmViYXNlICYmCgl0ZXN0X2NvbmZpZyBwdWxsLnJlYmFzZSB0cnVlICYmCglnaXQgcHVsbCAtLXJlYmFzZT1mYWxzZSAuIGNvcHkgJiYKCXRlc3QgIiQoZ2l0IHJldi1wYXJzZSBIRUFEXjEpIiA9ICIkKGdpdCByZXYtcGFyc2UgYmVmb3JlLXByZXNlcnZlLXJlYmFzZSkiICYmCgl0ZXN0ICIkKGdpdCByZXYtcGFyc2UgSEVBRF4yKSIgPSAiJChnaXQgcmV2LXBhcnNlIGNvcHkpIiAmJgoJdGVzdCBmaWxlMyA9ICIkKGdpdCBzaG93IEhFQUQ6ZmlsZTMudCkiCicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJy0tcmViYXNlPXRydWUgcmViYXNlcyBhbmQgZmxhdHRlbnMga2VlcC1tZXJnZScgJwoJZ2l0IHJlc2V0IC0taGFyZCBiZWZvcmUtcHJlc2VydmUtcmViYXNlICYmCgl0ZXN0X2NvbmZpZyBwdWxsLnJlYmFzZSBwcmVzZXJ2ZSAmJgoJZ2l0IHB1bGwgLS1yZWJhc2U9dHJ1ZSAuIGNvcHkgJiYKCXRlc3QgIiQoZ2l0IHJldi1wYXJzZSBIRUFEXl4pIiA9ICIkKGdpdCByZXYtcGFyc2UgY29weSkiICYmCgl0ZXN0IGZpbGUzID0gIiQoZ2l0IHNob3cgSEVBRDpmaWxlMy50KSIKJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyBSRUJBU0VfUCBcCgknLS1yZWJhc2U9cHJlc2VydmUgcmViYXNlcyBhbmQgbWVyZ2VzIGtlZXAtbWVyZ2UnICcKCWdpdCByZXNldCAtLWhhcmQgYmVmb3JlLXByZXNlcnZlLXJlYmFzZSAmJgoJdGVzdF9jb25maWcgcHVsbC5yZWJhc2UgdHJ1ZSAmJgoJZ2l0IHB1bGwgLS1yZWJhc2U9cHJlc2VydmUgLiBjb3B5ICYmCgl0ZXN0ICIkKGdpdCByZXYtcGFyc2UgSEVBRF5eKSIgPSAiJChnaXQgcmV2LXBhcnNlIGNvcHkpIiAmJgoJdGVzdCAiJChnaXQgcmV2LXBhcnNlIEhFQUReMikiID0gIiQoZ2l0IHJldi1wYXJzZSBrZWVwLW1lcmdlKSIKJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyAnLS1yZWJhc2U9aW52YWxpZCBmYWlscycgJwoJZ2l0IHJlc2V0IC0taGFyZCBiZWZvcmUtcHJlc2VydmUtcmViYXNlICYmCgkhIGdpdCBwdWxsIC0tcmViYXNlPWludmFsaWQgLiBjb3B5CicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJy0tcmViYXNlIG92ZXJyaWRlcyBwdWxsLnJlYmFzZT1wcmVzZXJ2ZSBhbmQgZmxhdHRlbnMga2VlcC1tZXJnZScgJwoJZ2l0IHJlc2V0IC0taGFyZCBiZWZvcmUtcHJlc2VydmUtcmViYXNlICYmCgl0ZXN0X2NvbmZpZyBwdWxsLnJlYmFzZSBwcmVzZXJ2ZSAmJgoJZ2l0IHB1bGwgLS1yZWJhc2UgLiBjb3B5ICYmCgl0ZXN0ICIkKGdpdCByZXYtcGFyc2UgSEVBRF5eKSIgPSAiJChnaXQgcmV2LXBhcnNlIGNvcHkpIiAmJgoJdGVzdCBmaWxlMyA9ICIkKGdpdCBzaG93IEhFQUQ6ZmlsZTMudCkiCicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJy0tcmViYXNlIHdpdGggcmViYXNlZCB1cHN0cmVhbScgJwoJZ2l0IHJlbW90ZSBhZGQgLWYgbWUgLiAmJgoJZ2l0IGNoZWNrb3V0IGNvcHkgJiYKCWdpdCB0YWcgY29weS1vcmlnICYmCglnaXQgcmVzZXQgLS1oYXJkIEhFQUReICYmCgllY2hvIGNvbmZsaWN0aW5nIG1vZGlmaWNhdGlvbiA+IGZpbGUgJiYKCWdpdCBjb21taXQgLW0gY29uZmxpY3QgZmlsZSAmJgoJZ2l0IGNoZWNrb3V0IHRvLXJlYmFzZSAmJgoJZWNobyBmaWxlID4gZmlsZTIgJiYKCWdpdCBjb21taXQgLW0gdG8tcmViYXNlIGZpbGUyICYmCglnaXQgdGFnIHRvLXJlYmFzZS1vcmlnICYmCglnaXQgcHVsbCAtLXJlYmFzZSBtZSBjb3B5ICYmCgl0ZXN0ICJjb25mbGljdGluZyBtb2RpZmljYXRpb24iID0gIiQoY2F0IGZpbGUpIiAmJgoJdGVzdCBmaWxlID0gIiQoY2F0IGZpbGUyKSIKJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyAnLS1yZWJhc2UgLWYgd2l0aCByZWJhc2VkIHVwc3RyZWFtJyAnCgl0ZXN0X3doZW5fZmluaXNoZWQgInRlc3RfbWlnaHRfZmFpbCBnaXQgcmViYXNlIC0tYWJvcnQiICYmCglnaXQgcmVzZXQgLS1oYXJkIHRvLXJlYmFzZS1vcmlnICYmCglnaXQgcHVsbCAtLXJlYmFzZSAtZiBtZSBjb3B5ICYmCgl0ZXN0ICJjb25mbGljdGluZyBtb2RpZmljYXRpb24iID0gIiQoY2F0IGZpbGUpIiAmJgoJdGVzdCBmaWxlID0gIiQoY2F0IGZpbGUyKSIKJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyAnLS1yZWJhc2Ugd2l0aCByZWJhc2VkIGRlZmF1bHQgdXBzdHJlYW0nICcKCWdpdCB1cGRhdGUtcmVmIHJlZnMvcmVtb3Rlcy9tZS9jb3B5IGNvcHktb3JpZyAmJgoJZ2l0IGNoZWNrb3V0IC0tdHJhY2sgLWIgdG8tcmViYXNlMiBtZS9jb3B5ICYmCglnaXQgcmVzZXQgLS1oYXJkIHRvLXJlYmFzZS1vcmlnICYmCglnaXQgcHVsbCAtLXJlYmFzZSAmJgoJdGVzdCAiY29uZmxpY3RpbmcgbW9kaWZpY2F0aW9uIiA9ICIkKGNhdCBmaWxlKSIgJiYKCXRlc3QgZmlsZSA9ICIkKGNhdCBmaWxlMikiCicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ3JlYmFzZWQgdXBzdHJlYW0gKyBmZXRjaCArIHB1bGwgLS1yZWJhc2UnICcKCglnaXQgdXBkYXRlLXJlZiByZWZzL3JlbW90ZXMvbWUvY29weSBjb3B5LW9yaWcgJiYKCWdpdCByZXNldCAtLWhhcmQgdG8tcmViYXNlLW9yaWcgJiYKCWdpdCBjaGVja291dCAtLXRyYWNrIC1iIHRvLXJlYmFzZTMgbWUvY29weSAmJgoJZ2l0IHJlc2V0IC0taGFyZCB0by1yZWJhc2Utb3JpZyAmJgoJZ2l0IGZldGNoICYmCglnaXQgcHVsbCAtLXJlYmFzZSAmJgoJdGVzdCAiY29uZmxpY3RpbmcgbW9kaWZpY2F0aW9uIiA9ICIkKGNhdCBmaWxlKSIgJiYKCXRlc3QgZmlsZSA9ICIkKGNhdCBmaWxlMikiCgonCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICdwdWxsIC0tcmViYXNlIGRpZXMgZWFybHkgd2l0aCBkaXJ0eSB3b3JraW5nIGRpcmVjdG9yeScgJwoJZ2l0IGNoZWNrb3V0IHRvLXJlYmFzZSAmJgoJZ2l0IHVwZGF0ZS1yZWYgcmVmcy9yZW1vdGVzL21lL2NvcHkgY29weV4gJiYKCUNPUFk9IiQoZ2l0IHJldi1wYXJzZSAtLXZlcmlmeSBtZS9jb3B5KSIgJiYKCWdpdCByZWJhc2UgLS1vbnRvICRDT1BZIGNvcHkgJiYKCXRlc3RfY29uZmlnIGJyYW5jaC50by1yZWJhc2UucmVtb3RlIG1lICYmCgl0ZXN0X2NvbmZpZyBicmFuY2gudG8tcmViYXNlLm1lcmdlIHJlZnMvaGVhZHMvY29weSAmJgoJdGVzdF9jb25maWcgYnJhbmNoLnRvLXJlYmFzZS5yZWJhc2UgdHJ1ZSAmJgoJZWNobyBkaXJ0eSA+PiBmaWxlICYmCglnaXQgYWRkIGZpbGUgJiYKCXRlc3RfbXVzdF9mYWlsIGdpdCBwdWxsICYmCgl0ZXN0ICIkQ09QWSIgPSAiJChnaXQgcmV2LXBhcnNlIC0tdmVyaWZ5IG1lL2NvcHkpIiAmJgoJZ2l0IGNoZWNrb3V0IEhFQUQgLS0gZmlsZSAmJgoJZ2l0IHB1bGwgJiYKCXRlc3QgIiRDT1BZIiAhPSAiJChnaXQgcmV2LXBhcnNlIC0tdmVyaWZ5IG1lL2NvcHkpIgonCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICdwdWxsIC0tcmViYXNlIHdvcmtzIG9uIGJyYW5jaCB5ZXQgdG8gYmUgYm9ybicgJwoJZ2l0IHJldi1wYXJzZSBtYXN0ZXIgPmV4cGVjdCAmJgoJbWtkaXIgZW1wdHlfcmVwbyAmJgoJKAoJCWNkIGVtcHR5X3JlcG8gJiYKCQlnaXQgaW5pdCAmJgoJCWdpdCBwdWxsIC0tcmViYXNlIC4uIG1hc3RlciAmJgoJCWdpdCByZXYtcGFyc2UgSEVBRCA+Li4vYWN0dWFsCgkpICYmCgl0ZXN0X2NtcCBleHBlY3QgYWN0dWFsCicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ3B1bGwgLS1yZWJhc2UgZmFpbHMgb24gdW5ib3JuIGJyYW5jaCB3aXRoIHN0YWdlZCBjaGFuZ2VzJyAnCgl0ZXN0X3doZW5fZmluaXNoZWQgInJtIC1yZiBlbXB0eV9yZXBvMiIgJiYKCWdpdCBpbml0IGVtcHR5X3JlcG8yICYmCgkoCgkJY2QgZW1wdHlfcmVwbzIgJiYKCQllY2hvIHN0YWdlZC1maWxlID5zdGFnZWQtZmlsZSAmJgoJCWdpdCBhZGQgc3RhZ2VkLWZpbGUgJiYKCQl0ZXN0ICIkKGdpdCBscy1maWxlcykiID0gc3RhZ2VkLWZpbGUgJiYKCQl0ZXN0X211c3RfZmFpbCBnaXQgcHVsbCAtLXJlYmFzZSAuLiBtYXN0ZXIgMj5lcnIgJiYKCQl0ZXN0ICIkKGdpdCBscy1maWxlcykiID0gc3RhZ2VkLWZpbGUgJiYKCQl0ZXN0ICIkKGdpdCBzaG93IDpzdGFnZWQtZmlsZSkiID0gc3RhZ2VkLWZpbGUgJiYKCQl0ZXN0X2kxOG5ncmVwICJ1bmJvcm4gYnJhbmNoIHdpdGggY2hhbmdlcyBhZGRlZCB0byB0aGUgaW5kZXgiIGVycgoJKQonCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICdwdWxsIC0tcmViYXNlIGZhaWxzIG9uIGNvcnJ1cHQgSEVBRCcgJwoJdGVzdF93aGVuX2ZpbmlzaGVkICJybSAtcmYgY29ycnVwdCIgJiYKCWdpdCBpbml0IGNvcnJ1cHQgJiYKCSgKCQljZCBjb3JydXB0ICYmCgkJdGVzdF9jb21taXQgb25lICYmCgkJb2JqPSQoZ2l0IHJldi1wYXJzZSAtLXZlcmlmeSBIRUFEIHwgc2VkICJzI14uLiMmLyMiKSAmJgoJCXJtIC1mIC5naXQvb2JqZWN0cy8kb2JqICYmCgkJdGVzdF9tdXN0X2ZhaWwgZ2l0IHB1bGwgLS1yZWJhc2UKCSkKJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyAnc2V0dXAgZm9yIGRldGVjdGluZyB1cHN0cmVhbWVkIGNoYW5nZXMnICcKCW1rZGlyIHNyYyAmJgoJKAoJCWNkIHNyYyAmJgoJCWdpdCBpbml0ICYmCgkJcHJpbnRmICIxXG4yXG4zXG40XG41XG42XG43XG44XG45XG4xMFxuIiA+IHN0dWZmICYmCgkJZ2l0IGFkZCBzdHVmZiAmJgoJCWdpdCBjb21taXQgLW0gIkluaXRpYWwgcmV2aXNpb24iCgkpICYmCglnaXQgY2xvbmUgc3JjIGRzdCAmJgoJKAoJCWNkIHNyYyAmJgoJCW1vZGlmeSBzLzUvNDMvIHN0dWZmICYmCgkJZ2l0IGNvbW1pdCAtYSAtbSAiNS0+NDMiICYmCgkJbW9kaWZ5IHMvNi80Mi8gc3R1ZmYgJiYKCQlnaXQgY29tbWl0IC1hIC1tICJNYWtlIGl0IGJpZ2dlciIKCSkgJiYKCSgKCQljZCBkc3QgJiYKCQltb2RpZnkgcy81LzQzLyBzdHVmZiAmJgoJCWdpdCBjb21taXQgLWEgLW0gIkluZGVwZW5kZW50IGRpc2NvdmVyeSBvZiA1LT40MyIKCSkKJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyAnZ2l0IHB1bGwgLS1yZWJhc2UgZGV0ZWN0cyB1cHN0cmVhbWVkIGNoYW5nZXMnICcKCSgKCQljZCBkc3QgJiYKCQlnaXQgcHVsbCAtLXJlYmFzZSAmJgoJCXRlc3QgLXogIiQoZ2l0IGxzLWZpbGVzIC11KSIKCSkKJwoKdGVzdF9leHBlY3Rfc3VjY2VzcyAnc2V0dXAgZm9yIGF2b2lkaW5nIHJlYXBwbHlpbmcgb2xkIHBhdGNoZXMnICcKCSgKCQljZCBkc3QgJiYKCQl0ZXN0X21pZ2h0X2ZhaWwgZ2l0IHJlYmFzZSAtLWFib3J0ICYmCgkJZ2l0IHJlc2V0IC0taGFyZCBvcmlnaW4vbWFzdGVyCgkpICYmCglnaXQgY2xvbmUgLS1iYXJlIHNyYyBzcmMtcmVwbGFjZS5naXQgJiYKCXJtIC1yZiBzcmMgJiYKCW12IHNyYy1yZXBsYWNlLmdpdCBzcmMgJiYKCSgKCQljZCBkc3QgJiYKCQltb2RpZnkgcy8yLzIyLyBzdHVmZiAmJgoJCWdpdCBjb21taXQgLWEgLW0gIkNoYW5nZSAyIiAmJgoJCW1vZGlmeSBzLzMvMzMvIHN0dWZmICYmCgkJZ2l0IGNvbW1pdCAtYSAtbSAiQ2hhbmdlIDMiICYmCgkJbW9kaWZ5IHMvNC80NC8gc3R1ZmYgJiYKCQlnaXQgY29tbWl0IC1hIC1tICJDaGFuZ2UgNCIgJiYKCQlnaXQgcHVzaCAmJgoKCQltb2RpZnkgcy80NC81NS8gc3R1ZmYgJiYKCQlnaXQgY29tbWl0IC0tYW1lbmQgLWEgLW0gIk1vZGlmaWVkIENoYW5nZSA0IgoJKQonCgp0ZXN0X2V4cGVjdF9zdWNjZXNzICdnaXQgcHVsbCAtLXJlYmFzZSBkb2VzIG5vdCByZWFwcGx5IG9sZCBwYXRjaGVzJyAnCgkoCgkJY2QgZHN0ICYmCgkJdGVzdF9tdXN0X2ZhaWwgZ2l0IHB1bGwgLS1yZWJhc2UgJiYKCQl0ZXN0IDEgPSAkKGZpbmQgLmdpdC9yZWJhc2UtYXBwbHkgLW5hbWUgIjAwMCoiIHwgd2MgLWwpCgkpCicKCnRlc3RfZXhwZWN0X3N1Y2Nlc3MgJ2dpdCBwdWxsIC0tcmViYXNlIGFnYWluc3QgbG9jYWwgYnJhbmNoJyAnCglnaXQgY2hlY2tvdXQgLWIgY29weTIgdG8tcmViYXNlLW9yaWcgJiYKCWdpdCBwdWxsIC0tcmViYXNlIC4gdG8tcmViYXNlICYmCgl0ZXN0ICJjb25mbGljdGluZyBtb2RpZmljYXRpb24iID0gIiQoY2F0IGZpbGUpIiAmJgoJdGVzdCBmaWxlID0gIiQoY2F0IGZpbGUyKSIKJwoKdGVzdF9kb25lCg==",
    "text": "#!/bin/sh\n\ntest_description='pulling into void'\n\n. ./test-lib.sh\n\nmodify () {\n\tsed -e \"$1\" \"$2\" >\"$2.x\" &&\n\tmv \"$2.x\" \"$2\"\n}\n\ntest_pull_autostash () {\n\tgit reset --hard before-rebase &&\n\techo dirty >new_file &&\n\tgit add new_file &&\n\tgit pull \"$@\" . copy &&\n\ttest_cmp_rev HEAD^ copy &&\n\ttest \"$(cat new_file)\" = dirty &&\n\ttest \"$(cat file)\" = \"modified again\"\n}\n\ntest_pull_autostash_fail () {\n\tgit reset --hard before-rebase &&\n\techo dirty >new_file &&\n\tgit add new_file &&\n\ttest_must_fail git pull \"$@\" . copy 2>err &&\n\ttest_i18ngrep \"uncommitted changes.\" err\n}\n\ntest_expect_success setup '\n\techo file >file &&\n\tgit add file &&\n\tgit commit -a -m original\n'\n\ntest_expect_success 'pulling into void' '\n\tgit init cloned &&\n\t(\n\t\tcd cloned &&\n\t\tgit pull ..\n\t) &&\n\ttest_path_is_file file &&\n\ttest_path_is_file cloned/file &&\n\ttest_cmp file cloned/file\n'\n\ntest_expect_success 'pulling into void using master:master' '\n\tgit init cloned-uho &&\n\t(\n\t\tcd cloned-uho &&\n\t\tgit pull .. master:master\n\t) &&\n\ttest_path_is_file file &&\n\ttest_path_is_file cloned-uho/file &&\n\ttest_cmp file cloned-uho/file\n'\n\ntest_expect_success 'pulling into void does not overwrite untracked files' '\n\tgit init cloned-untracked &&\n\t(\n\t\tcd cloned-untracked &&\n\t\techo untracked >file &&\n\t\ttest_must_fail git pull .. master &&\n\t\techo untracked >expect &&\n\t\ttest_cmp expect file\n\t)\n'\n\ntest_expect_success 'pulling into void does not overwrite staged files' '\n\tgit init cloned-staged-colliding &&\n\t(\n\t\tcd cloned-staged-colliding &&\n\t\techo \"alternate content\" >file &&\n\t\tgit add file &&\n\t\ttest_must_fail git pull .. master &&\n\t\techo \"alternate content\" >expect &&\n\t\ttest_cmp expect file &&\n\t\tgit cat-file blob :file >file.index &&\n\t\ttest_cmp expect file.index\n\t)\n'\n\ntest_expect_success 'pulling into void does not remove new staged files' '\n\tgit init cloned-staged-new &&\n\t(\n\t\tcd cloned-staged-new &&\n\t\techo \"new tracked file\" >newfile &&\n\t\tgit add newfile &&\n\t\tgit pull .. master &&\n\t\techo \"new tracked file\" >expect &&\n\t\ttest_cmp expect newfile &&\n\t\tgit cat-file blob :newfile >newfile.index &&\n\t\ttest_cmp expect newfile.index\n\t)\n'\n\ntest_expect_success 'pulling into void must not create an octopus' '\n\tgit init cloned-octopus &&\n\t(\n\t\tcd cloned-octopus &&\n\t\ttest_must_fail git pull .. master master &&\n\t\ttest_path_is_missing file\n\t)\n'\n\ntest_expect_success 'test . as a remote' '\n\tgit branch copy master &&\n\tgit config branch.copy.remote . &&\n\tgit config branch.copy.merge refs/heads/master &&\n\techo updated >file &&\n\tgit commit -a -m updated &&\n\tgit checkout copy &&\n\ttest \"$(cat file)\" = file &&\n\tgit pull &&\n\ttest \"$(cat file)\" = updated &&\n\tgit reflog -1 >reflog.actual &&\n\tsed \"s/^[0-9a-f][0-9a-f]*/OBJID/\" reflog.actual >reflog.fuzzy &&\n\techo \"OBJID HEAD@{0}: pull: Fast-forward\" >reflog.expected &&\n\ttest_cmp reflog.expected reflog.fuzzy\n'\n\ntest_expect_success 'the default remote . should not break explicit pull' '\n\tgit checkout -b second master^ &&\n\techo modified >file &&\n\tgit commit -a -m modified &&\n\tgit checkout copy &&\n\tgit reset --hard HEAD^ &&\n\ttest \"$(cat file)\" = file &&\n\tgit pull . second &&\n\ttest \"$(cat file)\" = modified &&\n\tgit reflog -1 >reflog.actual &&\n\tsed \"s/^[0-9a-f][0-9a-f]*/OBJID/\" reflog.actual >reflog.fuzzy &&\n\techo \"OBJID HEAD@{0}: pull . second: Fast-forward\" >reflog.expected &&\n\ttest_cmp reflog.expected reflog.fuzzy\n'\n\ntest_expect_success 'fail if wildcard spec does not match any refs' '\n\tgit checkout -b test copy^ &&\n\ttest_when_finished \"git checkout -f copy && git branch -D test\" &&\n\ttest \"$(cat file)\" = file &&\n\ttest_must_fail git pull . \"refs/nonexisting1/*:refs/nonexisting2/*\" 2>err &&\n\ttest_i18ngrep \"no candidates for merging\" err &&\n\ttest \"$(cat file)\" = file\n'\n\ntest_expect_success 'fail if no branches specified with non-default remote' '\n\tgit remote add test_remote . &&\n\ttest_when_finished \"git remote remove test_remote\" &&\n\tgit checkout -b test copy^ &&\n\ttest_when_finished \"git checkout -f copy && git branch -D test\" &&\n\ttest \"$(cat file)\" = file &&\n\ttest_config branch.test.remote origin &&\n\ttest_must_fail git pull test_remote 2>err &&\n\ttest_i18ngrep \"specify a branch on the command line\" err &&\n\ttest \"$(cat file)\" = file\n'\n\ntest_expect_success 'fail if not on a branch' '\n\tgit remote add origin . &&\n\ttest_when_finished \"git remote remove origin\" &&\n\tgit checkout HEAD^ &&\n\ttest_when_finished \"git checkout -f copy\" &&\n\ttest \"$(cat file)\" = file &&\n\ttest_must_fail git pull 2>err &&\n\ttest_i18ngrep \"not currently on a branch\" err &&\n\ttest \"$(cat file)\" = file\n'\n\ntest_expect_success 'fail if no configuration for current branch' '\n\tgit remote add test_remote . &&\n\ttest_when_finished \"git remote remove test_remote\" &&\n\tgit checkout -b test copy^ &&\n\ttest_when_finished \"git checkout -f copy && git branch -D test\" &&\n\ttest_config branch.test.remote test_remote &&\n\ttest \"$(cat file)\" = file &&\n\ttest_must_fail git pull 2>err &&\n\ttest_i18ngrep \"no tracking information\" err &&\n\ttest \"$(cat file)\" = file\n'\n\ntest_expect_success 'pull --all: fail if no configuration for current branch' '\n\tgit remote add test_remote . &&\n\ttest_when_finished \"git remote remove test_remote\" &&\n\tgit checkout -b test copy^ &&\n\ttest_when_finished \"git checkout -f copy && git branch -D test\" &&\n\ttest_config branch.test.remote test_remote &&\n\ttest \"$(cat file)\" = file &&\n\ttest_must_fail git pull --all 2>err &&\n\ttest_i18ngrep \"There is no tracking information\" err &&\n\ttest \"$(cat file)\" = file\n'\n\ntest_expect_success 'fail if upstream branch does not exist' '\n\tgit checkout -b test copy^ &&\n\ttest_when_finished \"git checkout -f copy && git branch -D test\" &&\n\ttest_config branch.test.remote . &&\n\ttest_config branch.test.merge refs/heads/nonexisting &&\n\ttest \"$(cat file)\" = file &&\n\ttest_must_fail git pull 2>err &&\n\ttest_i18ngrep \"no such ref was fetched\" err &&\n\ttest \"$(cat file)\" = file\n'\n\ntest_expect_success 'fail if the index has unresolved entries' '\n\tgit checkout -b third second^ &&\n\ttest_when_finished \"git checkout -f copy && git branch -D third\" &&\n\ttest \"$(cat file)\" = file &&\n\ttest_commit modified2 file &&\n\ttest -z \"$(git ls-files -u)\" &&\n\ttest_must_fail git pull . second &&\n\ttest -n \"$(git ls-files -u)\" &&\n\tcp file expected &&\n\ttest_must_fail git pull . second 2>err &&\n\ttest_i18ngrep \"Pulling is not possible because you have unmerged files.\" err &&\n\ttest_cmp expected file &&\n\tgit add file &&\n\ttest -z \"$(git ls-files -u)\" &&\n\ttest_must_fail git pull . second 2>err &&\n\ttest_i18ngrep \"You have not concluded your merge\" err &&\n\ttest_cmp expected file\n'\n\ntest_expect_success 'fast-forwards working tree if branch head is updated' '\n\tgit checkout -b third second^ &&\n\ttest_when_finished \"git checkout -f copy && git branch -D third\" &&\n\ttest \"$(cat file)\" = file &&\n\tgit pull . second:third 2>err &&\n\ttest_i18ngrep \"fetch updated the current branch head\" err &&\n\ttest \"$(cat file)\" = modified &&\n\ttest \"$(git rev-parse third)\" = \"$(git rev-parse second)\"\n'\n\ntest_expect_success 'fast-forward fails with conflicting work tree' '\n\tgit checkout -b third second^ &&\n\ttest_when_finished \"git checkout -f copy && git branch -D third\" &&\n\ttest \"$(cat file)\" = file &&\n\techo conflict >file &&\n\ttest_must_fail git pull . second:third 2>err &&\n\ttest_i18ngrep \"Cannot fast-forward your working tree\" err &&\n\ttest \"$(cat file)\" = conflict &&\n\ttest \"$(git rev-parse third)\" = \"$(git rev-parse second)\"\n'\n\ntest_expect_success '--rebase' '\n\tgit branch to-rebase &&\n\techo modified again > file &&\n\tgit commit -m file file &&\n\tgit checkout to-rebase &&\n\techo new > file2 &&\n\tgit add file2 &&\n\tgit commit -m \"new file\" &&\n\tgit tag before-rebase &&\n\tgit pull --rebase . copy &&\n\ttest \"$(git rev-parse HEAD^)\" = \"$(git rev-parse copy)\" &&\n\ttest new = \"$(git show HEAD:file2)\"\n'\n\ntest_expect_success '--rebase fast forward' '\n\tgit reset --hard before-rebase &&\n\tgit checkout -b ff &&\n\techo another modification >file &&\n\tgit commit -m third file &&\n\n\tgit checkout to-rebase &&\n\tgit pull --rebase . ff &&\n\ttest \"$(git rev-parse HEAD)\" = \"$(git rev-parse ff)\" &&\n\n\t# The above only validates the result.  Did we actually bypass rebase?\n\tgit reflog -1 >reflog.actual &&\n\tsed \"s/^[0-9a-f][0-9a-f]*/OBJID/\" reflog.actual >reflog.fuzzy &&\n\techo \"OBJID HEAD@{0}: pull --rebase . ff: Fast-forward\" >reflog.expected &&\n\ttest_cmp reflog.expected reflog.fuzzy\n'\n\ntest_expect_success '--rebase --autostash fast forward' '\n\ttest_when_finished \"\n\t\tgit reset --hard\n\t\tgit checkout to-rebase\n\t\tgit branch -D to-rebase-ff\n\t\tgit branch -D behind\" &&\n\tgit branch behind &&\n\tgit checkout -b to-rebase-ff &&\n\techo another modification >>file &&\n\tgit add file &&\n\tgit commit -m mod &&\n\n\tgit checkout behind &&\n\techo dirty >file &&\n\tgit pull --rebase --autostash . to-rebase-ff &&\n\ttest \"$(git rev-parse HEAD)\" = \"$(git rev-parse to-rebase-ff)\"\n'\n\ntest_expect_success '--rebase with conflicts shows advice' '\n\ttest_when_finished \"git rebase --abort; git checkout -f to-rebase\" &&\n\tgit checkout -b seq &&\n\ttest_seq 5 >seq.txt &&\n\tgit add seq.txt &&\n\ttest_tick &&\n\tgit commit -m \"Add seq.txt\" &&\n\techo 6 >>seq.txt &&\n\ttest_tick &&\n\tgit commit -m \"Append to seq.txt\" seq.txt &&\n\tgit checkout -b with-conflicts HEAD^ &&\n\techo conflicting >>seq.txt &&\n\ttest_tick &&\n\tgit commit -m \"Create conflict\" seq.txt &&\n\ttest_must_fail git pull --rebase . seq 2>err >out &&\n\ttest_i18ngrep \"Resolve all conflicts manually\" out\n'\n\ntest_expect_success 'failed --rebase shows advice' '\n\ttest_when_finished \"git rebase --abort; git checkout -f to-rebase\" &&\n\tgit checkout -b diverging &&\n\ttest_commit attributes .gitattributes \"* text=auto\" attrs &&\n\tsha1=\"$(printf \"1\\\\r\\\\n\" | git hash-object -w --stdin)\" &&\n\tgit update-index --cacheinfo 0644 $sha1 file &&\n\tgit commit -m v1-with-cr &&\n\t# force checkout because `git reset --hard` will not leave clean `file`\n\tgit checkout -f -b fails-to-rebase HEAD^ &&\n\ttest_commit v2-without-cr file \"2\" file2-lf &&\n\ttest_must_fail git pull --rebase . diverging 2>err >out &&\n\ttest_i18ngrep \"Resolve all conflicts manually\" out\n'\n\ntest_expect_success '--rebase fails with multiple branches' '\n\tgit reset --hard before-rebase &&\n\ttest_must_fail git pull --rebase . copy master 2>err &&\n\ttest \"$(git rev-parse HEAD)\" = \"$(git rev-parse before-rebase)\" &&\n\ttest_i18ngrep \"Cannot rebase onto multiple branches\" err &&\n\ttest modified = \"$(git show HEAD:file)\"\n'\n\ntest_expect_success 'pull --rebase succeeds with dirty working directory and rebase.autostash set' '\n\ttest_config rebase.autostash true &&\n\ttest_pull_autostash --rebase\n'\n\ntest_expect_success 'pull --rebase --autostash & rebase.autostash=true' '\n\ttest_config rebase.autostash true &&\n\ttest_pull_autostash --rebase --autostash\n'\n\ntest_expect_success 'pull --rebase --autostash & rebase.autostash=false' '\n\ttest_config rebase.autostash false &&\n\ttest_pull_autostash --rebase --autostash\n'\n\ntest_expect_success 'pull --rebase --autostash & rebase.autostash unset' '\n\ttest_unconfig rebase.autostash &&\n\ttest_pull_autostash --rebase --autostash\n'\n\ntest_expect_success 'pull --rebase --no-autostash & rebase.autostash=true' '\n\ttest_config rebase.autostash true &&\n\ttest_pull_autostash_fail --rebase --no-autostash\n'\n\ntest_expect_success 'pull --rebase --no-autostash & rebase.autostash=false' '\n\ttest_config rebase.autostash false &&\n\ttest_pull_autostash_fail --rebase --no-autostash\n'\n\ntest_expect_success 'pull --rebase --no-autostash & rebase.autostash unset' '\n\ttest_unconfig rebase.autostash &&\n\ttest_pull_autostash_fail --rebase --no-autostash\n'\n\nfor i in --autostash --no-autostash\ndo\n\ttest_expect_success \"pull $i (without --rebase) is illegal\" '\n\t\ttest_must_fail git pull $i . copy 2>err &&\n\t\ttest_i18ngrep \"only valid with --rebase\" err\n\t'\ndone\n\ntest_expect_success 'pull.rebase' '\n\tgit reset --hard before-rebase &&\n\ttest_config pull.rebase true &&\n\tgit pull . copy &&\n\ttest \"$(git rev-parse HEAD^)\" = \"$(git rev-parse copy)\" &&\n\ttest new = \"$(git show HEAD:file2)\"\n'\n\ntest_expect_success 'pull --autostash & pull.rebase=true' '\n\ttest_config pull.rebase true &&\n\ttest_pull_autostash --autostash\n'\n\ntest_expect_success 'pull --no-autostash & pull.rebase=true' '\n\ttest_config pull.rebase true &&\n\ttest_pull_autostash_fail --no-autostash\n'\n\ntest_expect_success 'branch.to-rebase.rebase' '\n\tgit reset --hard before-rebase &&\n\ttest_config branch.to-rebase.rebase true &&\n\tgit pull . copy &&\n\ttest \"$(git rev-parse HEAD^)\" = \"$(git rev-parse copy)\" &&\n\ttest new = \"$(git show HEAD:file2)\"\n'\n\ntest_expect_success 'branch.to-rebase.rebase should override pull.rebase' '\n\tgit reset --hard before-rebase &&\n\ttest_config pull.rebase true &&\n\ttest_config branch.to-rebase.rebase false &&\n\tgit pull . copy &&\n\ttest \"$(git rev-parse HEAD^)\" != \"$(git rev-parse copy)\" &&\n\ttest new = \"$(git show HEAD:file2)\"\n'\n\ntest_expect_success 'pull --rebase warns on --verify-signatures' '\n\tgit reset --hard before-rebase &&\n\tgit pull --rebase --verify-signatures . copy 2>err &&\n\ttest \"$(git rev-parse HEAD^)\" = \"$(git rev-parse copy)\" &&\n\ttest new = \"$(git show HEAD:file2)\" &&\n\ttest_i18ngrep \"ignoring --verify-signatures for rebase\" err\n'\n\ntest_expect_success 'pull --rebase does not warn on --no-verify-signatures' '\n\tgit reset --hard before-rebase &&\n\tgit pull --rebase --no-verify-signatures . copy 2>err &&\n\ttest \"$(git rev-parse HEAD^)\" = \"$(git rev-parse copy)\" &&\n\ttest new = \"$(git show HEAD:file2)\" &&\n\ttest_i18ngrep ! \"verify-signatures\" err\n'\n\n# add a feature branch, keep-merge, that is merged into master, so the\n# test can try preserving the merge commit (or not) with various\n# --rebase flags/pull.rebase settings.\ntest_expect_success 'preserve merge setup' '\n\tgit reset --hard before-rebase &&\n\tgit checkout -b keep-merge second^ &&\n\ttest_commit file3 &&\n\tgit checkout to-rebase &&\n\tgit merge keep-merge &&\n\tgit tag before-preserve-rebase\n'\n\ntest_expect_success 'pull.rebase=false create a new merge commit' '\n\tgit reset --hard before-preserve-rebase &&\n\ttest_config pull.rebase false &&\n\tgit pull . copy &&\n\ttest \"$(git rev-parse HEAD^1)\" = \"$(git rev-parse before-preserve-rebase)\" &&\n\ttest \"$(git rev-parse HEAD^2)\" = \"$(git rev-parse copy)\" &&\n\ttest file3 = \"$(git show HEAD:file3.t)\"\n'\n\ntest_expect_success 'pull.rebase=true flattens keep-merge' '\n\tgit reset --hard before-preserve-rebase &&\n\ttest_config pull.rebase true &&\n\tgit pull . copy &&\n\ttest \"$(git rev-parse HEAD^^)\" = \"$(git rev-parse copy)\" &&\n\ttest file3 = \"$(git show HEAD:file3.t)\"\n'\n\ntest_expect_success 'pull.rebase=1 is treated as true and flattens keep-merge' '\n\tgit reset --hard before-preserve-rebase &&\n\ttest_config pull.rebase 1 &&\n\tgit pull . copy &&\n\ttest \"$(git rev-parse HEAD^^)\" = \"$(git rev-parse copy)\" &&\n\ttest file3 = \"$(git show HEAD:file3.t)\"\n'\n\ntest_expect_success REBASE_P \\\n\t'pull.rebase=preserve rebases and merges keep-merge' '\n\tgit reset --hard before-preserve-rebase &&\n\ttest_config pull.rebase preserve &&\n\tgit pull . copy &&\n\ttest \"$(git rev-parse HEAD^^)\" = \"$(git rev-parse copy)\" &&\n\ttest \"$(git rev-parse HEAD^2)\" = \"$(git rev-parse keep-merge)\"\n'\n\ntest_expect_success 'pull.rebase=interactive' '\n\twrite_script \"$TRASH_DIRECTORY/fake-editor\" <<-\\EOF &&\n\techo I was here >fake.out &&\n\tfalse\n\tEOF\n\ttest_set_editor \"$TRASH_DIRECTORY/fake-editor\" &&\n\ttest_when_finished \"test_might_fail git rebase --abort\" &&\n\ttest_must_fail git pull --rebase=interactive . copy &&\n\ttest \"I was here\" = \"$(cat fake.out)\"\n'\n\ntest_expect_success 'pull --rebase=i' '\n\twrite_script \"$TRASH_DIRECTORY/fake-editor\" <<-\\EOF &&\n\techo I was here, too >fake.out &&\n\tfalse\n\tEOF\n\ttest_set_editor \"$TRASH_DIRECTORY/fake-editor\" &&\n\ttest_when_finished \"test_might_fail git rebase --abort\" &&\n\ttest_must_fail git pull --rebase=i . copy &&\n\ttest \"I was here, too\" = \"$(cat fake.out)\"\n'\n\ntest_expect_success 'pull.rebase=invalid fails' '\n\tgit reset --hard before-preserve-rebase &&\n\ttest_config pull.rebase invalid &&\n\t! git pull . copy\n'\n\ntest_expect_success '--rebase=false create a new merge commit' '\n\tgit reset --hard before-preserve-rebase &&\n\ttest_config pull.rebase true &&\n\tgit pull --rebase=false . copy &&\n\ttest \"$(git rev-parse HEAD^1)\" = \"$(git rev-parse before-preserve-rebase)\" &&\n\ttest \"$(git rev-parse HEAD^2)\" = \"$(git rev-parse copy)\" &&\n\ttest file3 = \"$(git show HEAD:file3.t)\"\n'\n\ntest_expect_success '--rebase=true rebases and flattens keep-merge' '\n\tgit reset --hard before-preserve-rebase &&\n\ttest_config pull.rebase preserve &&\n\tgit pull --rebase=true . copy &&\n\ttest \"$(git rev-parse HEAD^^)\" = \"$(git rev-parse copy)\" &&\n\ttest file3 = \"$(git show HEAD:file3.t)\"\n'\n\ntest_expect_success REBASE_P \\\n\t'--rebase=preserve rebases and merges keep-merge' '\n\tgit reset --hard before-preserve-rebase &&\n\ttest_config pull.rebase true &&\n\tgit pull --rebase=preserve . copy &&\n\ttest \"$(git rev-parse HEAD^^)\" = \"$(git rev-parse copy)\" &&\n\ttest \"$(git rev-parse HEAD^2)\" = \"$(git rev-parse keep-merge)\"\n'\n\ntest_expect_success '--rebase=invalid fails' '\n\tgit reset --hard before-preserve-rebase &&\n\t! git pull --rebase=invalid . copy\n'\n\ntest_expect_success '--rebase overrides pull.rebase=preserve and flattens keep-merge' '\n\tgit reset --hard before-preserve-rebase &&\n\ttest_config pull.rebase preserve &&\n\tgit pull --rebase . copy &&\n\ttest \"$(git rev-parse HEAD^^)\" = \"$(git rev-parse copy)\" &&\n\ttest file3 = \"$(git show HEAD:file3.t)\"\n'\n\ntest_expect_success '--rebase with rebased upstream' '\n\tgit remote add -f me . &&\n\tgit checkout copy &&\n\tgit tag copy-orig &&\n\tgit reset --hard HEAD^ &&\n\techo conflicting modification > file &&\n\tgit commit -m conflict file &&\n\tgit checkout to-rebase &&\n\techo file > file2 &&\n\tgit commit -m to-rebase file2 &&\n\tgit tag to-rebase-orig &&\n\tgit pull --rebase me copy &&\n\ttest \"conflicting modification\" = \"$(cat file)\" &&\n\ttest file = \"$(cat file2)\"\n'\n\ntest_expect_success '--rebase -f with rebased upstream' '\n\ttest_when_finished \"test_might_fail git rebase --abort\" &&\n\tgit reset --hard to-rebase-orig &&\n\tgit pull --rebase -f me copy &&\n\ttest \"conflicting modification\" = \"$(cat file)\" &&\n\ttest file = \"$(cat file2)\"\n'\n\ntest_expect_success '--rebase with rebased default upstream' '\n\tgit update-ref refs/remotes/me/copy copy-orig &&\n\tgit checkout --track -b to-rebase2 me/copy &&\n\tgit reset --hard to-rebase-orig &&\n\tgit pull --rebase &&\n\ttest \"conflicting modification\" = \"$(cat file)\" &&\n\ttest file = \"$(cat file2)\"\n'\n\ntest_expect_success 'rebased upstream + fetch + pull --rebase' '\n\n\tgit update-ref refs/remotes/me/copy copy-orig &&\n\tgit reset --hard to-rebase-orig &&\n\tgit checkout --track -b to-rebase3 me/copy &&\n\tgit reset --hard to-rebase-orig &&\n\tgit fetch &&\n\tgit pull --rebase &&\n\ttest \"conflicting modification\" = \"$(cat file)\" &&\n\ttest file = \"$(cat file2)\"\n\n'\n\ntest_expect_success 'pull --rebase dies early with dirty working directory' '\n\tgit checkout to-rebase &&\n\tgit update-ref refs/remotes/me/copy copy^ &&\n\tCOPY=\"$(git rev-parse --verify me/copy)\" &&\n\tgit rebase --onto $COPY copy &&\n\ttest_config branch.to-rebase.remote me &&\n\ttest_config branch.to-rebase.merge refs/heads/copy &&\n\ttest_config branch.to-rebase.rebase true &&\n\techo dirty >> file &&\n\tgit add file &&\n\ttest_must_fail git pull &&\n\ttest \"$COPY\" = \"$(git rev-parse --verify me/copy)\" &&\n\tgit checkout HEAD -- file &&\n\tgit pull &&\n\ttest \"$COPY\" != \"$(git rev-parse --verify me/copy)\"\n'\n\ntest_expect_success 'pull --rebase works on branch yet to be born' '\n\tgit rev-parse master >expect &&\n\tmkdir empty_repo &&\n\t(\n\t\tcd empty_repo &&\n\t\tgit init &&\n\t\tgit pull --rebase .. master &&\n\t\tgit rev-parse HEAD >../actual\n\t) &&\n\ttest_cmp expect actual\n'\n\ntest_expect_success 'pull --rebase fails on unborn branch with staged changes' '\n\ttest_when_finished \"rm -rf empty_repo2\" &&\n\tgit init empty_repo2 &&\n\t(\n\t\tcd empty_repo2 &&\n\t\techo staged-file >staged-file &&\n\t\tgit add staged-file &&\n\t\ttest \"$(git ls-files)\" = staged-file &&\n\t\ttest_must_fail git pull --rebase .. master 2>err &&\n\t\ttest \"$(git ls-files)\" = staged-file &&\n\t\ttest \"$(git show :staged-file)\" = staged-file &&\n\t\ttest_i18ngrep \"unborn branch with changes added to the index\" err\n\t)\n'\n\ntest_expect_success 'pull --rebase fails on corrupt HEAD' '\n\ttest_when_finished \"rm -rf corrupt\" &&\n\tgit init corrupt &&\n\t(\n\t\tcd corrupt &&\n\t\ttest_commit one &&\n\t\tobj=$(git rev-parse --verify HEAD | sed \"s#^..#&/#\") &&\n\t\trm -f .git/objects/$obj &&\n\t\ttest_must_fail git pull --rebase\n\t)\n'\n\ntest_expect_success 'setup for detecting upstreamed changes' '\n\tmkdir src &&\n\t(\n\t\tcd src &&\n\t\tgit init &&\n\t\tprintf \"1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n9\\n10\\n\" > stuff &&\n\t\tgit add stuff &&\n\t\tgit commit -m \"Initial revision\"\n\t) &&\n\tgit clone src dst &&\n\t(\n\t\tcd src &&\n\t\tmodify s/5/43/ stuff &&\n\t\tgit commit -a -m \"5->43\" &&\n\t\tmodify s/6/42/ stuff &&\n\t\tgit commit -a -m \"Make it bigger\"\n\t) &&\n\t(\n\t\tcd dst &&\n\t\tmodify s/5/43/ stuff &&\n\t\tgit commit -a -m \"Independent discovery of 5->43\"\n\t)\n'\n\ntest_expect_success 'git pull --rebase detects upstreamed changes' '\n\t(\n\t\tcd dst &&\n\t\tgit pull --rebase &&\n\t\ttest -z \"$(git ls-files -u)\"\n\t)\n'\n\ntest_expect_success 'setup for avoiding reapplying old patches' '\n\t(\n\t\tcd dst &&\n\t\ttest_might_fail git rebase --abort &&\n\t\tgit reset --hard origin/master\n\t) &&\n\tgit clone --bare src src-replace.git &&\n\trm -rf src &&\n\tmv src-replace.git src &&\n\t(\n\t\tcd dst &&\n\t\tmodify s/2/22/ stuff &&\n\t\tgit commit -a -m \"Change 2\" &&\n\t\tmodify s/3/33/ stuff &&\n\t\tgit commit -a -m \"Change 3\" &&\n\t\tmodify s/4/44/ stuff &&\n\t\tgit commit -a -m \"Change 4\" &&\n\t\tgit push &&\n\n\t\tmodify s/44/55/ stuff &&\n\t\tgit commit --amend -a -m \"Modified Change 4\"\n\t)\n'\n\ntest_expect_success 'git pull --rebase does not reapply old patches' '\n\t(\n\t\tcd dst &&\n\t\ttest_must_fail git pull --rebase &&\n\t\ttest 1 = $(find .git/rebase-apply -name \"000*\" | wc -l)\n\t)\n'\n\ntest_expect_success 'git pull --rebase against local branch' '\n\tgit checkout -b copy2 to-rebase-orig &&\n\tgit pull --rebase . to-rebase &&\n\ttest \"conflicting modification\" = \"$(cat file)\" &&\n\ttest file = \"$(cat file2)\"\n'\n\ntest_done\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "004d5884cd2a4e76e940e03ca011bd1a70504d97",
  "sha1_ok": true,
  "size": 21763
}
