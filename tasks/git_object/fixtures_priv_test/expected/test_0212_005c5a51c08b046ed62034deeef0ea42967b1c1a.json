{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJkaWZmLmgiCiNpbmNsdWRlICJjb21taXQuaCIKI2luY2x1ZGUgInRhZy5oIgojaW5jbHVkZSAiZ3JhcGguaCIKI2luY2x1ZGUgImxvZy10cmVlLmgiCiNpbmNsdWRlICJyZWZsb2ctd2Fsay5oIgojaW5jbHVkZSAicmVmcy5oIgojaW5jbHVkZSAic3RyaW5nLWxpc3QuaCIKI2luY2x1ZGUgImNvbG9yLmgiCiNpbmNsdWRlICJncGctaW50ZXJmYWNlLmgiCgpzdHJ1Y3QgZGVjb3JhdGlvbiBuYW1lX2RlY29yYXRpb24gPSB7ICJvYmplY3QgbmFtZXMiIH07CgplbnVtIGRlY29yYXRpb25fdHlwZSB7CglERUNPUkFUSU9OX05PTkUgPSAwLAoJREVDT1JBVElPTl9SRUZfTE9DQUwsCglERUNPUkFUSU9OX1JFRl9SRU1PVEUsCglERUNPUkFUSU9OX1JFRl9UQUcsCglERUNPUkFUSU9OX1JFRl9TVEFTSCwKCURFQ09SQVRJT05fUkVGX0hFQUQsCglERUNPUkFUSU9OX0dSQUZURUQsCn07CgpzdGF0aWMgY2hhciBkZWNvcmF0aW9uX2NvbG9yc1tdW0NPTE9SX01BWExFTl0gPSB7CglHSVRfQ09MT1JfUkVTRVQsCglHSVRfQ09MT1JfQk9MRF9HUkVFTiwJLyogUkVGX0xPQ0FMICovCglHSVRfQ09MT1JfQk9MRF9SRUQsCS8qIFJFRl9SRU1PVEUgKi8KCUdJVF9DT0xPUl9CT0xEX1lFTExPVywJLyogUkVGX1RBRyAqLwoJR0lUX0NPTE9SX0JPTERfTUFHRU5UQSwJLyogUkVGX1NUQVNIICovCglHSVRfQ09MT1JfQk9MRF9DWUFOLAkvKiBSRUZfSEVBRCAqLwoJR0lUX0NPTE9SX0JPTERfQkxVRSwJLyogR1JBRlRFRCAqLwp9OwoKc3RhdGljIGNvbnN0IGNoYXIgKmRlY29yYXRlX2dldF9jb2xvcihpbnQgZGVjb3JhdGVfdXNlX2NvbG9yLCBlbnVtIGRlY29yYXRpb25fdHlwZSBpeCkKewoJaWYgKHdhbnRfY29sb3IoZGVjb3JhdGVfdXNlX2NvbG9yKSkKCQlyZXR1cm4gZGVjb3JhdGlvbl9jb2xvcnNbaXhdOwoJcmV0dXJuICIiOwp9CgpzdGF0aWMgaW50IHBhcnNlX2RlY29yYXRlX2NvbG9yX3Nsb3QoY29uc3QgY2hhciAqc2xvdCkKewoJLyoKCSAqIFdlJ3JlIGNvbXBhcmluZyB3aXRoICdpZ25vcmUtY2FzZScgb24KCSAqIChiZWNhdXNlIGNvbmZpZy5jIHNldHMgdGhlbSBhbGwgdG9sb3dlciksCgkgKiBidXQgbGV0J3MgbWF0Y2ggdGhlIGxldHRlcnMgaW4gdGhlIGxpdGVyYWwKCSAqIHN0cmluZyB2YWx1ZXMgaGVyZSB3aXRoIGhvdyB0aGV5IGFyZQoJICogZG9jdW1lbnRlZCBpbiBEb2N1bWVudGF0aW9uL2NvbmZpZy50eHQsIGZvcgoJICogY29uc2lzdGVuY3kuCgkgKgoJICogV2UgbG92ZSBiZWluZyBjb25zaXN0ZW50LCBkb24ndCB3ZT8KCSAqLwoJaWYgKCFzdHJjYXNlY21wKHNsb3QsICJicmFuY2giKSkKCQlyZXR1cm4gREVDT1JBVElPTl9SRUZfTE9DQUw7CglpZiAoIXN0cmNhc2VjbXAoc2xvdCwgInJlbW90ZUJyYW5jaCIpKQoJCXJldHVybiBERUNPUkFUSU9OX1JFRl9SRU1PVEU7CglpZiAoIXN0cmNhc2VjbXAoc2xvdCwgInRhZyIpKQoJCXJldHVybiBERUNPUkFUSU9OX1JFRl9UQUc7CglpZiAoIXN0cmNhc2VjbXAoc2xvdCwgInN0YXNoIikpCgkJcmV0dXJuIERFQ09SQVRJT05fUkVGX1NUQVNIOwoJaWYgKCFzdHJjYXNlY21wKHNsb3QsICJIRUFEIikpCgkJcmV0dXJuIERFQ09SQVRJT05fUkVGX0hFQUQ7CglyZXR1cm4gLTE7Cn0KCmludCBwYXJzZV9kZWNvcmF0ZV9jb2xvcl9jb25maWcoY29uc3QgY2hhciAqdmFyLCBjb25zdCBpbnQgb2ZzLCBjb25zdCBjaGFyICp2YWx1ZSkKewoJaW50IHNsb3QgPSBwYXJzZV9kZWNvcmF0ZV9jb2xvcl9zbG90KHZhciArIG9mcyk7CglpZiAoc2xvdCA8IDApCgkJcmV0dXJuIDA7CglpZiAoIXZhbHVlKQoJCXJldHVybiBjb25maWdfZXJyb3Jfbm9uYm9vbCh2YXIpOwoJY29sb3JfcGFyc2UodmFsdWUsIHZhciwgZGVjb3JhdGlvbl9jb2xvcnNbc2xvdF0pOwoJcmV0dXJuIDA7Cn0KCi8qCiAqIGxvZy10cmVlLmMgdXNlcyBESUZGX09QVF9UU1QgZm9yIGRldGVybWluaW5nIHdoZXRoZXIgdG8gdXNlIGNvbG9yCiAqIGZvciBzaG93aW5nIHRoZSBjb21taXQgc2hhMSwgdXNlIHRoZSBzYW1lIGNoZWNrIGZvciAtLWRlY29yYXRlCiAqLwojZGVmaW5lIGRlY29yYXRlX2dldF9jb2xvcl9vcHQobywgaXgpIFwKCWRlY29yYXRlX2dldF9jb2xvcigobyktPnVzZV9jb2xvciwgaXgpCgpzdGF0aWMgdm9pZCBhZGRfbmFtZV9kZWNvcmF0aW9uKGVudW0gZGVjb3JhdGlvbl90eXBlIHR5cGUsIGNvbnN0IGNoYXIgKm5hbWUsIHN0cnVjdCBvYmplY3QgKm9iaikKewoJaW50IG5sZW4gPSBzdHJsZW4obmFtZSk7CglzdHJ1Y3QgbmFtZV9kZWNvcmF0aW9uICpyZXMgPSB4bWFsbG9jKHNpemVvZihzdHJ1Y3QgbmFtZV9kZWNvcmF0aW9uKSArIG5sZW4pOwoJbWVtY3B5KHJlcy0+bmFtZSwgbmFtZSwgbmxlbiArIDEpOwoJcmVzLT50eXBlID0gdHlwZTsKCXJlcy0+bmV4dCA9IGFkZF9kZWNvcmF0aW9uKCZuYW1lX2RlY29yYXRpb24sIG9iaiwgcmVzKTsKfQoKc3RhdGljIGludCBhZGRfcmVmX2RlY29yYXRpb24oY29uc3QgY2hhciAqcmVmbmFtZSwgY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwgaW50IGZsYWdzLCB2b2lkICpjYl9kYXRhKQp7CglzdHJ1Y3Qgb2JqZWN0ICpvYmo7CgllbnVtIGRlY29yYXRpb25fdHlwZSB0eXBlID0gREVDT1JBVElPTl9OT05FOwoKCWlmICghcHJlZml4Y21wKHJlZm5hbWUsICJyZWZzL3JlcGxhY2UvIikpIHsKCQl1bnNpZ25lZCBjaGFyIG9yaWdpbmFsX3NoYTFbMjBdOwoJCWlmICghcmVhZF9yZXBsYWNlX3JlZnMpCgkJCXJldHVybiAwOwoJCWlmIChnZXRfc2hhMV9oZXgocmVmbmFtZSArIDEzLCBvcmlnaW5hbF9zaGExKSkgewoJCQl3YXJuaW5nKCJpbnZhbGlkIHJlcGxhY2UgcmVmICVzIiwgcmVmbmFtZSk7CgkJCXJldHVybiAwOwoJCX0KCQlvYmogPSBwYXJzZV9vYmplY3Qob3JpZ2luYWxfc2hhMSk7CgkJaWYgKG9iaikKCQkJYWRkX25hbWVfZGVjb3JhdGlvbihERUNPUkFUSU9OX0dSQUZURUQsICJyZXBsYWNlZCIsIG9iaik7CgkJcmV0dXJuIDA7Cgl9CgoJb2JqID0gcGFyc2Vfb2JqZWN0KHNoYTEpOwoJaWYgKCFvYmopCgkJcmV0dXJuIDA7CgoJaWYgKCFwcmVmaXhjbXAocmVmbmFtZSwgInJlZnMvaGVhZHMvIikpCgkJdHlwZSA9IERFQ09SQVRJT05fUkVGX0xPQ0FMOwoJZWxzZSBpZiAoIXByZWZpeGNtcChyZWZuYW1lLCAicmVmcy9yZW1vdGVzLyIpKQoJCXR5cGUgPSBERUNPUkFUSU9OX1JFRl9SRU1PVEU7CgllbHNlIGlmICghcHJlZml4Y21wKHJlZm5hbWUsICJyZWZzL3RhZ3MvIikpCgkJdHlwZSA9IERFQ09SQVRJT05fUkVGX1RBRzsKCWVsc2UgaWYgKCFwcmVmaXhjbXAocmVmbmFtZSwgInJlZnMvc3Rhc2giKSkKCQl0eXBlID0gREVDT1JBVElPTl9SRUZfU1RBU0g7CgllbHNlIGlmICghcHJlZml4Y21wKHJlZm5hbWUsICJIRUFEIikpCgkJdHlwZSA9IERFQ09SQVRJT05fUkVGX0hFQUQ7CgoJaWYgKCFjYl9kYXRhIHx8ICooaW50ICopY2JfZGF0YSA9PSBERUNPUkFURV9TSE9SVF9SRUZTKQoJCXJlZm5hbWUgPSBwcmV0dGlmeV9yZWZuYW1lKHJlZm5hbWUpOwoJYWRkX25hbWVfZGVjb3JhdGlvbih0eXBlLCByZWZuYW1lLCBvYmopOwoJd2hpbGUgKG9iai0+dHlwZSA9PSBPQkpfVEFHKSB7CgkJb2JqID0gKChzdHJ1Y3QgdGFnICopb2JqKS0+dGFnZ2VkOwoJCWlmICghb2JqKQoJCQlicmVhazsKCQlhZGRfbmFtZV9kZWNvcmF0aW9uKERFQ09SQVRJT05fUkVGX1RBRywgcmVmbmFtZSwgb2JqKTsKCX0KCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGFkZF9ncmFmdF9kZWNvcmF0aW9uKGNvbnN0IHN0cnVjdCBjb21taXRfZ3JhZnQgKmdyYWZ0LCB2b2lkICpjYl9kYXRhKQp7CglzdHJ1Y3QgY29tbWl0ICpjb21taXQgPSBsb29rdXBfY29tbWl0KGdyYWZ0LT5zaGExKTsKCWlmICghY29tbWl0KQoJCXJldHVybiAwOwoJYWRkX25hbWVfZGVjb3JhdGlvbihERUNPUkFUSU9OX0dSQUZURUQsICJncmFmdGVkIiwgJmNvbW1pdC0+b2JqZWN0KTsKCXJldHVybiAwOwp9Cgp2b2lkIGxvYWRfcmVmX2RlY29yYXRpb25zKGludCBmbGFncykKewoJc3RhdGljIGludCBsb2FkZWQ7CglpZiAoIWxvYWRlZCkgewoJCWxvYWRlZCA9IDE7CgkJZm9yX2VhY2hfcmVmKGFkZF9yZWZfZGVjb3JhdGlvbiwgJmZsYWdzKTsKCQloZWFkX3JlZihhZGRfcmVmX2RlY29yYXRpb24sICZmbGFncyk7CgkJZm9yX2VhY2hfY29tbWl0X2dyYWZ0KGFkZF9ncmFmdF9kZWNvcmF0aW9uLCBOVUxMKTsKCX0KfQoKc3RhdGljIHZvaWQgc2hvd19wYXJlbnRzKHN0cnVjdCBjb21taXQgKmNvbW1pdCwgaW50IGFiYnJldikKewoJc3RydWN0IGNvbW1pdF9saXN0ICpwOwoJZm9yIChwID0gY29tbWl0LT5wYXJlbnRzOyBwIDsgcCA9IHAtPm5leHQpIHsKCQlzdHJ1Y3QgY29tbWl0ICpwYXJlbnQgPSBwLT5pdGVtOwoJCXByaW50ZigiICVzIiwgZmluZF91bmlxdWVfYWJicmV2KHBhcmVudC0+b2JqZWN0LnNoYTEsIGFiYnJldikpOwoJfQp9CgpzdGF0aWMgdm9pZCBzaG93X2NoaWxkcmVuKHN0cnVjdCByZXZfaW5mbyAqb3B0LCBzdHJ1Y3QgY29tbWl0ICpjb21taXQsIGludCBhYmJyZXYpCnsKCXN0cnVjdCBjb21taXRfbGlzdCAqcCA9IGxvb2t1cF9kZWNvcmF0aW9uKCZvcHQtPmNoaWxkcmVuLCAmY29tbWl0LT5vYmplY3QpOwoJZm9yICggOyBwOyBwID0gcC0+bmV4dCkgewoJCXByaW50ZigiICVzIiwgZmluZF91bmlxdWVfYWJicmV2KHAtPml0ZW0tPm9iamVjdC5zaGExLCBhYmJyZXYpKTsKCX0KfQoKdm9pZCBzaG93X2RlY29yYXRpb25zKHN0cnVjdCByZXZfaW5mbyAqb3B0LCBzdHJ1Y3QgY29tbWl0ICpjb21taXQpCnsKCWNvbnN0IGNoYXIgKnByZWZpeDsKCXN0cnVjdCBuYW1lX2RlY29yYXRpb24gKmRlY29yYXRpb247Cgljb25zdCBjaGFyICpjb2xvcl9jb21taXQgPQoJCWRpZmZfZ2V0X2NvbG9yX29wdCgmb3B0LT5kaWZmb3B0LCBESUZGX0NPTU1JVCk7Cgljb25zdCBjaGFyICpjb2xvcl9yZXNldCA9CgkJZGVjb3JhdGVfZ2V0X2NvbG9yX29wdCgmb3B0LT5kaWZmb3B0LCBERUNPUkFUSU9OX05PTkUpOwoKCWlmIChvcHQtPnNob3dfc291cmNlICYmIGNvbW1pdC0+dXRpbCkKCQlwcmludGYoIlx0JXMiLCAoY2hhciAqKSBjb21taXQtPnV0aWwpOwoJaWYgKCFvcHQtPnNob3dfZGVjb3JhdGlvbnMpCgkJcmV0dXJuOwoJZGVjb3JhdGlvbiA9IGxvb2t1cF9kZWNvcmF0aW9uKCZuYW1lX2RlY29yYXRpb24sICZjb21taXQtPm9iamVjdCk7CglpZiAoIWRlY29yYXRpb24pCgkJcmV0dXJuOwoJcHJlZml4ID0gIiAoIjsKCXdoaWxlIChkZWNvcmF0aW9uKSB7CgkJcHJpbnRmKCIlcyIsIHByZWZpeCk7CgkJZnB1dHMoZGVjb3JhdGVfZ2V0X2NvbG9yX29wdCgmb3B0LT5kaWZmb3B0LCBkZWNvcmF0aW9uLT50eXBlKSwKCQkgICAgICBzdGRvdXQpOwoJCWlmIChkZWNvcmF0aW9uLT50eXBlID09IERFQ09SQVRJT05fUkVGX1RBRykKCQkJZnB1dHMoInRhZzogIiwgc3Rkb3V0KTsKCQlwcmludGYoIiVzIiwgZGVjb3JhdGlvbi0+bmFtZSk7CgkJZnB1dHMoY29sb3JfcmVzZXQsIHN0ZG91dCk7CgkJZnB1dHMoY29sb3JfY29tbWl0LCBzdGRvdXQpOwoJCXByZWZpeCA9ICIsICI7CgkJZGVjb3JhdGlvbiA9IGRlY29yYXRpb24tPm5leHQ7Cgl9CglwdXRjaGFyKCcpJyk7Cn0KCi8qCiAqIFNlYXJjaCBmb3IgIl5bLUEtWmEtel0rOiBbXkBdK0AiIHBhdHRlcm4uIEl0IHVzdWFsbHkgbWF0Y2hlcwogKiBTaWduZWQtb2ZmLWJ5OiBhbmQgQWNrZWQtYnk6IGxpbmVzLgogKi8Kc3RhdGljIGludCBkZXRlY3RfYW55X3NpZ25vZmYoY2hhciAqbGV0dGVyLCBpbnQgc2l6ZSkKewoJY2hhciAqY3A7CglpbnQgc2Vlbl9jb2xvbiA9IDA7CglpbnQgc2Vlbl9hdCA9IDA7CglpbnQgc2Vlbl9uYW1lID0gMDsKCWludCBzZWVuX2hlYWQgPSAwOwoKCWNwID0gbGV0dGVyICsgc2l6ZTsKCXdoaWxlIChsZXR0ZXIgPD0gLS1jcCAmJiAqY3AgPT0gJ1xuJykKCQljb250aW51ZTsKCgl3aGlsZSAobGV0dGVyIDw9IGNwKSB7CgkJY2hhciBjaCA9ICpjcC0tOwoJCWlmIChjaCA9PSAnXG4nKQoJCQlicmVhazsKCgkJaWYgKCFzZWVuX2F0KSB7CgkJCWlmIChjaCA9PSAnQCcpCgkJCQlzZWVuX2F0ID0gMTsKCQkJY29udGludWU7CgkJfQoJCWlmICghc2Vlbl9jb2xvbikgewoJCQlpZiAoY2ggPT0gJ0AnKQoJCQkJcmV0dXJuIDA7CgkJCWVsc2UgaWYgKGNoID09ICc6JykKCQkJCXNlZW5fY29sb24gPSAxOwoJCQllbHNlCgkJCQlzZWVuX25hbWUgPSAxOwoJCQljb250aW51ZTsKCQl9CgkJaWYgKCgnQScgPD0gY2ggJiYgY2ggPD0gJ1onKSB8fAoJCSAgICAoJ2EnIDw9IGNoICYmIGNoIDw9ICd6JykgfHwKCQkgICAgY2ggPT0gJy0nKSB7CgkJCXNlZW5faGVhZCA9IDE7CgkJCWNvbnRpbnVlOwoJCX0KCQkvKiBubyBlbXB0eSBsYXN0IGxpbmUgZG9lc24ndCBtYXRjaCAqLwoJCXJldHVybiAwOwoJfQoJcmV0dXJuIHNlZW5faGVhZCAmJiBzZWVuX25hbWU7Cn0KCnN0YXRpYyB2b2lkIGFwcGVuZF9zaWdub2ZmKHN0cnVjdCBzdHJidWYgKnNiLCBjb25zdCBjaGFyICpzaWdub2ZmKQp7CglzdGF0aWMgY29uc3QgY2hhciBzaWduZWRfb2ZmX2J5W10gPSAiU2lnbmVkLW9mZi1ieTogIjsKCXNpemVfdCBzaWdub2ZmX2xlbiA9IHN0cmxlbihzaWdub2ZmKTsKCWludCBoYXNfc2lnbm9mZiA9IDA7CgljaGFyICpjcDsKCgljcCA9IHNiLT5idWY7CgoJLyogRmlyc3Qgc2VlIGlmIHdlIGFscmVhZHkgaGF2ZSB0aGUgc2lnbi1vZmYgYnkgdGhlIHNpZ25lciAqLwoJd2hpbGUgKChjcCA9IHN0cnN0cihjcCwgc2lnbmVkX29mZl9ieSkpKSB7CgoJCWhhc19zaWdub2ZmID0gMTsKCgkJY3AgKz0gc3RybGVuKHNpZ25lZF9vZmZfYnkpOwoJCWlmIChjcCArIHNpZ25vZmZfbGVuID49IHNiLT5idWYgKyBzYi0+bGVuKQoJCQlicmVhazsKCQlpZiAoc3RybmNtcChjcCwgc2lnbm9mZiwgc2lnbm9mZl9sZW4pKQoJCQljb250aW51ZTsKCQlpZiAoIWlzc3BhY2UoY3Bbc2lnbm9mZl9sZW5dKSkKCQkJY29udGludWU7CgkJLyogd2UgYWxyZWFkeSBoYXZlIGhpbSAqLwoJCXJldHVybjsKCX0KCglpZiAoIWhhc19zaWdub2ZmKQoJCWhhc19zaWdub2ZmID0gZGV0ZWN0X2FueV9zaWdub2ZmKHNiLT5idWYsIHNiLT5sZW4pOwoKCWlmICghaGFzX3NpZ25vZmYpCgkJc3RyYnVmX2FkZGNoKHNiLCAnXG4nKTsKCglzdHJidWZfYWRkc3RyKHNiLCBzaWduZWRfb2ZmX2J5KTsKCXN0cmJ1Zl9hZGQoc2IsIHNpZ25vZmYsIHNpZ25vZmZfbGVuKTsKCXN0cmJ1Zl9hZGRjaChzYiwgJ1xuJyk7Cn0KCnN0YXRpYyB1bnNpZ25lZCBpbnQgZGlnaXRzX2luX251bWJlcih1bnNpZ25lZCBpbnQgbnVtYmVyKQp7Cgl1bnNpZ25lZCBpbnQgaSA9IDEwLCByZXN1bHQgPSAxOwoJd2hpbGUgKGkgPD0gbnVtYmVyKSB7CgkJaSAqPSAxMDsKCQlyZXN1bHQrKzsKCX0KCXJldHVybiByZXN1bHQ7Cn0KCnZvaWQgZ2V0X3BhdGNoX2ZpbGVuYW1lKHN0cnVjdCBjb21taXQgKmNvbW1pdCwgaW50IG5yLCBjb25zdCBjaGFyICpzdWZmaXgsCgkJCXN0cnVjdCBzdHJidWYgKmJ1ZikKewoJaW50IHN1ZmZpeF9sZW4gPSBzdHJsZW4oc3VmZml4KSArIDE7CglpbnQgc3RhcnRfbGVuID0gYnVmLT5sZW47CgoJc3RyYnVmX2FkZGYoYnVmLCBjb21taXQgPyAiJTA0ZC0iIDogIiVkIiwgbnIpOwoJaWYgKGNvbW1pdCkgewoJCWludCBtYXhfbGVuID0gc3RhcnRfbGVuICsgRk9STUFUX1BBVENIX05BTUVfTUFYIC0gc3VmZml4X2xlbjsKCQlzdHJ1Y3QgcHJldHR5X3ByaW50X2NvbnRleHQgY3R4ID0gezB9OwoJCWN0eC5kYXRlX21vZGUgPSBEQVRFX05PUk1BTDsKCgkJZm9ybWF0X2NvbW1pdF9tZXNzYWdlKGNvbW1pdCwgIiVmIiwgYnVmLCAmY3R4KTsKCQlpZiAobWF4X2xlbiA8IGJ1Zi0+bGVuKQoJCQlzdHJidWZfc2V0bGVuKGJ1ZiwgbWF4X2xlbik7CgkJc3RyYnVmX2FkZHN0cihidWYsIHN1ZmZpeCk7Cgl9Cn0KCnZvaWQgbG9nX3dyaXRlX2VtYWlsX2hlYWRlcnMoc3RydWN0IHJldl9pbmZvICpvcHQsIHN0cnVjdCBjb21taXQgKmNvbW1pdCwKCQkJICAgICBjb25zdCBjaGFyICoqc3ViamVjdF9wLAoJCQkgICAgIGNvbnN0IGNoYXIgKipleHRyYV9oZWFkZXJzX3AsCgkJCSAgICAgaW50ICpuZWVkXzhiaXRfY3RlX3ApCnsKCWNvbnN0IGNoYXIgKnN1YmplY3QgPSBOVUxMOwoJY29uc3QgY2hhciAqZXh0cmFfaGVhZGVycyA9IG9wdC0+ZXh0cmFfaGVhZGVyczsKCWNvbnN0IGNoYXIgKm5hbWUgPSBzaGExX3RvX2hleChjb21taXQtPm9iamVjdC5zaGExKTsKCgkqbmVlZF84Yml0X2N0ZV9wID0gMDsgLyogdW5rbm93biAqLwoJaWYgKG9wdC0+dG90YWwgPiAwKSB7CgkJc3RhdGljIGNoYXIgYnVmZmVyWzY0XTsKCQlzbnByaW50ZihidWZmZXIsIHNpemVvZihidWZmZXIpLAoJCQkgIlN1YmplY3Q6IFslcyVzJTAqZC8lZF0gIiwKCQkJIG9wdC0+c3ViamVjdF9wcmVmaXgsCgkJCSAqb3B0LT5zdWJqZWN0X3ByZWZpeCA/ICIgIiA6ICIiLAoJCQkgZGlnaXRzX2luX251bWJlcihvcHQtPnRvdGFsKSwKCQkJIG9wdC0+bnIsIG9wdC0+dG90YWwpOwoJCXN1YmplY3QgPSBidWZmZXI7Cgl9IGVsc2UgaWYgKG9wdC0+dG90YWwgPT0gMCAmJiBvcHQtPnN1YmplY3RfcHJlZml4ICYmICpvcHQtPnN1YmplY3RfcHJlZml4KSB7CgkJc3RhdGljIGNoYXIgYnVmZmVyWzI1Nl07CgkJc25wcmludGYoYnVmZmVyLCBzaXplb2YoYnVmZmVyKSwKCQkJICJTdWJqZWN0OiBbJXNdICIsCgkJCSBvcHQtPnN1YmplY3RfcHJlZml4KTsKCQlzdWJqZWN0ID0gYnVmZmVyOwoJfSBlbHNlIHsKCQlzdWJqZWN0ID0gIlN1YmplY3Q6ICI7Cgl9CgoJcHJpbnRmKCJGcm9tICVzIE1vbiBTZXAgMTcgMDA6MDA6MDAgMjAwMVxuIiwgbmFtZSk7CglncmFwaF9zaG93X29uZWxpbmUob3B0LT5ncmFwaCk7CglpZiAob3B0LT5tZXNzYWdlX2lkKSB7CgkJcHJpbnRmKCJNZXNzYWdlLUlkOiA8JXM+XG4iLCBvcHQtPm1lc3NhZ2VfaWQpOwoJCWdyYXBoX3Nob3dfb25lbGluZShvcHQtPmdyYXBoKTsKCX0KCWlmIChvcHQtPnJlZl9tZXNzYWdlX2lkcyAmJiBvcHQtPnJlZl9tZXNzYWdlX2lkcy0+bnIgPiAwKSB7CgkJaW50IGksIG47CgkJbiA9IG9wdC0+cmVmX21lc3NhZ2VfaWRzLT5ucjsKCQlwcmludGYoIkluLVJlcGx5LVRvOiA8JXM+XG4iLCBvcHQtPnJlZl9tZXNzYWdlX2lkcy0+aXRlbXNbbi0xXS5zdHJpbmcpOwoJCWZvciAoaSA9IDA7IGkgPCBuOyBpKyspCgkJCXByaW50ZigiJXM8JXM+XG4iLCAoaSA+IDAgPyAiXHQiIDogIlJlZmVyZW5jZXM6ICIpLAoJCQkgICAgICAgb3B0LT5yZWZfbWVzc2FnZV9pZHMtPml0ZW1zW2ldLnN0cmluZyk7CgkJZ3JhcGhfc2hvd19vbmVsaW5lKG9wdC0+Z3JhcGgpOwoJfQoJaWYgKG9wdC0+bWltZV9ib3VuZGFyeSkgewoJCXN0YXRpYyBjaGFyIHN1YmplY3RfYnVmZmVyWzEwMjRdOwoJCXN0YXRpYyBjaGFyIGJ1ZmZlclsxMDI0XTsKCQlzdHJ1Y3Qgc3RyYnVmIGZpbGVuYW1lID0gIFNUUkJVRl9JTklUOwoJCSpuZWVkXzhiaXRfY3RlX3AgPSAtMTsgLyogTkVWRVIgKi8KCQlzbnByaW50ZihzdWJqZWN0X2J1ZmZlciwgc2l6ZW9mKHN1YmplY3RfYnVmZmVyKSAtIDEsCgkJCSAiJXMiCgkJCSAiTUlNRS1WZXJzaW9uOiAxLjBcbiIKCQkJICJDb250ZW50LVR5cGU6IG11bHRpcGFydC9taXhlZDsiCgkJCSAiIGJvdW5kYXJ5PVwiJXMlc1wiXG4iCgkJCSAiXG4iCgkJCSAiVGhpcyBpcyBhIG11bHRpLXBhcnQgbWVzc2FnZSBpbiBNSU1FICIKCQkJICJmb3JtYXQuXG4iCgkJCSAiLS0lcyVzXG4iCgkJCSAiQ29udGVudC1UeXBlOiB0ZXh0L3BsYWluOyAiCgkJCSAiY2hhcnNldD1VVEYtODsgZm9ybWF0PWZpeGVkXG4iCgkJCSAiQ29udGVudC1UcmFuc2Zlci1FbmNvZGluZzogOGJpdFxuXG4iLAoJCQkgZXh0cmFfaGVhZGVycyA/IGV4dHJhX2hlYWRlcnMgOiAiIiwKCQkJIG1pbWVfYm91bmRhcnlfbGVhZGVyLCBvcHQtPm1pbWVfYm91bmRhcnksCgkJCSBtaW1lX2JvdW5kYXJ5X2xlYWRlciwgb3B0LT5taW1lX2JvdW5kYXJ5KTsKCQlleHRyYV9oZWFkZXJzID0gc3ViamVjdF9idWZmZXI7CgoJCWdldF9wYXRjaF9maWxlbmFtZShvcHQtPm51bWJlcmVkX2ZpbGVzID8gTlVMTCA6IGNvbW1pdCwgb3B0LT5uciwKCQkJCSAgICBvcHQtPnBhdGNoX3N1ZmZpeCwgJmZpbGVuYW1lKTsKCQlzbnByaW50ZihidWZmZXIsIHNpemVvZihidWZmZXIpIC0gMSwKCQkJICJcbi0tJXMlc1xuIgoJCQkgIkNvbnRlbnQtVHlwZTogdGV4dC94LXBhdGNoOyIKCQkJICIgbmFtZT1cIiVzXCJcbiIKCQkJICJDb250ZW50LVRyYW5zZmVyLUVuY29kaW5nOiA4Yml0XG4iCgkJCSAiQ29udGVudC1EaXNwb3NpdGlvbjogJXM7IgoJCQkgIiBmaWxlbmFtZT1cIiVzXCJcblxuIiwKCQkJIG1pbWVfYm91bmRhcnlfbGVhZGVyLCBvcHQtPm1pbWVfYm91bmRhcnksCgkJCSBmaWxlbmFtZS5idWYsCgkJCSBvcHQtPm5vX2lubGluZSA/ICJhdHRhY2htZW50IiA6ICJpbmxpbmUiLAoJCQkgZmlsZW5hbWUuYnVmKTsKCQlvcHQtPmRpZmZvcHQuc3RhdF9zZXAgPSBidWZmZXI7CgkJc3RyYnVmX3JlbGVhc2UoJmZpbGVuYW1lKTsKCX0KCSpzdWJqZWN0X3AgPSBzdWJqZWN0OwoJKmV4dHJhX2hlYWRlcnNfcCA9IGV4dHJhX2hlYWRlcnM7Cn0KCnN0YXRpYyB2b2lkIHNob3dfc2lnX2xpbmVzKHN0cnVjdCByZXZfaW5mbyAqb3B0LCBpbnQgc3RhdHVzLCBjb25zdCBjaGFyICpib2wpCnsKCWNvbnN0IGNoYXIgKmNvbG9yLCAqcmVzZXQsICplb2w7CgoJY29sb3IgPSBkaWZmX2dldF9jb2xvcl9vcHQoJm9wdC0+ZGlmZm9wdCwKCQkJCSAgIHN0YXR1cyA/IERJRkZfV0hJVEVTUEFDRSA6IERJRkZfRlJBR0lORk8pOwoJcmVzZXQgPSBkaWZmX2dldF9jb2xvcl9vcHQoJm9wdC0+ZGlmZm9wdCwgRElGRl9SRVNFVCk7Cgl3aGlsZSAoKmJvbCkgewoJCWVvbCA9IHN0cmNocm51bChib2wsICdcbicpOwoJCXByaW50ZigiJXMlLipzJXMlcyIsIGNvbG9yLCAoaW50KShlb2wgLSBib2wpLCBib2wsIHJlc2V0LAoJCSAgICAgICAqZW9sID8gIlxuIiA6ICIiKTsKCQlib2wgPSAoKmVvbCkgPyAoZW9sICsgMSkgOiBlb2w7Cgl9Cn0KCnN0YXRpYyB2b2lkIHNob3dfc2lnbmF0dXJlKHN0cnVjdCByZXZfaW5mbyAqb3B0LCBzdHJ1Y3QgY29tbWl0ICpjb21taXQpCnsKCXN0cnVjdCBzdHJidWYgcGF5bG9hZCA9IFNUUkJVRl9JTklUOwoJc3RydWN0IHN0cmJ1ZiBzaWduYXR1cmUgPSBTVFJCVUZfSU5JVDsKCXN0cnVjdCBzdHJidWYgZ3BnX291dHB1dCA9IFNUUkJVRl9JTklUOwoJaW50IHN0YXR1czsKCglpZiAocGFyc2Vfc2lnbmVkX2NvbW1pdChjb21taXQtPm9iamVjdC5zaGExLCAmcGF5bG9hZCwgJnNpZ25hdHVyZSkgPD0gMCkKCQlnb3RvIG91dDsKCglzdGF0dXMgPSB2ZXJpZnlfc2lnbmVkX2J1ZmZlcihwYXlsb2FkLmJ1ZiwgcGF5bG9hZC5sZW4sCgkJCQkgICAgICBzaWduYXR1cmUuYnVmLCBzaWduYXR1cmUubGVuLAoJCQkJICAgICAgJmdwZ19vdXRwdXQpOwoJaWYgKHN0YXR1cyAmJiAhZ3BnX291dHB1dC5sZW4pCgkJc3RyYnVmX2FkZHN0cigmZ3BnX291dHB1dCwgIk5vIHNpZ25hdHVyZVxuIik7CgoJc2hvd19zaWdfbGluZXMob3B0LCBzdGF0dXMsIGdwZ19vdXRwdXQuYnVmKTsKCiBvdXQ6CglzdHJidWZfcmVsZWFzZSgmZ3BnX291dHB1dCk7CglzdHJidWZfcmVsZWFzZSgmcGF5bG9hZCk7CglzdHJidWZfcmVsZWFzZSgmc2lnbmF0dXJlKTsKfQoKdm9pZCBzaG93X2xvZyhzdHJ1Y3QgcmV2X2luZm8gKm9wdCkKewoJc3RydWN0IHN0cmJ1ZiBtc2didWYgPSBTVFJCVUZfSU5JVDsKCXN0cnVjdCBsb2dfaW5mbyAqbG9nID0gb3B0LT5sb2dpbmZvOwoJc3RydWN0IGNvbW1pdCAqY29tbWl0ID0gbG9nLT5jb21taXQsICpwYXJlbnQgPSBsb2ctPnBhcmVudDsKCWludCBhYmJyZXZfY29tbWl0ID0gb3B0LT5hYmJyZXZfY29tbWl0ID8gb3B0LT5hYmJyZXYgOiA0MDsKCWNvbnN0IGNoYXIgKmV4dHJhX2hlYWRlcnMgPSBvcHQtPmV4dHJhX2hlYWRlcnM7CglzdHJ1Y3QgcHJldHR5X3ByaW50X2NvbnRleHQgY3R4ID0gezB9OwoKCW9wdC0+bG9naW5mbyA9IE5VTEw7CgljdHguc2hvd19ub3RlcyA9IG9wdC0+c2hvd19ub3RlczsKCWlmICghb3B0LT52ZXJib3NlX2hlYWRlcikgewoJCWdyYXBoX3Nob3dfY29tbWl0KG9wdC0+Z3JhcGgpOwoKCQlpZiAoIW9wdC0+Z3JhcGgpCgkJCXB1dF9yZXZpc2lvbl9tYXJrKG9wdCwgY29tbWl0KTsKCQlmcHV0cyhmaW5kX3VuaXF1ZV9hYmJyZXYoY29tbWl0LT5vYmplY3Quc2hhMSwgYWJicmV2X2NvbW1pdCksIHN0ZG91dCk7CgkJaWYgKG9wdC0+cHJpbnRfcGFyZW50cykKCQkJc2hvd19wYXJlbnRzKGNvbW1pdCwgYWJicmV2X2NvbW1pdCk7CgkJaWYgKG9wdC0+Y2hpbGRyZW4ubmFtZSkKCQkJc2hvd19jaGlsZHJlbihvcHQsIGNvbW1pdCwgYWJicmV2X2NvbW1pdCk7CgkJc2hvd19kZWNvcmF0aW9ucyhvcHQsIGNvbW1pdCk7CgkJaWYgKG9wdC0+Z3JhcGggJiYgIWdyYXBoX2lzX2NvbW1pdF9maW5pc2hlZChvcHQtPmdyYXBoKSkgewoJCQlwdXRjaGFyKCdcbicpOwoJCQlncmFwaF9zaG93X3JlbWFpbmRlcihvcHQtPmdyYXBoKTsKCQl9CgkJcHV0Y2hhcihvcHQtPmRpZmZvcHQubGluZV90ZXJtaW5hdGlvbik7CgkJcmV0dXJuOwoJfQoKCS8qCgkgKiBJZiB1c2VfdGVybWluYXRvciBpcyBzZXQsIHdlIGFscmVhZHkgaGFuZGxlZCBhbnkgcmVjb3JkIHRlcm1pbmF0aW9uCgkgKiBhdCB0aGUgZW5kIG9mIHRoZSBsYXN0IHJlY29yZC4KCSAqIE90aGVyd2lzZSwgYWRkIGEgZGlmZm9wdC5saW5lX3Rlcm1pbmF0aW9uIGNoYXJhY3RlciBiZWZvcmUgYWxsCgkgKiBlbnRyaWVzIGJ1dCB0aGUgZmlyc3QuICAoSU9XLCBhcyBhIHNlcGFyYXRvciBiZXR3ZWVuIGVudHJpZXMpCgkgKi8KCWlmIChvcHQtPnNob3duX29uZSAmJiAhb3B0LT51c2VfdGVybWluYXRvcikgewoJCS8qCgkJICogSWYgZW50cmllcyBhcmUgc2VwYXJhdGVkIGJ5IGEgbmV3bGluZSwgdGhlIG91dHB1dAoJCSAqIHNob3VsZCBsb29rIGh1bWFuLXJlYWRhYmxlLiAgSWYgdGhlIGxhc3QgZW50cnkgZW5kZWQKCQkgKiB3aXRoIGEgbmV3bGluZSwgcHJpbnQgdGhlIGdyYXBoIG91dHB1dCBiZWZvcmUgdGhpcwoJCSAqIG5ld2xpbmUuICBPdGhlcndpc2UgaXQgd2lsbCBlbmQgdXAgYXMgYSBjb21wbGV0ZWx5IGJsYW5rCgkJICogbGluZSBhbmQgd2lsbCBsb29rIGxpa2UgYSBnYXAgaW4gdGhlIGdyYXBoLgoJCSAqCgkJICogSWYgdGhlIGVudHJ5IHNlcGFyYXRvciBpcyBub3QgYSBuZXdsaW5lLCB0aGUgb3V0cHV0IGlzCgkJICogcHJpbWFyaWx5IGludGVuZGVkIGZvciBwcm9ncmFtbWF0aWMgY29uc3VtcHRpb24sIGFuZCB3ZQoJCSAqIG5ldmVyIHdhbnQgdGhlIGV4dHJhIGdyYXBoIG91dHB1dCBiZWZvcmUgdGhlIGVudHJ5CgkJICogc2VwYXJhdG9yLgoJCSAqLwoJCWlmIChvcHQtPmRpZmZvcHQubGluZV90ZXJtaW5hdGlvbiA9PSAnXG4nICYmCgkJICAgICFvcHQtPm1pc3NpbmdfbmV3bGluZSkKCQkJZ3JhcGhfc2hvd19wYWRkaW5nKG9wdC0+Z3JhcGgpOwoJCXB1dGNoYXIob3B0LT5kaWZmb3B0LmxpbmVfdGVybWluYXRpb24pOwoJfQoJb3B0LT5zaG93bl9vbmUgPSAxOwoKCS8qCgkgKiBJZiB0aGUgaGlzdG9yeSBncmFwaCB3YXMgcmVxdWVzdGVkLAoJICogcHJpbnQgdGhlIGdyYXBoLCB1cCB0byB0aGlzIGNvbW1pdCdzIGxpbmUKCSAqLwoJZ3JhcGhfc2hvd19jb21taXQob3B0LT5ncmFwaCk7CgoJLyoKCSAqIFByaW50IGhlYWRlciBsaW5lIG9mIGhlYWRlci4uCgkgKi8KCglpZiAob3B0LT5jb21taXRfZm9ybWF0ID09IENNSVRfRk1UX0VNQUlMKSB7CgkJbG9nX3dyaXRlX2VtYWlsX2hlYWRlcnMob3B0LCBjb21taXQsICZjdHguc3ViamVjdCwgJmV4dHJhX2hlYWRlcnMsCgkJCQkJJmN0eC5uZWVkXzhiaXRfY3RlKTsKCX0gZWxzZSBpZiAob3B0LT5jb21taXRfZm9ybWF0ICE9IENNSVRfRk1UX1VTRVJGT1JNQVQpIHsKCQlmcHV0cyhkaWZmX2dldF9jb2xvcl9vcHQoJm9wdC0+ZGlmZm9wdCwgRElGRl9DT01NSVQpLCBzdGRvdXQpOwoJCWlmIChvcHQtPmNvbW1pdF9mb3JtYXQgIT0gQ01JVF9GTVRfT05FTElORSkKCQkJZnB1dHMoImNvbW1pdCAiLCBzdGRvdXQpOwoKCQlpZiAoIW9wdC0+Z3JhcGgpCgkJCXB1dF9yZXZpc2lvbl9tYXJrKG9wdCwgY29tbWl0KTsKCQlmcHV0cyhmaW5kX3VuaXF1ZV9hYmJyZXYoY29tbWl0LT5vYmplY3Quc2hhMSwgYWJicmV2X2NvbW1pdCksCgkJICAgICAgc3Rkb3V0KTsKCQlpZiAob3B0LT5wcmludF9wYXJlbnRzKQoJCQlzaG93X3BhcmVudHMoY29tbWl0LCBhYmJyZXZfY29tbWl0KTsKCQlpZiAob3B0LT5jaGlsZHJlbi5uYW1lKQoJCQlzaG93X2NoaWxkcmVuKG9wdCwgY29tbWl0LCBhYmJyZXZfY29tbWl0KTsKCQlpZiAocGFyZW50KQoJCQlwcmludGYoIiAoZnJvbSAlcykiLAoJCQkgICAgICAgZmluZF91bmlxdWVfYWJicmV2KHBhcmVudC0+b2JqZWN0LnNoYTEsCgkJCQkJCSAgYWJicmV2X2NvbW1pdCkpOwoJCXNob3dfZGVjb3JhdGlvbnMob3B0LCBjb21taXQpOwoJCXByaW50ZigiJXMiLCBkaWZmX2dldF9jb2xvcl9vcHQoJm9wdC0+ZGlmZm9wdCwgRElGRl9SRVNFVCkpOwoJCWlmIChvcHQtPmNvbW1pdF9mb3JtYXQgPT0gQ01JVF9GTVRfT05FTElORSkgewoJCQlwdXRjaGFyKCcgJyk7CgkJfSBlbHNlIHsKCQkJcHV0Y2hhcignXG4nKTsKCQkJZ3JhcGhfc2hvd19vbmVsaW5lKG9wdC0+Z3JhcGgpOwoJCX0KCQlpZiAob3B0LT5yZWZsb2dfaW5mbykgewoJCQkvKgoJCQkgKiBzZXR1cF9yZXZpc2lvbnMoKSBlbnN1cmVzIHRoYXQgb3B0LT5yZWZsb2dfaW5mbwoJCQkgKiBhbmQgb3B0LT5ncmFwaCBjYW5ub3QgYm90aCBiZSBzZXQsCgkJCSAqIHNvIHdlIGRvbid0IG5lZWQgdG8gd29ycnkgYWJvdXQgcHJpbnRpbmcgdGhlCgkJCSAqIGdyYXBoIGluZm8gaGVyZS4KCQkJICovCgkJCXNob3dfcmVmbG9nX21lc3NhZ2Uob3B0LT5yZWZsb2dfaW5mbywKCQkJCSAgICBvcHQtPmNvbW1pdF9mb3JtYXQgPT0gQ01JVF9GTVRfT05FTElORSwKCQkJCSAgICBvcHQtPmRhdGVfbW9kZV9leHBsaWNpdCA/CgkJCQkJb3B0LT5kYXRlX21vZGUgOgoJCQkJCURBVEVfTk9STUFMKTsKCQkJaWYgKG9wdC0+Y29tbWl0X2Zvcm1hdCA9PSBDTUlUX0ZNVF9PTkVMSU5FKQoJCQkJcmV0dXJuOwoJCX0KCX0KCglpZiAob3B0LT5zaG93X3NpZ25hdHVyZSkKCQlzaG93X3NpZ25hdHVyZShvcHQsIGNvbW1pdCk7CgoJaWYgKCFjb21taXQtPmJ1ZmZlcikKCQlyZXR1cm47CgoJLyoKCSAqIEFuZCB0aGVuIHRoZSBwcmV0dHktcHJpbnRlZCBtZXNzYWdlIGl0c2VsZgoJICovCglpZiAoY3R4Lm5lZWRfOGJpdF9jdGUgPj0gMCkKCQljdHgubmVlZF84Yml0X2N0ZSA9IGhhc19ub25fYXNjaWkob3B0LT5hZGRfc2lnbm9mZik7CgljdHguZGF0ZV9tb2RlID0gb3B0LT5kYXRlX21vZGU7CgljdHguYWJicmV2ID0gb3B0LT5kaWZmb3B0LmFiYnJldjsKCWN0eC5hZnRlcl9zdWJqZWN0ID0gZXh0cmFfaGVhZGVyczsKCWN0eC5wcmVzZXJ2ZV9zdWJqZWN0ID0gb3B0LT5wcmVzZXJ2ZV9zdWJqZWN0OwoJY3R4LnJlZmxvZ19pbmZvID0gb3B0LT5yZWZsb2dfaW5mbzsKCWN0eC5mbXQgPSBvcHQtPmNvbW1pdF9mb3JtYXQ7CglwcmV0dHlfcHJpbnRfY29tbWl0KCZjdHgsIGNvbW1pdCwgJm1zZ2J1Zik7CgoJaWYgKG9wdC0+YWRkX3NpZ25vZmYpCgkJYXBwZW5kX3NpZ25vZmYoJm1zZ2J1Ziwgb3B0LT5hZGRfc2lnbm9mZik7CglpZiAob3B0LT5zaG93X2xvZ19zaXplKSB7CgkJcHJpbnRmKCJsb2cgc2l6ZSAlaVxuIiwgKGludCltc2didWYubGVuKTsKCQlncmFwaF9zaG93X29uZWxpbmUob3B0LT5ncmFwaCk7Cgl9CgoJLyoKCSAqIFNldCBvcHQtPm1pc3NpbmdfbmV3bGluZSBpZiBtc2didWYgZG9lc24ndAoJICogZW5kIGluIGEgbmV3bGluZSAoaW5jbHVkaW5nIGlmIGl0IGlzIGVtcHR5KQoJICovCglpZiAoIW1zZ2J1Zi5sZW4gfHwgbXNnYnVmLmJ1Zlttc2didWYubGVuIC0gMV0gIT0gJ1xuJykKCQlvcHQtPm1pc3NpbmdfbmV3bGluZSA9IDE7CgllbHNlCgkJb3B0LT5taXNzaW5nX25ld2xpbmUgPSAwOwoKCWlmIChvcHQtPmdyYXBoKQoJCWdyYXBoX3Nob3dfY29tbWl0X21zZyhvcHQtPmdyYXBoLCAmbXNnYnVmKTsKCWVsc2UKCQlmd3JpdGUobXNnYnVmLmJ1Ziwgc2l6ZW9mKGNoYXIpLCBtc2didWYubGVuLCBzdGRvdXQpOwoJaWYgKG9wdC0+dXNlX3Rlcm1pbmF0b3IpIHsKCQlpZiAoIW9wdC0+bWlzc2luZ19uZXdsaW5lKQoJCQlncmFwaF9zaG93X3BhZGRpbmcob3B0LT5ncmFwaCk7CgkJcHV0Y2hhcignXG4nKTsKCX0KCglzdHJidWZfcmVsZWFzZSgmbXNnYnVmKTsKfQoKaW50IGxvZ190cmVlX2RpZmZfZmx1c2goc3RydWN0IHJldl9pbmZvICpvcHQpCnsKCWRpZmZjb3JlX3N0ZCgmb3B0LT5kaWZmb3B0KTsKCglpZiAoZGlmZl9xdWV1ZV9pc19lbXB0eSgpKSB7CgkJaW50IHNhdmVkX2ZtdCA9IG9wdC0+ZGlmZm9wdC5vdXRwdXRfZm9ybWF0OwoJCW9wdC0+ZGlmZm9wdC5vdXRwdXRfZm9ybWF0ID0gRElGRl9GT1JNQVRfTk9fT1VUUFVUOwoJCWRpZmZfZmx1c2goJm9wdC0+ZGlmZm9wdCk7CgkJb3B0LT5kaWZmb3B0Lm91dHB1dF9mb3JtYXQgPSBzYXZlZF9mbXQ7CgkJcmV0dXJuIDA7Cgl9CgoJaWYgKG9wdC0+bG9naW5mbyAmJiAhb3B0LT5ub19jb21taXRfaWQpIHsKCQkvKiBXaGVuIHNob3dpbmcgYSB2ZXJib3NlIGhlYWRlciAoaS5lLiBsb2cgbWVzc2FnZSksCgkJICogYW5kIG5vdCBpbiAtLXByZXR0eT1vbmVsaW5lIGZvcm1hdCwgd2Ugd291bGQgd2FudAoJCSAqIGFuIGV4dHJhIG5ld2xpbmUgYmV0d2VlbiB0aGUgZW5kIG9mIGxvZyBhbmQgdGhlCgkJICogb3V0cHV0IGZvciByZWFkYWJpbGl0eS4KCQkgKi8KCQlzaG93X2xvZyhvcHQpOwoJCWlmICgob3B0LT5kaWZmb3B0Lm91dHB1dF9mb3JtYXQgJiB+RElGRl9GT1JNQVRfTk9fT1VUUFVUKSAmJgoJCSAgICBvcHQtPnZlcmJvc2VfaGVhZGVyICYmCgkJICAgIG9wdC0+Y29tbWl0X2Zvcm1hdCAhPSBDTUlUX0ZNVF9PTkVMSU5FKSB7CgkJCWludCBwY2ggPSBESUZGX0ZPUk1BVF9ESUZGU1RBVCB8IERJRkZfRk9STUFUX1BBVENIOwoJCQlpZiAoKHBjaCAmIG9wdC0+ZGlmZm9wdC5vdXRwdXRfZm9ybWF0KSA9PSBwY2gpCgkJCQlwcmludGYoIi0tLSIpOwoJCQlpZiAob3B0LT5kaWZmb3B0Lm91dHB1dF9wcmVmaXgpIHsKCQkJCXN0cnVjdCBzdHJidWYgKm1zZyA9IE5VTEw7CgkJCQltc2cgPSBvcHQtPmRpZmZvcHQub3V0cHV0X3ByZWZpeCgmb3B0LT5kaWZmb3B0LAoJCQkJCW9wdC0+ZGlmZm9wdC5vdXRwdXRfcHJlZml4X2RhdGEpOwoJCQkJZndyaXRlKG1zZy0+YnVmLCBtc2ctPmxlbiwgMSwgc3Rkb3V0KTsKCQkJfQoJCQlwdXRjaGFyKCdcbicpOwoJCX0KCX0KCWRpZmZfZmx1c2goJm9wdC0+ZGlmZm9wdCk7CglyZXR1cm4gMTsKfQoKc3RhdGljIGludCBkb19kaWZmX2NvbWJpbmVkKHN0cnVjdCByZXZfaW5mbyAqb3B0LCBzdHJ1Y3QgY29tbWl0ICpjb21taXQpCnsKCXVuc2lnbmVkIGNvbnN0IGNoYXIgKnNoYTEgPSBjb21taXQtPm9iamVjdC5zaGExOwoKCWRpZmZfdHJlZV9jb21iaW5lZF9tZXJnZShzaGExLCBvcHQtPmRlbnNlX2NvbWJpbmVkX21lcmdlcywgb3B0KTsKCXJldHVybiAhb3B0LT5sb2dpbmZvOwp9CgovKgogKiBTaG93IHRoZSBkaWZmIG9mIGEgY29tbWl0LgogKgogKiBSZXR1cm4gdHJ1ZSBpZiB3ZSBwcmludGVkIGFueSBsb2cgaW5mbyBtZXNzYWdlcwogKi8Kc3RhdGljIGludCBsb2dfdHJlZV9kaWZmKHN0cnVjdCByZXZfaW5mbyAqb3B0LCBzdHJ1Y3QgY29tbWl0ICpjb21taXQsIHN0cnVjdCBsb2dfaW5mbyAqbG9nKQp7CglpbnQgc2hvd2VkX2xvZzsKCXN0cnVjdCBjb21taXRfbGlzdCAqcGFyZW50czsKCXVuc2lnbmVkIGNvbnN0IGNoYXIgKnNoYTEgPSBjb21taXQtPm9iamVjdC5zaGExOwoKCWlmICghb3B0LT5kaWZmICYmICFESUZGX09QVF9UU1QoJm9wdC0+ZGlmZm9wdCwgRVhJVF9XSVRIX1NUQVRVUykpCgkJcmV0dXJuIDA7CgoJLyogUm9vdCBjb21taXQ/ICovCglwYXJlbnRzID0gY29tbWl0LT5wYXJlbnRzOwoJaWYgKCFwYXJlbnRzKSB7CgkJaWYgKG9wdC0+c2hvd19yb290X2RpZmYpIHsKCQkJZGlmZl9yb290X3RyZWVfc2hhMShzaGExLCAiIiwgJm9wdC0+ZGlmZm9wdCk7CgkJCWxvZ190cmVlX2RpZmZfZmx1c2gob3B0KTsKCQl9CgkJcmV0dXJuICFvcHQtPmxvZ2luZm87Cgl9CgoJLyogTW9yZSB0aGFuIG9uZSBwYXJlbnQ/ICovCglpZiAocGFyZW50cyAmJiBwYXJlbnRzLT5uZXh0KSB7CgkJaWYgKG9wdC0+aWdub3JlX21lcmdlcykKCQkJcmV0dXJuIDA7CgkJZWxzZSBpZiAob3B0LT5jb21iaW5lX21lcmdlcykKCQkJcmV0dXJuIGRvX2RpZmZfY29tYmluZWQob3B0LCBjb21taXQpOwoJCWVsc2UgaWYgKG9wdC0+Zmlyc3RfcGFyZW50X29ubHkpIHsKCQkJLyoKCQkJICogR2VuZXJhdGUgbWVyZ2UgbG9nIGVudHJ5IG9ubHkgZm9yIHRoZSBmaXJzdAoJCQkgKiBwYXJlbnQsIHNob3dpbmcgc3VtbWFyeSBkaWZmIG9mIHRoZSBvdGhlcnMKCQkJICogd2UgbWVyZ2VkIF9pbl8uCgkJCSAqLwoJCQlkaWZmX3RyZWVfc2hhMShwYXJlbnRzLT5pdGVtLT5vYmplY3Quc2hhMSwgc2hhMSwgIiIsICZvcHQtPmRpZmZvcHQpOwoJCQlsb2dfdHJlZV9kaWZmX2ZsdXNoKG9wdCk7CgkJCXJldHVybiAhb3B0LT5sb2dpbmZvOwoJCX0KCgkJLyogSWYgd2Ugc2hvdyBpbmRpdmlkdWFsIGRpZmZzLCBzaG93IHRoZSBwYXJlbnQgaW5mbyAqLwoJCWxvZy0+cGFyZW50ID0gcGFyZW50cy0+aXRlbTsKCX0KCglzaG93ZWRfbG9nID0gMDsKCWZvciAoOzspIHsKCQlzdHJ1Y3QgY29tbWl0ICpwYXJlbnQgPSBwYXJlbnRzLT5pdGVtOwoKCQlkaWZmX3RyZWVfc2hhMShwYXJlbnQtPm9iamVjdC5zaGExLCBzaGExLCAiIiwgJm9wdC0+ZGlmZm9wdCk7CgkJbG9nX3RyZWVfZGlmZl9mbHVzaChvcHQpOwoKCQlzaG93ZWRfbG9nIHw9ICFvcHQtPmxvZ2luZm87CgoJCS8qIFNldCB1cCB0aGUgbG9nIGluZm8gZm9yIHRoZSBuZXh0IHBhcmVudCwgaWYgYW55Li4gKi8KCQlwYXJlbnRzID0gcGFyZW50cy0+bmV4dDsKCQlpZiAoIXBhcmVudHMpCgkJCWJyZWFrOwoJCWxvZy0+cGFyZW50ID0gcGFyZW50cy0+aXRlbTsKCQlvcHQtPmxvZ2luZm8gPSBsb2c7Cgl9CglyZXR1cm4gc2hvd2VkX2xvZzsKfQoKaW50IGxvZ190cmVlX2NvbW1pdChzdHJ1Y3QgcmV2X2luZm8gKm9wdCwgc3RydWN0IGNvbW1pdCAqY29tbWl0KQp7CglzdHJ1Y3QgbG9nX2luZm8gbG9nOwoJaW50IHNob3duOwoKCWxvZy5jb21taXQgPSBjb21taXQ7Cglsb2cucGFyZW50ID0gTlVMTDsKCW9wdC0+bG9naW5mbyA9ICZsb2c7CgoJc2hvd24gPSBsb2dfdHJlZV9kaWZmKG9wdCwgY29tbWl0LCAmbG9nKTsKCWlmICghc2hvd24gJiYgb3B0LT5sb2dpbmZvICYmIG9wdC0+YWx3YXlzX3Nob3dfaGVhZGVyKSB7CgkJbG9nLnBhcmVudCA9IE5VTEw7CgkJc2hvd19sb2cob3B0KTsKCQlzaG93biA9IDE7Cgl9CglvcHQtPmxvZ2luZm8gPSBOVUxMOwoJbWF5YmVfZmx1c2hfb3JfZGllKHN0ZG91dCwgInN0ZG91dCIpOwoJcmV0dXJuIHNob3duOwp9Cg==",
    "text": "#include \"cache.h\"\n#include \"diff.h\"\n#include \"commit.h\"\n#include \"tag.h\"\n#include \"graph.h\"\n#include \"log-tree.h\"\n#include \"reflog-walk.h\"\n#include \"refs.h\"\n#include \"string-list.h\"\n#include \"color.h\"\n#include \"gpg-interface.h\"\n\nstruct decoration name_decoration = { \"object names\" };\n\nenum decoration_type {\n\tDECORATION_NONE = 0,\n\tDECORATION_REF_LOCAL,\n\tDECORATION_REF_REMOTE,\n\tDECORATION_REF_TAG,\n\tDECORATION_REF_STASH,\n\tDECORATION_REF_HEAD,\n\tDECORATION_GRAFTED,\n};\n\nstatic char decoration_colors[][COLOR_MAXLEN] = {\n\tGIT_COLOR_RESET,\n\tGIT_COLOR_BOLD_GREEN,\t/* REF_LOCAL */\n\tGIT_COLOR_BOLD_RED,\t/* REF_REMOTE */\n\tGIT_COLOR_BOLD_YELLOW,\t/* REF_TAG */\n\tGIT_COLOR_BOLD_MAGENTA,\t/* REF_STASH */\n\tGIT_COLOR_BOLD_CYAN,\t/* REF_HEAD */\n\tGIT_COLOR_BOLD_BLUE,\t/* GRAFTED */\n};\n\nstatic const char *decorate_get_color(int decorate_use_color, enum decoration_type ix)\n{\n\tif (want_color(decorate_use_color))\n\t\treturn decoration_colors[ix];\n\treturn \"\";\n}\n\nstatic int parse_decorate_color_slot(const char *slot)\n{\n\t/*\n\t * We're comparing with 'ignore-case' on\n\t * (because config.c sets them all tolower),\n\t * but let's match the letters in the literal\n\t * string values here with how they are\n\t * documented in Documentation/config.txt, for\n\t * consistency.\n\t *\n\t * We love being consistent, don't we?\n\t */\n\tif (!strcasecmp(slot, \"branch\"))\n\t\treturn DECORATION_REF_LOCAL;\n\tif (!strcasecmp(slot, \"remoteBranch\"))\n\t\treturn DECORATION_REF_REMOTE;\n\tif (!strcasecmp(slot, \"tag\"))\n\t\treturn DECORATION_REF_TAG;\n\tif (!strcasecmp(slot, \"stash\"))\n\t\treturn DECORATION_REF_STASH;\n\tif (!strcasecmp(slot, \"HEAD\"))\n\t\treturn DECORATION_REF_HEAD;\n\treturn -1;\n}\n\nint parse_decorate_color_config(const char *var, const int ofs, const char *value)\n{\n\tint slot = parse_decorate_color_slot(var + ofs);\n\tif (slot < 0)\n\t\treturn 0;\n\tif (!value)\n\t\treturn config_error_nonbool(var);\n\tcolor_parse(value, var, decoration_colors[slot]);\n\treturn 0;\n}\n\n/*\n * log-tree.c uses DIFF_OPT_TST for determining whether to use color\n * for showing the commit sha1, use the same check for --decorate\n */\n#define decorate_get_color_opt(o, ix) \\\n\tdecorate_get_color((o)->use_color, ix)\n\nstatic void add_name_decoration(enum decoration_type type, const char *name, struct object *obj)\n{\n\tint nlen = strlen(name);\n\tstruct name_decoration *res = xmalloc(sizeof(struct name_decoration) + nlen);\n\tmemcpy(res->name, name, nlen + 1);\n\tres->type = type;\n\tres->next = add_decoration(&name_decoration, obj, res);\n}\n\nstatic int add_ref_decoration(const char *refname, const unsigned char *sha1, int flags, void *cb_data)\n{\n\tstruct object *obj;\n\tenum decoration_type type = DECORATION_NONE;\n\n\tif (!prefixcmp(refname, \"refs/replace/\")) {\n\t\tunsigned char original_sha1[20];\n\t\tif (!read_replace_refs)\n\t\t\treturn 0;\n\t\tif (get_sha1_hex(refname + 13, original_sha1)) {\n\t\t\twarning(\"invalid replace ref %s\", refname);\n\t\t\treturn 0;\n\t\t}\n\t\tobj = parse_object(original_sha1);\n\t\tif (obj)\n\t\t\tadd_name_decoration(DECORATION_GRAFTED, \"replaced\", obj);\n\t\treturn 0;\n\t}\n\n\tobj = parse_object(sha1);\n\tif (!obj)\n\t\treturn 0;\n\n\tif (!prefixcmp(refname, \"refs/heads/\"))\n\t\ttype = DECORATION_REF_LOCAL;\n\telse if (!prefixcmp(refname, \"refs/remotes/\"))\n\t\ttype = DECORATION_REF_REMOTE;\n\telse if (!prefixcmp(refname, \"refs/tags/\"))\n\t\ttype = DECORATION_REF_TAG;\n\telse if (!prefixcmp(refname, \"refs/stash\"))\n\t\ttype = DECORATION_REF_STASH;\n\telse if (!prefixcmp(refname, \"HEAD\"))\n\t\ttype = DECORATION_REF_HEAD;\n\n\tif (!cb_data || *(int *)cb_data == DECORATE_SHORT_REFS)\n\t\trefname = prettify_refname(refname);\n\tadd_name_decoration(type, refname, obj);\n\twhile (obj->type == OBJ_TAG) {\n\t\tobj = ((struct tag *)obj)->tagged;\n\t\tif (!obj)\n\t\t\tbreak;\n\t\tadd_name_decoration(DECORATION_REF_TAG, refname, obj);\n\t}\n\treturn 0;\n}\n\nstatic int add_graft_decoration(const struct commit_graft *graft, void *cb_data)\n{\n\tstruct commit *commit = lookup_commit(graft->sha1);\n\tif (!commit)\n\t\treturn 0;\n\tadd_name_decoration(DECORATION_GRAFTED, \"grafted\", &commit->object);\n\treturn 0;\n}\n\nvoid load_ref_decorations(int flags)\n{\n\tstatic int loaded;\n\tif (!loaded) {\n\t\tloaded = 1;\n\t\tfor_each_ref(add_ref_decoration, &flags);\n\t\thead_ref(add_ref_decoration, &flags);\n\t\tfor_each_commit_graft(add_graft_decoration, NULL);\n\t}\n}\n\nstatic void show_parents(struct commit *commit, int abbrev)\n{\n\tstruct commit_list *p;\n\tfor (p = commit->parents; p ; p = p->next) {\n\t\tstruct commit *parent = p->item;\n\t\tprintf(\" %s\", find_unique_abbrev(parent->object.sha1, abbrev));\n\t}\n}\n\nstatic void show_children(struct rev_info *opt, struct commit *commit, int abbrev)\n{\n\tstruct commit_list *p = lookup_decoration(&opt->children, &commit->object);\n\tfor ( ; p; p = p->next) {\n\t\tprintf(\" %s\", find_unique_abbrev(p->item->object.sha1, abbrev));\n\t}\n}\n\nvoid show_decorations(struct rev_info *opt, struct commit *commit)\n{\n\tconst char *prefix;\n\tstruct name_decoration *decoration;\n\tconst char *color_commit =\n\t\tdiff_get_color_opt(&opt->diffopt, DIFF_COMMIT);\n\tconst char *color_reset =\n\t\tdecorate_get_color_opt(&opt->diffopt, DECORATION_NONE);\n\n\tif (opt->show_source && commit->util)\n\t\tprintf(\"\\t%s\", (char *) commit->util);\n\tif (!opt->show_decorations)\n\t\treturn;\n\tdecoration = lookup_decoration(&name_decoration, &commit->object);\n\tif (!decoration)\n\t\treturn;\n\tprefix = \" (\";\n\twhile (decoration) {\n\t\tprintf(\"%s\", prefix);\n\t\tfputs(decorate_get_color_opt(&opt->diffopt, decoration->type),\n\t\t      stdout);\n\t\tif (decoration->type == DECORATION_REF_TAG)\n\t\t\tfputs(\"tag: \", stdout);\n\t\tprintf(\"%s\", decoration->name);\n\t\tfputs(color_reset, stdout);\n\t\tfputs(color_commit, stdout);\n\t\tprefix = \", \";\n\t\tdecoration = decoration->next;\n\t}\n\tputchar(')');\n}\n\n/*\n * Search for \"^[-A-Za-z]+: [^@]+@\" pattern. It usually matches\n * Signed-off-by: and Acked-by: lines.\n */\nstatic int detect_any_signoff(char *letter, int size)\n{\n\tchar *cp;\n\tint seen_colon = 0;\n\tint seen_at = 0;\n\tint seen_name = 0;\n\tint seen_head = 0;\n\n\tcp = letter + size;\n\twhile (letter <= --cp && *cp == '\\n')\n\t\tcontinue;\n\n\twhile (letter <= cp) {\n\t\tchar ch = *cp--;\n\t\tif (ch == '\\n')\n\t\t\tbreak;\n\n\t\tif (!seen_at) {\n\t\t\tif (ch == '@')\n\t\t\t\tseen_at = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!seen_colon) {\n\t\t\tif (ch == '@')\n\t\t\t\treturn 0;\n\t\t\telse if (ch == ':')\n\t\t\t\tseen_colon = 1;\n\t\t\telse\n\t\t\t\tseen_name = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (('A' <= ch && ch <= 'Z') ||\n\t\t    ('a' <= ch && ch <= 'z') ||\n\t\t    ch == '-') {\n\t\t\tseen_head = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/* no empty last line doesn't match */\n\t\treturn 0;\n\t}\n\treturn seen_head && seen_name;\n}\n\nstatic void append_signoff(struct strbuf *sb, const char *signoff)\n{\n\tstatic const char signed_off_by[] = \"Signed-off-by: \";\n\tsize_t signoff_len = strlen(signoff);\n\tint has_signoff = 0;\n\tchar *cp;\n\n\tcp = sb->buf;\n\n\t/* First see if we already have the sign-off by the signer */\n\twhile ((cp = strstr(cp, signed_off_by))) {\n\n\t\thas_signoff = 1;\n\n\t\tcp += strlen(signed_off_by);\n\t\tif (cp + signoff_len >= sb->buf + sb->len)\n\t\t\tbreak;\n\t\tif (strncmp(cp, signoff, signoff_len))\n\t\t\tcontinue;\n\t\tif (!isspace(cp[signoff_len]))\n\t\t\tcontinue;\n\t\t/* we already have him */\n\t\treturn;\n\t}\n\n\tif (!has_signoff)\n\t\thas_signoff = detect_any_signoff(sb->buf, sb->len);\n\n\tif (!has_signoff)\n\t\tstrbuf_addch(sb, '\\n');\n\n\tstrbuf_addstr(sb, signed_off_by);\n\tstrbuf_add(sb, signoff, signoff_len);\n\tstrbuf_addch(sb, '\\n');\n}\n\nstatic unsigned int digits_in_number(unsigned int number)\n{\n\tunsigned int i = 10, result = 1;\n\twhile (i <= number) {\n\t\ti *= 10;\n\t\tresult++;\n\t}\n\treturn result;\n}\n\nvoid get_patch_filename(struct commit *commit, int nr, const char *suffix,\n\t\t\tstruct strbuf *buf)\n{\n\tint suffix_len = strlen(suffix) + 1;\n\tint start_len = buf->len;\n\n\tstrbuf_addf(buf, commit ? \"%04d-\" : \"%d\", nr);\n\tif (commit) {\n\t\tint max_len = start_len + FORMAT_PATCH_NAME_MAX - suffix_len;\n\t\tstruct pretty_print_context ctx = {0};\n\t\tctx.date_mode = DATE_NORMAL;\n\n\t\tformat_commit_message(commit, \"%f\", buf, &ctx);\n\t\tif (max_len < buf->len)\n\t\t\tstrbuf_setlen(buf, max_len);\n\t\tstrbuf_addstr(buf, suffix);\n\t}\n}\n\nvoid log_write_email_headers(struct rev_info *opt, struct commit *commit,\n\t\t\t     const char **subject_p,\n\t\t\t     const char **extra_headers_p,\n\t\t\t     int *need_8bit_cte_p)\n{\n\tconst char *subject = NULL;\n\tconst char *extra_headers = opt->extra_headers;\n\tconst char *name = sha1_to_hex(commit->object.sha1);\n\n\t*need_8bit_cte_p = 0; /* unknown */\n\tif (opt->total > 0) {\n\t\tstatic char buffer[64];\n\t\tsnprintf(buffer, sizeof(buffer),\n\t\t\t \"Subject: [%s%s%0*d/%d] \",\n\t\t\t opt->subject_prefix,\n\t\t\t *opt->subject_prefix ? \" \" : \"\",\n\t\t\t digits_in_number(opt->total),\n\t\t\t opt->nr, opt->total);\n\t\tsubject = buffer;\n\t} else if (opt->total == 0 && opt->subject_prefix && *opt->subject_prefix) {\n\t\tstatic char buffer[256];\n\t\tsnprintf(buffer, sizeof(buffer),\n\t\t\t \"Subject: [%s] \",\n\t\t\t opt->subject_prefix);\n\t\tsubject = buffer;\n\t} else {\n\t\tsubject = \"Subject: \";\n\t}\n\n\tprintf(\"From %s Mon Sep 17 00:00:00 2001\\n\", name);\n\tgraph_show_oneline(opt->graph);\n\tif (opt->message_id) {\n\t\tprintf(\"Message-Id: <%s>\\n\", opt->message_id);\n\t\tgraph_show_oneline(opt->graph);\n\t}\n\tif (opt->ref_message_ids && opt->ref_message_ids->nr > 0) {\n\t\tint i, n;\n\t\tn = opt->ref_message_ids->nr;\n\t\tprintf(\"In-Reply-To: <%s>\\n\", opt->ref_message_ids->items[n-1].string);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tprintf(\"%s<%s>\\n\", (i > 0 ? \"\\t\" : \"References: \"),\n\t\t\t       opt->ref_message_ids->items[i].string);\n\t\tgraph_show_oneline(opt->graph);\n\t}\n\tif (opt->mime_boundary) {\n\t\tstatic char subject_buffer[1024];\n\t\tstatic char buffer[1024];\n\t\tstruct strbuf filename =  STRBUF_INIT;\n\t\t*need_8bit_cte_p = -1; /* NEVER */\n\t\tsnprintf(subject_buffer, sizeof(subject_buffer) - 1,\n\t\t\t \"%s\"\n\t\t\t \"MIME-Version: 1.0\\n\"\n\t\t\t \"Content-Type: multipart/mixed;\"\n\t\t\t \" boundary=\\\"%s%s\\\"\\n\"\n\t\t\t \"\\n\"\n\t\t\t \"This is a multi-part message in MIME \"\n\t\t\t \"format.\\n\"\n\t\t\t \"--%s%s\\n\"\n\t\t\t \"Content-Type: text/plain; \"\n\t\t\t \"charset=UTF-8; format=fixed\\n\"\n\t\t\t \"Content-Transfer-Encoding: 8bit\\n\\n\",\n\t\t\t extra_headers ? extra_headers : \"\",\n\t\t\t mime_boundary_leader, opt->mime_boundary,\n\t\t\t mime_boundary_leader, opt->mime_boundary);\n\t\textra_headers = subject_buffer;\n\n\t\tget_patch_filename(opt->numbered_files ? NULL : commit, opt->nr,\n\t\t\t\t    opt->patch_suffix, &filename);\n\t\tsnprintf(buffer, sizeof(buffer) - 1,\n\t\t\t \"\\n--%s%s\\n\"\n\t\t\t \"Content-Type: text/x-patch;\"\n\t\t\t \" name=\\\"%s\\\"\\n\"\n\t\t\t \"Content-Transfer-Encoding: 8bit\\n\"\n\t\t\t \"Content-Disposition: %s;\"\n\t\t\t \" filename=\\\"%s\\\"\\n\\n\",\n\t\t\t mime_boundary_leader, opt->mime_boundary,\n\t\t\t filename.buf,\n\t\t\t opt->no_inline ? \"attachment\" : \"inline\",\n\t\t\t filename.buf);\n\t\topt->diffopt.stat_sep = buffer;\n\t\tstrbuf_release(&filename);\n\t}\n\t*subject_p = subject;\n\t*extra_headers_p = extra_headers;\n}\n\nstatic void show_sig_lines(struct rev_info *opt, int status, const char *bol)\n{\n\tconst char *color, *reset, *eol;\n\n\tcolor = diff_get_color_opt(&opt->diffopt,\n\t\t\t\t   status ? DIFF_WHITESPACE : DIFF_FRAGINFO);\n\treset = diff_get_color_opt(&opt->diffopt, DIFF_RESET);\n\twhile (*bol) {\n\t\teol = strchrnul(bol, '\\n');\n\t\tprintf(\"%s%.*s%s%s\", color, (int)(eol - bol), bol, reset,\n\t\t       *eol ? \"\\n\" : \"\");\n\t\tbol = (*eol) ? (eol + 1) : eol;\n\t}\n}\n\nstatic void show_signature(struct rev_info *opt, struct commit *commit)\n{\n\tstruct strbuf payload = STRBUF_INIT;\n\tstruct strbuf signature = STRBUF_INIT;\n\tstruct strbuf gpg_output = STRBUF_INIT;\n\tint status;\n\n\tif (parse_signed_commit(commit->object.sha1, &payload, &signature) <= 0)\n\t\tgoto out;\n\n\tstatus = verify_signed_buffer(payload.buf, payload.len,\n\t\t\t\t      signature.buf, signature.len,\n\t\t\t\t      &gpg_output);\n\tif (status && !gpg_output.len)\n\t\tstrbuf_addstr(&gpg_output, \"No signature\\n\");\n\n\tshow_sig_lines(opt, status, gpg_output.buf);\n\n out:\n\tstrbuf_release(&gpg_output);\n\tstrbuf_release(&payload);\n\tstrbuf_release(&signature);\n}\n\nvoid show_log(struct rev_info *opt)\n{\n\tstruct strbuf msgbuf = STRBUF_INIT;\n\tstruct log_info *log = opt->loginfo;\n\tstruct commit *commit = log->commit, *parent = log->parent;\n\tint abbrev_commit = opt->abbrev_commit ? opt->abbrev : 40;\n\tconst char *extra_headers = opt->extra_headers;\n\tstruct pretty_print_context ctx = {0};\n\n\topt->loginfo = NULL;\n\tctx.show_notes = opt->show_notes;\n\tif (!opt->verbose_header) {\n\t\tgraph_show_commit(opt->graph);\n\n\t\tif (!opt->graph)\n\t\t\tput_revision_mark(opt, commit);\n\t\tfputs(find_unique_abbrev(commit->object.sha1, abbrev_commit), stdout);\n\t\tif (opt->print_parents)\n\t\t\tshow_parents(commit, abbrev_commit);\n\t\tif (opt->children.name)\n\t\t\tshow_children(opt, commit, abbrev_commit);\n\t\tshow_decorations(opt, commit);\n\t\tif (opt->graph && !graph_is_commit_finished(opt->graph)) {\n\t\t\tputchar('\\n');\n\t\t\tgraph_show_remainder(opt->graph);\n\t\t}\n\t\tputchar(opt->diffopt.line_termination);\n\t\treturn;\n\t}\n\n\t/*\n\t * If use_terminator is set, we already handled any record termination\n\t * at the end of the last record.\n\t * Otherwise, add a diffopt.line_termination character before all\n\t * entries but the first.  (IOW, as a separator between entries)\n\t */\n\tif (opt->shown_one && !opt->use_terminator) {\n\t\t/*\n\t\t * If entries are separated by a newline, the output\n\t\t * should look human-readable.  If the last entry ended\n\t\t * with a newline, print the graph output before this\n\t\t * newline.  Otherwise it will end up as a completely blank\n\t\t * line and will look like a gap in the graph.\n\t\t *\n\t\t * If the entry separator is not a newline, the output is\n\t\t * primarily intended for programmatic consumption, and we\n\t\t * never want the extra graph output before the entry\n\t\t * separator.\n\t\t */\n\t\tif (opt->diffopt.line_termination == '\\n' &&\n\t\t    !opt->missing_newline)\n\t\t\tgraph_show_padding(opt->graph);\n\t\tputchar(opt->diffopt.line_termination);\n\t}\n\topt->shown_one = 1;\n\n\t/*\n\t * If the history graph was requested,\n\t * print the graph, up to this commit's line\n\t */\n\tgraph_show_commit(opt->graph);\n\n\t/*\n\t * Print header line of header..\n\t */\n\n\tif (opt->commit_format == CMIT_FMT_EMAIL) {\n\t\tlog_write_email_headers(opt, commit, &ctx.subject, &extra_headers,\n\t\t\t\t\t&ctx.need_8bit_cte);\n\t} else if (opt->commit_format != CMIT_FMT_USERFORMAT) {\n\t\tfputs(diff_get_color_opt(&opt->diffopt, DIFF_COMMIT), stdout);\n\t\tif (opt->commit_format != CMIT_FMT_ONELINE)\n\t\t\tfputs(\"commit \", stdout);\n\n\t\tif (!opt->graph)\n\t\t\tput_revision_mark(opt, commit);\n\t\tfputs(find_unique_abbrev(commit->object.sha1, abbrev_commit),\n\t\t      stdout);\n\t\tif (opt->print_parents)\n\t\t\tshow_parents(commit, abbrev_commit);\n\t\tif (opt->children.name)\n\t\t\tshow_children(opt, commit, abbrev_commit);\n\t\tif (parent)\n\t\t\tprintf(\" (from %s)\",\n\t\t\t       find_unique_abbrev(parent->object.sha1,\n\t\t\t\t\t\t  abbrev_commit));\n\t\tshow_decorations(opt, commit);\n\t\tprintf(\"%s\", diff_get_color_opt(&opt->diffopt, DIFF_RESET));\n\t\tif (opt->commit_format == CMIT_FMT_ONELINE) {\n\t\t\tputchar(' ');\n\t\t} else {\n\t\t\tputchar('\\n');\n\t\t\tgraph_show_oneline(opt->graph);\n\t\t}\n\t\tif (opt->reflog_info) {\n\t\t\t/*\n\t\t\t * setup_revisions() ensures that opt->reflog_info\n\t\t\t * and opt->graph cannot both be set,\n\t\t\t * so we don't need to worry about printing the\n\t\t\t * graph info here.\n\t\t\t */\n\t\t\tshow_reflog_message(opt->reflog_info,\n\t\t\t\t    opt->commit_format == CMIT_FMT_ONELINE,\n\t\t\t\t    opt->date_mode_explicit ?\n\t\t\t\t\topt->date_mode :\n\t\t\t\t\tDATE_NORMAL);\n\t\t\tif (opt->commit_format == CMIT_FMT_ONELINE)\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\tif (opt->show_signature)\n\t\tshow_signature(opt, commit);\n\n\tif (!commit->buffer)\n\t\treturn;\n\n\t/*\n\t * And then the pretty-printed message itself\n\t */\n\tif (ctx.need_8bit_cte >= 0)\n\t\tctx.need_8bit_cte = has_non_ascii(opt->add_signoff);\n\tctx.date_mode = opt->date_mode;\n\tctx.abbrev = opt->diffopt.abbrev;\n\tctx.after_subject = extra_headers;\n\tctx.preserve_subject = opt->preserve_subject;\n\tctx.reflog_info = opt->reflog_info;\n\tctx.fmt = opt->commit_format;\n\tpretty_print_commit(&ctx, commit, &msgbuf);\n\n\tif (opt->add_signoff)\n\t\tappend_signoff(&msgbuf, opt->add_signoff);\n\tif (opt->show_log_size) {\n\t\tprintf(\"log size %i\\n\", (int)msgbuf.len);\n\t\tgraph_show_oneline(opt->graph);\n\t}\n\n\t/*\n\t * Set opt->missing_newline if msgbuf doesn't\n\t * end in a newline (including if it is empty)\n\t */\n\tif (!msgbuf.len || msgbuf.buf[msgbuf.len - 1] != '\\n')\n\t\topt->missing_newline = 1;\n\telse\n\t\topt->missing_newline = 0;\n\n\tif (opt->graph)\n\t\tgraph_show_commit_msg(opt->graph, &msgbuf);\n\telse\n\t\tfwrite(msgbuf.buf, sizeof(char), msgbuf.len, stdout);\n\tif (opt->use_terminator) {\n\t\tif (!opt->missing_newline)\n\t\t\tgraph_show_padding(opt->graph);\n\t\tputchar('\\n');\n\t}\n\n\tstrbuf_release(&msgbuf);\n}\n\nint log_tree_diff_flush(struct rev_info *opt)\n{\n\tdiffcore_std(&opt->diffopt);\n\n\tif (diff_queue_is_empty()) {\n\t\tint saved_fmt = opt->diffopt.output_format;\n\t\topt->diffopt.output_format = DIFF_FORMAT_NO_OUTPUT;\n\t\tdiff_flush(&opt->diffopt);\n\t\topt->diffopt.output_format = saved_fmt;\n\t\treturn 0;\n\t}\n\n\tif (opt->loginfo && !opt->no_commit_id) {\n\t\t/* When showing a verbose header (i.e. log message),\n\t\t * and not in --pretty=oneline format, we would want\n\t\t * an extra newline between the end of log and the\n\t\t * output for readability.\n\t\t */\n\t\tshow_log(opt);\n\t\tif ((opt->diffopt.output_format & ~DIFF_FORMAT_NO_OUTPUT) &&\n\t\t    opt->verbose_header &&\n\t\t    opt->commit_format != CMIT_FMT_ONELINE) {\n\t\t\tint pch = DIFF_FORMAT_DIFFSTAT | DIFF_FORMAT_PATCH;\n\t\t\tif ((pch & opt->diffopt.output_format) == pch)\n\t\t\t\tprintf(\"---\");\n\t\t\tif (opt->diffopt.output_prefix) {\n\t\t\t\tstruct strbuf *msg = NULL;\n\t\t\t\tmsg = opt->diffopt.output_prefix(&opt->diffopt,\n\t\t\t\t\topt->diffopt.output_prefix_data);\n\t\t\t\tfwrite(msg->buf, msg->len, 1, stdout);\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\t}\n\tdiff_flush(&opt->diffopt);\n\treturn 1;\n}\n\nstatic int do_diff_combined(struct rev_info *opt, struct commit *commit)\n{\n\tunsigned const char *sha1 = commit->object.sha1;\n\n\tdiff_tree_combined_merge(sha1, opt->dense_combined_merges, opt);\n\treturn !opt->loginfo;\n}\n\n/*\n * Show the diff of a commit.\n *\n * Return true if we printed any log info messages\n */\nstatic int log_tree_diff(struct rev_info *opt, struct commit *commit, struct log_info *log)\n{\n\tint showed_log;\n\tstruct commit_list *parents;\n\tunsigned const char *sha1 = commit->object.sha1;\n\n\tif (!opt->diff && !DIFF_OPT_TST(&opt->diffopt, EXIT_WITH_STATUS))\n\t\treturn 0;\n\n\t/* Root commit? */\n\tparents = commit->parents;\n\tif (!parents) {\n\t\tif (opt->show_root_diff) {\n\t\t\tdiff_root_tree_sha1(sha1, \"\", &opt->diffopt);\n\t\t\tlog_tree_diff_flush(opt);\n\t\t}\n\t\treturn !opt->loginfo;\n\t}\n\n\t/* More than one parent? */\n\tif (parents && parents->next) {\n\t\tif (opt->ignore_merges)\n\t\t\treturn 0;\n\t\telse if (opt->combine_merges)\n\t\t\treturn do_diff_combined(opt, commit);\n\t\telse if (opt->first_parent_only) {\n\t\t\t/*\n\t\t\t * Generate merge log entry only for the first\n\t\t\t * parent, showing summary diff of the others\n\t\t\t * we merged _in_.\n\t\t\t */\n\t\t\tdiff_tree_sha1(parents->item->object.sha1, sha1, \"\", &opt->diffopt);\n\t\t\tlog_tree_diff_flush(opt);\n\t\t\treturn !opt->loginfo;\n\t\t}\n\n\t\t/* If we show individual diffs, show the parent info */\n\t\tlog->parent = parents->item;\n\t}\n\n\tshowed_log = 0;\n\tfor (;;) {\n\t\tstruct commit *parent = parents->item;\n\n\t\tdiff_tree_sha1(parent->object.sha1, sha1, \"\", &opt->diffopt);\n\t\tlog_tree_diff_flush(opt);\n\n\t\tshowed_log |= !opt->loginfo;\n\n\t\t/* Set up the log info for the next parent, if any.. */\n\t\tparents = parents->next;\n\t\tif (!parents)\n\t\t\tbreak;\n\t\tlog->parent = parents->item;\n\t\topt->loginfo = log;\n\t}\n\treturn showed_log;\n}\n\nint log_tree_commit(struct rev_info *opt, struct commit *commit)\n{\n\tstruct log_info log;\n\tint shown;\n\n\tlog.commit = commit;\n\tlog.parent = NULL;\n\topt->loginfo = &log;\n\n\tshown = log_tree_diff(opt, commit, &log);\n\tif (!shown && opt->loginfo && opt->always_show_header) {\n\t\tlog.parent = NULL;\n\t\tshow_log(opt);\n\t\tshown = 1;\n\t}\n\topt->loginfo = NULL;\n\tmaybe_flush_or_die(stdout, \"stdout\");\n\treturn shown;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "005c5a51c08b046ed62034deeef0ea42967b1c1a",
  "sha1_ok": true,
  "size": 19435
}
