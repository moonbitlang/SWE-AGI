{
  "content": {
    "base64": "I2lmbmRlZiBDQUNIRV9ICiNkZWZpbmUgQ0FDSEVfSAoKI2luY2x1ZGUgPHN0ZGlvLmg+CiNpbmNsdWRlIDxzeXMvc3RhdC5oPgojaW5jbHVkZSA8ZmNudGwuaD4KI2luY2x1ZGUgPHN0ZGRlZi5oPgojaW5jbHVkZSA8c3RkbGliLmg+CiNpbmNsdWRlIDxzdGRhcmcuaD4KI2luY2x1ZGUgPHN0cmluZy5oPgojaW5jbHVkZSA8ZXJybm8uaD4KI2luY2x1ZGUgPHN5cy9tbWFuLmg+CgojaW5jbHVkZSA8b3BlbnNzbC9zaGEuaD4KI2luY2x1ZGUgPHpsaWIuaD4KCi8qCiAqIEJhc2ljIGRhdGEgc3RydWN0dXJlcyBmb3IgdGhlIGRpcmVjdG9yeSBjYWNoZQogKgogKiBOT1RFIE5PVEUgTk9URSEgVGhpcyBpcyBhbGwgaW4gdGhlIG5hdGl2ZSBDUFUgYnl0ZSBmb3JtYXQuIEl0J3MKICogbm90IGV2ZW4gdHJ5aW5nIHRvIGJlIHBvcnRhYmxlLiBJdCdzIHRyeWluZyB0byBiZSBlZmZpY2llbnQuIEl0J3MKICoganVzdCBhIGNhY2hlLCBhZnRlciBhbGwuCiAqLwoKI2RlZmluZSBDQUNIRV9TSUdOQVRVUkUgMHg0NDQ5NTI0MwkvKiAiRElSQyIgKi8Kc3RydWN0IGNhY2hlX2hlYWRlciB7Cgl1bnNpZ25lZCBpbnQgc2lnbmF0dXJlOwoJdW5zaWduZWQgaW50IHZlcnNpb247Cgl1bnNpZ25lZCBpbnQgZW50cmllczsKCXVuc2lnbmVkIGNoYXIgc2hhMVsyMF07Cn07CgovKgogKiBUaGUgImNhY2hlX3RpbWUiIGlzIGp1c3QgdGhlIGxvdyAzMiBiaXRzIG9mIHRoZQogKiB0aW1lLiBJdCBkb2Vzbid0IG1hdHRlciBpZiBpdCBvdmVyZmxvd3MgLSB3ZSBvbmx5CiAqIGNoZWNrIGl0IGZvciBlcXVhbGl0eSBpbiB0aGUgMzIgYml0cyB3ZSBzYXZlLgogKi8Kc3RydWN0IGNhY2hlX3RpbWUgewoJdW5zaWduZWQgaW50IHNlYzsKCXVuc2lnbmVkIGludCBuc2VjOwp9OwoKLyoKICogZGV2L2luby91aWQvZ2lkL3NpemUgYXJlIGFsc28ganVzdCB0cmFja2VkIHRvIHRoZSBsb3cgMzIgYml0cwogKiBBZ2FpbiAtIHRoaXMgaXMganVzdCBhICh2ZXJ5IHN0cm9uZyBpbiBwcmFjdGljZSkgaGV1cmlzdGljIHRoYXQKICogdGhlIGlub2RlIGhhc24ndCBjaGFuZ2VkLgogKi8Kc3RydWN0IGNhY2hlX2VudHJ5IHsKCXN0cnVjdCBjYWNoZV90aW1lIGN0aW1lOwoJc3RydWN0IGNhY2hlX3RpbWUgbXRpbWU7Cgl1bnNpZ25lZCBpbnQgc3RfZGV2OwoJdW5zaWduZWQgaW50IHN0X2lubzsKCXVuc2lnbmVkIGludCBzdF9tb2RlOwoJdW5zaWduZWQgaW50IHN0X3VpZDsKCXVuc2lnbmVkIGludCBzdF9naWQ7Cgl1bnNpZ25lZCBpbnQgc3Rfc2l6ZTsKCXVuc2lnbmVkIGNoYXIgc2hhMVsyMF07Cgl1bnNpZ25lZCBzaG9ydCBuYW1lbGVuOwoJY2hhciBuYW1lWzBdOwp9OwoKY29uc3QgY2hhciAqc2hhMV9maWxlX2RpcmVjdG9yeTsKc3RydWN0IGNhY2hlX2VudHJ5ICoqYWN0aXZlX2NhY2hlOwp1bnNpZ25lZCBpbnQgYWN0aXZlX25yLCBhY3RpdmVfYWxsb2M7CgojZGVmaW5lIERCX0VOVklST05NRU5UICJTSEExX0ZJTEVfRElSRUNUT1JZIgojZGVmaW5lIERFRkFVTFRfREJfRU5WSVJPTk1FTlQgIi5kaXJjYWNoZS9vYmplY3RzIgoKI2RlZmluZSBjYWNoZV9lbnRyeV9zaXplKGxlbikgKChvZmZzZXRvZihzdHJ1Y3QgY2FjaGVfZW50cnksbmFtZSkgKyAobGVuKSArIDgpICYgfjcpCiNkZWZpbmUgY2Vfc2l6ZShjZSkgY2FjaGVfZW50cnlfc2l6ZSgoY2UpLT5uYW1lbGVuKQoKI2RlZmluZSBhbGxvY19ucih4KSAoKCh4KSsxNikqMy8yKQoKLyogSW5pdGlhbGl6ZSBhbmQgdXNlIHRoZSBjYWNoZSBpbmZvcm1hdGlvbiAqLwpleHRlcm4gaW50IHJlYWRfY2FjaGUodm9pZCk7CmV4dGVybiBpbnQgY2FjaGVfbmFtZV9wb3MoY29uc3QgY2hhciAqbmFtZSwgaW50IG5hbWVsZW4pOwpleHRlcm4gaW50IGNhY2hlX21hdGNoX3N0YXQoc3RydWN0IGNhY2hlX2VudHJ5ICpjZSwgc3RydWN0IHN0YXQgKnN0KTsKCiNkZWZpbmUgTVRJTUVfQ0hBTkdFRAkweDAwMDEKI2RlZmluZSBDVElNRV9DSEFOR0VECTB4MDAwMgojZGVmaW5lIE9XTkVSX0NIQU5HRUQJMHgwMDA0CiNkZWZpbmUgTU9ERV9DSEFOR0VEICAgIDB4MDAwOAojZGVmaW5lIElOT0RFX0NIQU5HRUQgICAweDAwMTAKI2RlZmluZSBEQVRBX0NIQU5HRUQgICAgMHgwMDIwCgovKiBSZXR1cm4gYSBzdGF0aWNhbGx5IGFsbG9jYXRlZCBmaWxlbmFtZSBtYXRjaGluZyB0aGUgc2hhMSBzaWduYXR1cmUgKi8KZXh0ZXJuIGNoYXIgKnNoYTFfZmlsZV9uYW1lKHVuc2lnbmVkIGNoYXIgKnNoYTEpOwoKLyogV3JpdGUgYSBtZW1vcnkgYnVmZmVyIG91dCB0byB0aGUgc2hhIGZpbGUgKi8KZXh0ZXJuIGludCB3cml0ZV9zaGExX2J1ZmZlcih1bnNpZ25lZCBjaGFyICpzaGExLCB2b2lkICpidWYsIHVuc2lnbmVkIGludCBzaXplKTsKCi8qIFJlYWQgYW5kIHVucGFjayBhIHNoYTEgZmlsZSBpbnRvIG1lbW9yeSwgd3JpdGUgbWVtb3J5IHRvIGEgc2hhMSBmaWxlICovCmV4dGVybiB2b2lkICogbWFwX3NoYTFfZmlsZSh1bnNpZ25lZCBjaGFyICpzaGExLCB1bnNpZ25lZCBsb25nICpzaXplKTsKZXh0ZXJuIHZvaWQgKiB1bnBhY2tfc2hhMV9maWxlKHZvaWQgKm1hcCwgdW5zaWduZWQgbG9uZyBtYXBzaXplLCBjaGFyICp0eXBlLCB1bnNpZ25lZCBsb25nICpzaXplKTsKZXh0ZXJuIHZvaWQgKiByZWFkX3NoYTFfZmlsZSh1bnNpZ25lZCBjaGFyICpzaGExLCBjaGFyICp0eXBlLCB1bnNpZ25lZCBsb25nICpzaXplKTsKZXh0ZXJuIGludCB3cml0ZV9zaGExX2ZpbGUoY2hhciAqYnVmLCB1bnNpZ25lZCBsZW4pOwpleHRlcm4gaW50IGNoZWNrX3NoYTFfc2lnbmF0dXJlKHVuc2lnbmVkIGNoYXIgKnNoYTEsIHZvaWQgKmJ1ZiwgdW5zaWduZWQgbG9uZyBzaXplKTsKCi8qIENvbnZlcnQgdG8vZnJvbSBoZXgvc2hhMSByZXByZXNlbnRhdGlvbiAqLwpleHRlcm4gaW50IGdldF9zaGExX2hleChjaGFyICpoZXgsIHVuc2lnbmVkIGNoYXIgKnNoYTEpOwpleHRlcm4gY2hhciAqc2hhMV90b19oZXgodW5zaWduZWQgY2hhciAqc2hhMSk7CS8qIHN0YXRpYyBidWZmZXIhICovCgovKiBHZW5lcmFsIGhlbHBlciBmdW5jdGlvbnMgKi8KZXh0ZXJuIHZvaWQgdXNhZ2UoY29uc3QgY2hhciAqZXJyKTsKCiNlbmRpZiAvKiBDQUNIRV9IICovCg==",
    "text": "#ifndef CACHE_H\n#define CACHE_H\n\n#include <stdio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/mman.h>\n\n#include <openssl/sha.h>\n#include <zlib.h>\n\n/*\n * Basic data structures for the directory cache\n *\n * NOTE NOTE NOTE! This is all in the native CPU byte format. It's\n * not even trying to be portable. It's trying to be efficient. It's\n * just a cache, after all.\n */\n\n#define CACHE_SIGNATURE 0x44495243\t/* \"DIRC\" */\nstruct cache_header {\n\tunsigned int signature;\n\tunsigned int version;\n\tunsigned int entries;\n\tunsigned char sha1[20];\n};\n\n/*\n * The \"cache_time\" is just the low 32 bits of the\n * time. It doesn't matter if it overflows - we only\n * check it for equality in the 32 bits we save.\n */\nstruct cache_time {\n\tunsigned int sec;\n\tunsigned int nsec;\n};\n\n/*\n * dev/ino/uid/gid/size are also just tracked to the low 32 bits\n * Again - this is just a (very strong in practice) heuristic that\n * the inode hasn't changed.\n */\nstruct cache_entry {\n\tstruct cache_time ctime;\n\tstruct cache_time mtime;\n\tunsigned int st_dev;\n\tunsigned int st_ino;\n\tunsigned int st_mode;\n\tunsigned int st_uid;\n\tunsigned int st_gid;\n\tunsigned int st_size;\n\tunsigned char sha1[20];\n\tunsigned short namelen;\n\tchar name[0];\n};\n\nconst char *sha1_file_directory;\nstruct cache_entry **active_cache;\nunsigned int active_nr, active_alloc;\n\n#define DB_ENVIRONMENT \"SHA1_FILE_DIRECTORY\"\n#define DEFAULT_DB_ENVIRONMENT \".dircache/objects\"\n\n#define cache_entry_size(len) ((offsetof(struct cache_entry,name) + (len) + 8) & ~7)\n#define ce_size(ce) cache_entry_size((ce)->namelen)\n\n#define alloc_nr(x) (((x)+16)*3/2)\n\n/* Initialize and use the cache information */\nextern int read_cache(void);\nextern int cache_name_pos(const char *name, int namelen);\nextern int cache_match_stat(struct cache_entry *ce, struct stat *st);\n\n#define MTIME_CHANGED\t0x0001\n#define CTIME_CHANGED\t0x0002\n#define OWNER_CHANGED\t0x0004\n#define MODE_CHANGED    0x0008\n#define INODE_CHANGED   0x0010\n#define DATA_CHANGED    0x0020\n\n/* Return a statically allocated filename matching the sha1 signature */\nextern char *sha1_file_name(unsigned char *sha1);\n\n/* Write a memory buffer out to the sha file */\nextern int write_sha1_buffer(unsigned char *sha1, void *buf, unsigned int size);\n\n/* Read and unpack a sha1 file into memory, write memory to a sha1 file */\nextern void * map_sha1_file(unsigned char *sha1, unsigned long *size);\nextern void * unpack_sha1_file(void *map, unsigned long mapsize, char *type, unsigned long *size);\nextern void * read_sha1_file(unsigned char *sha1, char *type, unsigned long *size);\nextern int write_sha1_file(char *buf, unsigned len);\nextern int check_sha1_signature(unsigned char *sha1, void *buf, unsigned long size);\n\n/* Convert to/from hex/sha1 representation */\nextern int get_sha1_hex(char *hex, unsigned char *sha1);\nextern char *sha1_to_hex(unsigned char *sha1);\t/* static buffer! */\n\n/* General helper functions */\nextern void usage(const char *err);\n\n#endif /* CACHE_H */\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0038e8b8e04b287ec876594cbab9df4af09ce131",
  "sha1_ok": true,
  "size": 3067
}
