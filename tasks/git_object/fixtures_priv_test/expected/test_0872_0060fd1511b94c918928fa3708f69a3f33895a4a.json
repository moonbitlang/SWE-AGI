{
  "content": {
    "headers": [
      "tree 76a4143aaa6dd8327473a8002d12817681dadfd6",
      "parent a52ed76142f6e8d993bb4c50938a408966eb2b7c",
      "author Johannes Schindelin <johannes.schindelin@gmx.de> 1568290839 +0200",
      "committer Johannes Schindelin <johannes.schindelin@gmx.de> 1575462005 +0100"
    ],
    "message": "clone --recurse-submodules: prevent name squatting on Windows\n\nIn addition to preventing `.git` from being tracked by Git, on Windows\nwe also have to prevent `git~1` from being tracked, as the default NTFS\nshort name (also known as the \"8.3 filename\") for the file name `.git`\nis `git~1`, otherwise it would be possible for malicious repositories to\nwrite directly into the `.git/` directory, e.g. a `post-checkout` hook\nthat would then be executed _during_ a recursive clone.\n\nWhen we implemented appropriate protections in 2b4c6efc821 (read-cache:\noptionally disallow NTFS .git variants, 2014-12-16), we had analyzed\ncarefully that the `.git` directory or file would be guaranteed to be\nthe first directory entry to be written. Otherwise it would be possible\ne.g. for a file named `..git` to be assigned the short name `git~1` and\nsubsequently, the short name generated for `.git` would be `git~2`. Or\n`git~3`. Or even `~9999999` (for a detailed explanation of the lengths\nwe have to go to protect `.gitmodules`, see the commit message of\ne7cb0b4455c (is_ntfs_dotgit: match other .git files, 2018-05-11)).\n\nHowever, by exploiting two issues (that will be addressed in a related\npatch series close by), it is currently possible to clone a submodule\ninto a non-empty directory:\n\n- On Windows, file names cannot end in a space or a period (for\n  historical reasons: the period separating the base name from the file\n  extension was not actually written to disk, and the base name/file\n  extension was space-padded to the full 8/3 characters, respectively).\n  Helpfully, when creating a directory under the name, say, `sub.`, that\n  trailing period is trimmed automatically and the actual name on disk\n  is `sub`.\n\n  This means that while Git thinks that the submodule names `sub` and\n  `sub.` are different, they both access `.git/modules/sub/`.\n\n- While the backslash character is a valid file name character on Linux,\n  it is not so on Windows. As Git tries to be cross-platform, it\n  therefore allows backslash characters in the file names stored in tree\n  objects.\n\n  Which means that it is totally possible that a submodule `c` sits next\n  to a file `c\\..git`, and on Windows, during recursive clone a file\n  called `..git` will be written into `c/`, of course _before_ the\n  submodule is cloned.\n\nNote that the actual exploit is not quite as simple as having a\nsubmodule `c` next to a file `c\\..git`, as we have to make sure that the\ndirectory `.git/modules/b` already exists when the submodule is checked\nout, otherwise a different code path is taken in `module_clone()` that\ndoes _not_ allow a non-empty submodule directory to exist already.\n\nEven if we will address both issues nearby (the next commit will\ndisallow backslash characters in tree entries' file names on Windows,\nand another patch will disallow creating directories/files with trailing\nspaces or periods), it is a wise idea to defend in depth against this\nsort of attack vector: when submodules are cloned recursively, we now\n_require_ the directory to be empty, addressing CVE-2019-1349.\n\nNote: the code path we patch is shared with the code path of `git\nsubmodule update --init`, which must not expect, in general, that the\ndirectory is empty. Hence we have to introduce the new option\n`--force-init` and hand it all the way down from `git submodule` to the\nactual `git submodule--helper` process that performs the initial clone.\n\nReported-by: Nicolas Joly <Nicolas.Joly@microsoft.com>\nSigned-off-by: Johannes Schindelin <johannes.schindelin@gmx.de>\n",
    "type": "commit"
  },
  "kind": "commit",
  "oid": "0060fd1511b94c918928fa3708f69a3f33895a4a",
  "sha1_ok": true,
  "size": 3768
}
