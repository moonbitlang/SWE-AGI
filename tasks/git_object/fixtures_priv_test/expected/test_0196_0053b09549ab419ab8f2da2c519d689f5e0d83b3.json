{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJjb25maWcuaCIKI2luY2x1ZGUgInJlbW90ZS5oIgojaW5jbHVkZSAic3RyYnVmLmgiCiNpbmNsdWRlICJ3YWxrZXIuaCIKI2luY2x1ZGUgImh0dHAuaCIKI2luY2x1ZGUgImV4ZWNfY21kLmgiCiNpbmNsdWRlICJydW4tY29tbWFuZC5oIgojaW5jbHVkZSAicGt0LWxpbmUuaCIKI2luY2x1ZGUgInN0cmluZy1saXN0LmgiCiNpbmNsdWRlICJzaWRlYmFuZC5oIgojaW5jbHVkZSAiYXJndi1hcnJheS5oIgojaW5jbHVkZSAiY3JlZGVudGlhbC5oIgojaW5jbHVkZSAic2hhMS1hcnJheS5oIgojaW5jbHVkZSAic2VuZC1wYWNrLmgiCgpzdGF0aWMgc3RydWN0IHJlbW90ZSAqcmVtb3RlOwovKiBhbHdheXMgZW5kcyB3aXRoIGEgdHJhaWxpbmcgc2xhc2ggKi8Kc3RhdGljIHN0cnVjdCBzdHJidWYgdXJsID0gU1RSQlVGX0lOSVQ7CgpzdHJ1Y3Qgb3B0aW9ucyB7CglpbnQgdmVyYm9zaXR5OwoJdW5zaWduZWQgbG9uZyBkZXB0aDsKCWNoYXIgKmRlZXBlbl9zaW5jZTsKCXN0cnVjdCBzdHJpbmdfbGlzdCBkZWVwZW5fbm90OwoJc3RydWN0IHN0cmluZ19saXN0IHB1c2hfb3B0aW9uczsKCXVuc2lnbmVkIHByb2dyZXNzIDogMSwKCQljaGVja19zZWxmX2NvbnRhaW5lZF9hbmRfY29ubmVjdGVkIDogMSwKCQljbG9uaW5nIDogMSwKCQl1cGRhdGVfc2hhbGxvdyA6IDEsCgkJZm9sbG93dGFncyA6IDEsCgkJZHJ5X3J1biA6IDEsCgkJdGhpbiA6IDEsCgkJLyogT25lIG9mIHRoZSBTRU5EX1BBQ0tfUFVTSF9DRVJUXyogY29uc3RhbnRzLiAqLwoJCXB1c2hfY2VydCA6IDIsCgkJZGVlcGVuX3JlbGF0aXZlIDogMTsKfTsKc3RhdGljIHN0cnVjdCBvcHRpb25zIG9wdGlvbnM7CnN0YXRpYyBzdHJ1Y3Qgc3RyaW5nX2xpc3QgY2FzX29wdGlvbnMgPSBTVFJJTkdfTElTVF9JTklUX0RVUDsKCnN0YXRpYyBpbnQgc2V0X29wdGlvbihjb25zdCBjaGFyICpuYW1lLCBjb25zdCBjaGFyICp2YWx1ZSkKewoJaWYgKCFzdHJjbXAobmFtZSwgInZlcmJvc2l0eSIpKSB7CgkJY2hhciAqZW5kOwoJCWludCB2ID0gc3RydG9sKHZhbHVlLCAmZW5kLCAxMCk7CgkJaWYgKHZhbHVlID09IGVuZCB8fCAqZW5kKQoJCQlyZXR1cm4gLTE7CgkJb3B0aW9ucy52ZXJib3NpdHkgPSB2OwoJCXJldHVybiAwOwoJfQoJZWxzZSBpZiAoIXN0cmNtcChuYW1lLCAicHJvZ3Jlc3MiKSkgewoJCWlmICghc3RyY21wKHZhbHVlLCAidHJ1ZSIpKQoJCQlvcHRpb25zLnByb2dyZXNzID0gMTsKCQllbHNlIGlmICghc3RyY21wKHZhbHVlLCAiZmFsc2UiKSkKCQkJb3B0aW9ucy5wcm9ncmVzcyA9IDA7CgkJZWxzZQoJCQlyZXR1cm4gLTE7CgkJcmV0dXJuIDA7Cgl9CgllbHNlIGlmICghc3RyY21wKG5hbWUsICJkZXB0aCIpKSB7CgkJY2hhciAqZW5kOwoJCXVuc2lnbmVkIGxvbmcgdiA9IHN0cnRvdWwodmFsdWUsICZlbmQsIDEwKTsKCQlpZiAodmFsdWUgPT0gZW5kIHx8ICplbmQpCgkJCXJldHVybiAtMTsKCQlvcHRpb25zLmRlcHRoID0gdjsKCQlyZXR1cm4gMDsKCX0KCWVsc2UgaWYgKCFzdHJjbXAobmFtZSwgImRlZXBlbi1zaW5jZSIpKSB7CgkJb3B0aW9ucy5kZWVwZW5fc2luY2UgPSB4c3RyZHVwKHZhbHVlKTsKCQlyZXR1cm4gMDsKCX0KCWVsc2UgaWYgKCFzdHJjbXAobmFtZSwgImRlZXBlbi1ub3QiKSkgewoJCXN0cmluZ19saXN0X2FwcGVuZCgmb3B0aW9ucy5kZWVwZW5fbm90LCB2YWx1ZSk7CgkJcmV0dXJuIDA7Cgl9CgllbHNlIGlmICghc3RyY21wKG5hbWUsICJkZWVwZW4tcmVsYXRpdmUiKSkgewoJCWlmICghc3RyY21wKHZhbHVlLCAidHJ1ZSIpKQoJCQlvcHRpb25zLmRlZXBlbl9yZWxhdGl2ZSA9IDE7CgkJZWxzZSBpZiAoIXN0cmNtcCh2YWx1ZSwgImZhbHNlIikpCgkJCW9wdGlvbnMuZGVlcGVuX3JlbGF0aXZlID0gMDsKCQllbHNlCgkJCXJldHVybiAtMTsKCQlyZXR1cm4gMDsKCX0KCWVsc2UgaWYgKCFzdHJjbXAobmFtZSwgImZvbGxvd3RhZ3MiKSkgewoJCWlmICghc3RyY21wKHZhbHVlLCAidHJ1ZSIpKQoJCQlvcHRpb25zLmZvbGxvd3RhZ3MgPSAxOwoJCWVsc2UgaWYgKCFzdHJjbXAodmFsdWUsICJmYWxzZSIpKQoJCQlvcHRpb25zLmZvbGxvd3RhZ3MgPSAwOwoJCWVsc2UKCQkJcmV0dXJuIC0xOwoJCXJldHVybiAwOwoJfQoJZWxzZSBpZiAoIXN0cmNtcChuYW1lLCAiZHJ5LXJ1biIpKSB7CgkJaWYgKCFzdHJjbXAodmFsdWUsICJ0cnVlIikpCgkJCW9wdGlvbnMuZHJ5X3J1biA9IDE7CgkJZWxzZSBpZiAoIXN0cmNtcCh2YWx1ZSwgImZhbHNlIikpCgkJCW9wdGlvbnMuZHJ5X3J1biA9IDA7CgkJZWxzZQoJCQlyZXR1cm4gLTE7CgkJcmV0dXJuIDA7Cgl9CgllbHNlIGlmICghc3RyY21wKG5hbWUsICJjaGVjay1jb25uZWN0aXZpdHkiKSkgewoJCWlmICghc3RyY21wKHZhbHVlLCAidHJ1ZSIpKQoJCQlvcHRpb25zLmNoZWNrX3NlbGZfY29udGFpbmVkX2FuZF9jb25uZWN0ZWQgPSAxOwoJCWVsc2UgaWYgKCFzdHJjbXAodmFsdWUsICJmYWxzZSIpKQoJCQlvcHRpb25zLmNoZWNrX3NlbGZfY29udGFpbmVkX2FuZF9jb25uZWN0ZWQgPSAwOwoJCWVsc2UKCQkJcmV0dXJuIC0xOwoJCXJldHVybiAwOwoJfQoJZWxzZSBpZiAoIXN0cmNtcChuYW1lLCAiY2FzIikpIHsKCQlzdHJ1Y3Qgc3RyYnVmIHZhbCA9IFNUUkJVRl9JTklUOwoJCXN0cmJ1Zl9hZGRmKCZ2YWwsICItLSIgQ0FTX09QVF9OQU1FICI9JXMiLCB2YWx1ZSk7CgkJc3RyaW5nX2xpc3RfYXBwZW5kKCZjYXNfb3B0aW9ucywgdmFsLmJ1Zik7CgkJc3RyYnVmX3JlbGVhc2UoJnZhbCk7CgkJcmV0dXJuIDA7Cgl9IGVsc2UgaWYgKCFzdHJjbXAobmFtZSwgImNsb25pbmciKSkgewoJCWlmICghc3RyY21wKHZhbHVlLCAidHJ1ZSIpKQoJCQlvcHRpb25zLmNsb25pbmcgPSAxOwoJCWVsc2UgaWYgKCFzdHJjbXAodmFsdWUsICJmYWxzZSIpKQoJCQlvcHRpb25zLmNsb25pbmcgPSAwOwoJCWVsc2UKCQkJcmV0dXJuIC0xOwoJCXJldHVybiAwOwoJfSBlbHNlIGlmICghc3RyY21wKG5hbWUsICJ1cGRhdGUtc2hhbGxvdyIpKSB7CgkJaWYgKCFzdHJjbXAodmFsdWUsICJ0cnVlIikpCgkJCW9wdGlvbnMudXBkYXRlX3NoYWxsb3cgPSAxOwoJCWVsc2UgaWYgKCFzdHJjbXAodmFsdWUsICJmYWxzZSIpKQoJCQlvcHRpb25zLnVwZGF0ZV9zaGFsbG93ID0gMDsKCQllbHNlCgkJCXJldHVybiAtMTsKCQlyZXR1cm4gMDsKCX0gZWxzZSBpZiAoIXN0cmNtcChuYW1lLCAicHVzaGNlcnQiKSkgewoJCWlmICghc3RyY21wKHZhbHVlLCAidHJ1ZSIpKQoJCQlvcHRpb25zLnB1c2hfY2VydCA9IFNFTkRfUEFDS19QVVNIX0NFUlRfQUxXQVlTOwoJCWVsc2UgaWYgKCFzdHJjbXAodmFsdWUsICJmYWxzZSIpKQoJCQlvcHRpb25zLnB1c2hfY2VydCA9IFNFTkRfUEFDS19QVVNIX0NFUlRfTkVWRVI7CgkJZWxzZSBpZiAoIXN0cmNtcCh2YWx1ZSwgImlmLWFza2VkIikpCgkJCW9wdGlvbnMucHVzaF9jZXJ0ID0gU0VORF9QQUNLX1BVU0hfQ0VSVF9JRl9BU0tFRDsKCQllbHNlCgkJCXJldHVybiAtMTsKCQlyZXR1cm4gMDsKCX0gZWxzZSBpZiAoIXN0cmNtcChuYW1lLCAicHVzaC1vcHRpb24iKSkgewoJCXN0cmluZ19saXN0X2FwcGVuZCgmb3B0aW9ucy5wdXNoX29wdGlvbnMsIHZhbHVlKTsKCQlyZXR1cm4gMDsKCiNpZiBMSUJDVVJMX1ZFUlNJT05fTlVNID49IDB4MDcwYTA4Cgl9IGVsc2UgaWYgKCFzdHJjbXAobmFtZSwgImZhbWlseSIpKSB7CgkJaWYgKCFzdHJjbXAodmFsdWUsICJpcHY0IikpCgkJCWdpdF9jdXJsX2lwcmVzb2x2ZSA9IENVUkxfSVBSRVNPTFZFX1Y0OwoJCWVsc2UgaWYgKCFzdHJjbXAodmFsdWUsICJpcHY2IikpCgkJCWdpdF9jdXJsX2lwcmVzb2x2ZSA9IENVUkxfSVBSRVNPTFZFX1Y2OwoJCWVsc2UgaWYgKCFzdHJjbXAodmFsdWUsICJhbGwiKSkKCQkJZ2l0X2N1cmxfaXByZXNvbHZlID0gQ1VSTF9JUFJFU09MVkVfV0hBVEVWRVI7CgkJZWxzZQoJCQlyZXR1cm4gLTE7CgkJcmV0dXJuIDA7CiNlbmRpZiAvKiBMSUJDVVJMX1ZFUlNJT05fTlVNID49IDB4MDcwYTA4ICovCgl9IGVsc2UgewoJCXJldHVybiAxIC8qIHVuc3VwcG9ydGVkICovOwoJfQp9CgpzdHJ1Y3QgZGlzY292ZXJ5IHsKCWNvbnN0IGNoYXIgKnNlcnZpY2U7CgljaGFyICpidWZfYWxsb2M7CgljaGFyICpidWY7CglzaXplX3QgbGVuOwoJc3RydWN0IHJlZiAqcmVmczsKCXN0cnVjdCBvaWRfYXJyYXkgc2hhbGxvdzsKCXVuc2lnbmVkIHByb3RvX2dpdCA6IDE7Cn07CnN0YXRpYyBzdHJ1Y3QgZGlzY292ZXJ5ICpsYXN0X2Rpc2NvdmVyeTsKCnN0YXRpYyBzdHJ1Y3QgcmVmICpwYXJzZV9naXRfcmVmcyhzdHJ1Y3QgZGlzY292ZXJ5ICpoZWFkcywgaW50IGZvcl9wdXNoKQp7CglzdHJ1Y3QgcmVmICpsaXN0ID0gTlVMTDsKCWdldF9yZW1vdGVfaGVhZHMoLTEsIGhlYWRzLT5idWYsIGhlYWRzLT5sZW4sICZsaXN0LAoJCQkgZm9yX3B1c2ggPyBSRUZfTk9STUFMIDogMCwgTlVMTCwgJmhlYWRzLT5zaGFsbG93KTsKCXJldHVybiBsaXN0Owp9CgpzdGF0aWMgc3RydWN0IHJlZiAqcGFyc2VfaW5mb19yZWZzKHN0cnVjdCBkaXNjb3ZlcnkgKmhlYWRzKQp7CgljaGFyICpkYXRhLCAqc3RhcnQsICptaWQ7CgljaGFyICpyZWZfbmFtZTsKCWludCBpID0gMDsKCglzdHJ1Y3QgcmVmICpyZWZzID0gTlVMTDsKCXN0cnVjdCByZWYgKnJlZiA9IE5VTEw7CglzdHJ1Y3QgcmVmICpsYXN0X3JlZiA9IE5VTEw7CgoJZGF0YSA9IGhlYWRzLT5idWY7CglzdGFydCA9IE5VTEw7CgltaWQgPSBkYXRhOwoJd2hpbGUgKGkgPCBoZWFkcy0+bGVuKSB7CgkJaWYgKCFzdGFydCkgewoJCQlzdGFydCA9ICZkYXRhW2ldOwoJCX0KCQlpZiAoZGF0YVtpXSA9PSAnXHQnKQoJCQltaWQgPSAmZGF0YVtpXTsKCQlpZiAoZGF0YVtpXSA9PSAnXG4nKSB7CgkJCWlmIChtaWQgLSBzdGFydCAhPSA0MCkKCQkJCWRpZSgiJXNpbmZvL3JlZnMgbm90IHZhbGlkOiBpcyB0aGlzIGEgZ2l0IHJlcG9zaXRvcnk/IiwKCQkJCSAgICB1cmwuYnVmKTsKCQkJZGF0YVtpXSA9IDA7CgkJCXJlZl9uYW1lID0gbWlkICsgMTsKCQkJcmVmID0gYWxsb2NfcmVmKHJlZl9uYW1lKTsKCQkJZ2V0X29pZF9oZXgoc3RhcnQsICZyZWYtPm9sZF9vaWQpOwoJCQlpZiAoIXJlZnMpCgkJCQlyZWZzID0gcmVmOwoJCQlpZiAobGFzdF9yZWYpCgkJCQlsYXN0X3JlZi0+bmV4dCA9IHJlZjsKCQkJbGFzdF9yZWYgPSByZWY7CgkJCXN0YXJ0ID0gTlVMTDsKCQl9CgkJaSsrOwoJfQoKCXJlZiA9IGFsbG9jX3JlZigiSEVBRCIpOwoJaWYgKCFodHRwX2ZldGNoX3JlZih1cmwuYnVmLCByZWYpICYmCgkgICAgIXJlc29sdmVfcmVtb3RlX3N5bXJlZihyZWYsIHJlZnMpKSB7CgkJcmVmLT5uZXh0ID0gcmVmczsKCQlyZWZzID0gcmVmOwoJfSBlbHNlIHsKCQlmcmVlKHJlZik7Cgl9CgoJcmV0dXJuIHJlZnM7Cn0KCnN0YXRpYyB2b2lkIGZyZWVfZGlzY292ZXJ5KHN0cnVjdCBkaXNjb3ZlcnkgKmQpCnsKCWlmIChkKSB7CgkJaWYgKGQgPT0gbGFzdF9kaXNjb3ZlcnkpCgkJCWxhc3RfZGlzY292ZXJ5ID0gTlVMTDsKCQlmcmVlKGQtPnNoYWxsb3cub2lkKTsKCQlmcmVlKGQtPmJ1Zl9hbGxvYyk7CgkJZnJlZV9yZWZzKGQtPnJlZnMpOwoJCWZyZWUoZCk7Cgl9Cn0KCnN0YXRpYyBpbnQgc2hvd19odHRwX21lc3NhZ2Uoc3RydWN0IHN0cmJ1ZiAqdHlwZSwgc3RydWN0IHN0cmJ1ZiAqY2hhcnNldCwKCQkJICAgICBzdHJ1Y3Qgc3RyYnVmICptc2cpCnsKCWNvbnN0IGNoYXIgKnAsICplb2w7CgoJLyoKCSAqIFdlIG9ubHkgc2hvdyB0ZXh0L3BsYWluIHBhcnRzLCBhcyBvdGhlciB0eXBlcyBhcmUgbGlrZWx5CgkgKiB0byBiZSB1Z2x5IHRvIGxvb2sgYXQgb24gdGhlIHVzZXIncyB0ZXJtaW5hbC4KCSAqLwoJaWYgKHN0cmNtcCh0eXBlLT5idWYsICJ0ZXh0L3BsYWluIikpCgkJcmV0dXJuIC0xOwoJaWYgKGNoYXJzZXQtPmxlbikKCQlzdHJidWZfcmVlbmNvZGUobXNnLCBjaGFyc2V0LT5idWYsIGdldF9sb2dfb3V0cHV0X2VuY29kaW5nKCkpOwoKCXN0cmJ1Zl90cmltKG1zZyk7CglpZiAoIW1zZy0+bGVuKQoJCXJldHVybiAtMTsKCglwID0gbXNnLT5idWY7CglkbyB7CgkJZW9sID0gc3RyY2hybnVsKHAsICdcbicpOwoJCWZwcmludGYoc3RkZXJyLCAicmVtb3RlOiAlLipzXG4iLCAoaW50KShlb2wgLSBwKSwgcCk7CgkJcCA9IGVvbCArIDE7Cgl9IHdoaWxlKCplb2wpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBzdHJ1Y3QgZGlzY292ZXJ5ICpkaXNjb3Zlcl9yZWZzKGNvbnN0IGNoYXIgKnNlcnZpY2UsIGludCBmb3JfcHVzaCkKewoJc3RydWN0IHN0cmJ1ZiBleHAgPSBTVFJCVUZfSU5JVDsKCXN0cnVjdCBzdHJidWYgdHlwZSA9IFNUUkJVRl9JTklUOwoJc3RydWN0IHN0cmJ1ZiBjaGFyc2V0ID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZmZlciA9IFNUUkJVRl9JTklUOwoJc3RydWN0IHN0cmJ1ZiByZWZzX3VybCA9IFNUUkJVRl9JTklUOwoJc3RydWN0IHN0cmJ1ZiBlZmZlY3RpdmVfdXJsID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3QgZGlzY292ZXJ5ICpsYXN0ID0gbGFzdF9kaXNjb3Zlcnk7CglpbnQgaHR0cF9yZXQsIG1heWJlX3NtYXJ0ID0gMDsKCXN0cnVjdCBodHRwX2dldF9vcHRpb25zIGh0dHBfb3B0aW9uczsKCglpZiAobGFzdCAmJiAhc3RyY21wKHNlcnZpY2UsIGxhc3QtPnNlcnZpY2UpKQoJCXJldHVybiBsYXN0OwoJZnJlZV9kaXNjb3ZlcnkobGFzdCk7CgoJc3RyYnVmX2FkZGYoJnJlZnNfdXJsLCAiJXNpbmZvL3JlZnMiLCB1cmwuYnVmKTsKCWlmICgoc3RhcnRzX3dpdGgodXJsLmJ1ZiwgImh0dHA6Ly8iKSB8fCBzdGFydHNfd2l0aCh1cmwuYnVmLCAiaHR0cHM6Ly8iKSkgJiYKCSAgICAgZ2l0X2Vudl9ib29sKCJHSVRfU01BUlRfSFRUUCIsIDEpKSB7CgkJbWF5YmVfc21hcnQgPSAxOwoJCWlmICghc3RyY2hyKHVybC5idWYsICc/JykpCgkJCXN0cmJ1Zl9hZGRjaCgmcmVmc191cmwsICc/Jyk7CgkJZWxzZQoJCQlzdHJidWZfYWRkY2goJnJlZnNfdXJsLCAnJicpOwoJCXN0cmJ1Zl9hZGRmKCZyZWZzX3VybCwgInNlcnZpY2U9JXMiLCBzZXJ2aWNlKTsKCX0KCgltZW1zZXQoJmh0dHBfb3B0aW9ucywgMCwgc2l6ZW9mKGh0dHBfb3B0aW9ucykpOwoJaHR0cF9vcHRpb25zLmNvbnRlbnRfdHlwZSA9ICZ0eXBlOwoJaHR0cF9vcHRpb25zLmNoYXJzZXQgPSAmY2hhcnNldDsKCWh0dHBfb3B0aW9ucy5lZmZlY3RpdmVfdXJsID0gJmVmZmVjdGl2ZV91cmw7CglodHRwX29wdGlvbnMuYmFzZV91cmwgPSAmdXJsOwoJaHR0cF9vcHRpb25zLmluaXRpYWxfcmVxdWVzdCA9IDE7CglodHRwX29wdGlvbnMubm9fY2FjaGUgPSAxOwoJaHR0cF9vcHRpb25zLmtlZXBfZXJyb3IgPSAxOwoKCWh0dHBfcmV0ID0gaHR0cF9nZXRfc3RyYnVmKHJlZnNfdXJsLmJ1ZiwgJmJ1ZmZlciwgJmh0dHBfb3B0aW9ucyk7Cglzd2l0Y2ggKGh0dHBfcmV0KSB7CgljYXNlIEhUVFBfT0s6CgkJYnJlYWs7CgljYXNlIEhUVFBfTUlTU0lOR19UQVJHRVQ6CgkJc2hvd19odHRwX21lc3NhZ2UoJnR5cGUsICZjaGFyc2V0LCAmYnVmZmVyKTsKCQlkaWUoInJlcG9zaXRvcnkgJyVzJyBub3QgZm91bmQiLCB1cmwuYnVmKTsKCWNhc2UgSFRUUF9OT0FVVEg6CgkJc2hvd19odHRwX21lc3NhZ2UoJnR5cGUsICZjaGFyc2V0LCAmYnVmZmVyKTsKCQlkaWUoIkF1dGhlbnRpY2F0aW9uIGZhaWxlZCBmb3IgJyVzJyIsIHVybC5idWYpOwoJZGVmYXVsdDoKCQlzaG93X2h0dHBfbWVzc2FnZSgmdHlwZSwgJmNoYXJzZXQsICZidWZmZXIpOwoJCWRpZSgidW5hYmxlIHRvIGFjY2VzcyAnJXMnOiAlcyIsIHVybC5idWYsIGN1cmxfZXJyb3JzdHIpOwoJfQoKCWlmIChvcHRpb25zLnZlcmJvc2l0eSAmJiAhc3RhcnRzX3dpdGgocmVmc191cmwuYnVmLCB1cmwuYnVmKSkKCQl3YXJuaW5nKF8oInJlZGlyZWN0aW5nIHRvICVzIiksIHVybC5idWYpOwoKCWxhc3Q9IHhjYWxsb2MoMSwgc2l6ZW9mKCpsYXN0X2Rpc2NvdmVyeSkpOwoJbGFzdC0+c2VydmljZSA9IHNlcnZpY2U7CglsYXN0LT5idWZfYWxsb2MgPSBzdHJidWZfZGV0YWNoKCZidWZmZXIsICZsYXN0LT5sZW4pOwoJbGFzdC0+YnVmID0gbGFzdC0+YnVmX2FsbG9jOwoKCXN0cmJ1Zl9hZGRmKCZleHAsICJhcHBsaWNhdGlvbi94LSVzLWFkdmVydGlzZW1lbnQiLCBzZXJ2aWNlKTsKCWlmIChtYXliZV9zbWFydCAmJgoJICAgICg1IDw9IGxhc3QtPmxlbiAmJiBsYXN0LT5idWZbNF0gPT0gJyMnKSAmJgoJICAgICFzdHJidWZfY21wKCZleHAsICZ0eXBlKSkgewoJCWNoYXIgKmxpbmU7CgoJCS8qCgkJICogc21hcnQgSFRUUCByZXNwb25zZTsgdmFsaWRhdGUgdGhhdCB0aGUgc2VydmljZQoJCSAqIHBrdC1saW5lIG1hdGNoZXMgb3VyIHJlcXVlc3QuCgkJICovCgkJbGluZSA9IHBhY2tldF9yZWFkX2xpbmVfYnVmKCZsYXN0LT5idWYsICZsYXN0LT5sZW4sIE5VTEwpOwoKCQlzdHJidWZfcmVzZXQoJmV4cCk7CgkJc3RyYnVmX2FkZGYoJmV4cCwgIiMgc2VydmljZT0lcyIsIHNlcnZpY2UpOwoJCWlmIChzdHJjbXAobGluZSwgZXhwLmJ1ZikpCgkJCWRpZSgiaW52YWxpZCBzZXJ2ZXIgcmVzcG9uc2U7IGdvdCAnJXMnIiwgbGluZSk7CgkJc3RyYnVmX3JlbGVhc2UoJmV4cCk7CgoJCS8qIFRoZSBoZWFkZXIgY2FuIGluY2x1ZGUgYWRkaXRpb25hbCBtZXRhZGF0YSBsaW5lcywgdXAKCQkgKiB1bnRpbCBhIHBhY2tldCBmbHVzaCBtYXJrZXIuICBJZ25vcmUgdGhlc2Ugbm93LCBidXQKCQkgKiBpbiB0aGUgZnV0dXJlIHdlIG1pZ2h0IHN0YXJ0IHRvIHNjYW4gdGhlbS4KCQkgKi8KCQl3aGlsZSAocGFja2V0X3JlYWRfbGluZV9idWYoJmxhc3QtPmJ1ZiwgJmxhc3QtPmxlbiwgTlVMTCkpCgkJCTsKCgkJbGFzdC0+cHJvdG9fZ2l0ID0gMTsKCX0KCglpZiAobGFzdC0+cHJvdG9fZ2l0KQoJCWxhc3QtPnJlZnMgPSBwYXJzZV9naXRfcmVmcyhsYXN0LCBmb3JfcHVzaCk7CgllbHNlCgkJbGFzdC0+cmVmcyA9IHBhcnNlX2luZm9fcmVmcyhsYXN0KTsKCglzdHJidWZfcmVsZWFzZSgmcmVmc191cmwpOwoJc3RyYnVmX3JlbGVhc2UoJmV4cCk7CglzdHJidWZfcmVsZWFzZSgmdHlwZSk7CglzdHJidWZfcmVsZWFzZSgmY2hhcnNldCk7CglzdHJidWZfcmVsZWFzZSgmZWZmZWN0aXZlX3VybCk7CglzdHJidWZfcmVsZWFzZSgmYnVmZmVyKTsKCWxhc3RfZGlzY292ZXJ5ID0gbGFzdDsKCXJldHVybiBsYXN0Owp9CgpzdGF0aWMgc3RydWN0IHJlZiAqZ2V0X3JlZnMoaW50IGZvcl9wdXNoKQp7CglzdHJ1Y3QgZGlzY292ZXJ5ICpoZWFkczsKCglpZiAoZm9yX3B1c2gpCgkJaGVhZHMgPSBkaXNjb3Zlcl9yZWZzKCJnaXQtcmVjZWl2ZS1wYWNrIiwgZm9yX3B1c2gpOwoJZWxzZQoJCWhlYWRzID0gZGlzY292ZXJfcmVmcygiZ2l0LXVwbG9hZC1wYWNrIiwgZm9yX3B1c2gpOwoKCXJldHVybiBoZWFkcy0+cmVmczsKfQoKc3RhdGljIHZvaWQgb3V0cHV0X3JlZnMoc3RydWN0IHJlZiAqcmVmcykKewoJc3RydWN0IHJlZiAqcG9zbjsKCWZvciAocG9zbiA9IHJlZnM7IHBvc247IHBvc24gPSBwb3NuLT5uZXh0KSB7CgkJaWYgKHBvc24tPnN5bXJlZikKCQkJcHJpbnRmKCJAJXMgJXNcbiIsIHBvc24tPnN5bXJlZiwgcG9zbi0+bmFtZSk7CgkJZWxzZQoJCQlwcmludGYoIiVzICVzXG4iLCBvaWRfdG9faGV4KCZwb3NuLT5vbGRfb2lkKSwgcG9zbi0+bmFtZSk7Cgl9CglwcmludGYoIlxuIik7CglmZmx1c2goc3Rkb3V0KTsKfQoKc3RydWN0IHJwY19zdGF0ZSB7Cgljb25zdCBjaGFyICpzZXJ2aWNlX25hbWU7Cgljb25zdCBjaGFyICoqYXJndjsKCXN0cnVjdCBzdHJidWYgKnN0ZGluX3ByZWFtYmxlOwoJY2hhciAqc2VydmljZV91cmw7CgljaGFyICpoZHJfY29udGVudF90eXBlOwoJY2hhciAqaGRyX2FjY2VwdDsKCWNoYXIgKmJ1ZjsKCXNpemVfdCBhbGxvYzsKCXNpemVfdCBsZW47CglzaXplX3QgcG9zOwoJaW50IGluOwoJaW50IG91dDsKCWludCBhbnlfd3JpdHRlbjsKCXN0cnVjdCBzdHJidWYgcmVzdWx0OwoJdW5zaWduZWQgZ3ppcF9yZXF1ZXN0IDogMTsKCXVuc2lnbmVkIGluaXRpYWxfYnVmZmVyIDogMTsKfTsKCnN0YXRpYyBzaXplX3QgcnBjX291dCh2b2lkICpwdHIsIHNpemVfdCBlbHRzaXplLAoJCXNpemVfdCBubWVtYiwgdm9pZCAqYnVmZmVyXykKewoJc2l6ZV90IG1heCA9IGVsdHNpemUgKiBubWVtYjsKCXN0cnVjdCBycGNfc3RhdGUgKnJwYyA9IGJ1ZmZlcl87CglzaXplX3QgYXZhaWwgPSBycGMtPmxlbiAtIHJwYy0+cG9zOwoKCWlmICghYXZhaWwpIHsKCQlycGMtPmluaXRpYWxfYnVmZmVyID0gMDsKCQlhdmFpbCA9IHBhY2tldF9yZWFkKHJwYy0+b3V0LCBOVUxMLCBOVUxMLCBycGMtPmJ1ZiwgcnBjLT5hbGxvYywgMCk7CgkJaWYgKCFhdmFpbCkKCQkJcmV0dXJuIDA7CgkJcnBjLT5wb3MgPSAwOwoJCXJwYy0+bGVuID0gYXZhaWw7Cgl9CgoJaWYgKG1heCA8IGF2YWlsKQoJCWF2YWlsID0gbWF4OwoJbWVtY3B5KHB0ciwgcnBjLT5idWYgKyBycGMtPnBvcywgYXZhaWwpOwoJcnBjLT5wb3MgKz0gYXZhaWw7CglyZXR1cm4gYXZhaWw7Cn0KCiNpZm5kZWYgTk9fQ1VSTF9JT0NUTApzdGF0aWMgY3VybGlvZXJyIHJwY19pb2N0bChDVVJMICpoYW5kbGUsIGludCBjbWQsIHZvaWQgKmNsaWVudHApCnsKCXN0cnVjdCBycGNfc3RhdGUgKnJwYyA9IGNsaWVudHA7CgoJc3dpdGNoIChjbWQpIHsKCWNhc2UgQ1VSTElPQ01EX05PUDoKCQlyZXR1cm4gQ1VSTElPRV9PSzsKCgljYXNlIENVUkxJT0NNRF9SRVNUQVJUUkVBRDoKCQlpZiAocnBjLT5pbml0aWFsX2J1ZmZlcikgewoJCQlycGMtPnBvcyA9IDA7CgkJCXJldHVybiBDVVJMSU9FX09LOwoJCX0KCQllcnJvcigidW5hYmxlIHRvIHJld2luZCBycGMgcG9zdCBkYXRhIC0gdHJ5IGluY3JlYXNpbmcgaHR0cC5wb3N0QnVmZmVyIik7CgkJcmV0dXJuIENVUkxJT0VfRkFJTFJFU1RBUlQ7CgoJZGVmYXVsdDoKCQlyZXR1cm4gQ1VSTElPRV9VTktOT1dOQ01EOwoJfQp9CiNlbmRpZgoKc3RhdGljIHNpemVfdCBycGNfaW4oY2hhciAqcHRyLCBzaXplX3QgZWx0c2l6ZSwKCQlzaXplX3Qgbm1lbWIsIHZvaWQgKmJ1ZmZlcl8pCnsKCXNpemVfdCBzaXplID0gZWx0c2l6ZSAqIG5tZW1iOwoJc3RydWN0IHJwY19zdGF0ZSAqcnBjID0gYnVmZmVyXzsKCWlmIChzaXplKQoJCXJwYy0+YW55X3dyaXR0ZW4gPSAxOwoJd3JpdGVfb3JfZGllKHJwYy0+aW4sIHB0ciwgc2l6ZSk7CglyZXR1cm4gc2l6ZTsKfQoKc3RhdGljIGludCBydW5fc2xvdChzdHJ1Y3QgYWN0aXZlX3JlcXVlc3Rfc2xvdCAqc2xvdCwKCQkgICAgc3RydWN0IHNsb3RfcmVzdWx0cyAqcmVzdWx0cykKewoJaW50IGVycjsKCXN0cnVjdCBzbG90X3Jlc3VsdHMgcmVzdWx0c19idWY7CgoJaWYgKCFyZXN1bHRzKQoJCXJlc3VsdHMgPSAmcmVzdWx0c19idWY7CgoJZXJyID0gcnVuX29uZV9zbG90KHNsb3QsIHJlc3VsdHMpOwoKCWlmIChlcnIgIT0gSFRUUF9PSyAmJiBlcnIgIT0gSFRUUF9SRUFVVEgpIHsKCQlzdHJ1Y3Qgc3RyYnVmIG1zZyA9IFNUUkJVRl9JTklUOwoJCWlmIChyZXN1bHRzLT5odHRwX2NvZGUgJiYgcmVzdWx0cy0+aHR0cF9jb2RlICE9IDIwMCkKCQkJc3RyYnVmX2FkZGYoJm1zZywgIkhUVFAgJWxkIiwgcmVzdWx0cy0+aHR0cF9jb2RlKTsKCQlpZiAocmVzdWx0cy0+Y3VybF9yZXN1bHQgIT0gQ1VSTEVfT0spIHsKCQkJaWYgKG1zZy5sZW4pCgkJCQlzdHJidWZfYWRkY2goJm1zZywgJyAnKTsKCQkJc3RyYnVmX2FkZGYoJm1zZywgImN1cmwgJWQiLCByZXN1bHRzLT5jdXJsX3Jlc3VsdCk7CgkJCWlmIChjdXJsX2Vycm9yc3RyWzBdKSB7CgkJCQlzdHJidWZfYWRkY2goJm1zZywgJyAnKTsKCQkJCXN0cmJ1Zl9hZGRzdHIoJm1zZywgY3VybF9lcnJvcnN0cik7CgkJCX0KCQl9CgkJZXJyb3IoIlJQQyBmYWlsZWQ7ICVzIiwgbXNnLmJ1Zik7CgkJc3RyYnVmX3JlbGVhc2UoJm1zZyk7Cgl9CgoJcmV0dXJuIGVycjsKfQoKc3RhdGljIGludCBwcm9iZV9ycGMoc3RydWN0IHJwY19zdGF0ZSAqcnBjLCBzdHJ1Y3Qgc2xvdF9yZXN1bHRzICpyZXN1bHRzKQp7CglzdHJ1Y3QgYWN0aXZlX3JlcXVlc3Rfc2xvdCAqc2xvdDsKCXN0cnVjdCBjdXJsX3NsaXN0ICpoZWFkZXJzID0gaHR0cF9jb3B5X2RlZmF1bHRfaGVhZGVycygpOwoJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCWludCBlcnI7CgoJc2xvdCA9IGdldF9hY3RpdmVfc2xvdCgpOwoKCWhlYWRlcnMgPSBjdXJsX3NsaXN0X2FwcGVuZChoZWFkZXJzLCBycGMtPmhkcl9jb250ZW50X3R5cGUpOwoJaGVhZGVycyA9IGN1cmxfc2xpc3RfYXBwZW5kKGhlYWRlcnMsIHJwYy0+aGRyX2FjY2VwdCk7CgoJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX05PQk9EWSwgMCk7CgljdXJsX2Vhc3lfc2V0b3B0KHNsb3QtPmN1cmwsIENVUkxPUFRfUE9TVCwgMSk7CgljdXJsX2Vhc3lfc2V0b3B0KHNsb3QtPmN1cmwsIENVUkxPUFRfVVJMLCBycGMtPnNlcnZpY2VfdXJsKTsKCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9FTkNPRElORywgTlVMTCk7CgljdXJsX2Vhc3lfc2V0b3B0KHNsb3QtPmN1cmwsIENVUkxPUFRfUE9TVEZJRUxEUywgIjAwMDAiKTsKCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9QT1NURklFTERTSVpFLCA0KTsKCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9IVFRQSEVBREVSLCBoZWFkZXJzKTsKCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9XUklURUZVTkNUSU9OLCBmd3JpdGVfYnVmZmVyKTsKCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9GSUxFLCAmYnVmKTsKCgllcnIgPSBydW5fc2xvdChzbG90LCByZXN1bHRzKTsKCgljdXJsX3NsaXN0X2ZyZWVfYWxsKGhlYWRlcnMpOwoJc3RyYnVmX3JlbGVhc2UoJmJ1Zik7CglyZXR1cm4gZXJyOwp9CgpzdGF0aWMgY3VybF9vZmZfdCB4Y3VybF9vZmZfdChzc2l6ZV90IGxlbikgewoJaWYgKGxlbiA+IG1heGltdW1fc2lnbmVkX3ZhbHVlX29mX3R5cGUoY3VybF9vZmZfdCkpCgkJZGllKCJjYW5ub3QgaGFuZGxlIHB1c2hlcyB0aGlzIGJpZyIpOwoJcmV0dXJuIChjdXJsX29mZl90KSBsZW47Cn0KCnN0YXRpYyBpbnQgcG9zdF9ycGMoc3RydWN0IHJwY19zdGF0ZSAqcnBjKQp7CglzdHJ1Y3QgYWN0aXZlX3JlcXVlc3Rfc2xvdCAqc2xvdDsKCXN0cnVjdCBjdXJsX3NsaXN0ICpoZWFkZXJzID0gaHR0cF9jb3B5X2RlZmF1bHRfaGVhZGVycygpOwoJaW50IHVzZV9nemlwID0gcnBjLT5nemlwX3JlcXVlc3Q7CgljaGFyICpnemlwX2JvZHkgPSBOVUxMOwoJc2l6ZV90IGd6aXBfc2l6ZSA9IDA7CglpbnQgZXJyLCBsYXJnZV9yZXF1ZXN0ID0gMDsKCWludCBuZWVkc18xMDBfY29udGludWUgPSAwOwoKCS8qIFRyeSB0byBsb2FkIHRoZSBlbnRpcmUgcmVxdWVzdCwgaWYgd2UgY2FuIGZpdCBpdCBpbnRvIHRoZQoJICogYWxsb2NhdGVkIGJ1ZmZlciBzcGFjZSB3ZSBjYW4gdXNlIEhUVFAvMS4wIGFuZCBhdm9pZCB0aGUKCSAqIGNodW5rZWQgZW5jb2RpbmcgbWVzcy4KCSAqLwoJd2hpbGUgKDEpIHsKCQlzaXplX3QgbGVmdCA9IHJwYy0+YWxsb2MgLSBycGMtPmxlbjsKCQljaGFyICpidWYgPSBycGMtPmJ1ZiArIHJwYy0+bGVuOwoJCWludCBuOwoKCQlpZiAobGVmdCA8IExBUkdFX1BBQ0tFVF9NQVgpIHsKCQkJbGFyZ2VfcmVxdWVzdCA9IDE7CgkJCXVzZV9nemlwID0gMDsKCQkJYnJlYWs7CgkJfQoKCQluID0gcGFja2V0X3JlYWQocnBjLT5vdXQsIE5VTEwsIE5VTEwsIGJ1ZiwgbGVmdCwgMCk7CgkJaWYgKCFuKQoJCQlicmVhazsKCQlycGMtPmxlbiArPSBuOwoJfQoKCWlmIChsYXJnZV9yZXF1ZXN0KSB7CgkJc3RydWN0IHNsb3RfcmVzdWx0cyByZXN1bHRzOwoKCQlkbyB7CgkJCWVyciA9IHByb2JlX3JwYyhycGMsICZyZXN1bHRzKTsKCQkJaWYgKGVyciA9PSBIVFRQX1JFQVVUSCkKCQkJCWNyZWRlbnRpYWxfZmlsbCgmaHR0cF9hdXRoKTsKCQl9IHdoaWxlIChlcnIgPT0gSFRUUF9SRUFVVEgpOwoJCWlmIChlcnIgIT0gSFRUUF9PSykKCQkJcmV0dXJuIC0xOwoKCQlpZiAocmVzdWx0cy5hdXRoX2F2YWlsICYgQ1VSTEFVVEhfR1NTTkVHT1RJQVRFKQoJCQluZWVkc18xMDBfY29udGludWUgPSAxOwoJfQoKCWhlYWRlcnMgPSBjdXJsX3NsaXN0X2FwcGVuZChoZWFkZXJzLCBycGMtPmhkcl9jb250ZW50X3R5cGUpOwoJaGVhZGVycyA9IGN1cmxfc2xpc3RfYXBwZW5kKGhlYWRlcnMsIHJwYy0+aGRyX2FjY2VwdCk7CgloZWFkZXJzID0gY3VybF9zbGlzdF9hcHBlbmQoaGVhZGVycywgbmVlZHNfMTAwX2NvbnRpbnVlID8KCQkiRXhwZWN0OiAxMDAtY29udGludWUiIDogIkV4cGVjdDoiKTsKCnJldHJ5OgoJc2xvdCA9IGdldF9hY3RpdmVfc2xvdCgpOwoKCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9OT0JPRFksIDApOwoJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX1BPU1QsIDEpOwoJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX1VSTCwgcnBjLT5zZXJ2aWNlX3VybCk7CgljdXJsX2Vhc3lfc2V0b3B0KHNsb3QtPmN1cmwsIENVUkxPUFRfRU5DT0RJTkcsICJnemlwIik7CgoJaWYgKGxhcmdlX3JlcXVlc3QpIHsKCQkvKiBUaGUgcmVxdWVzdCBib2R5IGlzIGxhcmdlIGFuZCB0aGUgc2l6ZSBjYW5ub3QgYmUgcHJlZGljdGVkLgoJCSAqIFdlIG11c3QgdXNlIGNodW5rZWQgZW5jb2RpbmcgdG8gc2VuZCBpdC4KCQkgKi8KCQloZWFkZXJzID0gY3VybF9zbGlzdF9hcHBlbmQoaGVhZGVycywgIlRyYW5zZmVyLUVuY29kaW5nOiBjaHVua2VkIik7CgkJcnBjLT5pbml0aWFsX2J1ZmZlciA9IDE7CgkJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX1JFQURGVU5DVElPTiwgcnBjX291dCk7CgkJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX0lORklMRSwgcnBjKTsKI2lmbmRlZiBOT19DVVJMX0lPQ1RMCgkJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX0lPQ1RMRlVOQ1RJT04sIHJwY19pb2N0bCk7CgkJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX0lPQ1RMREFUQSwgcnBjKTsKI2VuZGlmCgkJaWYgKG9wdGlvbnMudmVyYm9zaXR5ID4gMSkgewoJCQlmcHJpbnRmKHN0ZGVyciwgIlBPU1QgJXMgKGNodW5rZWQpXG4iLCBycGMtPnNlcnZpY2VfbmFtZSk7CgkJCWZmbHVzaChzdGRlcnIpOwoJCX0KCgl9IGVsc2UgaWYgKGd6aXBfYm9keSkgewoJCS8qCgkJICogSWYgd2UgYXJlIGxvb3BpbmcgdG8gcmV0cnkgYXV0aGVudGljYXRpb24sIHRoZW4gdGhlIHByZXZpb3VzCgkJICogcnVuIHdpbGwgaGF2ZSBzZXQgdXAgdGhlIGhlYWRlcnMgYW5kIGd6aXAgYnVmZmVyIGFscmVhZHksCgkJICogYW5kIHdlIGp1c3QgbmVlZCB0byBzZW5kIGl0LgoJCSAqLwoJCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9QT1NURklFTERTLCBnemlwX2JvZHkpOwoJCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9QT1NURklFTERTSVpFX0xBUkdFLCB4Y3VybF9vZmZfdChnemlwX3NpemUpKTsKCgl9IGVsc2UgaWYgKHVzZV9nemlwICYmIDEwMjQgPCBycGMtPmxlbikgewoJCS8qIFRoZSBjbGllbnQgYmFja2VuZCBpc24ndCBnaXZpbmcgdXMgY29tcHJlc3NlZCBkYXRhIHNvCgkJICogd2UgY2FuIHRyeSB0byBkZWZsYXRlIGl0IG91cnNlbHZlcywgdGhpcyBtYXkgc2F2ZSBvbi4KCQkgKiB0aGUgdHJhbnNmZXIgdGltZS4KCQkgKi8KCQlnaXRfenN0cmVhbSBzdHJlYW07CgkJaW50IHJldDsKCgkJZ2l0X2RlZmxhdGVfaW5pdF9nemlwKCZzdHJlYW0sIFpfQkVTVF9DT01QUkVTU0lPTik7CgkJZ3ppcF9zaXplID0gZ2l0X2RlZmxhdGVfYm91bmQoJnN0cmVhbSwgcnBjLT5sZW4pOwoJCWd6aXBfYm9keSA9IHhtYWxsb2MoZ3ppcF9zaXplKTsKCgkJc3RyZWFtLm5leHRfaW4gPSAodW5zaWduZWQgY2hhciAqKXJwYy0+YnVmOwoJCXN0cmVhbS5hdmFpbF9pbiA9IHJwYy0+bGVuOwoJCXN0cmVhbS5uZXh0X291dCA9ICh1bnNpZ25lZCBjaGFyICopZ3ppcF9ib2R5OwoJCXN0cmVhbS5hdmFpbF9vdXQgPSBnemlwX3NpemU7CgoJCXJldCA9IGdpdF9kZWZsYXRlKCZzdHJlYW0sIFpfRklOSVNIKTsKCQlpZiAocmV0ICE9IFpfU1RSRUFNX0VORCkKCQkJZGllKCJjYW5ub3QgZGVmbGF0ZSByZXF1ZXN0OyB6bGliIGRlZmxhdGUgZXJyb3IgJWQiLCByZXQpOwoKCQlyZXQgPSBnaXRfZGVmbGF0ZV9lbmRfZ2VudGx5KCZzdHJlYW0pOwoJCWlmIChyZXQgIT0gWl9PSykKCQkJZGllKCJjYW5ub3QgZGVmbGF0ZSByZXF1ZXN0OyB6bGliIGVuZCBlcnJvciAlZCIsIHJldCk7CgoJCWd6aXBfc2l6ZSA9IHN0cmVhbS50b3RhbF9vdXQ7CgoJCWhlYWRlcnMgPSBjdXJsX3NsaXN0X2FwcGVuZChoZWFkZXJzLCAiQ29udGVudC1FbmNvZGluZzogZ3ppcCIpOwoJCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9QT1NURklFTERTLCBnemlwX2JvZHkpOwoJCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9QT1NURklFTERTSVpFX0xBUkdFLCB4Y3VybF9vZmZfdChnemlwX3NpemUpKTsKCgkJaWYgKG9wdGlvbnMudmVyYm9zaXR5ID4gMSkgewoJCQlmcHJpbnRmKHN0ZGVyciwgIlBPU1QgJXMgKGd6aXAgJWx1IHRvICVsdSBieXRlcylcbiIsCgkJCQlycGMtPnNlcnZpY2VfbmFtZSwKCQkJCSh1bnNpZ25lZCBsb25nKXJwYy0+bGVuLCAodW5zaWduZWQgbG9uZylnemlwX3NpemUpOwoJCQlmZmx1c2goc3RkZXJyKTsKCQl9Cgl9IGVsc2UgewoJCS8qIFdlIGtub3cgdGhlIGNvbXBsZXRlIHJlcXVlc3Qgc2l6ZSBpbiBhZHZhbmNlLCB1c2UgdGhlCgkJICogbW9yZSBub3JtYWwgQ29udGVudC1MZW5ndGggYXBwcm9hY2guCgkJICovCgkJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX1BPU1RGSUVMRFMsIHJwYy0+YnVmKTsKCQljdXJsX2Vhc3lfc2V0b3B0KHNsb3QtPmN1cmwsIENVUkxPUFRfUE9TVEZJRUxEU0laRV9MQVJHRSwgeGN1cmxfb2ZmX3QocnBjLT5sZW4pKTsKCQlpZiAob3B0aW9ucy52ZXJib3NpdHkgPiAxKSB7CgkJCWZwcmludGYoc3RkZXJyLCAiUE9TVCAlcyAoJWx1IGJ5dGVzKVxuIiwKCQkJCXJwYy0+c2VydmljZV9uYW1lLCAodW5zaWduZWQgbG9uZylycGMtPmxlbik7CgkJCWZmbHVzaChzdGRlcnIpOwoJCX0KCX0KCgljdXJsX2Vhc3lfc2V0b3B0KHNsb3QtPmN1cmwsIENVUkxPUFRfSFRUUEhFQURFUiwgaGVhZGVycyk7CgljdXJsX2Vhc3lfc2V0b3B0KHNsb3QtPmN1cmwsIENVUkxPUFRfV1JJVEVGVU5DVElPTiwgcnBjX2luKTsKCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9GSUxFLCBycGMpOwoKCglycGMtPmFueV93cml0dGVuID0gMDsKCWVyciA9IHJ1bl9zbG90KHNsb3QsIE5VTEwpOwoJaWYgKGVyciA9PSBIVFRQX1JFQVVUSCAmJiAhbGFyZ2VfcmVxdWVzdCkgewoJCWNyZWRlbnRpYWxfZmlsbCgmaHR0cF9hdXRoKTsKCQlnb3RvIHJldHJ5OwoJfQoJaWYgKGVyciAhPSBIVFRQX09LKQoJCWVyciA9IC0xOwoKCWlmICghcnBjLT5hbnlfd3JpdHRlbikKCQllcnIgPSAtMTsKCgljdXJsX3NsaXN0X2ZyZWVfYWxsKGhlYWRlcnMpOwoJZnJlZShnemlwX2JvZHkpOwoJcmV0dXJuIGVycjsKfQoKc3RhdGljIGludCBycGNfc2VydmljZShzdHJ1Y3QgcnBjX3N0YXRlICpycGMsIHN0cnVjdCBkaXNjb3ZlcnkgKmhlYWRzKQp7Cgljb25zdCBjaGFyICpzdmMgPSBycGMtPnNlcnZpY2VfbmFtZTsKCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3Qgc3RyYnVmICpwcmVhbWJsZSA9IHJwYy0+c3RkaW5fcHJlYW1ibGU7CglzdHJ1Y3QgY2hpbGRfcHJvY2VzcyBjbGllbnQgPSBDSElMRF9QUk9DRVNTX0lOSVQ7CglpbnQgZXJyID0gMDsKCgljbGllbnQuaW4gPSAtMTsKCWNsaWVudC5vdXQgPSAtMTsKCWNsaWVudC5naXRfY21kID0gMTsKCWNsaWVudC5hcmd2ID0gcnBjLT5hcmd2OwoJaWYgKHN0YXJ0X2NvbW1hbmQoJmNsaWVudCkpCgkJZXhpdCgxKTsKCWlmIChwcmVhbWJsZSkKCQl3cml0ZV9vcl9kaWUoY2xpZW50LmluLCBwcmVhbWJsZS0+YnVmLCBwcmVhbWJsZS0+bGVuKTsKCWlmIChoZWFkcykKCQl3cml0ZV9vcl9kaWUoY2xpZW50LmluLCBoZWFkcy0+YnVmLCBoZWFkcy0+bGVuKTsKCglycGMtPmFsbG9jID0gaHR0cF9wb3N0X2J1ZmZlcjsKCXJwYy0+YnVmID0geG1hbGxvYyhycGMtPmFsbG9jKTsKCXJwYy0+aW4gPSBjbGllbnQuaW47CglycGMtPm91dCA9IGNsaWVudC5vdXQ7CglzdHJidWZfaW5pdCgmcnBjLT5yZXN1bHQsIDApOwoKCXN0cmJ1Zl9hZGRmKCZidWYsICIlcyVzIiwgdXJsLmJ1Ziwgc3ZjKTsKCXJwYy0+c2VydmljZV91cmwgPSBzdHJidWZfZGV0YWNoKCZidWYsIE5VTEwpOwoKCXN0cmJ1Zl9hZGRmKCZidWYsICJDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL3gtJXMtcmVxdWVzdCIsIHN2Yyk7CglycGMtPmhkcl9jb250ZW50X3R5cGUgPSBzdHJidWZfZGV0YWNoKCZidWYsIE5VTEwpOwoKCXN0cmJ1Zl9hZGRmKCZidWYsICJBY2NlcHQ6IGFwcGxpY2F0aW9uL3gtJXMtcmVzdWx0Iiwgc3ZjKTsKCXJwYy0+aGRyX2FjY2VwdCA9IHN0cmJ1Zl9kZXRhY2goJmJ1ZiwgTlVMTCk7CgoJd2hpbGUgKCFlcnIpIHsKCQlpbnQgbiA9IHBhY2tldF9yZWFkKHJwYy0+b3V0LCBOVUxMLCBOVUxMLCBycGMtPmJ1ZiwgcnBjLT5hbGxvYywgMCk7CgkJaWYgKCFuKQoJCQlicmVhazsKCQlycGMtPnBvcyA9IDA7CgkJcnBjLT5sZW4gPSBuOwoJCWVyciB8PSBwb3N0X3JwYyhycGMpOwoJfQoKCWNsb3NlKGNsaWVudC5pbik7CgljbGllbnQuaW4gPSAtMTsKCWlmICghZXJyKSB7CgkJc3RyYnVmX3JlYWQoJnJwYy0+cmVzdWx0LCBjbGllbnQub3V0LCAwKTsKCX0gZWxzZSB7CgkJY2hhciBidWZbNDA5Nl07CgkJZm9yICg7OykKCQkJaWYgKHhyZWFkKGNsaWVudC5vdXQsIGJ1Ziwgc2l6ZW9mKGJ1ZikpIDw9IDApCgkJCQlicmVhazsKCX0KCgljbG9zZShjbGllbnQub3V0KTsKCWNsaWVudC5vdXQgPSAtMTsKCgllcnIgfD0gZmluaXNoX2NvbW1hbmQoJmNsaWVudCk7CglmcmVlKHJwYy0+c2VydmljZV91cmwpOwoJZnJlZShycGMtPmhkcl9jb250ZW50X3R5cGUpOwoJZnJlZShycGMtPmhkcl9hY2NlcHQpOwoJZnJlZShycGMtPmJ1Zik7CglzdHJidWZfcmVsZWFzZSgmYnVmKTsKCXJldHVybiBlcnI7Cn0KCnN0YXRpYyBpbnQgZmV0Y2hfZHVtYihpbnQgbnJfaGVhZHMsIHN0cnVjdCByZWYgKip0b19mZXRjaCkKewoJc3RydWN0IHdhbGtlciAqd2Fsa2VyOwoJY2hhciAqKnRhcmdldHM7CglpbnQgcmV0LCBpOwoKCUFMTE9DX0FSUkFZKHRhcmdldHMsIG5yX2hlYWRzKTsKCWlmIChvcHRpb25zLmRlcHRoIHx8IG9wdGlvbnMuZGVlcGVuX3NpbmNlKQoJCWRpZSgiZHVtYiBodHRwIHRyYW5zcG9ydCBkb2VzIG5vdCBzdXBwb3J0IHNoYWxsb3cgY2FwYWJpbGl0aWVzIik7Cglmb3IgKGkgPSAwOyBpIDwgbnJfaGVhZHM7IGkrKykKCQl0YXJnZXRzW2ldID0geHN0cmR1cChvaWRfdG9faGV4KCZ0b19mZXRjaFtpXS0+b2xkX29pZCkpOwoKCXdhbGtlciA9IGdldF9odHRwX3dhbGtlcih1cmwuYnVmKTsKCXdhbGtlci0+Z2V0X2FsbCA9IDE7Cgl3YWxrZXItPmdldF90cmVlID0gMTsKCXdhbGtlci0+Z2V0X2hpc3RvcnkgPSAxOwoJd2Fsa2VyLT5nZXRfdmVyYm9zZWx5ID0gb3B0aW9ucy52ZXJib3NpdHkgPj0gMzsKCXdhbGtlci0+Z2V0X3JlY292ZXIgPSAwOwoJcmV0ID0gd2Fsa2VyX2ZldGNoKHdhbGtlciwgbnJfaGVhZHMsIHRhcmdldHMsIE5VTEwsIE5VTEwpOwoJd2Fsa2VyX2ZyZWUod2Fsa2VyKTsKCglmb3IgKGkgPSAwOyBpIDwgbnJfaGVhZHM7IGkrKykKCQlmcmVlKHRhcmdldHNbaV0pOwoJZnJlZSh0YXJnZXRzKTsKCglyZXR1cm4gcmV0ID8gZXJyb3IoImZldGNoIGZhaWxlZC4iKSA6IDA7Cn0KCnN0YXRpYyBpbnQgZmV0Y2hfZ2l0KHN0cnVjdCBkaXNjb3ZlcnkgKmhlYWRzLAoJaW50IG5yX2hlYWRzLCBzdHJ1Y3QgcmVmICoqdG9fZmV0Y2gpCnsKCXN0cnVjdCBycGNfc3RhdGUgcnBjOwoJc3RydWN0IHN0cmJ1ZiBwcmVhbWJsZSA9IFNUUkJVRl9JTklUOwoJaW50IGksIGVycjsKCXN0cnVjdCBhcmd2X2FycmF5IGFyZ3MgPSBBUkdWX0FSUkFZX0lOSVQ7CgoJYXJndl9hcnJheV9wdXNobCgmYXJncywgImZldGNoLXBhY2siLCAiLS1zdGF0ZWxlc3MtcnBjIiwKCQkJICItLXN0ZGluIiwgIi0tbG9jay1wYWNrIiwgTlVMTCk7CglpZiAob3B0aW9ucy5mb2xsb3d0YWdzKQoJCWFyZ3ZfYXJyYXlfcHVzaCgmYXJncywgIi0taW5jbHVkZS10YWciKTsKCWlmIChvcHRpb25zLnRoaW4pCgkJYXJndl9hcnJheV9wdXNoKCZhcmdzLCAiLS10aGluIik7CglpZiAob3B0aW9ucy52ZXJib3NpdHkgPj0gMykKCQlhcmd2X2FycmF5X3B1c2hsKCZhcmdzLCAiLXYiLCAiLXYiLCBOVUxMKTsKCWlmIChvcHRpb25zLmNoZWNrX3NlbGZfY29udGFpbmVkX2FuZF9jb25uZWN0ZWQpCgkJYXJndl9hcnJheV9wdXNoKCZhcmdzLCAiLS1jaGVjay1zZWxmLWNvbnRhaW5lZC1hbmQtY29ubmVjdGVkIik7CglpZiAob3B0aW9ucy5jbG9uaW5nKQoJCWFyZ3ZfYXJyYXlfcHVzaCgmYXJncywgIi0tY2xvbmluZyIpOwoJaWYgKG9wdGlvbnMudXBkYXRlX3NoYWxsb3cpCgkJYXJndl9hcnJheV9wdXNoKCZhcmdzLCAiLS11cGRhdGUtc2hhbGxvdyIpOwoJaWYgKCFvcHRpb25zLnByb2dyZXNzKQoJCWFyZ3ZfYXJyYXlfcHVzaCgmYXJncywgIi0tbm8tcHJvZ3Jlc3MiKTsKCWlmIChvcHRpb25zLmRlcHRoKQoJCWFyZ3ZfYXJyYXlfcHVzaGYoJmFyZ3MsICItLWRlcHRoPSVsdSIsIG9wdGlvbnMuZGVwdGgpOwoJaWYgKG9wdGlvbnMuZGVlcGVuX3NpbmNlKQoJCWFyZ3ZfYXJyYXlfcHVzaGYoJmFyZ3MsICItLXNoYWxsb3ctc2luY2U9JXMiLCBvcHRpb25zLmRlZXBlbl9zaW5jZSk7Cglmb3IgKGkgPSAwOyBpIDwgb3B0aW9ucy5kZWVwZW5fbm90Lm5yOyBpKyspCgkJYXJndl9hcnJheV9wdXNoZigmYXJncywgIi0tc2hhbGxvdy1leGNsdWRlPSVzIiwKCQkJCSBvcHRpb25zLmRlZXBlbl9ub3QuaXRlbXNbaV0uc3RyaW5nKTsKCWlmIChvcHRpb25zLmRlZXBlbl9yZWxhdGl2ZSAmJiBvcHRpb25zLmRlcHRoKQoJCWFyZ3ZfYXJyYXlfcHVzaCgmYXJncywgIi0tZGVlcGVuLXJlbGF0aXZlIik7Cglhcmd2X2FycmF5X3B1c2goJmFyZ3MsIHVybC5idWYpOwoKCWZvciAoaSA9IDA7IGkgPCBucl9oZWFkczsgaSsrKSB7CgkJc3RydWN0IHJlZiAqcmVmID0gdG9fZmV0Y2hbaV07CgkJaWYgKCEqcmVmLT5uYW1lKQoJCQlkaWUoImNhbm5vdCBmZXRjaCBieSBzaGExIG92ZXIgc21hcnQgaHR0cCIpOwoJCXBhY2tldF9idWZfd3JpdGUoJnByZWFtYmxlLCAiJXMgJXNcbiIsCgkJCQkgb2lkX3RvX2hleCgmcmVmLT5vbGRfb2lkKSwgcmVmLT5uYW1lKTsKCX0KCXBhY2tldF9idWZfZmx1c2goJnByZWFtYmxlKTsKCgltZW1zZXQoJnJwYywgMCwgc2l6ZW9mKHJwYykpOwoJcnBjLnNlcnZpY2VfbmFtZSA9ICJnaXQtdXBsb2FkLXBhY2siLAoJcnBjLmFyZ3YgPSBhcmdzLmFyZ3Y7CglycGMuc3RkaW5fcHJlYW1ibGUgPSAmcHJlYW1ibGU7CglycGMuZ3ppcF9yZXF1ZXN0ID0gMTsKCgllcnIgPSBycGNfc2VydmljZSgmcnBjLCBoZWFkcyk7CglpZiAocnBjLnJlc3VsdC5sZW4pCgkJd3JpdGVfb3JfZGllKDEsIHJwYy5yZXN1bHQuYnVmLCBycGMucmVzdWx0Lmxlbik7CglzdHJidWZfcmVsZWFzZSgmcnBjLnJlc3VsdCk7CglzdHJidWZfcmVsZWFzZSgmcHJlYW1ibGUpOwoJYXJndl9hcnJheV9jbGVhcigmYXJncyk7CglyZXR1cm4gZXJyOwp9CgpzdGF0aWMgaW50IGZldGNoKGludCBucl9oZWFkcywgc3RydWN0IHJlZiAqKnRvX2ZldGNoKQp7CglzdHJ1Y3QgZGlzY292ZXJ5ICpkID0gZGlzY292ZXJfcmVmcygiZ2l0LXVwbG9hZC1wYWNrIiwgMCk7CglpZiAoZC0+cHJvdG9fZ2l0KQoJCXJldHVybiBmZXRjaF9naXQoZCwgbnJfaGVhZHMsIHRvX2ZldGNoKTsKCWVsc2UKCQlyZXR1cm4gZmV0Y2hfZHVtYihucl9oZWFkcywgdG9fZmV0Y2gpOwp9CgpzdGF0aWMgdm9pZCBwYXJzZV9mZXRjaChzdHJ1Y3Qgc3RyYnVmICpidWYpCnsKCXN0cnVjdCByZWYgKip0b19mZXRjaCA9IE5VTEw7CglzdHJ1Y3QgcmVmICpsaXN0X2hlYWQgPSBOVUxMOwoJc3RydWN0IHJlZiAqKmxpc3QgPSAmbGlzdF9oZWFkOwoJaW50IGFsbG9jX2hlYWRzID0gMCwgbnJfaGVhZHMgPSAwOwoKCWRvIHsKCQljb25zdCBjaGFyICpwOwoJCWlmIChza2lwX3ByZWZpeChidWYtPmJ1ZiwgImZldGNoICIsICZwKSkgewoJCQljb25zdCBjaGFyICpuYW1lOwoJCQlzdHJ1Y3QgcmVmICpyZWY7CgkJCXN0cnVjdCBvYmplY3RfaWQgb2xkX29pZDsKCgkJCWlmIChnZXRfb2lkX2hleChwLCAmb2xkX29pZCkpCgkJCQlkaWUoInByb3RvY29sIGVycm9yOiBleHBlY3RlZCBzaGEvcmVmLCBnb3QgJXMnIiwgcCk7CgkJCWlmIChwW0dJVF9TSEExX0hFWFNaXSA9PSAnICcpCgkJCQluYW1lID0gcCArIEdJVF9TSEExX0hFWFNaICsgMTsKCQkJZWxzZSBpZiAoIXBbR0lUX1NIQTFfSEVYU1pdKQoJCQkJbmFtZSA9ICIiOwoJCQllbHNlCgkJCQlkaWUoInByb3RvY29sIGVycm9yOiBleHBlY3RlZCBzaGEvcmVmLCBnb3QgJXMnIiwgcCk7CgoJCQlyZWYgPSBhbGxvY19yZWYobmFtZSk7CgkJCW9pZGNweSgmcmVmLT5vbGRfb2lkLCAmb2xkX29pZCk7CgoJCQkqbGlzdCA9IHJlZjsKCQkJbGlzdCA9ICZyZWYtPm5leHQ7CgoJCQlBTExPQ19HUk9XKHRvX2ZldGNoLCBucl9oZWFkcyArIDEsIGFsbG9jX2hlYWRzKTsKCQkJdG9fZmV0Y2hbbnJfaGVhZHMrK10gPSByZWY7CgkJfQoJCWVsc2UKCQkJZGllKCJodHRwIHRyYW5zcG9ydCBkb2VzIG5vdCBzdXBwb3J0ICVzIiwgYnVmLT5idWYpOwoKCQlzdHJidWZfcmVzZXQoYnVmKTsKCQlpZiAoc3RyYnVmX2dldGxpbmVfbGYoYnVmLCBzdGRpbikgPT0gRU9GKQoJCQlyZXR1cm47CgkJaWYgKCEqYnVmLT5idWYpCgkJCWJyZWFrOwoJfSB3aGlsZSAoMSk7CgoJaWYgKGZldGNoKG5yX2hlYWRzLCB0b19mZXRjaCkpCgkJZXhpdCgxMjgpOyAvKiBlcnJvciBhbHJlYWR5IHJlcG9ydGVkICovCglmcmVlX3JlZnMobGlzdF9oZWFkKTsKCWZyZWUodG9fZmV0Y2gpOwoKCXByaW50ZigiXG4iKTsKCWZmbHVzaChzdGRvdXQpOwoJc3RyYnVmX3Jlc2V0KGJ1Zik7Cn0KCnN0YXRpYyBpbnQgcHVzaF9kYXYoaW50IG5yX3NwZWMsIGNoYXIgKipzcGVjcykKewoJc3RydWN0IGNoaWxkX3Byb2Nlc3MgY2hpbGQgPSBDSElMRF9QUk9DRVNTX0lOSVQ7CglzaXplX3QgaTsKCgljaGlsZC5naXRfY21kID0gMTsKCWFyZ3ZfYXJyYXlfcHVzaCgmY2hpbGQuYXJncywgImh0dHAtcHVzaCIpOwoJYXJndl9hcnJheV9wdXNoKCZjaGlsZC5hcmdzLCAiLS1oZWxwZXItc3RhdHVzIik7CglpZiAob3B0aW9ucy5kcnlfcnVuKQoJCWFyZ3ZfYXJyYXlfcHVzaCgmY2hpbGQuYXJncywgIi0tZHJ5LXJ1biIpOwoJaWYgKG9wdGlvbnMudmVyYm9zaXR5ID4gMSkKCQlhcmd2X2FycmF5X3B1c2goJmNoaWxkLmFyZ3MsICItLXZlcmJvc2UiKTsKCWFyZ3ZfYXJyYXlfcHVzaCgmY2hpbGQuYXJncywgdXJsLmJ1Zik7Cglmb3IgKGkgPSAwOyBpIDwgbnJfc3BlYzsgaSsrKQoJCWFyZ3ZfYXJyYXlfcHVzaCgmY2hpbGQuYXJncywgc3BlY3NbaV0pOwoKCWlmIChydW5fY29tbWFuZCgmY2hpbGQpKQoJCWRpZSgiZ2l0LWh0dHAtcHVzaCBmYWlsZWQiKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IHB1c2hfZ2l0KHN0cnVjdCBkaXNjb3ZlcnkgKmhlYWRzLCBpbnQgbnJfc3BlYywgY2hhciAqKnNwZWNzKQp7CglzdHJ1Y3QgcnBjX3N0YXRlIHJwYzsKCWludCBpLCBlcnI7CglzdHJ1Y3QgYXJndl9hcnJheSBhcmdzOwoJc3RydWN0IHN0cmluZ19saXN0X2l0ZW0gKmNhc19vcHRpb247CglzdHJ1Y3Qgc3RyYnVmIHByZWFtYmxlID0gU1RSQlVGX0lOSVQ7CgoJYXJndl9hcnJheV9pbml0KCZhcmdzKTsKCWFyZ3ZfYXJyYXlfcHVzaGwoJmFyZ3MsICJzZW5kLXBhY2siLCAiLS1zdGF0ZWxlc3MtcnBjIiwgIi0taGVscGVyLXN0YXR1cyIsCgkJCSBOVUxMKTsKCglpZiAob3B0aW9ucy50aGluKQoJCWFyZ3ZfYXJyYXlfcHVzaCgmYXJncywgIi0tdGhpbiIpOwoJaWYgKG9wdGlvbnMuZHJ5X3J1bikKCQlhcmd2X2FycmF5X3B1c2goJmFyZ3MsICItLWRyeS1ydW4iKTsKCWlmIChvcHRpb25zLnB1c2hfY2VydCA9PSBTRU5EX1BBQ0tfUFVTSF9DRVJUX0FMV0FZUykKCQlhcmd2X2FycmF5X3B1c2goJmFyZ3MsICItLXNpZ25lZD15ZXMiKTsKCWVsc2UgaWYgKG9wdGlvbnMucHVzaF9jZXJ0ID09IFNFTkRfUEFDS19QVVNIX0NFUlRfSUZfQVNLRUQpCgkJYXJndl9hcnJheV9wdXNoKCZhcmdzLCAiLS1zaWduZWQ9aWYtYXNrZWQiKTsKCWlmIChvcHRpb25zLnZlcmJvc2l0eSA9PSAwKQoJCWFyZ3ZfYXJyYXlfcHVzaCgmYXJncywgIi0tcXVpZXQiKTsKCWVsc2UgaWYgKG9wdGlvbnMudmVyYm9zaXR5ID4gMSkKCQlhcmd2X2FycmF5X3B1c2goJmFyZ3MsICItLXZlcmJvc2UiKTsKCWZvciAoaSA9IDA7IGkgPCBvcHRpb25zLnB1c2hfb3B0aW9ucy5ucjsgaSsrKQoJCWFyZ3ZfYXJyYXlfcHVzaGYoJmFyZ3MsICItLXB1c2gtb3B0aW9uPSVzIiwKCQkJCSBvcHRpb25zLnB1c2hfb3B0aW9ucy5pdGVtc1tpXS5zdHJpbmcpOwoJYXJndl9hcnJheV9wdXNoKCZhcmdzLCBvcHRpb25zLnByb2dyZXNzID8gIi0tcHJvZ3Jlc3MiIDogIi0tbm8tcHJvZ3Jlc3MiKTsKCWZvcl9lYWNoX3N0cmluZ19saXN0X2l0ZW0oY2FzX29wdGlvbiwgJmNhc19vcHRpb25zKQoJCWFyZ3ZfYXJyYXlfcHVzaCgmYXJncywgY2FzX29wdGlvbi0+c3RyaW5nKTsKCWFyZ3ZfYXJyYXlfcHVzaCgmYXJncywgdXJsLmJ1Zik7CgoJYXJndl9hcnJheV9wdXNoKCZhcmdzLCAiLS1zdGRpbiIpOwoJZm9yIChpID0gMDsgaSA8IG5yX3NwZWM7IGkrKykKCQlwYWNrZXRfYnVmX3dyaXRlKCZwcmVhbWJsZSwgIiVzXG4iLCBzcGVjc1tpXSk7CglwYWNrZXRfYnVmX2ZsdXNoKCZwcmVhbWJsZSk7CgoJbWVtc2V0KCZycGMsIDAsIHNpemVvZihycGMpKTsKCXJwYy5zZXJ2aWNlX25hbWUgPSAiZ2l0LXJlY2VpdmUtcGFjayIsCglycGMuYXJndiA9IGFyZ3MuYXJndjsKCXJwYy5zdGRpbl9wcmVhbWJsZSA9ICZwcmVhbWJsZTsKCgllcnIgPSBycGNfc2VydmljZSgmcnBjLCBoZWFkcyk7CglpZiAocnBjLnJlc3VsdC5sZW4pCgkJd3JpdGVfb3JfZGllKDEsIHJwYy5yZXN1bHQuYnVmLCBycGMucmVzdWx0Lmxlbik7CglzdHJidWZfcmVsZWFzZSgmcnBjLnJlc3VsdCk7CglzdHJidWZfcmVsZWFzZSgmcHJlYW1ibGUpOwoJYXJndl9hcnJheV9jbGVhcigmYXJncyk7CglyZXR1cm4gZXJyOwp9CgpzdGF0aWMgaW50IHB1c2goaW50IG5yX3NwZWMsIGNoYXIgKipzcGVjcykKewoJc3RydWN0IGRpc2NvdmVyeSAqaGVhZHMgPSBkaXNjb3Zlcl9yZWZzKCJnaXQtcmVjZWl2ZS1wYWNrIiwgMSk7CglpbnQgcmV0OwoKCWlmIChoZWFkcy0+cHJvdG9fZ2l0KQoJCXJldCA9IHB1c2hfZ2l0KGhlYWRzLCBucl9zcGVjLCBzcGVjcyk7CgllbHNlCgkJcmV0ID0gcHVzaF9kYXYobnJfc3BlYywgc3BlY3MpOwoJZnJlZV9kaXNjb3ZlcnkoaGVhZHMpOwoJcmV0dXJuIHJldDsKfQoKc3RhdGljIHZvaWQgcGFyc2VfcHVzaChzdHJ1Y3Qgc3RyYnVmICpidWYpCnsKCWNoYXIgKipzcGVjcyA9IE5VTEw7CglpbnQgYWxsb2Nfc3BlYyA9IDAsIG5yX3NwZWMgPSAwLCBpLCByZXQ7CgoJZG8gewoJCWlmIChzdGFydHNfd2l0aChidWYtPmJ1ZiwgInB1c2ggIikpIHsKCQkJQUxMT0NfR1JPVyhzcGVjcywgbnJfc3BlYyArIDEsIGFsbG9jX3NwZWMpOwoJCQlzcGVjc1tucl9zcGVjKytdID0geHN0cmR1cChidWYtPmJ1ZiArIDUpOwoJCX0KCQllbHNlCgkJCWRpZSgiaHR0cCB0cmFuc3BvcnQgZG9lcyBub3Qgc3VwcG9ydCAlcyIsIGJ1Zi0+YnVmKTsKCgkJc3RyYnVmX3Jlc2V0KGJ1Zik7CgkJaWYgKHN0cmJ1Zl9nZXRsaW5lX2xmKGJ1Ziwgc3RkaW4pID09IEVPRikKCQkJZ290byBmcmVlX3NwZWNzOwoJCWlmICghKmJ1Zi0+YnVmKQoJCQlicmVhazsKCX0gd2hpbGUgKDEpOwoKCXJldCA9IHB1c2gobnJfc3BlYywgc3BlY3MpOwoJcHJpbnRmKCJcbiIpOwoJZmZsdXNoKHN0ZG91dCk7CgoJaWYgKHJldCkKCQlleGl0KDEyOCk7IC8qIGVycm9yIGFscmVhZHkgcmVwb3J0ZWQgKi8KCiBmcmVlX3NwZWNzOgoJZm9yIChpID0gMDsgaSA8IG5yX3NwZWM7IGkrKykKCQlmcmVlKHNwZWNzW2ldKTsKCWZyZWUoc3BlY3MpOwp9CgppbnQgY21kX21haW4oaW50IGFyZ2MsIGNvbnN0IGNoYXIgKiphcmd2KQp7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoJaW50IG5vbmdpdDsKCglzZXR1cF9naXRfZGlyZWN0b3J5X2dlbnRseSgmbm9uZ2l0KTsKCWlmIChhcmdjIDwgMikgewoJCWVycm9yKCJyZW1vdGUtY3VybDogdXNhZ2U6IGdpdCByZW1vdGUtY3VybCA8cmVtb3RlPiBbPHVybD5dIik7CgkJcmV0dXJuIDE7Cgl9CgoJb3B0aW9ucy52ZXJib3NpdHkgPSAxOwoJb3B0aW9ucy5wcm9ncmVzcyA9ICEhaXNhdHR5KDIpOwoJb3B0aW9ucy50aGluID0gMTsKCXN0cmluZ19saXN0X2luaXQoJm9wdGlvbnMuZGVlcGVuX25vdCwgMSk7CglzdHJpbmdfbGlzdF9pbml0KCZvcHRpb25zLnB1c2hfb3B0aW9ucywgMSk7CgoJcmVtb3RlID0gcmVtb3RlX2dldChhcmd2WzFdKTsKCglpZiAoYXJnYyA+IDIpIHsKCQllbmRfdXJsX3dpdGhfc2xhc2goJnVybCwgYXJndlsyXSk7Cgl9IGVsc2UgewoJCWVuZF91cmxfd2l0aF9zbGFzaCgmdXJsLCByZW1vdGUtPnVybFswXSk7Cgl9CgoJaHR0cF9pbml0KHJlbW90ZSwgdXJsLmJ1ZiwgMCk7CgoJZG8gewoJCWNvbnN0IGNoYXIgKmFyZzsKCgkJaWYgKHN0cmJ1Zl9nZXRsaW5lX2xmKCZidWYsIHN0ZGluKSA9PSBFT0YpIHsKCQkJaWYgKGZlcnJvcihzdGRpbikpCgkJCQllcnJvcigicmVtb3RlLWN1cmw6IGVycm9yIHJlYWRpbmcgY29tbWFuZCBzdHJlYW0gZnJvbSBnaXQiKTsKCQkJcmV0dXJuIDE7CgkJfQoJCWlmIChidWYubGVuID09IDApCgkJCWJyZWFrOwoJCWlmIChzdGFydHNfd2l0aChidWYuYnVmLCAiZmV0Y2ggIikpIHsKCQkJaWYgKG5vbmdpdCkKCQkJCWRpZSgicmVtb3RlLWN1cmw6IGZldGNoIGF0dGVtcHRlZCB3aXRob3V0IGEgbG9jYWwgcmVwbyIpOwoJCQlwYXJzZV9mZXRjaCgmYnVmKTsKCgkJfSBlbHNlIGlmICghc3RyY21wKGJ1Zi5idWYsICJsaXN0IikgfHwgc3RhcnRzX3dpdGgoYnVmLmJ1ZiwgImxpc3QgIikpIHsKCQkJaW50IGZvcl9wdXNoID0gISFzdHJzdHIoYnVmLmJ1ZiArIDQsICJmb3ItcHVzaCIpOwoJCQlvdXRwdXRfcmVmcyhnZXRfcmVmcyhmb3JfcHVzaCkpOwoKCQl9IGVsc2UgaWYgKHN0YXJ0c193aXRoKGJ1Zi5idWYsICJwdXNoICIpKSB7CgkJCXBhcnNlX3B1c2goJmJ1Zik7CgoJCX0gZWxzZSBpZiAoc2tpcF9wcmVmaXgoYnVmLmJ1ZiwgIm9wdGlvbiAiLCAmYXJnKSkgewoJCQljaGFyICp2YWx1ZSA9IHN0cmNocihhcmcsICcgJyk7CgkJCWludCByZXN1bHQ7CgoJCQlpZiAodmFsdWUpCgkJCQkqdmFsdWUrKyA9ICdcMCc7CgkJCWVsc2UKCQkJCXZhbHVlID0gInRydWUiOwoKCQkJcmVzdWx0ID0gc2V0X29wdGlvbihhcmcsIHZhbHVlKTsKCQkJaWYgKCFyZXN1bHQpCgkJCQlwcmludGYoIm9rXG4iKTsKCQkJZWxzZSBpZiAocmVzdWx0IDwgMCkKCQkJCXByaW50ZigiZXJyb3IgaW52YWxpZCB2YWx1ZVxuIik7CgkJCWVsc2UKCQkJCXByaW50ZigidW5zdXBwb3J0ZWRcbiIpOwoJCQlmZmx1c2goc3Rkb3V0KTsKCgkJfSBlbHNlIGlmICghc3RyY21wKGJ1Zi5idWYsICJjYXBhYmlsaXRpZXMiKSkgewoJCQlwcmludGYoImZldGNoXG4iKTsKCQkJcHJpbnRmKCJvcHRpb25cbiIpOwoJCQlwcmludGYoInB1c2hcbiIpOwoJCQlwcmludGYoImNoZWNrLWNvbm5lY3Rpdml0eVxuIik7CgkJCXByaW50ZigiXG4iKTsKCQkJZmZsdXNoKHN0ZG91dCk7CgkJfSBlbHNlIHsKCQkJZXJyb3IoInJlbW90ZS1jdXJsOiB1bmtub3duIGNvbW1hbmQgJyVzJyBmcm9tIGdpdCIsIGJ1Zi5idWYpOwoJCQlyZXR1cm4gMTsKCQl9CgkJc3RyYnVmX3Jlc2V0KCZidWYpOwoJfSB3aGlsZSAoMSk7CgoJaHR0cF9jbGVhbnVwKCk7CgoJcmV0dXJuIDA7Cn0K",
    "text": "#include \"cache.h\"\n#include \"config.h\"\n#include \"remote.h\"\n#include \"strbuf.h\"\n#include \"walker.h\"\n#include \"http.h\"\n#include \"exec_cmd.h\"\n#include \"run-command.h\"\n#include \"pkt-line.h\"\n#include \"string-list.h\"\n#include \"sideband.h\"\n#include \"argv-array.h\"\n#include \"credential.h\"\n#include \"sha1-array.h\"\n#include \"send-pack.h\"\n\nstatic struct remote *remote;\n/* always ends with a trailing slash */\nstatic struct strbuf url = STRBUF_INIT;\n\nstruct options {\n\tint verbosity;\n\tunsigned long depth;\n\tchar *deepen_since;\n\tstruct string_list deepen_not;\n\tstruct string_list push_options;\n\tunsigned progress : 1,\n\t\tcheck_self_contained_and_connected : 1,\n\t\tcloning : 1,\n\t\tupdate_shallow : 1,\n\t\tfollowtags : 1,\n\t\tdry_run : 1,\n\t\tthin : 1,\n\t\t/* One of the SEND_PACK_PUSH_CERT_* constants. */\n\t\tpush_cert : 2,\n\t\tdeepen_relative : 1;\n};\nstatic struct options options;\nstatic struct string_list cas_options = STRING_LIST_INIT_DUP;\n\nstatic int set_option(const char *name, const char *value)\n{\n\tif (!strcmp(name, \"verbosity\")) {\n\t\tchar *end;\n\t\tint v = strtol(value, &end, 10);\n\t\tif (value == end || *end)\n\t\t\treturn -1;\n\t\toptions.verbosity = v;\n\t\treturn 0;\n\t}\n\telse if (!strcmp(name, \"progress\")) {\n\t\tif (!strcmp(value, \"true\"))\n\t\t\toptions.progress = 1;\n\t\telse if (!strcmp(value, \"false\"))\n\t\t\toptions.progress = 0;\n\t\telse\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\telse if (!strcmp(name, \"depth\")) {\n\t\tchar *end;\n\t\tunsigned long v = strtoul(value, &end, 10);\n\t\tif (value == end || *end)\n\t\t\treturn -1;\n\t\toptions.depth = v;\n\t\treturn 0;\n\t}\n\telse if (!strcmp(name, \"deepen-since\")) {\n\t\toptions.deepen_since = xstrdup(value);\n\t\treturn 0;\n\t}\n\telse if (!strcmp(name, \"deepen-not\")) {\n\t\tstring_list_append(&options.deepen_not, value);\n\t\treturn 0;\n\t}\n\telse if (!strcmp(name, \"deepen-relative\")) {\n\t\tif (!strcmp(value, \"true\"))\n\t\t\toptions.deepen_relative = 1;\n\t\telse if (!strcmp(value, \"false\"))\n\t\t\toptions.deepen_relative = 0;\n\t\telse\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\telse if (!strcmp(name, \"followtags\")) {\n\t\tif (!strcmp(value, \"true\"))\n\t\t\toptions.followtags = 1;\n\t\telse if (!strcmp(value, \"false\"))\n\t\t\toptions.followtags = 0;\n\t\telse\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\telse if (!strcmp(name, \"dry-run\")) {\n\t\tif (!strcmp(value, \"true\"))\n\t\t\toptions.dry_run = 1;\n\t\telse if (!strcmp(value, \"false\"))\n\t\t\toptions.dry_run = 0;\n\t\telse\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\telse if (!strcmp(name, \"check-connectivity\")) {\n\t\tif (!strcmp(value, \"true\"))\n\t\t\toptions.check_self_contained_and_connected = 1;\n\t\telse if (!strcmp(value, \"false\"))\n\t\t\toptions.check_self_contained_and_connected = 0;\n\t\telse\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\telse if (!strcmp(name, \"cas\")) {\n\t\tstruct strbuf val = STRBUF_INIT;\n\t\tstrbuf_addf(&val, \"--\" CAS_OPT_NAME \"=%s\", value);\n\t\tstring_list_append(&cas_options, val.buf);\n\t\tstrbuf_release(&val);\n\t\treturn 0;\n\t} else if (!strcmp(name, \"cloning\")) {\n\t\tif (!strcmp(value, \"true\"))\n\t\t\toptions.cloning = 1;\n\t\telse if (!strcmp(value, \"false\"))\n\t\t\toptions.cloning = 0;\n\t\telse\n\t\t\treturn -1;\n\t\treturn 0;\n\t} else if (!strcmp(name, \"update-shallow\")) {\n\t\tif (!strcmp(value, \"true\"))\n\t\t\toptions.update_shallow = 1;\n\t\telse if (!strcmp(value, \"false\"))\n\t\t\toptions.update_shallow = 0;\n\t\telse\n\t\t\treturn -1;\n\t\treturn 0;\n\t} else if (!strcmp(name, \"pushcert\")) {\n\t\tif (!strcmp(value, \"true\"))\n\t\t\toptions.push_cert = SEND_PACK_PUSH_CERT_ALWAYS;\n\t\telse if (!strcmp(value, \"false\"))\n\t\t\toptions.push_cert = SEND_PACK_PUSH_CERT_NEVER;\n\t\telse if (!strcmp(value, \"if-asked\"))\n\t\t\toptions.push_cert = SEND_PACK_PUSH_CERT_IF_ASKED;\n\t\telse\n\t\t\treturn -1;\n\t\treturn 0;\n\t} else if (!strcmp(name, \"push-option\")) {\n\t\tstring_list_append(&options.push_options, value);\n\t\treturn 0;\n\n#if LIBCURL_VERSION_NUM >= 0x070a08\n\t} else if (!strcmp(name, \"family\")) {\n\t\tif (!strcmp(value, \"ipv4\"))\n\t\t\tgit_curl_ipresolve = CURL_IPRESOLVE_V4;\n\t\telse if (!strcmp(value, \"ipv6\"))\n\t\t\tgit_curl_ipresolve = CURL_IPRESOLVE_V6;\n\t\telse if (!strcmp(value, \"all\"))\n\t\t\tgit_curl_ipresolve = CURL_IPRESOLVE_WHATEVER;\n\t\telse\n\t\t\treturn -1;\n\t\treturn 0;\n#endif /* LIBCURL_VERSION_NUM >= 0x070a08 */\n\t} else {\n\t\treturn 1 /* unsupported */;\n\t}\n}\n\nstruct discovery {\n\tconst char *service;\n\tchar *buf_alloc;\n\tchar *buf;\n\tsize_t len;\n\tstruct ref *refs;\n\tstruct oid_array shallow;\n\tunsigned proto_git : 1;\n};\nstatic struct discovery *last_discovery;\n\nstatic struct ref *parse_git_refs(struct discovery *heads, int for_push)\n{\n\tstruct ref *list = NULL;\n\tget_remote_heads(-1, heads->buf, heads->len, &list,\n\t\t\t for_push ? REF_NORMAL : 0, NULL, &heads->shallow);\n\treturn list;\n}\n\nstatic struct ref *parse_info_refs(struct discovery *heads)\n{\n\tchar *data, *start, *mid;\n\tchar *ref_name;\n\tint i = 0;\n\n\tstruct ref *refs = NULL;\n\tstruct ref *ref = NULL;\n\tstruct ref *last_ref = NULL;\n\n\tdata = heads->buf;\n\tstart = NULL;\n\tmid = data;\n\twhile (i < heads->len) {\n\t\tif (!start) {\n\t\t\tstart = &data[i];\n\t\t}\n\t\tif (data[i] == '\\t')\n\t\t\tmid = &data[i];\n\t\tif (data[i] == '\\n') {\n\t\t\tif (mid - start != 40)\n\t\t\t\tdie(\"%sinfo/refs not valid: is this a git repository?\",\n\t\t\t\t    url.buf);\n\t\t\tdata[i] = 0;\n\t\t\tref_name = mid + 1;\n\t\t\tref = alloc_ref(ref_name);\n\t\t\tget_oid_hex(start, &ref->old_oid);\n\t\t\tif (!refs)\n\t\t\t\trefs = ref;\n\t\t\tif (last_ref)\n\t\t\t\tlast_ref->next = ref;\n\t\t\tlast_ref = ref;\n\t\t\tstart = NULL;\n\t\t}\n\t\ti++;\n\t}\n\n\tref = alloc_ref(\"HEAD\");\n\tif (!http_fetch_ref(url.buf, ref) &&\n\t    !resolve_remote_symref(ref, refs)) {\n\t\tref->next = refs;\n\t\trefs = ref;\n\t} else {\n\t\tfree(ref);\n\t}\n\n\treturn refs;\n}\n\nstatic void free_discovery(struct discovery *d)\n{\n\tif (d) {\n\t\tif (d == last_discovery)\n\t\t\tlast_discovery = NULL;\n\t\tfree(d->shallow.oid);\n\t\tfree(d->buf_alloc);\n\t\tfree_refs(d->refs);\n\t\tfree(d);\n\t}\n}\n\nstatic int show_http_message(struct strbuf *type, struct strbuf *charset,\n\t\t\t     struct strbuf *msg)\n{\n\tconst char *p, *eol;\n\n\t/*\n\t * We only show text/plain parts, as other types are likely\n\t * to be ugly to look at on the user's terminal.\n\t */\n\tif (strcmp(type->buf, \"text/plain\"))\n\t\treturn -1;\n\tif (charset->len)\n\t\tstrbuf_reencode(msg, charset->buf, get_log_output_encoding());\n\n\tstrbuf_trim(msg);\n\tif (!msg->len)\n\t\treturn -1;\n\n\tp = msg->buf;\n\tdo {\n\t\teol = strchrnul(p, '\\n');\n\t\tfprintf(stderr, \"remote: %.*s\\n\", (int)(eol - p), p);\n\t\tp = eol + 1;\n\t} while(*eol);\n\treturn 0;\n}\n\nstatic struct discovery *discover_refs(const char *service, int for_push)\n{\n\tstruct strbuf exp = STRBUF_INIT;\n\tstruct strbuf type = STRBUF_INIT;\n\tstruct strbuf charset = STRBUF_INIT;\n\tstruct strbuf buffer = STRBUF_INIT;\n\tstruct strbuf refs_url = STRBUF_INIT;\n\tstruct strbuf effective_url = STRBUF_INIT;\n\tstruct discovery *last = last_discovery;\n\tint http_ret, maybe_smart = 0;\n\tstruct http_get_options http_options;\n\n\tif (last && !strcmp(service, last->service))\n\t\treturn last;\n\tfree_discovery(last);\n\n\tstrbuf_addf(&refs_url, \"%sinfo/refs\", url.buf);\n\tif ((starts_with(url.buf, \"http://\") || starts_with(url.buf, \"https://\")) &&\n\t     git_env_bool(\"GIT_SMART_HTTP\", 1)) {\n\t\tmaybe_smart = 1;\n\t\tif (!strchr(url.buf, '?'))\n\t\t\tstrbuf_addch(&refs_url, '?');\n\t\telse\n\t\t\tstrbuf_addch(&refs_url, '&');\n\t\tstrbuf_addf(&refs_url, \"service=%s\", service);\n\t}\n\n\tmemset(&http_options, 0, sizeof(http_options));\n\thttp_options.content_type = &type;\n\thttp_options.charset = &charset;\n\thttp_options.effective_url = &effective_url;\n\thttp_options.base_url = &url;\n\thttp_options.initial_request = 1;\n\thttp_options.no_cache = 1;\n\thttp_options.keep_error = 1;\n\n\thttp_ret = http_get_strbuf(refs_url.buf, &buffer, &http_options);\n\tswitch (http_ret) {\n\tcase HTTP_OK:\n\t\tbreak;\n\tcase HTTP_MISSING_TARGET:\n\t\tshow_http_message(&type, &charset, &buffer);\n\t\tdie(\"repository '%s' not found\", url.buf);\n\tcase HTTP_NOAUTH:\n\t\tshow_http_message(&type, &charset, &buffer);\n\t\tdie(\"Authentication failed for '%s'\", url.buf);\n\tdefault:\n\t\tshow_http_message(&type, &charset, &buffer);\n\t\tdie(\"unable to access '%s': %s\", url.buf, curl_errorstr);\n\t}\n\n\tif (options.verbosity && !starts_with(refs_url.buf, url.buf))\n\t\twarning(_(\"redirecting to %s\"), url.buf);\n\n\tlast= xcalloc(1, sizeof(*last_discovery));\n\tlast->service = service;\n\tlast->buf_alloc = strbuf_detach(&buffer, &last->len);\n\tlast->buf = last->buf_alloc;\n\n\tstrbuf_addf(&exp, \"application/x-%s-advertisement\", service);\n\tif (maybe_smart &&\n\t    (5 <= last->len && last->buf[4] == '#') &&\n\t    !strbuf_cmp(&exp, &type)) {\n\t\tchar *line;\n\n\t\t/*\n\t\t * smart HTTP response; validate that the service\n\t\t * pkt-line matches our request.\n\t\t */\n\t\tline = packet_read_line_buf(&last->buf, &last->len, NULL);\n\n\t\tstrbuf_reset(&exp);\n\t\tstrbuf_addf(&exp, \"# service=%s\", service);\n\t\tif (strcmp(line, exp.buf))\n\t\t\tdie(\"invalid server response; got '%s'\", line);\n\t\tstrbuf_release(&exp);\n\n\t\t/* The header can include additional metadata lines, up\n\t\t * until a packet flush marker.  Ignore these now, but\n\t\t * in the future we might start to scan them.\n\t\t */\n\t\twhile (packet_read_line_buf(&last->buf, &last->len, NULL))\n\t\t\t;\n\n\t\tlast->proto_git = 1;\n\t}\n\n\tif (last->proto_git)\n\t\tlast->refs = parse_git_refs(last, for_push);\n\telse\n\t\tlast->refs = parse_info_refs(last);\n\n\tstrbuf_release(&refs_url);\n\tstrbuf_release(&exp);\n\tstrbuf_release(&type);\n\tstrbuf_release(&charset);\n\tstrbuf_release(&effective_url);\n\tstrbuf_release(&buffer);\n\tlast_discovery = last;\n\treturn last;\n}\n\nstatic struct ref *get_refs(int for_push)\n{\n\tstruct discovery *heads;\n\n\tif (for_push)\n\t\theads = discover_refs(\"git-receive-pack\", for_push);\n\telse\n\t\theads = discover_refs(\"git-upload-pack\", for_push);\n\n\treturn heads->refs;\n}\n\nstatic void output_refs(struct ref *refs)\n{\n\tstruct ref *posn;\n\tfor (posn = refs; posn; posn = posn->next) {\n\t\tif (posn->symref)\n\t\t\tprintf(\"@%s %s\\n\", posn->symref, posn->name);\n\t\telse\n\t\t\tprintf(\"%s %s\\n\", oid_to_hex(&posn->old_oid), posn->name);\n\t}\n\tprintf(\"\\n\");\n\tfflush(stdout);\n}\n\nstruct rpc_state {\n\tconst char *service_name;\n\tconst char **argv;\n\tstruct strbuf *stdin_preamble;\n\tchar *service_url;\n\tchar *hdr_content_type;\n\tchar *hdr_accept;\n\tchar *buf;\n\tsize_t alloc;\n\tsize_t len;\n\tsize_t pos;\n\tint in;\n\tint out;\n\tint any_written;\n\tstruct strbuf result;\n\tunsigned gzip_request : 1;\n\tunsigned initial_buffer : 1;\n};\n\nstatic size_t rpc_out(void *ptr, size_t eltsize,\n\t\tsize_t nmemb, void *buffer_)\n{\n\tsize_t max = eltsize * nmemb;\n\tstruct rpc_state *rpc = buffer_;\n\tsize_t avail = rpc->len - rpc->pos;\n\n\tif (!avail) {\n\t\trpc->initial_buffer = 0;\n\t\tavail = packet_read(rpc->out, NULL, NULL, rpc->buf, rpc->alloc, 0);\n\t\tif (!avail)\n\t\t\treturn 0;\n\t\trpc->pos = 0;\n\t\trpc->len = avail;\n\t}\n\n\tif (max < avail)\n\t\tavail = max;\n\tmemcpy(ptr, rpc->buf + rpc->pos, avail);\n\trpc->pos += avail;\n\treturn avail;\n}\n\n#ifndef NO_CURL_IOCTL\nstatic curlioerr rpc_ioctl(CURL *handle, int cmd, void *clientp)\n{\n\tstruct rpc_state *rpc = clientp;\n\n\tswitch (cmd) {\n\tcase CURLIOCMD_NOP:\n\t\treturn CURLIOE_OK;\n\n\tcase CURLIOCMD_RESTARTREAD:\n\t\tif (rpc->initial_buffer) {\n\t\t\trpc->pos = 0;\n\t\t\treturn CURLIOE_OK;\n\t\t}\n\t\terror(\"unable to rewind rpc post data - try increasing http.postBuffer\");\n\t\treturn CURLIOE_FAILRESTART;\n\n\tdefault:\n\t\treturn CURLIOE_UNKNOWNCMD;\n\t}\n}\n#endif\n\nstatic size_t rpc_in(char *ptr, size_t eltsize,\n\t\tsize_t nmemb, void *buffer_)\n{\n\tsize_t size = eltsize * nmemb;\n\tstruct rpc_state *rpc = buffer_;\n\tif (size)\n\t\trpc->any_written = 1;\n\twrite_or_die(rpc->in, ptr, size);\n\treturn size;\n}\n\nstatic int run_slot(struct active_request_slot *slot,\n\t\t    struct slot_results *results)\n{\n\tint err;\n\tstruct slot_results results_buf;\n\n\tif (!results)\n\t\tresults = &results_buf;\n\n\terr = run_one_slot(slot, results);\n\n\tif (err != HTTP_OK && err != HTTP_REAUTH) {\n\t\tstruct strbuf msg = STRBUF_INIT;\n\t\tif (results->http_code && results->http_code != 200)\n\t\t\tstrbuf_addf(&msg, \"HTTP %ld\", results->http_code);\n\t\tif (results->curl_result != CURLE_OK) {\n\t\t\tif (msg.len)\n\t\t\t\tstrbuf_addch(&msg, ' ');\n\t\t\tstrbuf_addf(&msg, \"curl %d\", results->curl_result);\n\t\t\tif (curl_errorstr[0]) {\n\t\t\t\tstrbuf_addch(&msg, ' ');\n\t\t\t\tstrbuf_addstr(&msg, curl_errorstr);\n\t\t\t}\n\t\t}\n\t\terror(\"RPC failed; %s\", msg.buf);\n\t\tstrbuf_release(&msg);\n\t}\n\n\treturn err;\n}\n\nstatic int probe_rpc(struct rpc_state *rpc, struct slot_results *results)\n{\n\tstruct active_request_slot *slot;\n\tstruct curl_slist *headers = http_copy_default_headers();\n\tstruct strbuf buf = STRBUF_INIT;\n\tint err;\n\n\tslot = get_active_slot();\n\n\theaders = curl_slist_append(headers, rpc->hdr_content_type);\n\theaders = curl_slist_append(headers, rpc->hdr_accept);\n\n\tcurl_easy_setopt(slot->curl, CURLOPT_NOBODY, 0);\n\tcurl_easy_setopt(slot->curl, CURLOPT_POST, 1);\n\tcurl_easy_setopt(slot->curl, CURLOPT_URL, rpc->service_url);\n\tcurl_easy_setopt(slot->curl, CURLOPT_ENCODING, NULL);\n\tcurl_easy_setopt(slot->curl, CURLOPT_POSTFIELDS, \"0000\");\n\tcurl_easy_setopt(slot->curl, CURLOPT_POSTFIELDSIZE, 4);\n\tcurl_easy_setopt(slot->curl, CURLOPT_HTTPHEADER, headers);\n\tcurl_easy_setopt(slot->curl, CURLOPT_WRITEFUNCTION, fwrite_buffer);\n\tcurl_easy_setopt(slot->curl, CURLOPT_FILE, &buf);\n\n\terr = run_slot(slot, results);\n\n\tcurl_slist_free_all(headers);\n\tstrbuf_release(&buf);\n\treturn err;\n}\n\nstatic curl_off_t xcurl_off_t(ssize_t len) {\n\tif (len > maximum_signed_value_of_type(curl_off_t))\n\t\tdie(\"cannot handle pushes this big\");\n\treturn (curl_off_t) len;\n}\n\nstatic int post_rpc(struct rpc_state *rpc)\n{\n\tstruct active_request_slot *slot;\n\tstruct curl_slist *headers = http_copy_default_headers();\n\tint use_gzip = rpc->gzip_request;\n\tchar *gzip_body = NULL;\n\tsize_t gzip_size = 0;\n\tint err, large_request = 0;\n\tint needs_100_continue = 0;\n\n\t/* Try to load the entire request, if we can fit it into the\n\t * allocated buffer space we can use HTTP/1.0 and avoid the\n\t * chunked encoding mess.\n\t */\n\twhile (1) {\n\t\tsize_t left = rpc->alloc - rpc->len;\n\t\tchar *buf = rpc->buf + rpc->len;\n\t\tint n;\n\n\t\tif (left < LARGE_PACKET_MAX) {\n\t\t\tlarge_request = 1;\n\t\t\tuse_gzip = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tn = packet_read(rpc->out, NULL, NULL, buf, left, 0);\n\t\tif (!n)\n\t\t\tbreak;\n\t\trpc->len += n;\n\t}\n\n\tif (large_request) {\n\t\tstruct slot_results results;\n\n\t\tdo {\n\t\t\terr = probe_rpc(rpc, &results);\n\t\t\tif (err == HTTP_REAUTH)\n\t\t\t\tcredential_fill(&http_auth);\n\t\t} while (err == HTTP_REAUTH);\n\t\tif (err != HTTP_OK)\n\t\t\treturn -1;\n\n\t\tif (results.auth_avail & CURLAUTH_GSSNEGOTIATE)\n\t\t\tneeds_100_continue = 1;\n\t}\n\n\theaders = curl_slist_append(headers, rpc->hdr_content_type);\n\theaders = curl_slist_append(headers, rpc->hdr_accept);\n\theaders = curl_slist_append(headers, needs_100_continue ?\n\t\t\"Expect: 100-continue\" : \"Expect:\");\n\nretry:\n\tslot = get_active_slot();\n\n\tcurl_easy_setopt(slot->curl, CURLOPT_NOBODY, 0);\n\tcurl_easy_setopt(slot->curl, CURLOPT_POST, 1);\n\tcurl_easy_setopt(slot->curl, CURLOPT_URL, rpc->service_url);\n\tcurl_easy_setopt(slot->curl, CURLOPT_ENCODING, \"gzip\");\n\n\tif (large_request) {\n\t\t/* The request body is large and the size cannot be predicted.\n\t\t * We must use chunked encoding to send it.\n\t\t */\n\t\theaders = curl_slist_append(headers, \"Transfer-Encoding: chunked\");\n\t\trpc->initial_buffer = 1;\n\t\tcurl_easy_setopt(slot->curl, CURLOPT_READFUNCTION, rpc_out);\n\t\tcurl_easy_setopt(slot->curl, CURLOPT_INFILE, rpc);\n#ifndef NO_CURL_IOCTL\n\t\tcurl_easy_setopt(slot->curl, CURLOPT_IOCTLFUNCTION, rpc_ioctl);\n\t\tcurl_easy_setopt(slot->curl, CURLOPT_IOCTLDATA, rpc);\n#endif\n\t\tif (options.verbosity > 1) {\n\t\t\tfprintf(stderr, \"POST %s (chunked)\\n\", rpc->service_name);\n\t\t\tfflush(stderr);\n\t\t}\n\n\t} else if (gzip_body) {\n\t\t/*\n\t\t * If we are looping to retry authentication, then the previous\n\t\t * run will have set up the headers and gzip buffer already,\n\t\t * and we just need to send it.\n\t\t */\n\t\tcurl_easy_setopt(slot->curl, CURLOPT_POSTFIELDS, gzip_body);\n\t\tcurl_easy_setopt(slot->curl, CURLOPT_POSTFIELDSIZE_LARGE, xcurl_off_t(gzip_size));\n\n\t} else if (use_gzip && 1024 < rpc->len) {\n\t\t/* The client backend isn't giving us compressed data so\n\t\t * we can try to deflate it ourselves, this may save on.\n\t\t * the transfer time.\n\t\t */\n\t\tgit_zstream stream;\n\t\tint ret;\n\n\t\tgit_deflate_init_gzip(&stream, Z_BEST_COMPRESSION);\n\t\tgzip_size = git_deflate_bound(&stream, rpc->len);\n\t\tgzip_body = xmalloc(gzip_size);\n\n\t\tstream.next_in = (unsigned char *)rpc->buf;\n\t\tstream.avail_in = rpc->len;\n\t\tstream.next_out = (unsigned char *)gzip_body;\n\t\tstream.avail_out = gzip_size;\n\n\t\tret = git_deflate(&stream, Z_FINISH);\n\t\tif (ret != Z_STREAM_END)\n\t\t\tdie(\"cannot deflate request; zlib deflate error %d\", ret);\n\n\t\tret = git_deflate_end_gently(&stream);\n\t\tif (ret != Z_OK)\n\t\t\tdie(\"cannot deflate request; zlib end error %d\", ret);\n\n\t\tgzip_size = stream.total_out;\n\n\t\theaders = curl_slist_append(headers, \"Content-Encoding: gzip\");\n\t\tcurl_easy_setopt(slot->curl, CURLOPT_POSTFIELDS, gzip_body);\n\t\tcurl_easy_setopt(slot->curl, CURLOPT_POSTFIELDSIZE_LARGE, xcurl_off_t(gzip_size));\n\n\t\tif (options.verbosity > 1) {\n\t\t\tfprintf(stderr, \"POST %s (gzip %lu to %lu bytes)\\n\",\n\t\t\t\trpc->service_name,\n\t\t\t\t(unsigned long)rpc->len, (unsigned long)gzip_size);\n\t\t\tfflush(stderr);\n\t\t}\n\t} else {\n\t\t/* We know the complete request size in advance, use the\n\t\t * more normal Content-Length approach.\n\t\t */\n\t\tcurl_easy_setopt(slot->curl, CURLOPT_POSTFIELDS, rpc->buf);\n\t\tcurl_easy_setopt(slot->curl, CURLOPT_POSTFIELDSIZE_LARGE, xcurl_off_t(rpc->len));\n\t\tif (options.verbosity > 1) {\n\t\t\tfprintf(stderr, \"POST %s (%lu bytes)\\n\",\n\t\t\t\trpc->service_name, (unsigned long)rpc->len);\n\t\t\tfflush(stderr);\n\t\t}\n\t}\n\n\tcurl_easy_setopt(slot->curl, CURLOPT_HTTPHEADER, headers);\n\tcurl_easy_setopt(slot->curl, CURLOPT_WRITEFUNCTION, rpc_in);\n\tcurl_easy_setopt(slot->curl, CURLOPT_FILE, rpc);\n\n\n\trpc->any_written = 0;\n\terr = run_slot(slot, NULL);\n\tif (err == HTTP_REAUTH && !large_request) {\n\t\tcredential_fill(&http_auth);\n\t\tgoto retry;\n\t}\n\tif (err != HTTP_OK)\n\t\terr = -1;\n\n\tif (!rpc->any_written)\n\t\terr = -1;\n\n\tcurl_slist_free_all(headers);\n\tfree(gzip_body);\n\treturn err;\n}\n\nstatic int rpc_service(struct rpc_state *rpc, struct discovery *heads)\n{\n\tconst char *svc = rpc->service_name;\n\tstruct strbuf buf = STRBUF_INIT;\n\tstruct strbuf *preamble = rpc->stdin_preamble;\n\tstruct child_process client = CHILD_PROCESS_INIT;\n\tint err = 0;\n\n\tclient.in = -1;\n\tclient.out = -1;\n\tclient.git_cmd = 1;\n\tclient.argv = rpc->argv;\n\tif (start_command(&client))\n\t\texit(1);\n\tif (preamble)\n\t\twrite_or_die(client.in, preamble->buf, preamble->len);\n\tif (heads)\n\t\twrite_or_die(client.in, heads->buf, heads->len);\n\n\trpc->alloc = http_post_buffer;\n\trpc->buf = xmalloc(rpc->alloc);\n\trpc->in = client.in;\n\trpc->out = client.out;\n\tstrbuf_init(&rpc->result, 0);\n\n\tstrbuf_addf(&buf, \"%s%s\", url.buf, svc);\n\trpc->service_url = strbuf_detach(&buf, NULL);\n\n\tstrbuf_addf(&buf, \"Content-Type: application/x-%s-request\", svc);\n\trpc->hdr_content_type = strbuf_detach(&buf, NULL);\n\n\tstrbuf_addf(&buf, \"Accept: application/x-%s-result\", svc);\n\trpc->hdr_accept = strbuf_detach(&buf, NULL);\n\n\twhile (!err) {\n\t\tint n = packet_read(rpc->out, NULL, NULL, rpc->buf, rpc->alloc, 0);\n\t\tif (!n)\n\t\t\tbreak;\n\t\trpc->pos = 0;\n\t\trpc->len = n;\n\t\terr |= post_rpc(rpc);\n\t}\n\n\tclose(client.in);\n\tclient.in = -1;\n\tif (!err) {\n\t\tstrbuf_read(&rpc->result, client.out, 0);\n\t} else {\n\t\tchar buf[4096];\n\t\tfor (;;)\n\t\t\tif (xread(client.out, buf, sizeof(buf)) <= 0)\n\t\t\t\tbreak;\n\t}\n\n\tclose(client.out);\n\tclient.out = -1;\n\n\terr |= finish_command(&client);\n\tfree(rpc->service_url);\n\tfree(rpc->hdr_content_type);\n\tfree(rpc->hdr_accept);\n\tfree(rpc->buf);\n\tstrbuf_release(&buf);\n\treturn err;\n}\n\nstatic int fetch_dumb(int nr_heads, struct ref **to_fetch)\n{\n\tstruct walker *walker;\n\tchar **targets;\n\tint ret, i;\n\n\tALLOC_ARRAY(targets, nr_heads);\n\tif (options.depth || options.deepen_since)\n\t\tdie(\"dumb http transport does not support shallow capabilities\");\n\tfor (i = 0; i < nr_heads; i++)\n\t\ttargets[i] = xstrdup(oid_to_hex(&to_fetch[i]->old_oid));\n\n\twalker = get_http_walker(url.buf);\n\twalker->get_all = 1;\n\twalker->get_tree = 1;\n\twalker->get_history = 1;\n\twalker->get_verbosely = options.verbosity >= 3;\n\twalker->get_recover = 0;\n\tret = walker_fetch(walker, nr_heads, targets, NULL, NULL);\n\twalker_free(walker);\n\n\tfor (i = 0; i < nr_heads; i++)\n\t\tfree(targets[i]);\n\tfree(targets);\n\n\treturn ret ? error(\"fetch failed.\") : 0;\n}\n\nstatic int fetch_git(struct discovery *heads,\n\tint nr_heads, struct ref **to_fetch)\n{\n\tstruct rpc_state rpc;\n\tstruct strbuf preamble = STRBUF_INIT;\n\tint i, err;\n\tstruct argv_array args = ARGV_ARRAY_INIT;\n\n\targv_array_pushl(&args, \"fetch-pack\", \"--stateless-rpc\",\n\t\t\t \"--stdin\", \"--lock-pack\", NULL);\n\tif (options.followtags)\n\t\targv_array_push(&args, \"--include-tag\");\n\tif (options.thin)\n\t\targv_array_push(&args, \"--thin\");\n\tif (options.verbosity >= 3)\n\t\targv_array_pushl(&args, \"-v\", \"-v\", NULL);\n\tif (options.check_self_contained_and_connected)\n\t\targv_array_push(&args, \"--check-self-contained-and-connected\");\n\tif (options.cloning)\n\t\targv_array_push(&args, \"--cloning\");\n\tif (options.update_shallow)\n\t\targv_array_push(&args, \"--update-shallow\");\n\tif (!options.progress)\n\t\targv_array_push(&args, \"--no-progress\");\n\tif (options.depth)\n\t\targv_array_pushf(&args, \"--depth=%lu\", options.depth);\n\tif (options.deepen_since)\n\t\targv_array_pushf(&args, \"--shallow-since=%s\", options.deepen_since);\n\tfor (i = 0; i < options.deepen_not.nr; i++)\n\t\targv_array_pushf(&args, \"--shallow-exclude=%s\",\n\t\t\t\t options.deepen_not.items[i].string);\n\tif (options.deepen_relative && options.depth)\n\t\targv_array_push(&args, \"--deepen-relative\");\n\targv_array_push(&args, url.buf);\n\n\tfor (i = 0; i < nr_heads; i++) {\n\t\tstruct ref *ref = to_fetch[i];\n\t\tif (!*ref->name)\n\t\t\tdie(\"cannot fetch by sha1 over smart http\");\n\t\tpacket_buf_write(&preamble, \"%s %s\\n\",\n\t\t\t\t oid_to_hex(&ref->old_oid), ref->name);\n\t}\n\tpacket_buf_flush(&preamble);\n\n\tmemset(&rpc, 0, sizeof(rpc));\n\trpc.service_name = \"git-upload-pack\",\n\trpc.argv = args.argv;\n\trpc.stdin_preamble = &preamble;\n\trpc.gzip_request = 1;\n\n\terr = rpc_service(&rpc, heads);\n\tif (rpc.result.len)\n\t\twrite_or_die(1, rpc.result.buf, rpc.result.len);\n\tstrbuf_release(&rpc.result);\n\tstrbuf_release(&preamble);\n\targv_array_clear(&args);\n\treturn err;\n}\n\nstatic int fetch(int nr_heads, struct ref **to_fetch)\n{\n\tstruct discovery *d = discover_refs(\"git-upload-pack\", 0);\n\tif (d->proto_git)\n\t\treturn fetch_git(d, nr_heads, to_fetch);\n\telse\n\t\treturn fetch_dumb(nr_heads, to_fetch);\n}\n\nstatic void parse_fetch(struct strbuf *buf)\n{\n\tstruct ref **to_fetch = NULL;\n\tstruct ref *list_head = NULL;\n\tstruct ref **list = &list_head;\n\tint alloc_heads = 0, nr_heads = 0;\n\n\tdo {\n\t\tconst char *p;\n\t\tif (skip_prefix(buf->buf, \"fetch \", &p)) {\n\t\t\tconst char *name;\n\t\t\tstruct ref *ref;\n\t\t\tstruct object_id old_oid;\n\n\t\t\tif (get_oid_hex(p, &old_oid))\n\t\t\t\tdie(\"protocol error: expected sha/ref, got %s'\", p);\n\t\t\tif (p[GIT_SHA1_HEXSZ] == ' ')\n\t\t\t\tname = p + GIT_SHA1_HEXSZ + 1;\n\t\t\telse if (!p[GIT_SHA1_HEXSZ])\n\t\t\t\tname = \"\";\n\t\t\telse\n\t\t\t\tdie(\"protocol error: expected sha/ref, got %s'\", p);\n\n\t\t\tref = alloc_ref(name);\n\t\t\toidcpy(&ref->old_oid, &old_oid);\n\n\t\t\t*list = ref;\n\t\t\tlist = &ref->next;\n\n\t\t\tALLOC_GROW(to_fetch, nr_heads + 1, alloc_heads);\n\t\t\tto_fetch[nr_heads++] = ref;\n\t\t}\n\t\telse\n\t\t\tdie(\"http transport does not support %s\", buf->buf);\n\n\t\tstrbuf_reset(buf);\n\t\tif (strbuf_getline_lf(buf, stdin) == EOF)\n\t\t\treturn;\n\t\tif (!*buf->buf)\n\t\t\tbreak;\n\t} while (1);\n\n\tif (fetch(nr_heads, to_fetch))\n\t\texit(128); /* error already reported */\n\tfree_refs(list_head);\n\tfree(to_fetch);\n\n\tprintf(\"\\n\");\n\tfflush(stdout);\n\tstrbuf_reset(buf);\n}\n\nstatic int push_dav(int nr_spec, char **specs)\n{\n\tstruct child_process child = CHILD_PROCESS_INIT;\n\tsize_t i;\n\n\tchild.git_cmd = 1;\n\targv_array_push(&child.args, \"http-push\");\n\targv_array_push(&child.args, \"--helper-status\");\n\tif (options.dry_run)\n\t\targv_array_push(&child.args, \"--dry-run\");\n\tif (options.verbosity > 1)\n\t\targv_array_push(&child.args, \"--verbose\");\n\targv_array_push(&child.args, url.buf);\n\tfor (i = 0; i < nr_spec; i++)\n\t\targv_array_push(&child.args, specs[i]);\n\n\tif (run_command(&child))\n\t\tdie(\"git-http-push failed\");\n\treturn 0;\n}\n\nstatic int push_git(struct discovery *heads, int nr_spec, char **specs)\n{\n\tstruct rpc_state rpc;\n\tint i, err;\n\tstruct argv_array args;\n\tstruct string_list_item *cas_option;\n\tstruct strbuf preamble = STRBUF_INIT;\n\n\targv_array_init(&args);\n\targv_array_pushl(&args, \"send-pack\", \"--stateless-rpc\", \"--helper-status\",\n\t\t\t NULL);\n\n\tif (options.thin)\n\t\targv_array_push(&args, \"--thin\");\n\tif (options.dry_run)\n\t\targv_array_push(&args, \"--dry-run\");\n\tif (options.push_cert == SEND_PACK_PUSH_CERT_ALWAYS)\n\t\targv_array_push(&args, \"--signed=yes\");\n\telse if (options.push_cert == SEND_PACK_PUSH_CERT_IF_ASKED)\n\t\targv_array_push(&args, \"--signed=if-asked\");\n\tif (options.verbosity == 0)\n\t\targv_array_push(&args, \"--quiet\");\n\telse if (options.verbosity > 1)\n\t\targv_array_push(&args, \"--verbose\");\n\tfor (i = 0; i < options.push_options.nr; i++)\n\t\targv_array_pushf(&args, \"--push-option=%s\",\n\t\t\t\t options.push_options.items[i].string);\n\targv_array_push(&args, options.progress ? \"--progress\" : \"--no-progress\");\n\tfor_each_string_list_item(cas_option, &cas_options)\n\t\targv_array_push(&args, cas_option->string);\n\targv_array_push(&args, url.buf);\n\n\targv_array_push(&args, \"--stdin\");\n\tfor (i = 0; i < nr_spec; i++)\n\t\tpacket_buf_write(&preamble, \"%s\\n\", specs[i]);\n\tpacket_buf_flush(&preamble);\n\n\tmemset(&rpc, 0, sizeof(rpc));\n\trpc.service_name = \"git-receive-pack\",\n\trpc.argv = args.argv;\n\trpc.stdin_preamble = &preamble;\n\n\terr = rpc_service(&rpc, heads);\n\tif (rpc.result.len)\n\t\twrite_or_die(1, rpc.result.buf, rpc.result.len);\n\tstrbuf_release(&rpc.result);\n\tstrbuf_release(&preamble);\n\targv_array_clear(&args);\n\treturn err;\n}\n\nstatic int push(int nr_spec, char **specs)\n{\n\tstruct discovery *heads = discover_refs(\"git-receive-pack\", 1);\n\tint ret;\n\n\tif (heads->proto_git)\n\t\tret = push_git(heads, nr_spec, specs);\n\telse\n\t\tret = push_dav(nr_spec, specs);\n\tfree_discovery(heads);\n\treturn ret;\n}\n\nstatic void parse_push(struct strbuf *buf)\n{\n\tchar **specs = NULL;\n\tint alloc_spec = 0, nr_spec = 0, i, ret;\n\n\tdo {\n\t\tif (starts_with(buf->buf, \"push \")) {\n\t\t\tALLOC_GROW(specs, nr_spec + 1, alloc_spec);\n\t\t\tspecs[nr_spec++] = xstrdup(buf->buf + 5);\n\t\t}\n\t\telse\n\t\t\tdie(\"http transport does not support %s\", buf->buf);\n\n\t\tstrbuf_reset(buf);\n\t\tif (strbuf_getline_lf(buf, stdin) == EOF)\n\t\t\tgoto free_specs;\n\t\tif (!*buf->buf)\n\t\t\tbreak;\n\t} while (1);\n\n\tret = push(nr_spec, specs);\n\tprintf(\"\\n\");\n\tfflush(stdout);\n\n\tif (ret)\n\t\texit(128); /* error already reported */\n\n free_specs:\n\tfor (i = 0; i < nr_spec; i++)\n\t\tfree(specs[i]);\n\tfree(specs);\n}\n\nint cmd_main(int argc, const char **argv)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tint nongit;\n\n\tsetup_git_directory_gently(&nongit);\n\tif (argc < 2) {\n\t\terror(\"remote-curl: usage: git remote-curl <remote> [<url>]\");\n\t\treturn 1;\n\t}\n\n\toptions.verbosity = 1;\n\toptions.progress = !!isatty(2);\n\toptions.thin = 1;\n\tstring_list_init(&options.deepen_not, 1);\n\tstring_list_init(&options.push_options, 1);\n\n\tremote = remote_get(argv[1]);\n\n\tif (argc > 2) {\n\t\tend_url_with_slash(&url, argv[2]);\n\t} else {\n\t\tend_url_with_slash(&url, remote->url[0]);\n\t}\n\n\thttp_init(remote, url.buf, 0);\n\n\tdo {\n\t\tconst char *arg;\n\n\t\tif (strbuf_getline_lf(&buf, stdin) == EOF) {\n\t\t\tif (ferror(stdin))\n\t\t\t\terror(\"remote-curl: error reading command stream from git\");\n\t\t\treturn 1;\n\t\t}\n\t\tif (buf.len == 0)\n\t\t\tbreak;\n\t\tif (starts_with(buf.buf, \"fetch \")) {\n\t\t\tif (nongit)\n\t\t\t\tdie(\"remote-curl: fetch attempted without a local repo\");\n\t\t\tparse_fetch(&buf);\n\n\t\t} else if (!strcmp(buf.buf, \"list\") || starts_with(buf.buf, \"list \")) {\n\t\t\tint for_push = !!strstr(buf.buf + 4, \"for-push\");\n\t\t\toutput_refs(get_refs(for_push));\n\n\t\t} else if (starts_with(buf.buf, \"push \")) {\n\t\t\tparse_push(&buf);\n\n\t\t} else if (skip_prefix(buf.buf, \"option \", &arg)) {\n\t\t\tchar *value = strchr(arg, ' ');\n\t\t\tint result;\n\n\t\t\tif (value)\n\t\t\t\t*value++ = '\\0';\n\t\t\telse\n\t\t\t\tvalue = \"true\";\n\n\t\t\tresult = set_option(arg, value);\n\t\t\tif (!result)\n\t\t\t\tprintf(\"ok\\n\");\n\t\t\telse if (result < 0)\n\t\t\t\tprintf(\"error invalid value\\n\");\n\t\t\telse\n\t\t\t\tprintf(\"unsupported\\n\");\n\t\t\tfflush(stdout);\n\n\t\t} else if (!strcmp(buf.buf, \"capabilities\")) {\n\t\t\tprintf(\"fetch\\n\");\n\t\t\tprintf(\"option\\n\");\n\t\t\tprintf(\"push\\n\");\n\t\t\tprintf(\"check-connectivity\\n\");\n\t\t\tprintf(\"\\n\");\n\t\t\tfflush(stdout);\n\t\t} else {\n\t\t\terror(\"remote-curl: unknown command '%s' from git\", buf.buf);\n\t\t\treturn 1;\n\t\t}\n\t\tstrbuf_reset(&buf);\n\t} while (1);\n\n\thttp_cleanup();\n\n\treturn 0;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0053b09549ab419ab8f2da2c519d689f5e0d83b3",
  "sha1_ok": true,
  "size": 27939
}
