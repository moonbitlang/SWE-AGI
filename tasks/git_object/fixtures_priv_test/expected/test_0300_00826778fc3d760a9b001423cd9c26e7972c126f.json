{
  "content": {
    "base64": "LyoKICogQ29weXJpZ2h0IDIwMDYgSm9uIExvZWxpZ2VyCiAqLwoKI2luY2x1ZGUgImdpdC1jb21wYXQtdXRpbC5oIgojaW5jbHVkZSAiaW50ZXJwb2xhdGUuaCIKCgp2b2lkIGludGVycF9zZXRfZW50cnkoc3RydWN0IGludGVycCAqdGFibGUsIGludCBzbG90LCBjb25zdCBjaGFyICp2YWx1ZSkKewoJY2hhciAqb2xkdmFsID0gdGFibGVbc2xvdF0udmFsdWU7CgljaGFyICpuZXd2YWwgPSBOVUxMOwoKCWlmIChvbGR2YWwpCgkJZnJlZShvbGR2YWwpOwoKCWlmICh2YWx1ZSkKCQluZXd2YWwgPSB4c3RyZHVwKHZhbHVlKTsKCgl0YWJsZVtzbG90XS52YWx1ZSA9IG5ld3ZhbDsKfQoKCnZvaWQgaW50ZXJwX2NsZWFyX3RhYmxlKHN0cnVjdCBpbnRlcnAgKnRhYmxlLCBpbnQgbmludGVycHMpCnsKCWludCBpOwoKCWZvciAoaSA9IDA7IGkgPCBuaW50ZXJwczsgaSsrKSB7CgkJaW50ZXJwX3NldF9lbnRyeSh0YWJsZSwgaSwgTlVMTCk7Cgl9Cn0KCgovKgogKiBDb252ZXJ0IGEgTlVMLXRlcm1pbmF0ZWQgc3RyaW5nIGluIGJ1ZmZlciBvcmlnCiAqIGludG8gdGhlIHN1cHBsaWVkIGJ1ZmZlciwgcmVzdWx0LCB3aG9zZSBsZW5ndGggaXMgcmVzbGVuLAogKiBwZXJmb3JtaW5nIHN1YnN0aXR1dGlvbnMgb24gJS1uYW1lZCBzdWItc3RyaW5ncyBmcm9tCiAqIHRoZSB0YWJsZSwgaW50ZXJwcywgd2l0aCBuaW50ZXJwcyBlbnRyaWVzLgogKgogKiBFeGFtcGxlIGludGVycHM6CiAqICAgIHsKICogICAgICAgIHsgIiVIIiwgImV4YW1wbGUub3JnIn0sCiAqICAgICAgICB7ICIlcG9ydCIsICIxMjMifSwKICogICAgICAgIHsgIiUlIiwgIiUifSwKICogICAgfQogKgogKiBSZXR1cm5zIDAgb24gYSBzdWNjZXNzZnVsIHN1YnN0aXR1dGlvbiBwYXNzIHRoYXQgZml0cyBpbiByZXN1bHQsCiAqIFJldHVybnMgYSBudW1iZXIgb2YgYnl0ZXMgbmVlZGVkIHRvIGhvbGQgdGhlIGZ1bGwgc3Vic3RpdHV0ZWQKICogc3RyaW5nIG90aGVyd2lzZS4KICovCgp1bnNpZ25lZCBsb25nIGludGVycG9sYXRlKGNoYXIgKnJlc3VsdCwgdW5zaWduZWQgbG9uZyByZXNsZW4sCgkJY29uc3QgY2hhciAqb3JpZywKCQljb25zdCBzdHJ1Y3QgaW50ZXJwICppbnRlcnBzLCBpbnQgbmludGVycHMpCnsKCWNvbnN0IGNoYXIgKnNyYyA9IG9yaWc7CgljaGFyICpkZXN0ID0gcmVzdWx0OwoJdW5zaWduZWQgbG9uZyBuZXdsZW4gPSAwOwoJY29uc3QgY2hhciAqbmFtZSwgKnZhbHVlOwoJdW5zaWduZWQgbG9uZyBuYW1lbGVuLCB2YWx1ZWxlbjsKCWludCBpOwoJY2hhciBjOwoKICAgICAgICBtZW1zZXQocmVzdWx0LCAwLCByZXNsZW4pOwoKCXdoaWxlICgoYyA9ICpzcmMpKSB7CgkJaWYgKGMgPT0gJyUnKSB7CgkJCS8qIFRyeSB0byBtYXRjaCBhbiBpbnRlcnBvbGF0aW9uIHN0cmluZy4gKi8KCQkJZm9yIChpID0gMDsgaSA8IG5pbnRlcnBzOyBpKyspIHsKCQkJCW5hbWUgPSBpbnRlcnBzW2ldLm5hbWU7CgkJCQluYW1lbGVuID0gc3RybGVuKG5hbWUpOwoJCQkJaWYgKHN0cm5jbXAoc3JjLCBuYW1lLCBuYW1lbGVuKSA9PSAwKQoJCQkJCWJyZWFrOwoJCQl9CgoJCQkvKiBDaGVjayBmb3IgdmFsaWQgaW50ZXJwb2xhdGlvbi4gKi8KCQkJaWYgKGkgPCBuaW50ZXJwcykgewoJCQkJdmFsdWUgPSBpbnRlcnBzW2ldLnZhbHVlOwoJCQkJdmFsdWVsZW4gPSBzdHJsZW4odmFsdWUpOwoKCQkJCWlmIChuZXdsZW4gKyB2YWx1ZWxlbiArIDEgPCByZXNsZW4pIHsKCQkJCQkvKiBTdWJzdGl0dXRlLiAqLwoJCQkJCXN0cm5jcHkoZGVzdCwgdmFsdWUsIHZhbHVlbGVuKTsKCQkJCQlkZXN0ICs9IHZhbHVlbGVuOwoJCQkJfQoJCQkJbmV3bGVuICs9IHZhbHVlbGVuOwoJCQkJc3JjICs9IG5hbWVsZW47CgkJCQljb250aW51ZTsKCQkJfQoJCX0KCQkvKiBTdHJhaWdodCBjb3B5IG9uZSBub24taW50ZXJwb2xhdGlvbiBjaGFyYWN0ZXIuICovCgkJaWYgKG5ld2xlbiArIDEgPCByZXNsZW4pCgkJCSpkZXN0KysgPSAqc3JjOwoJCXNyYysrOwoJCW5ld2xlbisrOwoJfQoKCWlmIChuZXdsZW4gKyAxIDwgcmVzbGVuKQoJCXJldHVybiAwOwoJZWxzZQoJCXJldHVybiBuZXdsZW4gKyAyOwp9Cg==",
    "text": "/*\n * Copyright 2006 Jon Loeliger\n */\n\n#include \"git-compat-util.h\"\n#include \"interpolate.h\"\n\n\nvoid interp_set_entry(struct interp *table, int slot, const char *value)\n{\n\tchar *oldval = table[slot].value;\n\tchar *newval = NULL;\n\n\tif (oldval)\n\t\tfree(oldval);\n\n\tif (value)\n\t\tnewval = xstrdup(value);\n\n\ttable[slot].value = newval;\n}\n\n\nvoid interp_clear_table(struct interp *table, int ninterps)\n{\n\tint i;\n\n\tfor (i = 0; i < ninterps; i++) {\n\t\tinterp_set_entry(table, i, NULL);\n\t}\n}\n\n\n/*\n * Convert a NUL-terminated string in buffer orig\n * into the supplied buffer, result, whose length is reslen,\n * performing substitutions on %-named sub-strings from\n * the table, interps, with ninterps entries.\n *\n * Example interps:\n *    {\n *        { \"%H\", \"example.org\"},\n *        { \"%port\", \"123\"},\n *        { \"%%\", \"%\"},\n *    }\n *\n * Returns 0 on a successful substitution pass that fits in result,\n * Returns a number of bytes needed to hold the full substituted\n * string otherwise.\n */\n\nunsigned long interpolate(char *result, unsigned long reslen,\n\t\tconst char *orig,\n\t\tconst struct interp *interps, int ninterps)\n{\n\tconst char *src = orig;\n\tchar *dest = result;\n\tunsigned long newlen = 0;\n\tconst char *name, *value;\n\tunsigned long namelen, valuelen;\n\tint i;\n\tchar c;\n\n        memset(result, 0, reslen);\n\n\twhile ((c = *src)) {\n\t\tif (c == '%') {\n\t\t\t/* Try to match an interpolation string. */\n\t\t\tfor (i = 0; i < ninterps; i++) {\n\t\t\t\tname = interps[i].name;\n\t\t\t\tnamelen = strlen(name);\n\t\t\t\tif (strncmp(src, name, namelen) == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Check for valid interpolation. */\n\t\t\tif (i < ninterps) {\n\t\t\t\tvalue = interps[i].value;\n\t\t\t\tvaluelen = strlen(value);\n\n\t\t\t\tif (newlen + valuelen + 1 < reslen) {\n\t\t\t\t\t/* Substitute. */\n\t\t\t\t\tstrncpy(dest, value, valuelen);\n\t\t\t\t\tdest += valuelen;\n\t\t\t\t}\n\t\t\t\tnewlen += valuelen;\n\t\t\t\tsrc += namelen;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t/* Straight copy one non-interpolation character. */\n\t\tif (newlen + 1 < reslen)\n\t\t\t*dest++ = *src;\n\t\tsrc++;\n\t\tnewlen++;\n\t}\n\n\tif (newlen + 1 < reslen)\n\t\treturn 0;\n\telse\n\t\treturn newlen + 2;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00826778fc3d760a9b001423cd9c26e7972c126f",
  "sha1_ok": true,
  "size": 2056
}
