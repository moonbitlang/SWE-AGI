{
  "content": {
    "base64": "TGlrZSBvdGhlciBwcm9qZWN0cywgd2UgYWxzbyBoYXZlIHNvbWUgZ3VpZGVsaW5lcyB0byBrZWVwIHRvIHRoZQpjb2RlLiAgRm9yIEdpdCBpbiBnZW5lcmFsLCBhIGZldyByb3VnaCBydWxlcyBhcmU6CgogLSBNb3N0IGltcG9ydGFudGx5LCB3ZSBuZXZlciBzYXkgIkl0J3MgaW4gUE9TSVg7IHdlJ2xsIGhhcHBpbHkKICAgaWdub3JlIHlvdXIgbmVlZHMgc2hvdWxkIHlvdXIgc3lzdGVtIG5vdCBjb25mb3JtIHRvIGl0LiIKICAgV2UgbGl2ZSBpbiB0aGUgcmVhbCB3b3JsZC4KCiAtIEhvd2V2ZXIsIHdlIG9mdGVuIHNheSAiTGV0J3Mgc3RheSBhd2F5IGZyb20gdGhhdCBjb25zdHJ1Y3QsCiAgIGl0J3Mgbm90IGV2ZW4gaW4gUE9TSVgiLgoKIC0gSW4gc3BpdGUgb2YgdGhlIGFib3ZlIHR3byBydWxlcywgd2Ugc29tZXRpbWVzIHNheSAiQWx0aG91Z2gKICAgdGhpcyBpcyBub3QgaW4gUE9TSVgsIGl0IChpcyBzbyBjb252ZW5pZW50IHwgbWFrZXMgdGhlIGNvZGUKICAgbXVjaCBtb3JlIHJlYWRhYmxlIHwgaGFzIG90aGVyIGdvb2QgY2hhcmFjdGVyaXN0aWNzKSBhbmQKICAgcHJhY3RpY2FsbHkgYWxsIHRoZSBwbGF0Zm9ybXMgd2UgY2FyZSBhYm91dCBzdXBwb3J0IGl0LCBzbwogICBsZXQncyB1c2UgaXQiLgoKICAgQWdhaW4sIHdlIGxpdmUgaW4gdGhlIHJlYWwgd29ybGQsIGFuZCBpdCBpcyBzb21ldGltZXMgYQogICBqdWRnZW1lbnQgY2FsbCwgdGhlIGRlY2lzaW9uIGJhc2VkIG1vcmUgb24gcmVhbCB3b3JsZAogICBjb25zdHJhaW50cyBwZW9wbGUgZmFjZSB0aGFuIHdoYXQgdGhlIHBhcGVyIHN0YW5kYXJkIHNheXMuCgogLSBGaXhpbmcgc3R5bGUgdmlvbGF0aW9ucyB3aGlsZSB3b3JraW5nIG9uIGEgcmVhbCBjaGFuZ2UgYXMgYQogICBwcmVwYXJhdG9yeSBjbGVhbi11cCBzdGVwIGlzIGdvb2QsIGJ1dCBvdGhlcndpc2UgYXZvaWQgdXNlbGVzcyBjb2RlCiAgIGNodXJuIGZvciB0aGUgc2FrZSBvZiBjb25mb3JtaW5nIHRvIHRoZSBzdHlsZS4KCiAgICJPbmNlIGl0IF9pc18gaW4gdGhlIHRyZWUsIGl0J3Mgbm90IHJlYWxseSB3b3J0aCB0aGUgcGF0Y2ggbm9pc2UgdG8KICAgZ28gYW5kIGZpeCBpdCB1cC4iCiAgIENmLiBodHRwOi8vbGttbC5pdS5lZHUvaHlwZXJtYWlsL2xpbnV4L2tlcm5lbC8xMDAxLjMvMDEwNjkuaHRtbAoKIC0gTG9nIG1lc3NhZ2VzIHRvIGV4cGxhaW4geW91ciBjaGFuZ2VzIGFyZSBhcyBpbXBvcnRhbnQgYXMgdGhlCiAgIGNoYW5nZXMgdGhlbXNlbHZlcy4gIENsZWFybHkgd3JpdHRlbiBjb2RlIGFuZCBpbi1jb2RlIGNvbW1lbnRzCiAgIGV4cGxhaW4gaG93IHRoZSBjb2RlIHdvcmtzIGFuZCB3aGF0IGlzIGFzc3VtZWQgZnJvbSB0aGUgc3Vycm91bmRpbmcKICAgY29udGV4dC4gIFRoZSBsb2cgbWVzc2FnZXMgZXhwbGFpbiB3aGF0IHRoZSBjaGFuZ2VzIHdhbnRlZCB0bwogICBhY2hpZXZlIGFuZCB3aHkgdGhlIGNoYW5nZXMgd2VyZSBuZWNlc3NhcnkgKG1vcmUgb24gdGhpcyBpbiB0aGUKICAgYWNjb21wYW55aW5nIFN1Ym1pdHRpbmdQYXRjaGVzIGRvY3VtZW50KS4KCk1ha2UgeW91ciBjb2RlIHJlYWRhYmxlIGFuZCBzZW5zaWJsZSwgYW5kIGRvbid0IHRyeSB0byBiZSBjbGV2ZXIuCgpBcyBmb3IgbW9yZSBjb25jcmV0ZSBndWlkZWxpbmVzLCBqdXN0IGltaXRhdGUgdGhlIGV4aXN0aW5nIGNvZGUKKHRoaXMgaXMgYSBnb29kIGd1aWRlbGluZSwgbm8gbWF0dGVyIHdoaWNoIHByb2plY3QgeW91IGFyZQpjb250cmlidXRpbmcgdG8pLiBJdCBpcyBhbHdheXMgcHJlZmVyYWJsZSB0byBtYXRjaCB0aGUgX2xvY2FsXwpjb252ZW50aW9uLiBOZXcgY29kZSBhZGRlZCB0byBHaXQgc3VpdGUgaXMgZXhwZWN0ZWQgdG8gbWF0Y2gKdGhlIG92ZXJhbGwgc3R5bGUgb2YgZXhpc3RpbmcgY29kZS4gTW9kaWZpY2F0aW9ucyB0byBleGlzdGluZwpjb2RlIGlzIGV4cGVjdGVkIHRvIG1hdGNoIHRoZSBzdHlsZSB0aGUgc3Vycm91bmRpbmcgY29kZSBhbHJlYWR5CnVzZXMgKGV2ZW4gaWYgaXQgZG9lc24ndCBtYXRjaCB0aGUgb3ZlcmFsbCBzdHlsZSBvZiBleGlzdGluZyBjb2RlKS4KCkJ1dCBpZiB5b3UgbXVzdCBoYXZlIGEgbGlzdCBvZiBydWxlcywgaGVyZSBhcmUgc29tZSBsYW5ndWFnZQpzcGVjaWZpYyBvbmVzLiBOb3RlIHRoYXQgRG9jdW1lbnRhdGlvbi9Ub29sc0ZvckdpdC50eHQgZG9jdW1lbnQKaGFzIGEgY29sbGVjdGlvbiBvZiB0aXBzIHRvIGhlbHAgeW91IHVzZSBzb21lIGV4dGVybmFsIHRvb2xzCnRvIGNvbmZvcm0gdG8gdGhlc2UgZ3VpZGVsaW5lcy4KCkZvciBzaGVsbCBzY3JpcHRzIHNwZWNpZmljYWxseSAobm90IGV4aGF1c3RpdmUpOgoKIC0gV2UgdXNlIHRhYnMgZm9yIGluZGVudGF0aW9uLgoKIC0gQ2FzZSBhcm1zIGFyZSBpbmRlbnRlZCBhdCB0aGUgc2FtZSBkZXB0aCBhcyBjYXNlIGFuZCBlc2FjIGxpbmVzLAogICBsaWtlIHRoaXM6CgoJY2FzZSAiJHZhcmlhYmxlIiBpbgoJcGF0dGVybjEpCgkJZG8gdGhpcwoJCTs7CglwYXR0ZXJuMikKCQlkbyB0aGF0CgkJOzsKCWVzYWMKCiAtIFJlZGlyZWN0aW9uIG9wZXJhdG9ycyBzaG91bGQgYmUgd3JpdHRlbiB3aXRoIHNwYWNlIGJlZm9yZSwgYnV0IG5vCiAgIHNwYWNlIGFmdGVyIHRoZW0uICBJbiBvdGhlciB3b3Jkcywgd3JpdGUgJ2VjaG8gdGVzdCA+IiRmaWxlIicKICAgaW5zdGVhZCBvZiAnZWNobyB0ZXN0PiAkZmlsZScgb3IgJ2VjaG8gdGVzdCA+ICRmaWxlJy4gIE5vdGUgdGhhdAogICBldmVuIHRob3VnaCBpdCBpcyBub3QgcmVxdWlyZWQgYnkgUE9TSVggdG8gZG91YmxlLXF1b3RlIHRoZQogICByZWRpcmVjdGlvbiB0YXJnZXQgaW4gYSB2YXJpYWJsZSAoYXMgc2hvd24gYWJvdmUpLCBvdXIgY29kZSBkb2VzIHNvCiAgIGJlY2F1c2Ugc29tZSB2ZXJzaW9ucyBvZiBiYXNoIGlzc3VlIGEgd2FybmluZyB3aXRob3V0IHRoZSBxdW90ZXMuCgoJKGluY29ycmVjdCkKCWNhdCBoZWxsbyA+IHdvcmxkIDwgdW5pdmVyc2UKCWVjaG8gaGVsbG8gPiR3b3JsZAoKCShjb3JyZWN0KQoJY2F0IGhlbGxvID53b3JsZCA8dW5pdmVyc2UKCWVjaG8gaGVsbG8gPiIkd29ybGQiCgogLSBXZSBwcmVmZXIgJCggLi4uICkgZm9yIGNvbW1hbmQgc3Vic3RpdHV0aW9uOyB1bmxpa2UgYGAsIGl0CiAgIHByb3Blcmx5IG5lc3RzLiAgSXQgc2hvdWxkIGhhdmUgYmVlbiB0aGUgd2F5IEJvdXJuZSBzcGVsbGVkCiAgIGl0IGZyb20gZGF5IG9uZSwgYnV0IHVuZm9ydHVuYXRlbHkgaXNuJ3QuCgogLSBJZiB5b3Ugd2FudCB0byBmaW5kIG91dCBpZiBhIGNvbW1hbmQgaXMgYXZhaWxhYmxlIG9uIHRoZSB1c2VyJ3MKICAgJFBBVEgsIHlvdSBzaG91bGQgdXNlICd0eXBlIDxjb21tYW5kPicsIGluc3RlYWQgb2YgJ3doaWNoIDxjb21tYW5kPicuCiAgIFRoZSBvdXRwdXQgb2YgJ3doaWNoJyBpcyBub3QgbWFjaGluZSBwYXJzYWJsZSBhbmQgaXRzIGV4aXQgY29kZQogICBpcyBub3QgcmVsaWFibGUgYWNyb3NzIHBsYXRmb3Jtcy4KCiAtIFdlIHVzZSBQT1NJWCBjb21wbGlhbnQgcGFyYW1ldGVyIHN1YnN0aXR1dGlvbnMgYW5kIGF2b2lkIGJhc2hpc21zOwogICBuYW1lbHk6CgogICAtIFdlIHVzZSAke3BhcmFtZXRlci13b3JkfSBhbmQgaXRzIFstPT8rXSBzaWJsaW5ncywgYW5kIHRoZWlyCiAgICAgY29sb24nZWQgInVuc2V0IG9yIG51bGwiIGZvcm0uCgogICAtIFdlIHVzZSAke3BhcmFtZXRlciN3b3JkfSBhbmQgaXRzIFsjJV0gc2libGluZ3MsIGFuZCB0aGVpcgogICAgIGRvdWJsZWQgImxvbmdlc3QgbWF0Y2hpbmciIGZvcm0uCgogICAtIE5vICJTdWJzdHJpbmcgRXhwYW5zaW9uIiAke3BhcmFtZXRlcjpvZmZzZXQ6bGVuZ3RofS4KCiAgIC0gTm8gc2hlbGwgYXJyYXlzLgoKICAgLSBObyBwYXR0ZXJuIHJlcGxhY2VtZW50ICR7cGFyYW1ldGVyL3BhdHRlcm4vc3RyaW5nfS4KCiAtIFdlIHVzZSBBcml0aG1ldGljIEV4cGFuc2lvbiAkKCggLi4uICkpLgoKIC0gV2UgZG8gbm90IHVzZSBQcm9jZXNzIFN1YnN0aXR1dGlvbiA8KGxpc3QpIG9yID4obGlzdCkuCgogLSBEbyBub3Qgd3JpdGUgY29udHJvbCBzdHJ1Y3R1cmVzIG9uIGEgc2luZ2xlIGxpbmUgd2l0aCBzZW1pY29sb24uCiAgICJ0aGVuIiBzaG91bGQgYmUgb24gdGhlIG5leHQgbGluZSBmb3IgaWYgc3RhdGVtZW50cywgYW5kICJkbyIKICAgc2hvdWxkIGJlIG9uIHRoZSBuZXh0IGxpbmUgZm9yICJ3aGlsZSIgYW5kICJmb3IiLgoKCShpbmNvcnJlY3QpCglpZiB0ZXN0IC1mIGhlbGxvOyB0aGVuCgkJZG8gdGhpcwoJZmkKCgkoY29ycmVjdCkKCWlmIHRlc3QgLWYgaGVsbG8KCXRoZW4KCQlkbyB0aGlzCglmaQoKIC0gSWYgYSBjb21tYW5kIHNlcXVlbmNlIGpvaW5lZCB3aXRoICYmIG9yIHx8IG9yIHwgc3BhbnMgbXVsdGlwbGUKICAgbGluZXMsIHB1dCBlYWNoIGNvbW1hbmQgb24gYSBzZXBhcmF0ZSBsaW5lIGFuZCBwdXQgJiYgYW5kIHx8IGFuZCB8CiAgIG9wZXJhdG9ycyBhdCB0aGUgZW5kIG9mIGVhY2ggbGluZSwgcmF0aGVyIHRoYW4gdGhlIHN0YXJ0LiBUaGlzCiAgIG1lYW5zIHlvdSBkb24ndCBuZWVkIHRvIHVzZSBcIHRvIGpvaW4gbGluZXMsIHNpbmNlIHRoZSBhYm92ZQogICBvcGVyYXRvcnMgaW1wbHkgdGhlIHNlcXVlbmNlIGlzbid0IGZpbmlzaGVkLgoKCShpbmNvcnJlY3QpCglncmVwIGJsb2IgdmVyaWZ5X3BhY2tfcmVzdWx0IFwKCXwgYXdrIC1mIHByaW50XzEuYXdrIFwKCXwgc29ydCA+YWN0dWFsICYmCgkuLi4KCgkoY29ycmVjdCkKCWdyZXAgYmxvYiB2ZXJpZnlfcGFja19yZXN1bHQgfAoJYXdrIC1mIHByaW50XzEuYXdrIHwKCXNvcnQgPmFjdHVhbCAmJgoJLi4uCgogLSBXZSBwcmVmZXIgInRlc3QiIG92ZXIgIlsgLi4uIF0iLgoKIC0gV2UgZG8gbm90IHdyaXRlIHRoZSBub2lzZXdvcmQgImZ1bmN0aW9uIiBpbiBmcm9udCBvZiBzaGVsbAogICBmdW5jdGlvbnMuCgogLSBXZSBwcmVmZXIgYSBzcGFjZSBiZXR3ZWVuIHRoZSBmdW5jdGlvbiBuYW1lIGFuZCB0aGUgcGFyZW50aGVzZXMsCiAgIGFuZCBubyBzcGFjZSBpbnNpZGUgdGhlIHBhcmVudGhlc2VzLiBUaGUgb3BlbmluZyAieyIgc2hvdWxkIGFsc28KICAgYmUgb24gdGhlIHNhbWUgbGluZS4KCgkoaW5jb3JyZWN0KQoJbXlfZnVuY3Rpb24oKXsKCQkuLi4KCgkoY29ycmVjdCkKCW15X2Z1bmN0aW9uICgpIHsKCQkuLi4KCiAtIEFzIHRvIHVzZSBvZiBncmVwLCBzdGljayB0byBhIHN1YnNldCBvZiBCUkUgKG5hbWVseSwgbm8gXHttLG5cfSwKICAgWzo6XSwgWz09XSwgb3IgWy4uXSkgZm9yIHBvcnRhYmlsaXR5LgoKICAgLSBXZSBkbyBub3QgdXNlIFx7bSxuXH07CgogICAtIFdlIGRvIG5vdCB1c2UgPyBvciArICh3aGljaCBhcmUgXHswLDFcfSBhbmQgXHsxLFx9CiAgICAgcmVzcGVjdGl2ZWx5IGluIEJSRSkgYnV0IHRoYXQgZ29lcyB3aXRob3V0IHNheWluZyBhcyB0aGVzZQogICAgIGFyZSBFUkUgZWxlbWVudHMgbm90IEJSRSAobm90ZSB0aGF0IFw/IGFuZCBcKyBhcmUgbm90IGV2ZW4gcGFydAogICAgIG9mIEJSRSAtLSBtYWtpbmcgdGhlbSBhY2Nlc3NpYmxlIGZyb20gQlJFIGlzIGEgR05VIGV4dGVuc2lvbikuCgogLSBVc2UgR2l0J3MgZ2V0dGV4dCB3cmFwcGVycyBpbiBnaXQtc2gtaTE4biB0byBtYWtlIHRoZSB1c2VyCiAgIGludGVyZmFjZSB0cmFuc2xhdGFibGUuIFNlZSAiTWFya2luZyBzdHJpbmdzIGZvciB0cmFuc2xhdGlvbiIgaW4KICAgcG8vUkVBRE1FLgoKIC0gV2UgZG8gbm90IHdyaXRlIG91ciAidGVzdCIgY29tbWFuZCB3aXRoICItYSIgYW5kICItbyIgYW5kIHVzZSAiJiYiCiAgIG9yICJ8fCIgdG8gY29uY2F0ZW5hdGUgbXVsdGlwbGUgInRlc3QiIGNvbW1hbmRzIGluc3RlYWQsIGJlY2F1c2UKICAgdGhlIHVzZSBvZiAiLWEvLW8iIGlzIG9mdGVuIGVycm9yLXByb25lLiAgRS5nLgoKICAgICB0ZXN0IC1uICIkeCIgLWEgIiRhIiA9ICIkYiIKCiAgIGlzIGJ1Z2d5IGFuZCBicmVha3Mgd2hlbiAkeCBpcyAiPSIsIGJ1dAoKICAgICB0ZXN0IC1uICIkeCIgJiYgdGVzdCAiJGEiID0gIiRiIgoKICAgZG9lcyBub3QgaGF2ZSBzdWNoIGEgcHJvYmxlbS4KCiAtIEV2ZW4gdGhvdWdoICJsb2NhbCIgaXMgbm90IHBhcnQgb2YgUE9TSVgsIHdlIG1ha2UgaGVhdnkgdXNlIG9mIGl0CiAgIGluIG91ciB0ZXN0IHN1aXRlLiAgV2UgZG8gbm90IHVzZSBpdCBpbiBzY3JpcHRlZCBQb3JjZWxhaW5zLCBhbmQKICAgaG9wZWZ1bGx5IG5vYm9keSBzdGFydHMgdXNpbmcgImxvY2FsIiBiZWZvcmUgdGhleSBhcmUgcmVpbXBsZW1lbnRlZAogICBpbiBDIDstKQoKCkZvciBDIHByb2dyYW1zOgoKIC0gV2UgdXNlIHRhYnMgdG8gaW5kZW50LCBhbmQgaW50ZXJwcmV0IHRhYnMgYXMgdGFraW5nIHVwIHRvCiAgIDggc3BhY2VzLgoKIC0gV2UgdHJ5IHRvIGtlZXAgdG8gYXQgbW9zdCA4MCBjaGFyYWN0ZXJzIHBlciBsaW5lLgoKIC0gQXMgYSBHaXQgZGV2ZWxvcGVyIHdlIGFzc3VtZSB5b3UgaGF2ZSBhIHJlYXNvbmFibHkgbW9kZXJuIGNvbXBpbGVyCiAgIGFuZCB3ZSByZWNvbW1lbmQgeW91IHRvIGVuYWJsZSB0aGUgREVWRUxPUEVSIG1ha2VmaWxlIGtub2IgdG8KICAgZW5zdXJlIHlvdXIgcGF0Y2ggaXMgY2xlYXIgb2YgYWxsIGNvbXBpbGVyIHdhcm5pbmdzIHdlIGNhcmUgYWJvdXQsCiAgIGJ5IGUuZy4gImVjaG8gREVWRUxPUEVSPTEgPj5jb25maWcubWFrIi4KCiAtIFdlIHRyeSB0byBzdXBwb3J0IGEgd2lkZSByYW5nZSBvZiBDIGNvbXBpbGVycyB0byBjb21waWxlIEdpdCB3aXRoLAogICBpbmNsdWRpbmcgb2xkIG9uZXMuICBBcyBvZiBHaXQgdjIuMzUuMCBHaXQgcmVxdWlyZXMgQzk5ICh3ZSBjaGVjawogICAiX19TVERDX1ZFUlNJT05fXyIpLiBZb3Ugc2hvdWxkIG5vdCB1c2UgZmVhdHVyZXMgZnJvbSBhIG5ld2VyIEMKICAgc3RhbmRhcmQsIGV2ZW4gaWYgeW91ciBjb21waWxlciBncm9rcyB0aGVtLgoKICAgTmV3IEM5OSBmZWF0dXJlcyBoYXZlIGJlZW4gcGhhc2VkIGluIGdyYWR1YWxseSwgaWYgc29tZXRoaW5nJ3MgbmV3CiAgIGluIEM5OSBidXQgbm90IHVzZWQgeWV0IGRvbid0IGFzc3VtZSB0aGF0IGl0J3Mgc2FmZSB0byB1c2UsIHNvbWUKICAgY29tcGlsZXJzIHdlIHRhcmdldCBoYXZlIG9ubHkgcGFydGlhbCBzdXBwb3J0IGZvciBpdC4gVGhlc2UgYXJlCiAgIGNvbnNpZGVyZWQgc2FmZSB0byB1c2U6CgogICAuIHNpbmNlIGFyb3VuZCAyMDA3IHdpdGggMmI2ODU0Yzg2M2EsIHdlIGhhdmUgYmVlbiB1c2luZwogICAgIGluaXRpYWxpemVyIGVsZW1lbnRzIHdoaWNoIGFyZSBub3QgY29tcHV0YWJsZSBhdCBsb2FkIHRpbWUuIEUuZy46CgoJY29uc3QgY2hhciAqYXJnc1tdID0geyJjb25zdGFudCIsIHZhcmlhYmxlLCBOVUxMfTsKCiAgIC4gc2luY2UgZWFybHkgMjAxMiB3aXRoIGUxMzI3MDIzZWEsIHdlIGhhdmUgYmVlbiB1c2luZyBhbiBlbnVtCiAgICAgZGVmaW5pdGlvbiB3aG9zZSBsYXN0IGVsZW1lbnQgaXMgZm9sbG93ZWQgYnkgYSBjb21tYS4gIFRoaXMsIGxpa2UKICAgICBhbiBhcnJheSBpbml0aWFsaXplciB0aGF0IGVuZHMgd2l0aCBhIHRyYWlsaW5nIGNvbW1hLCBjYW4gYmUgdXNlZAogICAgIHRvIHJlZHVjZSB0aGUgcGF0Y2ggbm9pc2Ugd2hlbiBhZGRpbmcgYSBuZXcgaWRlbnRpZmllciBhdCB0aGUgZW5kLgoKICAgLiBzaW5jZSBtaWQgMjAxNyB3aXRoIGNiYzBmODFkLCB3ZSBoYXZlIGJlZW4gdXNpbmcgZGVzaWduYXRlZAogICAgIGluaXRpYWxpemVycyBmb3Igc3RydWN0IChlLmcuICJzdHJ1Y3QgdCB2ID0geyAudmFsID0gJ2EnIH07IikuCgogICAuIHNpbmNlIG1pZCAyMDE3IHdpdGggNTEyZjQxY2YsIHdlIGhhdmUgYmVlbiB1c2luZyBkZXNpZ25hdGVkCiAgICAgaW5pdGlhbGl6ZXJzIGZvciBhcnJheSAoZS5nLiAiaW50IGFycmF5WzEwXSA9IHsgWzVdID0gMiB9IikuCgogICAuIHNpbmNlIGVhcmx5IDIwMjEgd2l0aCA3NjVkYzE2ODg4Miwgd2UgaGF2ZSBiZWVuIHVzaW5nIHZhcmlhZGljCiAgICAgbWFjcm9zLCBtb3N0bHkgZm9yIHByaW50Zi1saWtlIHRyYWNlIGFuZCBkZWJ1ZyBtYWNyb3MuCgogICAuIHNpbmNlIGxhdGUgMjAyMSB3aXRoIDQ0YmExMGQ2LCB3ZSBoYXZlIGhhZCB2YXJpYWJsZXMgZGVjbGFyZWQgaW4KICAgICB0aGUgZm9yIGxvb3AgImZvciAoaW50IGkgPSAwOyBpIDwgMTA7IGkrKykiLgoKICAgTmV3IEM5OSBmZWF0dXJlcyB0aGF0IHdlIGNhbm5vdCB1c2UgeWV0OgoKICAgLiAleiBhbmQgJXp1IGFzIGEgcHJpbnRmKCkgYXJndW1lbnQgZm9yIGEgc2l6ZV90ICh0aGUgJXogYmVpbmcgZm9yCiAgICAgdGhlIFBPU0lYLXNwZWNpZmljIHNzaXplX3QpLiBJbnN0ZWFkIHlvdSBzaG91bGQgdXNlCiAgICAgcHJpbnRmKCIlIlBSSXVNQVgsICh1aW50bWF4X3QpdikuICBUaGVzZSBkYXlzIHRoZSBNU1ZDIHZlcnNpb24gd2UKICAgICByZWx5IG9uIHN1cHBvcnRzICV6LCBidXQgdGhlIEMgbGlicmFyeSB1c2VkIGJ5IE1pbkdXIGRvZXMgbm90LgoKICAgLiBTaG9ydGhhbmQgbGlrZSAiLmEuYiA9ICpjIiBpbiBzdHJ1Y3QgaW5pdGlhbGl6YXRpb25zIGlzIGtub3duIHRvCiAgICAgdHJpcCB1cCBhbiBvbGRlciBJQk0gWExDIHZlcnNpb24sIHVzZSAiLmEgPSB7IC5iID0gKmMgfSIgaW5zdGVhZC4KICAgICBTZWUgdGhlIDMzNjY1ZDk4IChyZWZ0YWJsZTogbWFrZSBhc3NpZ25tZW50cyBwb3J0YWJsZSB0byBBSVggeGxjCiAgICAgdjEyLjAxLCAyMDIyLTAzLTI4KS4KCiAtIFZhcmlhYmxlcyBoYXZlIHRvIGJlIGRlY2xhcmVkIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGJsb2NrLCBiZWZvcmUKICAgdGhlIGZpcnN0IHN0YXRlbWVudCAoaS5lLiAtV2RlY2xhcmF0aW9uLWFmdGVyLXN0YXRlbWVudCkuCgogLSBOVUxMIHBvaW50ZXJzIHNoYWxsIGJlIHdyaXR0ZW4gYXMgTlVMTCwgbm90IGFzIDAuCgogLSBXaGVuIGRlY2xhcmluZyBwb2ludGVycywgdGhlIHN0YXIgc2lkZXMgd2l0aCB0aGUgdmFyaWFibGUKICAgbmFtZSwgaS5lLiAiY2hhciAqc3RyaW5nIiwgbm90ICJjaGFyKiBzdHJpbmciIG9yCiAgICJjaGFyICogc3RyaW5nIi4gIFRoaXMgbWFrZXMgaXQgZWFzaWVyIHRvIHVuZGVyc3RhbmQgY29kZQogICBsaWtlICJjaGFyICpzdHJpbmcsIGM7Ii4KCiAtIFVzZSB3aGl0ZXNwYWNlIGFyb3VuZCBvcGVyYXRvcnMgYW5kIGtleXdvcmRzLCBidXQgbm90IGluc2lkZQogICBwYXJlbnRoZXNlcyBhbmQgbm90IGFyb3VuZCBmdW5jdGlvbnMuIFNvOgoKICAgICAgICB3aGlsZSAoY29uZGl0aW9uKQoJCWZ1bmMoYmFyICsgMSk7CgogICBhbmQgbm90OgoKICAgICAgICB3aGlsZSggY29uZGl0aW9uICkKCQlmdW5jIChiYXIrMSk7CgogLSBEbyBub3QgZXhwbGljaXRseSBjb21wYXJlIGFuIGludGVncmFsIHZhbHVlIHdpdGggY29uc3RhbnQgMCBvciAnXDAnLAogICBvciBhIHBvaW50ZXIgdmFsdWUgd2l0aCBjb25zdGFudCBOVUxMLiAgRm9yIGluc3RhbmNlLCB0byB2YWxpZGF0ZSB0aGF0CiAgIGNvdW50ZWQgYXJyYXkgPHB0ciwgY250PiBpcyBpbml0aWFsaXplZCBidXQgaGFzIG5vIGVsZW1lbnRzLCB3cml0ZToKCglpZiAoIXB0ciB8fCBjbnQpCgkJQlVHKCJlbXB0eSBhcnJheSBleHBlY3RlZCIpOwoKICAgYW5kIG5vdDoKCglpZiAocHRyID09IE5VTEwgfHwgY250ICE9IDApOwoJCUJVRygiZW1wdHkgYXJyYXkgZXhwZWN0ZWQiKTsKCiAtIFdlIGF2b2lkIHVzaW5nIGJyYWNlcyB1bm5lY2Vzc2FyaWx5LiAgSS5lLgoKCWlmIChibGEpIHsKCQl4ID0gMTsKCX0KCiAgIGlzIGZyb3duZWQgdXBvbi4gQnV0IHRoZXJlIGFyZSBhIGZldyBleGNlcHRpb25zOgoKCS0gV2hlbiB0aGUgc3RhdGVtZW50IGV4dGVuZHMgb3ZlciBhIGZldyBsaW5lcyAoZS5nLiwgYSB3aGlsZSBsb29wCgkgIHdpdGggYW4gZW1iZWRkZWQgY29uZGl0aW9uYWwsIG9yIGEgY29tbWVudCkuIEUuZy46CgoJCXdoaWxlIChmb28pIHsKCQkJaWYgKHgpCgkJCQlvbmUoKTsKCQkJZWxzZQoJCQkJdHdvKCk7CgkJfQoKCQlpZiAoZm9vKSB7CgkJCS8qCgkJCSAqIFRoaXMgb25lIHJlcXVpcmVzIHNvbWUgZXhwbGFuYXRpb24sCgkJCSAqIHNvIHdlJ3JlIGJldHRlciBvZmYgd2l0aCBicmFjZXMgdG8gbWFrZQoJCQkgKiBpdCBvYnZpb3VzIHRoYXQgdGhlIGluZGVudGF0aW9uIGlzIGNvcnJlY3QuCgkJCSAqLwoJCQlkb2l0KCk7CgkJfQoKCS0gV2hlbiB0aGVyZSBhcmUgbXVsdGlwbGUgYXJtcyB0byBhIGNvbmRpdGlvbmFsIGFuZCBzb21lIG9mIHRoZW0KCSAgcmVxdWlyZSBicmFjZXMsIGVuY2xvc2UgZXZlbiBhIHNpbmdsZSBsaW5lIGJsb2NrIGluIGJyYWNlcyBmb3IKCSAgY29uc2lzdGVuY3kuIEUuZy46CgoJCWlmIChmb28pIHsKCQkJZG9pdCgpOwoJCX0gZWxzZSB7CgkJCW9uZSgpOwoJCQl0d28oKTsKCQkJdGhyZWUoKTsKCQl9CgogLSBXZSB0cnkgdG8gYXZvaWQgYXNzaWdubWVudHMgaW4gdGhlIGNvbmRpdGlvbiBvZiBhbiAiaWYiIHN0YXRlbWVudC4KCiAtIFRyeSB0byBtYWtlIHlvdXIgY29kZSB1bmRlcnN0YW5kYWJsZS4gIFlvdSBtYXkgcHV0IGNvbW1lbnRzCiAgIGluLCBidXQgY29tbWVudHMgaW52YXJpYWJseSB0ZW5kIHRvIHN0YWxlIG91dCB3aGVuIHRoZSBjb2RlCiAgIHRoZXkgd2VyZSBkZXNjcmliaW5nIGNoYW5nZXMuICBPZnRlbiBzcGxpdHRpbmcgYSBmdW5jdGlvbgogICBpbnRvIHR3byBtYWtlcyB0aGUgaW50ZW50aW9uIG9mIHRoZSBjb2RlIG11Y2ggY2xlYXJlci4KCiAtIE11bHRpLWxpbmUgY29tbWVudHMgaW5jbHVkZSB0aGVpciBkZWxpbWl0ZXJzIG9uIHNlcGFyYXRlIGxpbmVzIGZyb20KICAgdGhlIHRleHQuICBFLmcuCgoJLyoKCSAqIEEgdmVyeSBsb25nCgkgKiBtdWx0aS1saW5lIGNvbW1lbnQuCgkgKi8KCiAgIE5vdGUgaG93ZXZlciB0aGF0IGEgY29tbWVudCB0aGF0IGV4cGxhaW5zIGEgdHJhbnNsYXRhYmxlIHN0cmluZyB0bwogICB0cmFuc2xhdG9ycyB1c2VzIGEgY29udmVudGlvbiBvZiBzdGFydGluZyB3aXRoIGEgbWFnaWMgdG9rZW4KICAgIlRSQU5TTEFUT1JTOiAiLCBlLmcuCgoJLyoKCSAqIFRSQU5TTEFUT1JTOiBoZXJlIGlzIGEgY29tbWVudCB0aGF0IGV4cGxhaW5zIHRoZSBzdHJpbmcgdG8KCSAqIGJlIHRyYW5zbGF0ZWQsIHRoYXQgZm9sbG93cyBpbW1lZGlhdGVseSBhZnRlciBpdC4KCSAqLwoJXygiSGVyZSBpcyBhIHRyYW5zbGF0YWJsZSBzdHJpbmcgZXhwbGFpbmVkIGJ5IHRoZSBhYm92ZS4iKTsKCiAtIERvdWJsZSBuZWdhdGlvbiBpcyBvZnRlbiBoYXJkZXIgdG8gdW5kZXJzdGFuZCB0aGFuIG5vIG5lZ2F0aW9uCiAgIGF0IGFsbC4KCiAtIFRoZXJlIGFyZSB0d28gc2Nob29scyBvZiB0aG91Z2h0IHdoZW4gaXQgY29tZXMgdG8gY29tcGFyaXNvbiwKICAgZXNwZWNpYWxseSBpbnNpZGUgYSBsb29wLiBTb21lIHBlb3BsZSBwcmVmZXIgdG8gaGF2ZSB0aGUgbGVzcyBzdGFibGUKICAgdmFsdWUgb24gdGhlIGxlZnQgaGFuZCBzaWRlIGFuZCB0aGUgbW9yZSBzdGFibGUgdmFsdWUgb24gdGhlIHJpZ2h0IGhhbmQKICAgc2lkZSwgZS5nLiBpZiB5b3UgaGF2ZSBhIGxvb3AgdGhhdCBjb3VudHMgdmFyaWFibGUgaSBkb3duIHRvIHRoZQogICBsb3dlciBib3VuZCwKCgl3aGlsZSAoaSA+IGxvd2VyX2JvdW5kKSB7CgkJZG8gc29tZXRoaW5nOwoJCWktLTsKCX0KCiAgIE90aGVyIHBlb3BsZSBwcmVmZXIgdG8gaGF2ZSB0aGUgdGV4dHVhbCBvcmRlciBvZiB2YWx1ZXMgbWF0Y2ggdGhlCiAgIGFjdHVhbCBvcmRlciBvZiB2YWx1ZXMgaW4gdGhlaXIgY29tcGFyaXNvbiwgc28gdGhhdCB0aGV5IGNhbgogICBtZW50YWxseSBkcmF3IGEgbnVtYmVyIGxpbmUgZnJvbSBsZWZ0IHRvIHJpZ2h0IGFuZCBwbGFjZSB0aGVzZQogICB2YWx1ZXMgaW4gb3JkZXIsIGkuZS4KCgl3aGlsZSAobG93ZXJfYm91bmQgPCBpKSB7CgkJZG8gc29tZXRoaW5nOwoJCWktLTsKCX0KCiAgIEJvdGggYXJlIHZhbGlkLCBhbmQgd2UgdXNlIGJvdGguICBIb3dldmVyLCB0aGUgbW9yZSAic3RhYmxlIiB0aGUKICAgc3RhYmxlIHNpZGUgYmVjb21lcywgdGhlIG1vcmUgd2UgdGVuZCB0byBwcmVmZXIgdGhlIGZvcm1lcgogICAoY29tcGFyaXNvbiB3aXRoIGEgY29uc3RhbnQsICJpID4gMCIsIGlzIGFuIGV4dHJlbWUgZXhhbXBsZSkuCiAgIEp1c3QgZG8gbm90IG1peCBzdHlsZXMgaW4gdGhlIHNhbWUgcGFydCBvZiB0aGUgY29kZSBhbmQgbWltaWMKICAgZXhpc3Rpbmcgc3R5bGVzIGluIHRoZSBuZWlnaGJvdXJob29kLgoKIC0gVGhlcmUgYXJlIHR3byBzY2hvb2xzIG9mIHRob3VnaHQgd2hlbiBpdCBjb21lcyB0byBzcGxpdHRpbmcgYSBsb25nCiAgIGxvZ2ljYWwgbGluZSBpbnRvIG11bHRpcGxlIGxpbmVzLiAgU29tZSBwZW9wbGUgcHVzaCB0aGUgc2Vjb25kIGFuZAogICBzdWJzZXF1ZW50IGxpbmVzIGZhciBlbm91Z2ggdG8gdGhlIHJpZ2h0IHdpdGggdGFicyBhbmQgYWxpZ24gdGhlbToKCiAgICAgICAgaWYgKHRoZV9iZWdpbm5pbmdfb2ZfYV92ZXJ5X2xvbmdfZXhwcmVzc2lvbl90aGF0X2hhc190byB8fAoJCXNwYW5fbW9yZV90aGFuX2Ffc2luZ2xlX2xpbmVfb2YgfHwKCQl0aGVfc291cmNlX3RleHQpIHsKICAgICAgICAgICAgICAgIC4uLgoKICAgd2hpbGUgb3RoZXIgcGVvcGxlIHByZWZlciB0byBhbGlnbiB0aGUgc2Vjb25kIGFuZCB0aGUgc3Vic2VxdWVudAogICBsaW5lcyB3aXRoIHRoZSBjb2x1bW4gaW1tZWRpYXRlbHkgaW5zaWRlIHRoZSBvcGVuaW5nIHBhcmVudGhlc2lzLAogICB3aXRoIHRhYnMgYW5kIHNwYWNlcywgZm9sbG93aW5nIG91ciAidGFic3RvcCBpcyBhbHdheXMgYSBtdWx0aXBsZQogICBvZiA4IiBjb252ZW50aW9uOgoKICAgICAgICBpZiAodGhlX2JlZ2lubmluZ19vZl9hX3ZlcnlfbG9uZ19leHByZXNzaW9uX3RoYXRfaGFzX3RvIHx8CgkgICAgc3Bhbl9tb3JlX3RoYW5fYV9zaW5nbGVfbGluZV9vZiB8fAoJICAgIHRoZV9zb3VyY2VfdGV4dCkgewogICAgICAgICAgICAgICAgLi4uCgogICBCb3RoIGFyZSB2YWxpZCwgYW5kIHdlIHVzZSBib3RoLiAgQWdhaW4sIGp1c3QgZG8gbm90IG1peCBzdHlsZXMgaW4KICAgdGhlIHNhbWUgcGFydCBvZiB0aGUgY29kZSBhbmQgbWltaWMgZXhpc3Rpbmcgc3R5bGVzIGluIHRoZQogICBuZWlnaGJvdXJob29kLgoKIC0gV2hlbiBzcGxpdHRpbmcgYSBsb25nIGxvZ2ljYWwgbGluZSwgc29tZSBwZW9wbGUgY2hhbmdlIGxpbmUgYmVmb3JlCiAgIGEgYmluYXJ5IG9wZXJhdG9yLCBzbyB0aGF0IHRoZSByZXN1bHQgbG9va3MgbGlrZSBhIHBhcnNlIHRyZWUgd2hlbgogICB5b3UgdHVybiB5b3VyIGhlYWQgOTAtZGVncmVlcyBjb3VudGVyY2xvY2t3aXNlOgoKICAgICAgICBpZiAodGhlX2JlZ2lubmluZ19vZl9hX3ZlcnlfbG9uZ19leHByZXNzaW9uX3RoYXRfaGFzX3RvCgkgICAgfHwgc3Bhbl9tb3JlX3RoYW5fYV9zaW5nbGVfbGluZV9vZl90aGVfc291cmNlX3RleHQpIHsKCiAgIHdoaWxlIG90aGVyIHBlb3BsZSBwcmVmZXIgdG8gbGVhdmUgdGhlIG9wZXJhdG9yIGF0IHRoZSBlbmQgb2YgdGhlCiAgIGxpbmU6CgogICAgICAgIGlmICh0aGVfYmVnaW5uaW5nX29mX2FfdmVyeV9sb25nX2V4cHJlc3Npb25fdGhhdF9oYXNfdG8gfHwKCSAgICBzcGFuX21vcmVfdGhhbl9hX3NpbmdsZV9saW5lX29mX3RoZV9zb3VyY2VfdGV4dCkgewoKICAgQm90aCBhcmUgdmFsaWQsIGJ1dCB3ZSB0ZW5kIHRvIHVzZSB0aGUgbGF0dGVyIG1vcmUsIHVubGVzcyB0aGUKICAgZXhwcmVzc2lvbiBnZXRzIGZhaXJseSBjb21wbGV4LCBpbiB3aGljaCBjYXNlIHRoZSBmb3JtZXIgdGVuZHMgdG8KICAgYmUgZWFzaWVyIHRvIHJlYWQuICBBZ2FpbiwganVzdCBkbyBub3QgbWl4IHN0eWxlcyBpbiB0aGUgc2FtZSBwYXJ0CiAgIG9mIHRoZSBjb2RlIGFuZCBtaW1pYyBleGlzdGluZyBzdHlsZXMgaW4gdGhlIG5laWdoYm91cmhvb2QuCgogLSBXaGVuIHNwbGl0dGluZyBhIGxvbmcgbG9naWNhbCBsaW5lLCB3aXRoIGV2ZXJ5dGhpbmcgZWxzZSBiZWluZwogICBlcXVhbCwgaXQgaXMgcHJlZmVyYWJsZSB0byBzcGxpdCBhZnRlciB0aGUgb3BlcmF0b3IgYXQgaGlnaGVyCiAgIGxldmVsIGluIHRoZSBwYXJzZSB0cmVlLiAgVGhhdCBpcywgdGhpcyBpcyBtb3JlIHByZWZlcmFibGU6CgoJaWYgKGFfdmVyeV9sb25nX3ZhcmlhYmxlICogdGhhdF9pc191c2VkX2luICsKCSAgICBhX3ZlcnlfbG9uZ19leHByZXNzaW9uKSB7CgkJLi4uCgogICB0aGFuCgoJaWYgKGFfdmVyeV9sb25nX3ZhcmlhYmxlICoKCSAgICB0aGF0X2lzX3VzZWRfaW4gKyBhX3ZlcnlfbG9uZ19leHByZXNzaW9uKSB7CgkJLi4uCgogLSBTb21lIGNsZXZlciB0cmlja3MsIGxpa2UgdXNpbmcgdGhlICEhIG9wZXJhdG9yIHdpdGggYXJpdGhtZXRpYwogICBjb25zdHJ1Y3RzLCBjYW4gYmUgZXh0cmVtZWx5IGNvbmZ1c2luZyB0byBvdGhlcnMuICBBdm9pZCB0aGVtLAogICB1bmxlc3MgdGhlcmUgaXMgYSBjb21wZWxsaW5nIHJlYXNvbiB0byB1c2UgdGhlbS4KCiAtIFVzZSB0aGUgQVBJLiAgTm8sIHJlYWxseS4gIFdlIGhhdmUgYSBzdHJidWYgKHZhcmlhYmxlIGxlbmd0aAogICBzdHJpbmcpLCBzZXZlcmFsIGFycmF5cyB3aXRoIHRoZSBBTExPQ19HUk9XKCkgbWFjcm8sIGEKICAgc3RyaW5nX2xpc3QgZm9yIHNvcnRlZCBzdHJpbmcgbGlzdHMsIGEgaGFzaCBtYXAgKG1hcHBpbmcgc3RydWN0CiAgIG9iamVjdHMpIG5hbWVkICJzdHJ1Y3QgZGVjb3JhdGUiLCBhbW9uZ3N0IG90aGVyIHRoaW5ncy4KCiAtIFdoZW4geW91IGNvbWUgdXAgd2l0aCBhbiBBUEksIGRvY3VtZW50IGl0cyBmdW5jdGlvbnMgYW5kIHN0cnVjdHVyZXMKICAgaW4gdGhlIGhlYWRlciBmaWxlIHRoYXQgZXhwb3NlcyB0aGUgQVBJIHRvIGl0cyBjYWxsZXJzLiBVc2Ugd2hhdCBpcwogICBpbiAic3RyYnVmLmgiIGFzIGEgbW9kZWwgZm9yIHRoZSBhcHByb3ByaWF0ZSB0b25lIGFuZCBsZXZlbCBvZgogICBkZXRhaWwuCgogLSBUaGUgZmlyc3QgI2luY2x1ZGUgaW4gQyBmaWxlcywgZXhjZXB0IGluIHBsYXRmb3JtIHNwZWNpZmljIGNvbXBhdC8KICAgaW1wbGVtZW50YXRpb25zIGFuZCBzaGExZGMvLCBtdXN0IGJlIGVpdGhlciAiZ2l0LWNvbXBhdC11dGlsLmgiIG9yCiAgIG9uZSBvZiB0aGUgYXBwcm92ZWQgaGVhZGVycyB0aGF0IGluY2x1ZGVzIGl0IGZpcnN0IGZvciB5b3UuICAoVGhlCiAgIGFwcHJvdmVkIGhlYWRlcnMgY3VycmVudGx5IGluY2x1ZGUgImNhY2hlLmgiLCAiYnVpbHRpbi5oIiwKICAgInQvaGVscGVyL3Rlc3QtdG9vbC5oIiwgInhkaWZmL3hpbmNsdWRlLmgiLCBvcgogICAicmVmdGFibGUvc3lzdGVtLmgiKS4gIFlvdSBkbyBub3QgaGF2ZSB0byBpbmNsdWRlIG1vcmUgdGhhbiBvbmUgb2YKICAgdGhlc2UuCgogLSBBIEMgZmlsZSBtdXN0IGRpcmVjdGx5IGluY2x1ZGUgdGhlIGhlYWRlciBmaWxlcyB0aGF0IGRlY2xhcmUgdGhlCiAgIGZ1bmN0aW9ucyBhbmQgdGhlIHR5cGVzIGl0IHVzZXMsIGV4Y2VwdCBmb3IgdGhlIGZ1bmN0aW9ucyBhbmQgdHlwZXMKICAgdGhhdCBhcmUgbWFkZSBhdmFpbGFibGUgdG8gaXQgYnkgaW5jbHVkaW5nIG9uZSBvZiB0aGUgaGVhZGVyIGZpbGVzCiAgIGl0IG11c3QgaW5jbHVkZSBieSB0aGUgcHJldmlvdXMgcnVsZS4KCiAtIElmIHlvdSBhcmUgcGxhbm5pbmcgYSBuZXcgY29tbWFuZCwgY29uc2lkZXIgd3JpdGluZyBpdCBpbiBzaGVsbAogICBvciBwZXJsIGZpcnN0LCBzbyB0aGF0IGNoYW5nZXMgaW4gc2VtYW50aWNzIGNhbiBiZSBlYXNpbHkKICAgY2hhbmdlZCBhbmQgZGlzY3Vzc2VkLiAgTWFueSBHaXQgY29tbWFuZHMgc3RhcnRlZCBvdXQgbGlrZQogICB0aGF0LCBhbmQgYSBmZXcgYXJlIHN0aWxsIHNjcmlwdHMuCgogLSBBdm9pZCBpbnRyb2R1Y2luZyBhIG5ldyBkZXBlbmRlbmN5IGludG8gR2l0LiBUaGlzIG1lYW5zIHlvdQogICB1c3VhbGx5IHNob3VsZCBzdGF5IGF3YXkgZnJvbSBzY3JpcHRpbmcgbGFuZ3VhZ2VzIG5vdCBhbHJlYWR5CiAgIHVzZWQgaW4gdGhlIEdpdCBjb3JlIGNvbW1hbmQgc2V0ICh1bmxlc3MgeW91ciBjb21tYW5kIGlzIGNsZWFybHkKICAgc2VwYXJhdGUgZnJvbSBpdCwgc3VjaCBhcyBhbiBpbXBvcnRlciB0byBjb252ZXJ0IHJhbmRvbS1zY20tWAogICByZXBvc2l0b3JpZXMgdG8gR2l0KS4KCiAtIFdoZW4gd2UgcGFzcyA8c3RyaW5nLCBsZW5ndGg+IHBhaXIgdG8gZnVuY3Rpb25zLCB3ZSBzaG91bGQgdHJ5IHRvCiAgIHBhc3MgdGhlbSBpbiB0aGF0IG9yZGVyLgoKIC0gVXNlIEdpdCdzIGdldHRleHQgd3JhcHBlcnMgdG8gbWFrZSB0aGUgdXNlciBpbnRlcmZhY2UKICAgdHJhbnNsYXRhYmxlLiBTZWUgIk1hcmtpbmcgc3RyaW5ncyBmb3IgdHJhbnNsYXRpb24iIGluIHBvL1JFQURNRS4KCiAtIFZhcmlhYmxlcyBhbmQgZnVuY3Rpb25zIGxvY2FsIHRvIGEgZ2l2ZW4gc291cmNlIGZpbGUgc2hvdWxkIGJlIG1hcmtlZAogICB3aXRoICJzdGF0aWMiLiBWYXJpYWJsZXMgdGhhdCBhcmUgdmlzaWJsZSB0byBvdGhlciBzb3VyY2UgZmlsZXMKICAgbXVzdCBiZSBkZWNsYXJlZCB3aXRoICJleHRlcm4iIGluIGhlYWRlciBmaWxlcy4gSG93ZXZlciwgZnVuY3Rpb24KICAgZGVjbGFyYXRpb25zIHNob3VsZCBub3QgdXNlICJleHRlcm4iLCBhcyB0aGF0IGlzIGFscmVhZHkgdGhlIGRlZmF1bHQuCgogLSBZb3UgY2FuIGxhdW5jaCBnZGIgYXJvdW5kIHlvdXIgcHJvZ3JhbSB1c2luZyB0aGUgc2hvcnRoYW5kIEdJVF9ERUJVR0dFUi4KICAgUnVuIGBHSVRfREVCVUdHRVI9MSAuL2Jpbi13cmFwcGVycy9naXQgZm9vYCB0byBzaW1wbHkgdXNlIGdkYiBhcyBpcywgb3IKICAgcnVuIGBHSVRfREVCVUdHRVI9IjxkZWJ1Z2dlcj4gPGRlYnVnZ2VyLWFyZ3M+IiAuL2Jpbi13cmFwcGVycy9naXQgZm9vYCB0bwogICB1c2UgeW91ciBvd24gZGVidWdnZXIgYW5kIGFyZ3VtZW50cy4gRXhhbXBsZTogYEdJVF9ERUJVR0dFUj0iZGRkIC0tZ2RiIgogICAuL2Jpbi13cmFwcGVycy9naXQgbG9nYCAoU2VlIGB3cmFwLWZvci1iaW4uc2hgLikKCkZvciBQZXJsIHByb2dyYW1zOgoKIC0gTW9zdCBvZiB0aGUgQyBndWlkZWxpbmVzIGFib3ZlIGFwcGx5LgoKIC0gV2UgdHJ5IHRvIHN1cHBvcnQgUGVybCA1LjggYW5kIGxhdGVyICgidXNlIFBlcmwgNS4wMDgiKS4KCiAtIHVzZSBzdHJpY3QgYW5kIHVzZSB3YXJuaW5ncyBhcmUgc3Ryb25nbHkgcHJlZmVycmVkLgoKIC0gRG9uJ3Qgb3ZlcnVzZSBzdGF0ZW1lbnQgbW9kaWZpZXJzIHVubGVzcyB1c2luZyB0aGVtIG1ha2VzIHRoZQogICByZXN1bHQgZWFzaWVyIHRvIGZvbGxvdy4KCgkuLi4gZG8gc29tZXRoaW5nIC4uLgoJZG9fdGhpcygpIHVubGVzcyAoY29uZGl0aW9uKTsKICAgICAgICAuLi4gZG8gc29tZXRoaW5nIGVsc2UgLi4uCgogICBpcyBtb3JlIHJlYWRhYmxlIHRoYW46CgoJLi4uIGRvIHNvbWV0aGluZyAuLi4KCXVubGVzcyAoY29uZGl0aW9uKSB7CgkJZG9fdGhpcygpOwoJfQogICAgICAgIC4uLiBkbyBzb21ldGhpbmcgZWxzZSAuLi4KCiAgICpvbmx5KiB3aGVuIHRoZSBjb25kaXRpb24gaXMgc28gcmFyZSB0aGF0IGRvX3RoaXMoKSB3aWxsIGJlIGFsbW9zdAogICBhbHdheXMgY2FsbGVkLgoKIC0gV2UgdHJ5IHRvIGF2b2lkIGFzc2lnbm1lbnRzIGluc2lkZSAiaWYgKCkiIGNvbmRpdGlvbnMuCgogLSBMZWFybiBhbmQgdXNlIEdpdC5wbSBpZiB5b3UgbmVlZCB0aGF0IGZ1bmN0aW9uYWxpdHkuCgpGb3IgUHl0aG9uIHNjcmlwdHM6CgogLSBXZSBmb2xsb3cgUEVQLTggKGh0dHA6Ly93d3cucHl0aG9uLm9yZy9kZXYvcGVwcy9wZXAtMDAwOC8pLgoKIC0gQXMgYSBtaW5pbXVtLCB3ZSBhaW0gdG8gYmUgY29tcGF0aWJsZSB3aXRoIFB5dGhvbiAyLjcuCgogLSBXaGVyZSByZXF1aXJlZCBsaWJyYXJpZXMgZG8gbm90IHJlc3RyaWN0IHVzIHRvIFB5dGhvbiAyLCB3ZSB0cnkgdG8KICAgYWxzbyBiZSBjb21wYXRpYmxlIHdpdGggUHl0aG9uIDMuMSBhbmQgbGF0ZXIuCgoKUHJvZ3JhbSBPdXRwdXQKCiBXZSBtYWtlIGEgZGlzdGluY3Rpb24gYmV0d2VlbiBhIEdpdCBjb21tYW5kJ3MgcHJpbWFyeSBvdXRwdXQgYW5kCiBvdXRwdXQgd2hpY2ggaXMgbWVyZWx5IGNoYXR0eSBmZWVkYmFjayAoZm9yIGluc3RhbmNlLCBzdGF0dXMKIG1lc3NhZ2VzLCBydW5uaW5nIHRyYW5zY3JpcHQsIG9yIHByb2dyZXNzIGRpc3BsYXkpLCBhcyB3ZWxsIGFzIGVycm9yCiBtZXNzYWdlcy4gUm91Z2hseSBzcGVha2luZywgYSBHaXQgY29tbWFuZCdzIHByaW1hcnkgb3V0cHV0IGlzIHRoYXQKIHdoaWNoIG9uZSBtaWdodCB3YW50IHRvIGNhcHR1cmUgdG8gYSBmaWxlIG9yIHNlbmQgZG93biBhIHBpcGU7IGl0cwogY2hhdHR5IG91dHB1dCBzaG91bGQgbm90IGludGVyZmVyZSB3aXRoIHRoZXNlIHVzZS1jYXNlcy4KCiBBcyBzdWNoLCBwcmltYXJ5IG91dHB1dCBzaG91bGQgYmUgc2VudCB0byB0aGUgc3RhbmRhcmQgb3V0cHV0IHN0cmVhbQogKHN0ZG91dCksIGFuZCBjaGF0dHkgb3V0cHV0IHNob3VsZCBiZSBzZW50IHRvIHRoZSBzdGFuZGFyZCBlcnJvcgogc3RyZWFtIChzdGRlcnIpLiBFeGFtcGxlcyBvZiBjb21tYW5kcyB3aGljaCBwcm9kdWNlIHByaW1hcnkgb3V0cHV0CiBpbmNsdWRlIGBnaXQgbG9nYCwgYGdpdCBzaG93YCwgYW5kIGBnaXQgYnJhbmNoIC0tbGlzdGAgd2hpY2ggZ2VuZXJhdGUKIG91dHB1dCBvbiB0aGUgc3Rkb3V0IHN0cmVhbS4KCiBOb3QgYWxsIEdpdCBjb21tYW5kcyBoYXZlIHByaW1hcnkgb3V0cHV0OyB0aGlzIGlzIG9mdGVuIHRydWUgb2YKIGNvbW1hbmRzIHdob3NlIG1haW4gZnVuY3Rpb24gaXMgdG8gcGVyZm9ybSBhbiBhY3Rpb24uIFNvbWUgYWN0aW9uCiBjb21tYW5kcyBhcmUgc2lsZW50LCB3aGVyZWFzIG90aGVycyBhcmUgY2hhdHR5LiBBbiBleGFtcGxlIG9mIGEKIGNoYXR0eSBhY3Rpb24gY29tbWFuZHMgaXMgYGdpdCBjbG9uZWAgd2l0aCBpdHMgIkNsb25pbmcgaW50bwogJzxwYXRoPicuLi4iIGFuZCAiQ2hlY2tpbmcgY29ubmVjdGl2aXR5Li4uIiBzdGF0dXMgbWVzc2FnZXMgd2hpY2ggaXQKIHNlbmRzIHRvIHRoZSBzdGRlcnIgc3RyZWFtLgoKIEVycm9yIG1lc3NhZ2VzIGZyb20gR2l0IGNvbW1hbmRzIHNob3VsZCBhbHdheXMgYmUgc2VudCB0byB0aGUgc3RkZXJyCiBzdHJlYW0uCgoKRXJyb3IgTWVzc2FnZXMKCiAtIERvIG5vdCBlbmQgZXJyb3IgbWVzc2FnZXMgd2l0aCBhIGZ1bGwgc3RvcC4KCiAtIERvIG5vdCBjYXBpdGFsaXplIHRoZSBmaXJzdCB3b3JkLCBvbmx5IGJlY2F1c2UgaXQgaXMgdGhlIGZpcnN0IHdvcmQKICAgaW4gdGhlIG1lc3NhZ2UgKCJ1bmFibGUgdG8gb3BlbiAlcyIsIG5vdCAiVW5hYmxlIHRvIG9wZW4gJXMiKS4gIEJ1dAogICAiU0hBLTMgbm90IHN1cHBvcnRlZCIgaXMgZmluZSwgYmVjYXVzZSB0aGUgcmVhc29uIHRoZSBmaXJzdCB3b3JkIGlzCiAgIGNhcGl0YWxpemVkIGlzIG5vdCBiZWNhdXNlIGl0IGlzIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHNlbnRlbmNlLAogICBidXQgYmVjYXVzZSB0aGUgd29yZCB3b3VsZCBiZSBzcGVsbGVkIGluIGNhcGl0YWwgbGV0dGVycyBldmVuIHdoZW4KICAgaXQgYXBwZWFyZWQgaW4gdGhlIG1pZGRsZSBvZiB0aGUgc2VudGVuY2UuCgogLSBTYXkgd2hhdCB0aGUgZXJyb3IgaXMgZmlyc3QgKCJjYW5ub3Qgb3BlbiAlcyIsIG5vdCAiJXM6IGNhbm5vdCBvcGVuIikKCgpFeHRlcm5hbGx5IFZpc2libGUgTmFtZXMKCiAtIEZvciBjb25maWd1cmF0aW9uIHZhcmlhYmxlIG5hbWVzLCBmb2xsb3cgdGhlIGV4aXN0aW5nIGNvbnZlbnRpb246CgogICAuIFRoZSBzZWN0aW9uIG5hbWUgaW5kaWNhdGVzIHRoZSBhZmZlY3RlZCBzdWJzeXN0ZW0uCgogICAuIFRoZSBzdWJzZWN0aW9uIG5hbWUsIGlmIGFueSwgaW5kaWNhdGVzIHdoaWNoIG9mIGFuIHVuYm91bmRlZCBzZXQKICAgICBvZiB0aGluZ3MgdG8gc2V0IHRoZSB2YWx1ZSBmb3IuCgogICAuIFRoZSB2YXJpYWJsZSBuYW1lIGRlc2NyaWJlcyB0aGUgZWZmZWN0IG9mIHR3ZWFraW5nIHRoaXMga25vYi4KCiAgIFRoZSBzZWN0aW9uIGFuZCB2YXJpYWJsZSBuYW1lcyB0aGF0IGNvbnNpc3Qgb2YgbXVsdGlwbGUgd29yZHMgYXJlCiAgIGZvcm1lZCBieSBjb25jYXRlbmF0aW5nIHRoZSB3b3JkcyB3aXRob3V0IHB1bmN0dWF0aW9ucyAoZS5nLiBgLWApLAogICBhbmQgYXJlIGJyb2tlbiB1c2luZyBidW1weUNhcHMgaW4gZG9jdW1lbnRhdGlvbiBhcyBhIGhpbnQgdG8gdGhlCiAgIHJlYWRlci4KCiAgIFdoZW4gY2hvb3NpbmcgdGhlIHZhcmlhYmxlIG5hbWVzcGFjZSwgZG8gbm90IHVzZSB2YXJpYWJsZSBuYW1lIGZvcgogICBzcGVjaWZ5aW5nIHBvc3NpYmx5IHVuYm91bmRlZCBzZXQgb2YgdGhpbmdzLCBtb3N0IG5vdGFibHkgYW55dGhpbmcKICAgYW4gZW5kIHVzZXIgY2FuIGZyZWVseSBjb21lIHVwIHdpdGggKGUuZy4gYnJhbmNoIG5hbWVzKS4gIEluc3RlYWQsCiAgIHVzZSBzdWJzZWN0aW9uIG5hbWVzIG9yIHZhcmlhYmxlIHZhbHVlcywgbGlrZSB0aGUgZXhpc3RpbmcgdmFyaWFibGUKICAgYnJhbmNoLjxuYW1lPi5kZXNjcmlwdGlvbiBkb2VzLgoKCldyaXRpbmcgRG9jdW1lbnRhdGlvbjoKCiBNb3N0IChpZiBub3QgYWxsKSBvZiB0aGUgZG9jdW1lbnRhdGlvbiBwYWdlcyBhcmUgd3JpdHRlbiBpbiB0aGUKIEFzY2lpRG9jIGZvcm1hdCBpbiAqLnR4dCBmaWxlcyAoZS5nLiBEb2N1bWVudGF0aW9uL2dpdC50eHQpLCBhbmQKIHByb2Nlc3NlZCBpbnRvIEhUTUwgYW5kIG1hbnBhZ2VzIChlLmcuIGdpdC5odG1sIGFuZCBnaXQuMSBpbiB0aGUKIHNhbWUgZGlyZWN0b3J5KS4KCiBUaGUgZG9jdW1lbnRhdGlvbiBsaWJlcmFsbHkgbWl4ZXMgVVMgYW5kIFVLIEVuZ2xpc2ggKGVuX1VTL1VLKQogbm9ybXMgZm9yIHNwZWxsaW5nIGFuZCBncmFtbWFyLCB3aGljaCBpcyBzb21ld2hhdCB1bmZvcnR1bmF0ZS4KIEluIGFuIGlkZWFsIHdvcmxkLCBpdCB3b3VsZCBoYXZlIGJlZW4gYmV0dGVyIGlmIGl0IGNvbnNpc3RlbnRseQogdXNlZCBvbmx5IG9uZSBhbmQgbm90IHRoZSBvdGhlciwgYW5kIHdlIHdvdWxkIGhhdmUgcGlja2VkIGVuX1VTCiAoaWYgeW91IHdpc2ggdG8gY29ycmVjdCB0aGUgRW5nbGlzaCBvZiBzb21lIG9mIHRoZSBleGlzdGluZwogZG9jdW1lbnRhdGlvbiwgcGxlYXNlIHNlZSB0aGUgZG9jdW1lbnRhdGlvbi1yZWxhdGVkIGFkdmljZSBpbiB0aGUKIERvY3VtZW50YXRpb24vU3VibWl0dGluZ1BhdGNoZXMgZmlsZSkuCgogSW4gb3JkZXIgdG8gZW5zdXJlIHRoZSBkb2N1bWVudGF0aW9uIGlzIGluY2x1c2l2ZSwgYXZvaWQgYXNzdW1pbmcKIHRoYXQgYW4gdW5zcGVjaWZpZWQgZXhhbXBsZSBwZXJzb24gaXMgbWFsZSBvciBmZW1hbGUsIGFuZCB0aGluawogdHdpY2UgYmVmb3JlIHVzaW5nICJoZSIsICJoaW0iLCAic2hlIiwgb3IgImhlciIuICBIZXJlIGFyZSBzb21lCiB0aXBzIHRvIGF2b2lkIHVzZSBvZiBnZW5kZXJlZCBwcm9ub3VuczoKCiAgLSBQcmVmZXIgc3VjY2luY3RuZXNzIGFuZCBtYXR0ZXItb2YtZmFjdGx5IGRlc2NyaWJpbmcgZnVuY3Rpb25hbGl0eQogICAgaW4gdGhlIGFic3RyYWN0LiAgRS5nLgoKICAgICAtLXNob3J0OjogRW1pdCBvdXRwdXQgaW4gdGhlIHNob3J0LWZvcm1hdC4KCiAgICBhbmQgYXZvaWQgc29tZXRoaW5nIGxpa2UgdGhlc2Ugb3Zlcmx5IHZlcmJvc2UgYWx0ZXJuYXRpdmVzOgoKICAgICAtLXNob3J0OjogVXNlIHRoaXMgdG8gZW1pdCBvdXRwdXQgaW4gdGhlIHNob3J0LWZvcm1hdC4KICAgICAtLXNob3J0OjogWW91IGNhbiB1c2UgdGhpcyB0byBnZXQgb3V0cHV0IGluIHRoZSBzaG9ydC1mb3JtYXQuCiAgICAgLS1zaG9ydDo6IEEgdXNlciB3aG8gcHJlZmVycyBzaG9ydGVyIG91dHB1dCBjb3VsZC4uLi4KICAgICAtLXNob3J0OjogU2hvdWxkIGEgcGVyc29uIGFuZC9vciBwcm9ncmFtIHdhbnQgc2hvcnRlciBvdXRwdXQsIGhlCiAgICAgICAgICAgICAgIHNoZS90aGV5L2l0IGNhbi4uLgoKICAgIFRoaXMgcHJhY3RpY2Ugb2Z0ZW4gZWxpbWluYXRlcyB0aGUgbmVlZCB0byBpbnZvbHZlIGh1bWFuIGFjdG9ycyBpbgogICAgeW91ciBkZXNjcmlwdGlvbiwgYnV0IGl0IGlzIGEgZ29vZCBwcmFjdGljZSByZWdhcmRsZXNzIG9mIHRoZQogICAgYXZvaWRhbmNlIG9mIGdlbmRlcmVkIHByb25vdW5zLgoKICAtIFdoZW4gaXQgYmVjb21lcyBhd2t3YXJkIHRvIHN0aWNrIHRvIHRoaXMgc3R5bGUsIHByZWZlciAieW91IiB3aGVuCiAgICBhZGRyZXNzaW5nIHRoZSBoeXBvdGhldGljYWwgdXNlciwgYW5kIHBvc3NpYmx5ICJ3ZSIgd2hlbgogICAgZGlzY3Vzc2luZyBob3cgdGhlIHByb2dyYW0gbWlnaHQgcmVhY3QgdG8gdGhlIHVzZXIuICBFLmcuCgogICAgICBZb3UgY2FuIHVzZSB0aGlzIG9wdGlvbiBpbnN0ZWFkIG9mIC0teHl6LCBidXQgd2UgbWlnaHQgcmVtb3ZlCiAgICAgIHN1cHBvcnQgZm9yIGl0IGluIGZ1dHVyZSB2ZXJzaW9ucy4KCiAgICB3aGlsZSBrZWVwaW5nIGluIG1pbmQgdGhhdCB5b3UgY2FuIHByb2JhYmx5IGJlIGxlc3MgdmVyYm9zZSwgZS5nLgoKICAgICAgVXNlIHRoaXMgaW5zdGVhZCBvZiAtLXh5ei4gVGhpcyBvcHRpb24gbWlnaHQgYmUgcmVtb3ZlZCBpbiBmdXR1cmUKICAgICAgdmVyc2lvbnMuCgogIC0gSWYgeW91IHN0aWxsIG5lZWQgdG8gcmVmZXIgdG8gYW4gZXhhbXBsZSBwZXJzb24gdGhhdCBpcwogICAgdGhpcmQtcGVyc29uIHNpbmd1bGFyLCB5b3UgbWF5IHJlc29ydCB0byAic2luZ3VsYXIgdGhleSIgdG8gYXZvaWQKICAgICJoZS9zaGUvaGltL2hlciIsIGUuZy4KCiAgICAgIEEgY29udHJpYnV0b3IgYXNrcyB0aGVpciB1cHN0cmVhbSB0byBwdWxsIGZyb20gdGhlbS4KCiAgICBOb3RlIHRoYXQgdGhpcyBzb3VuZHMgdW5ncmFtbWF0aWNhbCBhbmQgdW5uYXR1cmFsIHRvIHRob3NlIHdobwogICAgbGVhcm5lZCB0aGF0ICJ0aGV5IiBpcyBvbmx5IHVzZWQgZm9yIHRoaXJkLXBlcnNvbiBwbHVyYWwsIGUuZy4KICAgIHRob3NlIHdobyBsZWFybiBFbmdsaXNoIGFzIGEgc2Vjb25kIGxhbmd1YWdlIGluIHNvbWUgcGFydHMgb2YgdGhlCiAgICB3b3JsZC4KCiBFdmVyeSB1c2VyLXZpc2libGUgY2hhbmdlIHNob3VsZCBiZSByZWZsZWN0ZWQgaW4gdGhlIGRvY3VtZW50YXRpb24uCiBUaGUgc2FtZSBnZW5lcmFsIHJ1bGUgYXMgZm9yIGNvZGUgYXBwbGllcyAtLSBpbWl0YXRlIHRoZSBleGlzdGluZwogY29udmVudGlvbnMuCgogQSBmZXcgY29tbWVudGVkIGV4YW1wbGVzIGZvbGxvdyB0byBwcm92aWRlIHJlZmVyZW5jZSB3aGVuIHdyaXRpbmcgb3IKIG1vZGlmeWluZyBjb21tYW5kIHVzYWdlIHN0cmluZ3MgYW5kIHN5bm9wc2lzIHNlY3Rpb25zIGluIHRoZSBtYW51YWwKIHBhZ2VzOgoKIFBsYWNlaG9sZGVycyBhcmUgc3BlbGxlZCBpbiBsb3dlcmNhc2UgYW5kIGVuY2xvc2VkIGluIGFuZ2xlIGJyYWNrZXRzOgogICA8ZmlsZT4KICAgLS1zb3J0PTxrZXk+CiAgIC0tYWJicmV2Wz08bj5dCgogSWYgYSBwbGFjZWhvbGRlciBoYXMgbXVsdGlwbGUgd29yZHMsIHRoZXkgYXJlIHNlcGFyYXRlZCBieSBkYXNoZXM6CiAgIDxuZXctYnJhbmNoLW5hbWU+CiAgIC0tdGVtcGxhdGU9PHRlbXBsYXRlLWRpcmVjdG9yeT4KCiBQb3NzaWJpbGl0eSBvZiBtdWx0aXBsZSBvY2N1cnJlbmNlcyBpcyBpbmRpY2F0ZWQgYnkgdGhyZWUgZG90czoKICAgPGZpbGU+Li4uCiAgIChPbmUgb3IgbW9yZSBvZiA8ZmlsZT4uKQoKIE9wdGlvbmFsIHBhcnRzIGFyZSBlbmNsb3NlZCBpbiBzcXVhcmUgYnJhY2tldHM6CiAgIFs8ZmlsZT4uLi5dCiAgIChaZXJvIG9yIG1vcmUgb2YgPGZpbGU+LikKCiAgIC0tZXhlYy1wYXRoWz08cGF0aD5dCiAgIChPcHRpb24gd2l0aCBhbiBvcHRpb25hbCBhcmd1bWVudC4gIE5vdGUgdGhhdCB0aGUgIj0iIGlzIGluc2lkZSB0aGUKICAgYnJhY2tldHMuKQoKICAgWzxwYXRjaD4uLi5dCiAgIChaZXJvIG9yIG1vcmUgb2YgPHBhdGNoPi4gIE5vdGUgdGhhdCB0aGUgZG90cyBhcmUgaW5zaWRlLCBub3QKICAgb3V0c2lkZSB0aGUgYnJhY2tldHMuKQoKIE11bHRpcGxlIGFsdGVybmF0aXZlcyBhcmUgaW5kaWNhdGVkIHdpdGggdmVydGljYWwgYmFyczoKICAgWy1xIHwgLS1xdWlldF0KICAgWy0tdXRmOCB8IC0tbm8tdXRmOF0KCiBVc2Ugc3BhY2luZyBhcm91bmQgInwiIHRva2VuKHMpLCBidXQgbm90IGltbWVkaWF0ZWx5IGFmdGVyIG9wZW5pbmcgb3IKIGJlZm9yZSBjbG9zaW5nIGEgW10gb3IgKCkgcGFpcjoKICAgRG86IFstcSB8IC0tcXVpZXRdCiAgIERvbid0OiBbLXF8LS1xdWlldF0KCiBEb24ndCB1c2Ugc3BhY2luZyBhcm91bmQgInwiIHRva2VucyB3aGVuIHRoZXkncmUgdXNlZCB0byBzZXBlcmF0ZSB0aGUKIGFsdGVybmF0ZSBhcmd1bWVudHMgb2YgYW4gb3B0aW9uOgogICAgRG86IC0tdHJhY2tbPShkaXJlY3R8aW5oZXJpdCldCiAgICBEb24ndDogLS10cmFja1s9KGRpcmVjdCB8IGluaGVyaXQpXQoKIFBhcmVudGhlc2VzIGFyZSB1c2VkIGZvciBncm91cGluZzoKICAgWyg8cmV2PiB8IDxyYW5nZT4pLi4uXQogICAoQW55IG51bWJlciBvZiBlaXRoZXIgPHJldj4gb3IgPHJhbmdlPi4gIFBhcmVucyBhcmUgbmVlZGVkIHRvIG1ha2UKICAgaXQgY2xlYXIgdGhhdCAiLi4uIiBwZXJ0YWlucyB0byBib3RoIDxyZXY+IGFuZCA8cmFuZ2U+LikKCiAgIFsoLXAgPHBhcmVudD4pLi4uXQogICAoQW55IG51bWJlciBvZiBvcHRpb24gLXAsIGVhY2ggd2l0aCBvbmUgPHBhcmVudD4gYXJndW1lbnQuKQoKICAgZ2l0IHJlbW90ZSBzZXQtaGVhZCA8bmFtZT4gKC1hIHwgLWQgfCA8YnJhbmNoPikKICAgKE9uZSBhbmQgb25seSBvbmUgb2YgIi1hIiwgIi1kIiBvciAiPGJyYW5jaD4iIF9tdXN0XyAobm8gc3F1YXJlCiAgIGJyYWNrZXRzKSBiZSBwcm92aWRlZC4pCgogQW5kIGEgc29tZXdoYXQgbW9yZSBjb250cml2ZWQgZXhhbXBsZToKICAgLS1kaWZmLWZpbHRlcj1bKEF8Q3xEfE18UnxUfFV8WHxCKS4uLlsqXV0KICAgSGVyZSAiPSIgaXMgb3V0c2lkZSB0aGUgYnJhY2tldHMsIGJlY2F1c2UgIi0tZGlmZi1maWx0ZXI9IiBpcyBhCiAgIHZhbGlkIHVzYWdlLiAgIioiIGhhcyBpdHMgb3duIHBhaXIgb2YgYnJhY2tldHMsIGJlY2F1c2UgaXQgY2FuCiAgIChvcHRpb25hbGx5KSBiZSBzcGVjaWZpZWQgb25seSB3aGVuIG9uZSBvciBtb3JlIG9mIHRoZSBsZXR0ZXJzIGlzCiAgIGFsc28gcHJvdmlkZWQuCgogIEEgbm90ZSBvbiBub3RhdGlvbjoKICAgVXNlICdnaXQnIChhbGwgbG93ZXJjYXNlKSB3aGVuIHRhbGtpbmcgYWJvdXQgY29tbWFuZHMgaS5lLiBzb21ldGhpbmcKICAgdGhlIHVzZXIgd291bGQgdHlwZSBpbnRvIGEgc2hlbGwgYW5kIHVzZSAnR2l0JyAodXBwZXJjYXNlIGZpcnN0IGxldHRlcikKICAgd2hlbiB0YWxraW5nIGFib3V0IHRoZSB2ZXJzaW9uIGNvbnRyb2wgc3lzdGVtIGFuZCBpdHMgcHJvcGVydGllcy4KCiBBIGZldyBjb21tZW50ZWQgZXhhbXBsZXMgZm9sbG93IHRvIHByb3ZpZGUgcmVmZXJlbmNlIHdoZW4gd3JpdGluZyBvcgogbW9kaWZ5aW5nIHBhcmFncmFwaHMgb3Igb3B0aW9uL2NvbW1hbmQgZXhwbGFuYXRpb25zIHRoYXQgY29udGFpbiBvcHRpb25zCiBvciBjb21tYW5kczoKCiBMaXRlcmFsIGV4YW1wbGVzIChlLmcuIHVzZSBvZiBjb21tYW5kLWxpbmUgb3B0aW9ucywgY29tbWFuZCBuYW1lcywKIGJyYW5jaCBuYW1lcywgVVJMcywgcGF0aG5hbWVzIChmaWxlcyBhbmQgZGlyZWN0b3JpZXMpLCBjb25maWd1cmF0aW9uIGFuZAogZW52aXJvbm1lbnQgdmFyaWFibGVzKSBtdXN0IGJlIHR5cGVzZXQgaW4gbW9ub3NwYWNlIChpLmUuIHdyYXBwZWQgd2l0aAogYmFja3RpY2tzKToKICAgYC0tcHJldHR5PW9uZWxpbmVgCiAgIGBnaXQgcmV2LWxpc3RgCiAgIGByZW1vdGUucHVzaERlZmF1bHRgCiAgIGBodHRwOi8vZ2l0LmV4YW1wbGUuY29tYAogICBgLmdpdC9jb25maWdgCiAgIGBHSVRfRElSYAogICBgSEVBRGAKCiBBbiBlbnZpcm9ubWVudCB2YXJpYWJsZSBtdXN0IGJlIHByZWZpeGVkIHdpdGggIiQiIG9ubHkgd2hlbiByZWZlcnJpbmcgdG8gaXRzCiB2YWx1ZSBhbmQgbm90IHdoZW4gcmVmZXJyaW5nIHRvIHRoZSB2YXJpYWJsZSBpdHNlbGYsIGluIHRoaXMgY2FzZSB0aGVyZSBpcwogbm90aGluZyB0byBhZGQgZXhjZXB0IHRoZSBiYWNrdGlja3M6CiAgIGBHSVRfRElSYCBpcyBzcGVjaWZpZWQKICAgYCRHSVRfRElSL2hvb2tzL3ByZS1yZWNlaXZlYAoKIFdvcmQgcGhyYXNlcyBlbmNsb3NlZCBpbiBgYmFja3RpY2sgY2hhcmFjdGVyc2AgYXJlIHJlbmRlcmVkIGxpdGVyYWxseQogYW5kIHdpbGwgbm90IGJlIGZ1cnRoZXIgZXhwYW5kZWQuIFRoZSB1c2Ugb2YgYGJhY2t0aWNrc2AgdG8gYWNoaWV2ZSB0aGUKIHByZXZpb3VzIHJ1bGUgbWVhbnMgdGhhdCBsaXRlcmFsIGV4YW1wbGVzIHNob3VsZCBub3QgdXNlIEFzY2lpRG9jCiBlc2NhcGVzLgogICBDb3JyZWN0OgogICAgICBgLS1wcmV0dHk9b25lbGluZWAKICAgSW5jb3JyZWN0OgogICAgICBgXC0tcHJldHR5PW9uZWxpbmVgCgogSWYgc29tZSBwbGFjZSBpbiB0aGUgZG9jdW1lbnRhdGlvbiBuZWVkcyB0byB0eXBlc2V0IGEgY29tbWFuZCB1c2FnZQogZXhhbXBsZSB3aXRoIGlubGluZSBzdWJzdGl0dXRpb25zLCBpdCBpcyBmaW5lIHRvIHVzZSArbW9ub3NwYWNlZCBhbmQKIGlubGluZSBzdWJzdGl0dXRlZCB0ZXh0KyBpbnN0ZWFkIG9mIGBtb25vc3BhY2VkIGxpdGVyYWwgdGV4dGAsIGFuZCB3aXRoCiB0aGUgZm9ybWVyLCB0aGUgcGFydCB0aGF0IHNob3VsZCBub3QgZ2V0IHN1YnN0aXR1dGVkIG11c3QgYmUKIHF1b3RlZC9lc2NhcGVkLgo=",
    "text": "Like other projects, we also have some guidelines to keep to the\ncode.  For Git in general, a few rough rules are:\n\n - Most importantly, we never say \"It's in POSIX; we'll happily\n   ignore your needs should your system not conform to it.\"\n   We live in the real world.\n\n - However, we often say \"Let's stay away from that construct,\n   it's not even in POSIX\".\n\n - In spite of the above two rules, we sometimes say \"Although\n   this is not in POSIX, it (is so convenient | makes the code\n   much more readable | has other good characteristics) and\n   practically all the platforms we care about support it, so\n   let's use it\".\n\n   Again, we live in the real world, and it is sometimes a\n   judgement call, the decision based more on real world\n   constraints people face than what the paper standard says.\n\n - Fixing style violations while working on a real change as a\n   preparatory clean-up step is good, but otherwise avoid useless code\n   churn for the sake of conforming to the style.\n\n   \"Once it _is_ in the tree, it's not really worth the patch noise to\n   go and fix it up.\"\n   Cf. http://lkml.iu.edu/hypermail/linux/kernel/1001.3/01069.html\n\n - Log messages to explain your changes are as important as the\n   changes themselves.  Clearly written code and in-code comments\n   explain how the code works and what is assumed from the surrounding\n   context.  The log messages explain what the changes wanted to\n   achieve and why the changes were necessary (more on this in the\n   accompanying SubmittingPatches document).\n\nMake your code readable and sensible, and don't try to be clever.\n\nAs for more concrete guidelines, just imitate the existing code\n(this is a good guideline, no matter which project you are\ncontributing to). It is always preferable to match the _local_\nconvention. New code added to Git suite is expected to match\nthe overall style of existing code. Modifications to existing\ncode is expected to match the style the surrounding code already\nuses (even if it doesn't match the overall style of existing code).\n\nBut if you must have a list of rules, here are some language\nspecific ones. Note that Documentation/ToolsForGit.txt document\nhas a collection of tips to help you use some external tools\nto conform to these guidelines.\n\nFor shell scripts specifically (not exhaustive):\n\n - We use tabs for indentation.\n\n - Case arms are indented at the same depth as case and esac lines,\n   like this:\n\n\tcase \"$variable\" in\n\tpattern1)\n\t\tdo this\n\t\t;;\n\tpattern2)\n\t\tdo that\n\t\t;;\n\tesac\n\n - Redirection operators should be written with space before, but no\n   space after them.  In other words, write 'echo test >\"$file\"'\n   instead of 'echo test> $file' or 'echo test > $file'.  Note that\n   even though it is not required by POSIX to double-quote the\n   redirection target in a variable (as shown above), our code does so\n   because some versions of bash issue a warning without the quotes.\n\n\t(incorrect)\n\tcat hello > world < universe\n\techo hello >$world\n\n\t(correct)\n\tcat hello >world <universe\n\techo hello >\"$world\"\n\n - We prefer $( ... ) for command substitution; unlike ``, it\n   properly nests.  It should have been the way Bourne spelled\n   it from day one, but unfortunately isn't.\n\n - If you want to find out if a command is available on the user's\n   $PATH, you should use 'type <command>', instead of 'which <command>'.\n   The output of 'which' is not machine parsable and its exit code\n   is not reliable across platforms.\n\n - We use POSIX compliant parameter substitutions and avoid bashisms;\n   namely:\n\n   - We use ${parameter-word} and its [-=?+] siblings, and their\n     colon'ed \"unset or null\" form.\n\n   - We use ${parameter#word} and its [#%] siblings, and their\n     doubled \"longest matching\" form.\n\n   - No \"Substring Expansion\" ${parameter:offset:length}.\n\n   - No shell arrays.\n\n   - No pattern replacement ${parameter/pattern/string}.\n\n - We use Arithmetic Expansion $(( ... )).\n\n - We do not use Process Substitution <(list) or >(list).\n\n - Do not write control structures on a single line with semicolon.\n   \"then\" should be on the next line for if statements, and \"do\"\n   should be on the next line for \"while\" and \"for\".\n\n\t(incorrect)\n\tif test -f hello; then\n\t\tdo this\n\tfi\n\n\t(correct)\n\tif test -f hello\n\tthen\n\t\tdo this\n\tfi\n\n - If a command sequence joined with && or || or | spans multiple\n   lines, put each command on a separate line and put && and || and |\n   operators at the end of each line, rather than the start. This\n   means you don't need to use \\ to join lines, since the above\n   operators imply the sequence isn't finished.\n\n\t(incorrect)\n\tgrep blob verify_pack_result \\\n\t| awk -f print_1.awk \\\n\t| sort >actual &&\n\t...\n\n\t(correct)\n\tgrep blob verify_pack_result |\n\tawk -f print_1.awk |\n\tsort >actual &&\n\t...\n\n - We prefer \"test\" over \"[ ... ]\".\n\n - We do not write the noiseword \"function\" in front of shell\n   functions.\n\n - We prefer a space between the function name and the parentheses,\n   and no space inside the parentheses. The opening \"{\" should also\n   be on the same line.\n\n\t(incorrect)\n\tmy_function(){\n\t\t...\n\n\t(correct)\n\tmy_function () {\n\t\t...\n\n - As to use of grep, stick to a subset of BRE (namely, no \\{m,n\\},\n   [::], [==], or [..]) for portability.\n\n   - We do not use \\{m,n\\};\n\n   - We do not use ? or + (which are \\{0,1\\} and \\{1,\\}\n     respectively in BRE) but that goes without saying as these\n     are ERE elements not BRE (note that \\? and \\+ are not even part\n     of BRE -- making them accessible from BRE is a GNU extension).\n\n - Use Git's gettext wrappers in git-sh-i18n to make the user\n   interface translatable. See \"Marking strings for translation\" in\n   po/README.\n\n - We do not write our \"test\" command with \"-a\" and \"-o\" and use \"&&\"\n   or \"||\" to concatenate multiple \"test\" commands instead, because\n   the use of \"-a/-o\" is often error-prone.  E.g.\n\n     test -n \"$x\" -a \"$a\" = \"$b\"\n\n   is buggy and breaks when $x is \"=\", but\n\n     test -n \"$x\" && test \"$a\" = \"$b\"\n\n   does not have such a problem.\n\n - Even though \"local\" is not part of POSIX, we make heavy use of it\n   in our test suite.  We do not use it in scripted Porcelains, and\n   hopefully nobody starts using \"local\" before they are reimplemented\n   in C ;-)\n\n\nFor C programs:\n\n - We use tabs to indent, and interpret tabs as taking up to\n   8 spaces.\n\n - We try to keep to at most 80 characters per line.\n\n - As a Git developer we assume you have a reasonably modern compiler\n   and we recommend you to enable the DEVELOPER makefile knob to\n   ensure your patch is clear of all compiler warnings we care about,\n   by e.g. \"echo DEVELOPER=1 >>config.mak\".\n\n - We try to support a wide range of C compilers to compile Git with,\n   including old ones.  As of Git v2.35.0 Git requires C99 (we check\n   \"__STDC_VERSION__\"). You should not use features from a newer C\n   standard, even if your compiler groks them.\n\n   New C99 features have been phased in gradually, if something's new\n   in C99 but not used yet don't assume that it's safe to use, some\n   compilers we target have only partial support for it. These are\n   considered safe to use:\n\n   . since around 2007 with 2b6854c863a, we have been using\n     initializer elements which are not computable at load time. E.g.:\n\n\tconst char *args[] = {\"constant\", variable, NULL};\n\n   . since early 2012 with e1327023ea, we have been using an enum\n     definition whose last element is followed by a comma.  This, like\n     an array initializer that ends with a trailing comma, can be used\n     to reduce the patch noise when adding a new identifier at the end.\n\n   . since mid 2017 with cbc0f81d, we have been using designated\n     initializers for struct (e.g. \"struct t v = { .val = 'a' };\").\n\n   . since mid 2017 with 512f41cf, we have been using designated\n     initializers for array (e.g. \"int array[10] = { [5] = 2 }\").\n\n   . since early 2021 with 765dc168882, we have been using variadic\n     macros, mostly for printf-like trace and debug macros.\n\n   . since late 2021 with 44ba10d6, we have had variables declared in\n     the for loop \"for (int i = 0; i < 10; i++)\".\n\n   New C99 features that we cannot use yet:\n\n   . %z and %zu as a printf() argument for a size_t (the %z being for\n     the POSIX-specific ssize_t). Instead you should use\n     printf(\"%\"PRIuMAX, (uintmax_t)v).  These days the MSVC version we\n     rely on supports %z, but the C library used by MinGW does not.\n\n   . Shorthand like \".a.b = *c\" in struct initializations is known to\n     trip up an older IBM XLC version, use \".a = { .b = *c }\" instead.\n     See the 33665d98 (reftable: make assignments portable to AIX xlc\n     v12.01, 2022-03-28).\n\n - Variables have to be declared at the beginning of the block, before\n   the first statement (i.e. -Wdeclaration-after-statement).\n\n - NULL pointers shall be written as NULL, not as 0.\n\n - When declaring pointers, the star sides with the variable\n   name, i.e. \"char *string\", not \"char* string\" or\n   \"char * string\".  This makes it easier to understand code\n   like \"char *string, c;\".\n\n - Use whitespace around operators and keywords, but not inside\n   parentheses and not around functions. So:\n\n        while (condition)\n\t\tfunc(bar + 1);\n\n   and not:\n\n        while( condition )\n\t\tfunc (bar+1);\n\n - Do not explicitly compare an integral value with constant 0 or '\\0',\n   or a pointer value with constant NULL.  For instance, to validate that\n   counted array <ptr, cnt> is initialized but has no elements, write:\n\n\tif (!ptr || cnt)\n\t\tBUG(\"empty array expected\");\n\n   and not:\n\n\tif (ptr == NULL || cnt != 0);\n\t\tBUG(\"empty array expected\");\n\n - We avoid using braces unnecessarily.  I.e.\n\n\tif (bla) {\n\t\tx = 1;\n\t}\n\n   is frowned upon. But there are a few exceptions:\n\n\t- When the statement extends over a few lines (e.g., a while loop\n\t  with an embedded conditional, or a comment). E.g.:\n\n\t\twhile (foo) {\n\t\t\tif (x)\n\t\t\t\tone();\n\t\t\telse\n\t\t\t\ttwo();\n\t\t}\n\n\t\tif (foo) {\n\t\t\t/*\n\t\t\t * This one requires some explanation,\n\t\t\t * so we're better off with braces to make\n\t\t\t * it obvious that the indentation is correct.\n\t\t\t */\n\t\t\tdoit();\n\t\t}\n\n\t- When there are multiple arms to a conditional and some of them\n\t  require braces, enclose even a single line block in braces for\n\t  consistency. E.g.:\n\n\t\tif (foo) {\n\t\t\tdoit();\n\t\t} else {\n\t\t\tone();\n\t\t\ttwo();\n\t\t\tthree();\n\t\t}\n\n - We try to avoid assignments in the condition of an \"if\" statement.\n\n - Try to make your code understandable.  You may put comments\n   in, but comments invariably tend to stale out when the code\n   they were describing changes.  Often splitting a function\n   into two makes the intention of the code much clearer.\n\n - Multi-line comments include their delimiters on separate lines from\n   the text.  E.g.\n\n\t/*\n\t * A very long\n\t * multi-line comment.\n\t */\n\n   Note however that a comment that explains a translatable string to\n   translators uses a convention of starting with a magic token\n   \"TRANSLATORS: \", e.g.\n\n\t/*\n\t * TRANSLATORS: here is a comment that explains the string to\n\t * be translated, that follows immediately after it.\n\t */\n\t_(\"Here is a translatable string explained by the above.\");\n\n - Double negation is often harder to understand than no negation\n   at all.\n\n - There are two schools of thought when it comes to comparison,\n   especially inside a loop. Some people prefer to have the less stable\n   value on the left hand side and the more stable value on the right hand\n   side, e.g. if you have a loop that counts variable i down to the\n   lower bound,\n\n\twhile (i > lower_bound) {\n\t\tdo something;\n\t\ti--;\n\t}\n\n   Other people prefer to have the textual order of values match the\n   actual order of values in their comparison, so that they can\n   mentally draw a number line from left to right and place these\n   values in order, i.e.\n\n\twhile (lower_bound < i) {\n\t\tdo something;\n\t\ti--;\n\t}\n\n   Both are valid, and we use both.  However, the more \"stable\" the\n   stable side becomes, the more we tend to prefer the former\n   (comparison with a constant, \"i > 0\", is an extreme example).\n   Just do not mix styles in the same part of the code and mimic\n   existing styles in the neighbourhood.\n\n - There are two schools of thought when it comes to splitting a long\n   logical line into multiple lines.  Some people push the second and\n   subsequent lines far enough to the right with tabs and align them:\n\n        if (the_beginning_of_a_very_long_expression_that_has_to ||\n\t\tspan_more_than_a_single_line_of ||\n\t\tthe_source_text) {\n                ...\n\n   while other people prefer to align the second and the subsequent\n   lines with the column immediately inside the opening parenthesis,\n   with tabs and spaces, following our \"tabstop is always a multiple\n   of 8\" convention:\n\n        if (the_beginning_of_a_very_long_expression_that_has_to ||\n\t    span_more_than_a_single_line_of ||\n\t    the_source_text) {\n                ...\n\n   Both are valid, and we use both.  Again, just do not mix styles in\n   the same part of the code and mimic existing styles in the\n   neighbourhood.\n\n - When splitting a long logical line, some people change line before\n   a binary operator, so that the result looks like a parse tree when\n   you turn your head 90-degrees counterclockwise:\n\n        if (the_beginning_of_a_very_long_expression_that_has_to\n\t    || span_more_than_a_single_line_of_the_source_text) {\n\n   while other people prefer to leave the operator at the end of the\n   line:\n\n        if (the_beginning_of_a_very_long_expression_that_has_to ||\n\t    span_more_than_a_single_line_of_the_source_text) {\n\n   Both are valid, but we tend to use the latter more, unless the\n   expression gets fairly complex, in which case the former tends to\n   be easier to read.  Again, just do not mix styles in the same part\n   of the code and mimic existing styles in the neighbourhood.\n\n - When splitting a long logical line, with everything else being\n   equal, it is preferable to split after the operator at higher\n   level in the parse tree.  That is, this is more preferable:\n\n\tif (a_very_long_variable * that_is_used_in +\n\t    a_very_long_expression) {\n\t\t...\n\n   than\n\n\tif (a_very_long_variable *\n\t    that_is_used_in + a_very_long_expression) {\n\t\t...\n\n - Some clever tricks, like using the !! operator with arithmetic\n   constructs, can be extremely confusing to others.  Avoid them,\n   unless there is a compelling reason to use them.\n\n - Use the API.  No, really.  We have a strbuf (variable length\n   string), several arrays with the ALLOC_GROW() macro, a\n   string_list for sorted string lists, a hash map (mapping struct\n   objects) named \"struct decorate\", amongst other things.\n\n - When you come up with an API, document its functions and structures\n   in the header file that exposes the API to its callers. Use what is\n   in \"strbuf.h\" as a model for the appropriate tone and level of\n   detail.\n\n - The first #include in C files, except in platform specific compat/\n   implementations and sha1dc/, must be either \"git-compat-util.h\" or\n   one of the approved headers that includes it first for you.  (The\n   approved headers currently include \"cache.h\", \"builtin.h\",\n   \"t/helper/test-tool.h\", \"xdiff/xinclude.h\", or\n   \"reftable/system.h\").  You do not have to include more than one of\n   these.\n\n - A C file must directly include the header files that declare the\n   functions and the types it uses, except for the functions and types\n   that are made available to it by including one of the header files\n   it must include by the previous rule.\n\n - If you are planning a new command, consider writing it in shell\n   or perl first, so that changes in semantics can be easily\n   changed and discussed.  Many Git commands started out like\n   that, and a few are still scripts.\n\n - Avoid introducing a new dependency into Git. This means you\n   usually should stay away from scripting languages not already\n   used in the Git core command set (unless your command is clearly\n   separate from it, such as an importer to convert random-scm-X\n   repositories to Git).\n\n - When we pass <string, length> pair to functions, we should try to\n   pass them in that order.\n\n - Use Git's gettext wrappers to make the user interface\n   translatable. See \"Marking strings for translation\" in po/README.\n\n - Variables and functions local to a given source file should be marked\n   with \"static\". Variables that are visible to other source files\n   must be declared with \"extern\" in header files. However, function\n   declarations should not use \"extern\", as that is already the default.\n\n - You can launch gdb around your program using the shorthand GIT_DEBUGGER.\n   Run `GIT_DEBUGGER=1 ./bin-wrappers/git foo` to simply use gdb as is, or\n   run `GIT_DEBUGGER=\"<debugger> <debugger-args>\" ./bin-wrappers/git foo` to\n   use your own debugger and arguments. Example: `GIT_DEBUGGER=\"ddd --gdb\"\n   ./bin-wrappers/git log` (See `wrap-for-bin.sh`.)\n\nFor Perl programs:\n\n - Most of the C guidelines above apply.\n\n - We try to support Perl 5.8 and later (\"use Perl 5.008\").\n\n - use strict and use warnings are strongly preferred.\n\n - Don't overuse statement modifiers unless using them makes the\n   result easier to follow.\n\n\t... do something ...\n\tdo_this() unless (condition);\n        ... do something else ...\n\n   is more readable than:\n\n\t... do something ...\n\tunless (condition) {\n\t\tdo_this();\n\t}\n        ... do something else ...\n\n   *only* when the condition is so rare that do_this() will be almost\n   always called.\n\n - We try to avoid assignments inside \"if ()\" conditions.\n\n - Learn and use Git.pm if you need that functionality.\n\nFor Python scripts:\n\n - We follow PEP-8 (http://www.python.org/dev/peps/pep-0008/).\n\n - As a minimum, we aim to be compatible with Python 2.7.\n\n - Where required libraries do not restrict us to Python 2, we try to\n   also be compatible with Python 3.1 and later.\n\n\nProgram Output\n\n We make a distinction between a Git command's primary output and\n output which is merely chatty feedback (for instance, status\n messages, running transcript, or progress display), as well as error\n messages. Roughly speaking, a Git command's primary output is that\n which one might want to capture to a file or send down a pipe; its\n chatty output should not interfere with these use-cases.\n\n As such, primary output should be sent to the standard output stream\n (stdout), and chatty output should be sent to the standard error\n stream (stderr). Examples of commands which produce primary output\n include `git log`, `git show`, and `git branch --list` which generate\n output on the stdout stream.\n\n Not all Git commands have primary output; this is often true of\n commands whose main function is to perform an action. Some action\n commands are silent, whereas others are chatty. An example of a\n chatty action commands is `git clone` with its \"Cloning into\n '<path>'...\" and \"Checking connectivity...\" status messages which it\n sends to the stderr stream.\n\n Error messages from Git commands should always be sent to the stderr\n stream.\n\n\nError Messages\n\n - Do not end error messages with a full stop.\n\n - Do not capitalize the first word, only because it is the first word\n   in the message (\"unable to open %s\", not \"Unable to open %s\").  But\n   \"SHA-3 not supported\" is fine, because the reason the first word is\n   capitalized is not because it is at the beginning of the sentence,\n   but because the word would be spelled in capital letters even when\n   it appeared in the middle of the sentence.\n\n - Say what the error is first (\"cannot open %s\", not \"%s: cannot open\")\n\n\nExternally Visible Names\n\n - For configuration variable names, follow the existing convention:\n\n   . The section name indicates the affected subsystem.\n\n   . The subsection name, if any, indicates which of an unbounded set\n     of things to set the value for.\n\n   . The variable name describes the effect of tweaking this knob.\n\n   The section and variable names that consist of multiple words are\n   formed by concatenating the words without punctuations (e.g. `-`),\n   and are broken using bumpyCaps in documentation as a hint to the\n   reader.\n\n   When choosing the variable namespace, do not use variable name for\n   specifying possibly unbounded set of things, most notably anything\n   an end user can freely come up with (e.g. branch names).  Instead,\n   use subsection names or variable values, like the existing variable\n   branch.<name>.description does.\n\n\nWriting Documentation:\n\n Most (if not all) of the documentation pages are written in the\n AsciiDoc format in *.txt files (e.g. Documentation/git.txt), and\n processed into HTML and manpages (e.g. git.html and git.1 in the\n same directory).\n\n The documentation liberally mixes US and UK English (en_US/UK)\n norms for spelling and grammar, which is somewhat unfortunate.\n In an ideal world, it would have been better if it consistently\n used only one and not the other, and we would have picked en_US\n (if you wish to correct the English of some of the existing\n documentation, please see the documentation-related advice in the\n Documentation/SubmittingPatches file).\n\n In order to ensure the documentation is inclusive, avoid assuming\n that an unspecified example person is male or female, and think\n twice before using \"he\", \"him\", \"she\", or \"her\".  Here are some\n tips to avoid use of gendered pronouns:\n\n  - Prefer succinctness and matter-of-factly describing functionality\n    in the abstract.  E.g.\n\n     --short:: Emit output in the short-format.\n\n    and avoid something like these overly verbose alternatives:\n\n     --short:: Use this to emit output in the short-format.\n     --short:: You can use this to get output in the short-format.\n     --short:: A user who prefers shorter output could....\n     --short:: Should a person and/or program want shorter output, he\n               she/they/it can...\n\n    This practice often eliminates the need to involve human actors in\n    your description, but it is a good practice regardless of the\n    avoidance of gendered pronouns.\n\n  - When it becomes awkward to stick to this style, prefer \"you\" when\n    addressing the hypothetical user, and possibly \"we\" when\n    discussing how the program might react to the user.  E.g.\n\n      You can use this option instead of --xyz, but we might remove\n      support for it in future versions.\n\n    while keeping in mind that you can probably be less verbose, e.g.\n\n      Use this instead of --xyz. This option might be removed in future\n      versions.\n\n  - If you still need to refer to an example person that is\n    third-person singular, you may resort to \"singular they\" to avoid\n    \"he/she/him/her\", e.g.\n\n      A contributor asks their upstream to pull from them.\n\n    Note that this sounds ungrammatical and unnatural to those who\n    learned that \"they\" is only used for third-person plural, e.g.\n    those who learn English as a second language in some parts of the\n    world.\n\n Every user-visible change should be reflected in the documentation.\n The same general rule as for code applies -- imitate the existing\n conventions.\n\n A few commented examples follow to provide reference when writing or\n modifying command usage strings and synopsis sections in the manual\n pages:\n\n Placeholders are spelled in lowercase and enclosed in angle brackets:\n   <file>\n   --sort=<key>\n   --abbrev[=<n>]\n\n If a placeholder has multiple words, they are separated by dashes:\n   <new-branch-name>\n   --template=<template-directory>\n\n Possibility of multiple occurrences is indicated by three dots:\n   <file>...\n   (One or more of <file>.)\n\n Optional parts are enclosed in square brackets:\n   [<file>...]\n   (Zero or more of <file>.)\n\n   --exec-path[=<path>]\n   (Option with an optional argument.  Note that the \"=\" is inside the\n   brackets.)\n\n   [<patch>...]\n   (Zero or more of <patch>.  Note that the dots are inside, not\n   outside the brackets.)\n\n Multiple alternatives are indicated with vertical bars:\n   [-q | --quiet]\n   [--utf8 | --no-utf8]\n\n Use spacing around \"|\" token(s), but not immediately after opening or\n before closing a [] or () pair:\n   Do: [-q | --quiet]\n   Don't: [-q|--quiet]\n\n Don't use spacing around \"|\" tokens when they're used to seperate the\n alternate arguments of an option:\n    Do: --track[=(direct|inherit)]\n    Don't: --track[=(direct | inherit)]\n\n Parentheses are used for grouping:\n   [(<rev> | <range>)...]\n   (Any number of either <rev> or <range>.  Parens are needed to make\n   it clear that \"...\" pertains to both <rev> and <range>.)\n\n   [(-p <parent>)...]\n   (Any number of option -p, each with one <parent> argument.)\n\n   git remote set-head <name> (-a | -d | <branch>)\n   (One and only one of \"-a\", \"-d\" or \"<branch>\" _must_ (no square\n   brackets) be provided.)\n\n And a somewhat more contrived example:\n   --diff-filter=[(A|C|D|M|R|T|U|X|B)...[*]]\n   Here \"=\" is outside the brackets, because \"--diff-filter=\" is a\n   valid usage.  \"*\" has its own pair of brackets, because it can\n   (optionally) be specified only when one or more of the letters is\n   also provided.\n\n  A note on notation:\n   Use 'git' (all lowercase) when talking about commands i.e. something\n   the user would type into a shell and use 'Git' (uppercase first letter)\n   when talking about the version control system and its properties.\n\n A few commented examples follow to provide reference when writing or\n modifying paragraphs or option/command explanations that contain options\n or commands:\n\n Literal examples (e.g. use of command-line options, command names,\n branch names, URLs, pathnames (files and directories), configuration and\n environment variables) must be typeset in monospace (i.e. wrapped with\n backticks):\n   `--pretty=oneline`\n   `git rev-list`\n   `remote.pushDefault`\n   `http://git.example.com`\n   `.git/config`\n   `GIT_DIR`\n   `HEAD`\n\n An environment variable must be prefixed with \"$\" only when referring to its\n value and not when referring to the variable itself, in this case there is\n nothing to add except the backticks:\n   `GIT_DIR` is specified\n   `$GIT_DIR/hooks/pre-receive`\n\n Word phrases enclosed in `backtick characters` are rendered literally\n and will not be further expanded. The use of `backticks` to achieve the\n previous rule means that literal examples should not use AsciiDoc\n escapes.\n   Correct:\n      `--pretty=oneline`\n   Incorrect:\n      `\\--pretty=oneline`\n\n If some place in the documentation needs to typeset a command usage\n example with inline substitutions, it is fine to use +monospaced and\n inline substituted text+ instead of `monospaced literal text`, and with\n the former, the part that should not get substituted must be\n quoted/escaped.\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "003393ed161dab04a5c73269d49fa2e2f2fdd1f6",
  "sha1_ok": true,
  "size": 26564
}
