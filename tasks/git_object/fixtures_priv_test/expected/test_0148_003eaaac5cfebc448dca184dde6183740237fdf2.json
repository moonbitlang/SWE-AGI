{
  "content": {
    "base64": "I2luY2x1ZGUgImJ1aWx0aW4uaCIKI2luY2x1ZGUgImNvbmZpZy5oIgojaW5jbHVkZSAiZGlyLmgiCiNpbmNsdWRlICJsb2NrZmlsZS5oIgojaW5jbHVkZSAicGFyc2Utb3B0aW9ucy5oIgojaW5jbHVkZSAicmVwb3NpdG9yeS5oIgojaW5jbHVkZSAiY29tbWl0LWdyYXBoLmgiCiNpbmNsdWRlICJvYmplY3Qtc3RvcmUuaCIKI2luY2x1ZGUgInByb2dyZXNzLmgiCiNpbmNsdWRlICJ0YWcuaCIKCnN0YXRpYyBjaGFyIGNvbnN0ICogY29uc3QgYnVpbHRpbl9jb21taXRfZ3JhcGhfdXNhZ2VbXSA9IHsKCU5fKCJnaXQgY29tbWl0LWdyYXBoIHZlcmlmeSBbLS1vYmplY3QtZGlyIDxvYmpkaXI+XSBbLS1zaGFsbG93XSBbLS1bbm8tXXByb2dyZXNzXSIpLAoJTl8oImdpdCBjb21taXQtZ3JhcGggd3JpdGUgWy0tb2JqZWN0LWRpciA8b2JqZGlyPl0gWy0tYXBwZW5kXSAiCgkgICAiWy0tc3BsaXRbPTxzdHJhdGVneT5dXSBbLS1yZWFjaGFibGV8LS1zdGRpbi1wYWNrc3wtLXN0ZGluLWNvbW1pdHNdICIKCSAgICJbLS1jaGFuZ2VkLXBhdGhzXSBbLS1bbm8tXW1heC1uZXctZmlsdGVycyA8bj5dIFstLVtuby1dcHJvZ3Jlc3NdICIKCSAgICI8c3BsaXQgb3B0aW9ucz4iKSwKCU5VTEwKfTsKCnN0YXRpYyBjb25zdCBjaGFyICogY29uc3QgYnVpbHRpbl9jb21taXRfZ3JhcGhfdmVyaWZ5X3VzYWdlW10gPSB7CglOXygiZ2l0IGNvbW1pdC1ncmFwaCB2ZXJpZnkgWy0tb2JqZWN0LWRpciA8b2JqZGlyPl0gWy0tc2hhbGxvd10gWy0tW25vLV1wcm9ncmVzc10iKSwKCU5VTEwKfTsKCnN0YXRpYyBjb25zdCBjaGFyICogY29uc3QgYnVpbHRpbl9jb21taXRfZ3JhcGhfd3JpdGVfdXNhZ2VbXSA9IHsKCU5fKCJnaXQgY29tbWl0LWdyYXBoIHdyaXRlIFstLW9iamVjdC1kaXIgPG9iamRpcj5dIFstLWFwcGVuZF0gIgoJICAgIlstLXNwbGl0Wz08c3RyYXRlZ3k+XV0gWy0tcmVhY2hhYmxlfC0tc3RkaW4tcGFja3N8LS1zdGRpbi1jb21taXRzXSAiCgkgICAiWy0tY2hhbmdlZC1wYXRoc10gWy0tW25vLV1tYXgtbmV3LWZpbHRlcnMgPG4+XSBbLS1bbm8tXXByb2dyZXNzXSAiCgkgICAiPHNwbGl0IG9wdGlvbnM+IiksCglOVUxMCn07CgpzdGF0aWMgc3RydWN0IG9wdHNfY29tbWl0X2dyYXBoIHsKCWNvbnN0IGNoYXIgKm9ial9kaXI7CglpbnQgcmVhY2hhYmxlOwoJaW50IHN0ZGluX3BhY2tzOwoJaW50IHN0ZGluX2NvbW1pdHM7CglpbnQgYXBwZW5kOwoJaW50IHNwbGl0OwoJaW50IHNoYWxsb3c7CglpbnQgcHJvZ3Jlc3M7CglpbnQgZW5hYmxlX2NoYW5nZWRfcGF0aHM7Cn0gb3B0czsKCnN0YXRpYyBpbnQgZ3JhcGhfdmVyaWZ5KGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndikKewoJc3RydWN0IGNvbW1pdF9ncmFwaCAqZ3JhcGggPSBOVUxMOwoJc3RydWN0IG9iamVjdF9kaXJlY3RvcnkgKm9kYiA9IE5VTEw7CgljaGFyICpncmFwaF9uYW1lOwoJaW50IG9wZW5fb2s7CglpbnQgZmQ7CglzdHJ1Y3Qgc3RhdCBzdDsKCWludCBmbGFncyA9IDA7CgoJc3RhdGljIHN0cnVjdCBvcHRpb24gYnVpbHRpbl9jb21taXRfZ3JhcGhfdmVyaWZ5X29wdGlvbnNbXSA9IHsKCQlPUFRfU1RSSU5HKDAsICJvYmplY3QtZGlyIiwgJm9wdHMub2JqX2RpciwKCQkJICAgTl8oImRpciIpLAoJCQkgICBOXygidGhlIG9iamVjdCBkaXJlY3RvcnkgdG8gc3RvcmUgdGhlIGdyYXBoIikpLAoJCU9QVF9CT09MKDAsICJzaGFsbG93IiwgJm9wdHMuc2hhbGxvdywKCQkJIE5fKCJpZiB0aGUgY29tbWl0LWdyYXBoIGlzIHNwbGl0LCBvbmx5IHZlcmlmeSB0aGUgdGlwIGZpbGUiKSksCgkJT1BUX0JPT0woMCwgInByb2dyZXNzIiwgJm9wdHMucHJvZ3Jlc3MsIE5fKCJmb3JjZSBwcm9ncmVzcyByZXBvcnRpbmciKSksCgkJT1BUX0VORCgpLAoJfTsKCgl0cmFjZTJfY21kX21vZGUoInZlcmlmeSIpOwoKCW9wdHMucHJvZ3Jlc3MgPSBpc2F0dHkoMik7CglhcmdjID0gcGFyc2Vfb3B0aW9ucyhhcmdjLCBhcmd2LCBOVUxMLAoJCQkgICAgIGJ1aWx0aW5fY29tbWl0X2dyYXBoX3ZlcmlmeV9vcHRpb25zLAoJCQkgICAgIGJ1aWx0aW5fY29tbWl0X2dyYXBoX3ZlcmlmeV91c2FnZSwgMCk7CgoJaWYgKCFvcHRzLm9ial9kaXIpCgkJb3B0cy5vYmpfZGlyID0gZ2V0X29iamVjdF9kaXJlY3RvcnkoKTsKCWlmIChvcHRzLnNoYWxsb3cpCgkJZmxhZ3MgfD0gQ09NTUlUX0dSQVBIX1ZFUklGWV9TSEFMTE9XOwoJaWYgKG9wdHMucHJvZ3Jlc3MpCgkJZmxhZ3MgfD0gQ09NTUlUX0dSQVBIX1dSSVRFX1BST0dSRVNTOwoKCW9kYiA9IGZpbmRfb2RiKHRoZV9yZXBvc2l0b3J5LCBvcHRzLm9ial9kaXIpOwoJZ3JhcGhfbmFtZSA9IGdldF9jb21taXRfZ3JhcGhfZmlsZW5hbWUob2RiKTsKCW9wZW5fb2sgPSBvcGVuX2NvbW1pdF9ncmFwaChncmFwaF9uYW1lLCAmZmQsICZzdCk7CglpZiAoIW9wZW5fb2sgJiYgZXJybm8gIT0gRU5PRU5UKQoJCWRpZV9lcnJubyhfKCJDb3VsZCBub3Qgb3BlbiBjb21taXQtZ3JhcGggJyVzJyIpLCBncmFwaF9uYW1lKTsKCglGUkVFX0FORF9OVUxMKGdyYXBoX25hbWUpOwoKCWlmIChvcGVuX29rKQoJCWdyYXBoID0gbG9hZF9jb21taXRfZ3JhcGhfb25lX2ZkX3N0KHRoZV9yZXBvc2l0b3J5LCBmZCwgJnN0LCBvZGIpOwoJZWxzZQoJCWdyYXBoID0gcmVhZF9jb21taXRfZ3JhcGhfb25lKHRoZV9yZXBvc2l0b3J5LCBvZGIpOwoKCS8qIFJldHVybiBmYWlsdXJlIGlmIG9wZW5fb2sgcHJlZGljdGVkIHN1Y2Nlc3MgKi8KCWlmICghZ3JhcGgpCgkJcmV0dXJuICEhb3Blbl9vazsKCglVTkxFQUsoZ3JhcGgpOwoJcmV0dXJuIHZlcmlmeV9jb21taXRfZ3JhcGgodGhlX3JlcG9zaXRvcnksIGdyYXBoLCBmbGFncyk7Cn0KCmV4dGVybiBpbnQgcmVhZF9yZXBsYWNlX3JlZnM7CnN0YXRpYyBzdHJ1Y3QgY29tbWl0X2dyYXBoX29wdHMgd3JpdGVfb3B0czsKCnN0YXRpYyBpbnQgd3JpdGVfb3B0aW9uX3BhcnNlX3NwbGl0KGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdCwgY29uc3QgY2hhciAqYXJnLAoJCQkJICAgIGludCB1bnNldCkKewoJZW51bSBjb21taXRfZ3JhcGhfc3BsaXRfZmxhZ3MgKmZsYWdzID0gb3B0LT52YWx1ZTsKCglCVUdfT05fT1BUX05FRyh1bnNldCk7CgoJb3B0cy5zcGxpdCA9IDE7CglpZiAoIWFyZykKCQlyZXR1cm4gMDsKCglpZiAoIXN0cmNtcChhcmcsICJuby1tZXJnZSIpKQoJCSpmbGFncyA9IENPTU1JVF9HUkFQSF9TUExJVF9NRVJHRV9QUk9ISUJJVEVEOwoJZWxzZSBpZiAoIXN0cmNtcChhcmcsICJyZXBsYWNlIikpCgkJKmZsYWdzID0gQ09NTUlUX0dSQVBIX1NQTElUX1JFUExBQ0U7CgllbHNlCgkJZGllKF8oInVucmVjb2duaXplZCAtLXNwbGl0IGFyZ3VtZW50LCAlcyIpLCBhcmcpOwoKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IHJlYWRfb25lX2NvbW1pdChzdHJ1Y3Qgb2lkc2V0ICpjb21taXRzLCBzdHJ1Y3QgcHJvZ3Jlc3MgKnByb2dyZXNzLAoJCQkgICBjb25zdCBjaGFyICpoYXNoKQp7CglzdHJ1Y3Qgb2JqZWN0ICpyZXN1bHQ7CglzdHJ1Y3Qgb2JqZWN0X2lkIG9pZDsKCWNvbnN0IGNoYXIgKmVuZDsKCglpZiAocGFyc2Vfb2lkX2hleChoYXNoLCAmb2lkLCAmZW5kKSkKCQlyZXR1cm4gZXJyb3IoXygidW5leHBlY3RlZCBub24taGV4IG9iamVjdCBJRDogJXMiKSwgaGFzaCk7CgoJcmVzdWx0ID0gZGVyZWZfdGFnKHRoZV9yZXBvc2l0b3J5LCBwYXJzZV9vYmplY3QodGhlX3JlcG9zaXRvcnksICZvaWQpLAoJCQkgICBOVUxMLCAwKTsKCWlmICghcmVzdWx0KQoJCXJldHVybiBlcnJvcihfKCJpbnZhbGlkIG9iamVjdDogJXMiKSwgaGFzaCk7CgllbHNlIGlmIChvYmplY3RfYXNfdHlwZShyZXN1bHQsIE9CSl9DT01NSVQsIDEpKQoJCW9pZHNldF9pbnNlcnQoY29tbWl0cywgJnJlc3VsdC0+b2lkKTsKCglkaXNwbGF5X3Byb2dyZXNzKHByb2dyZXNzLCBvaWRzZXRfc2l6ZShjb21taXRzKSk7CgoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgd3JpdGVfb3B0aW9uX21heF9uZXdfZmlsdGVycyhjb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHQsCgkJCQkJY29uc3QgY2hhciAqYXJnLAoJCQkJCWludCB1bnNldCkKewoJaW50ICp0byA9IG9wdC0+dmFsdWU7CglpZiAodW5zZXQpCgkJKnRvID0gLTE7CgllbHNlIHsKCQljb25zdCBjaGFyICpzOwoJCSp0byA9IHN0cnRvbChhcmcsIChjaGFyICoqKSZzLCAxMCk7CgkJaWYgKCpzKQoJCQlyZXR1cm4gZXJyb3IoXygiJXMgZXhwZWN0cyBhIG51bWVyaWNhbCB2YWx1ZSIpLAoJCQkJICAgICBvcHRuYW1lKG9wdCwgb3B0LT5mbGFncykpOwoJfQoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgZ2l0X2NvbW1pdF9ncmFwaF93cml0ZV9jb25maWcoY29uc3QgY2hhciAqdmFyLCBjb25zdCBjaGFyICp2YWx1ZSwKCQkJCQkgdm9pZCAqY2IpCnsKCWlmICghc3RyY21wKHZhciwgImNvbW1pdGdyYXBoLm1heG5ld2ZpbHRlcnMiKSkKCQl3cml0ZV9vcHRzLm1heF9uZXdfZmlsdGVycyA9IGdpdF9jb25maWdfaW50KHZhciwgdmFsdWUpOwoJLyoKCSAqIE5vIG5lZWQgdG8gZmFsbC1iYWNrIHRvICdnaXRfZGVmYXVsdF9jb25maWcnLCBzaW5jZSB0aGlzIHdhcyBhbHJlYWR5CgkgKiBjYWxsZWQgaW4gJ2NtZF9jb21taXRfZ3JhcGgoKScuCgkgKi8KCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGdyYXBoX3dyaXRlKGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndikKewoJc3RydWN0IHN0cmluZ19saXN0IHBhY2tfaW5kZXhlcyA9IFNUUklOR19MSVNUX0lOSVRfTk9EVVA7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoJc3RydWN0IG9pZHNldCBjb21taXRzID0gT0lEU0VUX0lOSVQ7CglzdHJ1Y3Qgb2JqZWN0X2RpcmVjdG9yeSAqb2RiID0gTlVMTDsKCWludCByZXN1bHQgPSAwOwoJZW51bSBjb21taXRfZ3JhcGhfd3JpdGVfZmxhZ3MgZmxhZ3MgPSAwOwoJc3RydWN0IHByb2dyZXNzICpwcm9ncmVzcyA9IE5VTEw7CgoJc3RhdGljIHN0cnVjdCBvcHRpb24gYnVpbHRpbl9jb21taXRfZ3JhcGhfd3JpdGVfb3B0aW9uc1tdID0gewoJCU9QVF9TVFJJTkcoMCwgIm9iamVjdC1kaXIiLCAmb3B0cy5vYmpfZGlyLAoJCQlOXygiZGlyIiksCgkJCU5fKCJ0aGUgb2JqZWN0IGRpcmVjdG9yeSB0byBzdG9yZSB0aGUgZ3JhcGgiKSksCgkJT1BUX0JPT0woMCwgInJlYWNoYWJsZSIsICZvcHRzLnJlYWNoYWJsZSwKCQkJTl8oInN0YXJ0IHdhbGsgYXQgYWxsIHJlZnMiKSksCgkJT1BUX0JPT0woMCwgInN0ZGluLXBhY2tzIiwgJm9wdHMuc3RkaW5fcGFja3MsCgkJCU5fKCJzY2FuIHBhY2staW5kZXhlcyBsaXN0ZWQgYnkgc3RkaW4gZm9yIGNvbW1pdHMiKSksCgkJT1BUX0JPT0woMCwgInN0ZGluLWNvbW1pdHMiLCAmb3B0cy5zdGRpbl9jb21taXRzLAoJCQlOXygic3RhcnQgd2FsayBhdCBjb21taXRzIGxpc3RlZCBieSBzdGRpbiIpKSwKCQlPUFRfQk9PTCgwLCAiYXBwZW5kIiwgJm9wdHMuYXBwZW5kLAoJCQlOXygiaW5jbHVkZSBhbGwgY29tbWl0cyBhbHJlYWR5IGluIHRoZSBjb21taXQtZ3JhcGggZmlsZSIpKSwKCQlPUFRfQk9PTCgwLCAiY2hhbmdlZC1wYXRocyIsICZvcHRzLmVuYWJsZV9jaGFuZ2VkX3BhdGhzLAoJCQlOXygiZW5hYmxlIGNvbXB1dGF0aW9uIGZvciBjaGFuZ2VkIHBhdGhzIikpLAoJCU9QVF9CT09MKDAsICJwcm9ncmVzcyIsICZvcHRzLnByb2dyZXNzLCBOXygiZm9yY2UgcHJvZ3Jlc3MgcmVwb3J0aW5nIikpLAoJCU9QVF9DQUxMQkFDS19GKDAsICJzcGxpdCIsICZ3cml0ZV9vcHRzLnNwbGl0X2ZsYWdzLCBOVUxMLAoJCQlOXygiYWxsb3cgd3JpdGluZyBhbiBpbmNyZW1lbnRhbCBjb21taXQtZ3JhcGggZmlsZSIpLAoJCQlQQVJTRV9PUFRfT1BUQVJHIHwgUEFSU0VfT1BUX05PTkVHLAoJCQl3cml0ZV9vcHRpb25fcGFyc2Vfc3BsaXQpLAoJCU9QVF9JTlRFR0VSKDAsICJtYXgtY29tbWl0cyIsICZ3cml0ZV9vcHRzLm1heF9jb21taXRzLAoJCQlOXygibWF4aW11bSBudW1iZXIgb2YgY29tbWl0cyBpbiBhIG5vbi1iYXNlIHNwbGl0IGNvbW1pdC1ncmFwaCIpKSwKCQlPUFRfSU5URUdFUigwLCAic2l6ZS1tdWx0aXBsZSIsICZ3cml0ZV9vcHRzLnNpemVfbXVsdGlwbGUsCgkJCU5fKCJtYXhpbXVtIHJhdGlvIGJldHdlZW4gdHdvIGxldmVscyBvZiBhIHNwbGl0IGNvbW1pdC1ncmFwaCIpKSwKCQlPUFRfRVhQSVJZX0RBVEUoMCwgImV4cGlyZS10aW1lIiwgJndyaXRlX29wdHMuZXhwaXJlX3RpbWUsCgkJCU5fKCJvbmx5IGV4cGlyZSBmaWxlcyBvbGRlciB0aGFuIGEgZ2l2ZW4gZGF0ZS10aW1lIikpLAoJCU9QVF9DQUxMQkFDS19GKDAsICJtYXgtbmV3LWZpbHRlcnMiLCAmd3JpdGVfb3B0cy5tYXhfbmV3X2ZpbHRlcnMsCgkJCU5VTEwsIE5fKCJtYXhpbXVtIG51bWJlciBvZiBjaGFuZ2VkLXBhdGggQmxvb20gZmlsdGVycyB0byBjb21wdXRlIiksCgkJCTAsIHdyaXRlX29wdGlvbl9tYXhfbmV3X2ZpbHRlcnMpLAoJCU9QVF9FTkQoKSwKCX07CgoJb3B0cy5wcm9ncmVzcyA9IGlzYXR0eSgyKTsKCW9wdHMuZW5hYmxlX2NoYW5nZWRfcGF0aHMgPSAtMTsKCXdyaXRlX29wdHMuc2l6ZV9tdWx0aXBsZSA9IDI7Cgl3cml0ZV9vcHRzLm1heF9jb21taXRzID0gMDsKCXdyaXRlX29wdHMuZXhwaXJlX3RpbWUgPSAwOwoJd3JpdGVfb3B0cy5tYXhfbmV3X2ZpbHRlcnMgPSAtMTsKCgl0cmFjZTJfY21kX21vZGUoIndyaXRlIik7CgoJZ2l0X2NvbmZpZyhnaXRfY29tbWl0X2dyYXBoX3dyaXRlX2NvbmZpZywgJm9wdHMpOwoKCWFyZ2MgPSBwYXJzZV9vcHRpb25zKGFyZ2MsIGFyZ3YsIE5VTEwsCgkJCSAgICAgYnVpbHRpbl9jb21taXRfZ3JhcGhfd3JpdGVfb3B0aW9ucywKCQkJICAgICBidWlsdGluX2NvbW1pdF9ncmFwaF93cml0ZV91c2FnZSwgMCk7CgoJaWYgKG9wdHMucmVhY2hhYmxlICsgb3B0cy5zdGRpbl9wYWNrcyArIG9wdHMuc3RkaW5fY29tbWl0cyA+IDEpCgkJZGllKF8oInVzZSBhdCBtb3N0IG9uZSBvZiAtLXJlYWNoYWJsZSwgLS1zdGRpbi1jb21taXRzLCBvciAtLXN0ZGluLXBhY2tzIikpOwoJaWYgKCFvcHRzLm9ial9kaXIpCgkJb3B0cy5vYmpfZGlyID0gZ2V0X29iamVjdF9kaXJlY3RvcnkoKTsKCWlmIChvcHRzLmFwcGVuZCkKCQlmbGFncyB8PSBDT01NSVRfR1JBUEhfV1JJVEVfQVBQRU5EOwoJaWYgKG9wdHMuc3BsaXQpCgkJZmxhZ3MgfD0gQ09NTUlUX0dSQVBIX1dSSVRFX1NQTElUOwoJaWYgKG9wdHMucHJvZ3Jlc3MpCgkJZmxhZ3MgfD0gQ09NTUlUX0dSQVBIX1dSSVRFX1BST0dSRVNTOwoJaWYgKCFvcHRzLmVuYWJsZV9jaGFuZ2VkX3BhdGhzKQoJCWZsYWdzIHw9IENPTU1JVF9HUkFQSF9OT19XUklURV9CTE9PTV9GSUxURVJTOwoJaWYgKG9wdHMuZW5hYmxlX2NoYW5nZWRfcGF0aHMgPT0gMSB8fAoJICAgIGdpdF9lbnZfYm9vbChHSVRfVEVTVF9DT01NSVRfR1JBUEhfQ0hBTkdFRF9QQVRIUywgMCkpCgkJZmxhZ3MgfD0gQ09NTUlUX0dSQVBIX1dSSVRFX0JMT09NX0ZJTFRFUlM7CgoJcmVhZF9yZXBsYWNlX3JlZnMgPSAwOwoJb2RiID0gZmluZF9vZGIodGhlX3JlcG9zaXRvcnksIG9wdHMub2JqX2Rpcik7CgoJaWYgKG9wdHMucmVhY2hhYmxlKSB7CgkJaWYgKHdyaXRlX2NvbW1pdF9ncmFwaF9yZWFjaGFibGUob2RiLCBmbGFncywgJndyaXRlX29wdHMpKQoJCQlyZXR1cm4gMTsKCQlyZXR1cm4gMDsKCX0KCglpZiAob3B0cy5zdGRpbl9wYWNrcykgewoJCXdoaWxlIChzdHJidWZfZ2V0bGluZSgmYnVmLCBzdGRpbikgIT0gRU9GKQoJCQlzdHJpbmdfbGlzdF9hcHBlbmQoJnBhY2tfaW5kZXhlcywKCQkJCQkgICBzdHJidWZfZGV0YWNoKCZidWYsIE5VTEwpKTsKCX0gZWxzZSBpZiAob3B0cy5zdGRpbl9jb21taXRzKSB7CgkJb2lkc2V0X2luaXQoJmNvbW1pdHMsIDApOwoJCWlmIChvcHRzLnByb2dyZXNzKQoJCQlwcm9ncmVzcyA9IHN0YXJ0X2RlbGF5ZWRfcHJvZ3Jlc3MoCgkJCQlfKCJDb2xsZWN0aW5nIGNvbW1pdHMgZnJvbSBpbnB1dCIpLCAwKTsKCgkJd2hpbGUgKHN0cmJ1Zl9nZXRsaW5lKCZidWYsIHN0ZGluKSAhPSBFT0YpIHsKCQkJaWYgKHJlYWRfb25lX2NvbW1pdCgmY29tbWl0cywgcHJvZ3Jlc3MsIGJ1Zi5idWYpKSB7CgkJCQlyZXN1bHQgPSAxOwoJCQkJZ290byBjbGVhbnVwOwoJCQl9CgkJfQoKCQlzdG9wX3Byb2dyZXNzKCZwcm9ncmVzcyk7Cgl9CgoJaWYgKHdyaXRlX2NvbW1pdF9ncmFwaChvZGIsCgkJCSAgICAgICBvcHRzLnN0ZGluX3BhY2tzID8gJnBhY2tfaW5kZXhlcyA6IE5VTEwsCgkJCSAgICAgICBvcHRzLnN0ZGluX2NvbW1pdHMgPyAmY29tbWl0cyA6IE5VTEwsCgkJCSAgICAgICBmbGFncywKCQkJICAgICAgICZ3cml0ZV9vcHRzKSkKCQlyZXN1bHQgPSAxOwoKY2xlYW51cDoKCXN0cmluZ19saXN0X2NsZWFyKCZwYWNrX2luZGV4ZXMsIDApOwoJc3RyYnVmX3JlbGVhc2UoJmJ1Zik7CglyZXR1cm4gcmVzdWx0Owp9CgppbnQgY21kX2NvbW1pdF9ncmFwaChpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsIGNvbnN0IGNoYXIgKnByZWZpeCkKewoJc3RhdGljIHN0cnVjdCBvcHRpb24gYnVpbHRpbl9jb21taXRfZ3JhcGhfb3B0aW9uc1tdID0gewoJCU9QVF9TVFJJTkcoMCwgIm9iamVjdC1kaXIiLCAmb3B0cy5vYmpfZGlyLAoJCQlOXygiZGlyIiksCgkJCU5fKCJ0aGUgb2JqZWN0IGRpcmVjdG9yeSB0byBzdG9yZSB0aGUgZ3JhcGgiKSksCgkJT1BUX0VORCgpLAoJfTsKCglpZiAoYXJnYyA9PSAyICYmICFzdHJjbXAoYXJndlsxXSwgIi1oIikpCgkJdXNhZ2Vfd2l0aF9vcHRpb25zKGJ1aWx0aW5fY29tbWl0X2dyYXBoX3VzYWdlLAoJCQkJICAgYnVpbHRpbl9jb21taXRfZ3JhcGhfb3B0aW9ucyk7CgoJZ2l0X2NvbmZpZyhnaXRfZGVmYXVsdF9jb25maWcsIE5VTEwpOwoJYXJnYyA9IHBhcnNlX29wdGlvbnMoYXJnYywgYXJndiwgcHJlZml4LAoJCQkgICAgIGJ1aWx0aW5fY29tbWl0X2dyYXBoX29wdGlvbnMsCgkJCSAgICAgYnVpbHRpbl9jb21taXRfZ3JhcGhfdXNhZ2UsCgkJCSAgICAgUEFSU0VfT1BUX1NUT1BfQVRfTk9OX09QVElPTik7CgoJc2F2ZV9jb21taXRfYnVmZmVyID0gMDsKCglpZiAoYXJnYyA+IDApIHsKCQlpZiAoIXN0cmNtcChhcmd2WzBdLCAidmVyaWZ5IikpCgkJCXJldHVybiBncmFwaF92ZXJpZnkoYXJnYywgYXJndik7CgkJaWYgKCFzdHJjbXAoYXJndlswXSwgIndyaXRlIikpCgkJCXJldHVybiBncmFwaF93cml0ZShhcmdjLCBhcmd2KTsKCX0KCgl1c2FnZV93aXRoX29wdGlvbnMoYnVpbHRpbl9jb21taXRfZ3JhcGhfdXNhZ2UsCgkJCSAgIGJ1aWx0aW5fY29tbWl0X2dyYXBoX29wdGlvbnMpOwp9Cg==",
    "text": "#include \"builtin.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockfile.h\"\n#include \"parse-options.h\"\n#include \"repository.h\"\n#include \"commit-graph.h\"\n#include \"object-store.h\"\n#include \"progress.h\"\n#include \"tag.h\"\n\nstatic char const * const builtin_commit_graph_usage[] = {\n\tN_(\"git commit-graph verify [--object-dir <objdir>] [--shallow] [--[no-]progress]\"),\n\tN_(\"git commit-graph write [--object-dir <objdir>] [--append] \"\n\t   \"[--split[=<strategy>]] [--reachable|--stdin-packs|--stdin-commits] \"\n\t   \"[--changed-paths] [--[no-]max-new-filters <n>] [--[no-]progress] \"\n\t   \"<split options>\"),\n\tNULL\n};\n\nstatic const char * const builtin_commit_graph_verify_usage[] = {\n\tN_(\"git commit-graph verify [--object-dir <objdir>] [--shallow] [--[no-]progress]\"),\n\tNULL\n};\n\nstatic const char * const builtin_commit_graph_write_usage[] = {\n\tN_(\"git commit-graph write [--object-dir <objdir>] [--append] \"\n\t   \"[--split[=<strategy>]] [--reachable|--stdin-packs|--stdin-commits] \"\n\t   \"[--changed-paths] [--[no-]max-new-filters <n>] [--[no-]progress] \"\n\t   \"<split options>\"),\n\tNULL\n};\n\nstatic struct opts_commit_graph {\n\tconst char *obj_dir;\n\tint reachable;\n\tint stdin_packs;\n\tint stdin_commits;\n\tint append;\n\tint split;\n\tint shallow;\n\tint progress;\n\tint enable_changed_paths;\n} opts;\n\nstatic int graph_verify(int argc, const char **argv)\n{\n\tstruct commit_graph *graph = NULL;\n\tstruct object_directory *odb = NULL;\n\tchar *graph_name;\n\tint open_ok;\n\tint fd;\n\tstruct stat st;\n\tint flags = 0;\n\n\tstatic struct option builtin_commit_graph_verify_options[] = {\n\t\tOPT_STRING(0, \"object-dir\", &opts.obj_dir,\n\t\t\t   N_(\"dir\"),\n\t\t\t   N_(\"the object directory to store the graph\")),\n\t\tOPT_BOOL(0, \"shallow\", &opts.shallow,\n\t\t\t N_(\"if the commit-graph is split, only verify the tip file\")),\n\t\tOPT_BOOL(0, \"progress\", &opts.progress, N_(\"force progress reporting\")),\n\t\tOPT_END(),\n\t};\n\n\ttrace2_cmd_mode(\"verify\");\n\n\topts.progress = isatty(2);\n\targc = parse_options(argc, argv, NULL,\n\t\t\t     builtin_commit_graph_verify_options,\n\t\t\t     builtin_commit_graph_verify_usage, 0);\n\n\tif (!opts.obj_dir)\n\t\topts.obj_dir = get_object_directory();\n\tif (opts.shallow)\n\t\tflags |= COMMIT_GRAPH_VERIFY_SHALLOW;\n\tif (opts.progress)\n\t\tflags |= COMMIT_GRAPH_WRITE_PROGRESS;\n\n\todb = find_odb(the_repository, opts.obj_dir);\n\tgraph_name = get_commit_graph_filename(odb);\n\topen_ok = open_commit_graph(graph_name, &fd, &st);\n\tif (!open_ok && errno != ENOENT)\n\t\tdie_errno(_(\"Could not open commit-graph '%s'\"), graph_name);\n\n\tFREE_AND_NULL(graph_name);\n\n\tif (open_ok)\n\t\tgraph = load_commit_graph_one_fd_st(the_repository, fd, &st, odb);\n\telse\n\t\tgraph = read_commit_graph_one(the_repository, odb);\n\n\t/* Return failure if open_ok predicted success */\n\tif (!graph)\n\t\treturn !!open_ok;\n\n\tUNLEAK(graph);\n\treturn verify_commit_graph(the_repository, graph, flags);\n}\n\nextern int read_replace_refs;\nstatic struct commit_graph_opts write_opts;\n\nstatic int write_option_parse_split(const struct option *opt, const char *arg,\n\t\t\t\t    int unset)\n{\n\tenum commit_graph_split_flags *flags = opt->value;\n\n\tBUG_ON_OPT_NEG(unset);\n\n\topts.split = 1;\n\tif (!arg)\n\t\treturn 0;\n\n\tif (!strcmp(arg, \"no-merge\"))\n\t\t*flags = COMMIT_GRAPH_SPLIT_MERGE_PROHIBITED;\n\telse if (!strcmp(arg, \"replace\"))\n\t\t*flags = COMMIT_GRAPH_SPLIT_REPLACE;\n\telse\n\t\tdie(_(\"unrecognized --split argument, %s\"), arg);\n\n\treturn 0;\n}\n\nstatic int read_one_commit(struct oidset *commits, struct progress *progress,\n\t\t\t   const char *hash)\n{\n\tstruct object *result;\n\tstruct object_id oid;\n\tconst char *end;\n\n\tif (parse_oid_hex(hash, &oid, &end))\n\t\treturn error(_(\"unexpected non-hex object ID: %s\"), hash);\n\n\tresult = deref_tag(the_repository, parse_object(the_repository, &oid),\n\t\t\t   NULL, 0);\n\tif (!result)\n\t\treturn error(_(\"invalid object: %s\"), hash);\n\telse if (object_as_type(result, OBJ_COMMIT, 1))\n\t\toidset_insert(commits, &result->oid);\n\n\tdisplay_progress(progress, oidset_size(commits));\n\n\treturn 0;\n}\n\nstatic int write_option_max_new_filters(const struct option *opt,\n\t\t\t\t\tconst char *arg,\n\t\t\t\t\tint unset)\n{\n\tint *to = opt->value;\n\tif (unset)\n\t\t*to = -1;\n\telse {\n\t\tconst char *s;\n\t\t*to = strtol(arg, (char **)&s, 10);\n\t\tif (*s)\n\t\t\treturn error(_(\"%s expects a numerical value\"),\n\t\t\t\t     optname(opt, opt->flags));\n\t}\n\treturn 0;\n}\n\nstatic int git_commit_graph_write_config(const char *var, const char *value,\n\t\t\t\t\t void *cb)\n{\n\tif (!strcmp(var, \"commitgraph.maxnewfilters\"))\n\t\twrite_opts.max_new_filters = git_config_int(var, value);\n\t/*\n\t * No need to fall-back to 'git_default_config', since this was already\n\t * called in 'cmd_commit_graph()'.\n\t */\n\treturn 0;\n}\n\nstatic int graph_write(int argc, const char **argv)\n{\n\tstruct string_list pack_indexes = STRING_LIST_INIT_NODUP;\n\tstruct strbuf buf = STRBUF_INIT;\n\tstruct oidset commits = OIDSET_INIT;\n\tstruct object_directory *odb = NULL;\n\tint result = 0;\n\tenum commit_graph_write_flags flags = 0;\n\tstruct progress *progress = NULL;\n\n\tstatic struct option builtin_commit_graph_write_options[] = {\n\t\tOPT_STRING(0, \"object-dir\", &opts.obj_dir,\n\t\t\tN_(\"dir\"),\n\t\t\tN_(\"the object directory to store the graph\")),\n\t\tOPT_BOOL(0, \"reachable\", &opts.reachable,\n\t\t\tN_(\"start walk at all refs\")),\n\t\tOPT_BOOL(0, \"stdin-packs\", &opts.stdin_packs,\n\t\t\tN_(\"scan pack-indexes listed by stdin for commits\")),\n\t\tOPT_BOOL(0, \"stdin-commits\", &opts.stdin_commits,\n\t\t\tN_(\"start walk at commits listed by stdin\")),\n\t\tOPT_BOOL(0, \"append\", &opts.append,\n\t\t\tN_(\"include all commits already in the commit-graph file\")),\n\t\tOPT_BOOL(0, \"changed-paths\", &opts.enable_changed_paths,\n\t\t\tN_(\"enable computation for changed paths\")),\n\t\tOPT_BOOL(0, \"progress\", &opts.progress, N_(\"force progress reporting\")),\n\t\tOPT_CALLBACK_F(0, \"split\", &write_opts.split_flags, NULL,\n\t\t\tN_(\"allow writing an incremental commit-graph file\"),\n\t\t\tPARSE_OPT_OPTARG | PARSE_OPT_NONEG,\n\t\t\twrite_option_parse_split),\n\t\tOPT_INTEGER(0, \"max-commits\", &write_opts.max_commits,\n\t\t\tN_(\"maximum number of commits in a non-base split commit-graph\")),\n\t\tOPT_INTEGER(0, \"size-multiple\", &write_opts.size_multiple,\n\t\t\tN_(\"maximum ratio between two levels of a split commit-graph\")),\n\t\tOPT_EXPIRY_DATE(0, \"expire-time\", &write_opts.expire_time,\n\t\t\tN_(\"only expire files older than a given date-time\")),\n\t\tOPT_CALLBACK_F(0, \"max-new-filters\", &write_opts.max_new_filters,\n\t\t\tNULL, N_(\"maximum number of changed-path Bloom filters to compute\"),\n\t\t\t0, write_option_max_new_filters),\n\t\tOPT_END(),\n\t};\n\n\topts.progress = isatty(2);\n\topts.enable_changed_paths = -1;\n\twrite_opts.size_multiple = 2;\n\twrite_opts.max_commits = 0;\n\twrite_opts.expire_time = 0;\n\twrite_opts.max_new_filters = -1;\n\n\ttrace2_cmd_mode(\"write\");\n\n\tgit_config(git_commit_graph_write_config, &opts);\n\n\targc = parse_options(argc, argv, NULL,\n\t\t\t     builtin_commit_graph_write_options,\n\t\t\t     builtin_commit_graph_write_usage, 0);\n\n\tif (opts.reachable + opts.stdin_packs + opts.stdin_commits > 1)\n\t\tdie(_(\"use at most one of --reachable, --stdin-commits, or --stdin-packs\"));\n\tif (!opts.obj_dir)\n\t\topts.obj_dir = get_object_directory();\n\tif (opts.append)\n\t\tflags |= COMMIT_GRAPH_WRITE_APPEND;\n\tif (opts.split)\n\t\tflags |= COMMIT_GRAPH_WRITE_SPLIT;\n\tif (opts.progress)\n\t\tflags |= COMMIT_GRAPH_WRITE_PROGRESS;\n\tif (!opts.enable_changed_paths)\n\t\tflags |= COMMIT_GRAPH_NO_WRITE_BLOOM_FILTERS;\n\tif (opts.enable_changed_paths == 1 ||\n\t    git_env_bool(GIT_TEST_COMMIT_GRAPH_CHANGED_PATHS, 0))\n\t\tflags |= COMMIT_GRAPH_WRITE_BLOOM_FILTERS;\n\n\tread_replace_refs = 0;\n\todb = find_odb(the_repository, opts.obj_dir);\n\n\tif (opts.reachable) {\n\t\tif (write_commit_graph_reachable(odb, flags, &write_opts))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\tif (opts.stdin_packs) {\n\t\twhile (strbuf_getline(&buf, stdin) != EOF)\n\t\t\tstring_list_append(&pack_indexes,\n\t\t\t\t\t   strbuf_detach(&buf, NULL));\n\t} else if (opts.stdin_commits) {\n\t\toidset_init(&commits, 0);\n\t\tif (opts.progress)\n\t\t\tprogress = start_delayed_progress(\n\t\t\t\t_(\"Collecting commits from input\"), 0);\n\n\t\twhile (strbuf_getline(&buf, stdin) != EOF) {\n\t\t\tif (read_one_commit(&commits, progress, buf.buf)) {\n\t\t\t\tresult = 1;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\n\t\tstop_progress(&progress);\n\t}\n\n\tif (write_commit_graph(odb,\n\t\t\t       opts.stdin_packs ? &pack_indexes : NULL,\n\t\t\t       opts.stdin_commits ? &commits : NULL,\n\t\t\t       flags,\n\t\t\t       &write_opts))\n\t\tresult = 1;\n\ncleanup:\n\tstring_list_clear(&pack_indexes, 0);\n\tstrbuf_release(&buf);\n\treturn result;\n}\n\nint cmd_commit_graph(int argc, const char **argv, const char *prefix)\n{\n\tstatic struct option builtin_commit_graph_options[] = {\n\t\tOPT_STRING(0, \"object-dir\", &opts.obj_dir,\n\t\t\tN_(\"dir\"),\n\t\t\tN_(\"the object directory to store the graph\")),\n\t\tOPT_END(),\n\t};\n\n\tif (argc == 2 && !strcmp(argv[1], \"-h\"))\n\t\tusage_with_options(builtin_commit_graph_usage,\n\t\t\t\t   builtin_commit_graph_options);\n\n\tgit_config(git_default_config, NULL);\n\targc = parse_options(argc, argv, prefix,\n\t\t\t     builtin_commit_graph_options,\n\t\t\t     builtin_commit_graph_usage,\n\t\t\t     PARSE_OPT_STOP_AT_NON_OPTION);\n\n\tsave_commit_buffer = 0;\n\n\tif (argc > 0) {\n\t\tif (!strcmp(argv[0], \"verify\"))\n\t\t\treturn graph_verify(argc, argv);\n\t\tif (!strcmp(argv[0], \"write\"))\n\t\t\treturn graph_write(argc, argv);\n\t}\n\n\tusage_with_options(builtin_commit_graph_usage,\n\t\t\t   builtin_commit_graph_options);\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "003eaaac5cfebc448dca184dde6183740237fdf2",
  "sha1_ok": true,
  "size": 9190
}
