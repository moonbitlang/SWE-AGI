{
  "content": {
    "base64": "I2lmbmRlZiBSRUZTX1JFRlNfSU5URVJOQUxfSAojZGVmaW5lIFJFRlNfUkVGU19JTlRFUk5BTF9ICgovKgogKiBEYXRhIHN0cnVjdHVyZXMgYW5kIGZ1bmN0aW9ucyBmb3IgdGhlIGludGVybmFsIHVzZSBvZiB0aGUgcmVmcwogKiBtb2R1bGUuIENvZGUgb3V0c2lkZSBvZiB0aGUgcmVmcyBtb2R1bGUgc2hvdWxkIHVzZSBvbmx5IHRoZSBwdWJsaWMKICogZnVuY3Rpb25zIGRlZmluZWQgaW4gInJlZnMuaCIsIGFuZCBzaG91bGQgKm5vdCogaW5jbHVkZSB0aGlzIGZpbGUuCiAqLwoKLyoKICogRmxhZyBwYXNzZWQgdG8gbG9ja19yZWZfc2hhMV9iYXNpYygpIHRlbGxpbmcgaXQgdG8gdG9sZXJhdGUgYnJva2VuCiAqIHJlZnMgKGkuZS4sIGJlY2F1c2UgdGhlIHJlZmVyZW5jZSBpcyBhYm91dCB0byBiZSBkZWxldGVkIGFueXdheSkuCiAqLwojZGVmaW5lIFJFRl9ERUxFVElORwkweDAyCgovKgogKiBVc2VkIGFzIGEgZmxhZyBpbiByZWZfdXBkYXRlOjpmbGFncyB3aGVuIGEgbG9vc2UgcmVmIGlzIGJlaW5nCiAqIHBydW5lZC4gVGhpcyBmbGFnIG11c3Qgb25seSBiZSB1c2VkIHdoZW4gUkVGX05PREVSRUYgaXMgc2V0LgogKi8KI2RlZmluZSBSRUZfSVNQUlVOSU5HCTB4MDQKCi8qCiAqIFVzZWQgYXMgYSBmbGFnIGluIHJlZl91cGRhdGU6OmZsYWdzIHdoZW4gdGhlIHJlZmVyZW5jZSBzaG91bGQgYmUKICogdXBkYXRlZCB0byBuZXdfc2hhMS4KICovCiNkZWZpbmUgUkVGX0hBVkVfTkVXCTB4MDgKCi8qCiAqIFVzZWQgYXMgYSBmbGFnIGluIHJlZl91cGRhdGU6OmZsYWdzIHdoZW4gb2xkX3NoYTEgc2hvdWxkIGJlCiAqIGNoZWNrZWQuCiAqLwojZGVmaW5lIFJFRl9IQVZFX09MRAkweDEwCgovKgogKiBVc2VkIGFzIGEgZmxhZyBpbiByZWZfdXBkYXRlOjpmbGFncyB3aGVuIHRoZSBsb2NrZmlsZSBuZWVkcyB0byBiZQogKiBjb21taXR0ZWQuCiAqLwojZGVmaW5lIFJFRl9ORUVEU19DT01NSVQgMHgyMAoKLyoKICogMHg0MCBpcyBSRUZfRk9SQ0VfQ1JFQVRFX1JFRkxPRywgc28gc2tpcCBpdCBpZiB5b3UncmUgYWRkaW5nIGEKICogdmFsdWUgdG8gcmVmX3VwZGF0ZTo6ZmxhZ3MKICovCgovKgogKiBVc2VkIGFzIGEgZmxhZyBpbiByZWZfdXBkYXRlOjpmbGFncyB3aGVuIHdlIHdhbnQgdG8gbG9nIGEgcmVmCiAqIHVwZGF0ZSBidXQgbm90IGFjdHVhbGx5IHBlcmZvcm0gaXQuICBUaGlzIGlzIHVzZWQgd2hlbiBhIHN5bWJvbGljCiAqIHJlZiB1cGRhdGUgaXMgc3BsaXQgdXAuCiAqLwojZGVmaW5lIFJFRl9MT0dfT05MWSAweDgwCgovKgogKiBJbnRlcm5hbCBmbGFnLCBtZWFuaW5nIHRoYXQgdGhlIGNvbnRhaW5pbmcgcmVmX3VwZGF0ZSB3YXMgdmlhIGFuCiAqIHVwZGF0ZSB0byBIRUFELgogKi8KI2RlZmluZSBSRUZfVVBEQVRFX1ZJQV9IRUFEIDB4MTAwCgovKgogKiBSZXR1cm4gdHJ1ZSBpZmYgcmVmbmFtZSBpcyBtaW5pbWFsbHkgc2FmZS4gIlNhZmUiIGhlcmUgbWVhbnMgdGhhdAogKiBkZWxldGluZyBhIGxvb3NlIHJlZmVyZW5jZSBieSB0aGlzIG5hbWUgd2lsbCBub3QgZG8gYW55IGRhbWFnZSwgZm9yCiAqIGV4YW1wbGUgYnkgY2F1c2luZyBhIGZpbGUgdGhhdCBpcyBub3QgYSByZWZlcmVuY2UgdG8gYmUgZGVsZXRlZC4KICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBjaGVjayB0aGF0IHRoZSByZWZlcmVuY2UgbmFtZSBpcyBsZWdhbDsgZm9yCiAqIHRoYXQsIHVzZSBjaGVja19yZWZuYW1lX2Zvcm1hdCgpLgogKgogKiBXZSBjb25zaWRlciBhIHJlZm5hbWUgdGhhdCBzdGFydHMgd2l0aCAicmVmcy8iIHRvIGJlIHNhZmUgYXMgbG9uZwogKiBhcyBhbnkgIi4uIiBjb21wb25lbnRzIHRoYXQgaXQgbWlnaHQgY29udGFpbiBkbyBub3QgZXNjYXBlICJyZWZzLyIuCiAqIE5hbWVzIHRoYXQgZG8gbm90IHN0YXJ0IHdpdGggInJlZnMvIiBhcmUgY29uc2lkZXJlZCBzYWZlIGlmZiB0aGV5CiAqIGNvbnNpc3QgZW50aXJlbHkgb2YgdXBwZXIgY2FzZSBjaGFyYWN0ZXJzIGFuZCAnXycgKGxpa2UgIkhFQUQiIGFuZAogKiAiTUVSR0VfSEVBRCIgYnV0IG5vdCAiY29uZmlnIiBvciAiRk9PL0JBUiIpLgogKi8KaW50IHJlZm5hbWVfaXNfc2FmZShjb25zdCBjaGFyICpyZWZuYW1lKTsKCmVudW0gcGVlbF9zdGF0dXMgewoJLyogb2JqZWN0IHdhcyBwZWVsZWQgc3VjY2Vzc2Z1bGx5OiAqLwoJUEVFTF9QRUVMRUQgPSAwLAoKCS8qCgkgKiBvYmplY3QgY2Fubm90IGJlIHBlZWxlZCBiZWNhdXNlIHRoZSBuYW1lZCBvYmplY3QgKG9yIGFuCgkgKiBvYmplY3QgcmVmZXJyZWQgdG8gYnkgYSB0YWcgaW4gdGhlIHBlZWwgY2hhaW4pLCBkb2VzIG5vdAoJICogZXhpc3QuCgkgKi8KCVBFRUxfSU5WQUxJRCA9IC0xLAoKCS8qIG9iamVjdCBjYW5ub3QgYmUgcGVlbGVkIGJlY2F1c2UgaXQgaXMgbm90IGEgdGFnOiAqLwoJUEVFTF9OT05fVEFHID0gLTIsCgoJLyogcmVmX2VudHJ5IGNvbnRhaW5zIG5vIHBlZWxlZCB2YWx1ZSBiZWNhdXNlIGl0IGlzIGEgc3ltcmVmOiAqLwoJUEVFTF9JU19TWU1SRUYgPSAtMywKCgkvKgoJICogcmVmX2VudHJ5IGNhbm5vdCBiZSBwZWVsZWQgYmVjYXVzZSBpdCBpcyBicm9rZW4gKGkuZS4sIHRoZQoJICogc3ltYm9saWMgcmVmZXJlbmNlIGNhbm5vdCBldmVuIGJlIHJlc29sdmVkIHRvIGFuIG9iamVjdAoJICogbmFtZSk6CgkgKi8KCVBFRUxfQlJPS0VOID0gLTQKfTsKCi8qCiAqIFBlZWwgdGhlIG5hbWVkIG9iamVjdDsgaS5lLiwgaWYgdGhlIG9iamVjdCBpcyBhIHRhZywgcmVzb2x2ZSB0aGUKICogdGFnIHJlY3Vyc2l2ZWx5IHVudGlsIGEgbm9uLXRhZyBpcyBmb3VuZC4gIElmIHN1Y2Nlc3NmdWwsIHN0b3JlIHRoZQogKiByZXN1bHQgdG8gc2hhMSBhbmQgcmV0dXJuIFBFRUxfUEVFTEVELiAgSWYgdGhlIG9iamVjdCBpcyBub3QgYSB0YWcKICogb3IgaXMgbm90IHZhbGlkLCByZXR1cm4gUEVFTF9OT05fVEFHIG9yIFBFRUxfSU5WQUxJRCwgcmVzcGVjdGl2ZWx5LAogKiBhbmQgbGVhdmUgc2hhMSB1bmNoYW5nZWQuCiAqLwplbnVtIHBlZWxfc3RhdHVzIHBlZWxfb2JqZWN0KGNvbnN0IHVuc2lnbmVkIGNoYXIgKm5hbWUsIHVuc2lnbmVkIGNoYXIgKnNoYTEpOwoKLyoKICogUmV0dXJuIDAgaWYgYSByZWZlcmVuY2UgbmFtZWQgcmVmbmFtZSBjb3VsZCBiZSBjcmVhdGVkIHdpdGhvdXQKICogY29uZmxpY3Rpbmcgd2l0aCB0aGUgbmFtZSBvZiBhbiBleGlzdGluZyByZWZlcmVuY2UuIE90aGVyd2lzZSwKICogcmV0dXJuIGEgbmVnYXRpdmUgdmFsdWUgYW5kIHdyaXRlIGFuIGV4cGxhbmF0aW9uIHRvIGVyci4gSWYgZXh0cmFzCiAqIGlzIG5vbi1OVUxMLCBpdCBpcyBhIGxpc3Qgb2YgYWRkaXRpb25hbCByZWZuYW1lcyB3aXRoIHdoaWNoIHJlZm5hbWUKICogaXMgbm90IGFsbG93ZWQgdG8gY29uZmxpY3QuIElmIHNraXAgaXMgbm9uLU5VTEwsIGlnbm9yZSBwb3RlbnRpYWwKICogY29uZmxpY3RzIHdpdGggcmVmcyBpbiBza2lwIChlLmcuLCBiZWNhdXNlIHRoZXkgYXJlIHNjaGVkdWxlZCBmb3IKICogZGVsZXRpb24gaW4gdGhlIHNhbWUgb3BlcmF0aW9uKS4gQmVoYXZpb3IgaXMgdW5kZWZpbmVkIGlmIHRoZSBzYW1lCiAqIG5hbWUgaXMgbGlzdGVkIGluIGJvdGggZXh0cmFzIGFuZCBza2lwLgogKgogKiBUd28gcmVmZXJlbmNlIG5hbWVzIGNvbmZsaWN0IGlmIG9uZSBvZiB0aGVtIGV4YWN0bHkgbWF0Y2hlcyB0aGUKICogbGVhZGluZyBjb21wb25lbnRzIG9mIHRoZSBvdGhlcjsgZS5nLiwgImZvby9iYXIiIGNvbmZsaWN0cyB3aXRoCiAqIGJvdGggImZvbyIgYW5kIHdpdGggImZvby9iYXIvYmF6IiBidXQgbm90IHdpdGggImZvby9iYXIiIG9yCiAqICJmb28vYmFyYmFkb3MiLgogKgogKiBleHRyYXMgYW5kIHNraXAgbXVzdCBiZSBzb3J0ZWQuCiAqLwppbnQgdmVyaWZ5X3JlZm5hbWVfYXZhaWxhYmxlKGNvbnN0IGNoYXIgKm5ld25hbWUsCgkJCSAgICAgY29uc3Qgc3RydWN0IHN0cmluZ19saXN0ICpleHRyYXMsCgkJCSAgICAgY29uc3Qgc3RydWN0IHN0cmluZ19saXN0ICpza2lwLAoJCQkgICAgIHN0cnVjdCBzdHJidWYgKmVycik7CgovKgogKiBDb3B5IHRoZSByZWZsb2cgbWVzc2FnZSBtc2cgdG8gYnVmLCB3aGljaCBoYXMgYmVlbiBhbGxvY2F0ZWQgc3VmZmljaWVudGx5CiAqIGxhcmdlLCB3aGlsZSBjbGVhbmluZyB1cCB0aGUgd2hpdGVzcGFjZXMuICBFc3BlY2lhbGx5LCBjb252ZXJ0IExGIHRvIHNwYWNlLAogKiBiZWNhdXNlIHJlZmxvZyBmaWxlIGlzIG9uZSBsaW5lIHBlciBlbnRyeS4KICovCmludCBjb3B5X3JlZmxvZ19tc2coY2hhciAqYnVmLCBjb25zdCBjaGFyICptc2cpOwoKaW50IHNob3VsZF9hdXRvY3JlYXRlX3JlZmxvZyhjb25zdCBjaGFyICpyZWZuYW1lKTsKCi8qKgogKiBJbmZvcm1hdGlvbiBuZWVkZWQgZm9yIGEgc2luZ2xlIHJlZiB1cGRhdGUuIFNldCBuZXdfc2hhMSB0byB0aGUgbmV3CiAqIHZhbHVlIG9yIHRvIG51bGxfc2hhMSB0byBkZWxldGUgdGhlIHJlZi4gVG8gY2hlY2sgdGhlIG9sZCB2YWx1ZQogKiB3aGlsZSB0aGUgcmVmIGlzIGxvY2tlZCwgc2V0IChmbGFncyAmIFJFRl9IQVZFX09MRCkgYW5kIHNldAogKiBvbGRfc2hhMSB0byB0aGUgb2xkIHZhbHVlLCBvciB0byBudWxsX3NoYTEgdG8gZW5zdXJlIHRoZSByZWYgZG9lcwogKiBub3QgZXhpc3QgYmVmb3JlIHVwZGF0ZS4KICovCnN0cnVjdCByZWZfdXBkYXRlIHsKCgkvKgoJICogSWYgKGZsYWdzICYgUkVGX0hBVkVfTkVXKSwgc2V0IHRoZSByZWZlcmVuY2UgdG8gdGhpcyB2YWx1ZToKCSAqLwoJdW5zaWduZWQgY2hhciBuZXdfc2hhMVsyMF07CgoJLyoKCSAqIElmIChmbGFncyAmIFJFRl9IQVZFX09MRCksIGNoZWNrIHRoYXQgdGhlIHJlZmVyZW5jZQoJICogcHJldmlvdXNseSBoYWQgdGhpcyB2YWx1ZToKCSAqLwoJdW5zaWduZWQgY2hhciBvbGRfc2hhMVsyMF07CgoJLyoKCSAqIE9uZSBvciBtb3JlIG9mIFJFRl9IQVZFX05FVywgUkVGX0hBVkVfT0xELCBSRUZfTk9ERVJFRiwKCSAqIFJFRl9ERUxFVElORywgUkVGX0lTUFJVTklORywgUkVGX0xPR19PTkxZLCBhbmQKCSAqIFJFRl9VUERBVEVfVklBX0hFQUQ6CgkgKi8KCXVuc2lnbmVkIGludCBmbGFnczsKCgl2b2lkICpiYWNrZW5kX2RhdGE7Cgl1bnNpZ25lZCBpbnQgdHlwZTsKCWNoYXIgKm1zZzsKCgkvKgoJICogSWYgdGhpcyByZWZfdXBkYXRlIHdhcyBzcGxpdCBvZmYgb2YgYSBzeW1yZWYgdXBkYXRlIHZpYQoJICogc3BsaXRfc3ltcmVmX3VwZGF0ZSgpLCB0aGVuIHRoaXMgbWVtYmVyIHBvaW50cyBhdCB0aGF0CgkgKiB1cGRhdGUuIFRoaXMgaXMgdXNlZCBmb3IgdHdvIHB1cnBvc2VzOgoJICogMS4gV2hlbiByZXBvcnRpbmcgZXJyb3JzLCB3ZSByZXBvcnQgdGhlIHJlZm5hbWUgdW5kZXIgd2hpY2gKCSAqICAgIHRoZSB1cGRhdGUgd2FzIG9yaWdpbmFsbHkgcmVxdWVzdGVkLgoJICogMi4gV2hlbiB3ZSByZWFkIHRoZSBvbGQgdmFsdWUgb2YgdGhpcyByZWZlcmVuY2UsIHdlCgkgKiAgICBwcm9wYWdhdGUgaXQgYmFjayB0byBpdHMgcGFyZW50IHVwZGF0ZSBmb3IgcmVjb3JkaW5nIGluCgkgKiAgICB0aGUgbGF0dGVyJ3MgcmVmbG9nLgoJICovCglzdHJ1Y3QgcmVmX3VwZGF0ZSAqcGFyZW50X3VwZGF0ZTsKCgljb25zdCBjaGFyIHJlZm5hbWVbRkxFWF9BUlJBWV07Cn07CgovKgogKiBBZGQgYSByZWZfdXBkYXRlIHdpdGggdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzIHRvIHRyYW5zYWN0aW9uLCBhbmQKICogcmV0dXJuIGEgcG9pbnRlciB0byB0aGUgbmV3IG9iamVjdC4gVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCB2ZXJpZnkKICogdGhhdCByZWZuYW1lIGlzIHdlbGwtZm9ybWVkLiBuZXdfc2hhMSBhbmQgb2xkX3NoYTEgYXJlIG9ubHkKICogZGVyZWZlcmVuY2VkIGlmIHRoZSBSRUZfSEFWRV9ORVcgYW5kIFJFRl9IQVZFX09MRCBiaXRzLAogKiByZXNwZWN0aXZlbHksIGFyZSBzZXQgaW4gZmxhZ3MuCiAqLwpzdHJ1Y3QgcmVmX3VwZGF0ZSAqcmVmX3RyYW5zYWN0aW9uX2FkZF91cGRhdGUoCgkJc3RydWN0IHJlZl90cmFuc2FjdGlvbiAqdHJhbnNhY3Rpb24sCgkJY29uc3QgY2hhciAqcmVmbmFtZSwgdW5zaWduZWQgaW50IGZsYWdzLAoJCWNvbnN0IHVuc2lnbmVkIGNoYXIgKm5ld19zaGExLAoJCWNvbnN0IHVuc2lnbmVkIGNoYXIgKm9sZF9zaGExLAoJCWNvbnN0IGNoYXIgKm1zZyk7CgovKgogKiBUcmFuc2FjdGlvbiBzdGF0ZXMuCiAqIE9QRU46ICAgVGhlIHRyYW5zYWN0aW9uIGlzIGluIGEgdmFsaWQgc3RhdGUgYW5kIGNhbiBhY2NlcHQgbmV3IHVwZGF0ZXMuCiAqICAgICAgICAgQW4gT1BFTiB0cmFuc2FjdGlvbiBjYW4gYmUgY29tbWl0dGVkLgogKiBDTE9TRUQ6IEEgY2xvc2VkIHRyYW5zYWN0aW9uIGlzIG5vIGxvbmdlciBhY3RpdmUgYW5kIG5vIG90aGVyIG9wZXJhdGlvbnMKICogICAgICAgICB0aGFuIGZyZWUgY2FuIGJlIHVzZWQgb24gaXQgaW4gdGhpcyBzdGF0ZS4KICogICAgICAgICBBIHRyYW5zYWN0aW9uIGNhbiBlaXRoZXIgYmVjb21lIGNsb3NlZCBieSBzdWNjZXNzZnVsbHkgY29tbWl0dGluZwogKiAgICAgICAgIGFuIGFjdGl2ZSB0cmFuc2FjdGlvbiBvciBpZiB0aGVyZSBpcyBhIGZhaWx1cmUgd2hpbGUgYnVpbGRpbmcKICogICAgICAgICB0aGUgdHJhbnNhY3Rpb24gdGh1cyByZW5kZXJpbmcgaXQgZmFpbGVkL2luYWN0aXZlLgogKi8KZW51bSByZWZfdHJhbnNhY3Rpb25fc3RhdGUgewoJUkVGX1RSQU5TQUNUSU9OX09QRU4gICA9IDAsCglSRUZfVFJBTlNBQ1RJT05fQ0xPU0VEID0gMQp9OwoKLyoKICogRGF0YSBzdHJ1Y3R1cmUgZm9yIGhvbGRpbmcgYSByZWZlcmVuY2UgdHJhbnNhY3Rpb24sIHdoaWNoIGNhbgogKiBjb25zaXN0IG9mIGNoZWNrcyBhbmQgdXBkYXRlcyB0byBtdWx0aXBsZSByZWZlcmVuY2VzLCBjYXJyaWVkIG91dAogKiBhcyBhdG9taWNhbGx5IGFzIHBvc3NpYmxlLiAgVGhpcyBzdHJ1Y3R1cmUgaXMgb3BhcXVlIHRvIGNhbGxlcnMuCiAqLwpzdHJ1Y3QgcmVmX3RyYW5zYWN0aW9uIHsKCXN0cnVjdCByZWZfdXBkYXRlICoqdXBkYXRlczsKCXNpemVfdCBhbGxvYzsKCXNpemVfdCBucjsKCWVudW0gcmVmX3RyYW5zYWN0aW9uX3N0YXRlIHN0YXRlOwp9OwoKaW50IGZpbGVzX2xvZ19yZWZfd3JpdGUoY29uc3QgY2hhciAqcmVmbmFtZSwgY29uc3QgdW5zaWduZWQgY2hhciAqb2xkX3NoYTEsCgkJCWNvbnN0IHVuc2lnbmVkIGNoYXIgKm5ld19zaGExLCBjb25zdCBjaGFyICptc2csCgkJCWludCBmbGFncywgc3RydWN0IHN0cmJ1ZiAqZXJyKTsKCi8qCiAqIENoZWNrIGZvciBlbnRyaWVzIGluIGV4dHJhcyB0aGF0IGFyZSB3aXRoaW4gdGhlIHNwZWNpZmllZAogKiBkaXJlY3RvcnksIHdoZXJlIGRpcm5hbWUgaXMgYSByZWZlcmVuY2UgZGlyZWN0b3J5IG5hbWUgaW5jbHVkaW5nCiAqIHRoZSB0cmFpbGluZyBzbGFzaCAoZS5nLiwgInJlZnMvaGVhZHMvZm9vLyIpLiBJZ25vcmUgYW55CiAqIGNvbmZsaWN0aW5nIHJlZmVyZW5jZXMgdGhhdCBhcmUgZm91bmQgaW4gc2tpcC4gSWYgdGhlcmUgaXMgYQogKiBjb25mbGljdGluZyByZWZlcmVuY2UsIHJldHVybiBpdHMgbmFtZS4KICoKICogZXh0cmFzIGFuZCBza2lwIG11c3QgYmUgc29ydGVkIGxpc3RzIG9mIHJlZmVyZW5jZSBuYW1lcy4gRWl0aGVyIG9uZQogKiBjYW4gYmUgTlVMTCwgc2lnbmlmeWluZyB0aGUgZW1wdHkgbGlzdC4KICovCmNvbnN0IGNoYXIgKmZpbmRfZGVzY2VuZGFudF9yZWYoY29uc3QgY2hhciAqZGlybmFtZSwKCQkJCWNvbnN0IHN0cnVjdCBzdHJpbmdfbGlzdCAqZXh0cmFzLAoJCQkJY29uc3Qgc3RydWN0IHN0cmluZ19saXN0ICpza2lwKTsKCi8qCiAqIENoZWNrIHdoZXRoZXIgYW4gYXR0ZW1wdCB0byByZW5hbWUgb2xkX3JlZm5hbWUgdG8gbmV3X3JlZm5hbWUgd291bGQKICogY2F1c2UgYSBEL0YgY29uZmxpY3Qgd2l0aCBhbnkgZXhpc3RpbmcgcmVmZXJlbmNlIChvdGhlciB0aGFuCiAqIHBvc3NpYmx5IG9sZF9yZWZuYW1lKS4gSWYgdGhlcmUgd291bGQgYmUgYSBjb25mbGljdCwgZW1pdCBhbiBlcnJvcgogKiBtZXNzYWdlIGFuZCByZXR1cm4gZmFsc2U7IG90aGVyd2lzZSwgcmV0dXJuIHRydWUuCiAqCiAqIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIGlzIG5vdCBzYWZlIGFnYWluc3QgYWxsIHJhY2VzIHdpdGggb3RoZXIKICogcHJvY2Vzc2VzICh0aG91Z2ggcmVuYW1lX3JlZigpIGNhdGNoZXMgc29tZSByYWNlcyB0aGF0IG1pZ2h0IGdldCBieQogKiB0aGlzIGNoZWNrKS4KICovCmludCByZW5hbWVfcmVmX2F2YWlsYWJsZShjb25zdCBjaGFyICpvbGRfcmVmbmFtZSwgY29uc3QgY2hhciAqbmV3X3JlZm5hbWUpOwoKLyogV2UgYWxsb3cgInJlY3Vyc2l2ZSIgc3ltYm9saWMgcmVmcy4gT25seSB3aXRoaW4gcmVhc29uLCB0aG91Z2ggKi8KI2RlZmluZSBTWU1SRUZfTUFYREVQVEggNQoKLyogSW5jbHVkZSBicm9rZW4gcmVmZXJlbmNlcyBpbiBhIGRvX2Zvcl9lYWNoX3JlZiooKSBpdGVyYXRpb246ICovCiNkZWZpbmUgRE9fRk9SX0VBQ0hfSU5DTFVERV9CUk9LRU4gMHgwMQoKLyoKICogUmVmZXJlbmNlIGl0ZXJhdG9ycwogKgogKiBBIHJlZmVyZW5jZSBpdGVyYXRvciBlbmNhcHN1bGF0ZXMgdGhlIHN0YXRlIG9mIGFuIGluLXByb2dyZXNzCiAqIGl0ZXJhdGlvbiBvdmVyIHJlZmVyZW5jZXMuIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBgc3RydWN0CiAqIHJlZl9pdGVyYXRvcmAgdmlhIG9uZSBvZiB0aGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlLgogKgogKiBBIGZyZXNobHktY3JlYXRlZCByZWZfaXRlcmF0b3IgZG9lc24ndCB5ZXQgcG9pbnQgYXQgYSByZWZlcmVuY2UuIFRvCiAqIGFkdmFuY2UgdGhlIGl0ZXJhdG9yLCBjYWxsIHJlZl9pdGVyYXRvcl9hZHZhbmNlKCkuIElmIHN1Y2Nlc3NmdWwsCiAqIHRoaXMgc2V0cyB0aGUgaXRlcmF0b3IncyByZWZuYW1lLCBvaWQsIGFuZCBmbGFncyBmaWVsZHMgdG8gZGVzY3JpYmUKICogdGhlIG5leHQgcmVmZXJlbmNlIGFuZCByZXR1cm5zIElURVJfT0suIFRoZSBkYXRhIHBvaW50ZWQgYXQgYnkKICogcmVmbmFtZSBhbmQgb2lkIGJlbG9uZyB0byB0aGUgaXRlcmF0b3I7IGlmIHlvdSB3YW50IHRvIHJldGFpbiB0aGVtCiAqIGFmdGVyIGNhbGxpbmcgcmVmX2l0ZXJhdG9yX2FkdmFuY2UoKSBhZ2FpbiBvciBjYWxsaW5nCiAqIHJlZl9pdGVyYXRvcl9hYm9ydCgpLCB5b3UgbXVzdCBtYWtlIGEgY29weS4gV2hlbiB0aGUgaXRlcmF0aW9uIGhhcwogKiBiZWVuIGV4aGF1c3RlZCwgcmVmX2l0ZXJhdG9yX2FkdmFuY2UoKSByZWxlYXNlcyBhbnkgcmVzb3VyY2VzCiAqIGFzc29jYXRlZCB3aXRoIHRoZSBpdGVyYXRpb24sIGZyZWVzIHRoZSByZWZfaXRlcmF0b3Igb2JqZWN0LCBhbmQKICogcmV0dXJucyBJVEVSX0RPTkUuIElmIHlvdSB3YW50IHRvIGFib3J0IHRoZSBpdGVyYXRpb24gZWFybHksIGNhbGwKICogcmVmX2l0ZXJhdG9yX2Fib3J0KCksIHdoaWNoIGFsc28gZnJlZXMgdGhlIHJlZl9pdGVyYXRvciBvYmplY3QgYW5kCiAqIGFueSBhc3NvY2lhdGVkIHJlc291cmNlcy4gSWYgdGhlcmUgd2FzIGFuIGludGVybmFsIGVycm9yIGFkdmFuY2luZwogKiB0byB0aGUgbmV4dCBlbnRyeSwgcmVmX2l0ZXJhdG9yX2FkdmFuY2UoKSBhYm9ydHMgdGhlIGl0ZXJhdGlvbiwKICogZnJlZXMgdGhlIHJlZl9pdGVyYXRvciwgYW5kIHJldHVybnMgSVRFUl9FUlJPUi4KICoKICogVGhlIHJlZmVyZW5jZSBjdXJyZW50bHkgYmVpbmcgbG9va2VkIGF0IGNhbiBiZSBwZWVsZWQgYnkgY2FsbGluZwogKiByZWZfaXRlcmF0b3JfcGVlbCgpLiBUaGlzIGZ1bmN0aW9uIGlzIG9mdGVuIGZhc3RlciB0aGFuIHBlZWxfcmVmKCksCiAqIHNvIGl0IHNob3VsZCBiZSBwcmVmZXJyZWQgd2hlbiBpdGVyYXRpbmcgb3ZlciByZWZlcmVuY2VzLgogKgogKiBQdXR0aW5nIGl0IGFsbCB0b2dldGhlciwgYSB0eXBpY2FsIGl0ZXJhdGlvbiBsb29rcyBsaWtlIHRoaXM6CiAqCiAqICAgICBpbnQgb2s7CiAqICAgICBzdHJ1Y3QgcmVmX2l0ZXJhdG9yICppdGVyID0gLi4uOwogKgogKiAgICAgd2hpbGUgKChvayA9IHJlZl9pdGVyYXRvcl9hZHZhbmNlKGl0ZXIpKSA9PSBJVEVSX09LKSB7CiAqICAgICAgICAgICAgIGlmICh3YW50X3RvX3N0b3BfaXRlcmF0aW9uKCkpIHsKICogICAgICAgICAgICAgICAgICAgICBvayA9IHJlZl9pdGVyYXRvcl9hYm9ydChpdGVyKTsKICogICAgICAgICAgICAgICAgICAgICBicmVhazsKICogICAgICAgICAgICAgfQogKgogKiAgICAgICAgICAgICAvLyBBY2Nlc3MgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGN1cnJlbnQgcmVmZXJlbmNlOgogKiAgICAgICAgICAgICBpZiAoIShpdGVyLT5mbGFncyAmIFJFRl9JU1NZTVJFRikpCiAqICAgICAgICAgICAgICAgICAgICAgcHJpbnRmKCIlcyBpcyAlc1xuIiwgaXRlci0+cmVmbmFtZSwgb2lkX3RvX2hleCgmaXRlci0+b2lkKSk7CiAqCiAqICAgICAgICAgICAgIC8vIElmIHlvdSBuZWVkIHRvIHBlZWwgdGhlIHJlZmVyZW5jZToKICogICAgICAgICAgICAgcmVmX2l0ZXJhdG9yX3BlZWwoaXRlciwgJm9pZCk7CiAqICAgICB9CiAqCiAqICAgICBpZiAob2sgIT0gSVRFUl9ET05FKQogKiAgICAgICAgICAgICBoYW5kbGVfZXJyb3IoKTsKICovCnN0cnVjdCByZWZfaXRlcmF0b3IgewoJc3RydWN0IHJlZl9pdGVyYXRvcl92dGFibGUgKnZ0YWJsZTsKCWNvbnN0IGNoYXIgKnJlZm5hbWU7Cgljb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQ7Cgl1bnNpZ25lZCBpbnQgZmxhZ3M7Cn07CgovKgogKiBBZHZhbmNlIHRoZSBpdGVyYXRvciB0byB0aGUgZmlyc3Qgb3IgbmV4dCBpdGVtIGFuZCByZXR1cm4gSVRFUl9PSy4KICogSWYgdGhlIGl0ZXJhdGlvbiBpcyBleGhhdXN0ZWQsIGZyZWUgdGhlIHJlc291cmNlcyBhc3NvY2lhdGVkIHdpdGgKICogdGhlIHJlZl9pdGVyYXRvciBhbmQgcmV0dXJuIElURVJfRE9ORS4gT24gZXJyb3JzLCBmcmVlIHRoZSBpdGVyYXRvcgogKiByZXNvdXJjZXMgYW5kIHJldHVybiBJVEVSX0VSUk9SLiBJdCBpcyBhIGJ1ZyB0byB1c2UgcmVmX2l0ZXJhdG9yIG9yCiAqIGNhbGwgdGhpcyBmdW5jdGlvbiBhZ2FpbiBhZnRlciBpdCBoYXMgcmV0dXJuZWQgSVRFUl9ET05FIG9yCiAqIElURVJfRVJST1IuCiAqLwppbnQgcmVmX2l0ZXJhdG9yX2FkdmFuY2Uoc3RydWN0IHJlZl9pdGVyYXRvciAqcmVmX2l0ZXJhdG9yKTsKCi8qCiAqIElmIHBvc3NpYmxlLCBwZWVsIHRoZSByZWZlcmVuY2UgY3VycmVudGx5IGJlaW5nIHZpZXdlZCBieSB0aGUKICogaXRlcmF0b3IuIFJldHVybiAwIG9uIHN1Y2Nlc3MuCiAqLwppbnQgcmVmX2l0ZXJhdG9yX3BlZWwoc3RydWN0IHJlZl9pdGVyYXRvciAqcmVmX2l0ZXJhdG9yLAoJCSAgICAgIHN0cnVjdCBvYmplY3RfaWQgKnBlZWxlZCk7CgovKgogKiBFbmQgdGhlIGl0ZXJhdGlvbiBiZWZvcmUgaXQgaGFzIGJlZW4gZXhoYXVzdGVkLCBmcmVlaW5nIHRoZQogKiByZWZlcmVuY2UgaXRlcmF0b3IgYW5kIGFueSBhc3NvY2lhdGVkIHJlc291cmNlcyBhbmQgcmV0dXJuaW5nCiAqIElURVJfRE9ORS4gSWYgdGhlIGFib3J0IGl0c2VsZiBmYWlsZWQsIHJldHVybiBJVEVSX0VSUk9SLgogKi8KaW50IHJlZl9pdGVyYXRvcl9hYm9ydChzdHJ1Y3QgcmVmX2l0ZXJhdG9yICpyZWZfaXRlcmF0b3IpOwoKLyoKICogQW4gaXRlcmF0b3Igb3ZlciBub3RoaW5nIChpdHMgZmlyc3QgcmVmX2l0ZXJhdG9yX2FkdmFuY2UoKSBjYWxsCiAqIHJldHVybnMgSVRFUl9ET05FKS4KICovCnN0cnVjdCByZWZfaXRlcmF0b3IgKmVtcHR5X3JlZl9pdGVyYXRvcl9iZWdpbih2b2lkKTsKCi8qCiAqIFJldHVybiB0cnVlIGlmZiByZWZfaXRlcmF0b3IgaXMgYW4gZW1wdHlfcmVmX2l0ZXJhdG9yLgogKi8KaW50IGlzX2VtcHR5X3JlZl9pdGVyYXRvcihzdHJ1Y3QgcmVmX2l0ZXJhdG9yICpyZWZfaXRlcmF0b3IpOwoKLyoKICogQSBjYWxsYmFjayBmdW5jdGlvbiB1c2VkIHRvIGluc3RydWN0IG1lcmdlX3JlZl9pdGVyYXRvciBob3cgdG8KICogaW50ZXJsZWF2ZSB0aGUgZW50cmllcyBmcm9tIGl0ZXIwIGFuZCBpdGVyMS4gVGhlIGZ1bmN0aW9uIHNob3VsZAogKiByZXR1cm4gb25lIG9mIHRoZSBjb25zdGFudHMgZGVmaW5lZCBpbiBlbnVtIGl0ZXJhdG9yX3NlbGVjdGlvbi4gSXQKICogbXVzdCBub3QgYWR2YW5jZSBlaXRoZXIgb2YgdGhlIGl0ZXJhdG9ycyBpdHNlbGYuCiAqCiAqIFRoZSBmdW5jdGlvbiBtdXN0IGJlIHByZXBhcmVkIHRvIGhhbmRsZSB0aGUgY2FzZSB0aGF0IGl0ZXIwIGFuZC9vcgogKiBpdGVyMSBpcyBOVUxMLCB3aGljaCBpbmRpY2F0ZXMgdGhhdCB0aGUgY29ycmVzcG9uZGluZyBzdWItaXRlcmF0b3IKICogaGFzIGJlZW4gZXhoYXVzdGVkLiBJdHMgcmV0dXJuIHZhbHVlIG11c3QgYmUgY29uc2lzdGVudCB3aXRoIHRoZQogKiBjdXJyZW50IHN0YXRlcyBvZiB0aGUgaXRlcmF0b3JzOyBlLmcuLCBpdCBtdXN0IG5vdCByZXR1cm4KICogSVRFUl9TS0lQXzEgaWYgaXRlcjEgaGFzIGFscmVhZHkgYmVlbiBleGhhdXN0ZWQuCiAqLwp0eXBlZGVmIGVudW0gaXRlcmF0b3Jfc2VsZWN0aW9uIHJlZl9pdGVyYXRvcl9zZWxlY3RfZm4oCgkJc3RydWN0IHJlZl9pdGVyYXRvciAqaXRlcjAsIHN0cnVjdCByZWZfaXRlcmF0b3IgKml0ZXIxLAoJCXZvaWQgKmNiX2RhdGEpOwoKLyoKICogSXRlcmF0ZSBvdmVyIHRoZSBlbnRyaWVzIGZyb20gaXRlcjAgYW5kIGl0ZXIxLCB3aXRoIHRoZSB2YWx1ZXMKICogaW50ZXJsZWF2ZWQgYXMgZGlyZWN0ZWQgYnkgdGhlIHNlbGVjdCBmdW5jdGlvbi4gVGhlIGl0ZXJhdG9yIHRha2VzCiAqIG93bmVyc2hpcCBvZiBpdGVyMCBhbmQgaXRlcjEgYW5kIGZyZWVzIHRoZW0gd2hlbiB0aGUgaXRlcmF0aW9uIGlzCiAqIG92ZXIuCiAqLwpzdHJ1Y3QgcmVmX2l0ZXJhdG9yICptZXJnZV9yZWZfaXRlcmF0b3JfYmVnaW4oCgkJc3RydWN0IHJlZl9pdGVyYXRvciAqaXRlcjAsIHN0cnVjdCByZWZfaXRlcmF0b3IgKml0ZXIxLAoJCXJlZl9pdGVyYXRvcl9zZWxlY3RfZm4gKnNlbGVjdCwgdm9pZCAqY2JfZGF0YSk7CgovKgogKiBBbiBpdGVyYXRvciBjb25zaXN0aW5nIG9mIHRoZSB1bmlvbiBvZiB0aGUgZW50cmllcyBmcm9tIGZyb250IGFuZAogKiBiYWNrLiBJZiB0aGVyZSBhcmUgZW50cmllcyBjb21tb24gdG8gdGhlIHR3byBzdWItaXRlcmF0b3JzLCB1c2UgdGhlCiAqIG9uZSBmcm9tIGZyb250LiBFYWNoIGl0ZXJhdG9yIG11c3QgaXRlcmF0ZSBvdmVyIGl0cyBlbnRyaWVzIGluCiAqIHN0cmNtcCgpIG9yZGVyIGJ5IHJlZm5hbWUgZm9yIHRoaXMgdG8gd29yay4KICoKICogVGhlIG5ldyBpdGVyYXRvciB0YWtlcyBvd25lcnNoaXAgb2YgaXRzIGFyZ3VtZW50cyBhbmQgZnJlZXMgdGhlbQogKiB3aGVuIHRoZSBpdGVyYXRpb24gaXMgb3Zlci4gQXMgYSBjb252ZW5pZW5jZSB0byBjYWxsZXJzLCBpZiBmcm9udAogKiBvciBiYWNrIGlzIGFuIGVtcHR5X3JlZl9pdGVyYXRvciwgdGhlbiBhYm9ydCB0aGF0IG9uZSBpbW1lZGlhdGVseQogKiBhbmQgcmV0dXJuIHRoZSBvdGhlciBpdGVyYXRvciBkaXJlY3RseSwgd2l0aG91dCB3cmFwcGluZyBpdC4KICovCnN0cnVjdCByZWZfaXRlcmF0b3IgKm92ZXJsYXlfcmVmX2l0ZXJhdG9yX2JlZ2luKAoJCXN0cnVjdCByZWZfaXRlcmF0b3IgKmZyb250LCBzdHJ1Y3QgcmVmX2l0ZXJhdG9yICpiYWNrKTsKCi8qCiAqIFdyYXAgaXRlcjAsIG9ubHkgbGV0dGluZyB0aHJvdWdoIHRoZSByZWZlcmVuY2VzIHdob3NlIG5hbWVzIHN0YXJ0CiAqIHdpdGggcHJlZml4LiBJZiB0cmltIGlzIHNldCwgc2V0IGl0ZXItPnJlZm5hbWUgdG8gdGhlIG5hbWUgb2YgdGhlCiAqIHJlZmVyZW5jZSB3aXRoIHRoYXQgbWFueSBjaGFyYWN0ZXJzIHRyaW1tZWQgb2ZmIHRoZSBmcm9udDsKICogb3RoZXJ3aXNlIHNldCBpdCB0byB0aGUgZnVsbCByZWZuYW1lLiBUaGUgbmV3IGl0ZXJhdG9yIHRha2VzIG92ZXIKICogb3duZXJzaGlwIG9mIGl0ZXIwIGFuZCBmcmVlcyBpdCB3aGVuIGl0ZXJhdGlvbiBpcyBvdmVyLiBJdCBtYWtlcwogKiBpdHMgb3duIGNvcHkgb2YgcHJlZml4LgogKgogKiBBcyBhbiBjb252ZW5pZW5jZSB0byBjYWxsZXJzLCBpZiBwcmVmaXggaXMgdGhlIGVtcHR5IHN0cmluZyBhbmQKICogdHJpbSBpcyB6ZXJvLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgaXRlcjAgZGlyZWN0bHksIHdpdGhvdXQKICogd3JhcHBpbmcgaXQuCiAqLwpzdHJ1Y3QgcmVmX2l0ZXJhdG9yICpwcmVmaXhfcmVmX2l0ZXJhdG9yX2JlZ2luKHN0cnVjdCByZWZfaXRlcmF0b3IgKml0ZXIwLAoJCQkJCSAgICAgICBjb25zdCBjaGFyICpwcmVmaXgsCgkJCQkJICAgICAgIGludCB0cmltKTsKCi8qIEludGVybmFsIGltcGxlbWVudGF0aW9uIG9mIHJlZmVyZW5jZSBpdGVyYXRpb246ICovCgovKgogKiBCYXNlIGNsYXNzIGNvbnN0cnVjdG9yIGZvciByZWZfaXRlcmF0b3JzLiBJbml0aWFsaXplIHRoZQogKiByZWZfaXRlcmF0b3IgcGFydCBvZiBpdGVyLCBzZXR0aW5nIGl0cyB2dGFibGUgcG9pbnRlciBhcyBzcGVjaWZpZWQuCiAqIFRoaXMgaXMgbWVhbnQgdG8gYmUgY2FsbGVkIG9ubHkgYnkgdGhlIGluaXRpYWxpemVycyBvZiBkZXJpdmVkCiAqIGNsYXNzZXMuCiAqLwp2b2lkIGJhc2VfcmVmX2l0ZXJhdG9yX2luaXQoc3RydWN0IHJlZl9pdGVyYXRvciAqaXRlciwKCQkJICAgIHN0cnVjdCByZWZfaXRlcmF0b3JfdnRhYmxlICp2dGFibGUpOwoKLyoKICogQmFzZSBjbGFzcyBkZXN0cnVjdG9yIGZvciByZWZfaXRlcmF0b3JzLiBEZXN0cm95IHRoZSByZWZfaXRlcmF0b3IKICogcGFydCBvZiBpdGVyIGFuZCBzaGFsbG93LWZyZWUgdGhlIG9iamVjdC4gVGhpcyBpcyBtZWFudCB0byBiZQogKiBjYWxsZWQgb25seSBieSB0aGUgZGVzdHJ1Y3RvcnMgb2YgZGVyaXZlZCBjbGFzc2VzLgogKi8Kdm9pZCBiYXNlX3JlZl9pdGVyYXRvcl9mcmVlKHN0cnVjdCByZWZfaXRlcmF0b3IgKml0ZXIpOwoKLyogVmlydHVhbCBmdW5jdGlvbiBkZWNsYXJhdGlvbnMgZm9yIHJlZl9pdGVyYXRvcnM6ICovCgp0eXBlZGVmIGludCByZWZfaXRlcmF0b3JfYWR2YW5jZV9mbihzdHJ1Y3QgcmVmX2l0ZXJhdG9yICpyZWZfaXRlcmF0b3IpOwoKdHlwZWRlZiBpbnQgcmVmX2l0ZXJhdG9yX3BlZWxfZm4oc3RydWN0IHJlZl9pdGVyYXRvciAqcmVmX2l0ZXJhdG9yLAoJCQkJIHN0cnVjdCBvYmplY3RfaWQgKnBlZWxlZCk7CgovKgogKiBJbXBsZW1lbnRhdGlvbnMgb2YgdGhpcyBmdW5jdGlvbiBzaG91bGQgZnJlZSBhbnkgcmVzb3VyY2VzIHNwZWNpZmljCiAqIHRvIHRoZSBkZXJpdmVkIGNsYXNzLCB0aGVuIGNhbGwgYmFzZV9yZWZfaXRlcmF0b3JfZnJlZSgpIHRvIGNsZWFuCiAqIHVwIGFuZCBmcmVlIHRoZSByZWZfaXRlcmF0b3Igb2JqZWN0LgogKi8KdHlwZWRlZiBpbnQgcmVmX2l0ZXJhdG9yX2Fib3J0X2ZuKHN0cnVjdCByZWZfaXRlcmF0b3IgKnJlZl9pdGVyYXRvcik7CgpzdHJ1Y3QgcmVmX2l0ZXJhdG9yX3Z0YWJsZSB7CglyZWZfaXRlcmF0b3JfYWR2YW5jZV9mbiAqYWR2YW5jZTsKCXJlZl9pdGVyYXRvcl9wZWVsX2ZuICpwZWVsOwoJcmVmX2l0ZXJhdG9yX2Fib3J0X2ZuICphYm9ydDsKfTsKCi8qCiAqIGN1cnJlbnRfcmVmX2l0ZXIgaXMgYSBwZXJmb3JtYW5jZSBoYWNrOiB3aGVuIGl0ZXJhdGluZyBvdmVyCiAqIHJlZmVyZW5jZXMgdXNpbmcgdGhlIGZvcl9lYWNoX3JlZiooKSBmdW5jdGlvbnMsIGN1cnJlbnRfcmVmX2l0ZXIgaXMKICogc2V0IHRvIHRoZSByZWZlcmVuY2UgaXRlcmF0b3IgYmVmb3JlIGNhbGxpbmcgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLgogKiBJZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gY2FsbHMgcGVlbF9yZWYoKSwgdGhlbiBwZWVsX3JlZigpIGZpcnN0CiAqIGNoZWNrcyB3aGV0aGVyIHRoZSByZWZlcmVuY2UgdG8gYmUgcGVlbGVkIGlzIHRoZSBvbmUgcmVmZXJyZWQgdG8gYnkKICogdGhlIGl0ZXJhdG9yIChpdCB1c3VhbGx5IGlzKSBhbmQgaWYgc28sIGFza3MgdGhlIGl0ZXJhdG9yIGZvciB0aGUKICogcGVlbGVkIHZlcnNpb24gb2YgdGhlIHJlZmVyZW5jZSBpZiBpdCBpcyBhdmFpbGFibGUuIFRoaXMgYXZvaWRzIGEKICogcmVmbmFtZSBsb29rdXAgaW4gYSBjb21tb24gY2FzZS4gY3VycmVudF9yZWZfaXRlciBpcyBzZXQgdG8gTlVMTAogKiB3aGVuIHRoZSBpdGVyYXRpb24gaXMgb3Zlci4KICovCmV4dGVybiBzdHJ1Y3QgcmVmX2l0ZXJhdG9yICpjdXJyZW50X3JlZl9pdGVyOwoKLyoKICogVGhlIGNvbW1vbiBiYWNrZW5kIGZvciB0aGUgZm9yX2VhY2hfKnJlZiogZnVuY3Rpb25zLiBDYWxsIGZuIGZvcgogKiBlYWNoIHJlZmVyZW5jZSBpbiBpdGVyLiBJZiB0aGUgaXRlcmF0b3IgaXRzZWxmIGV2ZXIgcmV0dXJucwogKiBJVEVSX0VSUk9SLCByZXR1cm4gLTEuIElmIGZuIGV2ZXIgcmV0dXJucyBhIG5vbi16ZXJvIHZhbHVlLCBzdG9wCiAqIHRoZSBpdGVyYXRpb24gYW5kIHJldHVybiB0aGF0IHZhbHVlLiBPdGhlcndpc2UsIHJldHVybiAwLiBJbiBhbnkKICogY2FzZSwgZnJlZSB0aGUgaXRlcmF0b3Igd2hlbiBkb25lLiBUaGlzIGZ1bmN0aW9uIGlzIGJhc2ljYWxseSBhbgogKiBhZGFwdGVyIGJldHdlZW4gdGhlIGNhbGxiYWNrIHN0eWxlIG9mIHJlZmVyZW5jZSBpdGVyYXRpb24gYW5kIHRoZQogKiBpdGVyYXRvciBzdHlsZS4KICovCmludCBkb19mb3JfZWFjaF9yZWZfaXRlcmF0b3Ioc3RydWN0IHJlZl9pdGVyYXRvciAqaXRlciwKCQkJICAgICBlYWNoX3JlZl9mbiBmbiwgdm9pZCAqY2JfZGF0YSk7CgovKgogKiBPbmx5IGluY2x1ZGUgcGVyLXdvcmt0cmVlIHJlZnMgaW4gYSBkb19mb3JfZWFjaF9yZWYqKCkgaXRlcmF0aW9uLgogKiBOb3JtYWxseSB0aGlzIHdpbGwgYmUgdXNlZCB3aXRoIGEgZmlsZXMgcmVmX3N0b3JlLCBzaW5jZSB0aGF0J3MKICogd2hlcmUgYWxsIHJlZmVyZW5jZSBiYWNrZW5kcyB3aWxsIHByZXN1bWFibHkgc3RvcmUgdGhlaXIKICogcGVyLXdvcmt0cmVlIHJlZnMuCiAqLwojZGVmaW5lIERPX0ZPUl9FQUNIX1BFUl9XT1JLVFJFRV9PTkxZIDB4MDIKCnN0cnVjdCByZWZfc3RvcmU7CgovKiByZWZzIGJhY2tlbmRzICovCgovKgogKiBJbml0aWFsaXplIHRoZSByZWZfc3RvcmUgZm9yIHRoZSBzcGVjaWZpZWQgc3VibW9kdWxlLCBvciBmb3IgdGhlCiAqIG1haW4gcmVwb3NpdG9yeSBpZiBzdWJtb2R1bGUgPT0gTlVMTC4gVGhlc2UgZnVuY3Rpb25zIHNob3VsZCBjYWxsCiAqIGJhc2VfcmVmX3N0b3JlX2luaXQoKSB0byBpbml0aWFsaXplIHRoZSBzaGFyZWQgcGFydCBvZiB0aGUKICogcmVmX3N0b3JlIGFuZCB0byByZWNvcmQgdGhlIHJlZl9zdG9yZSBmb3IgbGF0ZXIgbG9va3VwLgogKi8KdHlwZWRlZiBzdHJ1Y3QgcmVmX3N0b3JlICpyZWZfc3RvcmVfaW5pdF9mbihjb25zdCBjaGFyICpzdWJtb2R1bGUpOwoKdHlwZWRlZiBpbnQgcmVmX2luaXRfZGJfZm4oc3RydWN0IHJlZl9zdG9yZSAqcmVmcywgc3RydWN0IHN0cmJ1ZiAqZXJyKTsKCnR5cGVkZWYgaW50IHJlZl90cmFuc2FjdGlvbl9jb21taXRfZm4oc3RydWN0IHJlZl9zdG9yZSAqcmVmcywKCQkJCSAgICAgIHN0cnVjdCByZWZfdHJhbnNhY3Rpb24gKnRyYW5zYWN0aW9uLAoJCQkJICAgICAgc3RydWN0IHN0cmJ1ZiAqZXJyKTsKCnR5cGVkZWYgaW50IHBhY2tfcmVmc19mbihzdHJ1Y3QgcmVmX3N0b3JlICpyZWZfc3RvcmUsIHVuc2lnbmVkIGludCBmbGFncyk7CnR5cGVkZWYgaW50IHBlZWxfcmVmX2ZuKHN0cnVjdCByZWZfc3RvcmUgKnJlZl9zdG9yZSwKCQkJY29uc3QgY2hhciAqcmVmbmFtZSwgdW5zaWduZWQgY2hhciAqc2hhMSk7CnR5cGVkZWYgaW50IGNyZWF0ZV9zeW1yZWZfZm4oc3RydWN0IHJlZl9zdG9yZSAqcmVmX3N0b3JlLAoJCQkgICAgIGNvbnN0IGNoYXIgKnJlZl90YXJnZXQsCgkJCSAgICAgY29uc3QgY2hhciAqcmVmc19oZWFkc19tYXN0ZXIsCgkJCSAgICAgY29uc3QgY2hhciAqbG9nbXNnKTsKdHlwZWRlZiBpbnQgZGVsZXRlX3JlZnNfZm4oc3RydWN0IHJlZl9zdG9yZSAqcmVmX3N0b3JlLAoJCQkgICBzdHJ1Y3Qgc3RyaW5nX2xpc3QgKnJlZm5hbWVzLCB1bnNpZ25lZCBpbnQgZmxhZ3MpOwp0eXBlZGVmIGludCByZW5hbWVfcmVmX2ZuKHN0cnVjdCByZWZfc3RvcmUgKnJlZl9zdG9yZSwKCQkJICBjb25zdCBjaGFyICpvbGRyZWYsIGNvbnN0IGNoYXIgKm5ld3JlZiwKCQkJICBjb25zdCBjaGFyICpsb2dtc2cpOwoKLyoKICogSXRlcmF0ZSBvdmVyIHRoZSByZWZlcmVuY2VzIGluIHRoZSBzcGVjaWZpZWQgcmVmX3N0b3JlIHRoYXQgYXJlCiAqIHdpdGhpbiBmaW5kX2NvbnRhaW5pbmdfZGlyKHByZWZpeCkuIElmIHByZWZpeCBpcyBOVUxMIG9yIHRoZSBlbXB0eQogKiBzdHJpbmcsIGl0ZXJhdGUgb3ZlciBhbGwgcmVmZXJlbmNlcyBpbiB0aGUgc3VibW9kdWxlLgogKi8KdHlwZWRlZiBzdHJ1Y3QgcmVmX2l0ZXJhdG9yICpyZWZfaXRlcmF0b3JfYmVnaW5fZm4oCgkJc3RydWN0IHJlZl9zdG9yZSAqcmVmX3N0b3JlLAoJCWNvbnN0IGNoYXIgKnByZWZpeCwgdW5zaWduZWQgaW50IGZsYWdzKTsKCi8qIHJlZmxvZyBmdW5jdGlvbnMgKi8KCi8qCiAqIEl0ZXJhdGUgb3ZlciB0aGUgcmVmZXJlbmNlcyBpbiB0aGUgc3BlY2lmaWVkIHJlZl9zdG9yZSB0aGF0IGhhdmUgYQogKiByZWZsb2cuIFRoZSByZWZzIGFyZSBpdGVyYXRlZCBvdmVyIGluIGFyYml0cmFyeSBvcmRlci4KICovCnR5cGVkZWYgc3RydWN0IHJlZl9pdGVyYXRvciAqcmVmbG9nX2l0ZXJhdG9yX2JlZ2luX2ZuKAoJCXN0cnVjdCByZWZfc3RvcmUgKnJlZl9zdG9yZSk7Cgp0eXBlZGVmIGludCBmb3JfZWFjaF9yZWZsb2dfZW50X2ZuKHN0cnVjdCByZWZfc3RvcmUgKnJlZl9zdG9yZSwKCQkJCSAgIGNvbnN0IGNoYXIgKnJlZm5hbWUsCgkJCQkgICBlYWNoX3JlZmxvZ19lbnRfZm4gZm4sCgkJCQkgICB2b2lkICpjYl9kYXRhKTsKdHlwZWRlZiBpbnQgZm9yX2VhY2hfcmVmbG9nX2VudF9yZXZlcnNlX2ZuKHN0cnVjdCByZWZfc3RvcmUgKnJlZl9zdG9yZSwKCQkJCQkgICBjb25zdCBjaGFyICpyZWZuYW1lLAoJCQkJCSAgIGVhY2hfcmVmbG9nX2VudF9mbiBmbiwKCQkJCQkgICB2b2lkICpjYl9kYXRhKTsKdHlwZWRlZiBpbnQgcmVmbG9nX2V4aXN0c19mbihzdHJ1Y3QgcmVmX3N0b3JlICpyZWZfc3RvcmUsIGNvbnN0IGNoYXIgKnJlZm5hbWUpOwp0eXBlZGVmIGludCBjcmVhdGVfcmVmbG9nX2ZuKHN0cnVjdCByZWZfc3RvcmUgKnJlZl9zdG9yZSwgY29uc3QgY2hhciAqcmVmbmFtZSwKCQkJICAgICBpbnQgZm9yY2VfY3JlYXRlLCBzdHJ1Y3Qgc3RyYnVmICplcnIpOwp0eXBlZGVmIGludCBkZWxldGVfcmVmbG9nX2ZuKHN0cnVjdCByZWZfc3RvcmUgKnJlZl9zdG9yZSwgY29uc3QgY2hhciAqcmVmbmFtZSk7CnR5cGVkZWYgaW50IHJlZmxvZ19leHBpcmVfZm4oc3RydWN0IHJlZl9zdG9yZSAqcmVmX3N0b3JlLAoJCQkgICAgIGNvbnN0IGNoYXIgKnJlZm5hbWUsIGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEsCgkJCSAgICAgdW5zaWduZWQgaW50IGZsYWdzLAoJCQkgICAgIHJlZmxvZ19leHBpcnlfcHJlcGFyZV9mbiBwcmVwYXJlX2ZuLAoJCQkgICAgIHJlZmxvZ19leHBpcnlfc2hvdWxkX3BydW5lX2ZuIHNob3VsZF9wcnVuZV9mbiwKCQkJICAgICByZWZsb2dfZXhwaXJ5X2NsZWFudXBfZm4gY2xlYW51cF9mbiwKCQkJICAgICB2b2lkICpwb2xpY3lfY2JfZGF0YSk7CgovKgogKiBSZWFkIGEgcmVmZXJlbmNlIGZyb20gdGhlIHNwZWNpZmllZCByZWZlcmVuY2Ugc3RvcmUsIG5vbi1yZWN1cnNpdmVseS4KICogU2V0IHR5cGUgdG8gZGVzY3JpYmUgdGhlIHJlZmVyZW5jZSwgYW5kOgogKgogKiAtIElmIHJlZm5hbWUgaXMgdGhlIG5hbWUgb2YgYSBub3JtYWwgcmVmZXJlbmNlLCBmaWxsIGluIHNoYTEKICogICAobGVhdmluZyByZWZlcmVudCB1bmNoYW5nZWQpLgogKgogKiAtIElmIHJlZm5hbWUgaXMgdGhlIG5hbWUgb2YgYSBzeW1ib2xpYyByZWZlcmVuY2UsIHdyaXRlIHRoZSBmdWxsCiAqICAgbmFtZSBvZiB0aGUgcmVmZXJlbmNlIHRvIHdoaWNoIGl0IHJlZmVycyAoZS5nLgogKiAgICJyZWZzL2hlYWRzL21hc3RlciIpIHRvIHJlZmVyZW50IGFuZCBzZXQgdGhlIFJFRl9JU1NZTVJFRiBiaXQgaW4KICogICB0eXBlIChsZWF2aW5nIHNoYTEgdW5jaGFuZ2VkKS4gVGhlIGNhbGxlciBpcyByZXNwb25zaWJsZSBmb3IKICogICB2YWxpZGF0aW5nIHRoYXQgcmVmZXJlbnQgaXMgYSB2YWxpZCByZWZlcmVuY2UgbmFtZS4KICoKICogV0FSTklORzogcmVmbmFtZSBtaWdodCBiZSB1c2VkIGFzIHBhcnQgb2YgYSBmaWxlbmFtZSwgc28gaXQgaXMKICogaW1wb3J0YW50IGZyb20gYSBzZWN1cml0eSBzdGFuZHBvaW50IHRoYXQgaXQgYmUgc2FmZSBpbiB0aGUgc2Vuc2UKICogb2YgcmVmbmFtZV9pc19zYWZlKCkuIE1vcmVvdmVyLCBmb3Igc3ltcmVmcyB0aGlzIGZ1bmN0aW9uIHNldHMKICogcmVmZXJlbnQgdG8gd2hhdGV2ZXIgdGhlIHJlcG9zaXRvcnkgc2F5cywgd2hpY2ggbWlnaHQgbm90IGJlIGEKICogcHJvcGVybHktZm9ybWF0dGVkIG9yIGV2ZW4gc2FmZSByZWZlcmVuY2UgbmFtZS4gTkVJVEhFUiBJTlBVVCBOT1IKICogT1VUUFVUIFJFRkVSRU5DRSBOQU1FUyBBUkUgVkFMSURBVEVEIFdJVEhJTiBUSElTIEZVTkNUSU9OLgogKgogKiBSZXR1cm4gMCBvbiBzdWNjZXNzLiBJZiB0aGUgcmVmIGRvZXNuJ3QgZXhpc3QsIHNldCBlcnJubyB0byBFTk9FTlQKICogYW5kIHJldHVybiAtMS4gSWYgdGhlIHJlZiBleGlzdHMgYnV0IGlzIG5laXRoZXIgYSBzeW1ib2xpYyByZWYgbm9yCiAqIGEgc2hhMSwgaXQgaXMgYnJva2VuOyBzZXQgUkVGX0lTQlJPS0VOIGluIHR5cGUsIHNldCBlcnJubyB0bwogKiBFSU5WQUwsIGFuZCByZXR1cm4gLTEuIElmIHRoZXJlIGlzIGFub3RoZXIgZXJyb3IgcmVhZGluZyB0aGUgcmVmLAogKiBzZXQgZXJybm8gYXBwcm9wcmlhdGVseSBhbmQgcmV0dXJuIC0xLgogKgogKiBCYWNrZW5kLXNwZWNpZmljIGZsYWdzIG1pZ2h0IGJlIHNldCBpbiB0eXBlIGFzIHdlbGwsIHJlZ2FyZGxlc3Mgb2YKICogb3V0Y29tZS4KICoKICogSXQgaXMgT0sgZm9yIHJlZm5hbWUgdG8gcG9pbnQgaW50byByZWZlcmVudC4gSWYgc286CiAqCiAqIC0gaWYgdGhlIGZ1bmN0aW9uIHN1Y2NlZWRzIHdpdGggUkVGX0lTU1lNUkVGLCByZWZlcmVudCB3aWxsIGJlCiAqICAgb3ZlcndyaXR0ZW4gYW5kIHRoZSBtZW1vcnkgZm9ybWVybHkgcG9pbnRlZCB0byBieSBpdCBtaWdodCBiZQogKiAgIGNoYW5nZWQgb3IgZXZlbiBmcmVlZC4KICoKICogLSBpbiBhbGwgb3RoZXIgY2FzZXMsIHJlZmVyZW50IHdpbGwgYmUgdW50b3VjaGVkLCBhbmQgdGhlcmVmb3JlCiAqICAgcmVmbmFtZSB3aWxsIHN0aWxsIGJlIHZhbGlkIGFuZCB1bmNoYW5nZWQuCiAqLwp0eXBlZGVmIGludCByZWFkX3Jhd19yZWZfZm4oc3RydWN0IHJlZl9zdG9yZSAqcmVmX3N0b3JlLAoJCQkgICAgY29uc3QgY2hhciAqcmVmbmFtZSwgdW5zaWduZWQgY2hhciAqc2hhMSwKCQkJICAgIHN0cnVjdCBzdHJidWYgKnJlZmVyZW50LCB1bnNpZ25lZCBpbnQgKnR5cGUpOwoKdHlwZWRlZiBpbnQgdmVyaWZ5X3JlZm5hbWVfYXZhaWxhYmxlX2ZuKHN0cnVjdCByZWZfc3RvcmUgKnJlZl9zdG9yZSwKCQkJCQljb25zdCBjaGFyICpuZXduYW1lLAoJCQkJCWNvbnN0IHN0cnVjdCBzdHJpbmdfbGlzdCAqZXh0cmFzLAoJCQkJCWNvbnN0IHN0cnVjdCBzdHJpbmdfbGlzdCAqc2tpcCwKCQkJCQlzdHJ1Y3Qgc3RyYnVmICplcnIpOwoKc3RydWN0IHJlZl9zdG9yYWdlX2JlIHsKCXN0cnVjdCByZWZfc3RvcmFnZV9iZSAqbmV4dDsKCWNvbnN0IGNoYXIgKm5hbWU7CglyZWZfc3RvcmVfaW5pdF9mbiAqaW5pdDsKCXJlZl9pbml0X2RiX2ZuICppbml0X2RiOwoJcmVmX3RyYW5zYWN0aW9uX2NvbW1pdF9mbiAqdHJhbnNhY3Rpb25fY29tbWl0OwoJcmVmX3RyYW5zYWN0aW9uX2NvbW1pdF9mbiAqaW5pdGlhbF90cmFuc2FjdGlvbl9jb21taXQ7CgoJcGFja19yZWZzX2ZuICpwYWNrX3JlZnM7CglwZWVsX3JlZl9mbiAqcGVlbF9yZWY7CgljcmVhdGVfc3ltcmVmX2ZuICpjcmVhdGVfc3ltcmVmOwoJZGVsZXRlX3JlZnNfZm4gKmRlbGV0ZV9yZWZzOwoJcmVuYW1lX3JlZl9mbiAqcmVuYW1lX3JlZjsKCglyZWZfaXRlcmF0b3JfYmVnaW5fZm4gKml0ZXJhdG9yX2JlZ2luOwoJcmVhZF9yYXdfcmVmX2ZuICpyZWFkX3Jhd19yZWY7Cgl2ZXJpZnlfcmVmbmFtZV9hdmFpbGFibGVfZm4gKnZlcmlmeV9yZWZuYW1lX2F2YWlsYWJsZTsKCglyZWZsb2dfaXRlcmF0b3JfYmVnaW5fZm4gKnJlZmxvZ19pdGVyYXRvcl9iZWdpbjsKCWZvcl9lYWNoX3JlZmxvZ19lbnRfZm4gKmZvcl9lYWNoX3JlZmxvZ19lbnQ7Cglmb3JfZWFjaF9yZWZsb2dfZW50X3JldmVyc2VfZm4gKmZvcl9lYWNoX3JlZmxvZ19lbnRfcmV2ZXJzZTsKCXJlZmxvZ19leGlzdHNfZm4gKnJlZmxvZ19leGlzdHM7CgljcmVhdGVfcmVmbG9nX2ZuICpjcmVhdGVfcmVmbG9nOwoJZGVsZXRlX3JlZmxvZ19mbiAqZGVsZXRlX3JlZmxvZzsKCXJlZmxvZ19leHBpcmVfZm4gKnJlZmxvZ19leHBpcmU7Cn07CgpleHRlcm4gc3RydWN0IHJlZl9zdG9yYWdlX2JlIHJlZnNfYmVfZmlsZXM7CgovKgogKiBBIHJlcHJlc2VudGF0aW9uIG9mIHRoZSByZWZlcmVuY2Ugc3RvcmUgZm9yIHRoZSBtYWluIHJlcG9zaXRvcnkgb3IKICogYSBzdWJtb2R1bGUuIFRoZSByZWZfc3RvcmUgaW5zdGFuY2VzIGZvciBzdWJtb2R1bGVzIGFyZSBrZXB0IGluIGEKICogbGlua2VkIGxpc3QuCiAqLwpzdHJ1Y3QgcmVmX3N0b3JlIHsKCS8qIFRoZSBiYWNrZW5kIGRlc2NyaWJpbmcgdGhpcyByZWZfc3RvcmUncyBzdG9yYWdlIHNjaGVtZTogKi8KCWNvbnN0IHN0cnVjdCByZWZfc3RvcmFnZV9iZSAqYmU7Cn07CgovKgogKiBGaWxsIGluIHRoZSBnZW5lcmljIHBhcnQgb2YgcmVmcyBmb3IgdGhlIHNwZWNpZmllZCBzdWJtb2R1bGUgYW5kCiAqIGFkZCBpdCB0byBvdXIgY29sbGVjdGlvbiBvZiByZWZlcmVuY2Ugc3RvcmVzLgogKi8Kdm9pZCBiYXNlX3JlZl9zdG9yZV9pbml0KHN0cnVjdCByZWZfc3RvcmUgKnJlZnMsCgkJCSBjb25zdCBzdHJ1Y3QgcmVmX3N0b3JhZ2VfYmUgKmJlLAoJCQkgY29uc3QgY2hhciAqc3VibW9kdWxlKTsKCi8qCiAqIFJldHVybiB0aGUgcmVmX3N0b3JlIGluc3RhbmNlIGZvciB0aGUgc3BlY2lmaWVkIHN1Ym1vZHVsZS4gRm9yIHRoZQogKiBtYWluIHJlcG9zaXRvcnksIHVzZSBzdWJtb2R1bGU9PU5VTEw7IHN1Y2ggYSBjYWxsIGNhbm5vdCBmYWlsLiBGb3IKICogYSBzdWJtb2R1bGUsIHRoZSBzdWJtb2R1bGUgbXVzdCBleGlzdCBhbmQgYmUgYSBub25iYXJlIHJlcG9zaXRvcnksCiAqIG90aGVyd2lzZSByZXR1cm4gTlVMTC4gSWYgdGhlIHJlcXVlc3RlZCByZWZlcmVuY2Ugc3RvcmUgaGFzIG5vdCB5ZXQKICogYmVlbiBpbml0aWFsaXplZCwgaW5pdGlhbGl6ZSBpdCBmaXJzdC4KICoKICogRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCBzdWJtb2R1bGU9PSIiIGlzIHRyZWF0ZWQgdGhlIHNhbWUgYXMKICogc3VibW9kdWxlPT1OVUxMLgogKi8Kc3RydWN0IHJlZl9zdG9yZSAqZ2V0X3JlZl9zdG9yZShjb25zdCBjaGFyICpzdWJtb2R1bGUpOwoKI2VuZGlmIC8qIFJFRlNfUkVGU19JTlRFUk5BTF9IICovCg==",
    "text": "#ifndef REFS_REFS_INTERNAL_H\n#define REFS_REFS_INTERNAL_H\n\n/*\n * Data structures and functions for the internal use of the refs\n * module. Code outside of the refs module should use only the public\n * functions defined in \"refs.h\", and should *not* include this file.\n */\n\n/*\n * Flag passed to lock_ref_sha1_basic() telling it to tolerate broken\n * refs (i.e., because the reference is about to be deleted anyway).\n */\n#define REF_DELETING\t0x02\n\n/*\n * Used as a flag in ref_update::flags when a loose ref is being\n * pruned. This flag must only be used when REF_NODEREF is set.\n */\n#define REF_ISPRUNING\t0x04\n\n/*\n * Used as a flag in ref_update::flags when the reference should be\n * updated to new_sha1.\n */\n#define REF_HAVE_NEW\t0x08\n\n/*\n * Used as a flag in ref_update::flags when old_sha1 should be\n * checked.\n */\n#define REF_HAVE_OLD\t0x10\n\n/*\n * Used as a flag in ref_update::flags when the lockfile needs to be\n * committed.\n */\n#define REF_NEEDS_COMMIT 0x20\n\n/*\n * 0x40 is REF_FORCE_CREATE_REFLOG, so skip it if you're adding a\n * value to ref_update::flags\n */\n\n/*\n * Used as a flag in ref_update::flags when we want to log a ref\n * update but not actually perform it.  This is used when a symbolic\n * ref update is split up.\n */\n#define REF_LOG_ONLY 0x80\n\n/*\n * Internal flag, meaning that the containing ref_update was via an\n * update to HEAD.\n */\n#define REF_UPDATE_VIA_HEAD 0x100\n\n/*\n * Return true iff refname is minimally safe. \"Safe\" here means that\n * deleting a loose reference by this name will not do any damage, for\n * example by causing a file that is not a reference to be deleted.\n * This function does not check that the reference name is legal; for\n * that, use check_refname_format().\n *\n * We consider a refname that starts with \"refs/\" to be safe as long\n * as any \"..\" components that it might contain do not escape \"refs/\".\n * Names that do not start with \"refs/\" are considered safe iff they\n * consist entirely of upper case characters and '_' (like \"HEAD\" and\n * \"MERGE_HEAD\" but not \"config\" or \"FOO/BAR\").\n */\nint refname_is_safe(const char *refname);\n\nenum peel_status {\n\t/* object was peeled successfully: */\n\tPEEL_PEELED = 0,\n\n\t/*\n\t * object cannot be peeled because the named object (or an\n\t * object referred to by a tag in the peel chain), does not\n\t * exist.\n\t */\n\tPEEL_INVALID = -1,\n\n\t/* object cannot be peeled because it is not a tag: */\n\tPEEL_NON_TAG = -2,\n\n\t/* ref_entry contains no peeled value because it is a symref: */\n\tPEEL_IS_SYMREF = -3,\n\n\t/*\n\t * ref_entry cannot be peeled because it is broken (i.e., the\n\t * symbolic reference cannot even be resolved to an object\n\t * name):\n\t */\n\tPEEL_BROKEN = -4\n};\n\n/*\n * Peel the named object; i.e., if the object is a tag, resolve the\n * tag recursively until a non-tag is found.  If successful, store the\n * result to sha1 and return PEEL_PEELED.  If the object is not a tag\n * or is not valid, return PEEL_NON_TAG or PEEL_INVALID, respectively,\n * and leave sha1 unchanged.\n */\nenum peel_status peel_object(const unsigned char *name, unsigned char *sha1);\n\n/*\n * Return 0 if a reference named refname could be created without\n * conflicting with the name of an existing reference. Otherwise,\n * return a negative value and write an explanation to err. If extras\n * is non-NULL, it is a list of additional refnames with which refname\n * is not allowed to conflict. If skip is non-NULL, ignore potential\n * conflicts with refs in skip (e.g., because they are scheduled for\n * deletion in the same operation). Behavior is undefined if the same\n * name is listed in both extras and skip.\n *\n * Two reference names conflict if one of them exactly matches the\n * leading components of the other; e.g., \"foo/bar\" conflicts with\n * both \"foo\" and with \"foo/bar/baz\" but not with \"foo/bar\" or\n * \"foo/barbados\".\n *\n * extras and skip must be sorted.\n */\nint verify_refname_available(const char *newname,\n\t\t\t     const struct string_list *extras,\n\t\t\t     const struct string_list *skip,\n\t\t\t     struct strbuf *err);\n\n/*\n * Copy the reflog message msg to buf, which has been allocated sufficiently\n * large, while cleaning up the whitespaces.  Especially, convert LF to space,\n * because reflog file is one line per entry.\n */\nint copy_reflog_msg(char *buf, const char *msg);\n\nint should_autocreate_reflog(const char *refname);\n\n/**\n * Information needed for a single ref update. Set new_sha1 to the new\n * value or to null_sha1 to delete the ref. To check the old value\n * while the ref is locked, set (flags & REF_HAVE_OLD) and set\n * old_sha1 to the old value, or to null_sha1 to ensure the ref does\n * not exist before update.\n */\nstruct ref_update {\n\n\t/*\n\t * If (flags & REF_HAVE_NEW), set the reference to this value:\n\t */\n\tunsigned char new_sha1[20];\n\n\t/*\n\t * If (flags & REF_HAVE_OLD), check that the reference\n\t * previously had this value:\n\t */\n\tunsigned char old_sha1[20];\n\n\t/*\n\t * One or more of REF_HAVE_NEW, REF_HAVE_OLD, REF_NODEREF,\n\t * REF_DELETING, REF_ISPRUNING, REF_LOG_ONLY, and\n\t * REF_UPDATE_VIA_HEAD:\n\t */\n\tunsigned int flags;\n\n\tvoid *backend_data;\n\tunsigned int type;\n\tchar *msg;\n\n\t/*\n\t * If this ref_update was split off of a symref update via\n\t * split_symref_update(), then this member points at that\n\t * update. This is used for two purposes:\n\t * 1. When reporting errors, we report the refname under which\n\t *    the update was originally requested.\n\t * 2. When we read the old value of this reference, we\n\t *    propagate it back to its parent update for recording in\n\t *    the latter's reflog.\n\t */\n\tstruct ref_update *parent_update;\n\n\tconst char refname[FLEX_ARRAY];\n};\n\n/*\n * Add a ref_update with the specified properties to transaction, and\n * return a pointer to the new object. This function does not verify\n * that refname is well-formed. new_sha1 and old_sha1 are only\n * dereferenced if the REF_HAVE_NEW and REF_HAVE_OLD bits,\n * respectively, are set in flags.\n */\nstruct ref_update *ref_transaction_add_update(\n\t\tstruct ref_transaction *transaction,\n\t\tconst char *refname, unsigned int flags,\n\t\tconst unsigned char *new_sha1,\n\t\tconst unsigned char *old_sha1,\n\t\tconst char *msg);\n\n/*\n * Transaction states.\n * OPEN:   The transaction is in a valid state and can accept new updates.\n *         An OPEN transaction can be committed.\n * CLOSED: A closed transaction is no longer active and no other operations\n *         than free can be used on it in this state.\n *         A transaction can either become closed by successfully committing\n *         an active transaction or if there is a failure while building\n *         the transaction thus rendering it failed/inactive.\n */\nenum ref_transaction_state {\n\tREF_TRANSACTION_OPEN   = 0,\n\tREF_TRANSACTION_CLOSED = 1\n};\n\n/*\n * Data structure for holding a reference transaction, which can\n * consist of checks and updates to multiple references, carried out\n * as atomically as possible.  This structure is opaque to callers.\n */\nstruct ref_transaction {\n\tstruct ref_update **updates;\n\tsize_t alloc;\n\tsize_t nr;\n\tenum ref_transaction_state state;\n};\n\nint files_log_ref_write(const char *refname, const unsigned char *old_sha1,\n\t\t\tconst unsigned char *new_sha1, const char *msg,\n\t\t\tint flags, struct strbuf *err);\n\n/*\n * Check for entries in extras that are within the specified\n * directory, where dirname is a reference directory name including\n * the trailing slash (e.g., \"refs/heads/foo/\"). Ignore any\n * conflicting references that are found in skip. If there is a\n * conflicting reference, return its name.\n *\n * extras and skip must be sorted lists of reference names. Either one\n * can be NULL, signifying the empty list.\n */\nconst char *find_descendant_ref(const char *dirname,\n\t\t\t\tconst struct string_list *extras,\n\t\t\t\tconst struct string_list *skip);\n\n/*\n * Check whether an attempt to rename old_refname to new_refname would\n * cause a D/F conflict with any existing reference (other than\n * possibly old_refname). If there would be a conflict, emit an error\n * message and return false; otherwise, return true.\n *\n * Note that this function is not safe against all races with other\n * processes (though rename_ref() catches some races that might get by\n * this check).\n */\nint rename_ref_available(const char *old_refname, const char *new_refname);\n\n/* We allow \"recursive\" symbolic refs. Only within reason, though */\n#define SYMREF_MAXDEPTH 5\n\n/* Include broken references in a do_for_each_ref*() iteration: */\n#define DO_FOR_EACH_INCLUDE_BROKEN 0x01\n\n/*\n * Reference iterators\n *\n * A reference iterator encapsulates the state of an in-progress\n * iteration over references. Create an instance of `struct\n * ref_iterator` via one of the functions in this module.\n *\n * A freshly-created ref_iterator doesn't yet point at a reference. To\n * advance the iterator, call ref_iterator_advance(). If successful,\n * this sets the iterator's refname, oid, and flags fields to describe\n * the next reference and returns ITER_OK. The data pointed at by\n * refname and oid belong to the iterator; if you want to retain them\n * after calling ref_iterator_advance() again or calling\n * ref_iterator_abort(), you must make a copy. When the iteration has\n * been exhausted, ref_iterator_advance() releases any resources\n * assocated with the iteration, frees the ref_iterator object, and\n * returns ITER_DONE. If you want to abort the iteration early, call\n * ref_iterator_abort(), which also frees the ref_iterator object and\n * any associated resources. If there was an internal error advancing\n * to the next entry, ref_iterator_advance() aborts the iteration,\n * frees the ref_iterator, and returns ITER_ERROR.\n *\n * The reference currently being looked at can be peeled by calling\n * ref_iterator_peel(). This function is often faster than peel_ref(),\n * so it should be preferred when iterating over references.\n *\n * Putting it all together, a typical iteration looks like this:\n *\n *     int ok;\n *     struct ref_iterator *iter = ...;\n *\n *     while ((ok = ref_iterator_advance(iter)) == ITER_OK) {\n *             if (want_to_stop_iteration()) {\n *                     ok = ref_iterator_abort(iter);\n *                     break;\n *             }\n *\n *             // Access information about the current reference:\n *             if (!(iter->flags & REF_ISSYMREF))\n *                     printf(\"%s is %s\\n\", iter->refname, oid_to_hex(&iter->oid));\n *\n *             // If you need to peel the reference:\n *             ref_iterator_peel(iter, &oid);\n *     }\n *\n *     if (ok != ITER_DONE)\n *             handle_error();\n */\nstruct ref_iterator {\n\tstruct ref_iterator_vtable *vtable;\n\tconst char *refname;\n\tconst struct object_id *oid;\n\tunsigned int flags;\n};\n\n/*\n * Advance the iterator to the first or next item and return ITER_OK.\n * If the iteration is exhausted, free the resources associated with\n * the ref_iterator and return ITER_DONE. On errors, free the iterator\n * resources and return ITER_ERROR. It is a bug to use ref_iterator or\n * call this function again after it has returned ITER_DONE or\n * ITER_ERROR.\n */\nint ref_iterator_advance(struct ref_iterator *ref_iterator);\n\n/*\n * If possible, peel the reference currently being viewed by the\n * iterator. Return 0 on success.\n */\nint ref_iterator_peel(struct ref_iterator *ref_iterator,\n\t\t      struct object_id *peeled);\n\n/*\n * End the iteration before it has been exhausted, freeing the\n * reference iterator and any associated resources and returning\n * ITER_DONE. If the abort itself failed, return ITER_ERROR.\n */\nint ref_iterator_abort(struct ref_iterator *ref_iterator);\n\n/*\n * An iterator over nothing (its first ref_iterator_advance() call\n * returns ITER_DONE).\n */\nstruct ref_iterator *empty_ref_iterator_begin(void);\n\n/*\n * Return true iff ref_iterator is an empty_ref_iterator.\n */\nint is_empty_ref_iterator(struct ref_iterator *ref_iterator);\n\n/*\n * A callback function used to instruct merge_ref_iterator how to\n * interleave the entries from iter0 and iter1. The function should\n * return one of the constants defined in enum iterator_selection. It\n * must not advance either of the iterators itself.\n *\n * The function must be prepared to handle the case that iter0 and/or\n * iter1 is NULL, which indicates that the corresponding sub-iterator\n * has been exhausted. Its return value must be consistent with the\n * current states of the iterators; e.g., it must not return\n * ITER_SKIP_1 if iter1 has already been exhausted.\n */\ntypedef enum iterator_selection ref_iterator_select_fn(\n\t\tstruct ref_iterator *iter0, struct ref_iterator *iter1,\n\t\tvoid *cb_data);\n\n/*\n * Iterate over the entries from iter0 and iter1, with the values\n * interleaved as directed by the select function. The iterator takes\n * ownership of iter0 and iter1 and frees them when the iteration is\n * over.\n */\nstruct ref_iterator *merge_ref_iterator_begin(\n\t\tstruct ref_iterator *iter0, struct ref_iterator *iter1,\n\t\tref_iterator_select_fn *select, void *cb_data);\n\n/*\n * An iterator consisting of the union of the entries from front and\n * back. If there are entries common to the two sub-iterators, use the\n * one from front. Each iterator must iterate over its entries in\n * strcmp() order by refname for this to work.\n *\n * The new iterator takes ownership of its arguments and frees them\n * when the iteration is over. As a convenience to callers, if front\n * or back is an empty_ref_iterator, then abort that one immediately\n * and return the other iterator directly, without wrapping it.\n */\nstruct ref_iterator *overlay_ref_iterator_begin(\n\t\tstruct ref_iterator *front, struct ref_iterator *back);\n\n/*\n * Wrap iter0, only letting through the references whose names start\n * with prefix. If trim is set, set iter->refname to the name of the\n * reference with that many characters trimmed off the front;\n * otherwise set it to the full refname. The new iterator takes over\n * ownership of iter0 and frees it when iteration is over. It makes\n * its own copy of prefix.\n *\n * As an convenience to callers, if prefix is the empty string and\n * trim is zero, this function returns iter0 directly, without\n * wrapping it.\n */\nstruct ref_iterator *prefix_ref_iterator_begin(struct ref_iterator *iter0,\n\t\t\t\t\t       const char *prefix,\n\t\t\t\t\t       int trim);\n\n/* Internal implementation of reference iteration: */\n\n/*\n * Base class constructor for ref_iterators. Initialize the\n * ref_iterator part of iter, setting its vtable pointer as specified.\n * This is meant to be called only by the initializers of derived\n * classes.\n */\nvoid base_ref_iterator_init(struct ref_iterator *iter,\n\t\t\t    struct ref_iterator_vtable *vtable);\n\n/*\n * Base class destructor for ref_iterators. Destroy the ref_iterator\n * part of iter and shallow-free the object. This is meant to be\n * called only by the destructors of derived classes.\n */\nvoid base_ref_iterator_free(struct ref_iterator *iter);\n\n/* Virtual function declarations for ref_iterators: */\n\ntypedef int ref_iterator_advance_fn(struct ref_iterator *ref_iterator);\n\ntypedef int ref_iterator_peel_fn(struct ref_iterator *ref_iterator,\n\t\t\t\t struct object_id *peeled);\n\n/*\n * Implementations of this function should free any resources specific\n * to the derived class, then call base_ref_iterator_free() to clean\n * up and free the ref_iterator object.\n */\ntypedef int ref_iterator_abort_fn(struct ref_iterator *ref_iterator);\n\nstruct ref_iterator_vtable {\n\tref_iterator_advance_fn *advance;\n\tref_iterator_peel_fn *peel;\n\tref_iterator_abort_fn *abort;\n};\n\n/*\n * current_ref_iter is a performance hack: when iterating over\n * references using the for_each_ref*() functions, current_ref_iter is\n * set to the reference iterator before calling the callback function.\n * If the callback function calls peel_ref(), then peel_ref() first\n * checks whether the reference to be peeled is the one referred to by\n * the iterator (it usually is) and if so, asks the iterator for the\n * peeled version of the reference if it is available. This avoids a\n * refname lookup in a common case. current_ref_iter is set to NULL\n * when the iteration is over.\n */\nextern struct ref_iterator *current_ref_iter;\n\n/*\n * The common backend for the for_each_*ref* functions. Call fn for\n * each reference in iter. If the iterator itself ever returns\n * ITER_ERROR, return -1. If fn ever returns a non-zero value, stop\n * the iteration and return that value. Otherwise, return 0. In any\n * case, free the iterator when done. This function is basically an\n * adapter between the callback style of reference iteration and the\n * iterator style.\n */\nint do_for_each_ref_iterator(struct ref_iterator *iter,\n\t\t\t     each_ref_fn fn, void *cb_data);\n\n/*\n * Only include per-worktree refs in a do_for_each_ref*() iteration.\n * Normally this will be used with a files ref_store, since that's\n * where all reference backends will presumably store their\n * per-worktree refs.\n */\n#define DO_FOR_EACH_PER_WORKTREE_ONLY 0x02\n\nstruct ref_store;\n\n/* refs backends */\n\n/*\n * Initialize the ref_store for the specified submodule, or for the\n * main repository if submodule == NULL. These functions should call\n * base_ref_store_init() to initialize the shared part of the\n * ref_store and to record the ref_store for later lookup.\n */\ntypedef struct ref_store *ref_store_init_fn(const char *submodule);\n\ntypedef int ref_init_db_fn(struct ref_store *refs, struct strbuf *err);\n\ntypedef int ref_transaction_commit_fn(struct ref_store *refs,\n\t\t\t\t      struct ref_transaction *transaction,\n\t\t\t\t      struct strbuf *err);\n\ntypedef int pack_refs_fn(struct ref_store *ref_store, unsigned int flags);\ntypedef int peel_ref_fn(struct ref_store *ref_store,\n\t\t\tconst char *refname, unsigned char *sha1);\ntypedef int create_symref_fn(struct ref_store *ref_store,\n\t\t\t     const char *ref_target,\n\t\t\t     const char *refs_heads_master,\n\t\t\t     const char *logmsg);\ntypedef int delete_refs_fn(struct ref_store *ref_store,\n\t\t\t   struct string_list *refnames, unsigned int flags);\ntypedef int rename_ref_fn(struct ref_store *ref_store,\n\t\t\t  const char *oldref, const char *newref,\n\t\t\t  const char *logmsg);\n\n/*\n * Iterate over the references in the specified ref_store that are\n * within find_containing_dir(prefix). If prefix is NULL or the empty\n * string, iterate over all references in the submodule.\n */\ntypedef struct ref_iterator *ref_iterator_begin_fn(\n\t\tstruct ref_store *ref_store,\n\t\tconst char *prefix, unsigned int flags);\n\n/* reflog functions */\n\n/*\n * Iterate over the references in the specified ref_store that have a\n * reflog. The refs are iterated over in arbitrary order.\n */\ntypedef struct ref_iterator *reflog_iterator_begin_fn(\n\t\tstruct ref_store *ref_store);\n\ntypedef int for_each_reflog_ent_fn(struct ref_store *ref_store,\n\t\t\t\t   const char *refname,\n\t\t\t\t   each_reflog_ent_fn fn,\n\t\t\t\t   void *cb_data);\ntypedef int for_each_reflog_ent_reverse_fn(struct ref_store *ref_store,\n\t\t\t\t\t   const char *refname,\n\t\t\t\t\t   each_reflog_ent_fn fn,\n\t\t\t\t\t   void *cb_data);\ntypedef int reflog_exists_fn(struct ref_store *ref_store, const char *refname);\ntypedef int create_reflog_fn(struct ref_store *ref_store, const char *refname,\n\t\t\t     int force_create, struct strbuf *err);\ntypedef int delete_reflog_fn(struct ref_store *ref_store, const char *refname);\ntypedef int reflog_expire_fn(struct ref_store *ref_store,\n\t\t\t     const char *refname, const unsigned char *sha1,\n\t\t\t     unsigned int flags,\n\t\t\t     reflog_expiry_prepare_fn prepare_fn,\n\t\t\t     reflog_expiry_should_prune_fn should_prune_fn,\n\t\t\t     reflog_expiry_cleanup_fn cleanup_fn,\n\t\t\t     void *policy_cb_data);\n\n/*\n * Read a reference from the specified reference store, non-recursively.\n * Set type to describe the reference, and:\n *\n * - If refname is the name of a normal reference, fill in sha1\n *   (leaving referent unchanged).\n *\n * - If refname is the name of a symbolic reference, write the full\n *   name of the reference to which it refers (e.g.\n *   \"refs/heads/master\") to referent and set the REF_ISSYMREF bit in\n *   type (leaving sha1 unchanged). The caller is responsible for\n *   validating that referent is a valid reference name.\n *\n * WARNING: refname might be used as part of a filename, so it is\n * important from a security standpoint that it be safe in the sense\n * of refname_is_safe(). Moreover, for symrefs this function sets\n * referent to whatever the repository says, which might not be a\n * properly-formatted or even safe reference name. NEITHER INPUT NOR\n * OUTPUT REFERENCE NAMES ARE VALIDATED WITHIN THIS FUNCTION.\n *\n * Return 0 on success. If the ref doesn't exist, set errno to ENOENT\n * and return -1. If the ref exists but is neither a symbolic ref nor\n * a sha1, it is broken; set REF_ISBROKEN in type, set errno to\n * EINVAL, and return -1. If there is another error reading the ref,\n * set errno appropriately and return -1.\n *\n * Backend-specific flags might be set in type as well, regardless of\n * outcome.\n *\n * It is OK for refname to point into referent. If so:\n *\n * - if the function succeeds with REF_ISSYMREF, referent will be\n *   overwritten and the memory formerly pointed to by it might be\n *   changed or even freed.\n *\n * - in all other cases, referent will be untouched, and therefore\n *   refname will still be valid and unchanged.\n */\ntypedef int read_raw_ref_fn(struct ref_store *ref_store,\n\t\t\t    const char *refname, unsigned char *sha1,\n\t\t\t    struct strbuf *referent, unsigned int *type);\n\ntypedef int verify_refname_available_fn(struct ref_store *ref_store,\n\t\t\t\t\tconst char *newname,\n\t\t\t\t\tconst struct string_list *extras,\n\t\t\t\t\tconst struct string_list *skip,\n\t\t\t\t\tstruct strbuf *err);\n\nstruct ref_storage_be {\n\tstruct ref_storage_be *next;\n\tconst char *name;\n\tref_store_init_fn *init;\n\tref_init_db_fn *init_db;\n\tref_transaction_commit_fn *transaction_commit;\n\tref_transaction_commit_fn *initial_transaction_commit;\n\n\tpack_refs_fn *pack_refs;\n\tpeel_ref_fn *peel_ref;\n\tcreate_symref_fn *create_symref;\n\tdelete_refs_fn *delete_refs;\n\trename_ref_fn *rename_ref;\n\n\tref_iterator_begin_fn *iterator_begin;\n\tread_raw_ref_fn *read_raw_ref;\n\tverify_refname_available_fn *verify_refname_available;\n\n\treflog_iterator_begin_fn *reflog_iterator_begin;\n\tfor_each_reflog_ent_fn *for_each_reflog_ent;\n\tfor_each_reflog_ent_reverse_fn *for_each_reflog_ent_reverse;\n\treflog_exists_fn *reflog_exists;\n\tcreate_reflog_fn *create_reflog;\n\tdelete_reflog_fn *delete_reflog;\n\treflog_expire_fn *reflog_expire;\n};\n\nextern struct ref_storage_be refs_be_files;\n\n/*\n * A representation of the reference store for the main repository or\n * a submodule. The ref_store instances for submodules are kept in a\n * linked list.\n */\nstruct ref_store {\n\t/* The backend describing this ref_store's storage scheme: */\n\tconst struct ref_storage_be *be;\n};\n\n/*\n * Fill in the generic part of refs for the specified submodule and\n * add it to our collection of reference stores.\n */\nvoid base_ref_store_init(struct ref_store *refs,\n\t\t\t const struct ref_storage_be *be,\n\t\t\t const char *submodule);\n\n/*\n * Return the ref_store instance for the specified submodule. For the\n * main repository, use submodule==NULL; such a call cannot fail. For\n * a submodule, the submodule must exist and be a nonbare repository,\n * otherwise return NULL. If the requested reference store has not yet\n * been initialized, initialize it first.\n *\n * For backwards compatibility, submodule==\"\" is treated the same as\n * submodule==NULL.\n */\nstruct ref_store *get_ref_store(const char *submodule);\n\n#endif /* REFS_REFS_INTERNAL_H */\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "008822d67ccedd367fe010a261563adcca99227f",
  "sha1_ok": true,
  "size": 23434
}
