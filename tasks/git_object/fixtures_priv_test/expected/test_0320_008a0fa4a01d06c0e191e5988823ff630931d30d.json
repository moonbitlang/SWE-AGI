{
  "content": {
    "base64": "I2lmbmRlZiBDT01NSVRfSAojZGVmaW5lIENPTU1JVF9ICgojaW5jbHVkZSAib2JqZWN0LmgiCiNpbmNsdWRlICJ0cmVlLmgiCiNpbmNsdWRlICJzdHJidWYuaCIKI2luY2x1ZGUgImRlY29yYXRlLmgiCiNpbmNsdWRlICJncGctaW50ZXJmYWNlLmgiCiNpbmNsdWRlICJzdHJpbmctbGlzdC5oIgojaW5jbHVkZSAicHJldHR5LmgiCiNpbmNsdWRlICJjb21taXQtc2xhYi5oIgoKI2RlZmluZSBDT01NSVRfTk9UX0ZST01fR1JBUEggMHhGRkZGRkZGRgojZGVmaW5lIEdFTkVSQVRJT05fTlVNQkVSX0lORklOSVRZIDB4RkZGRkZGRkYKI2RlZmluZSBHRU5FUkFUSU9OX05VTUJFUl9NQVggMHgzRkZGRkZGRgojZGVmaW5lIEdFTkVSQVRJT05fTlVNQkVSX1pFUk8gMAoKc3RydWN0IGNvbW1pdF9saXN0IHsKCXN0cnVjdCBjb21taXQgKml0ZW07CglzdHJ1Y3QgY29tbWl0X2xpc3QgKm5leHQ7Cn07CgovKgogKiBUaGUgc2l6ZSBvZiB0aGlzIHN0cnVjdCBtYXR0ZXJzIGluIGZ1bGwgcmVwbyB3YWxrIG9wZXJhdGlvbnMgbGlrZQogKiAnZ2l0IGNsb25lJyBvciAnZ2l0IGdjJy4gQ29uc2lkZXIgdXNpbmcgY29tbWl0LXNsYWIgdG8gYXR0YWNoIGRhdGEKICogdG8gYSBjb21taXQgaW5zdGVhZCBvZiBhZGRpbmcgbmV3IGZpZWxkcyBoZXJlLgogKi8Kc3RydWN0IGNvbW1pdCB7CglzdHJ1Y3Qgb2JqZWN0IG9iamVjdDsKCXRpbWVzdGFtcF90IGRhdGU7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKnBhcmVudHM7CgoJLyoKCSAqIElmIHRoZSBjb21taXQgaXMgbG9hZGVkIGZyb20gdGhlIGNvbW1pdC1ncmFwaCBmaWxlLCB0aGVuIHRoaXMKCSAqIG1lbWJlciBtYXkgYmUgTlVMTC4gT25seSBhY2Nlc3MgaXQgdGhyb3VnaCByZXBvX2dldF9jb21taXRfdHJlZSgpCgkgKiBvciBnZXRfY29tbWl0X3RyZWVfb2lkKCkuCgkgKi8KCXN0cnVjdCB0cmVlICptYXliZV90cmVlOwoJdWludDMyX3QgZ3JhcGhfcG9zOwoJdWludDMyX3QgZ2VuZXJhdGlvbjsKCXVuc2lnbmVkIGludCBpbmRleDsKfTsKCmV4dGVybiBpbnQgc2F2ZV9jb21taXRfYnVmZmVyOwpleHRlcm4gY29uc3QgY2hhciAqY29tbWl0X3R5cGU7CgovKiBXaGlsZSB3ZSBjYW4gZGVjb3JhdGUgYW55IG9iamVjdCB3aXRoIGEgbmFtZSwgaXQncyBvbmx5IHVzZWQgZm9yIGNvbW1pdHMuLiAqLwpzdHJ1Y3QgbmFtZV9kZWNvcmF0aW9uIHsKCXN0cnVjdCBuYW1lX2RlY29yYXRpb24gKm5leHQ7CglpbnQgdHlwZTsKCWNoYXIgbmFtZVtGTEVYX0FSUkFZXTsKfTsKCmVudW0gZGVjb3JhdGlvbl90eXBlIHsKCURFQ09SQVRJT05fTk9ORSA9IDAsCglERUNPUkFUSU9OX1JFRl9MT0NBTCwKCURFQ09SQVRJT05fUkVGX1JFTU9URSwKCURFQ09SQVRJT05fUkVGX1RBRywKCURFQ09SQVRJT05fUkVGX1NUQVNILAoJREVDT1JBVElPTl9SRUZfSEVBRCwKCURFQ09SQVRJT05fR1JBRlRFRCwKfTsKCnZvaWQgYWRkX25hbWVfZGVjb3JhdGlvbihlbnVtIGRlY29yYXRpb25fdHlwZSB0eXBlLCBjb25zdCBjaGFyICpuYW1lLCBzdHJ1Y3Qgb2JqZWN0ICpvYmopOwpjb25zdCBzdHJ1Y3QgbmFtZV9kZWNvcmF0aW9uICpnZXRfbmFtZV9kZWNvcmF0aW9uKGNvbnN0IHN0cnVjdCBvYmplY3QgKm9iaik7CgpzdHJ1Y3QgY29tbWl0ICpsb29rdXBfY29tbWl0KHN0cnVjdCByZXBvc2l0b3J5ICpyLCBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQpOwpzdHJ1Y3QgY29tbWl0ICpsb29rdXBfY29tbWl0X3JlZmVyZW5jZShzdHJ1Y3QgcmVwb3NpdG9yeSAqciwKCQkJCSAgICAgICBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQpOwpzdHJ1Y3QgY29tbWl0ICpsb29rdXBfY29tbWl0X3JlZmVyZW5jZV9nZW50bHkoc3RydWN0IHJlcG9zaXRvcnkgKnIsCgkJCQkJICAgICAgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLAoJCQkJCSAgICAgIGludCBxdWlldCk7CnN0cnVjdCBjb21taXQgKmxvb2t1cF9jb21taXRfcmVmZXJlbmNlX2J5X25hbWUoY29uc3QgY2hhciAqbmFtZSk7CgovKgogKiBMb29rIHVwIG9iamVjdCBuYW1lZCBieSAib2lkIiwgZGVyZWZlcmVuY2UgdGFnIGFzIG5lY2Vzc2FyeSwKICogZ2V0IGEgY29tbWl0IGFuZCByZXR1cm4gaXQuIElmICJvaWQiIGRvZXMgbm90IGRlcmVmZXJlbmNlIHRvCiAqIGEgY29tbWl0LCB1c2UgcmVmX25hbWUgdG8gcmVwb3J0IGFuIGVycm9yIGFuZCBkaWUuCiAqLwpzdHJ1Y3QgY29tbWl0ICpsb29rdXBfY29tbWl0X29yX2RpZShjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsIGNvbnN0IGNoYXIgKnJlZl9uYW1lKTsKCmludCBwYXJzZV9jb21taXRfYnVmZmVyKHN0cnVjdCByZXBvc2l0b3J5ICpyLCBzdHJ1Y3QgY29tbWl0ICppdGVtLCBjb25zdCB2b2lkICpidWZmZXIsIHVuc2lnbmVkIGxvbmcgc2l6ZSwgaW50IGNoZWNrX2dyYXBoKTsKaW50IHJlcG9fcGFyc2VfY29tbWl0X2ludGVybmFsKHN0cnVjdCByZXBvc2l0b3J5ICpyLCBzdHJ1Y3QgY29tbWl0ICppdGVtLAoJCQkgICAgICAgaW50IHF1aWV0X29uX21pc3NpbmcsIGludCB1c2VfY29tbWl0X2dyYXBoKTsKaW50IHJlcG9fcGFyc2VfY29tbWl0X2dlbnRseShzdHJ1Y3QgcmVwb3NpdG9yeSAqciwKCQkJICAgICBzdHJ1Y3QgY29tbWl0ICppdGVtLAoJCQkgICAgIGludCBxdWlldF9vbl9taXNzaW5nKTsKc3RhdGljIGlubGluZSBpbnQgcmVwb19wYXJzZV9jb21taXQoc3RydWN0IHJlcG9zaXRvcnkgKnIsIHN0cnVjdCBjb21taXQgKml0ZW0pCnsKCXJldHVybiByZXBvX3BhcnNlX2NvbW1pdF9nZW50bHkociwgaXRlbSwgMCk7Cn0KCnN0YXRpYyBpbmxpbmUgaW50IHBhcnNlX2NvbW1pdF9ub19ncmFwaChzdHJ1Y3QgY29tbWl0ICpjb21taXQpCnsKCXJldHVybiByZXBvX3BhcnNlX2NvbW1pdF9pbnRlcm5hbCh0aGVfcmVwb3NpdG9yeSwgY29tbWl0LCAwLCAwKTsKfQoKI2lmbmRlZiBOT19USEVfUkVQT1NJVE9SWV9DT01QQVRJQklMSVRZX01BQ1JPUwojZGVmaW5lIHBhcnNlX2NvbW1pdF9pbnRlcm5hbChpdGVtLCBxdWlldCwgdXNlKSByZXBvX3BhcnNlX2NvbW1pdF9pbnRlcm5hbCh0aGVfcmVwb3NpdG9yeSwgaXRlbSwgcXVpZXQsIHVzZSkKI2RlZmluZSBwYXJzZV9jb21taXRfZ2VudGx5KGl0ZW0sIHF1aWV0KSByZXBvX3BhcnNlX2NvbW1pdF9nZW50bHkodGhlX3JlcG9zaXRvcnksIGl0ZW0sIHF1aWV0KQojZGVmaW5lIHBhcnNlX2NvbW1pdChpdGVtKSByZXBvX3BhcnNlX2NvbW1pdCh0aGVfcmVwb3NpdG9yeSwgaXRlbSkKI2VuZGlmCgp2b2lkIHBhcnNlX2NvbW1pdF9vcl9kaWUoc3RydWN0IGNvbW1pdCAqaXRlbSk7CgpzdHJ1Y3QgYnVmZmVyX3NsYWI7CnN0cnVjdCBidWZmZXJfc2xhYiAqYWxsb2NhdGVfY29tbWl0X2J1ZmZlcl9zbGFiKHZvaWQpOwp2b2lkIGZyZWVfY29tbWl0X2J1ZmZlcl9zbGFiKHN0cnVjdCBidWZmZXJfc2xhYiAqYnMpOwoKLyoKICogQXNzb2NpYXRlIGFuIG9iamVjdCBidWZmZXIgd2l0aCB0aGUgY29tbWl0LiBUaGUgb3duZXJzaGlwIG9mIHRoZQogKiBtZW1vcnkgaXMgaGFuZGVkIG92ZXIgdG8gdGhlIGNvbW1pdCwgYW5kIG11c3QgYmUgZnJlZSgpLWFibGUuCiAqLwp2b2lkIHNldF9jb21taXRfYnVmZmVyKHN0cnVjdCByZXBvc2l0b3J5ICpyLCBzdHJ1Y3QgY29tbWl0ICosIHZvaWQgKmJ1ZmZlciwgdW5zaWduZWQgbG9uZyBzaXplKTsKCi8qCiAqIEdldCBhbnkgY2FjaGVkIG9iamVjdCBidWZmZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBjb21taXQuIFJldHVybnMgTlVMTAogKiBpZiBub25lLiBUaGUgcmVzdWx0aW5nIG1lbW9yeSBzaG91bGQgbm90IGJlIGZyZWVkLgogKi8KY29uc3Qgdm9pZCAqZ2V0X2NhY2hlZF9jb21taXRfYnVmZmVyKHN0cnVjdCByZXBvc2l0b3J5ICosIGNvbnN0IHN0cnVjdCBjb21taXQgKiwgdW5zaWduZWQgbG9uZyAqc2l6ZSk7CgovKgogKiBHZXQgdGhlIGNvbW1pdCdzIG9iamVjdCBjb250ZW50cywgZWl0aGVyIGZyb20gY2FjaGUgb3IgYnkgcmVhZGluZyB0aGUgb2JqZWN0CiAqIGZyb20gZGlzay4gVGhlIHJlc3VsdGluZyBtZW1vcnkgc2hvdWxkIG5vdCBiZSBtb2RpZmllZCwgYW5kIG11c3QgYmUgZ2l2ZW4KICogdG8gdW51c2VfY29tbWl0X2J1ZmZlciB3aGVuIHRoZSBjYWxsZXIgaXMgZG9uZS4KICovCmNvbnN0IHZvaWQgKnJlcG9fZ2V0X2NvbW1pdF9idWZmZXIoc3RydWN0IHJlcG9zaXRvcnkgKnIsCgkJCQkgICBjb25zdCBzdHJ1Y3QgY29tbWl0ICosCgkJCQkgICB1bnNpZ25lZCBsb25nICpzaXplKTsKI2lmbmRlZiBOT19USEVfUkVQT1NJVE9SWV9DT01QQVRJQklMSVRZX01BQ1JPUwojZGVmaW5lIGdldF9jb21taXRfYnVmZmVyKGMsIHMpIHJlcG9fZ2V0X2NvbW1pdF9idWZmZXIodGhlX3JlcG9zaXRvcnksIGMsIHMpCiNlbmRpZgoKLyoKICogVGVsbCB0aGUgY29tbWl0IHN1YnN5c3RlbSB0aGF0IHdlIGFyZSBkb25lIHdpdGggYSBwYXJ0aWN1bGFyIGNvbW1pdCBidWZmZXIuCiAqIFRoZSBjb21taXQgYW5kIGJ1ZmZlciBzaG91bGQgYmUgdGhlIGlucHV0IGFuZCByZXR1cm4gdmFsdWUsIHJlc3BlY3RpdmVseSwKICogZnJvbSBhbiBlYXJsaWVyIGNhbGwgdG8gZ2V0X2NvbW1pdF9idWZmZXIuICBUaGUgYnVmZmVyIG1heSBvciBtYXkgbm90IGJlCiAqIGZyZWVkIGJ5IHRoaXMgY2FsbDsgY2FsbGVycyBzaG91bGQgbm90IGFjY2VzcyB0aGUgbWVtb3J5IGFmdGVyd2FyZHMuCiAqLwp2b2lkIHJlcG9fdW51c2VfY29tbWl0X2J1ZmZlcihzdHJ1Y3QgcmVwb3NpdG9yeSAqciwKCQkJICAgICAgY29uc3Qgc3RydWN0IGNvbW1pdCAqLAoJCQkgICAgICBjb25zdCB2b2lkICpidWZmZXIpOwojaWZuZGVmIE5PX1RIRV9SRVBPU0lUT1JZX0NPTVBBVElCSUxJVFlfTUFDUk9TCiNkZWZpbmUgdW51c2VfY29tbWl0X2J1ZmZlcihjLCBiKSByZXBvX3VudXNlX2NvbW1pdF9idWZmZXIodGhlX3JlcG9zaXRvcnksIGMsIGIpCiNlbmRpZgoKLyoKICogRnJlZSBhbnkgY2FjaGVkIG9iamVjdCBidWZmZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBjb21taXQuCiAqLwp2b2lkIGZyZWVfY29tbWl0X2J1ZmZlcihzdHJ1Y3QgcGFyc2VkX29iamVjdF9wb29sICpwb29sLCBzdHJ1Y3QgY29tbWl0ICopOwoKc3RydWN0IHRyZWUgKnJlcG9fZ2V0X2NvbW1pdF90cmVlKHN0cnVjdCByZXBvc2l0b3J5ICosIGNvbnN0IHN0cnVjdCBjb21taXQgKik7CiNkZWZpbmUgZ2V0X2NvbW1pdF90cmVlKGMpIHJlcG9fZ2V0X2NvbW1pdF90cmVlKHRoZV9yZXBvc2l0b3J5LCBjKQpzdHJ1Y3Qgb2JqZWN0X2lkICpnZXRfY29tbWl0X3RyZWVfb2lkKGNvbnN0IHN0cnVjdCBjb21taXQgKik7CgovKgogKiBSZWxlYXNlIG1lbW9yeSByZWxhdGVkIHRvIGEgY29tbWl0LCBpbmNsdWRpbmcgdGhlIHBhcmVudCBsaXN0IGFuZAogKiBhbnkgY2FjaGVkIG9iamVjdCBidWZmZXIuCiAqLwp2b2lkIHJlbGVhc2VfY29tbWl0X21lbW9yeShzdHJ1Y3QgcGFyc2VkX29iamVjdF9wb29sICpwb29sLCBzdHJ1Y3QgY29tbWl0ICpjKTsKCi8qCiAqIERpc2Fzc29jaWF0ZSBhbnkgY2FjaGVkIG9iamVjdCBidWZmZXIgZnJvbSB0aGUgY29tbWl0LCBidXQgZG8gbm90IGZyZWUgaXQuCiAqIFRoZSBidWZmZXIgKG9yIE5VTEwsIGlmIG5vbmUpIGlzIHJldHVybmVkLgogKi8KY29uc3Qgdm9pZCAqZGV0YWNoX2NvbW1pdF9idWZmZXIoc3RydWN0IGNvbW1pdCAqLCB1bnNpZ25lZCBsb25nICpzaXplcCk7CgovKiBGaW5kIGJlZ2lubmluZyBhbmQgbGVuZ3RoIG9mIGNvbW1pdCBzdWJqZWN0LiAqLwppbnQgZmluZF9jb21taXRfc3ViamVjdChjb25zdCBjaGFyICpjb21taXRfYnVmZmVyLCBjb25zdCBjaGFyICoqc3ViamVjdCk7CgpzdHJ1Y3QgY29tbWl0X2xpc3QgKmNvbW1pdF9saXN0X2luc2VydChzdHJ1Y3QgY29tbWl0ICppdGVtLAoJCQkJCXN0cnVjdCBjb21taXRfbGlzdCAqKmxpc3QpOwpzdHJ1Y3QgY29tbWl0X2xpc3QgKipjb21taXRfbGlzdF9hcHBlbmQoc3RydWN0IGNvbW1pdCAqY29tbWl0LAoJCQkJCXN0cnVjdCBjb21taXRfbGlzdCAqKm5leHQpOwp1bnNpZ25lZCBjb21taXRfbGlzdF9jb3VudChjb25zdCBzdHJ1Y3QgY29tbWl0X2xpc3QgKmwpOwpzdHJ1Y3QgY29tbWl0X2xpc3QgKmNvbW1pdF9saXN0X2luc2VydF9ieV9kYXRlKHN0cnVjdCBjb21taXQgKml0ZW0sCgkJCQkgICAgc3RydWN0IGNvbW1pdF9saXN0ICoqbGlzdCk7CnZvaWQgY29tbWl0X2xpc3Rfc29ydF9ieV9kYXRlKHN0cnVjdCBjb21taXRfbGlzdCAqKmxpc3QpOwoKLyogU2hhbGxvdyBjb3B5IG9mIHRoZSBpbnB1dCBsaXN0ICovCnN0cnVjdCBjb21taXRfbGlzdCAqY29weV9jb21taXRfbGlzdChzdHJ1Y3QgY29tbWl0X2xpc3QgKmxpc3QpOwoKdm9pZCBmcmVlX2NvbW1pdF9saXN0KHN0cnVjdCBjb21taXRfbGlzdCAqbGlzdCk7CgpzdHJ1Y3QgcmV2X2luZm87IC8qIGluIHJldmlzaW9uLmgsIGl0IGNpcmN1bGFybHkgdXNlcyBlbnVtIGNtaXRfZm10ICovCgppbnQgaGFzX25vbl9hc2NpaShjb25zdCBjaGFyICp0ZXh0KTsKY29uc3QgY2hhciAqbG9nbXNnX3JlZW5jb2RlKGNvbnN0IHN0cnVjdCBjb21taXQgKmNvbW1pdCwKCQkJICAgIGNoYXIgKipjb21taXRfZW5jb2RpbmcsCgkJCSAgICBjb25zdCBjaGFyICpvdXRwdXRfZW5jb2RpbmcpOwpjb25zdCBjaGFyICpyZXBvX2xvZ21zZ19yZWVuY29kZShzdHJ1Y3QgcmVwb3NpdG9yeSAqciwKCQkJCSBjb25zdCBzdHJ1Y3QgY29tbWl0ICpjb21taXQsCgkJCQkgY2hhciAqKmNvbW1pdF9lbmNvZGluZywKCQkJCSBjb25zdCBjaGFyICpvdXRwdXRfZW5jb2RpbmcpOwojaWZuZGVmIE5PX1RIRV9SRVBPU0lUT1JZX0NPTVBBVElCSUxJVFlfTUFDUk9TCiNkZWZpbmUgbG9nbXNnX3JlZW5jb2RlKGMsIGVuYywgb3V0KSByZXBvX2xvZ21zZ19yZWVuY29kZSh0aGVfcmVwb3NpdG9yeSwgYywgZW5jLCBvdXQpCiNlbmRpZgoKY29uc3QgY2hhciAqc2tpcF9ibGFua19saW5lcyhjb25zdCBjaGFyICptc2cpOwoKLyoqIFJlbW92ZXMgdGhlIGZpcnN0IGNvbW1pdCBmcm9tIGEgbGlzdCBzb3J0ZWQgYnkgZGF0ZSwgYW5kIGFkZHMgYWxsCiAqIG9mIGl0cyBwYXJlbnRzLgogKiovCnN0cnVjdCBjb21taXQgKnBvcF9tb3N0X3JlY2VudF9jb21taXQoc3RydWN0IGNvbW1pdF9saXN0ICoqbGlzdCwKCQkJCSAgICAgIHVuc2lnbmVkIGludCBtYXJrKTsKCnN0cnVjdCBjb21taXQgKnBvcF9jb21taXQoc3RydWN0IGNvbW1pdF9saXN0ICoqc3RhY2spOwoKdm9pZCBjbGVhcl9jb21taXRfbWFya3Moc3RydWN0IGNvbW1pdCAqY29tbWl0LCB1bnNpZ25lZCBpbnQgbWFyayk7CnZvaWQgY2xlYXJfY29tbWl0X21hcmtzX21hbnkoaW50IG5yLCBzdHJ1Y3QgY29tbWl0ICoqY29tbWl0LCB1bnNpZ25lZCBpbnQgbWFyayk7CgoKZW51bSByZXZfc29ydF9vcmRlciB7CglSRVZfU09SVF9JTl9HUkFQSF9PUkRFUiA9IDAsCglSRVZfU09SVF9CWV9DT01NSVRfREFURSwKCVJFVl9TT1JUX0JZX0FVVEhPUl9EQVRFCn07CgovKgogKiBQZXJmb3JtcyBhbiBpbi1wbGFjZSB0b3BvbG9naWNhbCBzb3J0IG9mIGxpc3Qgc3VwcGxpZWQuCiAqCiAqICAgaW52YXJpYW50IG9mIHJlc3VsdGluZyBsaXN0IGlzOgogKiAgICAgIGEgcmVhY2hhYmxlIGZyb20gYiA9PiBvcmQoYikgPCBvcmQoYSkKICogICBzb3J0X29yZGVyIGZ1cnRoZXIgc3BlY2lmaWVzOgogKiAgIFJFVl9TT1JUX0lOX0dSQVBIX09SREVSOiB0cnkgdG8gc2hvdyBhIGNvbW1pdCBvbiBhIHNpbmdsZS1wYXJlbnQKICogICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW4gdG9nZXRoZXIuCiAqICAgUkVWX1NPUlRfQllfQ09NTUlUX0RBVEU6IHNob3cgZWxpZ2libGUgY29tbWl0cyBpbiBjb21taXR0ZXItZGF0ZSBvcmRlci4KICovCnZvaWQgc29ydF9pbl90b3BvbG9naWNhbF9vcmRlcihzdHJ1Y3QgY29tbWl0X2xpc3QgKiosIGVudW0gcmV2X3NvcnRfb3JkZXIpOwoKc3RydWN0IGNvbW1pdF9ncmFmdCB7CglzdHJ1Y3Qgb2JqZWN0X2lkIG9pZDsKCWludCBucl9wYXJlbnQ7IC8qIDwgMCBpZiBzaGFsbG93IGNvbW1pdCAqLwoJc3RydWN0IG9iamVjdF9pZCBwYXJlbnRbRkxFWF9BUlJBWV07IC8qIG1vcmUgKi8KfTsKdHlwZWRlZiBpbnQgKCplYWNoX2NvbW1pdF9ncmFmdF9mbikoY29uc3Qgc3RydWN0IGNvbW1pdF9ncmFmdCAqLCB2b2lkICopOwoKc3RydWN0IGNvbW1pdF9ncmFmdCAqcmVhZF9ncmFmdF9saW5lKHN0cnVjdCBzdHJidWYgKmxpbmUpOwppbnQgcmVnaXN0ZXJfY29tbWl0X2dyYWZ0KHN0cnVjdCByZXBvc2l0b3J5ICpyLCBzdHJ1Y3QgY29tbWl0X2dyYWZ0ICosIGludCk7CnZvaWQgcHJlcGFyZV9jb21taXRfZ3JhZnQoc3RydWN0IHJlcG9zaXRvcnkgKnIpOwpzdHJ1Y3QgY29tbWl0X2dyYWZ0ICpsb29rdXBfY29tbWl0X2dyYWZ0KHN0cnVjdCByZXBvc2l0b3J5ICpyLCBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQpOwoKc3RydWN0IGNvbW1pdCAqZ2V0X2ZvcmtfcG9pbnQoY29uc3QgY2hhciAqcmVmbmFtZSwgc3RydWN0IGNvbW1pdCAqY29tbWl0KTsKCi8qIGxhcmdlc3QgcG9zaXRpdmUgbnVtYmVyIGEgc2lnbmVkIDMyLWJpdCBpbnRlZ2VyIGNhbiBjb250YWluICovCiNkZWZpbmUgSU5GSU5JVEVfREVQVEggMHg3ZmZmZmZmZgoKc3RydWN0IG9pZF9hcnJheTsKc3RydWN0IHJlZjsKaW50IHJlZ2lzdGVyX3NoYWxsb3coc3RydWN0IHJlcG9zaXRvcnkgKnIsIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCk7CmludCB1bnJlZ2lzdGVyX3NoYWxsb3coY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkKTsKaW50IGZvcl9lYWNoX2NvbW1pdF9ncmFmdChlYWNoX2NvbW1pdF9ncmFmdF9mbiwgdm9pZCAqKTsKaW50IGlzX3JlcG9zaXRvcnlfc2hhbGxvdyhzdHJ1Y3QgcmVwb3NpdG9yeSAqcik7CnN0cnVjdCBjb21taXRfbGlzdCAqZ2V0X3NoYWxsb3dfY29tbWl0cyhzdHJ1Y3Qgb2JqZWN0X2FycmF5ICpoZWFkcywKCQkJCQlpbnQgZGVwdGgsIGludCBzaGFsbG93X2ZsYWcsIGludCBub3Rfc2hhbGxvd19mbGFnKTsKc3RydWN0IGNvbW1pdF9saXN0ICpnZXRfc2hhbGxvd19jb21taXRzX2J5X3Jldl9saXN0KAoJCWludCBhYywgY29uc3QgY2hhciAqKmF2LCBpbnQgc2hhbGxvd19mbGFnLCBpbnQgbm90X3NoYWxsb3dfZmxhZyk7CnZvaWQgc2V0X2FsdGVybmF0ZV9zaGFsbG93X2ZpbGUoc3RydWN0IHJlcG9zaXRvcnkgKnIsIGNvbnN0IGNoYXIgKnBhdGgsIGludCBvdmVycmlkZSk7CmludCB3cml0ZV9zaGFsbG93X2NvbW1pdHMoc3RydWN0IHN0cmJ1ZiAqb3V0LCBpbnQgdXNlX3BhY2tfcHJvdG9jb2wsCgkJCSAgY29uc3Qgc3RydWN0IG9pZF9hcnJheSAqZXh0cmEpOwp2b2lkIHNldHVwX2FsdGVybmF0ZV9zaGFsbG93KHN0cnVjdCBsb2NrX2ZpbGUgKnNoYWxsb3dfbG9jaywKCQkJICAgICBjb25zdCBjaGFyICoqYWx0ZXJuYXRlX3NoYWxsb3dfZmlsZSwKCQkJICAgICBjb25zdCBzdHJ1Y3Qgb2lkX2FycmF5ICpleHRyYSk7CmNvbnN0IGNoYXIgKnNldHVwX3RlbXBvcmFyeV9zaGFsbG93KGNvbnN0IHN0cnVjdCBvaWRfYXJyYXkgKmV4dHJhKTsKdm9pZCBhZHZlcnRpc2Vfc2hhbGxvd19ncmFmdHMoaW50KTsKCi8qCiAqIEluaXRpYWxpemUgd2l0aCBwcmVwYXJlX3NoYWxsb3dfaW5mbygpIG9yIHplcm8taW5pdGlhbGl6ZSAoZXF1aXZhbGVudCB0bwogKiBwcmVwYXJlX3NoYWxsb3dfaW5mbyB3aXRoIGEgTlVMTCBvaWRfYXJyYXkpLgogKi8Kc3RydWN0IHNoYWxsb3dfaW5mbyB7CglzdHJ1Y3Qgb2lkX2FycmF5ICpzaGFsbG93OwoJaW50ICpvdXJzLCBucl9vdXJzOwoJaW50ICp0aGVpcnMsIG5yX3RoZWlyczsKCXN0cnVjdCBvaWRfYXJyYXkgKnJlZjsKCgkvKiBmb3IgcmVjZWl2ZS1wYWNrICovCgl1aW50MzJfdCAqKnVzZWRfc2hhbGxvdzsKCWludCAqbmVlZF9yZWFjaGFiaWxpdHlfdGVzdDsKCWludCAqcmVhY2hhYmxlOwoJaW50ICpzaGFsbG93X3JlZjsKCXN0cnVjdCBjb21taXQgKipjb21taXRzOwoJaW50IG5yX2NvbW1pdHM7Cn07Cgp2b2lkIHByZXBhcmVfc2hhbGxvd19pbmZvKHN0cnVjdCBzaGFsbG93X2luZm8gKiwgc3RydWN0IG9pZF9hcnJheSAqKTsKdm9pZCBjbGVhcl9zaGFsbG93X2luZm8oc3RydWN0IHNoYWxsb3dfaW5mbyAqKTsKdm9pZCByZW1vdmVfbm9uZXhpc3RlbnRfdGhlaXJzX3NoYWxsb3coc3RydWN0IHNoYWxsb3dfaW5mbyAqKTsKdm9pZCBhc3NpZ25fc2hhbGxvd19jb21taXRzX3RvX3JlZnMoc3RydWN0IHNoYWxsb3dfaW5mbyAqaW5mbywKCQkJCSAgICB1aW50MzJfdCAqKnVzZWQsCgkJCQkgICAgaW50ICpyZWZfc3RhdHVzKTsKaW50IGRlbGF5ZWRfcmVhY2hhYmlsaXR5X3Rlc3Qoc3RydWN0IHNoYWxsb3dfaW5mbyAqc2ksIGludCBjKTsKI2RlZmluZSBQUlVORV9TSE9XX09OTFkgMQojZGVmaW5lIFBSVU5FX1FVSUNLIDIKdm9pZCBwcnVuZV9zaGFsbG93KHVuc2lnbmVkIG9wdGlvbnMpOwpleHRlcm4gc3RydWN0IHRyYWNlX2tleSB0cmFjZV9zaGFsbG93OwoKaW50IGludGVyYWN0aXZlX2FkZChpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsIGNvbnN0IGNoYXIgKnByZWZpeCwgaW50IHBhdGNoKTsKaW50IHJ1bl9hZGRfaW50ZXJhY3RpdmUoY29uc3QgY2hhciAqcmV2aXNpb24sIGNvbnN0IGNoYXIgKnBhdGNoX21vZGUsCgkJCWNvbnN0IHN0cnVjdCBwYXRoc3BlYyAqcGF0aHNwZWMpOwoKc3RydWN0IGNvbW1pdF9leHRyYV9oZWFkZXIgewoJc3RydWN0IGNvbW1pdF9leHRyYV9oZWFkZXIgKm5leHQ7CgljaGFyICprZXk7CgljaGFyICp2YWx1ZTsKCXNpemVfdCBsZW47Cn07Cgp2b2lkIGFwcGVuZF9tZXJnZV90YWdfaGVhZGVycyhzdHJ1Y3QgY29tbWl0X2xpc3QgKnBhcmVudHMsCgkJCSAgICAgIHN0cnVjdCBjb21taXRfZXh0cmFfaGVhZGVyICoqKnRhaWwpOwoKaW50IGNvbW1pdF90cmVlKGNvbnN0IGNoYXIgKm1zZywgc2l6ZV90IG1zZ19sZW4sCgkJY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqdHJlZSwKCQlzdHJ1Y3QgY29tbWl0X2xpc3QgKnBhcmVudHMsIHN0cnVjdCBvYmplY3RfaWQgKnJldCwKCQljb25zdCBjaGFyICphdXRob3IsIGNvbnN0IGNoYXIgKnNpZ25fY29tbWl0KTsKCmludCBjb21taXRfdHJlZV9leHRlbmRlZChjb25zdCBjaGFyICptc2csIHNpemVfdCBtc2dfbGVuLAoJCQkgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqdHJlZSwKCQkJIHN0cnVjdCBjb21taXRfbGlzdCAqcGFyZW50cywKCQkJIHN0cnVjdCBvYmplY3RfaWQgKnJldCwgY29uc3QgY2hhciAqYXV0aG9yLAoJCQkgY29uc3QgY2hhciAqc2lnbl9jb21taXQsCgkJCSBzdHJ1Y3QgY29tbWl0X2V4dHJhX2hlYWRlciAqKTsKCnN0cnVjdCBjb21taXRfZXh0cmFfaGVhZGVyICpyZWFkX2NvbW1pdF9leHRyYV9oZWFkZXJzKHN0cnVjdCBjb21taXQgKiwgY29uc3QgY2hhciAqKik7Cgp2b2lkIGZyZWVfY29tbWl0X2V4dHJhX2hlYWRlcnMoc3RydWN0IGNvbW1pdF9leHRyYV9oZWFkZXIgKmV4dHJhKTsKCi8qCiAqIFNlYXJjaCB0aGUgY29tbWl0IG9iamVjdCBjb250ZW50cyBnaXZlbiBieSAibXNnIiBmb3IgdGhlIGhlYWRlciAia2V5Ii4KICogUmV0dXJucyBhIHBvaW50ZXIgdG8gdGhlIHN0YXJ0IG9mIHRoZSBoZWFkZXIgY29udGVudHMsIG9yIE5VTEwuIFRoZSBsZW5ndGgKICogb2YgdGhlIGhlYWRlciwgdXAgdG8gdGhlIGZpcnN0IG5ld2xpbmUsIGlzIHJldHVybmVkIHZpYSBvdXRfbGVuLgogKgogKiBOb3RlIHRoYXQgc29tZSBoZWFkZXJzIChsaWtlIG1lcmdldGFnKSBtYXkgYmUgbXVsdGktbGluZS4gSXQgaXMgdGhlIGNhbGxlcidzCiAqIHJlc3BvbnNpYmlsaXR5IHRvIHBhcnNlIGZ1cnRoZXIgaW4gdGhpcyBjYXNlIQogKi8KY29uc3QgY2hhciAqZmluZF9jb21taXRfaGVhZGVyKGNvbnN0IGNoYXIgKm1zZywgY29uc3QgY2hhciAqa2V5LAoJCQkgICAgICAgc2l6ZV90ICpvdXRfbGVuKTsKCi8qIEZpbmQgdGhlIGVuZCBvZiB0aGUgbG9nIG1lc3NhZ2UsIHRoZSByaWdodCBwbGFjZSBmb3IgYSBuZXcgdHJhaWxlci4gKi8Kc2l6ZV90IGlnbm9yZV9ub25fdHJhaWxlcihjb25zdCBjaGFyICpidWYsIHNpemVfdCBsZW4pOwoKdHlwZWRlZiBpbnQgKCplYWNoX21lcmdldGFnX2ZuKShzdHJ1Y3QgY29tbWl0ICpjb21taXQsIHN0cnVjdCBjb21taXRfZXh0cmFfaGVhZGVyICpleHRyYSwKCQkJCXZvaWQgKmNiX2RhdGEpOwoKaW50IGZvcl9lYWNoX21lcmdldGFnKGVhY2hfbWVyZ2V0YWdfZm4gZm4sIHN0cnVjdCBjb21taXQgKmNvbW1pdCwgdm9pZCAqZGF0YSk7CgpzdHJ1Y3QgbWVyZ2VfcmVtb3RlX2Rlc2MgewoJc3RydWN0IG9iamVjdCAqb2JqOyAvKiB0aGUgbmFtZWQgb2JqZWN0LCBjb3VsZCBiZSBhIHRhZyAqLwoJY2hhciBuYW1lW0ZMRVhfQVJSQVldOwp9OwpzdHJ1Y3QgbWVyZ2VfcmVtb3RlX2Rlc2MgKm1lcmdlX3JlbW90ZV91dGlsKHN0cnVjdCBjb21taXQgKik7CnZvaWQgc2V0X21lcmdlX3JlbW90ZV9kZXNjKHN0cnVjdCBjb21taXQgKmNvbW1pdCwKCQkJICAgY29uc3QgY2hhciAqbmFtZSwgc3RydWN0IG9iamVjdCAqb2JqKTsKCi8qCiAqIEdpdmVuICJuYW1lIiBmcm9tIHRoZSBjb21tYW5kIGxpbmUgdG8gbWVyZ2UsIGZpbmQgdGhlIGNvbW1pdCBvYmplY3QKICogYW5kIHJldHVybiBpdCwgd2hpbGUgc3RvcmluZyBtZXJnZV9yZW1vdGVfZGVzYyBpbiBpdHMgLT51dGlsIGZpZWxkLAogKiB0byBhbGxvdyBjYWxsZXJzIHRvIHRlbGwgaWYgd2UgYXJlIHRvbGQgdG8gbWVyZ2UgYSB0YWcuCiAqLwpzdHJ1Y3QgY29tbWl0ICpnZXRfbWVyZ2VfcGFyZW50KGNvbnN0IGNoYXIgKm5hbWUpOwoKaW50IHBhcnNlX3NpZ25lZF9jb21taXQoY29uc3Qgc3RydWN0IGNvbW1pdCAqY29tbWl0LAoJCQlzdHJ1Y3Qgc3RyYnVmICptZXNzYWdlLCBzdHJ1Y3Qgc3RyYnVmICpzaWduYXR1cmUpOwppbnQgcmVtb3ZlX3NpZ25hdHVyZShzdHJ1Y3Qgc3RyYnVmICpidWYpOwoKLyoKICogQ2hlY2sgdGhlIHNpZ25hdHVyZSBvZiB0aGUgZ2l2ZW4gY29tbWl0LiBUaGUgcmVzdWx0IG9mIHRoZSBjaGVjayBpcyBzdG9yZWQKICogaW4gc2lnLT5jaGVja19yZXN1bHQsICdHJyBmb3IgYSBnb29kIHNpZ25hdHVyZSwgJ1UnIGZvciBhIGdvb2Qgc2lnbmF0dXJlCiAqIGZyb20gYW4gdW50cnVzdGVkIHNpZ25lciwgJ0InIGZvciBhIGJhZCBzaWduYXR1cmUgYW5kICdOJyBmb3Igbm8gc2lnbmF0dXJlCiAqIGF0IGFsbC4gIFRoaXMgbWF5IGFsbG9jYXRlIG1lbW9yeSBmb3Igc2lnLT5ncGdfb3V0cHV0LCBzaWctPmdwZ19zdGF0dXMsCiAqIHNpZy0+c2lnbmVyIGFuZCBzaWctPmtleS4KICovCmludCBjaGVja19jb21taXRfc2lnbmF0dXJlKGNvbnN0IHN0cnVjdCBjb21taXQgKmNvbW1pdCwgc3RydWN0IHNpZ25hdHVyZV9jaGVjayAqc2lnYyk7CgovKiByZWNvcmQgYXV0aG9yLWRhdGUgZm9yIGVhY2ggY29tbWl0IG9iamVjdCAqLwpzdHJ1Y3QgYXV0aG9yX2RhdGVfc2xhYjsKdm9pZCByZWNvcmRfYXV0aG9yX2RhdGUoc3RydWN0IGF1dGhvcl9kYXRlX3NsYWIgKmF1dGhvcl9kYXRlLAoJCQlzdHJ1Y3QgY29tbWl0ICpjb21taXQpOwoKaW50IGNvbXBhcmVfY29tbWl0c19ieV9hdXRob3JfZGF0ZShjb25zdCB2b2lkICphXywgY29uc3Qgdm9pZCAqYl8sIHZvaWQgKnVudXNlZCk7CgovKgogKiBWZXJpZnkgYSBzaW5nbGUgY29tbWl0IHdpdGggY2hlY2tfY29tbWl0X3NpZ25hdHVyZSgpIGFuZCBkaWUoKSBpZiBpdCBpcyBub3QKICogYSBnb29kIHNpZ25hdHVyZS4gVGhpcyBpc24ndCByZWFsbHkgc3VpdGFibGUgZm9yIGdlbmVyYWwgdXNlLCBidXQgaXMgYQogKiBoZWxwZXIgdG8gaW1wbGVtZW50IGNvbnNpc3RlbnQgbG9naWMgZm9yIHB1bGwvbWVyZ2UgLS12ZXJpZnktc2lnbmF0dXJlcy4KICoKICogVGhlIGNoZWNrX3RydXN0IHBhcmFtZXRlciBpcyBtZWFudCBmb3IgYmFja3dhcmQtY29tcGF0aWJpbGl0eS4gIFRoZSBHUEcKICogaW50ZXJmYWNlIHZlcmlmaWVzIGtleSB0cnVzdCB3aXRoIGEgZGVmYXVsdCB0cnVzdCBsZXZlbCB0aGF0IGlzIGJlbG93IHRoZQogKiBkZWZhdWx0IHRydXN0IGxldmVsIGZvciBtZXJnZSBvcGVyYXRpb25zLiAgSXRzIHZhbHVlIHNob3VsZCBiZSBub24temVybyBpZgogKiB0aGUgdXNlciBoYXNuJ3Qgc2V0IGEgbWluaW11bSB0cnVzdCBsZXZlbCBleHBsaWNpdGx5IGluIHRoZWlyIGNvbmZpZ3VyYXRpb24uCiAqCiAqIElmIHRoZSB1c2VyIGhhcyBzZXQgYSBtaW5pbXVtIHRydXN0IGxldmVsLCB0aGVuIHRoYXQgdmFsdWUgc2hvdWxkIGJlIG9iZXllZAogKiBhbmQgY2hlY2tfdHJ1c3Qgc2hvdWxkIGJlIHplcm8sIGV2ZW4gaWYgdGhlIGNvbmZpZ3VyZWQgdHJ1c3QgbGV2ZWwgaXMgYmVsb3cKICogdGhlIGRlZmF1bHQgdHJ1c3QgbGV2ZWwgZm9yIG1lcmdlcy4KICovCnZvaWQgdmVyaWZ5X21lcmdlX3NpZ25hdHVyZShzdHJ1Y3QgY29tbWl0ICpjb21taXQsIGludCB2ZXJib3NlLAoJCQkgICAgaW50IGNoZWNrX3RydXN0KTsKCmludCBjb21wYXJlX2NvbW1pdHNfYnlfY29tbWl0X2RhdGUoY29uc3Qgdm9pZCAqYV8sIGNvbnN0IHZvaWQgKmJfLCB2b2lkICp1bnVzZWQpOwppbnQgY29tcGFyZV9jb21taXRzX2J5X2dlbl90aGVuX2NvbW1pdF9kYXRlKGNvbnN0IHZvaWQgKmFfLCBjb25zdCB2b2lkICpiXywgdm9pZCAqdW51c2VkKTsKCkxBU1RfQVJHX01VU1RfQkVfTlVMTAppbnQgcnVuX2NvbW1pdF9ob29rKGludCBlZGl0b3JfaXNfdXNlZCwgY29uc3QgY2hhciAqaW5kZXhfZmlsZSwgY29uc3QgY2hhciAqbmFtZSwgLi4uKTsKCiNlbmRpZiAvKiBDT01NSVRfSCAqLwo=",
    "text": "#ifndef COMMIT_H\n#define COMMIT_H\n\n#include \"object.h\"\n#include \"tree.h\"\n#include \"strbuf.h\"\n#include \"decorate.h\"\n#include \"gpg-interface.h\"\n#include \"string-list.h\"\n#include \"pretty.h\"\n#include \"commit-slab.h\"\n\n#define COMMIT_NOT_FROM_GRAPH 0xFFFFFFFF\n#define GENERATION_NUMBER_INFINITY 0xFFFFFFFF\n#define GENERATION_NUMBER_MAX 0x3FFFFFFF\n#define GENERATION_NUMBER_ZERO 0\n\nstruct commit_list {\n\tstruct commit *item;\n\tstruct commit_list *next;\n};\n\n/*\n * The size of this struct matters in full repo walk operations like\n * 'git clone' or 'git gc'. Consider using commit-slab to attach data\n * to a commit instead of adding new fields here.\n */\nstruct commit {\n\tstruct object object;\n\ttimestamp_t date;\n\tstruct commit_list *parents;\n\n\t/*\n\t * If the commit is loaded from the commit-graph file, then this\n\t * member may be NULL. Only access it through repo_get_commit_tree()\n\t * or get_commit_tree_oid().\n\t */\n\tstruct tree *maybe_tree;\n\tuint32_t graph_pos;\n\tuint32_t generation;\n\tunsigned int index;\n};\n\nextern int save_commit_buffer;\nextern const char *commit_type;\n\n/* While we can decorate any object with a name, it's only used for commits.. */\nstruct name_decoration {\n\tstruct name_decoration *next;\n\tint type;\n\tchar name[FLEX_ARRAY];\n};\n\nenum decoration_type {\n\tDECORATION_NONE = 0,\n\tDECORATION_REF_LOCAL,\n\tDECORATION_REF_REMOTE,\n\tDECORATION_REF_TAG,\n\tDECORATION_REF_STASH,\n\tDECORATION_REF_HEAD,\n\tDECORATION_GRAFTED,\n};\n\nvoid add_name_decoration(enum decoration_type type, const char *name, struct object *obj);\nconst struct name_decoration *get_name_decoration(const struct object *obj);\n\nstruct commit *lookup_commit(struct repository *r, const struct object_id *oid);\nstruct commit *lookup_commit_reference(struct repository *r,\n\t\t\t\t       const struct object_id *oid);\nstruct commit *lookup_commit_reference_gently(struct repository *r,\n\t\t\t\t\t      const struct object_id *oid,\n\t\t\t\t\t      int quiet);\nstruct commit *lookup_commit_reference_by_name(const char *name);\n\n/*\n * Look up object named by \"oid\", dereference tag as necessary,\n * get a commit and return it. If \"oid\" does not dereference to\n * a commit, use ref_name to report an error and die.\n */\nstruct commit *lookup_commit_or_die(const struct object_id *oid, const char *ref_name);\n\nint parse_commit_buffer(struct repository *r, struct commit *item, const void *buffer, unsigned long size, int check_graph);\nint repo_parse_commit_internal(struct repository *r, struct commit *item,\n\t\t\t       int quiet_on_missing, int use_commit_graph);\nint repo_parse_commit_gently(struct repository *r,\n\t\t\t     struct commit *item,\n\t\t\t     int quiet_on_missing);\nstatic inline int repo_parse_commit(struct repository *r, struct commit *item)\n{\n\treturn repo_parse_commit_gently(r, item, 0);\n}\n\nstatic inline int parse_commit_no_graph(struct commit *commit)\n{\n\treturn repo_parse_commit_internal(the_repository, commit, 0, 0);\n}\n\n#ifndef NO_THE_REPOSITORY_COMPATIBILITY_MACROS\n#define parse_commit_internal(item, quiet, use) repo_parse_commit_internal(the_repository, item, quiet, use)\n#define parse_commit_gently(item, quiet) repo_parse_commit_gently(the_repository, item, quiet)\n#define parse_commit(item) repo_parse_commit(the_repository, item)\n#endif\n\nvoid parse_commit_or_die(struct commit *item);\n\nstruct buffer_slab;\nstruct buffer_slab *allocate_commit_buffer_slab(void);\nvoid free_commit_buffer_slab(struct buffer_slab *bs);\n\n/*\n * Associate an object buffer with the commit. The ownership of the\n * memory is handed over to the commit, and must be free()-able.\n */\nvoid set_commit_buffer(struct repository *r, struct commit *, void *buffer, unsigned long size);\n\n/*\n * Get any cached object buffer associated with the commit. Returns NULL\n * if none. The resulting memory should not be freed.\n */\nconst void *get_cached_commit_buffer(struct repository *, const struct commit *, unsigned long *size);\n\n/*\n * Get the commit's object contents, either from cache or by reading the object\n * from disk. The resulting memory should not be modified, and must be given\n * to unuse_commit_buffer when the caller is done.\n */\nconst void *repo_get_commit_buffer(struct repository *r,\n\t\t\t\t   const struct commit *,\n\t\t\t\t   unsigned long *size);\n#ifndef NO_THE_REPOSITORY_COMPATIBILITY_MACROS\n#define get_commit_buffer(c, s) repo_get_commit_buffer(the_repository, c, s)\n#endif\n\n/*\n * Tell the commit subsystem that we are done with a particular commit buffer.\n * The commit and buffer should be the input and return value, respectively,\n * from an earlier call to get_commit_buffer.  The buffer may or may not be\n * freed by this call; callers should not access the memory afterwards.\n */\nvoid repo_unuse_commit_buffer(struct repository *r,\n\t\t\t      const struct commit *,\n\t\t\t      const void *buffer);\n#ifndef NO_THE_REPOSITORY_COMPATIBILITY_MACROS\n#define unuse_commit_buffer(c, b) repo_unuse_commit_buffer(the_repository, c, b)\n#endif\n\n/*\n * Free any cached object buffer associated with the commit.\n */\nvoid free_commit_buffer(struct parsed_object_pool *pool, struct commit *);\n\nstruct tree *repo_get_commit_tree(struct repository *, const struct commit *);\n#define get_commit_tree(c) repo_get_commit_tree(the_repository, c)\nstruct object_id *get_commit_tree_oid(const struct commit *);\n\n/*\n * Release memory related to a commit, including the parent list and\n * any cached object buffer.\n */\nvoid release_commit_memory(struct parsed_object_pool *pool, struct commit *c);\n\n/*\n * Disassociate any cached object buffer from the commit, but do not free it.\n * The buffer (or NULL, if none) is returned.\n */\nconst void *detach_commit_buffer(struct commit *, unsigned long *sizep);\n\n/* Find beginning and length of commit subject. */\nint find_commit_subject(const char *commit_buffer, const char **subject);\n\nstruct commit_list *commit_list_insert(struct commit *item,\n\t\t\t\t\tstruct commit_list **list);\nstruct commit_list **commit_list_append(struct commit *commit,\n\t\t\t\t\tstruct commit_list **next);\nunsigned commit_list_count(const struct commit_list *l);\nstruct commit_list *commit_list_insert_by_date(struct commit *item,\n\t\t\t\t    struct commit_list **list);\nvoid commit_list_sort_by_date(struct commit_list **list);\n\n/* Shallow copy of the input list */\nstruct commit_list *copy_commit_list(struct commit_list *list);\n\nvoid free_commit_list(struct commit_list *list);\n\nstruct rev_info; /* in revision.h, it circularly uses enum cmit_fmt */\n\nint has_non_ascii(const char *text);\nconst char *logmsg_reencode(const struct commit *commit,\n\t\t\t    char **commit_encoding,\n\t\t\t    const char *output_encoding);\nconst char *repo_logmsg_reencode(struct repository *r,\n\t\t\t\t const struct commit *commit,\n\t\t\t\t char **commit_encoding,\n\t\t\t\t const char *output_encoding);\n#ifndef NO_THE_REPOSITORY_COMPATIBILITY_MACROS\n#define logmsg_reencode(c, enc, out) repo_logmsg_reencode(the_repository, c, enc, out)\n#endif\n\nconst char *skip_blank_lines(const char *msg);\n\n/** Removes the first commit from a list sorted by date, and adds all\n * of its parents.\n **/\nstruct commit *pop_most_recent_commit(struct commit_list **list,\n\t\t\t\t      unsigned int mark);\n\nstruct commit *pop_commit(struct commit_list **stack);\n\nvoid clear_commit_marks(struct commit *commit, unsigned int mark);\nvoid clear_commit_marks_many(int nr, struct commit **commit, unsigned int mark);\n\n\nenum rev_sort_order {\n\tREV_SORT_IN_GRAPH_ORDER = 0,\n\tREV_SORT_BY_COMMIT_DATE,\n\tREV_SORT_BY_AUTHOR_DATE\n};\n\n/*\n * Performs an in-place topological sort of list supplied.\n *\n *   invariant of resulting list is:\n *      a reachable from b => ord(b) < ord(a)\n *   sort_order further specifies:\n *   REV_SORT_IN_GRAPH_ORDER: try to show a commit on a single-parent\n *                            chain together.\n *   REV_SORT_BY_COMMIT_DATE: show eligible commits in committer-date order.\n */\nvoid sort_in_topological_order(struct commit_list **, enum rev_sort_order);\n\nstruct commit_graft {\n\tstruct object_id oid;\n\tint nr_parent; /* < 0 if shallow commit */\n\tstruct object_id parent[FLEX_ARRAY]; /* more */\n};\ntypedef int (*each_commit_graft_fn)(const struct commit_graft *, void *);\n\nstruct commit_graft *read_graft_line(struct strbuf *line);\nint register_commit_graft(struct repository *r, struct commit_graft *, int);\nvoid prepare_commit_graft(struct repository *r);\nstruct commit_graft *lookup_commit_graft(struct repository *r, const struct object_id *oid);\n\nstruct commit *get_fork_point(const char *refname, struct commit *commit);\n\n/* largest positive number a signed 32-bit integer can contain */\n#define INFINITE_DEPTH 0x7fffffff\n\nstruct oid_array;\nstruct ref;\nint register_shallow(struct repository *r, const struct object_id *oid);\nint unregister_shallow(const struct object_id *oid);\nint for_each_commit_graft(each_commit_graft_fn, void *);\nint is_repository_shallow(struct repository *r);\nstruct commit_list *get_shallow_commits(struct object_array *heads,\n\t\t\t\t\tint depth, int shallow_flag, int not_shallow_flag);\nstruct commit_list *get_shallow_commits_by_rev_list(\n\t\tint ac, const char **av, int shallow_flag, int not_shallow_flag);\nvoid set_alternate_shallow_file(struct repository *r, const char *path, int override);\nint write_shallow_commits(struct strbuf *out, int use_pack_protocol,\n\t\t\t  const struct oid_array *extra);\nvoid setup_alternate_shallow(struct lock_file *shallow_lock,\n\t\t\t     const char **alternate_shallow_file,\n\t\t\t     const struct oid_array *extra);\nconst char *setup_temporary_shallow(const struct oid_array *extra);\nvoid advertise_shallow_grafts(int);\n\n/*\n * Initialize with prepare_shallow_info() or zero-initialize (equivalent to\n * prepare_shallow_info with a NULL oid_array).\n */\nstruct shallow_info {\n\tstruct oid_array *shallow;\n\tint *ours, nr_ours;\n\tint *theirs, nr_theirs;\n\tstruct oid_array *ref;\n\n\t/* for receive-pack */\n\tuint32_t **used_shallow;\n\tint *need_reachability_test;\n\tint *reachable;\n\tint *shallow_ref;\n\tstruct commit **commits;\n\tint nr_commits;\n};\n\nvoid prepare_shallow_info(struct shallow_info *, struct oid_array *);\nvoid clear_shallow_info(struct shallow_info *);\nvoid remove_nonexistent_theirs_shallow(struct shallow_info *);\nvoid assign_shallow_commits_to_refs(struct shallow_info *info,\n\t\t\t\t    uint32_t **used,\n\t\t\t\t    int *ref_status);\nint delayed_reachability_test(struct shallow_info *si, int c);\n#define PRUNE_SHOW_ONLY 1\n#define PRUNE_QUICK 2\nvoid prune_shallow(unsigned options);\nextern struct trace_key trace_shallow;\n\nint interactive_add(int argc, const char **argv, const char *prefix, int patch);\nint run_add_interactive(const char *revision, const char *patch_mode,\n\t\t\tconst struct pathspec *pathspec);\n\nstruct commit_extra_header {\n\tstruct commit_extra_header *next;\n\tchar *key;\n\tchar *value;\n\tsize_t len;\n};\n\nvoid append_merge_tag_headers(struct commit_list *parents,\n\t\t\t      struct commit_extra_header ***tail);\n\nint commit_tree(const char *msg, size_t msg_len,\n\t\tconst struct object_id *tree,\n\t\tstruct commit_list *parents, struct object_id *ret,\n\t\tconst char *author, const char *sign_commit);\n\nint commit_tree_extended(const char *msg, size_t msg_len,\n\t\t\t const struct object_id *tree,\n\t\t\t struct commit_list *parents,\n\t\t\t struct object_id *ret, const char *author,\n\t\t\t const char *sign_commit,\n\t\t\t struct commit_extra_header *);\n\nstruct commit_extra_header *read_commit_extra_headers(struct commit *, const char **);\n\nvoid free_commit_extra_headers(struct commit_extra_header *extra);\n\n/*\n * Search the commit object contents given by \"msg\" for the header \"key\".\n * Returns a pointer to the start of the header contents, or NULL. The length\n * of the header, up to the first newline, is returned via out_len.\n *\n * Note that some headers (like mergetag) may be multi-line. It is the caller's\n * responsibility to parse further in this case!\n */\nconst char *find_commit_header(const char *msg, const char *key,\n\t\t\t       size_t *out_len);\n\n/* Find the end of the log message, the right place for a new trailer. */\nsize_t ignore_non_trailer(const char *buf, size_t len);\n\ntypedef int (*each_mergetag_fn)(struct commit *commit, struct commit_extra_header *extra,\n\t\t\t\tvoid *cb_data);\n\nint for_each_mergetag(each_mergetag_fn fn, struct commit *commit, void *data);\n\nstruct merge_remote_desc {\n\tstruct object *obj; /* the named object, could be a tag */\n\tchar name[FLEX_ARRAY];\n};\nstruct merge_remote_desc *merge_remote_util(struct commit *);\nvoid set_merge_remote_desc(struct commit *commit,\n\t\t\t   const char *name, struct object *obj);\n\n/*\n * Given \"name\" from the command line to merge, find the commit object\n * and return it, while storing merge_remote_desc in its ->util field,\n * to allow callers to tell if we are told to merge a tag.\n */\nstruct commit *get_merge_parent(const char *name);\n\nint parse_signed_commit(const struct commit *commit,\n\t\t\tstruct strbuf *message, struct strbuf *signature);\nint remove_signature(struct strbuf *buf);\n\n/*\n * Check the signature of the given commit. The result of the check is stored\n * in sig->check_result, 'G' for a good signature, 'U' for a good signature\n * from an untrusted signer, 'B' for a bad signature and 'N' for no signature\n * at all.  This may allocate memory for sig->gpg_output, sig->gpg_status,\n * sig->signer and sig->key.\n */\nint check_commit_signature(const struct commit *commit, struct signature_check *sigc);\n\n/* record author-date for each commit object */\nstruct author_date_slab;\nvoid record_author_date(struct author_date_slab *author_date,\n\t\t\tstruct commit *commit);\n\nint compare_commits_by_author_date(const void *a_, const void *b_, void *unused);\n\n/*\n * Verify a single commit with check_commit_signature() and die() if it is not\n * a good signature. This isn't really suitable for general use, but is a\n * helper to implement consistent logic for pull/merge --verify-signatures.\n *\n * The check_trust parameter is meant for backward-compatibility.  The GPG\n * interface verifies key trust with a default trust level that is below the\n * default trust level for merge operations.  Its value should be non-zero if\n * the user hasn't set a minimum trust level explicitly in their configuration.\n *\n * If the user has set a minimum trust level, then that value should be obeyed\n * and check_trust should be zero, even if the configured trust level is below\n * the default trust level for merges.\n */\nvoid verify_merge_signature(struct commit *commit, int verbose,\n\t\t\t    int check_trust);\n\nint compare_commits_by_commit_date(const void *a_, const void *b_, void *unused);\nint compare_commits_by_gen_then_commit_date(const void *a_, const void *b_, void *unused);\n\nLAST_ARG_MUST_BE_NULL\nint run_commit_hook(int editor_is_used, const char *index_file, const char *name, ...);\n\n#endif /* COMMIT_H */\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "008a0fa4a01d06c0e191e5988823ff630931d30d",
  "sha1_ok": true,
  "size": 14636
}
