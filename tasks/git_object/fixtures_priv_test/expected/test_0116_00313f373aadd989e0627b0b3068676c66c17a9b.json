{
  "content": {
    "base64": "LyoKICogR0lUIC0gVGhlIGluZm9ybWF0aW9uIG1hbmFnZXIgZnJvbSBoZWxsCiAqCiAqIENvcHlyaWdodCAoQykgTGludXMgVG9ydmFsZHMsIDIwMDUKICovCiNpbmNsdWRlICJjYWNoZS5oIgojaW5jbHVkZSAicXVvdGUuaCIKI2luY2x1ZGUgImNhY2hlLXRyZWUuaCIKI2luY2x1ZGUgInRyZWUtd2Fsay5oIgojaW5jbHVkZSAiYnVpbHRpbi5oIgojaW5jbHVkZSAicmVmcy5oIgojaW5jbHVkZSAicmVzb2x2ZS11bmRvLmgiCiNpbmNsdWRlICJwYXJzZS1vcHRpb25zLmgiCiNpbmNsdWRlICJwYXRoc3BlYy5oIgoKLyoKICogRGVmYXVsdCB0byBub3QgYWxsb3dpbmcgY2hhbmdlcyB0byB0aGUgbGlzdCBvZiBmaWxlcy4gVGhlCiAqIHRvb2wgZG9lc24ndCBhY3R1YWxseSBjYXJlLCBidXQgdGhpcyBtYWtlcyBpdCBoYXJkZXIgdG8gYWRkCiAqIGZpbGVzIHRvIHRoZSByZXZpc2lvbiBjb250cm9sIGJ5IG1pc3Rha2UgYnkgZG9pbmcgc29tZXRoaW5nCiAqIGxpa2UgImdpdCB1cGRhdGUtaW5kZXggKiIgYW5kIHN1ZGRlbmx5IGhhdmluZyBhbGwgdGhlIG9iamVjdAogKiBmaWxlcyBiZSByZXZpc2lvbiBjb250cm9sbGVkLgogKi8Kc3RhdGljIGludCBhbGxvd19hZGQ7CnN0YXRpYyBpbnQgYWxsb3dfcmVtb3ZlOwpzdGF0aWMgaW50IGFsbG93X3JlcGxhY2U7CnN0YXRpYyBpbnQgaW5mb19vbmx5OwpzdGF0aWMgaW50IGZvcmNlX3JlbW92ZTsKc3RhdGljIGludCB2ZXJib3NlOwpzdGF0aWMgaW50IG1hcmtfdmFsaWRfb25seTsKc3RhdGljIGludCBtYXJrX3NraXBfd29ya3RyZWVfb25seTsKI2RlZmluZSBNQVJLX0ZMQUcgMQojZGVmaW5lIFVOTUFSS19GTEFHIDIKCl9fYXR0cmlidXRlX18oKGZvcm1hdCAocHJpbnRmLCAxLCAyKSkpCnN0YXRpYyB2b2lkIHJlcG9ydChjb25zdCBjaGFyICpmbXQsIC4uLikKewoJdmFfbGlzdCB2cDsKCglpZiAoIXZlcmJvc2UpCgkJcmV0dXJuOwoKCXZhX3N0YXJ0KHZwLCBmbXQpOwoJdnByaW50ZihmbXQsIHZwKTsKCXB1dGNoYXIoJ1xuJyk7Cgl2YV9lbmQodnApOwp9CgpzdGF0aWMgaW50IG1hcmtfY2VfZmxhZ3MoY29uc3QgY2hhciAqcGF0aCwgaW50IGZsYWcsIGludCBtYXJrKQp7CglpbnQgbmFtZWxlbiA9IHN0cmxlbihwYXRoKTsKCWludCBwb3MgPSBjYWNoZV9uYW1lX3BvcyhwYXRoLCBuYW1lbGVuKTsKCWlmICgwIDw9IHBvcykgewoJCWlmIChtYXJrKQoJCQlhY3RpdmVfY2FjaGVbcG9zXS0+Y2VfZmxhZ3MgfD0gZmxhZzsKCQllbHNlCgkJCWFjdGl2ZV9jYWNoZVtwb3NdLT5jZV9mbGFncyAmPSB+ZmxhZzsKCQljYWNoZV90cmVlX2ludmFsaWRhdGVfcGF0aChhY3RpdmVfY2FjaGVfdHJlZSwgcGF0aCk7CgkJYWN0aXZlX2NhY2hlX2NoYW5nZWQgPSAxOwoJCXJldHVybiAwOwoJfQoJcmV0dXJuIC0xOwp9CgpzdGF0aWMgaW50IHJlbW92ZV9vbmVfcGF0aChjb25zdCBjaGFyICpwYXRoKQp7CglpZiAoIWFsbG93X3JlbW92ZSkKCQlyZXR1cm4gZXJyb3IoIiVzOiBkb2VzIG5vdCBleGlzdCBhbmQgLS1yZW1vdmUgbm90IHBhc3NlZCIsIHBhdGgpOwoJaWYgKHJlbW92ZV9maWxlX2Zyb21fY2FjaGUocGF0aCkpCgkJcmV0dXJuIGVycm9yKCIlczogY2Fubm90IHJlbW92ZSBmcm9tIHRoZSBpbmRleCIsIHBhdGgpOwoJcmV0dXJuIDA7Cn0KCi8qCiAqIEhhbmRsZSBhIHBhdGggdGhhdCBjb3VsZG4ndCBiZSBsc3RhdCdlZC4gSXQncyBlaXRoZXI6CiAqICAtIG1pc3NpbmcgZmlsZSAoRU5PRU5UIG9yIEVOT1RESVIpLiBUaGF0J3Mgb2sgaWYgd2UncmUKICogICAgc3VwcG9zZWQgdG8gYmUgcmVtb3ZpbmcgaXQgYW5kIHRoZSByZW1vdmFsIGFjdHVhbGx5CiAqICAgIHN1Y2NlZWRzLgogKiAgLSBwZXJtaXNzaW9uIGVycm9yLiBUaGF0J3MgbmV2ZXIgb2suCiAqLwpzdGF0aWMgaW50IHByb2Nlc3NfbHN0YXRfZXJyb3IoY29uc3QgY2hhciAqcGF0aCwgaW50IGVycikKewoJaWYgKGVyciA9PSBFTk9FTlQgfHwgZXJyID09IEVOT1RESVIpCgkJcmV0dXJuIHJlbW92ZV9vbmVfcGF0aChwYXRoKTsKCXJldHVybiBlcnJvcigibHN0YXQoXCIlc1wiKTogJXMiLCBwYXRoLCBzdHJlcnJvcihlcnJubykpOwp9CgpzdGF0aWMgaW50IGFkZF9vbmVfcGF0aChjb25zdCBzdHJ1Y3QgY2FjaGVfZW50cnkgKm9sZCwgY29uc3QgY2hhciAqcGF0aCwgaW50IGxlbiwgc3RydWN0IHN0YXQgKnN0KQp7CglpbnQgb3B0aW9uLCBzaXplOwoJc3RydWN0IGNhY2hlX2VudHJ5ICpjZTsKCgkvKiBXYXMgdGhlIG9sZCBpbmRleCBlbnRyeSBhbHJlYWR5IHVwLXRvLWRhdGU/ICovCglpZiAob2xkICYmICFjZV9zdGFnZShvbGQpICYmICFjZV9tYXRjaF9zdGF0KG9sZCwgc3QsIDApKQoJCXJldHVybiAwOwoKCXNpemUgPSBjYWNoZV9lbnRyeV9zaXplKGxlbik7CgljZSA9IHhjYWxsb2MoMSwgc2l6ZSk7CgltZW1jcHkoY2UtPm5hbWUsIHBhdGgsIGxlbik7CgljZS0+Y2VfZmxhZ3MgPSBjcmVhdGVfY2VfZmxhZ3MoMCk7CgljZS0+Y2VfbmFtZWxlbiA9IGxlbjsKCWZpbGxfc3RhdF9jYWNoZV9pbmZvKGNlLCBzdCk7CgljZS0+Y2VfbW9kZSA9IGNlX21vZGVfZnJvbV9zdGF0KG9sZCwgc3QtPnN0X21vZGUpOwoKCWlmIChpbmRleF9wYXRoKGNlLT5zaGExLCBwYXRoLCBzdCwKCQkgICAgICAgaW5mb19vbmx5ID8gMCA6IEhBU0hfV1JJVEVfT0JKRUNUKSkgewoJCWZyZWUoY2UpOwoJCXJldHVybiAtMTsKCX0KCW9wdGlvbiA9IGFsbG93X2FkZCA/IEFERF9DQUNIRV9PS19UT19BREQgOiAwOwoJb3B0aW9uIHw9IGFsbG93X3JlcGxhY2UgPyBBRERfQ0FDSEVfT0tfVE9fUkVQTEFDRSA6IDA7CglpZiAoYWRkX2NhY2hlX2VudHJ5KGNlLCBvcHRpb24pKQoJCXJldHVybiBlcnJvcigiJXM6IGNhbm5vdCBhZGQgdG8gdGhlIGluZGV4IC0gbWlzc2luZyAtLWFkZCBvcHRpb24/IiwgcGF0aCk7CglyZXR1cm4gMDsKfQoKLyoKICogSGFuZGxlIGEgcGF0aCB0aGF0IHdhcyBhIGRpcmVjdG9yeS4gRm91ciBjYXNlczoKICoKICogIC0gaXQncyBhbHJlYWR5IGEgZ2l0bGluayBpbiB0aGUgaW5kZXgsIGFuZCB3ZSBrZWVwIGl0IHRoYXQKICogICAgd2F5LCBhbmQgdXBkYXRlIGl0IGlmIHdlIGNhbiAoaWYgd2UgY2Fubm90IGZpbmQgdGhlIEhFQUQsCiAqICAgIHdlJ3JlIGdvaW5nIHRvIGtlZXAgaXQgdW5jaGFuZ2VkIGluIHRoZSBpbmRleCEpCiAqCiAqICAtIGl0J3MgYSAqZmlsZSogaW4gdGhlIGluZGV4LCBpbiB3aGljaCBjYXNlIGl0IHNob3VsZCBiZQogKiAgICByZW1vdmVkIGFzIGEgZmlsZSBpZiByZW1vdmFsIGlzIGFsbG93ZWQsIHNpbmNlIGl0IGRvZXNuJ3QKICogICAgZXhpc3QgYXMgc3VjaCBhbnkgbW9yZS4gSWYgcmVtb3ZhbCBpc24ndCBhbGxvd2VkLCBpdCdzCiAqICAgIGFuIGVycm9yLgogKgogKiAgICAoTk9URSEgVGhpcyBpcyBvbGQgYW5kIGFyZ3VhYmx5IGZhaXJseSBzdHJhbmdlIGJlaGF2aW91ci4KICogICAgV2UgbWlnaHQgd2FudCB0byBtYWtlIHRoaXMgYW4gZXJyb3IgdW5jb25kaXRpb25hbGx5LCBhbmQKICogICAgdXNlICItLWZvcmNlLXJlbW92ZSIgaWYgeW91IGFjdHVhbGx5IHdhbnQgdG8gZm9yY2UgcmVtb3ZhbCkuCiAqCiAqICAtIGl0IHVzZWQgdG8gZXhpc3QgYXMgYSBzdWJkaXJlY3RvcnkgKGllIG11bHRpcGxlIGZpbGVzIHdpdGgKICogICAgdGhpcyBwYXJ0aWN1bGFyIHByZWZpeCkgaW4gdGhlIGluZGV4LCBpbiB3aGljaCBjYXNlIGl0J3Mgd3JvbmcKICogICAgdG8gdHJ5IHRvIHVwZGF0ZSBpdCBhcyBhIGRpcmVjdG9yeS4KICoKICogIC0gaXQgZG9lc24ndCBleGlzdCBhdCBhbGwgaW4gdGhlIGluZGV4LCBidXQgaXQgaXMgYSB2YWxpZAogKiAgICBnaXQgZGlyZWN0b3J5LCBhbmQgaXQgc2hvdWxkIGJlICphZGRlZCogYXMgYSBnaXRsaW5rLgogKi8Kc3RhdGljIGludCBwcm9jZXNzX2RpcmVjdG9yeShjb25zdCBjaGFyICpwYXRoLCBpbnQgbGVuLCBzdHJ1Y3Qgc3RhdCAqc3QpCnsKCXVuc2lnbmVkIGNoYXIgc2hhMVsyMF07CglpbnQgcG9zID0gY2FjaGVfbmFtZV9wb3MocGF0aCwgbGVuKTsKCgkvKiBFeGFjdCBtYXRjaDogZmlsZSBvciBleGlzdGluZyBnaXRsaW5rICovCglpZiAocG9zID49IDApIHsKCQljb25zdCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlID0gYWN0aXZlX2NhY2hlW3Bvc107CgkJaWYgKFNfSVNHSVRMSU5LKGNlLT5jZV9tb2RlKSkgewoKCQkJLyogRG8gbm90aGluZyB0byB0aGUgaW5kZXggaWYgdGhlcmUgaXMgbm8gSEVBRCEgKi8KCQkJaWYgKHJlc29sdmVfZ2l0bGlua19yZWYocGF0aCwgIkhFQUQiLCBzaGExKSA8IDApCgkJCQlyZXR1cm4gMDsKCgkJCXJldHVybiBhZGRfb25lX3BhdGgoY2UsIHBhdGgsIGxlbiwgc3QpOwoJCX0KCQkvKiBTaG91bGQgdGhpcyBiZSBhbiB1bmNvbmRpdGlvbmFsIGVycm9yPyAqLwoJCXJldHVybiByZW1vdmVfb25lX3BhdGgocGF0aCk7Cgl9CgoJLyogSW5leGFjdCBtYXRjaDogaXMgdGhlcmUgcGVyaGFwcyBhIHN1YmRpcmVjdG9yeSBtYXRjaD8gKi8KCXBvcyA9IC1wb3MtMTsKCXdoaWxlIChwb3MgPCBhY3RpdmVfbnIpIHsKCQljb25zdCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlID0gYWN0aXZlX2NhY2hlW3BvcysrXTsKCgkJaWYgKHN0cm5jbXAoY2UtPm5hbWUsIHBhdGgsIGxlbikpCgkJCWJyZWFrOwoJCWlmIChjZS0+bmFtZVtsZW5dID4gJy8nKQoJCQlicmVhazsKCQlpZiAoY2UtPm5hbWVbbGVuXSA8ICcvJykKCQkJY29udGludWU7CgoJCS8qIFN1YmRpcmVjdG9yeSBtYXRjaCAtIGVycm9yIG91dCAqLwoJCXJldHVybiBlcnJvcigiJXM6IGlzIGEgZGlyZWN0b3J5IC0gYWRkIGluZGl2aWR1YWwgZmlsZXMgaW5zdGVhZCIsIHBhdGgpOwoJfQoKCS8qIE5vIG1hdGNoIC0gc2hvdWxkIHdlIGFkZCBpdCBhcyBhIGdpdGxpbms/ICovCglpZiAoIXJlc29sdmVfZ2l0bGlua19yZWYocGF0aCwgIkhFQUQiLCBzaGExKSkKCQlyZXR1cm4gYWRkX29uZV9wYXRoKE5VTEwsIHBhdGgsIGxlbiwgc3QpOwoKCS8qIEVycm9yIG91dC4gKi8KCXJldHVybiBlcnJvcigiJXM6IGlzIGEgZGlyZWN0b3J5IC0gYWRkIGZpbGVzIGluc2lkZSBpbnN0ZWFkIiwgcGF0aCk7Cn0KCnN0YXRpYyBpbnQgcHJvY2Vzc19wYXRoKGNvbnN0IGNoYXIgKnBhdGgpCnsKCWludCBwb3MsIGxlbjsKCXN0cnVjdCBzdGF0IHN0OwoJY29uc3Qgc3RydWN0IGNhY2hlX2VudHJ5ICpjZTsKCglsZW4gPSBzdHJsZW4ocGF0aCk7CglpZiAoaGFzX3N5bWxpbmtfbGVhZGluZ19wYXRoKHBhdGgsIGxlbikpCgkJcmV0dXJuIGVycm9yKCInJXMnIGlzIGJleW9uZCBhIHN5bWJvbGljIGxpbmsiLCBwYXRoKTsKCglwb3MgPSBjYWNoZV9uYW1lX3BvcyhwYXRoLCBsZW4pOwoJY2UgPSBwb3MgPCAwID8gTlVMTCA6IGFjdGl2ZV9jYWNoZVtwb3NdOwoJaWYgKGNlICYmIGNlX3NraXBfd29ya3RyZWUoY2UpKSB7CgkJLyoKCQkgKiB3b3JraW5nIGRpcmVjdG9yeSB2ZXJzaW9uIGlzIGFzc3VtZWQgImdvb2QiCgkJICogc28gdXBkYXRpbmcgaXQgZG9lcyBub3QgbWFrZSBzZW5zZS4KCQkgKiBPbiB0aGUgb3RoZXIgaGFuZCwgcmVtb3ZpbmcgaXQgZnJvbSBpbmRleCBzaG91bGQgd29yawoJCSAqLwoJCWlmIChhbGxvd19yZW1vdmUgJiYgcmVtb3ZlX2ZpbGVfZnJvbV9jYWNoZShwYXRoKSkKCQkJcmV0dXJuIGVycm9yKCIlczogY2Fubm90IHJlbW92ZSBmcm9tIHRoZSBpbmRleCIsIHBhdGgpOwoJCXJldHVybiAwOwoJfQoKCS8qCgkgKiBGaXJzdCB0aGluZ3MgZmlyc3Q6IGdldCB0aGUgc3RhdCBpbmZvcm1hdGlvbiwgdG8gZGVjaWRlCgkgKiB3aGF0IHRvIGRvIGFib3V0IHRoZSBwYXRobmFtZSEKCSAqLwoJaWYgKGxzdGF0KHBhdGgsICZzdCkgPCAwKQoJCXJldHVybiBwcm9jZXNzX2xzdGF0X2Vycm9yKHBhdGgsIGVycm5vKTsKCglpZiAoU19JU0RJUihzdC5zdF9tb2RlKSkKCQlyZXR1cm4gcHJvY2Vzc19kaXJlY3RvcnkocGF0aCwgbGVuLCAmc3QpOwoKCXJldHVybiBhZGRfb25lX3BhdGgoY2UsIHBhdGgsIGxlbiwgJnN0KTsKfQoKc3RhdGljIGludCBhZGRfY2FjaGVpbmZvKHVuc2lnbmVkIGludCBtb2RlLCBjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExLAoJCQkgY29uc3QgY2hhciAqcGF0aCwgaW50IHN0YWdlKQp7CglpbnQgc2l6ZSwgbGVuLCBvcHRpb247CglzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlOwoKCWlmICghdmVyaWZ5X3BhdGgocGF0aCkpCgkJcmV0dXJuIGVycm9yKCJJbnZhbGlkIHBhdGggJyVzJyIsIHBhdGgpOwoKCWxlbiA9IHN0cmxlbihwYXRoKTsKCXNpemUgPSBjYWNoZV9lbnRyeV9zaXplKGxlbik7CgljZSA9IHhjYWxsb2MoMSwgc2l6ZSk7CgoJaGFzaGNweShjZS0+c2hhMSwgc2hhMSk7CgltZW1jcHkoY2UtPm5hbWUsIHBhdGgsIGxlbik7CgljZS0+Y2VfZmxhZ3MgPSBjcmVhdGVfY2VfZmxhZ3Moc3RhZ2UpOwoJY2UtPmNlX25hbWVsZW4gPSBsZW47CgljZS0+Y2VfbW9kZSA9IGNyZWF0ZV9jZV9tb2RlKG1vZGUpOwoJaWYgKGFzc3VtZV91bmNoYW5nZWQpCgkJY2UtPmNlX2ZsYWdzIHw9IENFX1ZBTElEOwoJb3B0aW9uID0gYWxsb3dfYWRkID8gQUREX0NBQ0hFX09LX1RPX0FERCA6IDA7CglvcHRpb24gfD0gYWxsb3dfcmVwbGFjZSA/IEFERF9DQUNIRV9PS19UT19SRVBMQUNFIDogMDsKCWlmIChhZGRfY2FjaGVfZW50cnkoY2UsIG9wdGlvbikpCgkJcmV0dXJuIGVycm9yKCIlczogY2Fubm90IGFkZCB0byB0aGUgaW5kZXggLSBtaXNzaW5nIC0tYWRkIG9wdGlvbj8iLAoJCQkgICAgIHBhdGgpOwoJcmVwb3J0KCJhZGQgJyVzJyIsIHBhdGgpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyB2b2lkIGNobW9kX3BhdGgoaW50IGZsaXAsIGNvbnN0IGNoYXIgKnBhdGgpCnsKCWludCBwb3M7CglzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlOwoJdW5zaWduZWQgaW50IG1vZGU7CgoJcG9zID0gY2FjaGVfbmFtZV9wb3MocGF0aCwgc3RybGVuKHBhdGgpKTsKCWlmIChwb3MgPCAwKQoJCWdvdG8gZmFpbDsKCWNlID0gYWN0aXZlX2NhY2hlW3Bvc107Cgltb2RlID0gY2UtPmNlX21vZGU7CglpZiAoIVNfSVNSRUcobW9kZSkpCgkJZ290byBmYWlsOwoJc3dpdGNoIChmbGlwKSB7CgljYXNlICcrJzoKCQljZS0+Y2VfbW9kZSB8PSAwMTExOyBicmVhazsKCWNhc2UgJy0nOgoJCWNlLT5jZV9tb2RlICY9IH4wMTExOyBicmVhazsKCWRlZmF1bHQ6CgkJZ290byBmYWlsOwoJfQoJY2FjaGVfdHJlZV9pbnZhbGlkYXRlX3BhdGgoYWN0aXZlX2NhY2hlX3RyZWUsIHBhdGgpOwoJYWN0aXZlX2NhY2hlX2NoYW5nZWQgPSAxOwoJcmVwb3J0KCJjaG1vZCAlY3ggJyVzJyIsIGZsaXAsIHBhdGgpOwoJcmV0dXJuOwogZmFpbDoKCWRpZSgiZ2l0IHVwZGF0ZS1pbmRleDogY2Fubm90IGNobW9kICVjeCAnJXMnIiwgZmxpcCwgcGF0aCk7Cn0KCnN0YXRpYyB2b2lkIHVwZGF0ZV9vbmUoY29uc3QgY2hhciAqcGF0aCkKewoJaWYgKCF2ZXJpZnlfcGF0aChwYXRoKSkgewoJCWZwcmludGYoc3RkZXJyLCAiSWdub3JpbmcgcGF0aCAlc1xuIiwgcGF0aCk7CgkJcmV0dXJuOwoJfQoJaWYgKG1hcmtfdmFsaWRfb25seSkgewoJCWlmIChtYXJrX2NlX2ZsYWdzKHBhdGgsIENFX1ZBTElELCBtYXJrX3ZhbGlkX29ubHkgPT0gTUFSS19GTEFHKSkKCQkJZGllKCJVbmFibGUgdG8gbWFyayBmaWxlICVzIiwgcGF0aCk7CgkJcmV0dXJuOwoJfQoJaWYgKG1hcmtfc2tpcF93b3JrdHJlZV9vbmx5KSB7CgkJaWYgKG1hcmtfY2VfZmxhZ3MocGF0aCwgQ0VfU0tJUF9XT1JLVFJFRSwgbWFya19za2lwX3dvcmt0cmVlX29ubHkgPT0gTUFSS19GTEFHKSkKCQkJZGllKCJVbmFibGUgdG8gbWFyayBmaWxlICVzIiwgcGF0aCk7CgkJcmV0dXJuOwoJfQoKCWlmIChmb3JjZV9yZW1vdmUpIHsKCQlpZiAocmVtb3ZlX2ZpbGVfZnJvbV9jYWNoZShwYXRoKSkKCQkJZGllKCJnaXQgdXBkYXRlLWluZGV4OiB1bmFibGUgdG8gcmVtb3ZlICVzIiwgcGF0aCk7CgkJcmVwb3J0KCJyZW1vdmUgJyVzJyIsIHBhdGgpOwoJCXJldHVybjsKCX0KCWlmIChwcm9jZXNzX3BhdGgocGF0aCkpCgkJZGllKCJVbmFibGUgdG8gcHJvY2VzcyBwYXRoICVzIiwgcGF0aCk7CglyZXBvcnQoImFkZCAnJXMnIiwgcGF0aCk7Cn0KCnN0YXRpYyB2b2lkIHJlYWRfaW5kZXhfaW5mbyhpbnQgbGluZV90ZXJtaW5hdGlvbikKewoJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCXN0cnVjdCBzdHJidWYgdXEgPSBTVFJCVUZfSU5JVDsKCgl3aGlsZSAoc3RyYnVmX2dldGxpbmUoJmJ1Ziwgc3RkaW4sIGxpbmVfdGVybWluYXRpb24pICE9IEVPRikgewoJCWNoYXIgKnB0ciwgKnRhYjsKCQljaGFyICpwYXRoX25hbWU7CgkJdW5zaWduZWQgY2hhciBzaGExWzIwXTsKCQl1bnNpZ25lZCBpbnQgbW9kZTsKCQl1bnNpZ25lZCBsb25nIHVsOwoJCWludCBzdGFnZTsKCgkJLyogVGhpcyByZWFkcyBsaW5lcyBmb3JtYXR0ZWQgaW4gb25lIG9mIHRocmVlIGZvcm1hdHM6CgkJICoKCQkgKiAoMSkgbW9kZSAgICAgICAgIFNQIHNoYTEgICAgICAgICAgVEFCIHBhdGgKCQkgKiBUaGUgZmlyc3QgZm9ybWF0IGlzIHdoYXQgImdpdCBhcHBseSAtLWluZGV4LWluZm8iCgkJICogcmVwb3J0cywgYW5kIHVzZWQgdG8gcmVjb25zdHJ1Y3QgYSBwYXJ0aWFsIHRyZWUKCQkgKiB0aGF0IGlzIHVzZWQgZm9yIHBob255IG1lcmdlIGJhc2UgdHJlZSB3aGVuIGZhbGxpbmcKCQkgKiBiYWNrIG9uIDMtd2F5IG1lcmdlLgoJCSAqCgkJICogKDIpIG1vZGUgU1AgdHlwZSBTUCBzaGExICAgICAgICAgIFRBQiBwYXRoCgkJICogVGhlIHNlY29uZCBmb3JtYXQgaXMgdG8gc3R1ZmYgImdpdCBscy10cmVlIiBvdXRwdXQKCQkgKiBpbnRvIHRoZSBpbmRleCBmaWxlLgoJCSAqCgkJICogKDMpIG1vZGUgICAgICAgICBTUCBzaGExIFNQIHN0YWdlIFRBQiBwYXRoCgkJICogVGhpcyBmb3JtYXQgaXMgdG8gcHV0IGhpZ2hlciBvcmRlciBzdGFnZXMgaW50byB0aGUKCQkgKiBpbmRleCBmaWxlIGFuZCBtYXRjaGVzICJnaXQgbHMtZmlsZXMgLS1zdGFnZSIgb3V0cHV0LgoJCSAqLwoJCWVycm5vID0gMDsKCQl1bCA9IHN0cnRvdWwoYnVmLmJ1ZiwgJnB0ciwgOCk7CgkJaWYgKHB0ciA9PSBidWYuYnVmIHx8ICpwdHIgIT0gJyAnCgkJICAgIHx8IGVycm5vIHx8ICh1bnNpZ25lZCBpbnQpIHVsICE9IHVsKQoJCQlnb3RvIGJhZF9saW5lOwoJCW1vZGUgPSB1bDsKCgkJdGFiID0gc3RyY2hyKHB0ciwgJ1x0Jyk7CgkJaWYgKCF0YWIgfHwgdGFiIC0gcHRyIDwgNDEpCgkJCWdvdG8gYmFkX2xpbmU7CgoJCWlmICh0YWJbLTJdID09ICcgJyAmJiAnMCcgPD0gdGFiWy0xXSAmJiB0YWJbLTFdIDw9ICczJykgewoJCQlzdGFnZSA9IHRhYlstMV0gLSAnMCc7CgkJCXB0ciA9IHRhYiArIDE7IC8qIHBvaW50IGF0IHRoZSBoZWFkIG9mIHBhdGggKi8KCQkJdGFiID0gdGFiIC0gMjsgLyogcG9pbnQgYXQgdGFpbCBvZiBzaGExICovCgkJfQoJCWVsc2UgewoJCQlzdGFnZSA9IDA7CgkJCXB0ciA9IHRhYiArIDE7IC8qIHBvaW50IGF0IHRoZSBoZWFkIG9mIHBhdGggKi8KCQl9CgoJCWlmIChnZXRfc2hhMV9oZXgodGFiIC0gNDAsIHNoYTEpIHx8IHRhYlstNDFdICE9ICcgJykKCQkJZ290byBiYWRfbGluZTsKCgkJcGF0aF9uYW1lID0gcHRyOwoJCWlmIChsaW5lX3Rlcm1pbmF0aW9uICYmIHBhdGhfbmFtZVswXSA9PSAnIicpIHsKCQkJc3RyYnVmX3Jlc2V0KCZ1cSk7CgkJCWlmICh1bnF1b3RlX2Nfc3R5bGUoJnVxLCBwYXRoX25hbWUsIE5VTEwpKSB7CgkJCQlkaWUoImdpdCB1cGRhdGUtaW5kZXg6IGJhZCBxdW90aW5nIG9mIHBhdGggbmFtZSIpOwoJCQl9CgkJCXBhdGhfbmFtZSA9IHVxLmJ1ZjsKCQl9CgoJCWlmICghdmVyaWZ5X3BhdGgocGF0aF9uYW1lKSkgewoJCQlmcHJpbnRmKHN0ZGVyciwgIklnbm9yaW5nIHBhdGggJXNcbiIsIHBhdGhfbmFtZSk7CgkJCWNvbnRpbnVlOwoJCX0KCgkJaWYgKCFtb2RlKSB7CgkJCS8qIG1vZGUgPT0gMCBtZWFucyB0aGVyZSBpcyBubyBzdWNoIHBhdGggLS0gcmVtb3ZlICovCgkJCWlmIChyZW1vdmVfZmlsZV9mcm9tX2NhY2hlKHBhdGhfbmFtZSkpCgkJCQlkaWUoImdpdCB1cGRhdGUtaW5kZXg6IHVuYWJsZSB0byByZW1vdmUgJXMiLAoJCQkJICAgIHB0cik7CgkJfQoJCWVsc2UgewoJCQkvKiBtb2RlICcgJyBzaGExICdcdCcgbmFtZQoJCQkgKiBwdHJbLTFdIHBvaW50cyBhdCB0YWIsCgkJCSAqIHB0clstNDFdIGlzIGF0IHRoZSBiZWdpbm5pbmcgb2Ygc2hhMQoJCQkgKi8KCQkJcHRyWy00Ml0gPSBwdHJbLTFdID0gMDsKCQkJaWYgKGFkZF9jYWNoZWluZm8obW9kZSwgc2hhMSwgcGF0aF9uYW1lLCBzdGFnZSkpCgkJCQlkaWUoImdpdCB1cGRhdGUtaW5kZXg6IHVuYWJsZSB0byB1cGRhdGUgJXMiLAoJCQkJICAgIHBhdGhfbmFtZSk7CgkJfQoJCWNvbnRpbnVlOwoKCWJhZF9saW5lOgoJCWRpZSgibWFsZm9ybWVkIGluZGV4IGluZm8gJXMiLCBidWYuYnVmKTsKCX0KCXN0cmJ1Zl9yZWxlYXNlKCZidWYpOwoJc3RyYnVmX3JlbGVhc2UoJnVxKTsKfQoKc3RhdGljIGNvbnN0IGNoYXIgKiBjb25zdCB1cGRhdGVfaW5kZXhfdXNhZ2VbXSA9IHsKCU5fKCJnaXQgdXBkYXRlLWluZGV4IFtvcHRpb25zXSBbLS1dIFs8ZmlsZT4uLi5dIiksCglOVUxMCn07CgpzdGF0aWMgdW5zaWduZWQgY2hhciBoZWFkX3NoYTFbMjBdOwpzdGF0aWMgdW5zaWduZWQgY2hhciBtZXJnZV9oZWFkX3NoYTFbMjBdOwoKc3RhdGljIHN0cnVjdCBjYWNoZV9lbnRyeSAqcmVhZF9vbmVfZW50KGNvbnN0IGNoYXIgKndoaWNoLAoJCQkJCXVuc2lnbmVkIGNoYXIgKmVudCwgY29uc3QgY2hhciAqcGF0aCwKCQkJCQlpbnQgbmFtZWxlbiwgaW50IHN0YWdlKQp7Cgl1bnNpZ25lZCBtb2RlOwoJdW5zaWduZWQgY2hhciBzaGExWzIwXTsKCWludCBzaXplOwoJc3RydWN0IGNhY2hlX2VudHJ5ICpjZTsKCglpZiAoZ2V0X3RyZWVfZW50cnkoZW50LCBwYXRoLCBzaGExLCAmbW9kZSkpIHsKCQlpZiAod2hpY2gpCgkJCWVycm9yKCIlczogbm90IGluICVzIGJyYW5jaC4iLCBwYXRoLCB3aGljaCk7CgkJcmV0dXJuIE5VTEw7Cgl9CglpZiAobW9kZSA9PSBTX0lGRElSKSB7CgkJaWYgKHdoaWNoKQoJCQllcnJvcigiJXM6IG5vdCBhIGJsb2IgaW4gJXMgYnJhbmNoLiIsIHBhdGgsIHdoaWNoKTsKCQlyZXR1cm4gTlVMTDsKCX0KCXNpemUgPSBjYWNoZV9lbnRyeV9zaXplKG5hbWVsZW4pOwoJY2UgPSB4Y2FsbG9jKDEsIHNpemUpOwoKCWhhc2hjcHkoY2UtPnNoYTEsIHNoYTEpOwoJbWVtY3B5KGNlLT5uYW1lLCBwYXRoLCBuYW1lbGVuKTsKCWNlLT5jZV9mbGFncyA9IGNyZWF0ZV9jZV9mbGFncyhzdGFnZSk7CgljZS0+Y2VfbmFtZWxlbiA9IG5hbWVsZW47CgljZS0+Y2VfbW9kZSA9IGNyZWF0ZV9jZV9tb2RlKG1vZGUpOwoJcmV0dXJuIGNlOwp9CgpzdGF0aWMgaW50IHVucmVzb2x2ZV9vbmUoY29uc3QgY2hhciAqcGF0aCkKewoJaW50IG5hbWVsZW4gPSBzdHJsZW4ocGF0aCk7CglpbnQgcG9zOwoJaW50IHJldCA9IDA7CglzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlXzIgPSBOVUxMLCAqY2VfMyA9IE5VTEw7CgoJLyogU2VlIGlmIHRoZXJlIGlzIHN1Y2ggZW50cnkgaW4gdGhlIGluZGV4LiAqLwoJcG9zID0gY2FjaGVfbmFtZV9wb3MocGF0aCwgbmFtZWxlbik7CglpZiAoMCA8PSBwb3MpIHsKCQkvKiBhbHJlYWR5IG1lcmdlZCAqLwoJCXBvcyA9IHVubWVyZ2VfY2FjaGVfZW50cnlfYXQocG9zKTsKCQlpZiAocG9zIDwgYWN0aXZlX25yKSB7CgkJCWNvbnN0IHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UgPSBhY3RpdmVfY2FjaGVbcG9zXTsKCQkJaWYgKGNlX3N0YWdlKGNlKSAmJgoJCQkgICAgY2VfbmFtZWxlbihjZSkgPT0gbmFtZWxlbiAmJgoJCQkgICAgIW1lbWNtcChjZS0+bmFtZSwgcGF0aCwgbmFtZWxlbikpCgkJCQlyZXR1cm4gMDsKCQl9CgkJLyogbm8gcmVzb2x2ZS11bmRvIGluZm9ybWF0aW9uOyBmYWxsIGJhY2sgKi8KCX0gZWxzZSB7CgkJLyogSWYgdGhlcmUgaXNuJ3QsIGVpdGhlciBpdCBpcyB1bm1lcmdlZCwgb3IKCQkgKiByZXNvbHZlZCBhcyAicmVtb3ZlZCIgYnkgbWlzdGFrZS4gIFdlIGRvIG5vdAoJCSAqIHdhbnQgdG8gZG8gYW55dGhpbmcgaW4gdGhlIGZvcm1lciBjYXNlLgoJCSAqLwoJCXBvcyA9IC1wb3MtMTsKCQlpZiAocG9zIDwgYWN0aXZlX25yKSB7CgkJCWNvbnN0IHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UgPSBhY3RpdmVfY2FjaGVbcG9zXTsKCQkJaWYgKGNlX25hbWVsZW4oY2UpID09IG5hbWVsZW4gJiYKCQkJICAgICFtZW1jbXAoY2UtPm5hbWUsIHBhdGgsIG5hbWVsZW4pKSB7CgkJCQlmcHJpbnRmKHN0ZGVyciwKCQkJCQkiJXM6IHNraXBwaW5nIHN0aWxsIHVubWVyZ2VkIHBhdGguXG4iLAoJCQkJCXBhdGgpOwoJCQkJZ290byBmcmVlX3JldHVybjsKCQkJfQoJCX0KCX0KCgkvKiBHcmFiIGJsb2JzIGZyb20gZ2l2ZW4gcGF0aCBmcm9tIEhFQUQgYW5kIE1FUkdFX0hFQUQsCgkgKiBzdHVmZiBIRUFEIHZlcnNpb24gaW4gc3RhZ2UgIzIsCgkgKiBzdHVmZiBNRVJHRV9IRUFEIHZlcnNpb24gaW4gc3RhZ2UgIzMuCgkgKi8KCWNlXzIgPSByZWFkX29uZV9lbnQoIm91ciIsIGhlYWRfc2hhMSwgcGF0aCwgbmFtZWxlbiwgMik7CgljZV8zID0gcmVhZF9vbmVfZW50KCJ0aGVpciIsIG1lcmdlX2hlYWRfc2hhMSwgcGF0aCwgbmFtZWxlbiwgMyk7CgoJaWYgKCFjZV8yIHx8ICFjZV8zKSB7CgkJcmV0ID0gLTE7CgkJZ290byBmcmVlX3JldHVybjsKCX0KCWlmICghaGFzaGNtcChjZV8yLT5zaGExLCBjZV8zLT5zaGExKSAmJgoJICAgIGNlXzItPmNlX21vZGUgPT0gY2VfMy0+Y2VfbW9kZSkgewoJCWZwcmludGYoc3RkZXJyLCAiJXM6IGlkZW50aWNhbCBpbiBib3RoLCBza2lwcGluZy5cbiIsCgkJCXBhdGgpOwoJCWdvdG8gZnJlZV9yZXR1cm47Cgl9CgoJcmVtb3ZlX2ZpbGVfZnJvbV9jYWNoZShwYXRoKTsKCWlmIChhZGRfY2FjaGVfZW50cnkoY2VfMiwgQUREX0NBQ0hFX09LX1RPX0FERCkpIHsKCQllcnJvcigiJXM6IGNhbm5vdCBhZGQgb3VyIHZlcnNpb24gdG8gdGhlIGluZGV4LiIsIHBhdGgpOwoJCXJldCA9IC0xOwoJCWdvdG8gZnJlZV9yZXR1cm47Cgl9CglpZiAoIWFkZF9jYWNoZV9lbnRyeShjZV8zLCBBRERfQ0FDSEVfT0tfVE9fQUREKSkKCQlyZXR1cm4gMDsKCWVycm9yKCIlczogY2Fubm90IGFkZCB0aGVpciB2ZXJzaW9uIHRvIHRoZSBpbmRleC4iLCBwYXRoKTsKCXJldCA9IC0xOwogZnJlZV9yZXR1cm46CglmcmVlKGNlXzIpOwoJZnJlZShjZV8zKTsKCXJldHVybiByZXQ7Cn0KCnN0YXRpYyB2b2lkIHJlYWRfaGVhZF9wb2ludGVycyh2b2lkKQp7CglpZiAocmVhZF9yZWYoIkhFQUQiLCBoZWFkX3NoYTEpKQoJCWRpZSgiTm8gSEVBRCAtLSBubyBpbml0aWFsIGNvbW1pdCB5ZXQ/Iik7CglpZiAocmVhZF9yZWYoIk1FUkdFX0hFQUQiLCBtZXJnZV9oZWFkX3NoYTEpKSB7CgkJZnByaW50ZihzdGRlcnIsICJOb3QgaW4gdGhlIG1pZGRsZSBvZiBhIG1lcmdlLlxuIik7CgkJZXhpdCgwKTsKCX0KfQoKc3RhdGljIGludCBkb191bnJlc29sdmUoaW50IGFjLCBjb25zdCBjaGFyICoqYXYsCgkJCWNvbnN0IGNoYXIgKnByZWZpeCwgaW50IHByZWZpeF9sZW5ndGgpCnsKCWludCBpOwoJaW50IGVyciA9IDA7CgoJLyogUmVhZCBIRUFEIGFuZCBNRVJHRV9IRUFEOyBpZiBNRVJHRV9IRUFEIGRvZXMgbm90IGV4aXN0LCB3ZQoJICogYXJlIG5vdCBkb2luZyBhIG1lcmdlLCBzbyBleGl0IHdpdGggc3VjY2VzcyBzdGF0dXMuCgkgKi8KCXJlYWRfaGVhZF9wb2ludGVycygpOwoKCWZvciAoaSA9IDE7IGkgPCBhYzsgaSsrKSB7CgkJY29uc3QgY2hhciAqYXJnID0gYXZbaV07CgkJY29uc3QgY2hhciAqcCA9IHByZWZpeF9wYXRoKHByZWZpeCwgcHJlZml4X2xlbmd0aCwgYXJnKTsKCQllcnIgfD0gdW5yZXNvbHZlX29uZShwKTsKCQlpZiAocCA8IGFyZyB8fCBwID4gYXJnICsgc3RybGVuKGFyZykpCgkJCWZyZWUoKGNoYXIgKilwKTsKCX0KCXJldHVybiBlcnI7Cn0KCnN0YXRpYyBpbnQgZG9fcmV1cGRhdGUoaW50IGFjLCBjb25zdCBjaGFyICoqYXYsCgkJICAgICAgIGNvbnN0IGNoYXIgKnByZWZpeCwgaW50IHByZWZpeF9sZW5ndGgpCnsKCS8qIFJlYWQgSEVBRCBhbmQgcnVuIHVwZGF0ZS1pbmRleCBvbiBwYXRocyB0aGF0IGFyZQoJICogbWVyZ2VkIGFuZCBhbHJlYWR5IGRpZmZlcmVudCBiZXR3ZWVuIGluZGV4IGFuZCBIRUFELgoJICovCglpbnQgcG9zOwoJaW50IGhhc19oZWFkID0gMTsKCXN0cnVjdCBwYXRoc3BlYyBwYXRoc3BlYzsKCglwYXJzZV9wYXRoc3BlYygmcGF0aHNwZWMsIDAsCgkJICAgICAgIFBBVEhTUEVDX1BSRUZFUl9DV0QsCgkJICAgICAgIHByZWZpeCwgYXYgKyAxKTsKCglpZiAocmVhZF9yZWYoIkhFQUQiLCBoZWFkX3NoYTEpKQoJCS8qIElmIHRoZXJlIGlzIG5vIEhFQUQsIHRoYXQgbWVhbnMgaXQgaXMgYW4gaW5pdGlhbAoJCSAqIGNvbW1pdC4gIFVwZGF0ZSBldmVyeXRoaW5nIGluIHRoZSBpbmRleC4KCQkgKi8KCQloYXNfaGVhZCA9IDA7CiByZWRvOgoJZm9yIChwb3MgPSAwOyBwb3MgPCBhY3RpdmVfbnI7IHBvcysrKSB7CgkJY29uc3Qgc3RydWN0IGNhY2hlX2VudHJ5ICpjZSA9IGFjdGl2ZV9jYWNoZVtwb3NdOwoJCXN0cnVjdCBjYWNoZV9lbnRyeSAqb2xkID0gTlVMTDsKCQlpbnQgc2F2ZV9ucjsKCQljaGFyICpwYXRoOwoKCQlpZiAoY2Vfc3RhZ2UoY2UpIHx8ICFjZV9wYXRoX21hdGNoKGNlLCAmcGF0aHNwZWMpKQoJCQljb250aW51ZTsKCQlpZiAoaGFzX2hlYWQpCgkJCW9sZCA9IHJlYWRfb25lX2VudChOVUxMLCBoZWFkX3NoYTEsCgkJCQkJICAgY2UtPm5hbWUsIGNlX25hbWVsZW4oY2UpLCAwKTsKCQlpZiAob2xkICYmIGNlLT5jZV9tb2RlID09IG9sZC0+Y2VfbW9kZSAmJgoJCSAgICAhaGFzaGNtcChjZS0+c2hhMSwgb2xkLT5zaGExKSkgewoJCQlmcmVlKG9sZCk7CgkJCWNvbnRpbnVlOyAvKiB1bmNoYW5nZWQgKi8KCQl9CgkJLyogQmUgY2FyZWZ1bC4gIFRoZSB3b3JraW5nIHRyZWUgbWF5IG5vdCBoYXZlIHRoZQoJCSAqIHBhdGggYW55bW9yZSwgaW4gd2hpY2ggY2FzZSwgdW5kZXIgJ2FsbG93X3JlbW92ZScsCgkJICogb3Igd29yc2UgeWV0ICdhbGxvd19yZXBsYWNlJywgYWN0aXZlX25yIG1heSBkZWNyZWFzZS4KCQkgKi8KCQlzYXZlX25yID0gYWN0aXZlX25yOwoJCXBhdGggPSB4c3RyZHVwKGNlLT5uYW1lKTsKCQl1cGRhdGVfb25lKHBhdGgpOwoJCWZyZWUocGF0aCk7CgkJaWYgKHNhdmVfbnIgIT0gYWN0aXZlX25yKQoJCQlnb3RvIHJlZG87Cgl9CglmcmVlX3BhdGhzcGVjKCZwYXRoc3BlYyk7CglyZXR1cm4gMDsKfQoKc3RydWN0IHJlZnJlc2hfcGFyYW1zIHsKCXVuc2lnbmVkIGludCBmbGFnczsKCWludCAqaGFzX2Vycm9yczsKfTsKCnN0YXRpYyBpbnQgcmVmcmVzaChzdHJ1Y3QgcmVmcmVzaF9wYXJhbXMgKm8sIHVuc2lnbmVkIGludCBmbGFnKQp7CglzZXR1cF93b3JrX3RyZWUoKTsKCXJlYWRfY2FjaGVfcHJlbG9hZChOVUxMKTsKCSpvLT5oYXNfZXJyb3JzIHw9IHJlZnJlc2hfY2FjaGUoby0+ZmxhZ3MgfCBmbGFnKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IHJlZnJlc2hfY2FsbGJhY2soY29uc3Qgc3RydWN0IG9wdGlvbiAqb3B0LAoJCQkJY29uc3QgY2hhciAqYXJnLCBpbnQgdW5zZXQpCnsKCXJldHVybiByZWZyZXNoKG9wdC0+dmFsdWUsIDApOwp9CgpzdGF0aWMgaW50IHJlYWxseV9yZWZyZXNoX2NhbGxiYWNrKGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdCwKCQkJCWNvbnN0IGNoYXIgKmFyZywgaW50IHVuc2V0KQp7CglyZXR1cm4gcmVmcmVzaChvcHQtPnZhbHVlLCBSRUZSRVNIX1JFQUxMWSk7Cn0KCnN0YXRpYyBpbnQgY2htb2RfY2FsbGJhY2soY29uc3Qgc3RydWN0IG9wdGlvbiAqb3B0LAoJCQkJY29uc3QgY2hhciAqYXJnLCBpbnQgdW5zZXQpCnsKCWNoYXIgKmZsaXAgPSBvcHQtPnZhbHVlOwoJaWYgKChhcmdbMF0gIT0gJy0nICYmIGFyZ1swXSAhPSAnKycpIHx8IGFyZ1sxXSAhPSAneCcgfHwgYXJnWzJdKQoJCXJldHVybiBlcnJvcigib3B0aW9uICdjaG1vZCcgZXhwZWN0cyBcIit4XCIgb3IgXCIteFwiIik7CgkqZmxpcCA9IGFyZ1swXTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IHJlc29sdmVfdW5kb19jbGVhcl9jYWxsYmFjayhjb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHQsCgkJCQljb25zdCBjaGFyICphcmcsIGludCB1bnNldCkKewoJcmVzb2x2ZV91bmRvX2NsZWFyKCk7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBjYWNoZWluZm9fY2FsbGJhY2soc3RydWN0IHBhcnNlX29wdF9jdHhfdCAqY3R4LAoJCQkJY29uc3Qgc3RydWN0IG9wdGlvbiAqb3B0LCBpbnQgdW5zZXQpCnsKCXVuc2lnbmVkIGNoYXIgc2hhMVsyMF07Cgl1bnNpZ25lZCBpbnQgbW9kZTsKCglpZiAoY3R4LT5hcmdjIDw9IDMpCgkJcmV0dXJuIGVycm9yKCJvcHRpb24gJ2NhY2hlaW5mbycgZXhwZWN0cyB0aHJlZSBhcmd1bWVudHMiKTsKCWlmIChzdHJ0b3VsX3VpKCorK2N0eC0+YXJndiwgOCwgJm1vZGUpIHx8CgkgICAgZ2V0X3NoYTFfaGV4KCorK2N0eC0+YXJndiwgc2hhMSkgfHwKCSAgICBhZGRfY2FjaGVpbmZvKG1vZGUsIHNoYTEsICorK2N0eC0+YXJndiwgMCkpCgkJZGllKCJnaXQgdXBkYXRlLWluZGV4OiAtLWNhY2hlaW5mbyBjYW5ub3QgYWRkICVzIiwgKmN0eC0+YXJndik7CgljdHgtPmFyZ2MgLT0gMzsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IHN0ZGluX2NhY2hlaW5mb19jYWxsYmFjayhzdHJ1Y3QgcGFyc2Vfb3B0X2N0eF90ICpjdHgsCgkJCSAgICAgIGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdCwgaW50IHVuc2V0KQp7CglpbnQgKmxpbmVfdGVybWluYXRpb24gPSBvcHQtPnZhbHVlOwoKCWlmIChjdHgtPmFyZ2MgIT0gMSkKCQlyZXR1cm4gZXJyb3IoIm9wdGlvbiAnJXMnIG11c3QgYmUgdGhlIGxhc3QgYXJndW1lbnQiLCBvcHQtPmxvbmdfbmFtZSk7CglhbGxvd19hZGQgPSBhbGxvd19yZXBsYWNlID0gYWxsb3dfcmVtb3ZlID0gMTsKCXJlYWRfaW5kZXhfaW5mbygqbGluZV90ZXJtaW5hdGlvbik7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBzdGRpbl9jYWxsYmFjayhzdHJ1Y3QgcGFyc2Vfb3B0X2N0eF90ICpjdHgsCgkJCQljb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHQsIGludCB1bnNldCkKewoJaW50ICpyZWFkX2Zyb21fc3RkaW4gPSBvcHQtPnZhbHVlOwoKCWlmIChjdHgtPmFyZ2MgIT0gMSkKCQlyZXR1cm4gZXJyb3IoIm9wdGlvbiAnJXMnIG11c3QgYmUgdGhlIGxhc3QgYXJndW1lbnQiLCBvcHQtPmxvbmdfbmFtZSk7CgkqcmVhZF9mcm9tX3N0ZGluID0gMTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IHVucmVzb2x2ZV9jYWxsYmFjayhzdHJ1Y3QgcGFyc2Vfb3B0X2N0eF90ICpjdHgsCgkJCQljb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHQsIGludCBmbGFncykKewoJaW50ICpoYXNfZXJyb3JzID0gb3B0LT52YWx1ZTsKCWNvbnN0IGNoYXIgKnByZWZpeCA9IHN0YXJ0dXBfaW5mby0+cHJlZml4OwoKCS8qIGNvbnN1bWUgcmVtYWluaW5nIGFyZ3VtZW50cy4gKi8KCSpoYXNfZXJyb3JzID0gZG9fdW5yZXNvbHZlKGN0eC0+YXJnYywgY3R4LT5hcmd2LAoJCQkJcHJlZml4LCBwcmVmaXggPyBzdHJsZW4ocHJlZml4KSA6IDApOwoJaWYgKCpoYXNfZXJyb3JzKQoJCWFjdGl2ZV9jYWNoZV9jaGFuZ2VkID0gMDsKCgljdHgtPmFyZ3YgKz0gY3R4LT5hcmdjIC0gMTsKCWN0eC0+YXJnYyA9IDE7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCByZXVwZGF0ZV9jYWxsYmFjayhzdHJ1Y3QgcGFyc2Vfb3B0X2N0eF90ICpjdHgsCgkJCQljb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHQsIGludCBmbGFncykKewoJaW50ICpoYXNfZXJyb3JzID0gb3B0LT52YWx1ZTsKCWNvbnN0IGNoYXIgKnByZWZpeCA9IHN0YXJ0dXBfaW5mby0+cHJlZml4OwoKCS8qIGNvbnN1bWUgcmVtYWluaW5nIGFyZ3VtZW50cy4gKi8KCXNldHVwX3dvcmtfdHJlZSgpOwoJKmhhc19lcnJvcnMgPSBkb19yZXVwZGF0ZShjdHgtPmFyZ2MsIGN0eC0+YXJndiwKCQkJCXByZWZpeCwgcHJlZml4ID8gc3RybGVuKHByZWZpeCkgOiAwKTsKCWlmICgqaGFzX2Vycm9ycykKCQlhY3RpdmVfY2FjaGVfY2hhbmdlZCA9IDA7CgoJY3R4LT5hcmd2ICs9IGN0eC0+YXJnYyAtIDE7CgljdHgtPmFyZ2MgPSAxOwoJcmV0dXJuIDA7Cn0KCmludCBjbWRfdXBkYXRlX2luZGV4KGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndiwgY29uc3QgY2hhciAqcHJlZml4KQp7CglpbnQgbmV3ZmQsIGVudHJpZXMsIGhhc19lcnJvcnMgPSAwLCBsaW5lX3Rlcm1pbmF0aW9uID0gJ1xuJzsKCWludCByZWFkX2Zyb21fc3RkaW4gPSAwOwoJaW50IHByZWZpeF9sZW5ndGggPSBwcmVmaXggPyBzdHJsZW4ocHJlZml4KSA6IDA7CglpbnQgcHJlZmVycmVkX2luZGV4X2Zvcm1hdCA9IDA7CgljaGFyIHNldF9leGVjdXRhYmxlX2JpdCA9IDA7CglzdHJ1Y3QgcmVmcmVzaF9wYXJhbXMgcmVmcmVzaF9hcmdzID0gezAsICZoYXNfZXJyb3JzfTsKCWludCBsb2NrX2Vycm9yID0gMDsKCXN0cnVjdCBsb2NrX2ZpbGUgKmxvY2tfZmlsZTsKCXN0cnVjdCBwYXJzZV9vcHRfY3R4X3QgY3R4OwoJaW50IHBhcnNlb3B0X3N0YXRlID0gUEFSU0VfT1BUX1VOS05PV047CglzdHJ1Y3Qgb3B0aW9uIG9wdGlvbnNbXSA9IHsKCQlPUFRfQklUKCdxJywgTlVMTCwgJnJlZnJlc2hfYXJncy5mbGFncywKCQkJTl8oImNvbnRpbnVlIHJlZnJlc2ggZXZlbiB3aGVuIGluZGV4IG5lZWRzIHVwZGF0ZSIpLAoJCQlSRUZSRVNIX1FVSUVUKSwKCQlPUFRfQklUKDAsICJpZ25vcmUtc3VibW9kdWxlcyIsICZyZWZyZXNoX2FyZ3MuZmxhZ3MsCgkJCU5fKCJyZWZyZXNoOiBpZ25vcmUgc3VibW9kdWxlcyIpLAoJCQlSRUZSRVNIX0lHTk9SRV9TVUJNT0RVTEVTKSwKCQlPUFRfU0VUX0lOVCgwLCAiYWRkIiwgJmFsbG93X2FkZCwKCQkJTl8oImRvIG5vdCBpZ25vcmUgbmV3IGZpbGVzIiksIDEpLAoJCU9QVF9TRVRfSU5UKDAsICJyZXBsYWNlIiwgJmFsbG93X3JlcGxhY2UsCgkJCU5fKCJsZXQgZmlsZXMgcmVwbGFjZSBkaXJlY3RvcmllcyBhbmQgdmljZS12ZXJzYSIpLCAxKSwKCQlPUFRfU0VUX0lOVCgwLCAicmVtb3ZlIiwgJmFsbG93X3JlbW92ZSwKCQkJTl8oIm5vdGljZSBmaWxlcyBtaXNzaW5nIGZyb20gd29ya3RyZWUiKSwgMSksCgkJT1BUX0JJVCgwLCAidW5tZXJnZWQiLCAmcmVmcmVzaF9hcmdzLmZsYWdzLAoJCQlOXygicmVmcmVzaCBldmVuIGlmIGluZGV4IGNvbnRhaW5zIHVubWVyZ2VkIGVudHJpZXMiKSwKCQkJUkVGUkVTSF9VTk1FUkdFRCksCgkJe09QVElPTl9DQUxMQkFDSywgMCwgInJlZnJlc2giLCAmcmVmcmVzaF9hcmdzLCBOVUxMLAoJCQlOXygicmVmcmVzaCBzdGF0IGluZm9ybWF0aW9uIiksCgkJCVBBUlNFX09QVF9OT0FSRyB8IFBBUlNFX09QVF9OT05FRywKCQkJcmVmcmVzaF9jYWxsYmFja30sCgkJe09QVElPTl9DQUxMQkFDSywgMCwgInJlYWxseS1yZWZyZXNoIiwgJnJlZnJlc2hfYXJncywgTlVMTCwKCQkJTl8oImxpa2UgLS1yZWZyZXNoLCBidXQgaWdub3JlIGFzc3VtZS11bmNoYW5nZWQgc2V0dGluZyIpLAoJCQlQQVJTRV9PUFRfTk9BUkcgfCBQQVJTRV9PUFRfTk9ORUcsCgkJCXJlYWxseV9yZWZyZXNoX2NhbGxiYWNrfSwKCQl7T1BUSU9OX0xPV0xFVkVMX0NBTExCQUNLLCAwLCAiY2FjaGVpbmZvIiwgTlVMTCwKCQkJTl8oIjxtb2RlPiA8b2JqZWN0PiA8cGF0aD4iKSwKCQkJTl8oImFkZCB0aGUgc3BlY2lmaWVkIGVudHJ5IHRvIHRoZSBpbmRleCIpLAoJCQlQQVJTRV9PUFRfTk9BUkcgfAkvKiBkaXNhbGxvdyAtLWNhY2hlaW5mbz08bW9kZT4gZm9ybSAqLwoJCQlQQVJTRV9PUFRfTk9ORUcgfCBQQVJTRV9PUFRfTElURVJBTF9BUkdIRUxQLAoJCQkocGFyc2Vfb3B0X2NiICopIGNhY2hlaW5mb19jYWxsYmFja30sCgkJe09QVElPTl9DQUxMQkFDSywgMCwgImNobW9kIiwgJnNldF9leGVjdXRhYmxlX2JpdCwgTl8oIigrLy0peCIpLAoJCQlOXygib3ZlcnJpZGUgdGhlIGV4ZWN1dGFibGUgYml0IG9mIHRoZSBsaXN0ZWQgZmlsZXMiKSwKCQkJUEFSU0VfT1BUX05PTkVHIHwgUEFSU0VfT1BUX0xJVEVSQUxfQVJHSEVMUCwKCQkJY2htb2RfY2FsbGJhY2t9LAoJCXtPUFRJT05fU0VUX0lOVCwgMCwgImFzc3VtZS11bmNoYW5nZWQiLCAmbWFya192YWxpZF9vbmx5LCBOVUxMLAoJCQlOXygibWFyayBmaWxlcyBhcyBcIm5vdCBjaGFuZ2luZ1wiIiksCgkJCVBBUlNFX09QVF9OT0FSRyB8IFBBUlNFX09QVF9OT05FRywgTlVMTCwgTUFSS19GTEFHfSwKCQl7T1BUSU9OX1NFVF9JTlQsIDAsICJuby1hc3N1bWUtdW5jaGFuZ2VkIiwgJm1hcmtfdmFsaWRfb25seSwgTlVMTCwKCQkJTl8oImNsZWFyIGFzc3VtZWQtdW5jaGFuZ2VkIGJpdCIpLAoJCQlQQVJTRV9PUFRfTk9BUkcgfCBQQVJTRV9PUFRfTk9ORUcsIE5VTEwsIFVOTUFSS19GTEFHfSwKCQl7T1BUSU9OX1NFVF9JTlQsIDAsICJza2lwLXdvcmt0cmVlIiwgJm1hcmtfc2tpcF93b3JrdHJlZV9vbmx5LCBOVUxMLAoJCQlOXygibWFyayBmaWxlcyBhcyBcImluZGV4LW9ubHlcIiIpLAoJCQlQQVJTRV9PUFRfTk9BUkcgfCBQQVJTRV9PUFRfTk9ORUcsIE5VTEwsIE1BUktfRkxBR30sCgkJe09QVElPTl9TRVRfSU5ULCAwLCAibm8tc2tpcC13b3JrdHJlZSIsICZtYXJrX3NraXBfd29ya3RyZWVfb25seSwgTlVMTCwKCQkJTl8oImNsZWFyIHNraXAtd29ya3RyZWUgYml0IiksCgkJCVBBUlNFX09QVF9OT0FSRyB8IFBBUlNFX09QVF9OT05FRywgTlVMTCwgVU5NQVJLX0ZMQUd9LAoJCU9QVF9TRVRfSU5UKDAsICJpbmZvLW9ubHkiLCAmaW5mb19vbmx5LAoJCQlOXygiYWRkIHRvIGluZGV4IG9ubHk7IGRvIG5vdCBhZGQgY29udGVudCB0byBvYmplY3QgZGF0YWJhc2UiKSwgMSksCgkJT1BUX1NFVF9JTlQoMCwgImZvcmNlLXJlbW92ZSIsICZmb3JjZV9yZW1vdmUsCgkJCU5fKCJyZW1vdmUgbmFtZWQgcGF0aHMgZXZlbiBpZiBwcmVzZW50IGluIHdvcmt0cmVlIiksIDEpLAoJCU9QVF9TRVRfSU5UKCd6JywgTlVMTCwgJmxpbmVfdGVybWluYXRpb24sCgkJCU5fKCJ3aXRoIC0tc3RkaW46IGlucHV0IGxpbmVzIGFyZSB0ZXJtaW5hdGVkIGJ5IG51bGwgYnl0ZXMiKSwgJ1wwJyksCgkJe09QVElPTl9MT1dMRVZFTF9DQUxMQkFDSywgMCwgInN0ZGluIiwgJnJlYWRfZnJvbV9zdGRpbiwgTlVMTCwKCQkJTl8oInJlYWQgbGlzdCBvZiBwYXRocyB0byBiZSB1cGRhdGVkIGZyb20gc3RhbmRhcmQgaW5wdXQiKSwKCQkJUEFSU0VfT1BUX05PTkVHIHwgUEFSU0VfT1BUX05PQVJHLAoJCQkocGFyc2Vfb3B0X2NiICopIHN0ZGluX2NhbGxiYWNrfSwKCQl7T1BUSU9OX0xPV0xFVkVMX0NBTExCQUNLLCAwLCAiaW5kZXgtaW5mbyIsICZsaW5lX3Rlcm1pbmF0aW9uLCBOVUxMLAoJCQlOXygiYWRkIGVudHJpZXMgZnJvbSBzdGFuZGFyZCBpbnB1dCB0byB0aGUgaW5kZXgiKSwKCQkJUEFSU0VfT1BUX05PTkVHIHwgUEFSU0VfT1BUX05PQVJHLAoJCQkocGFyc2Vfb3B0X2NiICopIHN0ZGluX2NhY2hlaW5mb19jYWxsYmFja30sCgkJe09QVElPTl9MT1dMRVZFTF9DQUxMQkFDSywgMCwgInVucmVzb2x2ZSIsICZoYXNfZXJyb3JzLCBOVUxMLAoJCQlOXygicmVwb3B1bGF0ZSBzdGFnZXMgIzIgYW5kICMzIGZvciB0aGUgbGlzdGVkIHBhdGhzIiksCgkJCVBBUlNFX09QVF9OT05FRyB8IFBBUlNFX09QVF9OT0FSRywKCQkJKHBhcnNlX29wdF9jYiAqKSB1bnJlc29sdmVfY2FsbGJhY2t9LAoJCXtPUFRJT05fTE9XTEVWRUxfQ0FMTEJBQ0ssICdnJywgImFnYWluIiwgJmhhc19lcnJvcnMsIE5VTEwsCgkJCU5fKCJvbmx5IHVwZGF0ZSBlbnRyaWVzIHRoYXQgZGlmZmVyIGZyb20gSEVBRCIpLAoJCQlQQVJTRV9PUFRfTk9ORUcgfCBQQVJTRV9PUFRfTk9BUkcsCgkJCShwYXJzZV9vcHRfY2IgKikgcmV1cGRhdGVfY2FsbGJhY2t9LAoJCU9QVF9CSVQoMCwgImlnbm9yZS1taXNzaW5nIiwgJnJlZnJlc2hfYXJncy5mbGFncywKCQkJTl8oImlnbm9yZSBmaWxlcyBtaXNzaW5nIGZyb20gd29ya3RyZWUiKSwKCQkJUkVGUkVTSF9JR05PUkVfTUlTU0lORyksCgkJT1BUX1NFVF9JTlQoMCwgInZlcmJvc2UiLCAmdmVyYm9zZSwKCQkJTl8oInJlcG9ydCBhY3Rpb25zIHRvIHN0YW5kYXJkIG91dHB1dCIpLCAxKSwKCQl7T1BUSU9OX0NBTExCQUNLLCAwLCAiY2xlYXItcmVzb2x2ZS11bmRvIiwgTlVMTCwgTlVMTCwKCQkJTl8oIihmb3IgcG9yY2VsYWlucykgZm9yZ2V0IHNhdmVkIHVucmVzb2x2ZWQgY29uZmxpY3RzIiksCgkJCVBBUlNFX09QVF9OT0FSRyB8IFBBUlNFX09QVF9OT05FRywKCQkJcmVzb2x2ZV91bmRvX2NsZWFyX2NhbGxiYWNrfSwKCQlPUFRfSU5URUdFUigwLCAiaW5kZXgtdmVyc2lvbiIsICZwcmVmZXJyZWRfaW5kZXhfZm9ybWF0LAoJCQlOXygid3JpdGUgaW5kZXggaW4gdGhpcyBmb3JtYXQiKSksCgkJT1BUX0VORCgpCgl9OwoKCWlmIChhcmdjID09IDIgJiYgIXN0cmNtcChhcmd2WzFdLCAiLWgiKSkKCQl1c2FnZV93aXRoX29wdGlvbnModXBkYXRlX2luZGV4X3VzYWdlLCBvcHRpb25zKTsKCglnaXRfY29uZmlnKGdpdF9kZWZhdWx0X2NvbmZpZywgTlVMTCk7CgoJLyogV2UgY2FuJ3QgZnJlZSB0aGlzIG1lbW9yeSwgaXQgYmVjb21lcyBwYXJ0IG9mIGEgbGlua2VkIGxpc3QgcGFyc2VkIGF0ZXhpdCgpICovCglsb2NrX2ZpbGUgPSB4Y2FsbG9jKDEsIHNpemVvZihzdHJ1Y3QgbG9ja19maWxlKSk7CgoJbmV3ZmQgPSBob2xkX2xvY2tlZF9pbmRleChsb2NrX2ZpbGUsIDApOwoJaWYgKG5ld2ZkIDwgMCkKCQlsb2NrX2Vycm9yID0gZXJybm87CgoJZW50cmllcyA9IHJlYWRfY2FjaGUoKTsKCWlmIChlbnRyaWVzIDwgMCkKCQlkaWUoImNhY2hlIGNvcnJ1cHRlZCIpOwoKCS8qCgkgKiBDdXN0b20gY29weSBvZiBwYXJzZV9vcHRpb25zKCkgYmVjYXVzZSB3ZSB3YW50IHRvIGhhbmRsZQoJICogZmlsZW5hbWUgYXJndW1lbnRzIGFzIHRoZXkgY29tZS4KCSAqLwoJcGFyc2Vfb3B0aW9uc19zdGFydCgmY3R4LCBhcmdjLCBhcmd2LCBwcmVmaXgsCgkJCSAgICBvcHRpb25zLCBQQVJTRV9PUFRfU1RPUF9BVF9OT05fT1BUSU9OKTsKCXdoaWxlIChjdHguYXJnYykgewoJCWlmIChwYXJzZW9wdF9zdGF0ZSAhPSBQQVJTRV9PUFRfRE9ORSkKCQkJcGFyc2VvcHRfc3RhdGUgPSBwYXJzZV9vcHRpb25zX3N0ZXAoJmN0eCwgb3B0aW9ucywKCQkJCQkJCSAgICB1cGRhdGVfaW5kZXhfdXNhZ2UpOwoJCWlmICghY3R4LmFyZ2MpCgkJCWJyZWFrOwoJCXN3aXRjaCAocGFyc2VvcHRfc3RhdGUpIHsKCQljYXNlIFBBUlNFX09QVF9IRUxQOgoJCQlleGl0KDEyOSk7CgkJY2FzZSBQQVJTRV9PUFRfTk9OX09QVElPTjoKCQljYXNlIFBBUlNFX09QVF9ET05FOgoJCXsKCQkJY29uc3QgY2hhciAqcGF0aCA9IGN0eC5hcmd2WzBdOwoJCQljb25zdCBjaGFyICpwOwoKCQkJc2V0dXBfd29ya190cmVlKCk7CgkJCXAgPSBwcmVmaXhfcGF0aChwcmVmaXgsIHByZWZpeF9sZW5ndGgsIHBhdGgpOwoJCQl1cGRhdGVfb25lKHApOwoJCQlpZiAoc2V0X2V4ZWN1dGFibGVfYml0KQoJCQkJY2htb2RfcGF0aChzZXRfZXhlY3V0YWJsZV9iaXQsIHApOwoJCQlmcmVlKChjaGFyICopcCk7CgkJCWN0eC5hcmdjLS07CgkJCWN0eC5hcmd2Kys7CgkJCWJyZWFrOwoJCX0KCQljYXNlIFBBUlNFX09QVF9VTktOT1dOOgoJCQlpZiAoY3R4LmFyZ3ZbMF1bMV0gPT0gJy0nKQoJCQkJZXJyb3IoInVua25vd24gb3B0aW9uICclcyciLCBjdHguYXJndlswXSArIDIpOwoJCQllbHNlCgkJCQllcnJvcigidW5rbm93biBzd2l0Y2ggJyVjJyIsICpjdHgub3B0KTsKCQkJdXNhZ2Vfd2l0aF9vcHRpb25zKHVwZGF0ZV9pbmRleF91c2FnZSwgb3B0aW9ucyk7CgkJfQoJfQoJYXJnYyA9IHBhcnNlX29wdGlvbnNfZW5kKCZjdHgpOwoJaWYgKHByZWZlcnJlZF9pbmRleF9mb3JtYXQpIHsKCQlpZiAocHJlZmVycmVkX2luZGV4X2Zvcm1hdCA8IElOREVYX0ZPUk1BVF9MQiB8fAoJCSAgICBJTkRFWF9GT1JNQVRfVUIgPCBwcmVmZXJyZWRfaW5kZXhfZm9ybWF0KQoJCQlkaWUoImluZGV4LXZlcnNpb24gJWQgbm90IGluIHJhbmdlOiAlZC4uJWQiLAoJCQkgICAgcHJlZmVycmVkX2luZGV4X2Zvcm1hdCwKCQkJICAgIElOREVYX0ZPUk1BVF9MQiwgSU5ERVhfRk9STUFUX1VCKTsKCgkJaWYgKHRoZV9pbmRleC52ZXJzaW9uICE9IHByZWZlcnJlZF9pbmRleF9mb3JtYXQpCgkJCWFjdGl2ZV9jYWNoZV9jaGFuZ2VkID0gMTsKCQl0aGVfaW5kZXgudmVyc2lvbiA9IHByZWZlcnJlZF9pbmRleF9mb3JtYXQ7Cgl9CgoJaWYgKHJlYWRfZnJvbV9zdGRpbikgewoJCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQsIG5idWYgPSBTVFJCVUZfSU5JVDsKCgkJc2V0dXBfd29ya190cmVlKCk7CgkJd2hpbGUgKHN0cmJ1Zl9nZXRsaW5lKCZidWYsIHN0ZGluLCBsaW5lX3Rlcm1pbmF0aW9uKSAhPSBFT0YpIHsKCQkJY29uc3QgY2hhciAqcDsKCQkJaWYgKGxpbmVfdGVybWluYXRpb24gJiYgYnVmLmJ1ZlswXSA9PSAnIicpIHsKCQkJCXN0cmJ1Zl9yZXNldCgmbmJ1Zik7CgkJCQlpZiAodW5xdW90ZV9jX3N0eWxlKCZuYnVmLCBidWYuYnVmLCBOVUxMKSkKCQkJCQlkaWUoImxpbmUgaXMgYmFkbHkgcXVvdGVkIik7CgkJCQlzdHJidWZfc3dhcCgmYnVmLCAmbmJ1Zik7CgkJCX0KCQkJcCA9IHByZWZpeF9wYXRoKHByZWZpeCwgcHJlZml4X2xlbmd0aCwgYnVmLmJ1Zik7CgkJCXVwZGF0ZV9vbmUocCk7CgkJCWlmIChzZXRfZXhlY3V0YWJsZV9iaXQpCgkJCQljaG1vZF9wYXRoKHNldF9leGVjdXRhYmxlX2JpdCwgcCk7CgkJCWZyZWUoKGNoYXIgKilwKTsKCQl9CgkJc3RyYnVmX3JlbGVhc2UoJm5idWYpOwoJCXN0cmJ1Zl9yZWxlYXNlKCZidWYpOwoJfQoKCWlmIChhY3RpdmVfY2FjaGVfY2hhbmdlZCkgewoJCWlmIChuZXdmZCA8IDApIHsKCQkJaWYgKHJlZnJlc2hfYXJncy5mbGFncyAmIFJFRlJFU0hfUVVJRVQpCgkJCQlleGl0KDEyOCk7CgkJCXVuYWJsZV90b19sb2NrX2luZGV4X2RpZShnZXRfaW5kZXhfZmlsZSgpLCBsb2NrX2Vycm9yKTsKCQl9CgkJaWYgKHdyaXRlX2NhY2hlKG5ld2ZkLCBhY3RpdmVfY2FjaGUsIGFjdGl2ZV9ucikgfHwKCQkgICAgY29tbWl0X2xvY2tlZF9pbmRleChsb2NrX2ZpbGUpKQoJCQlkaWUoIlVuYWJsZSB0byB3cml0ZSBuZXcgaW5kZXggZmlsZSIpOwoJfQoKCXJvbGxiYWNrX2xvY2tfZmlsZShsb2NrX2ZpbGUpOwoKCXJldHVybiBoYXNfZXJyb3JzID8gMSA6IDA7Cn0K",
    "text": "/*\n * GIT - The information manager from hell\n *\n * Copyright (C) Linus Torvalds, 2005\n */\n#include \"cache.h\"\n#include \"quote.h\"\n#include \"cache-tree.h\"\n#include \"tree-walk.h\"\n#include \"builtin.h\"\n#include \"refs.h\"\n#include \"resolve-undo.h\"\n#include \"parse-options.h\"\n#include \"pathspec.h\"\n\n/*\n * Default to not allowing changes to the list of files. The\n * tool doesn't actually care, but this makes it harder to add\n * files to the revision control by mistake by doing something\n * like \"git update-index *\" and suddenly having all the object\n * files be revision controlled.\n */\nstatic int allow_add;\nstatic int allow_remove;\nstatic int allow_replace;\nstatic int info_only;\nstatic int force_remove;\nstatic int verbose;\nstatic int mark_valid_only;\nstatic int mark_skip_worktree_only;\n#define MARK_FLAG 1\n#define UNMARK_FLAG 2\n\n__attribute__((format (printf, 1, 2)))\nstatic void report(const char *fmt, ...)\n{\n\tva_list vp;\n\n\tif (!verbose)\n\t\treturn;\n\n\tva_start(vp, fmt);\n\tvprintf(fmt, vp);\n\tputchar('\\n');\n\tva_end(vp);\n}\n\nstatic int mark_ce_flags(const char *path, int flag, int mark)\n{\n\tint namelen = strlen(path);\n\tint pos = cache_name_pos(path, namelen);\n\tif (0 <= pos) {\n\t\tif (mark)\n\t\t\tactive_cache[pos]->ce_flags |= flag;\n\t\telse\n\t\t\tactive_cache[pos]->ce_flags &= ~flag;\n\t\tcache_tree_invalidate_path(active_cache_tree, path);\n\t\tactive_cache_changed = 1;\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n\nstatic int remove_one_path(const char *path)\n{\n\tif (!allow_remove)\n\t\treturn error(\"%s: does not exist and --remove not passed\", path);\n\tif (remove_file_from_cache(path))\n\t\treturn error(\"%s: cannot remove from the index\", path);\n\treturn 0;\n}\n\n/*\n * Handle a path that couldn't be lstat'ed. It's either:\n *  - missing file (ENOENT or ENOTDIR). That's ok if we're\n *    supposed to be removing it and the removal actually\n *    succeeds.\n *  - permission error. That's never ok.\n */\nstatic int process_lstat_error(const char *path, int err)\n{\n\tif (err == ENOENT || err == ENOTDIR)\n\t\treturn remove_one_path(path);\n\treturn error(\"lstat(\\\"%s\\\"): %s\", path, strerror(errno));\n}\n\nstatic int add_one_path(const struct cache_entry *old, const char *path, int len, struct stat *st)\n{\n\tint option, size;\n\tstruct cache_entry *ce;\n\n\t/* Was the old index entry already up-to-date? */\n\tif (old && !ce_stage(old) && !ce_match_stat(old, st, 0))\n\t\treturn 0;\n\n\tsize = cache_entry_size(len);\n\tce = xcalloc(1, size);\n\tmemcpy(ce->name, path, len);\n\tce->ce_flags = create_ce_flags(0);\n\tce->ce_namelen = len;\n\tfill_stat_cache_info(ce, st);\n\tce->ce_mode = ce_mode_from_stat(old, st->st_mode);\n\n\tif (index_path(ce->sha1, path, st,\n\t\t       info_only ? 0 : HASH_WRITE_OBJECT)) {\n\t\tfree(ce);\n\t\treturn -1;\n\t}\n\toption = allow_add ? ADD_CACHE_OK_TO_ADD : 0;\n\toption |= allow_replace ? ADD_CACHE_OK_TO_REPLACE : 0;\n\tif (add_cache_entry(ce, option))\n\t\treturn error(\"%s: cannot add to the index - missing --add option?\", path);\n\treturn 0;\n}\n\n/*\n * Handle a path that was a directory. Four cases:\n *\n *  - it's already a gitlink in the index, and we keep it that\n *    way, and update it if we can (if we cannot find the HEAD,\n *    we're going to keep it unchanged in the index!)\n *\n *  - it's a *file* in the index, in which case it should be\n *    removed as a file if removal is allowed, since it doesn't\n *    exist as such any more. If removal isn't allowed, it's\n *    an error.\n *\n *    (NOTE! This is old and arguably fairly strange behaviour.\n *    We might want to make this an error unconditionally, and\n *    use \"--force-remove\" if you actually want to force removal).\n *\n *  - it used to exist as a subdirectory (ie multiple files with\n *    this particular prefix) in the index, in which case it's wrong\n *    to try to update it as a directory.\n *\n *  - it doesn't exist at all in the index, but it is a valid\n *    git directory, and it should be *added* as a gitlink.\n */\nstatic int process_directory(const char *path, int len, struct stat *st)\n{\n\tunsigned char sha1[20];\n\tint pos = cache_name_pos(path, len);\n\n\t/* Exact match: file or existing gitlink */\n\tif (pos >= 0) {\n\t\tconst struct cache_entry *ce = active_cache[pos];\n\t\tif (S_ISGITLINK(ce->ce_mode)) {\n\n\t\t\t/* Do nothing to the index if there is no HEAD! */\n\t\t\tif (resolve_gitlink_ref(path, \"HEAD\", sha1) < 0)\n\t\t\t\treturn 0;\n\n\t\t\treturn add_one_path(ce, path, len, st);\n\t\t}\n\t\t/* Should this be an unconditional error? */\n\t\treturn remove_one_path(path);\n\t}\n\n\t/* Inexact match: is there perhaps a subdirectory match? */\n\tpos = -pos-1;\n\twhile (pos < active_nr) {\n\t\tconst struct cache_entry *ce = active_cache[pos++];\n\n\t\tif (strncmp(ce->name, path, len))\n\t\t\tbreak;\n\t\tif (ce->name[len] > '/')\n\t\t\tbreak;\n\t\tif (ce->name[len] < '/')\n\t\t\tcontinue;\n\n\t\t/* Subdirectory match - error out */\n\t\treturn error(\"%s: is a directory - add individual files instead\", path);\n\t}\n\n\t/* No match - should we add it as a gitlink? */\n\tif (!resolve_gitlink_ref(path, \"HEAD\", sha1))\n\t\treturn add_one_path(NULL, path, len, st);\n\n\t/* Error out. */\n\treturn error(\"%s: is a directory - add files inside instead\", path);\n}\n\nstatic int process_path(const char *path)\n{\n\tint pos, len;\n\tstruct stat st;\n\tconst struct cache_entry *ce;\n\n\tlen = strlen(path);\n\tif (has_symlink_leading_path(path, len))\n\t\treturn error(\"'%s' is beyond a symbolic link\", path);\n\n\tpos = cache_name_pos(path, len);\n\tce = pos < 0 ? NULL : active_cache[pos];\n\tif (ce && ce_skip_worktree(ce)) {\n\t\t/*\n\t\t * working directory version is assumed \"good\"\n\t\t * so updating it does not make sense.\n\t\t * On the other hand, removing it from index should work\n\t\t */\n\t\tif (allow_remove && remove_file_from_cache(path))\n\t\t\treturn error(\"%s: cannot remove from the index\", path);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * First things first: get the stat information, to decide\n\t * what to do about the pathname!\n\t */\n\tif (lstat(path, &st) < 0)\n\t\treturn process_lstat_error(path, errno);\n\n\tif (S_ISDIR(st.st_mode))\n\t\treturn process_directory(path, len, &st);\n\n\treturn add_one_path(ce, path, len, &st);\n}\n\nstatic int add_cacheinfo(unsigned int mode, const unsigned char *sha1,\n\t\t\t const char *path, int stage)\n{\n\tint size, len, option;\n\tstruct cache_entry *ce;\n\n\tif (!verify_path(path))\n\t\treturn error(\"Invalid path '%s'\", path);\n\n\tlen = strlen(path);\n\tsize = cache_entry_size(len);\n\tce = xcalloc(1, size);\n\n\thashcpy(ce->sha1, sha1);\n\tmemcpy(ce->name, path, len);\n\tce->ce_flags = create_ce_flags(stage);\n\tce->ce_namelen = len;\n\tce->ce_mode = create_ce_mode(mode);\n\tif (assume_unchanged)\n\t\tce->ce_flags |= CE_VALID;\n\toption = allow_add ? ADD_CACHE_OK_TO_ADD : 0;\n\toption |= allow_replace ? ADD_CACHE_OK_TO_REPLACE : 0;\n\tif (add_cache_entry(ce, option))\n\t\treturn error(\"%s: cannot add to the index - missing --add option?\",\n\t\t\t     path);\n\treport(\"add '%s'\", path);\n\treturn 0;\n}\n\nstatic void chmod_path(int flip, const char *path)\n{\n\tint pos;\n\tstruct cache_entry *ce;\n\tunsigned int mode;\n\n\tpos = cache_name_pos(path, strlen(path));\n\tif (pos < 0)\n\t\tgoto fail;\n\tce = active_cache[pos];\n\tmode = ce->ce_mode;\n\tif (!S_ISREG(mode))\n\t\tgoto fail;\n\tswitch (flip) {\n\tcase '+':\n\t\tce->ce_mode |= 0111; break;\n\tcase '-':\n\t\tce->ce_mode &= ~0111; break;\n\tdefault:\n\t\tgoto fail;\n\t}\n\tcache_tree_invalidate_path(active_cache_tree, path);\n\tactive_cache_changed = 1;\n\treport(\"chmod %cx '%s'\", flip, path);\n\treturn;\n fail:\n\tdie(\"git update-index: cannot chmod %cx '%s'\", flip, path);\n}\n\nstatic void update_one(const char *path)\n{\n\tif (!verify_path(path)) {\n\t\tfprintf(stderr, \"Ignoring path %s\\n\", path);\n\t\treturn;\n\t}\n\tif (mark_valid_only) {\n\t\tif (mark_ce_flags(path, CE_VALID, mark_valid_only == MARK_FLAG))\n\t\t\tdie(\"Unable to mark file %s\", path);\n\t\treturn;\n\t}\n\tif (mark_skip_worktree_only) {\n\t\tif (mark_ce_flags(path, CE_SKIP_WORKTREE, mark_skip_worktree_only == MARK_FLAG))\n\t\t\tdie(\"Unable to mark file %s\", path);\n\t\treturn;\n\t}\n\n\tif (force_remove) {\n\t\tif (remove_file_from_cache(path))\n\t\t\tdie(\"git update-index: unable to remove %s\", path);\n\t\treport(\"remove '%s'\", path);\n\t\treturn;\n\t}\n\tif (process_path(path))\n\t\tdie(\"Unable to process path %s\", path);\n\treport(\"add '%s'\", path);\n}\n\nstatic void read_index_info(int line_termination)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tstruct strbuf uq = STRBUF_INIT;\n\n\twhile (strbuf_getline(&buf, stdin, line_termination) != EOF) {\n\t\tchar *ptr, *tab;\n\t\tchar *path_name;\n\t\tunsigned char sha1[20];\n\t\tunsigned int mode;\n\t\tunsigned long ul;\n\t\tint stage;\n\n\t\t/* This reads lines formatted in one of three formats:\n\t\t *\n\t\t * (1) mode         SP sha1          TAB path\n\t\t * The first format is what \"git apply --index-info\"\n\t\t * reports, and used to reconstruct a partial tree\n\t\t * that is used for phony merge base tree when falling\n\t\t * back on 3-way merge.\n\t\t *\n\t\t * (2) mode SP type SP sha1          TAB path\n\t\t * The second format is to stuff \"git ls-tree\" output\n\t\t * into the index file.\n\t\t *\n\t\t * (3) mode         SP sha1 SP stage TAB path\n\t\t * This format is to put higher order stages into the\n\t\t * index file and matches \"git ls-files --stage\" output.\n\t\t */\n\t\terrno = 0;\n\t\tul = strtoul(buf.buf, &ptr, 8);\n\t\tif (ptr == buf.buf || *ptr != ' '\n\t\t    || errno || (unsigned int) ul != ul)\n\t\t\tgoto bad_line;\n\t\tmode = ul;\n\n\t\ttab = strchr(ptr, '\\t');\n\t\tif (!tab || tab - ptr < 41)\n\t\t\tgoto bad_line;\n\n\t\tif (tab[-2] == ' ' && '0' <= tab[-1] && tab[-1] <= '3') {\n\t\t\tstage = tab[-1] - '0';\n\t\t\tptr = tab + 1; /* point at the head of path */\n\t\t\ttab = tab - 2; /* point at tail of sha1 */\n\t\t}\n\t\telse {\n\t\t\tstage = 0;\n\t\t\tptr = tab + 1; /* point at the head of path */\n\t\t}\n\n\t\tif (get_sha1_hex(tab - 40, sha1) || tab[-41] != ' ')\n\t\t\tgoto bad_line;\n\n\t\tpath_name = ptr;\n\t\tif (line_termination && path_name[0] == '\"') {\n\t\t\tstrbuf_reset(&uq);\n\t\t\tif (unquote_c_style(&uq, path_name, NULL)) {\n\t\t\t\tdie(\"git update-index: bad quoting of path name\");\n\t\t\t}\n\t\t\tpath_name = uq.buf;\n\t\t}\n\n\t\tif (!verify_path(path_name)) {\n\t\t\tfprintf(stderr, \"Ignoring path %s\\n\", path_name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!mode) {\n\t\t\t/* mode == 0 means there is no such path -- remove */\n\t\t\tif (remove_file_from_cache(path_name))\n\t\t\t\tdie(\"git update-index: unable to remove %s\",\n\t\t\t\t    ptr);\n\t\t}\n\t\telse {\n\t\t\t/* mode ' ' sha1 '\\t' name\n\t\t\t * ptr[-1] points at tab,\n\t\t\t * ptr[-41] is at the beginning of sha1\n\t\t\t */\n\t\t\tptr[-42] = ptr[-1] = 0;\n\t\t\tif (add_cacheinfo(mode, sha1, path_name, stage))\n\t\t\t\tdie(\"git update-index: unable to update %s\",\n\t\t\t\t    path_name);\n\t\t}\n\t\tcontinue;\n\n\tbad_line:\n\t\tdie(\"malformed index info %s\", buf.buf);\n\t}\n\tstrbuf_release(&buf);\n\tstrbuf_release(&uq);\n}\n\nstatic const char * const update_index_usage[] = {\n\tN_(\"git update-index [options] [--] [<file>...]\"),\n\tNULL\n};\n\nstatic unsigned char head_sha1[20];\nstatic unsigned char merge_head_sha1[20];\n\nstatic struct cache_entry *read_one_ent(const char *which,\n\t\t\t\t\tunsigned char *ent, const char *path,\n\t\t\t\t\tint namelen, int stage)\n{\n\tunsigned mode;\n\tunsigned char sha1[20];\n\tint size;\n\tstruct cache_entry *ce;\n\n\tif (get_tree_entry(ent, path, sha1, &mode)) {\n\t\tif (which)\n\t\t\terror(\"%s: not in %s branch.\", path, which);\n\t\treturn NULL;\n\t}\n\tif (mode == S_IFDIR) {\n\t\tif (which)\n\t\t\terror(\"%s: not a blob in %s branch.\", path, which);\n\t\treturn NULL;\n\t}\n\tsize = cache_entry_size(namelen);\n\tce = xcalloc(1, size);\n\n\thashcpy(ce->sha1, sha1);\n\tmemcpy(ce->name, path, namelen);\n\tce->ce_flags = create_ce_flags(stage);\n\tce->ce_namelen = namelen;\n\tce->ce_mode = create_ce_mode(mode);\n\treturn ce;\n}\n\nstatic int unresolve_one(const char *path)\n{\n\tint namelen = strlen(path);\n\tint pos;\n\tint ret = 0;\n\tstruct cache_entry *ce_2 = NULL, *ce_3 = NULL;\n\n\t/* See if there is such entry in the index. */\n\tpos = cache_name_pos(path, namelen);\n\tif (0 <= pos) {\n\t\t/* already merged */\n\t\tpos = unmerge_cache_entry_at(pos);\n\t\tif (pos < active_nr) {\n\t\t\tconst struct cache_entry *ce = active_cache[pos];\n\t\t\tif (ce_stage(ce) &&\n\t\t\t    ce_namelen(ce) == namelen &&\n\t\t\t    !memcmp(ce->name, path, namelen))\n\t\t\t\treturn 0;\n\t\t}\n\t\t/* no resolve-undo information; fall back */\n\t} else {\n\t\t/* If there isn't, either it is unmerged, or\n\t\t * resolved as \"removed\" by mistake.  We do not\n\t\t * want to do anything in the former case.\n\t\t */\n\t\tpos = -pos-1;\n\t\tif (pos < active_nr) {\n\t\t\tconst struct cache_entry *ce = active_cache[pos];\n\t\t\tif (ce_namelen(ce) == namelen &&\n\t\t\t    !memcmp(ce->name, path, namelen)) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"%s: skipping still unmerged path.\\n\",\n\t\t\t\t\tpath);\n\t\t\t\tgoto free_return;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Grab blobs from given path from HEAD and MERGE_HEAD,\n\t * stuff HEAD version in stage #2,\n\t * stuff MERGE_HEAD version in stage #3.\n\t */\n\tce_2 = read_one_ent(\"our\", head_sha1, path, namelen, 2);\n\tce_3 = read_one_ent(\"their\", merge_head_sha1, path, namelen, 3);\n\n\tif (!ce_2 || !ce_3) {\n\t\tret = -1;\n\t\tgoto free_return;\n\t}\n\tif (!hashcmp(ce_2->sha1, ce_3->sha1) &&\n\t    ce_2->ce_mode == ce_3->ce_mode) {\n\t\tfprintf(stderr, \"%s: identical in both, skipping.\\n\",\n\t\t\tpath);\n\t\tgoto free_return;\n\t}\n\n\tremove_file_from_cache(path);\n\tif (add_cache_entry(ce_2, ADD_CACHE_OK_TO_ADD)) {\n\t\terror(\"%s: cannot add our version to the index.\", path);\n\t\tret = -1;\n\t\tgoto free_return;\n\t}\n\tif (!add_cache_entry(ce_3, ADD_CACHE_OK_TO_ADD))\n\t\treturn 0;\n\terror(\"%s: cannot add their version to the index.\", path);\n\tret = -1;\n free_return:\n\tfree(ce_2);\n\tfree(ce_3);\n\treturn ret;\n}\n\nstatic void read_head_pointers(void)\n{\n\tif (read_ref(\"HEAD\", head_sha1))\n\t\tdie(\"No HEAD -- no initial commit yet?\");\n\tif (read_ref(\"MERGE_HEAD\", merge_head_sha1)) {\n\t\tfprintf(stderr, \"Not in the middle of a merge.\\n\");\n\t\texit(0);\n\t}\n}\n\nstatic int do_unresolve(int ac, const char **av,\n\t\t\tconst char *prefix, int prefix_length)\n{\n\tint i;\n\tint err = 0;\n\n\t/* Read HEAD and MERGE_HEAD; if MERGE_HEAD does not exist, we\n\t * are not doing a merge, so exit with success status.\n\t */\n\tread_head_pointers();\n\n\tfor (i = 1; i < ac; i++) {\n\t\tconst char *arg = av[i];\n\t\tconst char *p = prefix_path(prefix, prefix_length, arg);\n\t\terr |= unresolve_one(p);\n\t\tif (p < arg || p > arg + strlen(arg))\n\t\t\tfree((char *)p);\n\t}\n\treturn err;\n}\n\nstatic int do_reupdate(int ac, const char **av,\n\t\t       const char *prefix, int prefix_length)\n{\n\t/* Read HEAD and run update-index on paths that are\n\t * merged and already different between index and HEAD.\n\t */\n\tint pos;\n\tint has_head = 1;\n\tstruct pathspec pathspec;\n\n\tparse_pathspec(&pathspec, 0,\n\t\t       PATHSPEC_PREFER_CWD,\n\t\t       prefix, av + 1);\n\n\tif (read_ref(\"HEAD\", head_sha1))\n\t\t/* If there is no HEAD, that means it is an initial\n\t\t * commit.  Update everything in the index.\n\t\t */\n\t\thas_head = 0;\n redo:\n\tfor (pos = 0; pos < active_nr; pos++) {\n\t\tconst struct cache_entry *ce = active_cache[pos];\n\t\tstruct cache_entry *old = NULL;\n\t\tint save_nr;\n\t\tchar *path;\n\n\t\tif (ce_stage(ce) || !ce_path_match(ce, &pathspec))\n\t\t\tcontinue;\n\t\tif (has_head)\n\t\t\told = read_one_ent(NULL, head_sha1,\n\t\t\t\t\t   ce->name, ce_namelen(ce), 0);\n\t\tif (old && ce->ce_mode == old->ce_mode &&\n\t\t    !hashcmp(ce->sha1, old->sha1)) {\n\t\t\tfree(old);\n\t\t\tcontinue; /* unchanged */\n\t\t}\n\t\t/* Be careful.  The working tree may not have the\n\t\t * path anymore, in which case, under 'allow_remove',\n\t\t * or worse yet 'allow_replace', active_nr may decrease.\n\t\t */\n\t\tsave_nr = active_nr;\n\t\tpath = xstrdup(ce->name);\n\t\tupdate_one(path);\n\t\tfree(path);\n\t\tif (save_nr != active_nr)\n\t\t\tgoto redo;\n\t}\n\tfree_pathspec(&pathspec);\n\treturn 0;\n}\n\nstruct refresh_params {\n\tunsigned int flags;\n\tint *has_errors;\n};\n\nstatic int refresh(struct refresh_params *o, unsigned int flag)\n{\n\tsetup_work_tree();\n\tread_cache_preload(NULL);\n\t*o->has_errors |= refresh_cache(o->flags | flag);\n\treturn 0;\n}\n\nstatic int refresh_callback(const struct option *opt,\n\t\t\t\tconst char *arg, int unset)\n{\n\treturn refresh(opt->value, 0);\n}\n\nstatic int really_refresh_callback(const struct option *opt,\n\t\t\t\tconst char *arg, int unset)\n{\n\treturn refresh(opt->value, REFRESH_REALLY);\n}\n\nstatic int chmod_callback(const struct option *opt,\n\t\t\t\tconst char *arg, int unset)\n{\n\tchar *flip = opt->value;\n\tif ((arg[0] != '-' && arg[0] != '+') || arg[1] != 'x' || arg[2])\n\t\treturn error(\"option 'chmod' expects \\\"+x\\\" or \\\"-x\\\"\");\n\t*flip = arg[0];\n\treturn 0;\n}\n\nstatic int resolve_undo_clear_callback(const struct option *opt,\n\t\t\t\tconst char *arg, int unset)\n{\n\tresolve_undo_clear();\n\treturn 0;\n}\n\nstatic int cacheinfo_callback(struct parse_opt_ctx_t *ctx,\n\t\t\t\tconst struct option *opt, int unset)\n{\n\tunsigned char sha1[20];\n\tunsigned int mode;\n\n\tif (ctx->argc <= 3)\n\t\treturn error(\"option 'cacheinfo' expects three arguments\");\n\tif (strtoul_ui(*++ctx->argv, 8, &mode) ||\n\t    get_sha1_hex(*++ctx->argv, sha1) ||\n\t    add_cacheinfo(mode, sha1, *++ctx->argv, 0))\n\t\tdie(\"git update-index: --cacheinfo cannot add %s\", *ctx->argv);\n\tctx->argc -= 3;\n\treturn 0;\n}\n\nstatic int stdin_cacheinfo_callback(struct parse_opt_ctx_t *ctx,\n\t\t\t      const struct option *opt, int unset)\n{\n\tint *line_termination = opt->value;\n\n\tif (ctx->argc != 1)\n\t\treturn error(\"option '%s' must be the last argument\", opt->long_name);\n\tallow_add = allow_replace = allow_remove = 1;\n\tread_index_info(*line_termination);\n\treturn 0;\n}\n\nstatic int stdin_callback(struct parse_opt_ctx_t *ctx,\n\t\t\t\tconst struct option *opt, int unset)\n{\n\tint *read_from_stdin = opt->value;\n\n\tif (ctx->argc != 1)\n\t\treturn error(\"option '%s' must be the last argument\", opt->long_name);\n\t*read_from_stdin = 1;\n\treturn 0;\n}\n\nstatic int unresolve_callback(struct parse_opt_ctx_t *ctx,\n\t\t\t\tconst struct option *opt, int flags)\n{\n\tint *has_errors = opt->value;\n\tconst char *prefix = startup_info->prefix;\n\n\t/* consume remaining arguments. */\n\t*has_errors = do_unresolve(ctx->argc, ctx->argv,\n\t\t\t\tprefix, prefix ? strlen(prefix) : 0);\n\tif (*has_errors)\n\t\tactive_cache_changed = 0;\n\n\tctx->argv += ctx->argc - 1;\n\tctx->argc = 1;\n\treturn 0;\n}\n\nstatic int reupdate_callback(struct parse_opt_ctx_t *ctx,\n\t\t\t\tconst struct option *opt, int flags)\n{\n\tint *has_errors = opt->value;\n\tconst char *prefix = startup_info->prefix;\n\n\t/* consume remaining arguments. */\n\tsetup_work_tree();\n\t*has_errors = do_reupdate(ctx->argc, ctx->argv,\n\t\t\t\tprefix, prefix ? strlen(prefix) : 0);\n\tif (*has_errors)\n\t\tactive_cache_changed = 0;\n\n\tctx->argv += ctx->argc - 1;\n\tctx->argc = 1;\n\treturn 0;\n}\n\nint cmd_update_index(int argc, const char **argv, const char *prefix)\n{\n\tint newfd, entries, has_errors = 0, line_termination = '\\n';\n\tint read_from_stdin = 0;\n\tint prefix_length = prefix ? strlen(prefix) : 0;\n\tint preferred_index_format = 0;\n\tchar set_executable_bit = 0;\n\tstruct refresh_params refresh_args = {0, &has_errors};\n\tint lock_error = 0;\n\tstruct lock_file *lock_file;\n\tstruct parse_opt_ctx_t ctx;\n\tint parseopt_state = PARSE_OPT_UNKNOWN;\n\tstruct option options[] = {\n\t\tOPT_BIT('q', NULL, &refresh_args.flags,\n\t\t\tN_(\"continue refresh even when index needs update\"),\n\t\t\tREFRESH_QUIET),\n\t\tOPT_BIT(0, \"ignore-submodules\", &refresh_args.flags,\n\t\t\tN_(\"refresh: ignore submodules\"),\n\t\t\tREFRESH_IGNORE_SUBMODULES),\n\t\tOPT_SET_INT(0, \"add\", &allow_add,\n\t\t\tN_(\"do not ignore new files\"), 1),\n\t\tOPT_SET_INT(0, \"replace\", &allow_replace,\n\t\t\tN_(\"let files replace directories and vice-versa\"), 1),\n\t\tOPT_SET_INT(0, \"remove\", &allow_remove,\n\t\t\tN_(\"notice files missing from worktree\"), 1),\n\t\tOPT_BIT(0, \"unmerged\", &refresh_args.flags,\n\t\t\tN_(\"refresh even if index contains unmerged entries\"),\n\t\t\tREFRESH_UNMERGED),\n\t\t{OPTION_CALLBACK, 0, \"refresh\", &refresh_args, NULL,\n\t\t\tN_(\"refresh stat information\"),\n\t\t\tPARSE_OPT_NOARG | PARSE_OPT_NONEG,\n\t\t\trefresh_callback},\n\t\t{OPTION_CALLBACK, 0, \"really-refresh\", &refresh_args, NULL,\n\t\t\tN_(\"like --refresh, but ignore assume-unchanged setting\"),\n\t\t\tPARSE_OPT_NOARG | PARSE_OPT_NONEG,\n\t\t\treally_refresh_callback},\n\t\t{OPTION_LOWLEVEL_CALLBACK, 0, \"cacheinfo\", NULL,\n\t\t\tN_(\"<mode> <object> <path>\"),\n\t\t\tN_(\"add the specified entry to the index\"),\n\t\t\tPARSE_OPT_NOARG |\t/* disallow --cacheinfo=<mode> form */\n\t\t\tPARSE_OPT_NONEG | PARSE_OPT_LITERAL_ARGHELP,\n\t\t\t(parse_opt_cb *) cacheinfo_callback},\n\t\t{OPTION_CALLBACK, 0, \"chmod\", &set_executable_bit, N_(\"(+/-)x\"),\n\t\t\tN_(\"override the executable bit of the listed files\"),\n\t\t\tPARSE_OPT_NONEG | PARSE_OPT_LITERAL_ARGHELP,\n\t\t\tchmod_callback},\n\t\t{OPTION_SET_INT, 0, \"assume-unchanged\", &mark_valid_only, NULL,\n\t\t\tN_(\"mark files as \\\"not changing\\\"\"),\n\t\t\tPARSE_OPT_NOARG | PARSE_OPT_NONEG, NULL, MARK_FLAG},\n\t\t{OPTION_SET_INT, 0, \"no-assume-unchanged\", &mark_valid_only, NULL,\n\t\t\tN_(\"clear assumed-unchanged bit\"),\n\t\t\tPARSE_OPT_NOARG | PARSE_OPT_NONEG, NULL, UNMARK_FLAG},\n\t\t{OPTION_SET_INT, 0, \"skip-worktree\", &mark_skip_worktree_only, NULL,\n\t\t\tN_(\"mark files as \\\"index-only\\\"\"),\n\t\t\tPARSE_OPT_NOARG | PARSE_OPT_NONEG, NULL, MARK_FLAG},\n\t\t{OPTION_SET_INT, 0, \"no-skip-worktree\", &mark_skip_worktree_only, NULL,\n\t\t\tN_(\"clear skip-worktree bit\"),\n\t\t\tPARSE_OPT_NOARG | PARSE_OPT_NONEG, NULL, UNMARK_FLAG},\n\t\tOPT_SET_INT(0, \"info-only\", &info_only,\n\t\t\tN_(\"add to index only; do not add content to object database\"), 1),\n\t\tOPT_SET_INT(0, \"force-remove\", &force_remove,\n\t\t\tN_(\"remove named paths even if present in worktree\"), 1),\n\t\tOPT_SET_INT('z', NULL, &line_termination,\n\t\t\tN_(\"with --stdin: input lines are terminated by null bytes\"), '\\0'),\n\t\t{OPTION_LOWLEVEL_CALLBACK, 0, \"stdin\", &read_from_stdin, NULL,\n\t\t\tN_(\"read list of paths to be updated from standard input\"),\n\t\t\tPARSE_OPT_NONEG | PARSE_OPT_NOARG,\n\t\t\t(parse_opt_cb *) stdin_callback},\n\t\t{OPTION_LOWLEVEL_CALLBACK, 0, \"index-info\", &line_termination, NULL,\n\t\t\tN_(\"add entries from standard input to the index\"),\n\t\t\tPARSE_OPT_NONEG | PARSE_OPT_NOARG,\n\t\t\t(parse_opt_cb *) stdin_cacheinfo_callback},\n\t\t{OPTION_LOWLEVEL_CALLBACK, 0, \"unresolve\", &has_errors, NULL,\n\t\t\tN_(\"repopulate stages #2 and #3 for the listed paths\"),\n\t\t\tPARSE_OPT_NONEG | PARSE_OPT_NOARG,\n\t\t\t(parse_opt_cb *) unresolve_callback},\n\t\t{OPTION_LOWLEVEL_CALLBACK, 'g', \"again\", &has_errors, NULL,\n\t\t\tN_(\"only update entries that differ from HEAD\"),\n\t\t\tPARSE_OPT_NONEG | PARSE_OPT_NOARG,\n\t\t\t(parse_opt_cb *) reupdate_callback},\n\t\tOPT_BIT(0, \"ignore-missing\", &refresh_args.flags,\n\t\t\tN_(\"ignore files missing from worktree\"),\n\t\t\tREFRESH_IGNORE_MISSING),\n\t\tOPT_SET_INT(0, \"verbose\", &verbose,\n\t\t\tN_(\"report actions to standard output\"), 1),\n\t\t{OPTION_CALLBACK, 0, \"clear-resolve-undo\", NULL, NULL,\n\t\t\tN_(\"(for porcelains) forget saved unresolved conflicts\"),\n\t\t\tPARSE_OPT_NOARG | PARSE_OPT_NONEG,\n\t\t\tresolve_undo_clear_callback},\n\t\tOPT_INTEGER(0, \"index-version\", &preferred_index_format,\n\t\t\tN_(\"write index in this format\")),\n\t\tOPT_END()\n\t};\n\n\tif (argc == 2 && !strcmp(argv[1], \"-h\"))\n\t\tusage_with_options(update_index_usage, options);\n\n\tgit_config(git_default_config, NULL);\n\n\t/* We can't free this memory, it becomes part of a linked list parsed atexit() */\n\tlock_file = xcalloc(1, sizeof(struct lock_file));\n\n\tnewfd = hold_locked_index(lock_file, 0);\n\tif (newfd < 0)\n\t\tlock_error = errno;\n\n\tentries = read_cache();\n\tif (entries < 0)\n\t\tdie(\"cache corrupted\");\n\n\t/*\n\t * Custom copy of parse_options() because we want to handle\n\t * filename arguments as they come.\n\t */\n\tparse_options_start(&ctx, argc, argv, prefix,\n\t\t\t    options, PARSE_OPT_STOP_AT_NON_OPTION);\n\twhile (ctx.argc) {\n\t\tif (parseopt_state != PARSE_OPT_DONE)\n\t\t\tparseopt_state = parse_options_step(&ctx, options,\n\t\t\t\t\t\t\t    update_index_usage);\n\t\tif (!ctx.argc)\n\t\t\tbreak;\n\t\tswitch (parseopt_state) {\n\t\tcase PARSE_OPT_HELP:\n\t\t\texit(129);\n\t\tcase PARSE_OPT_NON_OPTION:\n\t\tcase PARSE_OPT_DONE:\n\t\t{\n\t\t\tconst char *path = ctx.argv[0];\n\t\t\tconst char *p;\n\n\t\t\tsetup_work_tree();\n\t\t\tp = prefix_path(prefix, prefix_length, path);\n\t\t\tupdate_one(p);\n\t\t\tif (set_executable_bit)\n\t\t\t\tchmod_path(set_executable_bit, p);\n\t\t\tfree((char *)p);\n\t\t\tctx.argc--;\n\t\t\tctx.argv++;\n\t\t\tbreak;\n\t\t}\n\t\tcase PARSE_OPT_UNKNOWN:\n\t\t\tif (ctx.argv[0][1] == '-')\n\t\t\t\terror(\"unknown option '%s'\", ctx.argv[0] + 2);\n\t\t\telse\n\t\t\t\terror(\"unknown switch '%c'\", *ctx.opt);\n\t\t\tusage_with_options(update_index_usage, options);\n\t\t}\n\t}\n\targc = parse_options_end(&ctx);\n\tif (preferred_index_format) {\n\t\tif (preferred_index_format < INDEX_FORMAT_LB ||\n\t\t    INDEX_FORMAT_UB < preferred_index_format)\n\t\t\tdie(\"index-version %d not in range: %d..%d\",\n\t\t\t    preferred_index_format,\n\t\t\t    INDEX_FORMAT_LB, INDEX_FORMAT_UB);\n\n\t\tif (the_index.version != preferred_index_format)\n\t\t\tactive_cache_changed = 1;\n\t\tthe_index.version = preferred_index_format;\n\t}\n\n\tif (read_from_stdin) {\n\t\tstruct strbuf buf = STRBUF_INIT, nbuf = STRBUF_INIT;\n\n\t\tsetup_work_tree();\n\t\twhile (strbuf_getline(&buf, stdin, line_termination) != EOF) {\n\t\t\tconst char *p;\n\t\t\tif (line_termination && buf.buf[0] == '\"') {\n\t\t\t\tstrbuf_reset(&nbuf);\n\t\t\t\tif (unquote_c_style(&nbuf, buf.buf, NULL))\n\t\t\t\t\tdie(\"line is badly quoted\");\n\t\t\t\tstrbuf_swap(&buf, &nbuf);\n\t\t\t}\n\t\t\tp = prefix_path(prefix, prefix_length, buf.buf);\n\t\t\tupdate_one(p);\n\t\t\tif (set_executable_bit)\n\t\t\t\tchmod_path(set_executable_bit, p);\n\t\t\tfree((char *)p);\n\t\t}\n\t\tstrbuf_release(&nbuf);\n\t\tstrbuf_release(&buf);\n\t}\n\n\tif (active_cache_changed) {\n\t\tif (newfd < 0) {\n\t\t\tif (refresh_args.flags & REFRESH_QUIET)\n\t\t\t\texit(128);\n\t\t\tunable_to_lock_index_die(get_index_file(), lock_error);\n\t\t}\n\t\tif (write_cache(newfd, active_cache, active_nr) ||\n\t\t    commit_locked_index(lock_file))\n\t\t\tdie(\"Unable to write new index file\");\n\t}\n\n\trollback_lock_file(lock_file);\n\n\treturn has_errors ? 1 : 0;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00313f373aadd989e0627b0b3068676c66c17a9b",
  "sha1_ok": true,
  "size": 24978
}
