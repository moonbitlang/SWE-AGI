{
  "content": {
    "base64": "I2lmbmRlZiBQQUNLRklMRV9ICiNkZWZpbmUgUEFDS0ZJTEVfSAoKI2luY2x1ZGUgIm9iamVjdC5oIgojaW5jbHVkZSAib2lkc2V0LmgiCgovKiBpbiBvYmplY3Qtc3RvcmUuaCAqLwpzdHJ1Y3QgcGFja2VkX2dpdDsKc3RydWN0IG9iamVjdF9pbmZvOwoKc3RydWN0IHBhY2tfd2luZG93IHsKCXN0cnVjdCBwYWNrX3dpbmRvdyAqbmV4dDsKCXVuc2lnbmVkIGNoYXIgKmJhc2U7CglvZmZfdCBvZmZzZXQ7CglzaXplX3QgbGVuOwoJdW5zaWduZWQgaW50IGxhc3RfdXNlZDsKCXVuc2lnbmVkIGludCBpbnVzZV9jbnQ7Cn07CgpzdHJ1Y3QgcGFja19lbnRyeSB7CglvZmZfdCBvZmZzZXQ7CglzdHJ1Y3QgcGFja2VkX2dpdCAqcDsKfTsKCi8qCiAqIEdlbmVyYXRlIHRoZSBmaWxlbmFtZSB0byBiZSB1c2VkIGZvciBhIHBhY2sgZmlsZSB3aXRoIGNoZWNrc3VtICJzaGExIiBhbmQKICogZXh0ZW5zaW9uICJleHQiLiBUaGUgcmVzdWx0IGlzIHdyaXR0ZW4gaW50byB0aGUgc3RyYnVmICJidWYiLCBvdmVyd3JpdGluZwogKiBhbnkgZXhpc3RpbmcgY29udGVudHMuIEEgcG9pbnRlciB0byBidWYtPmJ1ZiBpcyByZXR1cm5lZCBhcyBhIGNvbnZlbmllbmNlLgogKgogKiBFeGFtcGxlOiBvZGJfcGFja19uYW1lKG91dCwgc2hhMSwgImlkeCIpID0+ICIuZ2l0L29iamVjdHMvcGFjay9wYWNrLTEyMzQuLmlkeCIKICovCmNoYXIgKm9kYl9wYWNrX25hbWUoc3RydWN0IHJlcG9zaXRvcnkgKnIsIHN0cnVjdCBzdHJidWYgKmJ1ZiwKCQkgICAgY29uc3QgdW5zaWduZWQgY2hhciAqaGFzaCwgY29uc3QgY2hhciAqZXh0KTsKCi8qCiAqIFJldHVybiB0aGUgYmFzZW5hbWUgb2YgdGhlIHBhY2tmaWxlLCBvbWl0dGluZyBhbnkgY29udGFpbmluZyBkaXJlY3RvcnkKICogKGUuZy4sICJwYWNrLTEyMzRhYmNkWy4uLl0ucGFjayIpLgogKi8KY29uc3QgY2hhciAqcGFja19iYXNlbmFtZShzdHJ1Y3QgcGFja2VkX2dpdCAqcCk7CgovKgogKiBQYXJzZSB0aGUgcGFjayBpZHggZmlsZSBmb3VuZCBhdCBpZHhfcGF0aCBhbmQgY3JlYXRlIGEgcGFja2VkX2dpdCBzdHJ1Y3QKICogd2hpY2ggY2FuIGJlIHVzZWQgd2l0aCBmaW5kX3BhY2tfZW50cnlfb25lKCkuCiAqCiAqIFlvdSBwcm9iYWJseSBkb24ndCB3YW50IHRvIHVzZSB0aGlzIGZ1bmN0aW9uISBJdCBza2lwcyBtb3N0IG9mIHRoZSBub3JtYWwKICogc2FuaXR5IGNoZWNrcyAoaW5jbHVkaW5nIHdoZXRoZXIgd2UgZXZlbiBoYXZlIHRoZSBtYXRjaGluZyAucGFjayBmaWxlKSwKICogYW5kIGRvZXMgbm90IGFkZCB0aGUgcmVzdWx0aW5nIHBhY2tlZF9naXQgc3RydWN0IHRvIHRoZSBpbnRlcm5hbCBsaXN0IG9mCiAqIHBhY2tzLiBZb3UgcHJvYmFibHkgd2FudCBhZGRfcGFja2VkX2dpdCgpIGluc3RlYWQuCiAqLwpzdHJ1Y3QgcGFja2VkX2dpdCAqcGFyc2VfcGFja19pbmRleChzdHJ1Y3QgcmVwb3NpdG9yeSAqciwgdW5zaWduZWQgY2hhciAqc2hhMSwKCQkJCSAgICBjb25zdCBjaGFyICppZHhfcGF0aCk7Cgp0eXBlZGVmIHZvaWQgZWFjaF9maWxlX2luX3BhY2tfZGlyX2ZuKGNvbnN0IGNoYXIgKmZ1bGxfcGF0aCwgc2l6ZV90IGZ1bGxfcGF0aF9sZW4sCgkJCQkgICAgICBjb25zdCBjaGFyICpmaWxlX25hbWUsIHZvaWQgKmRhdGEpOwp2b2lkIGZvcl9lYWNoX2ZpbGVfaW5fcGFja19zdWJkaXIoY29uc3QgY2hhciAqb2JqZGlyLAoJCQkJICBjb25zdCBjaGFyICpzdWJkaXIsCgkJCQkgIGVhY2hfZmlsZV9pbl9wYWNrX2Rpcl9mbiBmbiwKCQkJCSAgdm9pZCAqZGF0YSk7CnZvaWQgZm9yX2VhY2hfZmlsZV9pbl9wYWNrX2Rpcihjb25zdCBjaGFyICpvYmpkaXIsCgkJCSAgICAgICBlYWNoX2ZpbGVfaW5fcGFja19kaXJfZm4gZm4sCgkJCSAgICAgICB2b2lkICpkYXRhKTsKCi8qIEEgaG9vayB0byByZXBvcnQgaW52YWxpZCBmaWxlcyBpbiBwYWNrIGRpcmVjdG9yeSAqLwojZGVmaW5lIFBBQ0tESVJfRklMRV9QQUNLIDEKI2RlZmluZSBQQUNLRElSX0ZJTEVfSURYIDIKI2RlZmluZSBQQUNLRElSX0ZJTEVfR0FSQkFHRSA0CmV4dGVybiB2b2lkICgqcmVwb3J0X2dhcmJhZ2UpKHVuc2lnbmVkIHNlZW5fYml0cywgY29uc3QgY2hhciAqcGF0aCk7Cgp2b2lkIHJlcHJlcGFyZV9wYWNrZWRfZ2l0KHN0cnVjdCByZXBvc2l0b3J5ICpyKTsKdm9pZCBpbnN0YWxsX3BhY2tlZF9naXQoc3RydWN0IHJlcG9zaXRvcnkgKnIsIHN0cnVjdCBwYWNrZWRfZ2l0ICpwYWNrKTsKCnN0cnVjdCBwYWNrZWRfZ2l0ICpnZXRfcGFja2VkX2dpdChzdHJ1Y3QgcmVwb3NpdG9yeSAqcik7CnN0cnVjdCBsaXN0X2hlYWQgKmdldF9wYWNrZWRfZ2l0X21ydShzdHJ1Y3QgcmVwb3NpdG9yeSAqcik7CnN0cnVjdCBtdWx0aV9wYWNrX2luZGV4ICpnZXRfbXVsdGlfcGFja19pbmRleChzdHJ1Y3QgcmVwb3NpdG9yeSAqcik7CnN0cnVjdCBtdWx0aV9wYWNrX2luZGV4ICpnZXRfbG9jYWxfbXVsdGlfcGFja19pbmRleChzdHJ1Y3QgcmVwb3NpdG9yeSAqcik7CnN0cnVjdCBwYWNrZWRfZ2l0ICpnZXRfYWxsX3BhY2tzKHN0cnVjdCByZXBvc2l0b3J5ICpyKTsKCi8qCiAqIEdpdmUgYSByb3VnaCBjb3VudCBvZiBvYmplY3RzIGluIHRoZSByZXBvc2l0b3J5LiBUaGlzIHNhY3JpZmljZXMgYWNjdXJhY3kKICogZm9yIHNwZWVkLgogKi8KdW5zaWduZWQgbG9uZyByZXBvX2FwcHJveGltYXRlX29iamVjdF9jb3VudChzdHJ1Y3QgcmVwb3NpdG9yeSAqcik7CgovKgogKiBGaW5kIHRoZSBwYWNrIHdpdGhpbiB0aGUgInBhY2tzIiBsaXN0IHdob3NlIGluZGV4IGNvbnRhaW5zIHRoZSBvYmplY3QgIm9pZCIuCiAqIEZvciBnZW5lcmFsIG9iamVjdCBsb29rdXBzLCB5b3UgcHJvYmFibHkgZG9uJ3Qgd2FudCB0aGlzOyB1c2UKICogZmluZF9wYWNrX2VudHJ5KCkgaW5zdGVhZC4KICovCnN0cnVjdCBwYWNrZWRfZ2l0ICpmaW5kX29pZF9wYWNrKGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwKCQkJCSBzdHJ1Y3QgcGFja2VkX2dpdCAqcGFja3MpOwoKdm9pZCBwYWNrX3JlcG9ydChzdHJ1Y3QgcmVwb3NpdG9yeSAqcmVwbyk7CgovKgogKiBtbWFwIHRoZSBpbmRleCBmaWxlIGZvciB0aGUgc3BlY2lmaWVkIHBhY2tmaWxlIChpZiBpdCBpcyBub3QKICogYWxyZWFkeSBtbWFwcGVkKS4gIFJldHVybiAwIG9uIHN1Y2Nlc3MuCiAqLwppbnQgb3Blbl9wYWNrX2luZGV4KHN0cnVjdCBwYWNrZWRfZ2l0ICopOwoKLyoKICogbXVubWFwIHRoZSBpbmRleCBmaWxlIGZvciB0aGUgc3BlY2lmaWVkIHBhY2tmaWxlIChpZiBpdCBpcwogKiBjdXJyZW50bHkgbW1hcHBlZCkuCiAqLwp2b2lkIGNsb3NlX3BhY2tfaW5kZXgoc3RydWN0IHBhY2tlZF9naXQgKik7CgppbnQgY2xvc2VfcGFja19mZChzdHJ1Y3QgcGFja2VkX2dpdCAqcCk7Cgp1aW50MzJfdCBnZXRfcGFja19mYW5vdXQoc3RydWN0IHBhY2tlZF9naXQgKnAsIHVpbnQzMl90IHZhbHVlKTsKCnN0cnVjdCByYXdfb2JqZWN0X3N0b3JlOwoKdW5zaWduZWQgY2hhciAqdXNlX3BhY2soc3RydWN0IHBhY2tlZF9naXQgKiwgc3RydWN0IHBhY2tfd2luZG93ICoqLCBvZmZfdCwgdW5zaWduZWQgbG9uZyAqKTsKdm9pZCBjbG9zZV9wYWNrX3dpbmRvd3Moc3RydWN0IHBhY2tlZF9naXQgKik7CnZvaWQgY2xvc2VfcGFjayhzdHJ1Y3QgcGFja2VkX2dpdCAqKTsKdm9pZCBjbG9zZV9vYmplY3Rfc3RvcmUoc3RydWN0IHJhd19vYmplY3Rfc3RvcmUgKm8pOwp2b2lkIHVudXNlX3BhY2soc3RydWN0IHBhY2tfd2luZG93ICoqKTsKdm9pZCBjbGVhcl9kZWx0YV9iYXNlX2NhY2hlKHZvaWQpOwpzdHJ1Y3QgcGFja2VkX2dpdCAqYWRkX3BhY2tlZF9naXQoc3RydWN0IHJlcG9zaXRvcnkgKnIsIGNvbnN0IGNoYXIgKnBhdGgsCgkJCQkgIHNpemVfdCBwYXRoX2xlbiwgaW50IGxvY2FsKTsKCi8qCiAqIFVubGluayB0aGUgLnBhY2sgYW5kIGFzc29jaWF0ZWQgZXh0ZW5zaW9uIGZpbGVzLgogKiBEb2VzIG5vdCB1bmxpbmsgaWYgJ2ZvcmNlX2RlbGV0ZScgaXMgZmFsc2UgYW5kIHRoZSBwYWNrLWZpbGUgaXMKICogbWFya2VkIGFzICIua2VlcCIuCiAqLwp2b2lkIHVubGlua19wYWNrX3BhdGgoY29uc3QgY2hhciAqcGFja19uYW1lLCBpbnQgZm9yY2VfZGVsZXRlKTsKCi8qCiAqIE1ha2Ugc3VyZSB0aGF0IGEgcG9pbnRlciBhY2Nlc3MgaW50byBhbiBtbWFwJ2QgaW5kZXggZmlsZSBpcyB3aXRoaW4gYm91bmRzLAogKiBhbmQgY2FuIHByb3ZpZGUgYXQgbGVhc3QgOCBieXRlcyBvZiBkYXRhLgogKgogKiBOb3RlIHRoYXQgdGhpcyBpcyBvbmx5IG5lY2Vzc2FyeSBmb3IgdmFyaWFibGUtbGVuZ3RoIHNlZ21lbnRzIG9mIHRoZSBmaWxlCiAqIChsaWtlIHRoZSA2NC1iaXQgZXh0ZW5kZWQgb2Zmc2V0IHRhYmxlKSwgYXMgd2UgY29tcGFyZSB0aGUgc2l6ZSB0byB0aGUKICogZml4ZWQtbGVuZ3RoIHBhcnRzIHdoZW4gd2Ugb3BlbiB0aGUgZmlsZS4KICovCnZvaWQgY2hlY2tfcGFja19pbmRleF9wdHIoY29uc3Qgc3RydWN0IHBhY2tlZF9naXQgKnAsIGNvbnN0IHZvaWQgKnB0cik7CgovKgogKiBQZXJmb3JtIGJpbmFyeSBzZWFyY2ggb24gYSBwYWNrLWluZGV4IGZvciBhIGdpdmVuIG9pZC4gUGFja2ZpbGUgaXMgZXhwZWN0ZWQgdG8KICogaGF2ZSBhIHZhbGlkIHBhY2staW5kZXguCiAqCiAqIFNlZSAnYnNlYXJjaF9oYXNoJyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4KICovCmludCBic2VhcmNoX3BhY2soY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLCBjb25zdCBzdHJ1Y3QgcGFja2VkX2dpdCAqcCwgdWludDMyX3QgKnJlc3VsdCk7CgovKgogKiBXcml0ZSB0aGUgb2lkIG9mIHRoZSBudGggb2JqZWN0IHdpdGhpbiB0aGUgc3BlY2lmaWVkIHBhY2tmaWxlIGludG8gdGhlIGZpcnN0CiAqIHBhcmFtZXRlci4gT3BlbiB0aGUgaW5kZXggaWYgaXQgaXMgbm90IGFscmVhZHkgb3Blbi4gIFJldHVybnMgMCBvbiBzdWNjZXNzLAogKiBuZWdhdGl2ZSBvdGhlcndpc2UuCiAqLwppbnQgbnRoX3BhY2tlZF9vYmplY3RfaWQoc3RydWN0IG9iamVjdF9pZCAqLCBzdHJ1Y3QgcGFja2VkX2dpdCAqLCB1aW50MzJfdCBuKTsKCi8qCiAqIFJldHVybiB0aGUgb2Zmc2V0IG9mIHRoZSBudGggb2JqZWN0IHdpdGhpbiB0aGUgc3BlY2lmaWVkIHBhY2tmaWxlLgogKiBUaGUgaW5kZXggbXVzdCBhbHJlYWR5IGJlIG9wZW5lZC4KICovCm9mZl90IG50aF9wYWNrZWRfb2JqZWN0X29mZnNldChjb25zdCBzdHJ1Y3QgcGFja2VkX2dpdCAqLCB1aW50MzJfdCBuKTsKCi8qCiAqIElmIHRoZSBvYmplY3QgbmFtZWQgYnkgb2lkIGlzIHByZXNlbnQgaW4gdGhlIHNwZWNpZmllZCBwYWNrZmlsZSwKICogcmV0dXJuIGl0cyBvZmZzZXQgd2l0aGluIHRoZSBwYWNrZmlsZTsgb3RoZXJ3aXNlLCByZXR1cm4gMC4KICovCm9mZl90IGZpbmRfcGFja19lbnRyeV9vbmUoY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLCBzdHJ1Y3QgcGFja2VkX2dpdCAqKTsKCmludCBpc19wYWNrX3ZhbGlkKHN0cnVjdCBwYWNrZWRfZ2l0ICopOwp2b2lkICp1bnBhY2tfZW50cnkoc3RydWN0IHJlcG9zaXRvcnkgKnIsIHN0cnVjdCBwYWNrZWRfZ2l0ICosIG9mZl90LCBlbnVtIG9iamVjdF90eXBlICosIHVuc2lnbmVkIGxvbmcgKik7CnVuc2lnbmVkIGxvbmcgdW5wYWNrX29iamVjdF9oZWFkZXJfYnVmZmVyKGNvbnN0IHVuc2lnbmVkIGNoYXIgKmJ1ZiwgdW5zaWduZWQgbG9uZyBsZW4sIGVudW0gb2JqZWN0X3R5cGUgKnR5cGUsIHVuc2lnbmVkIGxvbmcgKnNpemVwKTsKdW5zaWduZWQgbG9uZyBnZXRfc2l6ZV9mcm9tX2RlbHRhKHN0cnVjdCBwYWNrZWRfZ2l0ICosIHN0cnVjdCBwYWNrX3dpbmRvdyAqKiwgb2ZmX3QpOwppbnQgdW5wYWNrX29iamVjdF9oZWFkZXIoc3RydWN0IHBhY2tlZF9naXQgKiwgc3RydWN0IHBhY2tfd2luZG93ICoqLCBvZmZfdCAqLCB1bnNpZ25lZCBsb25nICopOwpvZmZfdCBnZXRfZGVsdGFfYmFzZShzdHJ1Y3QgcGFja2VkX2dpdCAqcCwgc3RydWN0IHBhY2tfd2luZG93ICoqd19jdXJzLAoJCSAgICAgb2ZmX3QgKmN1cnBvcywgZW51bSBvYmplY3RfdHlwZSB0eXBlLAoJCSAgICAgb2ZmX3QgZGVsdGFfb2JqX29mZnNldCk7Cgp2b2lkIHJlbGVhc2VfcGFja19tZW1vcnkoc2l6ZV90KTsKCi8qIGdsb2JhbCBmbGFnIHRvIGVuYWJsZSBleHRyYSBjaGVja3Mgd2hlbiBhY2Nlc3NpbmcgcGFja2VkIG9iamVjdHMgKi8KZXh0ZXJuIGludCBkb19jaGVja19wYWNrZWRfb2JqZWN0X2NyYzsKCmludCBwYWNrZWRfb2JqZWN0X2luZm8oc3RydWN0IHJlcG9zaXRvcnkgKnIsCgkJICAgICAgIHN0cnVjdCBwYWNrZWRfZ2l0ICpwYWNrLAoJCSAgICAgICBvZmZfdCBvZmZzZXQsIHN0cnVjdCBvYmplY3RfaW5mbyAqKTsKCnZvaWQgbWFya19iYWRfcGFja2VkX29iamVjdChzdHJ1Y3QgcGFja2VkX2dpdCAqLCBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICopOwpjb25zdCBzdHJ1Y3QgcGFja2VkX2dpdCAqaGFzX3BhY2tlZF9hbmRfYmFkKHN0cnVjdCByZXBvc2l0b3J5ICosIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKik7CgojZGVmaW5lIE9OX0RJU0tfS0VFUF9QQUNLUyAxCiNkZWZpbmUgSU5fQ09SRV9LRUVQX1BBQ0tTIDIKCi8qCiAqIElmZiBhIHBhY2sgZmlsZSBpbiB0aGUgZ2l2ZW4gcmVwb3NpdG9yeSBjb250YWlucyB0aGUgb2JqZWN0IG5hbWVkIGJ5IHNoYTEsCiAqIHJldHVybiB0cnVlIGFuZCBzdG9yZSBpdHMgbG9jYXRpb24gdG8gZS4KICovCmludCBmaW5kX3BhY2tfZW50cnkoc3RydWN0IHJlcG9zaXRvcnkgKnIsIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwgc3RydWN0IHBhY2tfZW50cnkgKmUpOwppbnQgZmluZF9rZXB0X3BhY2tfZW50cnkoc3RydWN0IHJlcG9zaXRvcnkgKnIsIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwgdW5zaWduZWQgZmxhZ3MsIHN0cnVjdCBwYWNrX2VudHJ5ICplKTsKCmludCBoYXNfb2JqZWN0X3BhY2soc3RydWN0IHJlcG9zaXRvcnkgKnIsIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCk7CmludCBoYXNfb2JqZWN0X2tlcHRfcGFjayhzdHJ1Y3QgcmVwb3NpdG9yeSAqciwgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLAoJCQkgdW5zaWduZWQgZmxhZ3MpOwoKLyoKICogUmV0dXJuIDEgaWYgYW4gb2JqZWN0IGluIGEgcHJvbWlzb3IgcGFja2ZpbGUgaXMgb3IgcmVmZXJzIHRvIHRoZSBnaXZlbgogKiBvYmplY3QsIDAgb3RoZXJ3aXNlLgogKi8KaW50IGlzX3Byb21pc29yX29iamVjdChzdHJ1Y3QgcmVwb3NpdG9yeSAqciwgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkKTsKCi8qCiAqIEV4cG9zZSBhIGZ1bmN0aW9uIGZvciBmdXp6IHRlc3RpbmcuCiAqCiAqIGxvYWRfaWR4KCkgcGFyc2VzIGEgYmxvY2sgb2YgbWVtb3J5IGFzIGEgcGFja2ZpbGUgaW5kZXggYW5kIHB1dHMgdGhlIHJlc3VsdHMKICogaW50byBhIHN0cnVjdCBwYWNrZWRfZ2l0LgogKgogKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBub3QgYmUgdXNlZCBkaXJlY3RseS4gSXQgaXMgZXhwb3NlZCBoZXJlIG9ubHkgc28gdGhhdCB3ZQogKiBoYXZlIGEgY29udmVuaWVudCBlbnRyeS1wb2ludCBmb3IgZnV6eiB0ZXN0aW5nLiBGb3IgcmVhbCB1c2VzLCB5b3Ugc2hvdWxkCiAqIHByb2JhYmx5IHVzZSBvcGVuX3BhY2tfaW5kZXgoKSBpbnN0ZWFkLgogKi8KaW50IGxvYWRfaWR4KGNvbnN0IGNoYXIgKnBhdGgsIGNvbnN0IHVuc2lnbmVkIGludCBoYXNoc3osIHZvaWQgKmlkeF9tYXAsCgkgICAgIHNpemVfdCBpZHhfc2l6ZSwgc3RydWN0IHBhY2tlZF9naXQgKnApOwoKLyoKICogUGFyc2UgYSAtLXBhY2tfaGVhZGVyIG9wdGlvbiBhcyBhY2NlcHRlZCBieSBpbmRleC1wYWNrIGFuZCB1bnBhY2stb2JqZWN0cywKICogdHVybmluZyBpdCBpbnRvIHRoZSBtYXRjaGluZyBieXRlcyB3ZSdkIGZpbmQgaW4gYSBwYWNrLgogKi8KaW50IHBhcnNlX3BhY2tfaGVhZGVyX29wdGlvbihjb25zdCBjaGFyICppbiwgdW5zaWduZWQgY2hhciAqb3V0LCB1bnNpZ25lZCBpbnQgKmxlbik7CgojZW5kaWYK",
    "text": "#ifndef PACKFILE_H\n#define PACKFILE_H\n\n#include \"object.h\"\n#include \"oidset.h\"\n\n/* in object-store.h */\nstruct packed_git;\nstruct object_info;\n\nstruct pack_window {\n\tstruct pack_window *next;\n\tunsigned char *base;\n\toff_t offset;\n\tsize_t len;\n\tunsigned int last_used;\n\tunsigned int inuse_cnt;\n};\n\nstruct pack_entry {\n\toff_t offset;\n\tstruct packed_git *p;\n};\n\n/*\n * Generate the filename to be used for a pack file with checksum \"sha1\" and\n * extension \"ext\". The result is written into the strbuf \"buf\", overwriting\n * any existing contents. A pointer to buf->buf is returned as a convenience.\n *\n * Example: odb_pack_name(out, sha1, \"idx\") => \".git/objects/pack/pack-1234..idx\"\n */\nchar *odb_pack_name(struct repository *r, struct strbuf *buf,\n\t\t    const unsigned char *hash, const char *ext);\n\n/*\n * Return the basename of the packfile, omitting any containing directory\n * (e.g., \"pack-1234abcd[...].pack\").\n */\nconst char *pack_basename(struct packed_git *p);\n\n/*\n * Parse the pack idx file found at idx_path and create a packed_git struct\n * which can be used with find_pack_entry_one().\n *\n * You probably don't want to use this function! It skips most of the normal\n * sanity checks (including whether we even have the matching .pack file),\n * and does not add the resulting packed_git struct to the internal list of\n * packs. You probably want add_packed_git() instead.\n */\nstruct packed_git *parse_pack_index(struct repository *r, unsigned char *sha1,\n\t\t\t\t    const char *idx_path);\n\ntypedef void each_file_in_pack_dir_fn(const char *full_path, size_t full_path_len,\n\t\t\t\t      const char *file_name, void *data);\nvoid for_each_file_in_pack_subdir(const char *objdir,\n\t\t\t\t  const char *subdir,\n\t\t\t\t  each_file_in_pack_dir_fn fn,\n\t\t\t\t  void *data);\nvoid for_each_file_in_pack_dir(const char *objdir,\n\t\t\t       each_file_in_pack_dir_fn fn,\n\t\t\t       void *data);\n\n/* A hook to report invalid files in pack directory */\n#define PACKDIR_FILE_PACK 1\n#define PACKDIR_FILE_IDX 2\n#define PACKDIR_FILE_GARBAGE 4\nextern void (*report_garbage)(unsigned seen_bits, const char *path);\n\nvoid reprepare_packed_git(struct repository *r);\nvoid install_packed_git(struct repository *r, struct packed_git *pack);\n\nstruct packed_git *get_packed_git(struct repository *r);\nstruct list_head *get_packed_git_mru(struct repository *r);\nstruct multi_pack_index *get_multi_pack_index(struct repository *r);\nstruct multi_pack_index *get_local_multi_pack_index(struct repository *r);\nstruct packed_git *get_all_packs(struct repository *r);\n\n/*\n * Give a rough count of objects in the repository. This sacrifices accuracy\n * for speed.\n */\nunsigned long repo_approximate_object_count(struct repository *r);\n\n/*\n * Find the pack within the \"packs\" list whose index contains the object \"oid\".\n * For general object lookups, you probably don't want this; use\n * find_pack_entry() instead.\n */\nstruct packed_git *find_oid_pack(const struct object_id *oid,\n\t\t\t\t struct packed_git *packs);\n\nvoid pack_report(struct repository *repo);\n\n/*\n * mmap the index file for the specified packfile (if it is not\n * already mmapped).  Return 0 on success.\n */\nint open_pack_index(struct packed_git *);\n\n/*\n * munmap the index file for the specified packfile (if it is\n * currently mmapped).\n */\nvoid close_pack_index(struct packed_git *);\n\nint close_pack_fd(struct packed_git *p);\n\nuint32_t get_pack_fanout(struct packed_git *p, uint32_t value);\n\nstruct raw_object_store;\n\nunsigned char *use_pack(struct packed_git *, struct pack_window **, off_t, unsigned long *);\nvoid close_pack_windows(struct packed_git *);\nvoid close_pack(struct packed_git *);\nvoid close_object_store(struct raw_object_store *o);\nvoid unuse_pack(struct pack_window **);\nvoid clear_delta_base_cache(void);\nstruct packed_git *add_packed_git(struct repository *r, const char *path,\n\t\t\t\t  size_t path_len, int local);\n\n/*\n * Unlink the .pack and associated extension files.\n * Does not unlink if 'force_delete' is false and the pack-file is\n * marked as \".keep\".\n */\nvoid unlink_pack_path(const char *pack_name, int force_delete);\n\n/*\n * Make sure that a pointer access into an mmap'd index file is within bounds,\n * and can provide at least 8 bytes of data.\n *\n * Note that this is only necessary for variable-length segments of the file\n * (like the 64-bit extended offset table), as we compare the size to the\n * fixed-length parts when we open the file.\n */\nvoid check_pack_index_ptr(const struct packed_git *p, const void *ptr);\n\n/*\n * Perform binary search on a pack-index for a given oid. Packfile is expected to\n * have a valid pack-index.\n *\n * See 'bsearch_hash' for more information.\n */\nint bsearch_pack(const struct object_id *oid, const struct packed_git *p, uint32_t *result);\n\n/*\n * Write the oid of the nth object within the specified packfile into the first\n * parameter. Open the index if it is not already open.  Returns 0 on success,\n * negative otherwise.\n */\nint nth_packed_object_id(struct object_id *, struct packed_git *, uint32_t n);\n\n/*\n * Return the offset of the nth object within the specified packfile.\n * The index must already be opened.\n */\noff_t nth_packed_object_offset(const struct packed_git *, uint32_t n);\n\n/*\n * If the object named by oid is present in the specified packfile,\n * return its offset within the packfile; otherwise, return 0.\n */\noff_t find_pack_entry_one(const struct object_id *oid, struct packed_git *);\n\nint is_pack_valid(struct packed_git *);\nvoid *unpack_entry(struct repository *r, struct packed_git *, off_t, enum object_type *, unsigned long *);\nunsigned long unpack_object_header_buffer(const unsigned char *buf, unsigned long len, enum object_type *type, unsigned long *sizep);\nunsigned long get_size_from_delta(struct packed_git *, struct pack_window **, off_t);\nint unpack_object_header(struct packed_git *, struct pack_window **, off_t *, unsigned long *);\noff_t get_delta_base(struct packed_git *p, struct pack_window **w_curs,\n\t\t     off_t *curpos, enum object_type type,\n\t\t     off_t delta_obj_offset);\n\nvoid release_pack_memory(size_t);\n\n/* global flag to enable extra checks when accessing packed objects */\nextern int do_check_packed_object_crc;\n\nint packed_object_info(struct repository *r,\n\t\t       struct packed_git *pack,\n\t\t       off_t offset, struct object_info *);\n\nvoid mark_bad_packed_object(struct packed_git *, const struct object_id *);\nconst struct packed_git *has_packed_and_bad(struct repository *, const struct object_id *);\n\n#define ON_DISK_KEEP_PACKS 1\n#define IN_CORE_KEEP_PACKS 2\n\n/*\n * Iff a pack file in the given repository contains the object named by sha1,\n * return true and store its location to e.\n */\nint find_pack_entry(struct repository *r, const struct object_id *oid, struct pack_entry *e);\nint find_kept_pack_entry(struct repository *r, const struct object_id *oid, unsigned flags, struct pack_entry *e);\n\nint has_object_pack(struct repository *r, const struct object_id *oid);\nint has_object_kept_pack(struct repository *r, const struct object_id *oid,\n\t\t\t unsigned flags);\n\n/*\n * Return 1 if an object in a promisor packfile is or refers to the given\n * object, 0 otherwise.\n */\nint is_promisor_object(struct repository *r, const struct object_id *oid);\n\n/*\n * Expose a function for fuzz testing.\n *\n * load_idx() parses a block of memory as a packfile index and puts the results\n * into a struct packed_git.\n *\n * This function should not be used directly. It is exposed here only so that we\n * have a convenient entry-point for fuzz testing. For real uses, you should\n * probably use open_pack_index() instead.\n */\nint load_idx(const char *path, const unsigned int hashsz, void *idx_map,\n\t     size_t idx_size, struct packed_git *p);\n\n/*\n * Parse a --pack_header option as accepted by index-pack and unpack-objects,\n * turning it into the matching bytes we'd find in a pack.\n */\nint parse_pack_header_option(const char *in, unsigned char *out, unsigned int *len);\n\n#endif\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00ada7a938f7a971a54b2b398e4e53eea59eb4ae",
  "sha1_ok": true,
  "size": 7917
}
