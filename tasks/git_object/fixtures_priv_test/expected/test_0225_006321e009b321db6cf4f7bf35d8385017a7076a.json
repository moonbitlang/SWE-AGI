{
  "content": {
    "base64": "LyoKICogR0lUIC0gVGhlIGluZm9ybWF0aW9uIG1hbmFnZXIgZnJvbSBoZWxsCiAqCiAqIENvcHlyaWdodCAoQykgTGludXMgVG9ydmFsZHMsIDIwMDUKICoKICogVGhpcyBoYW5kbGVzIGJhc2ljIGdpdCBzaGExIG9iamVjdCBmaWxlcyAtIHBhY2tpbmcsIHVucGFja2luZywKICogY3JlYXRpb24gZXRjLgogKi8KI2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJkZWx0YS5oIgojaW5jbHVkZSAicGFjay5oIgojaW5jbHVkZSAiYmxvYi5oIgojaW5jbHVkZSAiY29tbWl0LmgiCiNpbmNsdWRlICJ0YWcuaCIKI2luY2x1ZGUgInRyZWUuaCIKI2luY2x1ZGUgInJlZnMuaCIKI2luY2x1ZGUgInBhY2stcmV2aW5kZXguaCIKI2luY2x1ZGUgInNoYTEtbG9va3VwLmgiCgojaWZuZGVmIE9fTk9BVElNRQojaWYgZGVmaW5lZChfX2xpbnV4X18pICYmIChkZWZpbmVkKF9faTM4Nl9fKSB8fCBkZWZpbmVkKF9fUFBDX18pKQojZGVmaW5lIE9fTk9BVElNRSAwMTAwMDAwMAojZWxzZQojZGVmaW5lIE9fTk9BVElNRSAwCiNlbmRpZgojZW5kaWYKCiNpZmRlZiBOT19DOTlfRk9STUFUCiNkZWZpbmUgU1pfRk1UICJsdSIKc3RhdGljIHVuc2lnbmVkIGxvbmcgc3pfZm10KHNpemVfdCBzKSB7IHJldHVybiAodW5zaWduZWQgbG9uZylzOyB9CiNlbHNlCiNkZWZpbmUgU1pfRk1UICJ6dSIKc3RhdGljIHNpemVfdCBzel9mbXQoc2l6ZV90IHMpIHsgcmV0dXJuIHM7IH0KI2VuZGlmCgpjb25zdCB1bnNpZ25lZCBjaGFyIG51bGxfc2hhMVsyMF07CgpzdGF0aWMgaW5saW5lIGludCBvZmZzZXRfMXN0X2NvbXBvbmVudChjb25zdCBjaGFyICpwYXRoKQp7CglpZiAoaGFzX2Rvc19kcml2ZV9wcmVmaXgocGF0aCkpCgkJcmV0dXJuIDIgKyAocGF0aFsyXSA9PSAnLycpOwoJcmV0dXJuICpwYXRoID09ICcvJzsKfQoKaW50IHNhZmVfY3JlYXRlX2xlYWRpbmdfZGlyZWN0b3JpZXMoY2hhciAqcGF0aCkKewoJY2hhciAqcG9zID0gcGF0aCArIG9mZnNldF8xc3RfY29tcG9uZW50KHBhdGgpOwoJc3RydWN0IHN0YXQgc3Q7CgoJd2hpbGUgKHBvcykgewoJCXBvcyA9IHN0cmNocihwb3MsICcvJyk7CgkJaWYgKCFwb3MpCgkJCWJyZWFrOwoJCXdoaWxlICgqKytwb3MgPT0gJy8nKQoJCQk7CgkJaWYgKCEqcG9zKQoJCQlicmVhazsKCQkqLS1wb3MgPSAnXDAnOwoJCWlmICghc3RhdChwYXRoLCAmc3QpKSB7CgkJCS8qIHBhdGggZXhpc3RzICovCgkJCWlmICghU19JU0RJUihzdC5zdF9tb2RlKSkgewoJCQkJKnBvcyA9ICcvJzsKCQkJCXJldHVybiAtMzsKCQkJfQoJCX0KCQllbHNlIGlmIChta2RpcihwYXRoLCAwNzc3KSkgewoJCQkqcG9zID0gJy8nOwoJCQlyZXR1cm4gLTE7CgkJfQoJCWVsc2UgaWYgKGFkanVzdF9zaGFyZWRfcGVybShwYXRoKSkgewoJCQkqcG9zID0gJy8nOwoJCQlyZXR1cm4gLTI7CgkJfQoJCSpwb3MrKyA9ICcvJzsKCX0KCXJldHVybiAwOwp9CgppbnQgc2FmZV9jcmVhdGVfbGVhZGluZ19kaXJlY3Rvcmllc19jb25zdChjb25zdCBjaGFyICpwYXRoKQp7CgkvKiBwYXRoIHBvaW50cyB0byBjYWNoZSBlbnRyaWVzLCBzbyB4c3RyZHVwIGJlZm9yZSBtZXNzaW5nIHdpdGggaXQgKi8KCWNoYXIgKmJ1ZiA9IHhzdHJkdXAocGF0aCk7CglpbnQgcmVzdWx0ID0gc2FmZV9jcmVhdGVfbGVhZGluZ19kaXJlY3RvcmllcyhidWYpOwoJZnJlZShidWYpOwoJcmV0dXJuIHJlc3VsdDsKfQoKc3RhdGljIHZvaWQgZmlsbF9zaGExX3BhdGgoY2hhciAqcGF0aGJ1ZiwgY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSkKewoJaW50IGk7Cglmb3IgKGkgPSAwOyBpIDwgMjA7IGkrKykgewoJCXN0YXRpYyBjaGFyIGhleFtdID0gIjAxMjM0NTY3ODlhYmNkZWYiOwoJCXVuc2lnbmVkIGludCB2YWwgPSBzaGExW2ldOwoJCWNoYXIgKnBvcyA9IHBhdGhidWYgKyBpKjIgKyAoaSA+IDApOwoJCSpwb3MrKyA9IGhleFt2YWwgPj4gNF07CgkJKnBvcyA9IGhleFt2YWwgJiAweGZdOwoJfQp9CgovKgogKiBOT1RFISBUaGlzIHJldHVybnMgYSBzdGF0aWNhbGx5IGFsbG9jYXRlZCBidWZmZXIsIHNvIHlvdSBoYXZlIHRvIGJlCiAqIGNhcmVmdWwgYWJvdXQgdXNpbmcgaXQuIERvIGFuICJ4c3RyZHVwKCkiIGlmIHlvdSBuZWVkIHRvIHNhdmUgdGhlCiAqIGZpbGVuYW1lLgogKgogKiBBbHNvIG5vdGUgdGhhdCB0aGlzIHJldHVybnMgdGhlIGxvY2F0aW9uIGZvciBjcmVhdGluZy4gIFJlYWRpbmcKICogU0hBMSBmaWxlIGNhbiBoYXBwZW4gZnJvbSBhbnkgYWx0ZXJuYXRlIGRpcmVjdG9yeSBsaXN0ZWQgaW4gdGhlCiAqIERCX0VOVklST05NRU5UIGVudmlyb25tZW50IHZhcmlhYmxlIGlmIGl0IGlzIG5vdCBmb3VuZCBpbgogKiB0aGUgcHJpbWFyeSBvYmplY3QgZGF0YWJhc2UuCiAqLwpjaGFyICpzaGExX2ZpbGVfbmFtZShjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExKQp7CglzdGF0aWMgY2hhciAqbmFtZSwgKmJhc2U7CgoJaWYgKCFiYXNlKSB7CgkJY29uc3QgY2hhciAqc2hhMV9maWxlX2RpcmVjdG9yeSA9IGdldF9vYmplY3RfZGlyZWN0b3J5KCk7CgkJaW50IGxlbiA9IHN0cmxlbihzaGExX2ZpbGVfZGlyZWN0b3J5KTsKCQliYXNlID0geG1hbGxvYyhsZW4gKyA2MCk7CgkJbWVtY3B5KGJhc2UsIHNoYTFfZmlsZV9kaXJlY3RvcnksIGxlbik7CgkJbWVtc2V0KGJhc2UrbGVuLCAwLCA2MCk7CgkJYmFzZVtsZW5dID0gJy8nOwoJCWJhc2VbbGVuKzNdID0gJy8nOwoJCW5hbWUgPSBiYXNlICsgbGVuICsgMTsKCX0KCWZpbGxfc2hhMV9wYXRoKG5hbWUsIHNoYTEpOwoJcmV0dXJuIGJhc2U7Cn0KCnN0YXRpYyBjaGFyICpzaGExX2dldF9wYWNrX25hbWUoY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwKCQkJCWNoYXIgKipuYW1lLCBjaGFyICoqYmFzZSwgY29uc3QgY2hhciAqd2hpY2gpCnsKCXN0YXRpYyBjb25zdCBjaGFyIGhleFtdID0gIjAxMjM0NTY3ODlhYmNkZWYiOwoJY2hhciAqYnVmOwoJaW50IGk7CgoJaWYgKCEqYmFzZSkgewoJCWNvbnN0IGNoYXIgKnNoYTFfZmlsZV9kaXJlY3RvcnkgPSBnZXRfb2JqZWN0X2RpcmVjdG9yeSgpOwoJCWludCBsZW4gPSBzdHJsZW4oc2hhMV9maWxlX2RpcmVjdG9yeSk7CgkJKmJhc2UgPSB4bWFsbG9jKGxlbiArIDYwKTsKCQlzcHJpbnRmKCpiYXNlLCAiJXMvcGFjay9wYWNrLTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAuJXMiLAoJCQlzaGExX2ZpbGVfZGlyZWN0b3J5LCB3aGljaCk7CgkJKm5hbWUgPSAqYmFzZSArIGxlbiArIDExOwoJfQoKCWJ1ZiA9ICpuYW1lOwoKCWZvciAoaSA9IDA7IGkgPCAyMDsgaSsrKSB7CgkJdW5zaWduZWQgaW50IHZhbCA9ICpzaGExKys7CgkJKmJ1ZisrID0gaGV4W3ZhbCA+PiA0XTsKCQkqYnVmKysgPSBoZXhbdmFsICYgMHhmXTsKCX0KCglyZXR1cm4gKmJhc2U7Cn0KCmNoYXIgKnNoYTFfcGFja19uYW1lKGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEpCnsKCXN0YXRpYyBjaGFyICpuYW1lLCAqYmFzZTsKCglyZXR1cm4gc2hhMV9nZXRfcGFja19uYW1lKHNoYTEsICZuYW1lLCAmYmFzZSwgInBhY2siKTsKfQoKY2hhciAqc2hhMV9wYWNrX2luZGV4X25hbWUoY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSkKewoJc3RhdGljIGNoYXIgKm5hbWUsICpiYXNlOwoKCXJldHVybiBzaGExX2dldF9wYWNrX25hbWUoc2hhMSwgJm5hbWUsICZiYXNlLCAiaWR4Iik7Cn0KCnN0cnVjdCBhbHRlcm5hdGVfb2JqZWN0X2RhdGFiYXNlICphbHRfb2RiX2xpc3Q7CnN0YXRpYyBzdHJ1Y3QgYWx0ZXJuYXRlX29iamVjdF9kYXRhYmFzZSAqKmFsdF9vZGJfdGFpbDsKCnN0YXRpYyB2b2lkIHJlYWRfaW5mb19hbHRlcm5hdGVzKGNvbnN0IGNoYXIgKiBhbHRlcm5hdGVzLCBpbnQgZGVwdGgpOwoKLyoKICogUHJlcGFyZSBhbHRlcm5hdGUgb2JqZWN0IGRhdGFiYXNlIHJlZ2lzdHJ5LgogKgogKiBUaGUgdmFyaWFibGUgYWx0X29kYl9saXN0IHBvaW50cyBhdCB0aGUgbGlzdCBvZiBzdHJ1Y3QKICogYWx0ZXJuYXRlX29iamVjdF9kYXRhYmFzZS4gIFRoZSBlbGVtZW50cyBvbiB0aGlzIGxpc3QgY29tZSBmcm9tCiAqIG5vbi1lbXB0eSBlbGVtZW50cyBmcm9tIGNvbG9uIHNlcGFyYXRlZCBBTFRFUk5BVEVfREJfRU5WSVJPTk1FTlQKICogZW52aXJvbm1lbnQgdmFyaWFibGUsIGFuZCAkR0lUX09CSkVDVF9ESVJFQ1RPUlkvaW5mby9hbHRlcm5hdGVzLAogKiB3aG9zZSBjb250ZW50cyBpcyBzaW1pbGFyIHRvIHRoYXQgZW52aXJvbm1lbnQgdmFyaWFibGUgYnV0IGNhbiBiZQogKiBMRiBzZXBhcmF0ZWQuICBJdHMgYmFzZSBwb2ludHMgYXQgYSBzdGF0aWNhbGx5IGFsbG9jYXRlZCBidWZmZXIgdGhhdAogKiBjb250YWlucyAiL3RoZS9kaXJlY3RvcnkvY29ycmVzcG9uZGluZy90by8uZ2l0L29iamVjdHMvLi4uIiwgd2hpbGUKICogaXRzIG5hbWUgcG9pbnRzIGp1c3QgYWZ0ZXIgdGhlIHNsYXNoIGF0IHRoZSBlbmQgb2YgIi5naXQvb2JqZWN0cy8iCiAqIGluIHRoZSBleGFtcGxlIGFib3ZlLCBhbmQgaGFzIGVub3VnaCBzcGFjZSB0byBob2xkIDQwLWJ5dGUgaGV4CiAqIFNIQTEsIGFuIGV4dHJhIHNsYXNoIGZvciB0aGUgZmlyc3QgbGV2ZWwgaW5kaXJlY3Rpb24sIGFuZCB0aGUKICogdGVybWluYXRpbmcgTlVMLgogKi8Kc3RhdGljIGludCBsaW5rX2FsdF9vZGJfZW50cnkoY29uc3QgY2hhciAqIGVudHJ5LCBpbnQgbGVuLCBjb25zdCBjaGFyICogcmVsYXRpdmVfYmFzZSwgaW50IGRlcHRoKQp7Cgljb25zdCBjaGFyICpvYmpkaXIgPSBnZXRfb2JqZWN0X2RpcmVjdG9yeSgpOwoJc3RydWN0IGFsdGVybmF0ZV9vYmplY3RfZGF0YWJhc2UgKmVudDsKCXN0cnVjdCBhbHRlcm5hdGVfb2JqZWN0X2RhdGFiYXNlICphbHQ7CgkvKiA0MyA9IDQwLWJ5dGUgKyAyICcvJyArIHRlcm1pbmF0aW5nIE5VTCAqLwoJaW50IHBmeGxlbiA9IGxlbjsKCWludCBlbnRsZW4gPSBwZnhsZW4gKyA0MzsKCWludCBiYXNlX2xlbiA9IC0xOwoKCWlmICghaXNfYWJzb2x1dGVfcGF0aChlbnRyeSkgJiYgcmVsYXRpdmVfYmFzZSkgewoJCS8qIFJlbGF0aXZlIGFsdC1vZGIgKi8KCQlpZiAoYmFzZV9sZW4gPCAwKQoJCQliYXNlX2xlbiA9IHN0cmxlbihyZWxhdGl2ZV9iYXNlKSArIDE7CgkJZW50bGVuICs9IGJhc2VfbGVuOwoJCXBmeGxlbiArPSBiYXNlX2xlbjsKCX0KCWVudCA9IHhtYWxsb2Moc2l6ZW9mKCplbnQpICsgZW50bGVuKTsKCglpZiAoIWlzX2Fic29sdXRlX3BhdGgoZW50cnkpICYmIHJlbGF0aXZlX2Jhc2UpIHsKCQltZW1jcHkoZW50LT5iYXNlLCByZWxhdGl2ZV9iYXNlLCBiYXNlX2xlbiAtIDEpOwoJCWVudC0+YmFzZVtiYXNlX2xlbiAtIDFdID0gJy8nOwoJCW1lbWNweShlbnQtPmJhc2UgKyBiYXNlX2xlbiwgZW50cnksIGxlbik7Cgl9CgllbHNlCgkJbWVtY3B5KGVudC0+YmFzZSwgZW50cnksIHBmeGxlbik7CgoJZW50LT5uYW1lID0gZW50LT5iYXNlICsgcGZ4bGVuICsgMTsKCWVudC0+YmFzZVtwZnhsZW4gKyAzXSA9ICcvJzsKCWVudC0+YmFzZVtwZnhsZW5dID0gZW50LT5iYXNlW2VudGxlbi0xXSA9IDA7CgoJLyogRGV0ZWN0IGNhc2VzIHdoZXJlIGFsdGVybmF0ZSBkaXNhcHBlYXJlZCAqLwoJaWYgKCFpc19kaXJlY3RvcnkoZW50LT5iYXNlKSkgewoJCWVycm9yKCJvYmplY3QgZGlyZWN0b3J5ICVzIGRvZXMgbm90IGV4aXN0OyAiCgkJICAgICAgImNoZWNrIC5naXQvb2JqZWN0cy9pbmZvL2FsdGVybmF0ZXMuIiwKCQkgICAgICBlbnQtPmJhc2UpOwoJCWZyZWUoZW50KTsKCQlyZXR1cm4gLTE7Cgl9CgoJLyogUHJldmVudCB0aGUgY29tbW9uIG1pc3Rha2Ugb2YgbGlzdGluZyB0aGUgc2FtZQoJICogdGhpbmcgdHdpY2UsIG9yIG9iamVjdCBkaXJlY3RvcnkgaXRzZWxmLgoJICovCglmb3IgKGFsdCA9IGFsdF9vZGJfbGlzdDsgYWx0OyBhbHQgPSBhbHQtPm5leHQpIHsKCQlpZiAoIW1lbWNtcChlbnQtPmJhc2UsIGFsdC0+YmFzZSwgcGZ4bGVuKSkgewoJCQlmcmVlKGVudCk7CgkJCXJldHVybiAtMTsKCQl9Cgl9CglpZiAoIW1lbWNtcChlbnQtPmJhc2UsIG9iamRpciwgcGZ4bGVuKSkgewoJCWZyZWUoZW50KTsKCQlyZXR1cm4gLTE7Cgl9CgoJLyogYWRkIHRoZSBhbHRlcm5hdGUgZW50cnkgKi8KCSphbHRfb2RiX3RhaWwgPSBlbnQ7CglhbHRfb2RiX3RhaWwgPSAmKGVudC0+bmV4dCk7CgllbnQtPm5leHQgPSBOVUxMOwoKCS8qIHJlY3Vyc2l2ZWx5IGFkZCBhbHRlcm5hdGVzICovCglyZWFkX2luZm9fYWx0ZXJuYXRlcyhlbnQtPmJhc2UsIGRlcHRoICsgMSk7CgoJZW50LT5iYXNlW3BmeGxlbl0gPSAnLyc7CgoJcmV0dXJuIDA7Cn0KCnN0YXRpYyB2b2lkIGxpbmtfYWx0X29kYl9lbnRyaWVzKGNvbnN0IGNoYXIgKmFsdCwgY29uc3QgY2hhciAqZXAsIGludCBzZXAsCgkJCQkgY29uc3QgY2hhciAqcmVsYXRpdmVfYmFzZSwgaW50IGRlcHRoKQp7Cgljb25zdCBjaGFyICpjcCwgKmxhc3Q7CgoJaWYgKGRlcHRoID4gNSkgewoJCWVycm9yKCIlczogaWdub3JpbmcgYWx0ZXJuYXRlIG9iamVjdCBzdG9yZXMsIG5lc3RpbmcgdG9vIGRlZXAuIiwKCQkJCXJlbGF0aXZlX2Jhc2UpOwoJCXJldHVybjsKCX0KCglsYXN0ID0gYWx0OwoJd2hpbGUgKGxhc3QgPCBlcCkgewoJCWNwID0gbGFzdDsKCQlpZiAoY3AgPCBlcCAmJiAqY3AgPT0gJyMnKSB7CgkJCXdoaWxlIChjcCA8IGVwICYmICpjcCAhPSBzZXApCgkJCQljcCsrOwoJCQlsYXN0ID0gY3AgKyAxOwoJCQljb250aW51ZTsKCQl9CgkJd2hpbGUgKGNwIDwgZXAgJiYgKmNwICE9IHNlcCkKCQkJY3ArKzsKCQlpZiAobGFzdCAhPSBjcCkgewoJCQlpZiAoIWlzX2Fic29sdXRlX3BhdGgobGFzdCkgJiYgZGVwdGgpIHsKCQkJCWVycm9yKCIlczogaWdub3JpbmcgcmVsYXRpdmUgYWx0ZXJuYXRlIG9iamVjdCBzdG9yZSAlcyIsCgkJCQkJCXJlbGF0aXZlX2Jhc2UsIGxhc3QpOwoJCQl9IGVsc2UgewoJCQkJbGlua19hbHRfb2RiX2VudHJ5KGxhc3QsIGNwIC0gbGFzdCwKCQkJCQkJcmVsYXRpdmVfYmFzZSwgZGVwdGgpOwoJCQl9CgkJfQoJCXdoaWxlIChjcCA8IGVwICYmICpjcCA9PSBzZXApCgkJCWNwKys7CgkJbGFzdCA9IGNwOwoJfQp9CgpzdGF0aWMgdm9pZCByZWFkX2luZm9fYWx0ZXJuYXRlcyhjb25zdCBjaGFyICogcmVsYXRpdmVfYmFzZSwgaW50IGRlcHRoKQp7CgljaGFyICptYXA7CglzaXplX3QgbWFwc3o7CglzdHJ1Y3Qgc3RhdCBzdDsKCWNvbnN0IGNoYXIgYWx0X2ZpbGVfbmFtZVtdID0gImluZm8vYWx0ZXJuYXRlcyI7CgkvKiBHaXZlbiB0aGF0IHJlbGF0aXZlX2Jhc2UgaXMgbm8gbG9uZ2VyIHRoYW4gUEFUSF9NQVgsCgkgICBlbnN1cmUgdGhhdCAicGF0aCIgaGFzIGVub3VnaCBzcGFjZSB0byBhcHBlbmQgIi8iLCB0aGUKCSAgIGZpbGUgbmFtZSwgImluZm8vYWx0ZXJuYXRlcyIsIGFuZCBhIHRyYWlsaW5nIE5VTC4gICovCgljaGFyIHBhdGhbUEFUSF9NQVggKyAxICsgc2l6ZW9mIGFsdF9maWxlX25hbWVdOwoJaW50IGZkOwoKCXNwcmludGYocGF0aCwgIiVzLyVzIiwgcmVsYXRpdmVfYmFzZSwgYWx0X2ZpbGVfbmFtZSk7CglmZCA9IG9wZW4ocGF0aCwgT19SRE9OTFkpOwoJaWYgKGZkIDwgMCkKCQlyZXR1cm47CglpZiAoZnN0YXQoZmQsICZzdCkgfHwgKHN0LnN0X3NpemUgPT0gMCkpIHsKCQljbG9zZShmZCk7CgkJcmV0dXJuOwoJfQoJbWFwc3ogPSB4c2l6ZV90KHN0LnN0X3NpemUpOwoJbWFwID0geG1tYXAoTlVMTCwgbWFwc3osIFBST1RfUkVBRCwgTUFQX1BSSVZBVEUsIGZkLCAwKTsKCWNsb3NlKGZkKTsKCglsaW5rX2FsdF9vZGJfZW50cmllcyhtYXAsIG1hcCArIG1hcHN6LCAnXG4nLCByZWxhdGl2ZV9iYXNlLCBkZXB0aCk7CgoJbXVubWFwKG1hcCwgbWFwc3opOwp9Cgp2b2lkIGFkZF90b19hbHRlcm5hdGVzX2ZpbGUoY29uc3QgY2hhciAqcmVmZXJlbmNlKQp7CglzdHJ1Y3QgbG9ja19maWxlICpsb2NrID0geGNhbGxvYygxLCBzaXplb2Yoc3RydWN0IGxvY2tfZmlsZSkpOwoJaW50IGZkID0gaG9sZF9sb2NrX2ZpbGVfZm9yX2FwcGVuZChsb2NrLCBnaXRfcGF0aCgib2JqZWN0cy9pbmZvL2FsdGVybmF0ZXMiKSwgTE9DS19ESUVfT05fRVJST1IpOwoJY2hhciAqYWx0ID0gbWtwYXRoKCIlcy9vYmplY3RzXG4iLCByZWZlcmVuY2UpOwoJd3JpdGVfb3JfZGllKGZkLCBhbHQsIHN0cmxlbihhbHQpKTsKCWlmIChjb21taXRfbG9ja19maWxlKGxvY2spKQoJCWRpZSgiY291bGQgbm90IGNsb3NlIGFsdGVybmF0ZXMgZmlsZSIpOwoJaWYgKGFsdF9vZGJfdGFpbCkKCQlsaW5rX2FsdF9vZGJfZW50cmllcyhhbHQsIGFsdCArIHN0cmxlbihhbHQpLCAnXG4nLCBOVUxMLCAwKTsKfQoKdm9pZCBmb3JlYWNoX2FsdF9vZGIoYWx0X29kYl9mbiBmbiwgdm9pZCAqY2IpCnsKCXN0cnVjdCBhbHRlcm5hdGVfb2JqZWN0X2RhdGFiYXNlICplbnQ7CgoJcHJlcGFyZV9hbHRfb2RiKCk7Cglmb3IgKGVudCA9IGFsdF9vZGJfbGlzdDsgZW50OyBlbnQgPSBlbnQtPm5leHQpCgkJaWYgKGZuKGVudCwgY2IpKQoJCQlyZXR1cm47Cn0KCnZvaWQgcHJlcGFyZV9hbHRfb2RiKHZvaWQpCnsKCWNvbnN0IGNoYXIgKmFsdDsKCglpZiAoYWx0X29kYl90YWlsKQoJCXJldHVybjsKCglhbHQgPSBnZXRlbnYoQUxURVJOQVRFX0RCX0VOVklST05NRU5UKTsKCWlmICghYWx0KSBhbHQgPSAiIjsKCglhbHRfb2RiX3RhaWwgPSAmYWx0X29kYl9saXN0OwoJbGlua19hbHRfb2RiX2VudHJpZXMoYWx0LCBhbHQgKyBzdHJsZW4oYWx0KSwgUEFUSF9TRVAsIE5VTEwsIDApOwoKCXJlYWRfaW5mb19hbHRlcm5hdGVzKGdldF9vYmplY3RfZGlyZWN0b3J5KCksIDApOwp9CgpzdGF0aWMgaW50IGhhc19sb29zZV9vYmplY3RfbG9jYWwoY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSkKewoJY2hhciAqbmFtZSA9IHNoYTFfZmlsZV9uYW1lKHNoYTEpOwoJcmV0dXJuICFhY2Nlc3MobmFtZSwgRl9PSyk7Cn0KCmludCBoYXNfbG9vc2Vfb2JqZWN0X25vbmxvY2FsKGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEpCnsKCXN0cnVjdCBhbHRlcm5hdGVfb2JqZWN0X2RhdGFiYXNlICphbHQ7CglwcmVwYXJlX2FsdF9vZGIoKTsKCWZvciAoYWx0ID0gYWx0X29kYl9saXN0OyBhbHQ7IGFsdCA9IGFsdC0+bmV4dCkgewoJCWZpbGxfc2hhMV9wYXRoKGFsdC0+bmFtZSwgc2hhMSk7CgkJaWYgKCFhY2Nlc3MoYWx0LT5iYXNlLCBGX09LKSkKCQkJcmV0dXJuIDE7Cgl9CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBoYXNfbG9vc2Vfb2JqZWN0KGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEpCnsKCXJldHVybiBoYXNfbG9vc2Vfb2JqZWN0X2xvY2FsKHNoYTEpIHx8CgkgICAgICAgaGFzX2xvb3NlX29iamVjdF9ub25sb2NhbChzaGExKTsKfQoKc3RhdGljIHVuc2lnbmVkIGludCBwYWNrX3VzZWRfY3RyOwpzdGF0aWMgdW5zaWduZWQgaW50IHBhY2tfbW1hcF9jYWxsczsKc3RhdGljIHVuc2lnbmVkIGludCBwZWFrX3BhY2tfb3Blbl93aW5kb3dzOwpzdGF0aWMgdW5zaWduZWQgaW50IHBhY2tfb3Blbl93aW5kb3dzOwpzdGF0aWMgc2l6ZV90IHBlYWtfcGFja19tYXBwZWQ7CnN0YXRpYyBzaXplX3QgcGFja19tYXBwZWQ7CnN0cnVjdCBwYWNrZWRfZ2l0ICpwYWNrZWRfZ2l0OwoKdm9pZCBwYWNrX3JlcG9ydCh2b2lkKQp7CglmcHJpbnRmKHN0ZGVyciwKCQkicGFja19yZXBvcnQ6IGdldHBhZ2VzaXplKCkgICAgICAgICAgICA9ICUxMCIgU1pfRk1UICJcbiIKCQkicGFja19yZXBvcnQ6IGNvcmUucGFja2VkR2l0V2luZG93U2l6ZSA9ICUxMCIgU1pfRk1UICJcbiIKCQkicGFja19yZXBvcnQ6IGNvcmUucGFja2VkR2l0TGltaXQgICAgICA9ICUxMCIgU1pfRk1UICJcbiIsCgkJc3pfZm10KGdldHBhZ2VzaXplKCkpLAoJCXN6X2ZtdChwYWNrZWRfZ2l0X3dpbmRvd19zaXplKSwKCQlzel9mbXQocGFja2VkX2dpdF9saW1pdCkpOwoJZnByaW50ZihzdGRlcnIsCgkJInBhY2tfcmVwb3J0OiBwYWNrX3VzZWRfY3RyICAgICAgICAgICAgPSAlMTB1XG4iCgkJInBhY2tfcmVwb3J0OiBwYWNrX21tYXBfY2FsbHMgICAgICAgICAgPSAlMTB1XG4iCgkJInBhY2tfcmVwb3J0OiBwYWNrX29wZW5fd2luZG93cyAgICAgICAgPSAlMTB1IC8gJTEwdVxuIgoJCSJwYWNrX3JlcG9ydDogcGFja19tYXBwZWQgICAgICAgICAgICAgID0gIgoJCQkiJTEwIiBTWl9GTVQgIiAvICUxMCIgU1pfRk1UICJcbiIsCgkJcGFja191c2VkX2N0ciwKCQlwYWNrX21tYXBfY2FsbHMsCgkJcGFja19vcGVuX3dpbmRvd3MsIHBlYWtfcGFja19vcGVuX3dpbmRvd3MsCgkJc3pfZm10KHBhY2tfbWFwcGVkKSwgc3pfZm10KHBlYWtfcGFja19tYXBwZWQpKTsKfQoKc3RhdGljIGludCBjaGVja19wYWNrZWRfZ2l0X2lkeChjb25zdCBjaGFyICpwYXRoLCAgc3RydWN0IHBhY2tlZF9naXQgKnApCnsKCXZvaWQgKmlkeF9tYXA7CglzdHJ1Y3QgcGFja19pZHhfaGVhZGVyICpoZHI7CglzaXplX3QgaWR4X3NpemU7Cgl1aW50MzJfdCB2ZXJzaW9uLCBuciwgaSwgKmluZGV4OwoJaW50IGZkID0gb3BlbihwYXRoLCBPX1JET05MWSk7CglzdHJ1Y3Qgc3RhdCBzdDsKCglpZiAoZmQgPCAwKQoJCXJldHVybiAtMTsKCWlmIChmc3RhdChmZCwgJnN0KSkgewoJCWNsb3NlKGZkKTsKCQlyZXR1cm4gLTE7Cgl9CglpZHhfc2l6ZSA9IHhzaXplX3Qoc3Quc3Rfc2l6ZSk7CglpZiAoaWR4X3NpemUgPCA0ICogMjU2ICsgMjAgKyAyMCkgewoJCWNsb3NlKGZkKTsKCQlyZXR1cm4gZXJyb3IoImluZGV4IGZpbGUgJXMgaXMgdG9vIHNtYWxsIiwgcGF0aCk7Cgl9CglpZHhfbWFwID0geG1tYXAoTlVMTCwgaWR4X3NpemUsIFBST1RfUkVBRCwgTUFQX1BSSVZBVEUsIGZkLCAwKTsKCWNsb3NlKGZkKTsKCgloZHIgPSBpZHhfbWFwOwoJaWYgKGhkci0+aWR4X3NpZ25hdHVyZSA9PSBodG9ubChQQUNLX0lEWF9TSUdOQVRVUkUpKSB7CgkJdmVyc2lvbiA9IG50b2hsKGhkci0+aWR4X3ZlcnNpb24pOwoJCWlmICh2ZXJzaW9uIDwgMiB8fCB2ZXJzaW9uID4gMikgewoJCQltdW5tYXAoaWR4X21hcCwgaWR4X3NpemUpOwoJCQlyZXR1cm4gZXJyb3IoImluZGV4IGZpbGUgJXMgaXMgdmVyc2lvbiAlIlBSSXUzMgoJCQkJICAgICAiIGFuZCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgYmluYXJ5IgoJCQkJICAgICAiICh0cnkgdXBncmFkaW5nIEdJVCB0byBhIG5ld2VyIHZlcnNpb24pIiwKCQkJCSAgICAgcGF0aCwgdmVyc2lvbik7CgkJfQoJfSBlbHNlCgkJdmVyc2lvbiA9IDE7CgoJbnIgPSAwOwoJaW5kZXggPSBpZHhfbWFwOwoJaWYgKHZlcnNpb24gPiAxKQoJCWluZGV4ICs9IDI7ICAvKiBza2lwIGluZGV4IGhlYWRlciAqLwoJZm9yIChpID0gMDsgaSA8IDI1NjsgaSsrKSB7CgkJdWludDMyX3QgbiA9IG50b2hsKGluZGV4W2ldKTsKCQlpZiAobiA8IG5yKSB7CgkJCW11bm1hcChpZHhfbWFwLCBpZHhfc2l6ZSk7CgkJCXJldHVybiBlcnJvcigibm9uLW1vbm90b25pYyBpbmRleCAlcyIsIHBhdGgpOwoJCX0KCQluciA9IG47Cgl9CgoJaWYgKHZlcnNpb24gPT0gMSkgewoJCS8qCgkJICogVG90YWwgc2l6ZToKCQkgKiAgLSAyNTYgaW5kZXggZW50cmllcyA0IGJ5dGVzIGVhY2gKCQkgKiAgLSAyNC1ieXRlIGVudHJpZXMgKiBuciAoMjAtYnl0ZSBzaGExICsgNC1ieXRlIG9mZnNldCkKCQkgKiAgLSAyMC1ieXRlIFNIQTEgb2YgdGhlIHBhY2tmaWxlCgkJICogIC0gMjAtYnl0ZSBTSEExIGZpbGUgY2hlY2tzdW0KCQkgKi8KCQlpZiAoaWR4X3NpemUgIT0gNCoyNTYgKyBuciAqIDI0ICsgMjAgKyAyMCkgewoJCQltdW5tYXAoaWR4X21hcCwgaWR4X3NpemUpOwoJCQlyZXR1cm4gZXJyb3IoIndyb25nIGluZGV4IHYxIGZpbGUgc2l6ZSBpbiAlcyIsIHBhdGgpOwoJCX0KCX0gZWxzZSBpZiAodmVyc2lvbiA9PSAyKSB7CgkJLyoKCQkgKiBNaW5pbXVtIHNpemU6CgkJICogIC0gOCBieXRlcyBvZiBoZWFkZXIKCQkgKiAgLSAyNTYgaW5kZXggZW50cmllcyA0IGJ5dGVzIGVhY2gKCQkgKiAgLSAyMC1ieXRlIHNoYTEgZW50cnkgKiBucgoJCSAqICAtIDQtYnl0ZSBjcmMgZW50cnkgKiBucgoJCSAqICAtIDQtYnl0ZSBvZmZzZXQgZW50cnkgKiBucgoJCSAqICAtIDIwLWJ5dGUgU0hBMSBvZiB0aGUgcGFja2ZpbGUKCQkgKiAgLSAyMC1ieXRlIFNIQTEgZmlsZSBjaGVja3N1bQoJCSAqIEFuZCBhZnRlciB0aGUgNC1ieXRlIG9mZnNldCB0YWJsZSBtaWdodCBiZSBhCgkJICogdmFyaWFibGUgc2l6ZWQgdGFibGUgY29udGFpbmluZyA4LWJ5dGUgZW50cmllcwoJCSAqIGZvciBvZmZzZXRzIGxhcmdlciB0aGFuIDJeMzEuCgkJICovCgkJdW5zaWduZWQgbG9uZyBtaW5fc2l6ZSA9IDggKyA0KjI1NiArIG5yKigyMCArIDQgKyA0KSArIDIwICsgMjA7CgkJdW5zaWduZWQgbG9uZyBtYXhfc2l6ZSA9IG1pbl9zaXplOwoJCWlmIChucikKCQkJbWF4X3NpemUgKz0gKG5yIC0gMSkqODsKCQlpZiAoaWR4X3NpemUgPCBtaW5fc2l6ZSB8fCBpZHhfc2l6ZSA+IG1heF9zaXplKSB7CgkJCW11bm1hcChpZHhfbWFwLCBpZHhfc2l6ZSk7CgkJCXJldHVybiBlcnJvcigid3JvbmcgaW5kZXggdjIgZmlsZSBzaXplIGluICVzIiwgcGF0aCk7CgkJfQoJCWlmIChpZHhfc2l6ZSAhPSBtaW5fc2l6ZSAmJgoJCSAgICAvKgoJCSAgICAgKiBtYWtlIHN1cmUgd2UgY2FuIGRlYWwgd2l0aCBsYXJnZSBwYWNrIG9mZnNldHMuCgkJICAgICAqIDMxLWJpdCBzaWduZWQgb2Zmc2V0IHdvbid0IGJlIGVub3VnaCwgbmVpdGhlcgoJCSAgICAgKiAzMi1iaXQgdW5zaWduZWQgb25lIHdpbGwgYmUuCgkJICAgICAqLwoJCSAgICAoc2l6ZW9mKG9mZl90KSA8PSA0KSkgewoJCQltdW5tYXAoaWR4X21hcCwgaWR4X3NpemUpOwoJCQlyZXR1cm4gZXJyb3IoInBhY2sgdG9vIGxhcmdlIGZvciBjdXJyZW50IGRlZmluaXRpb24gb2Ygb2ZmX3QgaW4gJXMiLCBwYXRoKTsKCQl9Cgl9CgoJcC0+aW5kZXhfdmVyc2lvbiA9IHZlcnNpb247CglwLT5pbmRleF9kYXRhID0gaWR4X21hcDsKCXAtPmluZGV4X3NpemUgPSBpZHhfc2l6ZTsKCXAtPm51bV9vYmplY3RzID0gbnI7CglyZXR1cm4gMDsKfQoKaW50IG9wZW5fcGFja19pbmRleChzdHJ1Y3QgcGFja2VkX2dpdCAqcCkKewoJY2hhciAqaWR4X25hbWU7CglpbnQgcmV0OwoKCWlmIChwLT5pbmRleF9kYXRhKQoJCXJldHVybiAwOwoKCWlkeF9uYW1lID0geHN0cmR1cChwLT5wYWNrX25hbWUpOwoJc3RyY3B5KGlkeF9uYW1lICsgc3RybGVuKGlkeF9uYW1lKSAtIHN0cmxlbigiLnBhY2siKSwgIi5pZHgiKTsKCXJldCA9IGNoZWNrX3BhY2tlZF9naXRfaWR4KGlkeF9uYW1lLCBwKTsKCWZyZWUoaWR4X25hbWUpOwoJcmV0dXJuIHJldDsKfQoKc3RhdGljIHZvaWQgc2Nhbl93aW5kb3dzKHN0cnVjdCBwYWNrZWRfZ2l0ICpwLAoJc3RydWN0IHBhY2tlZF9naXQgKipscnVfcCwKCXN0cnVjdCBwYWNrX3dpbmRvdyAqKmxydV93LAoJc3RydWN0IHBhY2tfd2luZG93ICoqbHJ1X2wpCnsKCXN0cnVjdCBwYWNrX3dpbmRvdyAqdywgKndfbDsKCglmb3IgKHdfbCA9IE5VTEwsIHcgPSBwLT53aW5kb3dzOyB3OyB3ID0gdy0+bmV4dCkgewoJCWlmICghdy0+aW51c2VfY250KSB7CgkJCWlmICghKmxydV93IHx8IHctPmxhc3RfdXNlZCA8ICgqbHJ1X3cpLT5sYXN0X3VzZWQpIHsKCQkJCSpscnVfcCA9IHA7CgkJCQkqbHJ1X3cgPSB3OwoJCQkJKmxydV9sID0gd19sOwoJCQl9CgkJfQoJCXdfbCA9IHc7Cgl9Cn0KCnN0YXRpYyBpbnQgdW51c2Vfb25lX3dpbmRvdyhzdHJ1Y3QgcGFja2VkX2dpdCAqY3VycmVudCwgaW50IGtlZXBfZmQpCnsKCXN0cnVjdCBwYWNrZWRfZ2l0ICpwLCAqbHJ1X3AgPSBOVUxMOwoJc3RydWN0IHBhY2tfd2luZG93ICpscnVfdyA9IE5VTEwsICpscnVfbCA9IE5VTEw7CgoJaWYgKGN1cnJlbnQpCgkJc2Nhbl93aW5kb3dzKGN1cnJlbnQsICZscnVfcCwgJmxydV93LCAmbHJ1X2wpOwoJZm9yIChwID0gcGFja2VkX2dpdDsgcDsgcCA9IHAtPm5leHQpCgkJc2Nhbl93aW5kb3dzKHAsICZscnVfcCwgJmxydV93LCAmbHJ1X2wpOwoJaWYgKGxydV9wKSB7CgkJbXVubWFwKGxydV93LT5iYXNlLCBscnVfdy0+bGVuKTsKCQlwYWNrX21hcHBlZCAtPSBscnVfdy0+bGVuOwoJCWlmIChscnVfbCkKCQkJbHJ1X2wtPm5leHQgPSBscnVfdy0+bmV4dDsKCQllbHNlIHsKCQkJbHJ1X3AtPndpbmRvd3MgPSBscnVfdy0+bmV4dDsKCQkJaWYgKCFscnVfcC0+d2luZG93cyAmJiBscnVfcC0+cGFja19mZCAhPSBrZWVwX2ZkKSB7CgkJCQljbG9zZShscnVfcC0+cGFja19mZCk7CgkJCQlscnVfcC0+cGFja19mZCA9IC0xOwoJCQl9CgkJfQoJCWZyZWUobHJ1X3cpOwoJCXBhY2tfb3Blbl93aW5kb3dzLS07CgkJcmV0dXJuIDE7Cgl9CglyZXR1cm4gMDsKfQoKdm9pZCByZWxlYXNlX3BhY2tfbWVtb3J5KHNpemVfdCBuZWVkLCBpbnQgZmQpCnsKCXNpemVfdCBjdXIgPSBwYWNrX21hcHBlZDsKCXdoaWxlIChuZWVkID49IChjdXIgLSBwYWNrX21hcHBlZCkgJiYgdW51c2Vfb25lX3dpbmRvdyhOVUxMLCBmZCkpCgkJOyAvKiBub3RoaW5nICovCn0KCnZvaWQgY2xvc2VfcGFja193aW5kb3dzKHN0cnVjdCBwYWNrZWRfZ2l0ICpwKQp7Cgl3aGlsZSAocC0+d2luZG93cykgewoJCXN0cnVjdCBwYWNrX3dpbmRvdyAqdyA9IHAtPndpbmRvd3M7CgoJCWlmICh3LT5pbnVzZV9jbnQpCgkJCWRpZSgicGFjayAnJXMnIHN0aWxsIGhhcyBvcGVuIHdpbmRvd3MgdG8gaXQiLAoJCQkgICAgcC0+cGFja19uYW1lKTsKCQltdW5tYXAody0+YmFzZSwgdy0+bGVuKTsKCQlwYWNrX21hcHBlZCAtPSB3LT5sZW47CgkJcGFja19vcGVuX3dpbmRvd3MtLTsKCQlwLT53aW5kb3dzID0gdy0+bmV4dDsKCQlmcmVlKHcpOwoJfQp9Cgp2b2lkIHVudXNlX3BhY2soc3RydWN0IHBhY2tfd2luZG93ICoqd19jdXJzb3IpCnsKCXN0cnVjdCBwYWNrX3dpbmRvdyAqdyA9ICp3X2N1cnNvcjsKCWlmICh3KSB7CgkJdy0+aW51c2VfY250LS07CgkJKndfY3Vyc29yID0gTlVMTDsKCX0KfQoKLyoKICogVGhpcyBpcyB1c2VkIGJ5IGdpdC1yZXBhY2sgaW4gY2FzZSBhIG5ld2x5IGNyZWF0ZWQgcGFjayBoYXBwZW5zIHRvCiAqIGNvbnRhaW4gdGhlIHNhbWUgc2V0IG9mIG9iamVjdHMgYXMgYW4gZXhpc3Rpbmcgb25lLiAgSW4gdGhhdCBjYXNlCiAqIHRoZSByZXN1bHRpbmcgZmlsZSBtaWdodCBiZSBkaWZmZXJlbnQgZXZlbiBpZiBpdHMgbmFtZSB3b3VsZCBiZSB0aGUKICogc2FtZS4gIEl0IGlzIGJlc3QgdG8gY2xvc2UgYW55IHJlZmVyZW5jZSB0byB0aGUgb2xkIHBhY2sgYmVmb3JlIGl0IGlzCiAqIHJlcGxhY2VkIG9uIGRpc2suICBPZiBjb3Vyc2Ugbm8gaW5kZXggcG9pbnRlcnMgbm9yIHdpbmRvd3MgZm9yIGdpdmVuIHBhY2sKICogbXVzdCBzdWJzaXN0IGF0IHRoaXMgcG9pbnQuICBJZiBldmVyIG9iamVjdHMgZnJvbSB0aGlzIHBhY2sgYXJlIHJlcXVlc3RlZAogKiBhZ2FpbiwgdGhlIG5ldyB2ZXJzaW9uIG9mIHRoZSBwYWNrIHdpbGwgYmUgcmVpbml0aWFsaXplZCB0aHJvdWdoCiAqIHJlcHJlcGFyZV9wYWNrZWRfZ2l0KCkuCiAqLwp2b2lkIGZyZWVfcGFja19ieV9uYW1lKGNvbnN0IGNoYXIgKnBhY2tfbmFtZSkKewoJc3RydWN0IHBhY2tlZF9naXQgKnAsICoqcHAgPSAmcGFja2VkX2dpdDsKCgl3aGlsZSAoKnBwKSB7CgkJcCA9ICpwcDsKCQlpZiAoc3RyY21wKHBhY2tfbmFtZSwgcC0+cGFja19uYW1lKSA9PSAwKSB7CgkJCWNsZWFyX2RlbHRhX2Jhc2VfY2FjaGUoKTsKCQkJY2xvc2VfcGFja193aW5kb3dzKHApOwoJCQlpZiAocC0+cGFja19mZCAhPSAtMSkKCQkJCWNsb3NlKHAtPnBhY2tfZmQpOwoJCQlpZiAocC0+aW5kZXhfZGF0YSkKCQkJCW11bm1hcCgodm9pZCAqKXAtPmluZGV4X2RhdGEsIHAtPmluZGV4X3NpemUpOwoJCQlmcmVlKHAtPmJhZF9vYmplY3Rfc2hhMSk7CgkJCSpwcCA9IHAtPm5leHQ7CgkJCWZyZWUocCk7CgkJCXJldHVybjsKCQl9CgkJcHAgPSAmcC0+bmV4dDsKCX0KfQoKLyoKICogRG8gbm90IGNhbGwgdGhpcyBkaXJlY3RseSBhcyB0aGlzIGxlYWtzIHAtPnBhY2tfZmQgb24gZXJyb3IgcmV0dXJuOwogKiBjYWxsIG9wZW5fcGFja2VkX2dpdCgpIGluc3RlYWQuCiAqLwpzdGF0aWMgaW50IG9wZW5fcGFja2VkX2dpdF8xKHN0cnVjdCBwYWNrZWRfZ2l0ICpwKQp7CglzdHJ1Y3Qgc3RhdCBzdDsKCXN0cnVjdCBwYWNrX2hlYWRlciBoZHI7Cgl1bnNpZ25lZCBjaGFyIHNoYTFbMjBdOwoJdW5zaWduZWQgY2hhciAqaWR4X3NoYTE7Cglsb25nIGZkX2ZsYWc7CgoJaWYgKCFwLT5pbmRleF9kYXRhICYmIG9wZW5fcGFja19pbmRleChwKSkKCQlyZXR1cm4gZXJyb3IoInBhY2tmaWxlICVzIGluZGV4IHVuYXZhaWxhYmxlIiwgcC0+cGFja19uYW1lKTsKCglwLT5wYWNrX2ZkID0gb3BlbihwLT5wYWNrX25hbWUsIE9fUkRPTkxZKTsKCXdoaWxlIChwLT5wYWNrX2ZkIDwgMCAmJiBlcnJubyA9PSBFTUZJTEUgJiYgdW51c2Vfb25lX3dpbmRvdyhwLCAtMSkpCgkJcC0+cGFja19mZCA9IG9wZW4ocC0+cGFja19uYW1lLCBPX1JET05MWSk7CglpZiAocC0+cGFja19mZCA8IDAgfHwgZnN0YXQocC0+cGFja19mZCwgJnN0KSkKCQlyZXR1cm4gLTE7CgoJLyogSWYgd2UgY3JlYXRlZCB0aGUgc3RydWN0IGJlZm9yZSB3ZSBoYWQgdGhlIHBhY2sgd2UgbGFjayBzaXplLiAqLwoJaWYgKCFwLT5wYWNrX3NpemUpIHsKCQlpZiAoIVNfSVNSRUcoc3Quc3RfbW9kZSkpCgkJCXJldHVybiBlcnJvcigicGFja2ZpbGUgJXMgbm90IGEgcmVndWxhciBmaWxlIiwgcC0+cGFja19uYW1lKTsKCQlwLT5wYWNrX3NpemUgPSBzdC5zdF9zaXplOwoJfSBlbHNlIGlmIChwLT5wYWNrX3NpemUgIT0gc3Quc3Rfc2l6ZSkKCQlyZXR1cm4gZXJyb3IoInBhY2tmaWxlICVzIHNpemUgY2hhbmdlZCIsIHAtPnBhY2tfbmFtZSk7CgoJLyogV2UgbGVhdmUgdGhlc2UgZmlsZSBkZXNjcmlwdG9ycyBvcGVuIHdpdGggc2xpZGluZyBtbWFwOwoJICogdGhlcmUgaXMgbm8gcG9pbnQga2VlcGluZyB0aGVtIG9wZW4gYWNyb3NzIGV4ZWMoKSwgdGhvdWdoLgoJICovCglmZF9mbGFnID0gZmNudGwocC0+cGFja19mZCwgRl9HRVRGRCwgMCk7CglpZiAoZmRfZmxhZyA8IDApCgkJcmV0dXJuIGVycm9yKCJjYW5ub3QgZGV0ZXJtaW5lIGZpbGUgZGVzY3JpcHRvciBmbGFncyIpOwoJZmRfZmxhZyB8PSBGRF9DTE9FWEVDOwoJaWYgKGZjbnRsKHAtPnBhY2tfZmQsIEZfU0VURkQsIGZkX2ZsYWcpID09IC0xKQoJCXJldHVybiBlcnJvcigiY2Fubm90IHNldCBGRF9DTE9FWEVDIik7CgoJLyogVmVyaWZ5IHdlIHJlY29nbml6ZSB0aGlzIHBhY2sgZmlsZSBmb3JtYXQuICovCglpZiAocmVhZF9pbl9mdWxsKHAtPnBhY2tfZmQsICZoZHIsIHNpemVvZihoZHIpKSAhPSBzaXplb2YoaGRyKSkKCQlyZXR1cm4gZXJyb3IoImZpbGUgJXMgaXMgZmFyIHRvbyBzaG9ydCB0byBiZSBhIHBhY2tmaWxlIiwgcC0+cGFja19uYW1lKTsKCWlmIChoZHIuaGRyX3NpZ25hdHVyZSAhPSBodG9ubChQQUNLX1NJR05BVFVSRSkpCgkJcmV0dXJuIGVycm9yKCJmaWxlICVzIGlzIG5vdCBhIEdJVCBwYWNrZmlsZSIsIHAtPnBhY2tfbmFtZSk7CglpZiAoIXBhY2tfdmVyc2lvbl9vayhoZHIuaGRyX3ZlcnNpb24pKQoJCXJldHVybiBlcnJvcigicGFja2ZpbGUgJXMgaXMgdmVyc2lvbiAlIlBSSXUzMiIgYW5kIG5vdCIKCQkJIiBzdXBwb3J0ZWQgKHRyeSB1cGdyYWRpbmcgR0lUIHRvIGEgbmV3ZXIgdmVyc2lvbikiLAoJCQlwLT5wYWNrX25hbWUsIG50b2hsKGhkci5oZHJfdmVyc2lvbikpOwoKCS8qIFZlcmlmeSB0aGUgcGFjayBtYXRjaGVzIGl0cyBpbmRleC4gKi8KCWlmIChwLT5udW1fb2JqZWN0cyAhPSBudG9obChoZHIuaGRyX2VudHJpZXMpKQoJCXJldHVybiBlcnJvcigicGFja2ZpbGUgJXMgY2xhaW1zIHRvIGhhdmUgJSJQUkl1MzIiIG9iamVjdHMiCgkJCSAgICAgIiB3aGlsZSBpbmRleCBpbmRpY2F0ZXMgJSJQUkl1MzIiIG9iamVjdHMiLAoJCQkgICAgIHAtPnBhY2tfbmFtZSwgbnRvaGwoaGRyLmhkcl9lbnRyaWVzKSwKCQkJICAgICBwLT5udW1fb2JqZWN0cyk7CglpZiAobHNlZWsocC0+cGFja19mZCwgcC0+cGFja19zaXplIC0gc2l6ZW9mKHNoYTEpLCBTRUVLX1NFVCkgPT0gLTEpCgkJcmV0dXJuIGVycm9yKCJlbmQgb2YgcGFja2ZpbGUgJXMgaXMgdW5hdmFpbGFibGUiLCBwLT5wYWNrX25hbWUpOwoJaWYgKHJlYWRfaW5fZnVsbChwLT5wYWNrX2ZkLCBzaGExLCBzaXplb2Yoc2hhMSkpICE9IHNpemVvZihzaGExKSkKCQlyZXR1cm4gZXJyb3IoInBhY2tmaWxlICVzIHNpZ25hdHVyZSBpcyB1bmF2YWlsYWJsZSIsIHAtPnBhY2tfbmFtZSk7CglpZHhfc2hhMSA9ICgodW5zaWduZWQgY2hhciAqKXAtPmluZGV4X2RhdGEpICsgcC0+aW5kZXhfc2l6ZSAtIDQwOwoJaWYgKGhhc2hjbXAoc2hhMSwgaWR4X3NoYTEpKQoJCXJldHVybiBlcnJvcigicGFja2ZpbGUgJXMgZG9lcyBub3QgbWF0Y2ggaW5kZXgiLCBwLT5wYWNrX25hbWUpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgb3Blbl9wYWNrZWRfZ2l0KHN0cnVjdCBwYWNrZWRfZ2l0ICpwKQp7CglpZiAoIW9wZW5fcGFja2VkX2dpdF8xKHApKQoJCXJldHVybiAwOwoJaWYgKHAtPnBhY2tfZmQgIT0gLTEpIHsKCQljbG9zZShwLT5wYWNrX2ZkKTsKCQlwLT5wYWNrX2ZkID0gLTE7Cgl9CglyZXR1cm4gLTE7Cn0KCnN0YXRpYyBpbnQgaW5fd2luZG93KHN0cnVjdCBwYWNrX3dpbmRvdyAqd2luLCBvZmZfdCBvZmZzZXQpCnsKCS8qIFdlIG11c3QgcHJvbWlzZSBhdCBsZWFzdCAyMCBieXRlcyAob25lIGhhc2gpIGFmdGVyIHRoZQoJICogb2Zmc2V0IGlzIGF2YWlsYWJsZSBmcm9tIHRoaXMgd2luZG93LCBvdGhlcndpc2UgdGhlIG9mZnNldAoJICogaXMgbm90IGFjdHVhbGx5IGluIHRoaXMgd2luZG93IGFuZCBhIGRpZmZlcmVudCB3aW5kb3cgKHdoaWNoCgkgKiBoYXMgdGhhdCBvbmUgaGFzaCBleGNlc3MpIG11c3QgYmUgdXNlZC4gIFRoaXMgaXMgdG8gc3VwcG9ydAoJICogdGhlIG9iamVjdCBoZWFkZXIgYW5kIGRlbHRhIGJhc2UgcGFyc2luZyByb3V0aW5lcyBiZWxvdy4KCSAqLwoJb2ZmX3Qgd2luX29mZiA9IHdpbi0+b2Zmc2V0OwoJcmV0dXJuIHdpbl9vZmYgPD0gb2Zmc2V0CgkJJiYgKG9mZnNldCArIDIwKSA8PSAod2luX29mZiArIHdpbi0+bGVuKTsKfQoKdW5zaWduZWQgY2hhciAqdXNlX3BhY2soc3RydWN0IHBhY2tlZF9naXQgKnAsCgkJc3RydWN0IHBhY2tfd2luZG93ICoqd19jdXJzb3IsCgkJb2ZmX3Qgb2Zmc2V0LAoJCXVuc2lnbmVkIGludCAqbGVmdCkKewoJc3RydWN0IHBhY2tfd2luZG93ICp3aW4gPSAqd19jdXJzb3I7CgoJaWYgKHAtPnBhY2tfZmQgPT0gLTEgJiYgb3Blbl9wYWNrZWRfZ2l0KHApKQoJCWRpZSgicGFja2ZpbGUgJXMgY2Fubm90IGJlIGFjY2Vzc2VkIiwgcC0+cGFja19uYW1lKTsKCgkvKiBTaW5jZSBwYWNrZmlsZXMgZW5kIGluIGEgaGFzaCBvZiB0aGVpciBjb250ZW50IGFuZCBpdCdzCgkgKiBwb2ludGxlc3MgdG8gYXNrIGZvciBhbiBvZmZzZXQgaW50byB0aGUgbWlkZGxlIG9mIHRoYXQKCSAqIGhhc2gsIGFuZCB0aGUgaW5fd2luZG93IGZ1bmN0aW9uIGFib3ZlIHdvdWxkbid0IG1hdGNoCgkgKiBkb24ndCBhbGxvdyBhbiBvZmZzZXQgdG9vIGNsb3NlIHRvIHRoZSBlbmQgb2YgdGhlIGZpbGUuCgkgKi8KCWlmIChvZmZzZXQgPiAocC0+cGFja19zaXplIC0gMjApKQoJCWRpZSgib2Zmc2V0IGJleW9uZCBlbmQgb2YgcGFja2ZpbGUgKHRydW5jYXRlZCBwYWNrPykiKTsKCglpZiAoIXdpbiB8fCAhaW5fd2luZG93KHdpbiwgb2Zmc2V0KSkgewoJCWlmICh3aW4pCgkJCXdpbi0+aW51c2VfY250LS07CgkJZm9yICh3aW4gPSBwLT53aW5kb3dzOyB3aW47IHdpbiA9IHdpbi0+bmV4dCkgewoJCQlpZiAoaW5fd2luZG93KHdpbiwgb2Zmc2V0KSkKCQkJCWJyZWFrOwoJCX0KCQlpZiAoIXdpbikgewoJCQlzaXplX3Qgd2luZG93X2FsaWduID0gcGFja2VkX2dpdF93aW5kb3dfc2l6ZSAvIDI7CgkJCW9mZl90IGxlbjsKCQkJd2luID0geGNhbGxvYygxLCBzaXplb2YoKndpbikpOwoJCQl3aW4tPm9mZnNldCA9IChvZmZzZXQgLyB3aW5kb3dfYWxpZ24pICogd2luZG93X2FsaWduOwoJCQlsZW4gPSBwLT5wYWNrX3NpemUgLSB3aW4tPm9mZnNldDsKCQkJaWYgKGxlbiA+IHBhY2tlZF9naXRfd2luZG93X3NpemUpCgkJCQlsZW4gPSBwYWNrZWRfZ2l0X3dpbmRvd19zaXplOwoJCQl3aW4tPmxlbiA9IChzaXplX3QpbGVuOwoJCQlwYWNrX21hcHBlZCArPSB3aW4tPmxlbjsKCQkJd2hpbGUgKHBhY2tlZF9naXRfbGltaXQgPCBwYWNrX21hcHBlZAoJCQkJJiYgdW51c2Vfb25lX3dpbmRvdyhwLCBwLT5wYWNrX2ZkKSkKCQkJCTsgLyogbm90aGluZyAqLwoJCQl3aW4tPmJhc2UgPSB4bW1hcChOVUxMLCB3aW4tPmxlbiwKCQkJCVBST1RfUkVBRCwgTUFQX1BSSVZBVEUsCgkJCQlwLT5wYWNrX2ZkLCB3aW4tPm9mZnNldCk7CgkJCWlmICh3aW4tPmJhc2UgPT0gTUFQX0ZBSUxFRCkKCQkJCWRpZSgicGFja2ZpbGUgJXMgY2Fubm90IGJlIG1hcHBlZDogJXMiLAoJCQkJCXAtPnBhY2tfbmFtZSwKCQkJCQlzdHJlcnJvcihlcnJubykpOwoJCQlwYWNrX21tYXBfY2FsbHMrKzsKCQkJcGFja19vcGVuX3dpbmRvd3MrKzsKCQkJaWYgKHBhY2tfbWFwcGVkID4gcGVha19wYWNrX21hcHBlZCkKCQkJCXBlYWtfcGFja19tYXBwZWQgPSBwYWNrX21hcHBlZDsKCQkJaWYgKHBhY2tfb3Blbl93aW5kb3dzID4gcGVha19wYWNrX29wZW5fd2luZG93cykKCQkJCXBlYWtfcGFja19vcGVuX3dpbmRvd3MgPSBwYWNrX29wZW5fd2luZG93czsKCQkJd2luLT5uZXh0ID0gcC0+d2luZG93czsKCQkJcC0+d2luZG93cyA9IHdpbjsKCQl9Cgl9CglpZiAod2luICE9ICp3X2N1cnNvcikgewoJCXdpbi0+bGFzdF91c2VkID0gcGFja191c2VkX2N0cisrOwoJCXdpbi0+aW51c2VfY250Kys7CgkJKndfY3Vyc29yID0gd2luOwoJfQoJb2Zmc2V0IC09IHdpbi0+b2Zmc2V0OwoJaWYgKGxlZnQpCgkJKmxlZnQgPSB3aW4tPmxlbiAtIHhzaXplX3Qob2Zmc2V0KTsKCXJldHVybiB3aW4tPmJhc2UgKyBvZmZzZXQ7Cn0KCnN0YXRpYyBzdHJ1Y3QgcGFja2VkX2dpdCAqYWxsb2NfcGFja2VkX2dpdChpbnQgZXh0cmEpCnsKCXN0cnVjdCBwYWNrZWRfZ2l0ICpwID0geG1hbGxvYyhzaXplb2YoKnApICsgZXh0cmEpOwoJbWVtc2V0KHAsIDAsIHNpemVvZigqcCkpOwoJcC0+cGFja19mZCA9IC0xOwoJcmV0dXJuIHA7Cn0KCnN0cnVjdCBwYWNrZWRfZ2l0ICphZGRfcGFja2VkX2dpdChjb25zdCBjaGFyICpwYXRoLCBpbnQgcGF0aF9sZW4sIGludCBsb2NhbCkKewoJc3RydWN0IHN0YXQgc3Q7CglzdHJ1Y3QgcGFja2VkX2dpdCAqcCA9IGFsbG9jX3BhY2tlZF9naXQocGF0aF9sZW4gKyAyKTsKCgkvKgoJICogTWFrZSBzdXJlIGEgY29ycmVzcG9uZGluZyAucGFjayBmaWxlIGV4aXN0cyBhbmQgdGhhdAoJICogdGhlIGluZGV4IGxvb2tzIHNhbmUuCgkgKi8KCXBhdGhfbGVuIC09IHN0cmxlbigiLmlkeCIpOwoJaWYgKHBhdGhfbGVuIDwgMSkgewoJCWZyZWUocCk7CgkJcmV0dXJuIE5VTEw7Cgl9CgltZW1jcHkocC0+cGFja19uYW1lLCBwYXRoLCBwYXRoX2xlbik7CgoJc3RyY3B5KHAtPnBhY2tfbmFtZSArIHBhdGhfbGVuLCAiLmtlZXAiKTsKCWlmICghYWNjZXNzKHAtPnBhY2tfbmFtZSwgRl9PSykpCgkJcC0+cGFja19rZWVwID0gMTsKCglzdHJjcHkocC0+cGFja19uYW1lICsgcGF0aF9sZW4sICIucGFjayIpOwoJaWYgKHN0YXQocC0+cGFja19uYW1lLCAmc3QpIHx8ICFTX0lTUkVHKHN0LnN0X21vZGUpKSB7CgkJZnJlZShwKTsKCQlyZXR1cm4gTlVMTDsKCX0KCgkvKiBvaywgaXQgbG9va3Mgc2FuZSBhcyBmYXIgYXMgd2UgY2FuIGNoZWNrIHdpdGhvdXQKCSAqIGFjdHVhbGx5IG1hcHBpbmcgdGhlIHBhY2sgZmlsZS4KCSAqLwoJcC0+cGFja19zaXplID0gc3Quc3Rfc2l6ZTsKCXAtPnBhY2tfbG9jYWwgPSBsb2NhbDsKCXAtPm10aW1lID0gc3Quc3RfbXRpbWU7CglpZiAocGF0aF9sZW4gPCA0MCB8fCBnZXRfc2hhMV9oZXgocGF0aCArIHBhdGhfbGVuIC0gNDAsIHAtPnNoYTEpKQoJCWhhc2hjbHIocC0+c2hhMSk7CglyZXR1cm4gcDsKfQoKc3RydWN0IHBhY2tlZF9naXQgKnBhcnNlX3BhY2tfaW5kZXgodW5zaWduZWQgY2hhciAqc2hhMSkKewoJY29uc3QgY2hhciAqaWR4X3BhdGggPSBzaGExX3BhY2tfaW5kZXhfbmFtZShzaGExKTsKCWNvbnN0IGNoYXIgKnBhdGggPSBzaGExX3BhY2tfbmFtZShzaGExKTsKCXN0cnVjdCBwYWNrZWRfZ2l0ICpwID0gYWxsb2NfcGFja2VkX2dpdChzdHJsZW4ocGF0aCkgKyAxKTsKCglzdHJjcHkocC0+cGFja19uYW1lLCBwYXRoKTsKCWhhc2hjcHkocC0+c2hhMSwgc2hhMSk7CglpZiAoY2hlY2tfcGFja2VkX2dpdF9pZHgoaWR4X3BhdGgsIHApKSB7CgkJZnJlZShwKTsKCQlyZXR1cm4gTlVMTDsKCX0KCglyZXR1cm4gcDsKfQoKdm9pZCBpbnN0YWxsX3BhY2tlZF9naXQoc3RydWN0IHBhY2tlZF9naXQgKnBhY2spCnsKCXBhY2stPm5leHQgPSBwYWNrZWRfZ2l0OwoJcGFja2VkX2dpdCA9IHBhY2s7Cn0KCnN0YXRpYyB2b2lkIHByZXBhcmVfcGFja2VkX2dpdF9vbmUoY2hhciAqb2JqZGlyLCBpbnQgbG9jYWwpCnsKCS8qIEVuc3VyZSB0aGF0IHRoaXMgYnVmZmVyIGlzIGxhcmdlIGVub3VnaCBzbyB0aGF0IHdlIGNhbgoJICAgYXBwZW5kICIvcGFjay8iIHdpdGhvdXQgY2xvYmJlcmluZyB0aGUgc3RhY2sgZXZlbiBpZgoJICAgc3RybGVuKG9iamRpcikgd2VyZSBQQVRIX01BWC4gICovCgljaGFyIHBhdGhbUEFUSF9NQVggKyAxICsgNCArIDEgKyAxXTsKCWludCBsZW47CglESVIgKmRpcjsKCXN0cnVjdCBkaXJlbnQgKmRlOwoKCXNwcmludGYocGF0aCwgIiVzL3BhY2siLCBvYmpkaXIpOwoJbGVuID0gc3RybGVuKHBhdGgpOwoJZGlyID0gb3BlbmRpcihwYXRoKTsKCXdoaWxlICghZGlyICYmIGVycm5vID09IEVNRklMRSAmJiB1bnVzZV9vbmVfd2luZG93KHBhY2tlZF9naXQsIC0xKSkKCQlkaXIgPSBvcGVuZGlyKHBhdGgpOwoJaWYgKCFkaXIpIHsKCQlpZiAoZXJybm8gIT0gRU5PRU5UKQoJCQllcnJvcigidW5hYmxlIHRvIG9wZW4gb2JqZWN0IHBhY2sgZGlyZWN0b3J5OiAlczogJXMiLAoJCQkgICAgICBwYXRoLCBzdHJlcnJvcihlcnJubykpOwoJCXJldHVybjsKCX0KCXBhdGhbbGVuKytdID0gJy8nOwoJd2hpbGUgKChkZSA9IHJlYWRkaXIoZGlyKSkgIT0gTlVMTCkgewoJCWludCBuYW1lbGVuID0gc3RybGVuKGRlLT5kX25hbWUpOwoJCXN0cnVjdCBwYWNrZWRfZ2l0ICpwOwoKCQlpZiAoIWhhc19leHRlbnNpb24oZGUtPmRfbmFtZSwgIi5pZHgiKSkKCQkJY29udGludWU7CgoJCWlmIChsZW4gKyBuYW1lbGVuICsgMSA+IHNpemVvZihwYXRoKSkKCQkJY29udGludWU7CgoJCS8qIERvbid0IHJlb3BlbiBhIHBhY2sgd2UgYWxyZWFkeSBoYXZlLiAqLwoJCXN0cmNweShwYXRoICsgbGVuLCBkZS0+ZF9uYW1lKTsKCQlmb3IgKHAgPSBwYWNrZWRfZ2l0OyBwOyBwID0gcC0+bmV4dCkgewoJCQlpZiAoIW1lbWNtcChwYXRoLCBwLT5wYWNrX25hbWUsIGxlbiArIG5hbWVsZW4gLSA0KSkKCQkJCWJyZWFrOwoJCX0KCQlpZiAocCkKCQkJY29udGludWU7CgkJLyogU2VlIGlmIGl0IHJlYWxseSBpcyBhIHZhbGlkIC5pZHggZmlsZSB3aXRoIGNvcnJlc3BvbmRpbmcKCQkgKiAucGFjayBmaWxlIHRoYXQgd2UgY2FuIG1hcC4KCQkgKi8KCQlwID0gYWRkX3BhY2tlZF9naXQocGF0aCwgbGVuICsgbmFtZWxlbiwgbG9jYWwpOwoJCWlmICghcCkKCQkJY29udGludWU7CgkJaW5zdGFsbF9wYWNrZWRfZ2l0KHApOwoJfQoJY2xvc2VkaXIoZGlyKTsKfQoKc3RhdGljIGludCBzb3J0X3BhY2soY29uc3Qgdm9pZCAqYV8sIGNvbnN0IHZvaWQgKmJfKQp7CglzdHJ1Y3QgcGFja2VkX2dpdCAqYSA9ICooKHN0cnVjdCBwYWNrZWRfZ2l0ICoqKWFfKTsKCXN0cnVjdCBwYWNrZWRfZ2l0ICpiID0gKigoc3RydWN0IHBhY2tlZF9naXQgKiopYl8pOwoJaW50IHN0OwoKCS8qCgkgKiBMb2NhbCBwYWNrcyB0ZW5kIHRvIGNvbnRhaW4gb2JqZWN0cyBzcGVjaWZpYyB0byBvdXIKCSAqIHZhcmlhbnQgb2YgdGhlIHByb2plY3QgdGhhbiByZW1vdGUgb25lcy4gIEluIGFkZGl0aW9uLAoJICogcmVtb3RlIG9uZXMgY291bGQgYmUgb24gYSBuZXR3b3JrIG1vdW50ZWQgZmlsZXN5c3RlbS4KCSAqIEZhdm9yIGxvY2FsIG9uZXMgZm9yIHRoZXNlIHJlYXNvbnMuCgkgKi8KCXN0ID0gYS0+cGFja19sb2NhbCAtIGItPnBhY2tfbG9jYWw7CglpZiAoc3QpCgkJcmV0dXJuIC1zdDsKCgkvKgoJICogWW91bmdlciBwYWNrcyB0ZW5kIHRvIGNvbnRhaW4gbW9yZSByZWNlbnQgb2JqZWN0cywKCSAqIGFuZCBtb3JlIHJlY2VudCBvYmplY3RzIHRlbmQgdG8gZ2V0IGFjY2Vzc2VkIG1vcmUKCSAqIG9mdGVuLgoJICovCglpZiAoYS0+bXRpbWUgPCBiLT5tdGltZSkKCQlyZXR1cm4gMTsKCWVsc2UgaWYgKGEtPm10aW1lID09IGItPm10aW1lKQoJCXJldHVybiAwOwoJcmV0dXJuIC0xOwp9CgpzdGF0aWMgdm9pZCByZWFycmFuZ2VfcGFja2VkX2dpdCh2b2lkKQp7CglzdHJ1Y3QgcGFja2VkX2dpdCAqKmFyeSwgKnA7CglpbnQgaSwgbjsKCglmb3IgKG4gPSAwLCBwID0gcGFja2VkX2dpdDsgcDsgcCA9IHAtPm5leHQpCgkJbisrOwoJaWYgKG4gPCAyKQoJCXJldHVybjsKCgkvKiBwcmVwYXJlIGFuIGFycmF5IG9mIHBhY2tlZF9naXQgZm9yIGVhc2llciBzb3J0aW5nICovCglhcnkgPSB4Y2FsbG9jKG4sIHNpemVvZihzdHJ1Y3QgcGFja2VkX2dpdCAqKSk7Cglmb3IgKG4gPSAwLCBwID0gcGFja2VkX2dpdDsgcDsgcCA9IHAtPm5leHQpCgkJYXJ5W24rK10gPSBwOwoKCXFzb3J0KGFyeSwgbiwgc2l6ZW9mKHN0cnVjdCBwYWNrZWRfZ2l0ICopLCBzb3J0X3BhY2spOwoKCS8qIGxpbmsgdGhlbSBiYWNrIGFnYWluICovCglmb3IgKGkgPSAwOyBpIDwgbiAtIDE7IGkrKykKCQlhcnlbaV0tPm5leHQgPSBhcnlbaSArIDFdOwoJYXJ5W24gLSAxXS0+bmV4dCA9IE5VTEw7CglwYWNrZWRfZ2l0ID0gYXJ5WzBdOwoKCWZyZWUoYXJ5KTsKfQoKc3RhdGljIGludCBwcmVwYXJlX3BhY2tlZF9naXRfcnVuX29uY2UgPSAwOwp2b2lkIHByZXBhcmVfcGFja2VkX2dpdCh2b2lkKQp7CglzdHJ1Y3QgYWx0ZXJuYXRlX29iamVjdF9kYXRhYmFzZSAqYWx0OwoKCWlmIChwcmVwYXJlX3BhY2tlZF9naXRfcnVuX29uY2UpCgkJcmV0dXJuOwoJcHJlcGFyZV9wYWNrZWRfZ2l0X29uZShnZXRfb2JqZWN0X2RpcmVjdG9yeSgpLCAxKTsKCXByZXBhcmVfYWx0X29kYigpOwoJZm9yIChhbHQgPSBhbHRfb2RiX2xpc3Q7IGFsdDsgYWx0ID0gYWx0LT5uZXh0KSB7CgkJYWx0LT5uYW1lWy0xXSA9IDA7CgkJcHJlcGFyZV9wYWNrZWRfZ2l0X29uZShhbHQtPmJhc2UsIDApOwoJCWFsdC0+bmFtZVstMV0gPSAnLyc7Cgl9CglyZWFycmFuZ2VfcGFja2VkX2dpdCgpOwoJcHJlcGFyZV9wYWNrZWRfZ2l0X3J1bl9vbmNlID0gMTsKfQoKdm9pZCByZXByZXBhcmVfcGFja2VkX2dpdCh2b2lkKQp7CglkaXNjYXJkX3JldmluZGV4KCk7CglwcmVwYXJlX3BhY2tlZF9naXRfcnVuX29uY2UgPSAwOwoJcHJlcGFyZV9wYWNrZWRfZ2l0KCk7Cn0KCnN0YXRpYyB2b2lkIG1hcmtfYmFkX3BhY2tlZF9vYmplY3Qoc3RydWN0IHBhY2tlZF9naXQgKnAsCgkJCQkgICBjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExKQp7Cgl1bnNpZ25lZCBpOwoJZm9yIChpID0gMDsgaSA8IHAtPm51bV9iYWRfb2JqZWN0czsgaSsrKQoJCWlmICghaGFzaGNtcChzaGExLCBwLT5iYWRfb2JqZWN0X3NoYTEgKyAyMCAqIGkpKQoJCQlyZXR1cm47CglwLT5iYWRfb2JqZWN0X3NoYTEgPSB4cmVhbGxvYyhwLT5iYWRfb2JqZWN0X3NoYTEsIDIwICogKHAtPm51bV9iYWRfb2JqZWN0cyArIDEpKTsKCWhhc2hjcHkocC0+YmFkX29iamVjdF9zaGExICsgMjAgKiBwLT5udW1fYmFkX29iamVjdHMsIHNoYTEpOwoJcC0+bnVtX2JhZF9vYmplY3RzKys7Cn0KCnN0YXRpYyBpbnQgaGFzX3BhY2tlZF9hbmRfYmFkKGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEpCnsKCXN0cnVjdCBwYWNrZWRfZ2l0ICpwOwoJdW5zaWduZWQgaTsKCglmb3IgKHAgPSBwYWNrZWRfZ2l0OyBwOyBwID0gcC0+bmV4dCkKCQlmb3IgKGkgPSAwOyBpIDwgcC0+bnVtX2JhZF9vYmplY3RzOyBpKyspCgkJCWlmICghaGFzaGNtcChzaGExLCBwLT5iYWRfb2JqZWN0X3NoYTEgKyAyMCAqIGkpKQoJCQkJcmV0dXJuIDE7CglyZXR1cm4gMDsKfQoKaW50IGNoZWNrX3NoYTFfc2lnbmF0dXJlKGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEsIHZvaWQgKm1hcCwgdW5zaWduZWQgbG9uZyBzaXplLCBjb25zdCBjaGFyICp0eXBlKQp7Cgl1bnNpZ25lZCBjaGFyIHJlYWxfc2hhMVsyMF07CgloYXNoX3NoYTFfZmlsZShtYXAsIHNpemUsIHR5cGUsIHJlYWxfc2hhMSk7CglyZXR1cm4gaGFzaGNtcChzaGExLCByZWFsX3NoYTEpID8gLTEgOiAwOwp9CgpzdGF0aWMgaW50IGdpdF9vcGVuX25vYXRpbWUoY29uc3QgY2hhciAqbmFtZSkKewoJc3RhdGljIGludCBzaGExX2ZpbGVfb3Blbl9mbGFnID0gT19OT0FUSU1FOwoJaW50IGZkID0gb3BlbihuYW1lLCBPX1JET05MWSB8IHNoYTFfZmlsZV9vcGVuX2ZsYWcpOwoKCS8qIE1pZ2h0IHRoZSBmYWlsdXJlIGJlIGR1ZSB0byBPX05PQVRJTUU/ICovCglpZiAoZmQgPCAwICYmIGVycm5vICE9IEVOT0VOVCAmJiBzaGExX2ZpbGVfb3Blbl9mbGFnKSB7CgkJZmQgPSBvcGVuKG5hbWUsIE9fUkRPTkxZKTsKCQlpZiAoZmQgPj0gMCkKCQkJc2hhMV9maWxlX29wZW5fZmxhZyA9IDA7Cgl9CglyZXR1cm4gZmQ7Cn0KCnN0YXRpYyBpbnQgb3Blbl9zaGExX2ZpbGUoY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSkKewoJaW50IGZkOwoJY2hhciAqbmFtZSA9IHNoYTFfZmlsZV9uYW1lKHNoYTEpOwoJc3RydWN0IGFsdGVybmF0ZV9vYmplY3RfZGF0YWJhc2UgKmFsdDsKCglmZCA9IGdpdF9vcGVuX25vYXRpbWUobmFtZSk7CglpZiAoZmQgPj0gMCkKCQlyZXR1cm4gZmQ7CgoJcHJlcGFyZV9hbHRfb2RiKCk7CgllcnJubyA9IEVOT0VOVDsKCWZvciAoYWx0ID0gYWx0X29kYl9saXN0OyBhbHQ7IGFsdCA9IGFsdC0+bmV4dCkgewoJCW5hbWUgPSBhbHQtPm5hbWU7CgkJZmlsbF9zaGExX3BhdGgobmFtZSwgc2hhMSk7CgkJZmQgPSBnaXRfb3Blbl9ub2F0aW1lKGFsdC0+YmFzZSk7CgkJaWYgKGZkID49IDApCgkJCXJldHVybiBmZDsKCX0KCXJldHVybiAtMTsKfQoKc3RhdGljIHZvaWQgKm1hcF9zaGExX2ZpbGUoY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwgdW5zaWduZWQgbG9uZyAqc2l6ZSkKewoJdm9pZCAqbWFwOwoJaW50IGZkOwoKCWZkID0gb3Blbl9zaGExX2ZpbGUoc2hhMSk7CgltYXAgPSBOVUxMOwoJaWYgKGZkID49IDApIHsKCQlzdHJ1Y3Qgc3RhdCBzdDsKCgkJaWYgKCFmc3RhdChmZCwgJnN0KSkgewoJCQkqc2l6ZSA9IHhzaXplX3Qoc3Quc3Rfc2l6ZSk7CgkJCW1hcCA9IHhtbWFwKE5VTEwsICpzaXplLCBQUk9UX1JFQUQsIE1BUF9QUklWQVRFLCBmZCwgMCk7CgkJfQoJCWNsb3NlKGZkKTsKCX0KCXJldHVybiBtYXA7Cn0KCnN0YXRpYyBpbnQgbGVnYWN5X2xvb3NlX29iamVjdCh1bnNpZ25lZCBjaGFyICptYXApCnsKCXVuc2lnbmVkIGludCB3b3JkOwoKCS8qCgkgKiBJcyBpdCBhIHpsaWItY29tcHJlc3NlZCBidWZmZXI/IElmIHNvLCB0aGUgZmlyc3QgYnl0ZQoJICogbXVzdCBiZSAweDc4ICgxNS1iaXQgd2luZG93IHNpemUsIGRlZmxhdGVkKSwgYW5kIHRoZQoJICogZmlyc3QgMTYtYml0IHdvcmQgaXMgZXZlbmx5IGRpdmlzaWJsZSBieSAzMQoJICovCgl3b3JkID0gKG1hcFswXSA8PCA4KSArIG1hcFsxXTsKCWlmIChtYXBbMF0gPT0gMHg3OCAmJiAhKHdvcmQgJSAzMSkpCgkJcmV0dXJuIDE7CgllbHNlCgkJcmV0dXJuIDA7Cn0KCnVuc2lnbmVkIGxvbmcgdW5wYWNrX29iamVjdF9oZWFkZXJfYnVmZmVyKGNvbnN0IHVuc2lnbmVkIGNoYXIgKmJ1ZiwKCQl1bnNpZ25lZCBsb25nIGxlbiwgZW51bSBvYmplY3RfdHlwZSAqdHlwZSwgdW5zaWduZWQgbG9uZyAqc2l6ZXApCnsKCXVuc2lnbmVkIHNoaWZ0OwoJdW5zaWduZWQgbG9uZyBzaXplLCBjOwoJdW5zaWduZWQgbG9uZyB1c2VkID0gMDsKCgljID0gYnVmW3VzZWQrK107CgkqdHlwZSA9IChjID4+IDQpICYgNzsKCXNpemUgPSBjICYgMTU7CglzaGlmdCA9IDQ7Cgl3aGlsZSAoYyAmIDB4ODApIHsKCQlpZiAobGVuIDw9IHVzZWQgfHwgYml0c2l6ZW9mKGxvbmcpIDw9IHNoaWZ0KSB7CgkJCWVycm9yKCJiYWQgb2JqZWN0IGhlYWRlciIpOwoJCQlyZXR1cm4gMDsKCQl9CgkJYyA9IGJ1Zlt1c2VkKytdOwoJCXNpemUgKz0gKGMgJiAweDdmKSA8PCBzaGlmdDsKCQlzaGlmdCArPSA3OwoJfQoJKnNpemVwID0gc2l6ZTsKCXJldHVybiB1c2VkOwp9CgpzdGF0aWMgaW50IHVucGFja19zaGExX2hlYWRlcih6X3N0cmVhbSAqc3RyZWFtLCB1bnNpZ25lZCBjaGFyICptYXAsIHVuc2lnbmVkIGxvbmcgbWFwc2l6ZSwgdm9pZCAqYnVmZmVyLCB1bnNpZ25lZCBsb25nIGJ1ZnNpeikKewoJdW5zaWduZWQgbG9uZyBzaXplLCB1c2VkOwoJc3RhdGljIGNvbnN0IGNoYXIgdmFsaWRfbG9vc2Vfb2JqZWN0X3R5cGVbOF0gPSB7CgkJMCwgLyogT0JKX0VYVCAqLwoJCTEsIDEsIDEsIDEsIC8qICJjb21taXQiLCAidHJlZSIsICJibG9iIiwgInRhZyIgKi8KCQkwLCAvKiAiZGVsdGEiIGFuZCBvdGhlcnMgYXJlIGludmFsaWQgaW4gYSBsb29zZSBvYmplY3QgKi8KCX07CgllbnVtIG9iamVjdF90eXBlIHR5cGU7CgoJLyogR2V0IHRoZSBkYXRhIHN0cmVhbSAqLwoJbWVtc2V0KHN0cmVhbSwgMCwgc2l6ZW9mKCpzdHJlYW0pKTsKCXN0cmVhbS0+bmV4dF9pbiA9IG1hcDsKCXN0cmVhbS0+YXZhaWxfaW4gPSBtYXBzaXplOwoJc3RyZWFtLT5uZXh0X291dCA9IGJ1ZmZlcjsKCXN0cmVhbS0+YXZhaWxfb3V0ID0gYnVmc2l6OwoKCWlmIChsZWdhY3lfbG9vc2Vfb2JqZWN0KG1hcCkpIHsKCQlnaXRfaW5mbGF0ZV9pbml0KHN0cmVhbSk7CgkJcmV0dXJuIGdpdF9pbmZsYXRlKHN0cmVhbSwgMCk7Cgl9CgoKCS8qCgkgKiBUaGVyZSB1c2VkIHRvIGJlIGEgc2Vjb25kIGxvb3NlIG9iamVjdCBoZWFkZXIgZm9ybWF0IHdoaWNoCgkgKiB3YXMgbWVhbnQgdG8gbWltaWMgdGhlIGluLXBhY2sgZm9ybWF0LCBhbGxvd2luZyBmb3IgZGlyZWN0CgkgKiBjb3B5IG9mIHRoZSBvYmplY3QgZGF0YS4gIFRoaXMgZm9ybWF0IHR1cm5lZCB1cCBub3QgdG8gYmUKCSAqIHJlYWxseSB3b3J0aCBpdCBhbmQgd2UgZG9uJ3Qgd3JpdGUgaXQgYW55IGxvbmdlci4gIEJ1dCB3ZQoJICogY2FuIHN0aWxsIHJlYWQgaXQuCgkgKi8KCXVzZWQgPSB1bnBhY2tfb2JqZWN0X2hlYWRlcl9idWZmZXIobWFwLCBtYXBzaXplLCAmdHlwZSwgJnNpemUpOwoJaWYgKCF1c2VkIHx8ICF2YWxpZF9sb29zZV9vYmplY3RfdHlwZVt0eXBlXSkKCQlyZXR1cm4gLTE7CgltYXAgKz0gdXNlZDsKCW1hcHNpemUgLT0gdXNlZDsKCgkvKiBTZXQgdXAgdGhlIHN0cmVhbSBmb3IgdGhlIHJlc3QuLiAqLwoJc3RyZWFtLT5uZXh0X2luID0gbWFwOwoJc3RyZWFtLT5hdmFpbF9pbiA9IG1hcHNpemU7CglnaXRfaW5mbGF0ZV9pbml0KHN0cmVhbSk7CgoJLyogQW5kIGdlbmVyYXRlIHRoZSBmYWtlIHRyYWRpdGlvbmFsIGhlYWRlciAqLwoJc3RyZWFtLT50b3RhbF9vdXQgPSAxICsgc25wcmludGYoYnVmZmVyLCBidWZzaXosICIlcyAlbHUiLAoJCQkJCSB0eXBlbmFtZSh0eXBlKSwgc2l6ZSk7CglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgKnVucGFja19zaGExX3Jlc3Qoel9zdHJlYW0gKnN0cmVhbSwgdm9pZCAqYnVmZmVyLCB1bnNpZ25lZCBsb25nIHNpemUsIGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEpCnsKCWludCBieXRlcyA9IHN0cmxlbihidWZmZXIpICsgMTsKCXVuc2lnbmVkIGNoYXIgKmJ1ZiA9IHhtYWxsb2N6KHNpemUpOwoJdW5zaWduZWQgbG9uZyBuOwoJaW50IHN0YXR1cyA9IFpfT0s7CgoJbiA9IHN0cmVhbS0+dG90YWxfb3V0IC0gYnl0ZXM7CglpZiAobiA+IHNpemUpCgkJbiA9IHNpemU7CgltZW1jcHkoYnVmLCAoY2hhciAqKSBidWZmZXIgKyBieXRlcywgbik7CglieXRlcyA9IG47CglpZiAoYnl0ZXMgPD0gc2l6ZSkgewoJCS8qCgkJICogVGhlIGFib3ZlIGNvbmRpdGlvbiBtdXN0IGJlIChieXRlcyA8PSBzaXplKSwgbm90CgkJICogKGJ5dGVzIDwgc2l6ZSkuICBJbiBvdGhlciB3b3JkcywgZXZlbiB0aG91Z2ggd2UKCQkgKiBleHBlY3Qgbm8gbW9yZSBvdXRwdXQgYW5kIHNldCBhdmFpbF9vdXQgdG8gemVyMCwKCQkgKiB0aGUgaW5wdXQgemxpYiBzdHJlYW0gbWF5IGhhdmUgYnl0ZXMgdGhhdCBleHByZXNzCgkJICogInRoaXMgY29uY2x1ZGVzIHRoZSBzdHJlYW0iLCBhbmQgd2UgKmRvKiB3YW50IHRvCgkJICogZWF0IHRoYXQgaW5wdXQuCgkJICoKCQkgKiBPdGhlcndpc2Ugd2Ugd291bGQgbm90IGJlIGFibGUgdG8gdGVzdCB0aGF0IHdlCgkJICogY29uc3VtZWQgYWxsIHRoZSBpbnB1dCB0byByZWFjaCB0aGUgZXhwZWN0ZWQgc2l6ZTsKCQkgKiB3ZSBhbHNvIHdhbnQgdG8gY2hlY2sgdGhhdCB6bGliIHRlbGxzIHVzIHRoYXQgYWxsCgkJICogd2VudCB3ZWxsIHdpdGggc3RhdHVzID09IFpfU1RSRUFNX0VORCBhdCB0aGUgZW5kLgoJCSAqLwoJCXN0cmVhbS0+bmV4dF9vdXQgPSBidWYgKyBieXRlczsKCQlzdHJlYW0tPmF2YWlsX291dCA9IHNpemUgLSBieXRlczsKCQl3aGlsZSAoc3RhdHVzID09IFpfT0spCgkJCXN0YXR1cyA9IGdpdF9pbmZsYXRlKHN0cmVhbSwgWl9GSU5JU0gpOwoJfQoJaWYgKHN0YXR1cyA9PSBaX1NUUkVBTV9FTkQgJiYgIXN0cmVhbS0+YXZhaWxfaW4pIHsKCQlnaXRfaW5mbGF0ZV9lbmQoc3RyZWFtKTsKCQlyZXR1cm4gYnVmOwoJfQoKCWlmIChzdGF0dXMgPCAwKQoJCWVycm9yKCJjb3JydXB0IGxvb3NlIG9iamVjdCAnJXMnIiwgc2hhMV90b19oZXgoc2hhMSkpOwoJZWxzZSBpZiAoc3RyZWFtLT5hdmFpbF9pbikKCQllcnJvcigiZ2FyYmFnZSBhdCBlbmQgb2YgbG9vc2Ugb2JqZWN0ICclcyciLAoJCSAgICAgIHNoYTFfdG9faGV4KHNoYTEpKTsKCWZyZWUoYnVmKTsKCXJldHVybiBOVUxMOwp9CgovKgogKiBXZSB1c2VkIHRvIGp1c3QgdXNlICJzc2NhbmYoKSIsIGJ1dCB0aGF0J3MgYWN0dWFsbHkgd2F5CiAqIHRvbyBwZXJtaXNzaXZlIGZvciB3aGF0IHdlIHdhbnQgdG8gY2hlY2suIFNvIGRvIGFuIGFuYWwKICogb2JqZWN0IGhlYWRlciBwYXJzZSBieSBoYW5kLgogKi8Kc3RhdGljIGludCBwYXJzZV9zaGExX2hlYWRlcihjb25zdCBjaGFyICpoZHIsIHVuc2lnbmVkIGxvbmcgKnNpemVwKQp7CgljaGFyIHR5cGVbMTBdOwoJaW50IGk7Cgl1bnNpZ25lZCBsb25nIHNpemU7CgoJLyoKCSAqIFRoZSB0eXBlIGNhbiBiZSBhdCBtb3N0IHRlbiBieXRlcyAoaW5jbHVkaW5nIHRoZQoJICogdGVybWluYXRpbmcgJ1wwJyB0aGF0IHdlIGFkZCksIGFuZCBpcyBmb2xsb3dlZCBieQoJICogYSBzcGFjZS4KCSAqLwoJaSA9IDA7Cglmb3IgKDs7KSB7CgkJY2hhciBjID0gKmhkcisrOwoJCWlmIChjID09ICcgJykKCQkJYnJlYWs7CgkJdHlwZVtpKytdID0gYzsKCQlpZiAoaSA+PSBzaXplb2YodHlwZSkpCgkJCXJldHVybiAtMTsKCX0KCXR5cGVbaV0gPSAwOwoKCS8qCgkgKiBUaGUgbGVuZ3RoIG11c3QgZm9sbG93IGltbWVkaWF0ZWx5LCBhbmQgYmUgaW4gY2Fub25pY2FsCgkgKiBkZWNpbWFsIGZvcm1hdCAoaWUgIjAxMCIgaXMgbm90IHZhbGlkKS4KCSAqLwoJc2l6ZSA9ICpoZHIrKyAtICcwJzsKCWlmIChzaXplID4gOSkKCQlyZXR1cm4gLTE7CglpZiAoc2l6ZSkgewoJCWZvciAoOzspIHsKCQkJdW5zaWduZWQgbG9uZyBjID0gKmhkciAtICcwJzsKCQkJaWYgKGMgPiA5KQoJCQkJYnJlYWs7CgkJCWhkcisrOwoJCQlzaXplID0gc2l6ZSAqIDEwICsgYzsKCQl9Cgl9Cgkqc2l6ZXAgPSBzaXplOwoKCS8qCgkgKiBUaGUgbGVuZ3RoIG11c3QgYmUgZm9sbG93ZWQgYnkgYSB6ZXJvIGJ5dGUKCSAqLwoJcmV0dXJuICpoZHIgPyAtMSA6IHR5cGVfZnJvbV9zdHJpbmcodHlwZSk7Cn0KCnN0YXRpYyB2b2lkICp1bnBhY2tfc2hhMV9maWxlKHZvaWQgKm1hcCwgdW5zaWduZWQgbG9uZyBtYXBzaXplLCBlbnVtIG9iamVjdF90eXBlICp0eXBlLCB1bnNpZ25lZCBsb25nICpzaXplLCBjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExKQp7CglpbnQgcmV0OwoJel9zdHJlYW0gc3RyZWFtOwoJY2hhciBoZHJbODE5Ml07CgoJcmV0ID0gdW5wYWNrX3NoYTFfaGVhZGVyKCZzdHJlYW0sIG1hcCwgbWFwc2l6ZSwgaGRyLCBzaXplb2YoaGRyKSk7CglpZiAocmV0IDwgWl9PSyB8fCAoKnR5cGUgPSBwYXJzZV9zaGExX2hlYWRlcihoZHIsIHNpemUpKSA8IDApCgkJcmV0dXJuIE5VTEw7CgoJcmV0dXJuIHVucGFja19zaGExX3Jlc3QoJnN0cmVhbSwgaGRyLCAqc2l6ZSwgc2hhMSk7Cn0KCnVuc2lnbmVkIGxvbmcgZ2V0X3NpemVfZnJvbV9kZWx0YShzdHJ1Y3QgcGFja2VkX2dpdCAqcCwKCQkJCSAgc3RydWN0IHBhY2tfd2luZG93ICoqd19jdXJzLAoJCQkgICAgICAgICAgb2ZmX3QgY3VycG9zKQp7Cgljb25zdCB1bnNpZ25lZCBjaGFyICpkYXRhOwoJdW5zaWduZWQgY2hhciBkZWx0YV9oZWFkWzIwXSwgKmluOwoJel9zdHJlYW0gc3RyZWFtOwoJaW50IHN0OwoKCW1lbXNldCgmc3RyZWFtLCAwLCBzaXplb2Yoc3RyZWFtKSk7CglzdHJlYW0ubmV4dF9vdXQgPSBkZWx0YV9oZWFkOwoJc3RyZWFtLmF2YWlsX291dCA9IHNpemVvZihkZWx0YV9oZWFkKTsKCglnaXRfaW5mbGF0ZV9pbml0KCZzdHJlYW0pOwoJZG8gewoJCWluID0gdXNlX3BhY2socCwgd19jdXJzLCBjdXJwb3MsICZzdHJlYW0uYXZhaWxfaW4pOwoJCXN0cmVhbS5uZXh0X2luID0gaW47CgkJc3QgPSBnaXRfaW5mbGF0ZSgmc3RyZWFtLCBaX0ZJTklTSCk7CgkJY3VycG9zICs9IHN0cmVhbS5uZXh0X2luIC0gaW47Cgl9IHdoaWxlICgoc3QgPT0gWl9PSyB8fCBzdCA9PSBaX0JVRl9FUlJPUikgJiYKCQkgc3RyZWFtLnRvdGFsX291dCA8IHNpemVvZihkZWx0YV9oZWFkKSk7CglnaXRfaW5mbGF0ZV9lbmQoJnN0cmVhbSk7CglpZiAoKHN0ICE9IFpfU1RSRUFNX0VORCkgJiYgc3RyZWFtLnRvdGFsX291dCAhPSBzaXplb2YoZGVsdGFfaGVhZCkpIHsKCQllcnJvcigiZGVsdGEgZGF0YSB1bnBhY2staW5pdGlhbCBmYWlsZWQiKTsKCQlyZXR1cm4gMDsKCX0KCgkvKiBFeGFtaW5lIHRoZSBpbml0aWFsIHBhcnQgb2YgdGhlIGRlbHRhIHRvIGZpZ3VyZSBvdXQKCSAqIHRoZSByZXN1bHQgc2l6ZS4KCSAqLwoJZGF0YSA9IGRlbHRhX2hlYWQ7CgoJLyogaWdub3JlIGJhc2Ugc2l6ZSAqLwoJZ2V0X2RlbHRhX2hkcl9zaXplKCZkYXRhLCBkZWx0YV9oZWFkK3NpemVvZihkZWx0YV9oZWFkKSk7CgoJLyogUmVhZCB0aGUgcmVzdWx0IHNpemUgKi8KCXJldHVybiBnZXRfZGVsdGFfaGRyX3NpemUoJmRhdGEsIGRlbHRhX2hlYWQrc2l6ZW9mKGRlbHRhX2hlYWQpKTsKfQoKc3RhdGljIG9mZl90IGdldF9kZWx0YV9iYXNlKHN0cnVjdCBwYWNrZWRfZ2l0ICpwLAoJCQkJICAgIHN0cnVjdCBwYWNrX3dpbmRvdyAqKndfY3VycywKCQkJCSAgICBvZmZfdCAqY3VycG9zLAoJCQkJICAgIGVudW0gb2JqZWN0X3R5cGUgdHlwZSwKCQkJCSAgICBvZmZfdCBkZWx0YV9vYmpfb2Zmc2V0KQp7Cgl1bnNpZ25lZCBjaGFyICpiYXNlX2luZm8gPSB1c2VfcGFjayhwLCB3X2N1cnMsICpjdXJwb3MsIE5VTEwpOwoJb2ZmX3QgYmFzZV9vZmZzZXQ7CgoJLyogdXNlX3BhY2soKSBhc3N1cmVkIHVzIHdlIGhhdmUgW2Jhc2VfaW5mbywgYmFzZV9pbmZvICsgMjApCgkgKiBhcyBhIHJhbmdlIHRoYXQgd2UgY2FuIGxvb2sgYXQgd2l0aG91dCB3YWxraW5nIG9mZiB0aGUKCSAqIGVuZCBvZiB0aGUgbWFwcGVkIHdpbmRvdy4gIEl0cyBhY3R1YWxseSB0aGUgaGFzaCBzaXplCgkgKiB0aGF0IGlzIGFzc3VyZWQuICBBbiBPRlNfREVMVEEgbG9uZ2VyIHRoYW4gdGhlIGhhc2ggc2l6ZQoJICogaXMgc3R1cGlkLCBhcyB0aGVuIGEgUkVGX0RFTFRBIHdvdWxkIGJlIHNtYWxsZXIgdG8gc3RvcmUuCgkgKi8KCWlmICh0eXBlID09IE9CSl9PRlNfREVMVEEpIHsKCQl1bnNpZ25lZCB1c2VkID0gMDsKCQl1bnNpZ25lZCBjaGFyIGMgPSBiYXNlX2luZm9bdXNlZCsrXTsKCQliYXNlX29mZnNldCA9IGMgJiAxMjc7CgkJd2hpbGUgKGMgJiAxMjgpIHsKCQkJYmFzZV9vZmZzZXQgKz0gMTsKCQkJaWYgKCFiYXNlX29mZnNldCB8fCBNU0IoYmFzZV9vZmZzZXQsIDcpKQoJCQkJcmV0dXJuIDA7ICAvKiBvdmVyZmxvdyAqLwoJCQljID0gYmFzZV9pbmZvW3VzZWQrK107CgkJCWJhc2Vfb2Zmc2V0ID0gKGJhc2Vfb2Zmc2V0IDw8IDcpICsgKGMgJiAxMjcpOwoJCX0KCQliYXNlX29mZnNldCA9IGRlbHRhX29ial9vZmZzZXQgLSBiYXNlX29mZnNldDsKCQlpZiAoYmFzZV9vZmZzZXQgPD0gMCB8fCBiYXNlX29mZnNldCA+PSBkZWx0YV9vYmpfb2Zmc2V0KQoJCQlyZXR1cm4gMDsgIC8qIG91dCBvZiBib3VuZCAqLwoJCSpjdXJwb3MgKz0gdXNlZDsKCX0gZWxzZSBpZiAodHlwZSA9PSBPQkpfUkVGX0RFTFRBKSB7CgkJLyogVGhlIGJhc2UgZW50cnkgX211c3RfIGJlIGluIHRoZSBzYW1lIHBhY2sgKi8KCQliYXNlX29mZnNldCA9IGZpbmRfcGFja19lbnRyeV9vbmUoYmFzZV9pbmZvLCBwKTsKCQkqY3VycG9zICs9IDIwOwoJfSBlbHNlCgkJZGllKCJJIGFtIHRvdGFsbHkgc2NyZXdlZCIpOwoJcmV0dXJuIGJhc2Vfb2Zmc2V0Owp9CgovKiBmb3J3YXJkIGRlY2xhcmF0aW9uIGZvciBhIG11dHVhbGx5IHJlY3Vyc2l2ZSBmdW5jdGlvbiAqLwpzdGF0aWMgaW50IHBhY2tlZF9vYmplY3RfaW5mbyhzdHJ1Y3QgcGFja2VkX2dpdCAqcCwgb2ZmX3Qgb2Zmc2V0LAoJCQkgICAgICB1bnNpZ25lZCBsb25nICpzaXplcCk7CgpzdGF0aWMgaW50IHBhY2tlZF9kZWx0YV9pbmZvKHN0cnVjdCBwYWNrZWRfZ2l0ICpwLAoJCQkgICAgIHN0cnVjdCBwYWNrX3dpbmRvdyAqKndfY3VycywKCQkJICAgICBvZmZfdCBjdXJwb3MsCgkJCSAgICAgZW51bSBvYmplY3RfdHlwZSB0eXBlLAoJCQkgICAgIG9mZl90IG9ial9vZmZzZXQsCgkJCSAgICAgdW5zaWduZWQgbG9uZyAqc2l6ZXApCnsKCW9mZl90IGJhc2Vfb2Zmc2V0OwoKCWJhc2Vfb2Zmc2V0ID0gZ2V0X2RlbHRhX2Jhc2UocCwgd19jdXJzLCAmY3VycG9zLCB0eXBlLCBvYmpfb2Zmc2V0KTsKCWlmICghYmFzZV9vZmZzZXQpCgkJcmV0dXJuIE9CSl9CQUQ7Cgl0eXBlID0gcGFja2VkX29iamVjdF9pbmZvKHAsIGJhc2Vfb2Zmc2V0LCBOVUxMKTsKCWlmICh0eXBlIDw9IE9CSl9OT05FKSB7CgkJc3RydWN0IHJldmluZGV4X2VudHJ5ICpyZXZpZHg7CgkJY29uc3QgdW5zaWduZWQgY2hhciAqYmFzZV9zaGExOwoJCXJldmlkeCA9IGZpbmRfcGFja19yZXZpbmRleChwLCBiYXNlX29mZnNldCk7CgkJaWYgKCFyZXZpZHgpCgkJCXJldHVybiBPQkpfQkFEOwoJCWJhc2Vfc2hhMSA9IG50aF9wYWNrZWRfb2JqZWN0X3NoYTEocCwgcmV2aWR4LT5ucik7CgkJbWFya19iYWRfcGFja2VkX29iamVjdChwLCBiYXNlX3NoYTEpOwoJCXR5cGUgPSBzaGExX29iamVjdF9pbmZvKGJhc2Vfc2hhMSwgTlVMTCk7CgkJaWYgKHR5cGUgPD0gT0JKX05PTkUpCgkJCXJldHVybiBPQkpfQkFEOwoJfQoKCS8qIFdlIGNob29zZSB0byBvbmx5IGdldCB0aGUgdHlwZSBvZiB0aGUgYmFzZSBvYmplY3QgYW5kCgkgKiBpZ25vcmUgcG90ZW50aWFsbHkgY29ycnVwdCBwYWNrIGZpbGUgdGhhdCBleHBlY3RzIHRoZSBkZWx0YQoJICogYmFzZWQgb24gYSBiYXNlIHdpdGggYSB3cm9uZyBzaXplLiAgVGhpcyBzYXZlcyB0b25zIG9mCgkgKiBpbmZsYXRlKCkgY2FsbHMuCgkgKi8KCWlmIChzaXplcCkgewoJCSpzaXplcCA9IGdldF9zaXplX2Zyb21fZGVsdGEocCwgd19jdXJzLCBjdXJwb3MpOwoJCWlmICgqc2l6ZXAgPT0gMCkKCQkJdHlwZSA9IE9CSl9CQUQ7Cgl9CgoJcmV0dXJuIHR5cGU7Cn0KCnN0YXRpYyBpbnQgdW5wYWNrX29iamVjdF9oZWFkZXIoc3RydWN0IHBhY2tlZF9naXQgKnAsCgkJCQlzdHJ1Y3QgcGFja193aW5kb3cgKip3X2N1cnMsCgkJCQlvZmZfdCAqY3VycG9zLAoJCQkJdW5zaWduZWQgbG9uZyAqc2l6ZXApCnsKCXVuc2lnbmVkIGNoYXIgKmJhc2U7Cgl1bnNpZ25lZCBpbnQgbGVmdDsKCXVuc2lnbmVkIGxvbmcgdXNlZDsKCWVudW0gb2JqZWN0X3R5cGUgdHlwZTsKCgkvKiB1c2VfcGFjaygpIGFzc3VyZXMgdXMgd2UgaGF2ZSBbYmFzZSwgYmFzZSArIDIwKSBhdmFpbGFibGUKCSAqIGFzIGEgcmFuZ2UgdGhhdCB3ZSBjYW4gbG9vayBhdCBhdC4gIChJdHMgYWN0dWFsbHkgdGhlIGhhc2gKCSAqIHNpemUgdGhhdCBpcyBhc3N1cmVkLikgIFdpdGggb3VyIG9iamVjdCBoZWFkZXIgZW5jb2RpbmcKCSAqIHRoZSBtYXhpbXVtIGRlZmxhdGVkIG9iamVjdCBzaXplIGlzIDJeMTM3LCB3aGljaCBpcyBqdXN0CgkgKiBpbnNhbmUsIHNvIHdlIGtub3cgd29uJ3QgZXhjZWVkIHdoYXQgd2UgaGF2ZSBiZWVuIGdpdmVuLgoJICovCgliYXNlID0gdXNlX3BhY2socCwgd19jdXJzLCAqY3VycG9zLCAmbGVmdCk7Cgl1c2VkID0gdW5wYWNrX29iamVjdF9oZWFkZXJfYnVmZmVyKGJhc2UsIGxlZnQsICZ0eXBlLCBzaXplcCk7CglpZiAoIXVzZWQpIHsKCQl0eXBlID0gT0JKX0JBRDsKCX0gZWxzZQoJCSpjdXJwb3MgKz0gdXNlZDsKCglyZXR1cm4gdHlwZTsKfQoKY29uc3QgY2hhciAqcGFja2VkX29iamVjdF9pbmZvX2RldGFpbChzdHJ1Y3QgcGFja2VkX2dpdCAqcCwKCQkJCSAgICAgIG9mZl90IG9ial9vZmZzZXQsCgkJCQkgICAgICB1bnNpZ25lZCBsb25nICpzaXplLAoJCQkJICAgICAgdW5zaWduZWQgbG9uZyAqc3RvcmVfc2l6ZSwKCQkJCSAgICAgIHVuc2lnbmVkIGludCAqZGVsdGFfY2hhaW5fbGVuZ3RoLAoJCQkJICAgICAgdW5zaWduZWQgY2hhciAqYmFzZV9zaGExKQp7CglzdHJ1Y3QgcGFja193aW5kb3cgKndfY3VycyA9IE5VTEw7CglvZmZfdCBjdXJwb3M7Cgl1bnNpZ25lZCBsb25nIGR1bW15OwoJdW5zaWduZWQgY2hhciAqbmV4dF9zaGExOwoJZW51bSBvYmplY3RfdHlwZSB0eXBlOwoJc3RydWN0IHJldmluZGV4X2VudHJ5ICpyZXZpZHg7CgoJKmRlbHRhX2NoYWluX2xlbmd0aCA9IDA7CgljdXJwb3MgPSBvYmpfb2Zmc2V0OwoJdHlwZSA9IHVucGFja19vYmplY3RfaGVhZGVyKHAsICZ3X2N1cnMsICZjdXJwb3MsIHNpemUpOwoKCXJldmlkeCA9IGZpbmRfcGFja19yZXZpbmRleChwLCBvYmpfb2Zmc2V0KTsKCSpzdG9yZV9zaXplID0gcmV2aWR4WzFdLm9mZnNldCAtIG9ial9vZmZzZXQ7CgoJZm9yICg7OykgewoJCXN3aXRjaCAodHlwZSkgewoJCWRlZmF1bHQ6CgkJCWRpZSgicGFjayAlcyBjb250YWlucyB1bmtub3duIG9iamVjdCB0eXBlICVkIiwKCQkJICAgIHAtPnBhY2tfbmFtZSwgdHlwZSk7CgkJY2FzZSBPQkpfQ09NTUlUOgoJCWNhc2UgT0JKX1RSRUU6CgkJY2FzZSBPQkpfQkxPQjoKCQljYXNlIE9CSl9UQUc6CgkJCXVudXNlX3BhY2soJndfY3Vycyk7CgkJCXJldHVybiB0eXBlbmFtZSh0eXBlKTsKCQljYXNlIE9CSl9PRlNfREVMVEE6CgkJCW9ial9vZmZzZXQgPSBnZXRfZGVsdGFfYmFzZShwLCAmd19jdXJzLCAmY3VycG9zLCB0eXBlLCBvYmpfb2Zmc2V0KTsKCQkJaWYgKCFvYmpfb2Zmc2V0KQoJCQkJZGllKCJwYWNrICVzIGNvbnRhaW5zIGJhZCBkZWx0YSBiYXNlIHJlZmVyZW5jZSBvZiB0eXBlICVzIiwKCQkJCSAgICBwLT5wYWNrX25hbWUsIHR5cGVuYW1lKHR5cGUpKTsKCQkJaWYgKCpkZWx0YV9jaGFpbl9sZW5ndGggPT0gMCkgewoJCQkJcmV2aWR4ID0gZmluZF9wYWNrX3JldmluZGV4KHAsIG9ial9vZmZzZXQpOwoJCQkJaGFzaGNweShiYXNlX3NoYTEsIG50aF9wYWNrZWRfb2JqZWN0X3NoYTEocCwgcmV2aWR4LT5ucikpOwoJCQl9CgkJCWJyZWFrOwoJCWNhc2UgT0JKX1JFRl9ERUxUQToKCQkJbmV4dF9zaGExID0gdXNlX3BhY2socCwgJndfY3VycywgY3VycG9zLCBOVUxMKTsKCQkJaWYgKCpkZWx0YV9jaGFpbl9sZW5ndGggPT0gMCkKCQkJCWhhc2hjcHkoYmFzZV9zaGExLCBuZXh0X3NoYTEpOwoJCQlvYmpfb2Zmc2V0ID0gZmluZF9wYWNrX2VudHJ5X29uZShuZXh0X3NoYTEsIHApOwoJCQlicmVhazsKCQl9CgkJKCpkZWx0YV9jaGFpbl9sZW5ndGgpKys7CgkJY3VycG9zID0gb2JqX29mZnNldDsKCQl0eXBlID0gdW5wYWNrX29iamVjdF9oZWFkZXIocCwgJndfY3VycywgJmN1cnBvcywgJmR1bW15KTsKCX0KfQoKc3RhdGljIGludCBwYWNrZWRfb2JqZWN0X2luZm8oc3RydWN0IHBhY2tlZF9naXQgKnAsIG9mZl90IG9ial9vZmZzZXQsCgkJCSAgICAgIHVuc2lnbmVkIGxvbmcgKnNpemVwKQp7CglzdHJ1Y3QgcGFja193aW5kb3cgKndfY3VycyA9IE5VTEw7Cgl1bnNpZ25lZCBsb25nIHNpemU7CglvZmZfdCBjdXJwb3MgPSBvYmpfb2Zmc2V0OwoJZW51bSBvYmplY3RfdHlwZSB0eXBlOwoKCXR5cGUgPSB1bnBhY2tfb2JqZWN0X2hlYWRlcihwLCAmd19jdXJzLCAmY3VycG9zLCAmc2l6ZSk7CgoJc3dpdGNoICh0eXBlKSB7CgljYXNlIE9CSl9PRlNfREVMVEE6CgljYXNlIE9CSl9SRUZfREVMVEE6CgkJdHlwZSA9IHBhY2tlZF9kZWx0YV9pbmZvKHAsICZ3X2N1cnMsIGN1cnBvcywKCQkJCQkgdHlwZSwgb2JqX29mZnNldCwgc2l6ZXApOwoJCWJyZWFrOwoJY2FzZSBPQkpfQ09NTUlUOgoJY2FzZSBPQkpfVFJFRToKCWNhc2UgT0JKX0JMT0I6CgljYXNlIE9CSl9UQUc6CgkJaWYgKHNpemVwKQoJCQkqc2l6ZXAgPSBzaXplOwoJCWJyZWFrOwoJZGVmYXVsdDoKCQllcnJvcigidW5rbm93biBvYmplY3QgdHlwZSAlaSBhdCBvZmZzZXQgJSJQUkl1TUFYIiBpbiAlcyIsCgkJICAgICAgdHlwZSwgKHVpbnRtYXhfdClvYmpfb2Zmc2V0LCBwLT5wYWNrX25hbWUpOwoJCXR5cGUgPSBPQkpfQkFEOwoJfQoJdW51c2VfcGFjaygmd19jdXJzKTsKCXJldHVybiB0eXBlOwp9CgpzdGF0aWMgdm9pZCAqdW5wYWNrX2NvbXByZXNzZWRfZW50cnkoc3RydWN0IHBhY2tlZF9naXQgKnAsCgkJCQkgICAgc3RydWN0IHBhY2tfd2luZG93ICoqd19jdXJzLAoJCQkJICAgIG9mZl90IGN1cnBvcywKCQkJCSAgICB1bnNpZ25lZCBsb25nIHNpemUpCnsKCWludCBzdDsKCXpfc3RyZWFtIHN0cmVhbTsKCXVuc2lnbmVkIGNoYXIgKmJ1ZmZlciwgKmluOwoKCWJ1ZmZlciA9IHhtYWxsb2N6KHNpemUpOwoJbWVtc2V0KCZzdHJlYW0sIDAsIHNpemVvZihzdHJlYW0pKTsKCXN0cmVhbS5uZXh0X291dCA9IGJ1ZmZlcjsKCXN0cmVhbS5hdmFpbF9vdXQgPSBzaXplICsgMTsKCglnaXRfaW5mbGF0ZV9pbml0KCZzdHJlYW0pOwoJZG8gewoJCWluID0gdXNlX3BhY2socCwgd19jdXJzLCBjdXJwb3MsICZzdHJlYW0uYXZhaWxfaW4pOwoJCXN0cmVhbS5uZXh0X2luID0gaW47CgkJc3QgPSBnaXRfaW5mbGF0ZSgmc3RyZWFtLCBaX0ZJTklTSCk7CgkJaWYgKCFzdHJlYW0uYXZhaWxfb3V0KQoJCQlicmVhazsgLyogdGhlIHBheWxvYWQgaXMgbGFyZ2VyIHRoYW4gaXQgc2hvdWxkIGJlICovCgkJY3VycG9zICs9IHN0cmVhbS5uZXh0X2luIC0gaW47Cgl9IHdoaWxlIChzdCA9PSBaX09LIHx8IHN0ID09IFpfQlVGX0VSUk9SKTsKCWdpdF9pbmZsYXRlX2VuZCgmc3RyZWFtKTsKCWlmICgoc3QgIT0gWl9TVFJFQU1fRU5EKSB8fCBzdHJlYW0udG90YWxfb3V0ICE9IHNpemUpIHsKCQlmcmVlKGJ1ZmZlcik7CgkJcmV0dXJuIE5VTEw7Cgl9CgoJcmV0dXJuIGJ1ZmZlcjsKfQoKI2RlZmluZSBNQVhfREVMVEFfQ0FDSEUgKDI1NikKCnN0YXRpYyBzaXplX3QgZGVsdGFfYmFzZV9jYWNoZWQ7CgpzdGF0aWMgc3RydWN0IGRlbHRhX2Jhc2VfY2FjaGVfbHJ1X2xpc3QgewoJc3RydWN0IGRlbHRhX2Jhc2VfY2FjaGVfbHJ1X2xpc3QgKnByZXY7CglzdHJ1Y3QgZGVsdGFfYmFzZV9jYWNoZV9scnVfbGlzdCAqbmV4dDsKfSBkZWx0YV9iYXNlX2NhY2hlX2xydSA9IHsgJmRlbHRhX2Jhc2VfY2FjaGVfbHJ1LCAmZGVsdGFfYmFzZV9jYWNoZV9scnUgfTsKCnN0YXRpYyBzdHJ1Y3QgZGVsdGFfYmFzZV9jYWNoZV9lbnRyeSB7CglzdHJ1Y3QgZGVsdGFfYmFzZV9jYWNoZV9scnVfbGlzdCBscnU7Cgl2b2lkICpkYXRhOwoJc3RydWN0IHBhY2tlZF9naXQgKnA7CglvZmZfdCBiYXNlX29mZnNldDsKCXVuc2lnbmVkIGxvbmcgc2l6ZTsKCWVudW0gb2JqZWN0X3R5cGUgdHlwZTsKfSBkZWx0YV9iYXNlX2NhY2hlW01BWF9ERUxUQV9DQUNIRV07CgpzdGF0aWMgdW5zaWduZWQgbG9uZyBwYWNrX2VudHJ5X2hhc2goc3RydWN0IHBhY2tlZF9naXQgKnAsIG9mZl90IGJhc2Vfb2Zmc2V0KQp7Cgl1bnNpZ25lZCBsb25nIGhhc2g7CgoJaGFzaCA9ICh1bnNpZ25lZCBsb25nKXAgKyAodW5zaWduZWQgbG9uZyliYXNlX29mZnNldDsKCWhhc2ggKz0gKGhhc2ggPj4gOCkgKyAoaGFzaCA+PiAxNik7CglyZXR1cm4gaGFzaCAlIE1BWF9ERUxUQV9DQUNIRTsKfQoKc3RhdGljIHZvaWQgKmNhY2hlX29yX3VucGFja19lbnRyeShzdHJ1Y3QgcGFja2VkX2dpdCAqcCwgb2ZmX3QgYmFzZV9vZmZzZXQsCgl1bnNpZ25lZCBsb25nICpiYXNlX3NpemUsIGVudW0gb2JqZWN0X3R5cGUgKnR5cGUsIGludCBrZWVwX2NhY2hlKQp7Cgl2b2lkICpyZXQ7Cgl1bnNpZ25lZCBsb25nIGhhc2ggPSBwYWNrX2VudHJ5X2hhc2gocCwgYmFzZV9vZmZzZXQpOwoJc3RydWN0IGRlbHRhX2Jhc2VfY2FjaGVfZW50cnkgKmVudCA9IGRlbHRhX2Jhc2VfY2FjaGUgKyBoYXNoOwoKCXJldCA9IGVudC0+ZGF0YTsKCWlmICghcmV0IHx8IGVudC0+cCAhPSBwIHx8IGVudC0+YmFzZV9vZmZzZXQgIT0gYmFzZV9vZmZzZXQpCgkJcmV0dXJuIHVucGFja19lbnRyeShwLCBiYXNlX29mZnNldCwgdHlwZSwgYmFzZV9zaXplKTsKCglpZiAoIWtlZXBfY2FjaGUpIHsKCQllbnQtPmRhdGEgPSBOVUxMOwoJCWVudC0+bHJ1Lm5leHQtPnByZXYgPSBlbnQtPmxydS5wcmV2OwoJCWVudC0+bHJ1LnByZXYtPm5leHQgPSBlbnQtPmxydS5uZXh0OwoJCWRlbHRhX2Jhc2VfY2FjaGVkIC09IGVudC0+c2l6ZTsKCX0gZWxzZSB7CgkJcmV0ID0geG1lbWR1cHooZW50LT5kYXRhLCBlbnQtPnNpemUpOwoJfQoJKnR5cGUgPSBlbnQtPnR5cGU7CgkqYmFzZV9zaXplID0gZW50LT5zaXplOwoJcmV0dXJuIHJldDsKfQoKc3RhdGljIGlubGluZSB2b2lkIHJlbGVhc2VfZGVsdGFfYmFzZV9jYWNoZShzdHJ1Y3QgZGVsdGFfYmFzZV9jYWNoZV9lbnRyeSAqZW50KQp7CglpZiAoZW50LT5kYXRhKSB7CgkJZnJlZShlbnQtPmRhdGEpOwoJCWVudC0+ZGF0YSA9IE5VTEw7CgkJZW50LT5scnUubmV4dC0+cHJldiA9IGVudC0+bHJ1LnByZXY7CgkJZW50LT5scnUucHJldi0+bmV4dCA9IGVudC0+bHJ1Lm5leHQ7CgkJZGVsdGFfYmFzZV9jYWNoZWQgLT0gZW50LT5zaXplOwoJfQp9Cgp2b2lkIGNsZWFyX2RlbHRhX2Jhc2VfY2FjaGUodm9pZCkKewoJdW5zaWduZWQgbG9uZyBwOwoJZm9yIChwID0gMDsgcCA8IE1BWF9ERUxUQV9DQUNIRTsgcCsrKQoJCXJlbGVhc2VfZGVsdGFfYmFzZV9jYWNoZSgmZGVsdGFfYmFzZV9jYWNoZVtwXSk7Cn0KCnN0YXRpYyB2b2lkIGFkZF9kZWx0YV9iYXNlX2NhY2hlKHN0cnVjdCBwYWNrZWRfZ2l0ICpwLCBvZmZfdCBiYXNlX29mZnNldCwKCXZvaWQgKmJhc2UsIHVuc2lnbmVkIGxvbmcgYmFzZV9zaXplLCBlbnVtIG9iamVjdF90eXBlIHR5cGUpCnsKCXVuc2lnbmVkIGxvbmcgaGFzaCA9IHBhY2tfZW50cnlfaGFzaChwLCBiYXNlX29mZnNldCk7CglzdHJ1Y3QgZGVsdGFfYmFzZV9jYWNoZV9lbnRyeSAqZW50ID0gZGVsdGFfYmFzZV9jYWNoZSArIGhhc2g7CglzdHJ1Y3QgZGVsdGFfYmFzZV9jYWNoZV9scnVfbGlzdCAqbHJ1OwoKCXJlbGVhc2VfZGVsdGFfYmFzZV9jYWNoZShlbnQpOwoJZGVsdGFfYmFzZV9jYWNoZWQgKz0gYmFzZV9zaXplOwoKCWZvciAobHJ1ID0gZGVsdGFfYmFzZV9jYWNoZV9scnUubmV4dDsKCSAgICAgZGVsdGFfYmFzZV9jYWNoZWQgPiBkZWx0YV9iYXNlX2NhY2hlX2xpbWl0CgkgICAgICYmIGxydSAhPSAmZGVsdGFfYmFzZV9jYWNoZV9scnU7CgkgICAgIGxydSA9IGxydS0+bmV4dCkgewoJCXN0cnVjdCBkZWx0YV9iYXNlX2NhY2hlX2VudHJ5ICpmID0gKHZvaWQgKilscnU7CgkJaWYgKGYtPnR5cGUgPT0gT0JKX0JMT0IpCgkJCXJlbGVhc2VfZGVsdGFfYmFzZV9jYWNoZShmKTsKCX0KCWZvciAobHJ1ID0gZGVsdGFfYmFzZV9jYWNoZV9scnUubmV4dDsKCSAgICAgZGVsdGFfYmFzZV9jYWNoZWQgPiBkZWx0YV9iYXNlX2NhY2hlX2xpbWl0CgkgICAgICYmIGxydSAhPSAmZGVsdGFfYmFzZV9jYWNoZV9scnU7CgkgICAgIGxydSA9IGxydS0+bmV4dCkgewoJCXN0cnVjdCBkZWx0YV9iYXNlX2NhY2hlX2VudHJ5ICpmID0gKHZvaWQgKilscnU7CgkJcmVsZWFzZV9kZWx0YV9iYXNlX2NhY2hlKGYpOwoJfQoKCWVudC0+cCA9IHA7CgllbnQtPmJhc2Vfb2Zmc2V0ID0gYmFzZV9vZmZzZXQ7CgllbnQtPnR5cGUgPSB0eXBlOwoJZW50LT5kYXRhID0gYmFzZTsKCWVudC0+c2l6ZSA9IGJhc2Vfc2l6ZTsKCWVudC0+bHJ1Lm5leHQgPSAmZGVsdGFfYmFzZV9jYWNoZV9scnU7CgllbnQtPmxydS5wcmV2ID0gZGVsdGFfYmFzZV9jYWNoZV9scnUucHJldjsKCWRlbHRhX2Jhc2VfY2FjaGVfbHJ1LnByZXYtPm5leHQgPSAmZW50LT5scnU7CglkZWx0YV9iYXNlX2NhY2hlX2xydS5wcmV2ID0gJmVudC0+bHJ1Owp9CgpzdGF0aWMgdm9pZCAqcmVhZF9vYmplY3QoY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwgZW51bSBvYmplY3RfdHlwZSAqdHlwZSwKCQkJIHVuc2lnbmVkIGxvbmcgKnNpemUpOwoKc3RhdGljIHZvaWQgKnVucGFja19kZWx0YV9lbnRyeShzdHJ1Y3QgcGFja2VkX2dpdCAqcCwKCQkJCXN0cnVjdCBwYWNrX3dpbmRvdyAqKndfY3VycywKCQkJCW9mZl90IGN1cnBvcywKCQkJCXVuc2lnbmVkIGxvbmcgZGVsdGFfc2l6ZSwKCQkJCW9mZl90IG9ial9vZmZzZXQsCgkJCQllbnVtIG9iamVjdF90eXBlICp0eXBlLAoJCQkJdW5zaWduZWQgbG9uZyAqc2l6ZXApCnsKCXZvaWQgKmRlbHRhX2RhdGEsICpyZXN1bHQsICpiYXNlOwoJdW5zaWduZWQgbG9uZyBiYXNlX3NpemU7CglvZmZfdCBiYXNlX29mZnNldDsKCgliYXNlX29mZnNldCA9IGdldF9kZWx0YV9iYXNlKHAsIHdfY3VycywgJmN1cnBvcywgKnR5cGUsIG9ial9vZmZzZXQpOwoJaWYgKCFiYXNlX29mZnNldCkgewoJCWVycm9yKCJmYWlsZWQgdG8gdmFsaWRhdGUgZGVsdGEgYmFzZSByZWZlcmVuY2UgIgoJCSAgICAgICJhdCBvZmZzZXQgJSJQUkl1TUFYIiBmcm9tICVzIiwKCQkgICAgICAodWludG1heF90KWN1cnBvcywgcC0+cGFja19uYW1lKTsKCQlyZXR1cm4gTlVMTDsKCX0KCXVudXNlX3BhY2sod19jdXJzKTsKCWJhc2UgPSBjYWNoZV9vcl91bnBhY2tfZW50cnkocCwgYmFzZV9vZmZzZXQsICZiYXNlX3NpemUsIHR5cGUsIDApOwoJaWYgKCFiYXNlKSB7CgkJLyoKCQkgKiBXZSdyZSBwcm9iYWJseSBpbiBkZWVwIHNoaXQsIGJ1dCBsZXQncyB0cnkgdG8gZmV0Y2gKCQkgKiB0aGUgcmVxdWlyZWQgYmFzZSBhbnl3YXkgZnJvbSBhbm90aGVyIHBhY2sgb3IgbG9vc2UuCgkJICogVGhpcyBpcyBjb3N0bHkgYnV0IHNob3VsZCBoYXBwZW4gb25seSBpbiB0aGUgcHJlc2VuY2UKCQkgKiBvZiBhIGNvcnJ1cHRlZCBwYWNrLCBhbmQgaXMgYmV0dGVyIHRoYW4gZmFpbGluZyBvdXRyaWdodC4KCQkgKi8KCQlzdHJ1Y3QgcmV2aW5kZXhfZW50cnkgKnJldmlkeDsKCQljb25zdCB1bnNpZ25lZCBjaGFyICpiYXNlX3NoYTE7CgkJcmV2aWR4ID0gZmluZF9wYWNrX3JldmluZGV4KHAsIGJhc2Vfb2Zmc2V0KTsKCQlpZiAoIXJldmlkeCkKCQkJcmV0dXJuIE5VTEw7CgkJYmFzZV9zaGExID0gbnRoX3BhY2tlZF9vYmplY3Rfc2hhMShwLCByZXZpZHgtPm5yKTsKCQllcnJvcigiZmFpbGVkIHRvIHJlYWQgZGVsdGEgYmFzZSBvYmplY3QgJXMiCgkJICAgICAgIiBhdCBvZmZzZXQgJSJQUkl1TUFYIiBmcm9tICVzIiwKCQkgICAgICBzaGExX3RvX2hleChiYXNlX3NoYTEpLCAodWludG1heF90KWJhc2Vfb2Zmc2V0LAoJCSAgICAgIHAtPnBhY2tfbmFtZSk7CgkJbWFya19iYWRfcGFja2VkX29iamVjdChwLCBiYXNlX3NoYTEpOwoJCWJhc2UgPSByZWFkX29iamVjdChiYXNlX3NoYTEsIHR5cGUsICZiYXNlX3NpemUpOwoJCWlmICghYmFzZSkKCQkJcmV0dXJuIE5VTEw7Cgl9CgoJZGVsdGFfZGF0YSA9IHVucGFja19jb21wcmVzc2VkX2VudHJ5KHAsIHdfY3VycywgY3VycG9zLCBkZWx0YV9zaXplKTsKCWlmICghZGVsdGFfZGF0YSkgewoJCWVycm9yKCJmYWlsZWQgdG8gdW5wYWNrIGNvbXByZXNzZWQgZGVsdGEgIgoJCSAgICAgICJhdCBvZmZzZXQgJSJQUkl1TUFYIiBmcm9tICVzIiwKCQkgICAgICAodWludG1heF90KWN1cnBvcywgcC0+cGFja19uYW1lKTsKCQlmcmVlKGJhc2UpOwoJCXJldHVybiBOVUxMOwoJfQoJcmVzdWx0ID0gcGF0Y2hfZGVsdGEoYmFzZSwgYmFzZV9zaXplLAoJCQkgICAgIGRlbHRhX2RhdGEsIGRlbHRhX3NpemUsCgkJCSAgICAgc2l6ZXApOwoJaWYgKCFyZXN1bHQpCgkJZGllKCJmYWlsZWQgdG8gYXBwbHkgZGVsdGEiKTsKCWZyZWUoZGVsdGFfZGF0YSk7CglhZGRfZGVsdGFfYmFzZV9jYWNoZShwLCBiYXNlX29mZnNldCwgYmFzZSwgYmFzZV9zaXplLCAqdHlwZSk7CglyZXR1cm4gcmVzdWx0Owp9CgppbnQgZG9fY2hlY2tfcGFja2VkX29iamVjdF9jcmM7Cgp2b2lkICp1bnBhY2tfZW50cnkoc3RydWN0IHBhY2tlZF9naXQgKnAsIG9mZl90IG9ial9vZmZzZXQsCgkJICAgZW51bSBvYmplY3RfdHlwZSAqdHlwZSwgdW5zaWduZWQgbG9uZyAqc2l6ZXApCnsKCXN0cnVjdCBwYWNrX3dpbmRvdyAqd19jdXJzID0gTlVMTDsKCW9mZl90IGN1cnBvcyA9IG9ial9vZmZzZXQ7Cgl2b2lkICpkYXRhOwoKCWlmIChkb19jaGVja19wYWNrZWRfb2JqZWN0X2NyYyAmJiBwLT5pbmRleF92ZXJzaW9uID4gMSkgewoJCXN0cnVjdCByZXZpbmRleF9lbnRyeSAqcmV2aWR4ID0gZmluZF9wYWNrX3JldmluZGV4KHAsIG9ial9vZmZzZXQpOwoJCXVuc2lnbmVkIGxvbmcgbGVuID0gcmV2aWR4WzFdLm9mZnNldCAtIG9ial9vZmZzZXQ7CgkJaWYgKGNoZWNrX3BhY2tfY3JjKHAsICZ3X2N1cnMsIG9ial9vZmZzZXQsIGxlbiwgcmV2aWR4LT5ucikpIHsKCQkJY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSA9CgkJCQludGhfcGFja2VkX29iamVjdF9zaGExKHAsIHJldmlkeC0+bnIpOwoJCQllcnJvcigiYmFkIHBhY2tlZCBvYmplY3QgQ1JDIGZvciAlcyIsCgkJCSAgICAgIHNoYTFfdG9faGV4KHNoYTEpKTsKCQkJbWFya19iYWRfcGFja2VkX29iamVjdChwLCBzaGExKTsKCQkJdW51c2VfcGFjaygmd19jdXJzKTsKCQkJcmV0dXJuIE5VTEw7CgkJfQoJfQoKCSp0eXBlID0gdW5wYWNrX29iamVjdF9oZWFkZXIocCwgJndfY3VycywgJmN1cnBvcywgc2l6ZXApOwoJc3dpdGNoICgqdHlwZSkgewoJY2FzZSBPQkpfT0ZTX0RFTFRBOgoJY2FzZSBPQkpfUkVGX0RFTFRBOgoJCWRhdGEgPSB1bnBhY2tfZGVsdGFfZW50cnkocCwgJndfY3VycywgY3VycG9zLCAqc2l6ZXAsCgkJCQkJICBvYmpfb2Zmc2V0LCB0eXBlLCBzaXplcCk7CgkJYnJlYWs7CgljYXNlIE9CSl9DT01NSVQ6CgljYXNlIE9CSl9UUkVFOgoJY2FzZSBPQkpfQkxPQjoKCWNhc2UgT0JKX1RBRzoKCQlkYXRhID0gdW5wYWNrX2NvbXByZXNzZWRfZW50cnkocCwgJndfY3VycywgY3VycG9zLCAqc2l6ZXApOwoJCWJyZWFrOwoJZGVmYXVsdDoKCQlkYXRhID0gTlVMTDsKCQllcnJvcigidW5rbm93biBvYmplY3QgdHlwZSAlaSBhdCBvZmZzZXQgJSJQUkl1TUFYIiBpbiAlcyIsCgkJICAgICAgKnR5cGUsICh1aW50bWF4X3Qpb2JqX29mZnNldCwgcC0+cGFja19uYW1lKTsKCX0KCXVudXNlX3BhY2soJndfY3Vycyk7CglyZXR1cm4gZGF0YTsKfQoKY29uc3QgdW5zaWduZWQgY2hhciAqbnRoX3BhY2tlZF9vYmplY3Rfc2hhMShzdHJ1Y3QgcGFja2VkX2dpdCAqcCwKCQkJCQkgICAgdWludDMyX3QgbikKewoJY29uc3QgdW5zaWduZWQgY2hhciAqaW5kZXggPSBwLT5pbmRleF9kYXRhOwoJaWYgKCFpbmRleCkgewoJCWlmIChvcGVuX3BhY2tfaW5kZXgocCkpCgkJCXJldHVybiBOVUxMOwoJCWluZGV4ID0gcC0+aW5kZXhfZGF0YTsKCX0KCWlmIChuID49IHAtPm51bV9vYmplY3RzKQoJCXJldHVybiBOVUxMOwoJaW5kZXggKz0gNCAqIDI1NjsKCWlmIChwLT5pbmRleF92ZXJzaW9uID09IDEpIHsKCQlyZXR1cm4gaW5kZXggKyAyNCAqIG4gKyA0OwoJfSBlbHNlIHsKCQlpbmRleCArPSA4OwoJCXJldHVybiBpbmRleCArIDIwICogbjsKCX0KfQoKb2ZmX3QgbnRoX3BhY2tlZF9vYmplY3Rfb2Zmc2V0KGNvbnN0IHN0cnVjdCBwYWNrZWRfZ2l0ICpwLCB1aW50MzJfdCBuKQp7Cgljb25zdCB1bnNpZ25lZCBjaGFyICppbmRleCA9IHAtPmluZGV4X2RhdGE7CglpbmRleCArPSA0ICogMjU2OwoJaWYgKHAtPmluZGV4X3ZlcnNpb24gPT0gMSkgewoJCXJldHVybiBudG9obCgqKCh1aW50MzJfdCAqKShpbmRleCArIDI0ICogbikpKTsKCX0gZWxzZSB7CgkJdWludDMyX3Qgb2ZmOwoJCWluZGV4ICs9IDggKyBwLT5udW1fb2JqZWN0cyAqICgyMCArIDQpOwoJCW9mZiA9IG50b2hsKCooKHVpbnQzMl90ICopKGluZGV4ICsgNCAqIG4pKSk7CgkJaWYgKCEob2ZmICYgMHg4MDAwMDAwMCkpCgkJCXJldHVybiBvZmY7CgkJaW5kZXggKz0gcC0+bnVtX29iamVjdHMgKiA0ICsgKG9mZiAmIDB4N2ZmZmZmZmYpICogODsKCQlyZXR1cm4gKCgodWludDY0X3QpbnRvaGwoKigodWludDMyX3QgKikoaW5kZXggKyAwKSkpKSA8PCAzMikgfAoJCQkJICAgbnRvaGwoKigodWludDMyX3QgKikoaW5kZXggKyA0KSkpOwoJfQp9CgpvZmZfdCBmaW5kX3BhY2tfZW50cnlfb25lKGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEsCgkJCQkgIHN0cnVjdCBwYWNrZWRfZ2l0ICpwKQp7Cgljb25zdCB1aW50MzJfdCAqbGV2ZWwxX29mcyA9IHAtPmluZGV4X2RhdGE7Cgljb25zdCB1bnNpZ25lZCBjaGFyICppbmRleCA9IHAtPmluZGV4X2RhdGE7Cgl1bnNpZ25lZCBoaSwgbG8sIHN0cmlkZTsKCXN0YXRpYyBpbnQgdXNlX2xvb2t1cCA9IC0xOwoJc3RhdGljIGludCBkZWJ1Z19sb29rdXAgPSAtMTsKCglpZiAoZGVidWdfbG9va3VwIDwgMCkKCQlkZWJ1Z19sb29rdXAgPSAhIWdldGVudigiR0lUX0RFQlVHX0xPT0tVUCIpOwoKCWlmICghaW5kZXgpIHsKCQlpZiAob3Blbl9wYWNrX2luZGV4KHApKQoJCQlyZXR1cm4gMDsKCQlsZXZlbDFfb2ZzID0gcC0+aW5kZXhfZGF0YTsKCQlpbmRleCA9IHAtPmluZGV4X2RhdGE7Cgl9CglpZiAocC0+aW5kZXhfdmVyc2lvbiA+IDEpIHsKCQlsZXZlbDFfb2ZzICs9IDI7CgkJaW5kZXggKz0gODsKCX0KCWluZGV4ICs9IDQgKiAyNTY7CgloaSA9IG50b2hsKGxldmVsMV9vZnNbKnNoYTFdKTsKCWxvID0gKCgqc2hhMSA9PSAweDApID8gMCA6IG50b2hsKGxldmVsMV9vZnNbKnNoYTEgLSAxXSkpOwoJaWYgKHAtPmluZGV4X3ZlcnNpb24gPiAxKSB7CgkJc3RyaWRlID0gMjA7Cgl9IGVsc2UgewoJCXN0cmlkZSA9IDI0OwoJCWluZGV4ICs9IDQ7Cgl9CgoJaWYgKGRlYnVnX2xvb2t1cCkKCQlwcmludGYoIiUwMnglMDJ4JTAyeC4uLiBsbyAldSBoaSAldSBuciAlIlBSSXUzMiJcbiIsCgkJICAgICAgIHNoYTFbMF0sIHNoYTFbMV0sIHNoYTFbMl0sIGxvLCBoaSwgcC0+bnVtX29iamVjdHMpOwoKCWlmICh1c2VfbG9va3VwIDwgMCkKCQl1c2VfbG9va3VwID0gISFnZXRlbnYoIkdJVF9VU0VfTE9PS1VQIik7CglpZiAodXNlX2xvb2t1cCkgewoJCWludCBwb3MgPSBzaGExX2VudHJ5X3BvcyhpbmRleCwgc3RyaWRlLCAwLAoJCQkJCSBsbywgaGksIHAtPm51bV9vYmplY3RzLCBzaGExKTsKCQlpZiAocG9zIDwgMCkKCQkJcmV0dXJuIDA7CgkJcmV0dXJuIG50aF9wYWNrZWRfb2JqZWN0X29mZnNldChwLCBwb3MpOwoJfQoKCWRvIHsKCQl1bnNpZ25lZCBtaSA9IChsbyArIGhpKSAvIDI7CgkJaW50IGNtcCA9IGhhc2hjbXAoaW5kZXggKyBtaSAqIHN0cmlkZSwgc2hhMSk7CgoJCWlmIChkZWJ1Z19sb29rdXApCgkJCXByaW50ZigibG8gJXUgaGkgJXUgcmcgJXUgbWkgJXVcbiIsCgkJCSAgICAgICBsbywgaGksIGhpIC0gbG8sIG1pKTsKCQlpZiAoIWNtcCkKCQkJcmV0dXJuIG50aF9wYWNrZWRfb2JqZWN0X29mZnNldChwLCBtaSk7CgkJaWYgKGNtcCA+IDApCgkJCWhpID0gbWk7CgkJZWxzZQoJCQlsbyA9IG1pKzE7Cgl9IHdoaWxlIChsbyA8IGhpKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGZpbmRfcGFja19lbnRyeShjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExLCBzdHJ1Y3QgcGFja19lbnRyeSAqZSkKewoJc3RhdGljIHN0cnVjdCBwYWNrZWRfZ2l0ICpsYXN0X2ZvdW5kID0gKHZvaWQgKikxOwoJc3RydWN0IHBhY2tlZF9naXQgKnA7CglvZmZfdCBvZmZzZXQ7CgoJcHJlcGFyZV9wYWNrZWRfZ2l0KCk7CglpZiAoIXBhY2tlZF9naXQpCgkJcmV0dXJuIDA7CglwID0gKGxhc3RfZm91bmQgPT0gKHZvaWQgKikxKSA/IHBhY2tlZF9naXQgOiBsYXN0X2ZvdW5kOwoKCWRvIHsKCQlpZiAocC0+bnVtX2JhZF9vYmplY3RzKSB7CgkJCXVuc2lnbmVkIGk7CgkJCWZvciAoaSA9IDA7IGkgPCBwLT5udW1fYmFkX29iamVjdHM7IGkrKykKCQkJCWlmICghaGFzaGNtcChzaGExLCBwLT5iYWRfb2JqZWN0X3NoYTEgKyAyMCAqIGkpKQoJCQkJCWdvdG8gbmV4dDsKCQl9CgoJCW9mZnNldCA9IGZpbmRfcGFja19lbnRyeV9vbmUoc2hhMSwgcCk7CgkJaWYgKG9mZnNldCkgewoJCQkvKgoJCQkgKiBXZSBhcmUgYWJvdXQgdG8gdGVsbCB0aGUgY2FsbGVyIHdoZXJlIHRoZXkgY2FuCgkJCSAqIGxvY2F0ZSB0aGUgcmVxdWVzdGVkIG9iamVjdC4gIFdlIGJldHRlciBtYWtlCgkJCSAqIHN1cmUgdGhlIHBhY2tmaWxlIGlzIHN0aWxsIGhlcmUgYW5kIGNhbiBiZQoJCQkgKiBhY2Nlc3NlZCBiZWZvcmUgc3VwcGx5aW5nIHRoYXQgYW5zd2VyLCBhcwoJCQkgKiBpdCBtYXkgaGF2ZSBiZWVuIGRlbGV0ZWQgc2luY2UgdGhlIGluZGV4CgkJCSAqIHdhcyBsb2FkZWQhCgkJCSAqLwoJCQlpZiAocC0+cGFja19mZCA9PSAtMSAmJiBvcGVuX3BhY2tlZF9naXQocCkpIHsKCQkJCWVycm9yKCJwYWNrZmlsZSAlcyBjYW5ub3QgYmUgYWNjZXNzZWQiLCBwLT5wYWNrX25hbWUpOwoJCQkJZ290byBuZXh0OwoJCQl9CgkJCWUtPm9mZnNldCA9IG9mZnNldDsKCQkJZS0+cCA9IHA7CgkJCWhhc2hjcHkoZS0+c2hhMSwgc2hhMSk7CgkJCWxhc3RfZm91bmQgPSBwOwoJCQlyZXR1cm4gMTsKCQl9CgoJCW5leHQ6CgkJaWYgKHAgPT0gbGFzdF9mb3VuZCkKCQkJcCA9IHBhY2tlZF9naXQ7CgkJZWxzZQoJCQlwID0gcC0+bmV4dDsKCQlpZiAocCA9PSBsYXN0X2ZvdW5kKQoJCQlwID0gcC0+bmV4dDsKCX0gd2hpbGUgKHApOwoJcmV0dXJuIDA7Cn0KCnN0cnVjdCBwYWNrZWRfZ2l0ICpmaW5kX3NoYTFfcGFjayhjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExLAoJCQkJICBzdHJ1Y3QgcGFja2VkX2dpdCAqcGFja3MpCnsKCXN0cnVjdCBwYWNrZWRfZ2l0ICpwOwoKCWZvciAocCA9IHBhY2tzOyBwOyBwID0gcC0+bmV4dCkgewoJCWlmIChmaW5kX3BhY2tfZW50cnlfb25lKHNoYTEsIHApKQoJCQlyZXR1cm4gcDsKCX0KCXJldHVybiBOVUxMOwoKfQoKc3RhdGljIGludCBzaGExX2xvb3NlX29iamVjdF9pbmZvKGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEsIHVuc2lnbmVkIGxvbmcgKnNpemVwKQp7CglpbnQgc3RhdHVzOwoJdW5zaWduZWQgbG9uZyBtYXBzaXplLCBzaXplOwoJdm9pZCAqbWFwOwoJel9zdHJlYW0gc3RyZWFtOwoJY2hhciBoZHJbMzJdOwoKCW1hcCA9IG1hcF9zaGExX2ZpbGUoc2hhMSwgJm1hcHNpemUpOwoJaWYgKCFtYXApCgkJcmV0dXJuIGVycm9yKCJ1bmFibGUgdG8gZmluZCAlcyIsIHNoYTFfdG9faGV4KHNoYTEpKTsKCWlmICh1bnBhY2tfc2hhMV9oZWFkZXIoJnN0cmVhbSwgbWFwLCBtYXBzaXplLCBoZHIsIHNpemVvZihoZHIpKSA8IDApCgkJc3RhdHVzID0gZXJyb3IoInVuYWJsZSB0byB1bnBhY2sgJXMgaGVhZGVyIiwKCQkJICAgICAgIHNoYTFfdG9faGV4KHNoYTEpKTsKCWVsc2UgaWYgKChzdGF0dXMgPSBwYXJzZV9zaGExX2hlYWRlcihoZHIsICZzaXplKSkgPCAwKQoJCXN0YXR1cyA9IGVycm9yKCJ1bmFibGUgdG8gcGFyc2UgJXMgaGVhZGVyIiwgc2hhMV90b19oZXgoc2hhMSkpOwoJZWxzZSBpZiAoc2l6ZXApCgkJKnNpemVwID0gc2l6ZTsKCWdpdF9pbmZsYXRlX2VuZCgmc3RyZWFtKTsKCW11bm1hcChtYXAsIG1hcHNpemUpOwoJcmV0dXJuIHN0YXR1czsKfQoKaW50IHNoYTFfb2JqZWN0X2luZm8oY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwgdW5zaWduZWQgbG9uZyAqc2l6ZXApCnsKCXN0cnVjdCBwYWNrX2VudHJ5IGU7CglpbnQgc3RhdHVzOwoKCWlmICghZmluZF9wYWNrX2VudHJ5KHNoYTEsICZlKSkgewoJCS8qIE1vc3QgbGlrZWx5IGl0J3MgYSBsb29zZSBvYmplY3QuICovCgkJc3RhdHVzID0gc2hhMV9sb29zZV9vYmplY3RfaW5mbyhzaGExLCBzaXplcCk7CgkJaWYgKHN0YXR1cyA+PSAwKQoJCQlyZXR1cm4gc3RhdHVzOwoKCQkvKiBOb3QgYSBsb29zZSBvYmplY3Q7IHNvbWVvbmUgZWxzZSBtYXkgaGF2ZSBqdXN0IHBhY2tlZCBpdC4gKi8KCQlyZXByZXBhcmVfcGFja2VkX2dpdCgpOwoJCWlmICghZmluZF9wYWNrX2VudHJ5KHNoYTEsICZlKSkKCQkJcmV0dXJuIHN0YXR1czsKCX0KCglzdGF0dXMgPSBwYWNrZWRfb2JqZWN0X2luZm8oZS5wLCBlLm9mZnNldCwgc2l6ZXApOwoJaWYgKHN0YXR1cyA8IDApIHsKCQltYXJrX2JhZF9wYWNrZWRfb2JqZWN0KGUucCwgc2hhMSk7CgkJc3RhdHVzID0gc2hhMV9vYmplY3RfaW5mbyhzaGExLCBzaXplcCk7Cgl9CgoJcmV0dXJuIHN0YXR1czsKfQoKc3RhdGljIHZvaWQgKnJlYWRfcGFja2VkX3NoYTEoY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwKCQkJICAgICAgZW51bSBvYmplY3RfdHlwZSAqdHlwZSwgdW5zaWduZWQgbG9uZyAqc2l6ZSkKewoJc3RydWN0IHBhY2tfZW50cnkgZTsKCXZvaWQgKmRhdGE7CgoJaWYgKCFmaW5kX3BhY2tfZW50cnkoc2hhMSwgJmUpKQoJCXJldHVybiBOVUxMOwoJZGF0YSA9IGNhY2hlX29yX3VucGFja19lbnRyeShlLnAsIGUub2Zmc2V0LCBzaXplLCB0eXBlLCAxKTsKCWlmICghZGF0YSkgewoJCS8qCgkJICogV2UncmUgcHJvYmFibHkgaW4gZGVlcCBzaGl0LCBidXQgbGV0J3MgdHJ5IHRvIGZldGNoCgkJICogdGhlIHJlcXVpcmVkIG9iamVjdCBhbnl3YXkgZnJvbSBhbm90aGVyIHBhY2sgb3IgbG9vc2UuCgkJICogVGhpcyBzaG91bGQgaGFwcGVuIG9ubHkgaW4gdGhlIHByZXNlbmNlIG9mIGEgY29ycnVwdGVkCgkJICogcGFjaywgYW5kIGlzIGJldHRlciB0aGFuIGZhaWxpbmcgb3V0cmlnaHQuCgkJICovCgkJZXJyb3IoImZhaWxlZCB0byByZWFkIG9iamVjdCAlcyBhdCBvZmZzZXQgJSJQUkl1TUFYIiBmcm9tICVzIiwKCQkgICAgICBzaGExX3RvX2hleChzaGExKSwgKHVpbnRtYXhfdCllLm9mZnNldCwgZS5wLT5wYWNrX25hbWUpOwoJCW1hcmtfYmFkX3BhY2tlZF9vYmplY3QoZS5wLCBzaGExKTsKCQlkYXRhID0gcmVhZF9vYmplY3Qoc2hhMSwgdHlwZSwgc2l6ZSk7Cgl9CglyZXR1cm4gZGF0YTsKfQoKLyoKICogVGhpcyBpcyBtZWFudCB0byBob2xkIGEgKnNtYWxsKiBudW1iZXIgb2Ygb2JqZWN0cyB0aGF0IHlvdSB3b3VsZAogKiB3YW50IHJlYWRfc2hhMV9maWxlKCkgdG8gYmUgYWJsZSB0byByZXR1cm4sIGJ1dCB5ZXQgeW91IGRvIG5vdCB3YW50CiAqIHRvIHdyaXRlIHRoZW0gaW50byB0aGUgb2JqZWN0IHN0b3JlIChlLmcuIGEgYnJvd3NlLW9ubHkKICogYXBwbGljYXRpb24pLgogKi8Kc3RhdGljIHN0cnVjdCBjYWNoZWRfb2JqZWN0IHsKCXVuc2lnbmVkIGNoYXIgc2hhMVsyMF07CgllbnVtIG9iamVjdF90eXBlIHR5cGU7Cgl2b2lkICpidWY7Cgl1bnNpZ25lZCBsb25nIHNpemU7Cn0gKmNhY2hlZF9vYmplY3RzOwpzdGF0aWMgaW50IGNhY2hlZF9vYmplY3RfbnIsIGNhY2hlZF9vYmplY3RfYWxsb2M7CgpzdGF0aWMgc3RydWN0IGNhY2hlZF9vYmplY3QgZW1wdHlfdHJlZSA9IHsKCUVNUFRZX1RSRUVfU0hBMV9CSU4sCglPQkpfVFJFRSwKCSIiLAoJMAp9OwoKc3RhdGljIHN0cnVjdCBjYWNoZWRfb2JqZWN0ICpmaW5kX2NhY2hlZF9vYmplY3QoY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSkKewoJaW50IGk7CglzdHJ1Y3QgY2FjaGVkX29iamVjdCAqY28gPSBjYWNoZWRfb2JqZWN0czsKCglmb3IgKGkgPSAwOyBpIDwgY2FjaGVkX29iamVjdF9ucjsgaSsrLCBjbysrKSB7CgkJaWYgKCFoYXNoY21wKGNvLT5zaGExLCBzaGExKSkKCQkJcmV0dXJuIGNvOwoJfQoJaWYgKCFoYXNoY21wKHNoYTEsIGVtcHR5X3RyZWUuc2hhMSkpCgkJcmV0dXJuICZlbXB0eV90cmVlOwoJcmV0dXJuIE5VTEw7Cn0KCmludCBwcmV0ZW5kX3NoYTFfZmlsZSh2b2lkICpidWYsIHVuc2lnbmVkIGxvbmcgbGVuLCBlbnVtIG9iamVjdF90eXBlIHR5cGUsCgkJICAgICAgdW5zaWduZWQgY2hhciAqc2hhMSkKewoJc3RydWN0IGNhY2hlZF9vYmplY3QgKmNvOwoKCWhhc2hfc2hhMV9maWxlKGJ1ZiwgbGVuLCB0eXBlbmFtZSh0eXBlKSwgc2hhMSk7CglpZiAoaGFzX3NoYTFfZmlsZShzaGExKSB8fCBmaW5kX2NhY2hlZF9vYmplY3Qoc2hhMSkpCgkJcmV0dXJuIDA7CglpZiAoY2FjaGVkX29iamVjdF9hbGxvYyA8PSBjYWNoZWRfb2JqZWN0X25yKSB7CgkJY2FjaGVkX29iamVjdF9hbGxvYyA9IGFsbG9jX25yKGNhY2hlZF9vYmplY3RfYWxsb2MpOwoJCWNhY2hlZF9vYmplY3RzID0geHJlYWxsb2MoY2FjaGVkX29iamVjdHMsCgkJCQkJICBzaXplb2YoKmNhY2hlZF9vYmplY3RzKSAqCgkJCQkJICBjYWNoZWRfb2JqZWN0X2FsbG9jKTsKCX0KCWNvID0gJmNhY2hlZF9vYmplY3RzW2NhY2hlZF9vYmplY3RfbnIrK107Cgljby0+c2l6ZSA9IGxlbjsKCWNvLT50eXBlID0gdHlwZTsKCWNvLT5idWYgPSB4bWFsbG9jKGxlbik7CgltZW1jcHkoY28tPmJ1ZiwgYnVmLCBsZW4pOwoJaGFzaGNweShjby0+c2hhMSwgc2hhMSk7CglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgKnJlYWRfb2JqZWN0KGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEsIGVudW0gb2JqZWN0X3R5cGUgKnR5cGUsCgkJCSB1bnNpZ25lZCBsb25nICpzaXplKQp7Cgl1bnNpZ25lZCBsb25nIG1hcHNpemU7Cgl2b2lkICptYXAsICpidWY7CglzdHJ1Y3QgY2FjaGVkX29iamVjdCAqY287CgoJY28gPSBmaW5kX2NhY2hlZF9vYmplY3Qoc2hhMSk7CglpZiAoY28pIHsKCQkqdHlwZSA9IGNvLT50eXBlOwoJCSpzaXplID0gY28tPnNpemU7CgkJcmV0dXJuIHhtZW1kdXB6KGNvLT5idWYsIGNvLT5zaXplKTsKCX0KCglidWYgPSByZWFkX3BhY2tlZF9zaGExKHNoYTEsIHR5cGUsIHNpemUpOwoJaWYgKGJ1ZikKCQlyZXR1cm4gYnVmOwoJbWFwID0gbWFwX3NoYTFfZmlsZShzaGExLCAmbWFwc2l6ZSk7CglpZiAobWFwKSB7CgkJYnVmID0gdW5wYWNrX3NoYTFfZmlsZShtYXAsIG1hcHNpemUsIHR5cGUsIHNpemUsIHNoYTEpOwoJCW11bm1hcChtYXAsIG1hcHNpemUpOwoJCXJldHVybiBidWY7Cgl9CglyZXByZXBhcmVfcGFja2VkX2dpdCgpOwoJcmV0dXJuIHJlYWRfcGFja2VkX3NoYTEoc2hhMSwgdHlwZSwgc2l6ZSk7Cn0KCnZvaWQgKnJlYWRfc2hhMV9maWxlX3JlcGwoY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwKCQkJICBlbnVtIG9iamVjdF90eXBlICp0eXBlLAoJCQkgIHVuc2lnbmVkIGxvbmcgKnNpemUsCgkJCSAgY29uc3QgdW5zaWduZWQgY2hhciAqKnJlcGxhY2VtZW50KQp7Cgljb25zdCB1bnNpZ25lZCBjaGFyICpyZXBsID0gbG9va3VwX3JlcGxhY2Vfb2JqZWN0KHNoYTEpOwoJdm9pZCAqZGF0YSA9IHJlYWRfb2JqZWN0KHJlcGwsIHR5cGUsIHNpemUpOwoKCS8qIGRpZSBpZiB3ZSByZXBsYWNlZCBhbiBvYmplY3Qgd2l0aCBvbmUgdGhhdCBkb2VzIG5vdCBleGlzdCAqLwoJaWYgKCFkYXRhICYmIHJlcGwgIT0gc2hhMSkKCQlkaWUoInJlcGxhY2VtZW50ICVzIG5vdCBmb3VuZCBmb3IgJXMiLAoJCSAgICBzaGExX3RvX2hleChyZXBsKSwgc2hhMV90b19oZXgoc2hhMSkpOwoKCS8qIGxlZ2FjeSBiZWhhdmlvciBpcyB0byBkaWUgb24gY29ycnVwdGVkIG9iamVjdHMgKi8KCWlmICghZGF0YSAmJiAoaGFzX2xvb3NlX29iamVjdChyZXBsKSB8fCBoYXNfcGFja2VkX2FuZF9iYWQocmVwbCkpKQoJCWRpZSgib2JqZWN0ICVzIGlzIGNvcnJ1cHRlZCIsIHNoYTFfdG9faGV4KHJlcGwpKTsKCglpZiAocmVwbGFjZW1lbnQpCgkJKnJlcGxhY2VtZW50ID0gcmVwbDsKCglyZXR1cm4gZGF0YTsKfQoKdm9pZCAqcmVhZF9vYmplY3Rfd2l0aF9yZWZlcmVuY2UoY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwKCQkJCSBjb25zdCBjaGFyICpyZXF1aXJlZF90eXBlX25hbWUsCgkJCQkgdW5zaWduZWQgbG9uZyAqc2l6ZSwKCQkJCSB1bnNpZ25lZCBjaGFyICphY3R1YWxfc2hhMV9yZXR1cm4pCnsKCWVudW0gb2JqZWN0X3R5cGUgdHlwZSwgcmVxdWlyZWRfdHlwZTsKCXZvaWQgKmJ1ZmZlcjsKCXVuc2lnbmVkIGxvbmcgaXNpemU7Cgl1bnNpZ25lZCBjaGFyIGFjdHVhbF9zaGExWzIwXTsKCglyZXF1aXJlZF90eXBlID0gdHlwZV9mcm9tX3N0cmluZyhyZXF1aXJlZF90eXBlX25hbWUpOwoJaGFzaGNweShhY3R1YWxfc2hhMSwgc2hhMSk7Cgl3aGlsZSAoMSkgewoJCWludCByZWZfbGVuZ3RoID0gLTE7CgkJY29uc3QgY2hhciAqcmVmX3R5cGUgPSBOVUxMOwoKCQlidWZmZXIgPSByZWFkX3NoYTFfZmlsZShhY3R1YWxfc2hhMSwgJnR5cGUsICZpc2l6ZSk7CgkJaWYgKCFidWZmZXIpCgkJCXJldHVybiBOVUxMOwoJCWlmICh0eXBlID09IHJlcXVpcmVkX3R5cGUpIHsKCQkJKnNpemUgPSBpc2l6ZTsKCQkJaWYgKGFjdHVhbF9zaGExX3JldHVybikKCQkJCWhhc2hjcHkoYWN0dWFsX3NoYTFfcmV0dXJuLCBhY3R1YWxfc2hhMSk7CgkJCXJldHVybiBidWZmZXI7CgkJfQoJCS8qIEhhbmRsZSByZWZlcmVuY2VzICovCgkJZWxzZSBpZiAodHlwZSA9PSBPQkpfQ09NTUlUKQoJCQlyZWZfdHlwZSA9ICJ0cmVlICI7CgkJZWxzZSBpZiAodHlwZSA9PSBPQkpfVEFHKQoJCQlyZWZfdHlwZSA9ICJvYmplY3QgIjsKCQllbHNlIHsKCQkJZnJlZShidWZmZXIpOwoJCQlyZXR1cm4gTlVMTDsKCQl9CgkJcmVmX2xlbmd0aCA9IHN0cmxlbihyZWZfdHlwZSk7CgoJCWlmIChyZWZfbGVuZ3RoICsgNDAgPiBpc2l6ZSB8fAoJCSAgICBtZW1jbXAoYnVmZmVyLCByZWZfdHlwZSwgcmVmX2xlbmd0aCkgfHwKCQkgICAgZ2V0X3NoYTFfaGV4KChjaGFyICopIGJ1ZmZlciArIHJlZl9sZW5ndGgsIGFjdHVhbF9zaGExKSkgewoJCQlmcmVlKGJ1ZmZlcik7CgkJCXJldHVybiBOVUxMOwoJCX0KCQlmcmVlKGJ1ZmZlcik7CgkJLyogTm93IHdlIGhhdmUgdGhlIElEIG9mIHRoZSByZWZlcnJlZC10byBvYmplY3QgaW4KCQkgKiBhY3R1YWxfc2hhMS4gIENoZWNrIGFnYWluLiAqLwoJfQp9CgpzdGF0aWMgdm9pZCB3cml0ZV9zaGExX2ZpbGVfcHJlcGFyZShjb25zdCB2b2lkICpidWYsIHVuc2lnbmVkIGxvbmcgbGVuLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGFyICp0eXBlLCB1bnNpZ25lZCBjaGFyICpzaGExLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFyICpoZHIsIGludCAqaGRybGVuKQp7CglnaXRfU0hBX0NUWCBjOwoKCS8qIEdlbmVyYXRlIHRoZSBoZWFkZXIgKi8KCSpoZHJsZW4gPSBzcHJpbnRmKGhkciwgIiVzICVsdSIsIHR5cGUsIGxlbikrMTsKCgkvKiBTaGExLi4gKi8KCWdpdF9TSEExX0luaXQoJmMpOwoJZ2l0X1NIQTFfVXBkYXRlKCZjLCBoZHIsICpoZHJsZW4pOwoJZ2l0X1NIQTFfVXBkYXRlKCZjLCBidWYsIGxlbik7CglnaXRfU0hBMV9GaW5hbChzaGExLCAmYyk7Cn0KCi8qCiAqIE1vdmUgdGhlIGp1c3Qgd3JpdHRlbiBvYmplY3QgaW50byBpdHMgZmluYWwgcmVzdGluZyBwbGFjZS4KICogTkVFRFNXT1JLOiB0aGlzIHNob3VsZCBiZSByZW5hbWVkIHRvIGZpbmFsaXplX3RlbXBfZmlsZSgpIGFzCiAqICJtb3ZpbmciIGlzIG9ubHkgYSBwYXJ0IG9mIHdoYXQgaXQgZG9lcywgd2hlbiBubyBwYXRjaCBiZXR3ZWVuCiAqIG1hc3RlciB0byBwdSBjaGFuZ2VzIHRoZSBjYWxsIHNpdGVzIG9mIHRoaXMgZnVuY3Rpb24uCiAqLwppbnQgbW92ZV90ZW1wX3RvX2ZpbGUoY29uc3QgY2hhciAqdG1wZmlsZSwgY29uc3QgY2hhciAqZmlsZW5hbWUpCnsKCWludCByZXQgPSAwOwoKCWlmIChvYmplY3RfY3JlYXRpb25fbW9kZSA9PSBPQkpFQ1RfQ1JFQVRJT05fVVNFU19SRU5BTUVTKQoJCWdvdG8gdHJ5X3JlbmFtZTsKCWVsc2UgaWYgKGxpbmsodG1wZmlsZSwgZmlsZW5hbWUpKQoJCXJldCA9IGVycm5vOwoKCS8qCgkgKiBDb2RhIGhhY2sgLSBjb2RhIGRvZXNuJ3QgbGlrZSBjcm9zcy1kaXJlY3RvcnkgbGlua3MsCgkgKiBzbyB3ZSBmYWxsIGJhY2sgdG8gYSByZW5hbWUsIHdoaWNoIHdpbGwgbWVhbiB0aGF0IGl0CgkgKiB3b24ndCBiZSBhYmxlIHRvIGNoZWNrIGNvbGxpc2lvbnMsIGJ1dCB0aGF0J3Mgbm90IGEKCSAqIGJpZyBkZWFsLgoJICoKCSAqIFRoZSBzYW1lIGhvbGRzIGZvciBGQVQgZm9ybWF0dGVkIG1lZGlhLgoJICoKCSAqIFdoZW4gdGhpcyBzdWNjZWVkcywgd2UganVzdCByZXR1cm4uICBXZSBoYXZlIG5vdGhpbmcKCSAqIGxlZnQgdG8gdW5saW5rLgoJICovCglpZiAocmV0ICYmIHJldCAhPSBFRVhJU1QpIHsKCXRyeV9yZW5hbWU6CgkJaWYgKCFyZW5hbWUodG1wZmlsZSwgZmlsZW5hbWUpKQoJCQlnb3RvIG91dDsKCQlyZXQgPSBlcnJubzsKCX0KCXVubGlua19vcl93YXJuKHRtcGZpbGUpOwoJaWYgKHJldCkgewoJCWlmIChyZXQgIT0gRUVYSVNUKSB7CgkJCXJldHVybiBlcnJvcigidW5hYmxlIHRvIHdyaXRlIHNoYTEgZmlsZW5hbWUgJXM6ICVzXG4iLCBmaWxlbmFtZSwgc3RyZXJyb3IocmV0KSk7CgkJfQoJCS8qIEZJWE1FISEhIENvbGxpc2lvbiBjaGVjayBoZXJlID8gKi8KCX0KCm91dDoKCWlmIChzZXRfc2hhcmVkX3Blcm0oZmlsZW5hbWUsIChTX0lGUkVHfDA0NDQpKSkKCQlyZXR1cm4gZXJyb3IoInVuYWJsZSB0byBzZXQgcGVybWlzc2lvbiB0byAnJXMnIiwgZmlsZW5hbWUpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgd3JpdGVfYnVmZmVyKGludCBmZCwgY29uc3Qgdm9pZCAqYnVmLCBzaXplX3QgbGVuKQp7CglpZiAod3JpdGVfaW5fZnVsbChmZCwgYnVmLCBsZW4pIDwgMCkKCQlyZXR1cm4gZXJyb3IoImZpbGUgd3JpdGUgZXJyb3IgKCVzKSIsIHN0cmVycm9yKGVycm5vKSk7CglyZXR1cm4gMDsKfQoKaW50IGhhc2hfc2hhMV9maWxlKGNvbnN0IHZvaWQgKmJ1ZiwgdW5zaWduZWQgbG9uZyBsZW4sIGNvbnN0IGNoYXIgKnR5cGUsCiAgICAgICAgICAgICAgICAgICB1bnNpZ25lZCBjaGFyICpzaGExKQp7CgljaGFyIGhkclszMl07CglpbnQgaGRybGVuOwoJd3JpdGVfc2hhMV9maWxlX3ByZXBhcmUoYnVmLCBsZW4sIHR5cGUsIHNoYTEsIGhkciwgJmhkcmxlbik7CglyZXR1cm4gMDsKfQoKLyogRmluYWxpemUgYSBmaWxlIG9uIGRpc2ssIGFuZCBjbG9zZSBpdC4gKi8Kc3RhdGljIHZvaWQgY2xvc2Vfc2hhMV9maWxlKGludCBmZCkKewoJaWYgKGZzeW5jX29iamVjdF9maWxlcykKCQlmc3luY19vcl9kaWUoZmQsICJzaGExIGZpbGUiKTsKCWlmIChjbG9zZShmZCkgIT0gMCkKCQlkaWVfZXJybm8oImVycm9yIHdoZW4gY2xvc2luZyBzaGExIGZpbGUiKTsKfQoKLyogU2l6ZSBvZiBkaXJlY3RvcnkgY29tcG9uZW50LCBpbmNsdWRpbmcgdGhlIGVuZGluZyAnLycgKi8Kc3RhdGljIGlubGluZSBpbnQgZGlyZWN0b3J5X3NpemUoY29uc3QgY2hhciAqZmlsZW5hbWUpCnsKCWNvbnN0IGNoYXIgKnMgPSBzdHJyY2hyKGZpbGVuYW1lLCAnLycpOwoJaWYgKCFzKQoJCXJldHVybiAwOwoJcmV0dXJuIHMgLSBmaWxlbmFtZSArIDE7Cn0KCi8qCiAqIFRoaXMgY3JlYXRlcyBhIHRlbXBvcmFyeSBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeSBhcyB0aGUgZmluYWwKICogJ2ZpbGVuYW1lJwogKgogKiBXZSB3YW50IHRvIGF2b2lkIGNyb3NzLWRpcmVjdG9yeSBmaWxlbmFtZSByZW5hbWVzLCBiZWNhdXNlIHRob3NlCiAqIGNhbiBoYXZlIHByb2JsZW1zIG9uIHZhcmlvdXMgZmlsZXN5c3RlbXMgKEZBVCwgTkZTLCBDb2RhKS4KICovCnN0YXRpYyBpbnQgY3JlYXRlX3RtcGZpbGUoY2hhciAqYnVmZmVyLCBzaXplX3QgYnVmc2l6LCBjb25zdCBjaGFyICpmaWxlbmFtZSkKewoJaW50IGZkLCBkaXJsZW4gPSBkaXJlY3Rvcnlfc2l6ZShmaWxlbmFtZSk7CgoJaWYgKGRpcmxlbiArIDIwID4gYnVmc2l6KSB7CgkJZXJybm8gPSBFTkFNRVRPT0xPTkc7CgkJcmV0dXJuIC0xOwoJfQoJbWVtY3B5KGJ1ZmZlciwgZmlsZW5hbWUsIGRpcmxlbik7CglzdHJjcHkoYnVmZmVyICsgZGlybGVuLCAidG1wX29ial9YWFhYWFgiKTsKCWZkID0gbWtzdGVtcChidWZmZXIpOwoJaWYgKGZkIDwgMCAmJiBkaXJsZW4gJiYgZXJybm8gPT0gRU5PRU5UKSB7CgkJLyogTWFrZSBzdXJlIHRoZSBkaXJlY3RvcnkgZXhpc3RzICovCgkJbWVtY3B5KGJ1ZmZlciwgZmlsZW5hbWUsIGRpcmxlbik7CgkJYnVmZmVyW2Rpcmxlbi0xXSA9IDA7CgkJaWYgKG1rZGlyKGJ1ZmZlciwgMDc3NykgfHwgYWRqdXN0X3NoYXJlZF9wZXJtKGJ1ZmZlcikpCgkJCXJldHVybiAtMTsKCgkJLyogVHJ5IGFnYWluICovCgkJc3RyY3B5KGJ1ZmZlciArIGRpcmxlbiAtIDEsICIvdG1wX29ial9YWFhYWFgiKTsKCQlmZCA9IG1rc3RlbXAoYnVmZmVyKTsKCX0KCXJldHVybiBmZDsKfQoKc3RhdGljIGludCB3cml0ZV9sb29zZV9vYmplY3QoY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwgY2hhciAqaGRyLCBpbnQgaGRybGVuLAoJCQkgICAgICB2b2lkICpidWYsIHVuc2lnbmVkIGxvbmcgbGVuLCB0aW1lX3QgbXRpbWUpCnsKCWludCBmZCwgcmV0OwoJdW5zaWduZWQgY2hhciBjb21wcmVzc2VkWzQwOTZdOwoJel9zdHJlYW0gc3RyZWFtOwoJZ2l0X1NIQV9DVFggYzsKCXVuc2lnbmVkIGNoYXIgcGFyYW5vX3NoYTFbMjBdOwoJY2hhciAqZmlsZW5hbWU7CglzdGF0aWMgY2hhciB0bXBmaWxlW1BBVEhfTUFYXTsKCglmaWxlbmFtZSA9IHNoYTFfZmlsZV9uYW1lKHNoYTEpOwoJZmQgPSBjcmVhdGVfdG1wZmlsZSh0bXBmaWxlLCBzaXplb2YodG1wZmlsZSksIGZpbGVuYW1lKTsKCXdoaWxlIChmZCA8IDAgJiYgZXJybm8gPT0gRU1GSUxFICYmIHVudXNlX29uZV93aW5kb3cocGFja2VkX2dpdCwgLTEpKQoJCWZkID0gY3JlYXRlX3RtcGZpbGUodG1wZmlsZSwgc2l6ZW9mKHRtcGZpbGUpLCBmaWxlbmFtZSk7CglpZiAoZmQgPCAwKSB7CgkJaWYgKGVycm5vID09IEVBQ0NFUykKCQkJcmV0dXJuIGVycm9yKCJpbnN1ZmZpY2llbnQgcGVybWlzc2lvbiBmb3IgYWRkaW5nIGFuIG9iamVjdCB0byByZXBvc2l0b3J5IGRhdGFiYXNlICVzXG4iLCBnZXRfb2JqZWN0X2RpcmVjdG9yeSgpKTsKCQllbHNlCgkJCXJldHVybiBlcnJvcigidW5hYmxlIHRvIGNyZWF0ZSB0ZW1wb3Jhcnkgc2hhMSBmaWxlbmFtZSAlczogJXNcbiIsIHRtcGZpbGUsIHN0cmVycm9yKGVycm5vKSk7Cgl9CgoJLyogU2V0IGl0IHVwICovCgltZW1zZXQoJnN0cmVhbSwgMCwgc2l6ZW9mKHN0cmVhbSkpOwoJZGVmbGF0ZUluaXQoJnN0cmVhbSwgemxpYl9jb21wcmVzc2lvbl9sZXZlbCk7CglzdHJlYW0ubmV4dF9vdXQgPSBjb21wcmVzc2VkOwoJc3RyZWFtLmF2YWlsX291dCA9IHNpemVvZihjb21wcmVzc2VkKTsKCWdpdF9TSEExX0luaXQoJmMpOwoKCS8qIEZpcnN0IGhlYWRlci4uICovCglzdHJlYW0ubmV4dF9pbiA9ICh1bnNpZ25lZCBjaGFyICopaGRyOwoJc3RyZWFtLmF2YWlsX2luID0gaGRybGVuOwoJd2hpbGUgKGRlZmxhdGUoJnN0cmVhbSwgMCkgPT0gWl9PSykKCQkvKiBub3RoaW5nICovOwoJZ2l0X1NIQTFfVXBkYXRlKCZjLCBoZHIsIGhkcmxlbik7CgoJLyogVGhlbiB0aGUgZGF0YSBpdHNlbGYuLiAqLwoJc3RyZWFtLm5leHRfaW4gPSBidWY7CglzdHJlYW0uYXZhaWxfaW4gPSBsZW47CglkbyB7CgkJdW5zaWduZWQgY2hhciAqaW4wID0gc3RyZWFtLm5leHRfaW47CgkJcmV0ID0gZGVmbGF0ZSgmc3RyZWFtLCBaX0ZJTklTSCk7CgkJZ2l0X1NIQTFfVXBkYXRlKCZjLCBpbjAsIHN0cmVhbS5uZXh0X2luIC0gaW4wKTsKCQlpZiAod3JpdGVfYnVmZmVyKGZkLCBjb21wcmVzc2VkLCBzdHJlYW0ubmV4dF9vdXQgLSBjb21wcmVzc2VkKSA8IDApCgkJCWRpZSgidW5hYmxlIHRvIHdyaXRlIHNoYTEgZmlsZSIpOwoJCXN0cmVhbS5uZXh0X291dCA9IGNvbXByZXNzZWQ7CgkJc3RyZWFtLmF2YWlsX291dCA9IHNpemVvZihjb21wcmVzc2VkKTsKCX0gd2hpbGUgKHJldCA9PSBaX09LKTsKCglpZiAocmV0ICE9IFpfU1RSRUFNX0VORCkKCQlkaWUoInVuYWJsZSB0byBkZWZsYXRlIG5ldyBvYmplY3QgJXMgKCVkKSIsIHNoYTFfdG9faGV4KHNoYTEpLCByZXQpOwoJcmV0ID0gZGVmbGF0ZUVuZCgmc3RyZWFtKTsKCWlmIChyZXQgIT0gWl9PSykKCQlkaWUoImRlZmxhdGVFbmQgb24gb2JqZWN0ICVzIGZhaWxlZCAoJWQpIiwgc2hhMV90b19oZXgoc2hhMSksIHJldCk7CglnaXRfU0hBMV9GaW5hbChwYXJhbm9fc2hhMSwgJmMpOwoJaWYgKGhhc2hjbXAoc2hhMSwgcGFyYW5vX3NoYTEpICE9IDApCgkJZGllKCJjb25mdXNlZCBieSB1bnN0YWJsZSBvYmplY3Qgc291cmNlIGRhdGEgZm9yICVzIiwgc2hhMV90b19oZXgoc2hhMSkpOwoKCWNsb3NlX3NoYTFfZmlsZShmZCk7CgoJaWYgKG10aW1lKSB7CgkJc3RydWN0IHV0aW1idWYgdXRiOwoJCXV0Yi5hY3RpbWUgPSBtdGltZTsKCQl1dGIubW9kdGltZSA9IG10aW1lOwoJCWlmICh1dGltZSh0bXBmaWxlLCAmdXRiKSA8IDApCgkJCXdhcm5pbmcoImZhaWxlZCB1dGltZSgpIG9uICVzOiAlcyIsCgkJCQl0bXBmaWxlLCBzdHJlcnJvcihlcnJubykpOwoJfQoKCXJldHVybiBtb3ZlX3RlbXBfdG9fZmlsZSh0bXBmaWxlLCBmaWxlbmFtZSk7Cn0KCmludCB3cml0ZV9zaGExX2ZpbGUodm9pZCAqYnVmLCB1bnNpZ25lZCBsb25nIGxlbiwgY29uc3QgY2hhciAqdHlwZSwgdW5zaWduZWQgY2hhciAqcmV0dXJuc2hhMSkKewoJdW5zaWduZWQgY2hhciBzaGExWzIwXTsKCWNoYXIgaGRyWzMyXTsKCWludCBoZHJsZW47CgoJLyogTm9ybWFsbHkgaWYgd2UgaGF2ZSBpdCBpbiB0aGUgcGFjayB0aGVuIHdlIGRvIG5vdCBib3RoZXIgd3JpdGluZwoJICogaXQgb3V0IGludG8gLmdpdC9vYmplY3RzLz8/Lz97Mzh9IGZpbGUuCgkgKi8KCXdyaXRlX3NoYTFfZmlsZV9wcmVwYXJlKGJ1ZiwgbGVuLCB0eXBlLCBzaGExLCBoZHIsICZoZHJsZW4pOwoJaWYgKHJldHVybnNoYTEpCgkJaGFzaGNweShyZXR1cm5zaGExLCBzaGExKTsKCWlmIChoYXNfc2hhMV9maWxlKHNoYTEpKQoJCXJldHVybiAwOwoJcmV0dXJuIHdyaXRlX2xvb3NlX29iamVjdChzaGExLCBoZHIsIGhkcmxlbiwgYnVmLCBsZW4sIDApOwp9CgppbnQgZm9yY2Vfb2JqZWN0X2xvb3NlKGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEsIHRpbWVfdCBtdGltZSkKewoJdm9pZCAqYnVmOwoJdW5zaWduZWQgbG9uZyBsZW47CgllbnVtIG9iamVjdF90eXBlIHR5cGU7CgljaGFyIGhkclszMl07CglpbnQgaGRybGVuOwoJaW50IHJldDsKCglpZiAoaGFzX2xvb3NlX29iamVjdChzaGExKSkKCQlyZXR1cm4gMDsKCWJ1ZiA9IHJlYWRfcGFja2VkX3NoYTEoc2hhMSwgJnR5cGUsICZsZW4pOwoJaWYgKCFidWYpCgkJcmV0dXJuIGVycm9yKCJjYW5ub3QgcmVhZCBzaGExX2ZpbGUgZm9yICVzIiwgc2hhMV90b19oZXgoc2hhMSkpOwoJaGRybGVuID0gc3ByaW50ZihoZHIsICIlcyAlbHUiLCB0eXBlbmFtZSh0eXBlKSwgbGVuKSArIDE7CglyZXQgPSB3cml0ZV9sb29zZV9vYmplY3Qoc2hhMSwgaGRyLCBoZHJsZW4sIGJ1ZiwgbGVuLCBtdGltZSk7CglmcmVlKGJ1Zik7CgoJcmV0dXJuIHJldDsKfQoKaW50IGhhc19wYWNrX2luZGV4KGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEpCnsKCXN0cnVjdCBzdGF0IHN0OwoJaWYgKHN0YXQoc2hhMV9wYWNrX2luZGV4X25hbWUoc2hhMSksICZzdCkpCgkJcmV0dXJuIDA7CglyZXR1cm4gMTsKfQoKaW50IGhhc19zaGExX3BhY2soY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSkKewoJc3RydWN0IHBhY2tfZW50cnkgZTsKCXJldHVybiBmaW5kX3BhY2tfZW50cnkoc2hhMSwgJmUpOwp9CgppbnQgaGFzX3NoYTFfZmlsZShjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExKQp7CglzdHJ1Y3QgcGFja19lbnRyeSBlOwoKCWlmIChmaW5kX3BhY2tfZW50cnkoc2hhMSwgJmUpKQoJCXJldHVybiAxOwoJcmV0dXJuIGhhc19sb29zZV9vYmplY3Qoc2hhMSk7Cn0KCnN0YXRpYyBpbnQgaW5kZXhfbWVtKHVuc2lnbmVkIGNoYXIgKnNoYTEsIHZvaWQgKmJ1Ziwgc2l6ZV90IHNpemUsCgkJICAgICBpbnQgd3JpdGVfb2JqZWN0LCBlbnVtIG9iamVjdF90eXBlIHR5cGUsIGNvbnN0IGNoYXIgKnBhdGgpCnsKCWludCByZXQsIHJlX2FsbG9jYXRlZCA9IDA7CgoJaWYgKCF0eXBlKQoJCXR5cGUgPSBPQkpfQkxPQjsKCgkvKgoJICogQ29udmVydCBibG9icyB0byBnaXQgaW50ZXJuYWwgZm9ybWF0CgkgKi8KCWlmICgodHlwZSA9PSBPQkpfQkxPQikgJiYgcGF0aCkgewoJCXN0cnVjdCBzdHJidWYgbmJ1ZiA9IFNUUkJVRl9JTklUOwoJCWlmIChjb252ZXJ0X3RvX2dpdChwYXRoLCBidWYsIHNpemUsICZuYnVmLAoJCSAgICAgICAgICAgICAgICAgICB3cml0ZV9vYmplY3QgPyBzYWZlX2NybGYgOiAwKSkgewoJCQlidWYgPSBzdHJidWZfZGV0YWNoKCZuYnVmLCAmc2l6ZSk7CgkJCXJlX2FsbG9jYXRlZCA9IDE7CgkJfQoJfQoKCWlmICh3cml0ZV9vYmplY3QpCgkJcmV0ID0gd3JpdGVfc2hhMV9maWxlKGJ1Ziwgc2l6ZSwgdHlwZW5hbWUodHlwZSksIHNoYTEpOwoJZWxzZQoJCXJldCA9IGhhc2hfc2hhMV9maWxlKGJ1Ziwgc2l6ZSwgdHlwZW5hbWUodHlwZSksIHNoYTEpOwoJaWYgKHJlX2FsbG9jYXRlZCkKCQlmcmVlKGJ1Zik7CglyZXR1cm4gcmV0Owp9CgojZGVmaW5lIFNNQUxMX0ZJTEVfU0laRSAoMzIqMTAyNCkKCmludCBpbmRleF9mZCh1bnNpZ25lZCBjaGFyICpzaGExLCBpbnQgZmQsIHN0cnVjdCBzdGF0ICpzdCwgaW50IHdyaXRlX29iamVjdCwKCSAgICAgZW51bSBvYmplY3RfdHlwZSB0eXBlLCBjb25zdCBjaGFyICpwYXRoKQp7CglpbnQgcmV0OwoJc2l6ZV90IHNpemUgPSB4c2l6ZV90KHN0LT5zdF9zaXplKTsKCglpZiAoIVNfSVNSRUcoc3QtPnN0X21vZGUpKSB7CgkJc3RydWN0IHN0cmJ1ZiBzYnVmID0gU1RSQlVGX0lOSVQ7CgkJaWYgKHN0cmJ1Zl9yZWFkKCZzYnVmLCBmZCwgNDA5NikgPj0gMCkKCQkJcmV0ID0gaW5kZXhfbWVtKHNoYTEsIHNidWYuYnVmLCBzYnVmLmxlbiwgd3JpdGVfb2JqZWN0LAoJCQkJCXR5cGUsIHBhdGgpOwoJCWVsc2UKCQkJcmV0ID0gLTE7CgkJc3RyYnVmX3JlbGVhc2UoJnNidWYpOwoJfSBlbHNlIGlmIChzaXplIDw9IFNNQUxMX0ZJTEVfU0laRSkgewoJCWNoYXIgKmJ1ZiA9IHhtYWxsb2Moc2l6ZSk7CgkJaWYgKHNpemUgPT0gcmVhZF9pbl9mdWxsKGZkLCBidWYsIHNpemUpKQoJCQlyZXQgPSBpbmRleF9tZW0oc2hhMSwgYnVmLCBzaXplLCB3cml0ZV9vYmplY3QsIHR5cGUsCgkJCQkJcGF0aCk7CgkJZWxzZQoJCQlyZXQgPSBlcnJvcigic2hvcnQgcmVhZCAlcyIsIHN0cmVycm9yKGVycm5vKSk7CgkJZnJlZShidWYpOwoJfSBlbHNlIGlmIChzaXplKSB7CgkJdm9pZCAqYnVmID0geG1tYXAoTlVMTCwgc2l6ZSwgUFJPVF9SRUFELCBNQVBfUFJJVkFURSwgZmQsIDApOwoJCXJldCA9IGluZGV4X21lbShzaGExLCBidWYsIHNpemUsIHdyaXRlX29iamVjdCwgdHlwZSwgcGF0aCk7CgkJbXVubWFwKGJ1Ziwgc2l6ZSk7Cgl9IGVsc2UKCQlyZXQgPSBpbmRleF9tZW0oc2hhMSwgTlVMTCwgc2l6ZSwgd3JpdGVfb2JqZWN0LCB0eXBlLCBwYXRoKTsKCWNsb3NlKGZkKTsKCXJldHVybiByZXQ7Cn0KCmludCBpbmRleF9wYXRoKHVuc2lnbmVkIGNoYXIgKnNoYTEsIGNvbnN0IGNoYXIgKnBhdGgsIHN0cnVjdCBzdGF0ICpzdCwgaW50IHdyaXRlX29iamVjdCkKewoJaW50IGZkOwoJc3RydWN0IHN0cmJ1ZiBzYiA9IFNUUkJVRl9JTklUOwoKCXN3aXRjaCAoc3QtPnN0X21vZGUgJiBTX0lGTVQpIHsKCWNhc2UgU19JRlJFRzoKCQlmZCA9IG9wZW4ocGF0aCwgT19SRE9OTFkpOwoJCWlmIChmZCA8IDApCgkJCXJldHVybiBlcnJvcigib3BlbihcIiVzXCIpOiAlcyIsIHBhdGgsCgkJCQkgICAgIHN0cmVycm9yKGVycm5vKSk7CgkJaWYgKGluZGV4X2ZkKHNoYTEsIGZkLCBzdCwgd3JpdGVfb2JqZWN0LCBPQkpfQkxPQiwgcGF0aCkgPCAwKQoJCQlyZXR1cm4gZXJyb3IoIiVzOiBmYWlsZWQgdG8gaW5zZXJ0IGludG8gZGF0YWJhc2UiLAoJCQkJICAgICBwYXRoKTsKCQlicmVhazsKCWNhc2UgU19JRkxOSzoKCQlpZiAoc3RyYnVmX3JlYWRsaW5rKCZzYiwgcGF0aCwgc3QtPnN0X3NpemUpKSB7CgkJCWNoYXIgKmVycnN0ciA9IHN0cmVycm9yKGVycm5vKTsKCQkJcmV0dXJuIGVycm9yKCJyZWFkbGluayhcIiVzXCIpOiAlcyIsIHBhdGgsCgkJCSAgICAgICAgICAgICBlcnJzdHIpOwoJCX0KCQlpZiAoIXdyaXRlX29iamVjdCkKCQkJaGFzaF9zaGExX2ZpbGUoc2IuYnVmLCBzYi5sZW4sIGJsb2JfdHlwZSwgc2hhMSk7CgkJZWxzZSBpZiAod3JpdGVfc2hhMV9maWxlKHNiLmJ1Ziwgc2IubGVuLCBibG9iX3R5cGUsIHNoYTEpKQoJCQlyZXR1cm4gZXJyb3IoIiVzOiBmYWlsZWQgdG8gaW5zZXJ0IGludG8gZGF0YWJhc2UiLAoJCQkJICAgICBwYXRoKTsKCQlzdHJidWZfcmVsZWFzZSgmc2IpOwoJCWJyZWFrOwoJY2FzZSBTX0lGRElSOgoJCXJldHVybiByZXNvbHZlX2dpdGxpbmtfcmVmKHBhdGgsICJIRUFEIiwgc2hhMSk7CglkZWZhdWx0OgoJCXJldHVybiBlcnJvcigiJXM6IHVuc3VwcG9ydGVkIGZpbGUgdHlwZSIsIHBhdGgpOwoJfQoJcmV0dXJuIDA7Cn0KCmludCByZWFkX3BhY2tfaGVhZGVyKGludCBmZCwgc3RydWN0IHBhY2tfaGVhZGVyICpoZWFkZXIpCnsKCWlmIChyZWFkX2luX2Z1bGwoZmQsIGhlYWRlciwgc2l6ZW9mKCpoZWFkZXIpKSA8IHNpemVvZigqaGVhZGVyKSkKCQkvKiAiZW9mIGJlZm9yZSBwYWNrIGhlYWRlciB3YXMgZnVsbHkgcmVhZCIgKi8KCQlyZXR1cm4gUEhfRVJST1JfRU9GOwoKCWlmIChoZWFkZXItPmhkcl9zaWduYXR1cmUgIT0gaHRvbmwoUEFDS19TSUdOQVRVUkUpKQoJCS8qICJwcm90b2NvbCBlcnJvciAocGFjayBzaWduYXR1cmUgbWlzbWF0Y2ggZGV0ZWN0ZWQpIiAqLwoJCXJldHVybiBQSF9FUlJPUl9QQUNLX1NJR05BVFVSRTsKCWlmICghcGFja192ZXJzaW9uX29rKGhlYWRlci0+aGRyX3ZlcnNpb24pKQoJCS8qICJwcm90b2NvbCBlcnJvciAocGFjayB2ZXJzaW9uIHVuc3VwcG9ydGVkKSIgKi8KCQlyZXR1cm4gUEhfRVJST1JfUFJPVE9DT0w7CglyZXR1cm4gMDsKfQo=",
    "text": "/*\n * GIT - The information manager from hell\n *\n * Copyright (C) Linus Torvalds, 2005\n *\n * This handles basic git sha1 object files - packing, unpacking,\n * creation etc.\n */\n#include \"cache.h\"\n#include \"delta.h\"\n#include \"pack.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"tag.h\"\n#include \"tree.h\"\n#include \"refs.h\"\n#include \"pack-revindex.h\"\n#include \"sha1-lookup.h\"\n\n#ifndef O_NOATIME\n#if defined(__linux__) && (defined(__i386__) || defined(__PPC__))\n#define O_NOATIME 01000000\n#else\n#define O_NOATIME 0\n#endif\n#endif\n\n#ifdef NO_C99_FORMAT\n#define SZ_FMT \"lu\"\nstatic unsigned long sz_fmt(size_t s) { return (unsigned long)s; }\n#else\n#define SZ_FMT \"zu\"\nstatic size_t sz_fmt(size_t s) { return s; }\n#endif\n\nconst unsigned char null_sha1[20];\n\nstatic inline int offset_1st_component(const char *path)\n{\n\tif (has_dos_drive_prefix(path))\n\t\treturn 2 + (path[2] == '/');\n\treturn *path == '/';\n}\n\nint safe_create_leading_directories(char *path)\n{\n\tchar *pos = path + offset_1st_component(path);\n\tstruct stat st;\n\n\twhile (pos) {\n\t\tpos = strchr(pos, '/');\n\t\tif (!pos)\n\t\t\tbreak;\n\t\twhile (*++pos == '/')\n\t\t\t;\n\t\tif (!*pos)\n\t\t\tbreak;\n\t\t*--pos = '\\0';\n\t\tif (!stat(path, &st)) {\n\t\t\t/* path exists */\n\t\t\tif (!S_ISDIR(st.st_mode)) {\n\t\t\t\t*pos = '/';\n\t\t\t\treturn -3;\n\t\t\t}\n\t\t}\n\t\telse if (mkdir(path, 0777)) {\n\t\t\t*pos = '/';\n\t\t\treturn -1;\n\t\t}\n\t\telse if (adjust_shared_perm(path)) {\n\t\t\t*pos = '/';\n\t\t\treturn -2;\n\t\t}\n\t\t*pos++ = '/';\n\t}\n\treturn 0;\n}\n\nint safe_create_leading_directories_const(const char *path)\n{\n\t/* path points to cache entries, so xstrdup before messing with it */\n\tchar *buf = xstrdup(path);\n\tint result = safe_create_leading_directories(buf);\n\tfree(buf);\n\treturn result;\n}\n\nstatic void fill_sha1_path(char *pathbuf, const unsigned char *sha1)\n{\n\tint i;\n\tfor (i = 0; i < 20; i++) {\n\t\tstatic char hex[] = \"0123456789abcdef\";\n\t\tunsigned int val = sha1[i];\n\t\tchar *pos = pathbuf + i*2 + (i > 0);\n\t\t*pos++ = hex[val >> 4];\n\t\t*pos = hex[val & 0xf];\n\t}\n}\n\n/*\n * NOTE! This returns a statically allocated buffer, so you have to be\n * careful about using it. Do an \"xstrdup()\" if you need to save the\n * filename.\n *\n * Also note that this returns the location for creating.  Reading\n * SHA1 file can happen from any alternate directory listed in the\n * DB_ENVIRONMENT environment variable if it is not found in\n * the primary object database.\n */\nchar *sha1_file_name(const unsigned char *sha1)\n{\n\tstatic char *name, *base;\n\n\tif (!base) {\n\t\tconst char *sha1_file_directory = get_object_directory();\n\t\tint len = strlen(sha1_file_directory);\n\t\tbase = xmalloc(len + 60);\n\t\tmemcpy(base, sha1_file_directory, len);\n\t\tmemset(base+len, 0, 60);\n\t\tbase[len] = '/';\n\t\tbase[len+3] = '/';\n\t\tname = base + len + 1;\n\t}\n\tfill_sha1_path(name, sha1);\n\treturn base;\n}\n\nstatic char *sha1_get_pack_name(const unsigned char *sha1,\n\t\t\t\tchar **name, char **base, const char *which)\n{\n\tstatic const char hex[] = \"0123456789abcdef\";\n\tchar *buf;\n\tint i;\n\n\tif (!*base) {\n\t\tconst char *sha1_file_directory = get_object_directory();\n\t\tint len = strlen(sha1_file_directory);\n\t\t*base = xmalloc(len + 60);\n\t\tsprintf(*base, \"%s/pack/pack-1234567890123456789012345678901234567890.%s\",\n\t\t\tsha1_file_directory, which);\n\t\t*name = *base + len + 11;\n\t}\n\n\tbuf = *name;\n\n\tfor (i = 0; i < 20; i++) {\n\t\tunsigned int val = *sha1++;\n\t\t*buf++ = hex[val >> 4];\n\t\t*buf++ = hex[val & 0xf];\n\t}\n\n\treturn *base;\n}\n\nchar *sha1_pack_name(const unsigned char *sha1)\n{\n\tstatic char *name, *base;\n\n\treturn sha1_get_pack_name(sha1, &name, &base, \"pack\");\n}\n\nchar *sha1_pack_index_name(const unsigned char *sha1)\n{\n\tstatic char *name, *base;\n\n\treturn sha1_get_pack_name(sha1, &name, &base, \"idx\");\n}\n\nstruct alternate_object_database *alt_odb_list;\nstatic struct alternate_object_database **alt_odb_tail;\n\nstatic void read_info_alternates(const char * alternates, int depth);\n\n/*\n * Prepare alternate object database registry.\n *\n * The variable alt_odb_list points at the list of struct\n * alternate_object_database.  The elements on this list come from\n * non-empty elements from colon separated ALTERNATE_DB_ENVIRONMENT\n * environment variable, and $GIT_OBJECT_DIRECTORY/info/alternates,\n * whose contents is similar to that environment variable but can be\n * LF separated.  Its base points at a statically allocated buffer that\n * contains \"/the/directory/corresponding/to/.git/objects/...\", while\n * its name points just after the slash at the end of \".git/objects/\"\n * in the example above, and has enough space to hold 40-byte hex\n * SHA1, an extra slash for the first level indirection, and the\n * terminating NUL.\n */\nstatic int link_alt_odb_entry(const char * entry, int len, const char * relative_base, int depth)\n{\n\tconst char *objdir = get_object_directory();\n\tstruct alternate_object_database *ent;\n\tstruct alternate_object_database *alt;\n\t/* 43 = 40-byte + 2 '/' + terminating NUL */\n\tint pfxlen = len;\n\tint entlen = pfxlen + 43;\n\tint base_len = -1;\n\n\tif (!is_absolute_path(entry) && relative_base) {\n\t\t/* Relative alt-odb */\n\t\tif (base_len < 0)\n\t\t\tbase_len = strlen(relative_base) + 1;\n\t\tentlen += base_len;\n\t\tpfxlen += base_len;\n\t}\n\tent = xmalloc(sizeof(*ent) + entlen);\n\n\tif (!is_absolute_path(entry) && relative_base) {\n\t\tmemcpy(ent->base, relative_base, base_len - 1);\n\t\tent->base[base_len - 1] = '/';\n\t\tmemcpy(ent->base + base_len, entry, len);\n\t}\n\telse\n\t\tmemcpy(ent->base, entry, pfxlen);\n\n\tent->name = ent->base + pfxlen + 1;\n\tent->base[pfxlen + 3] = '/';\n\tent->base[pfxlen] = ent->base[entlen-1] = 0;\n\n\t/* Detect cases where alternate disappeared */\n\tif (!is_directory(ent->base)) {\n\t\terror(\"object directory %s does not exist; \"\n\t\t      \"check .git/objects/info/alternates.\",\n\t\t      ent->base);\n\t\tfree(ent);\n\t\treturn -1;\n\t}\n\n\t/* Prevent the common mistake of listing the same\n\t * thing twice, or object directory itself.\n\t */\n\tfor (alt = alt_odb_list; alt; alt = alt->next) {\n\t\tif (!memcmp(ent->base, alt->base, pfxlen)) {\n\t\t\tfree(ent);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (!memcmp(ent->base, objdir, pfxlen)) {\n\t\tfree(ent);\n\t\treturn -1;\n\t}\n\n\t/* add the alternate entry */\n\t*alt_odb_tail = ent;\n\talt_odb_tail = &(ent->next);\n\tent->next = NULL;\n\n\t/* recursively add alternates */\n\tread_info_alternates(ent->base, depth + 1);\n\n\tent->base[pfxlen] = '/';\n\n\treturn 0;\n}\n\nstatic void link_alt_odb_entries(const char *alt, const char *ep, int sep,\n\t\t\t\t const char *relative_base, int depth)\n{\n\tconst char *cp, *last;\n\n\tif (depth > 5) {\n\t\terror(\"%s: ignoring alternate object stores, nesting too deep.\",\n\t\t\t\trelative_base);\n\t\treturn;\n\t}\n\n\tlast = alt;\n\twhile (last < ep) {\n\t\tcp = last;\n\t\tif (cp < ep && *cp == '#') {\n\t\t\twhile (cp < ep && *cp != sep)\n\t\t\t\tcp++;\n\t\t\tlast = cp + 1;\n\t\t\tcontinue;\n\t\t}\n\t\twhile (cp < ep && *cp != sep)\n\t\t\tcp++;\n\t\tif (last != cp) {\n\t\t\tif (!is_absolute_path(last) && depth) {\n\t\t\t\terror(\"%s: ignoring relative alternate object store %s\",\n\t\t\t\t\t\trelative_base, last);\n\t\t\t} else {\n\t\t\t\tlink_alt_odb_entry(last, cp - last,\n\t\t\t\t\t\trelative_base, depth);\n\t\t\t}\n\t\t}\n\t\twhile (cp < ep && *cp == sep)\n\t\t\tcp++;\n\t\tlast = cp;\n\t}\n}\n\nstatic void read_info_alternates(const char * relative_base, int depth)\n{\n\tchar *map;\n\tsize_t mapsz;\n\tstruct stat st;\n\tconst char alt_file_name[] = \"info/alternates\";\n\t/* Given that relative_base is no longer than PATH_MAX,\n\t   ensure that \"path\" has enough space to append \"/\", the\n\t   file name, \"info/alternates\", and a trailing NUL.  */\n\tchar path[PATH_MAX + 1 + sizeof alt_file_name];\n\tint fd;\n\n\tsprintf(path, \"%s/%s\", relative_base, alt_file_name);\n\tfd = open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn;\n\tif (fstat(fd, &st) || (st.st_size == 0)) {\n\t\tclose(fd);\n\t\treturn;\n\t}\n\tmapsz = xsize_t(st.st_size);\n\tmap = xmmap(NULL, mapsz, PROT_READ, MAP_PRIVATE, fd, 0);\n\tclose(fd);\n\n\tlink_alt_odb_entries(map, map + mapsz, '\\n', relative_base, depth);\n\n\tmunmap(map, mapsz);\n}\n\nvoid add_to_alternates_file(const char *reference)\n{\n\tstruct lock_file *lock = xcalloc(1, sizeof(struct lock_file));\n\tint fd = hold_lock_file_for_append(lock, git_path(\"objects/info/alternates\"), LOCK_DIE_ON_ERROR);\n\tchar *alt = mkpath(\"%s/objects\\n\", reference);\n\twrite_or_die(fd, alt, strlen(alt));\n\tif (commit_lock_file(lock))\n\t\tdie(\"could not close alternates file\");\n\tif (alt_odb_tail)\n\t\tlink_alt_odb_entries(alt, alt + strlen(alt), '\\n', NULL, 0);\n}\n\nvoid foreach_alt_odb(alt_odb_fn fn, void *cb)\n{\n\tstruct alternate_object_database *ent;\n\n\tprepare_alt_odb();\n\tfor (ent = alt_odb_list; ent; ent = ent->next)\n\t\tif (fn(ent, cb))\n\t\t\treturn;\n}\n\nvoid prepare_alt_odb(void)\n{\n\tconst char *alt;\n\n\tif (alt_odb_tail)\n\t\treturn;\n\n\talt = getenv(ALTERNATE_DB_ENVIRONMENT);\n\tif (!alt) alt = \"\";\n\n\talt_odb_tail = &alt_odb_list;\n\tlink_alt_odb_entries(alt, alt + strlen(alt), PATH_SEP, NULL, 0);\n\n\tread_info_alternates(get_object_directory(), 0);\n}\n\nstatic int has_loose_object_local(const unsigned char *sha1)\n{\n\tchar *name = sha1_file_name(sha1);\n\treturn !access(name, F_OK);\n}\n\nint has_loose_object_nonlocal(const unsigned char *sha1)\n{\n\tstruct alternate_object_database *alt;\n\tprepare_alt_odb();\n\tfor (alt = alt_odb_list; alt; alt = alt->next) {\n\t\tfill_sha1_path(alt->name, sha1);\n\t\tif (!access(alt->base, F_OK))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int has_loose_object(const unsigned char *sha1)\n{\n\treturn has_loose_object_local(sha1) ||\n\t       has_loose_object_nonlocal(sha1);\n}\n\nstatic unsigned int pack_used_ctr;\nstatic unsigned int pack_mmap_calls;\nstatic unsigned int peak_pack_open_windows;\nstatic unsigned int pack_open_windows;\nstatic size_t peak_pack_mapped;\nstatic size_t pack_mapped;\nstruct packed_git *packed_git;\n\nvoid pack_report(void)\n{\n\tfprintf(stderr,\n\t\t\"pack_report: getpagesize()            = %10\" SZ_FMT \"\\n\"\n\t\t\"pack_report: core.packedGitWindowSize = %10\" SZ_FMT \"\\n\"\n\t\t\"pack_report: core.packedGitLimit      = %10\" SZ_FMT \"\\n\",\n\t\tsz_fmt(getpagesize()),\n\t\tsz_fmt(packed_git_window_size),\n\t\tsz_fmt(packed_git_limit));\n\tfprintf(stderr,\n\t\t\"pack_report: pack_used_ctr            = %10u\\n\"\n\t\t\"pack_report: pack_mmap_calls          = %10u\\n\"\n\t\t\"pack_report: pack_open_windows        = %10u / %10u\\n\"\n\t\t\"pack_report: pack_mapped              = \"\n\t\t\t\"%10\" SZ_FMT \" / %10\" SZ_FMT \"\\n\",\n\t\tpack_used_ctr,\n\t\tpack_mmap_calls,\n\t\tpack_open_windows, peak_pack_open_windows,\n\t\tsz_fmt(pack_mapped), sz_fmt(peak_pack_mapped));\n}\n\nstatic int check_packed_git_idx(const char *path,  struct packed_git *p)\n{\n\tvoid *idx_map;\n\tstruct pack_idx_header *hdr;\n\tsize_t idx_size;\n\tuint32_t version, nr, i, *index;\n\tint fd = open(path, O_RDONLY);\n\tstruct stat st;\n\n\tif (fd < 0)\n\t\treturn -1;\n\tif (fstat(fd, &st)) {\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tidx_size = xsize_t(st.st_size);\n\tif (idx_size < 4 * 256 + 20 + 20) {\n\t\tclose(fd);\n\t\treturn error(\"index file %s is too small\", path);\n\t}\n\tidx_map = xmmap(NULL, idx_size, PROT_READ, MAP_PRIVATE, fd, 0);\n\tclose(fd);\n\n\thdr = idx_map;\n\tif (hdr->idx_signature == htonl(PACK_IDX_SIGNATURE)) {\n\t\tversion = ntohl(hdr->idx_version);\n\t\tif (version < 2 || version > 2) {\n\t\t\tmunmap(idx_map, idx_size);\n\t\t\treturn error(\"index file %s is version %\"PRIu32\n\t\t\t\t     \" and is not supported by this binary\"\n\t\t\t\t     \" (try upgrading GIT to a newer version)\",\n\t\t\t\t     path, version);\n\t\t}\n\t} else\n\t\tversion = 1;\n\n\tnr = 0;\n\tindex = idx_map;\n\tif (version > 1)\n\t\tindex += 2;  /* skip index header */\n\tfor (i = 0; i < 256; i++) {\n\t\tuint32_t n = ntohl(index[i]);\n\t\tif (n < nr) {\n\t\t\tmunmap(idx_map, idx_size);\n\t\t\treturn error(\"non-monotonic index %s\", path);\n\t\t}\n\t\tnr = n;\n\t}\n\n\tif (version == 1) {\n\t\t/*\n\t\t * Total size:\n\t\t *  - 256 index entries 4 bytes each\n\t\t *  - 24-byte entries * nr (20-byte sha1 + 4-byte offset)\n\t\t *  - 20-byte SHA1 of the packfile\n\t\t *  - 20-byte SHA1 file checksum\n\t\t */\n\t\tif (idx_size != 4*256 + nr * 24 + 20 + 20) {\n\t\t\tmunmap(idx_map, idx_size);\n\t\t\treturn error(\"wrong index v1 file size in %s\", path);\n\t\t}\n\t} else if (version == 2) {\n\t\t/*\n\t\t * Minimum size:\n\t\t *  - 8 bytes of header\n\t\t *  - 256 index entries 4 bytes each\n\t\t *  - 20-byte sha1 entry * nr\n\t\t *  - 4-byte crc entry * nr\n\t\t *  - 4-byte offset entry * nr\n\t\t *  - 20-byte SHA1 of the packfile\n\t\t *  - 20-byte SHA1 file checksum\n\t\t * And after the 4-byte offset table might be a\n\t\t * variable sized table containing 8-byte entries\n\t\t * for offsets larger than 2^31.\n\t\t */\n\t\tunsigned long min_size = 8 + 4*256 + nr*(20 + 4 + 4) + 20 + 20;\n\t\tunsigned long max_size = min_size;\n\t\tif (nr)\n\t\t\tmax_size += (nr - 1)*8;\n\t\tif (idx_size < min_size || idx_size > max_size) {\n\t\t\tmunmap(idx_map, idx_size);\n\t\t\treturn error(\"wrong index v2 file size in %s\", path);\n\t\t}\n\t\tif (idx_size != min_size &&\n\t\t    /*\n\t\t     * make sure we can deal with large pack offsets.\n\t\t     * 31-bit signed offset won't be enough, neither\n\t\t     * 32-bit unsigned one will be.\n\t\t     */\n\t\t    (sizeof(off_t) <= 4)) {\n\t\t\tmunmap(idx_map, idx_size);\n\t\t\treturn error(\"pack too large for current definition of off_t in %s\", path);\n\t\t}\n\t}\n\n\tp->index_version = version;\n\tp->index_data = idx_map;\n\tp->index_size = idx_size;\n\tp->num_objects = nr;\n\treturn 0;\n}\n\nint open_pack_index(struct packed_git *p)\n{\n\tchar *idx_name;\n\tint ret;\n\n\tif (p->index_data)\n\t\treturn 0;\n\n\tidx_name = xstrdup(p->pack_name);\n\tstrcpy(idx_name + strlen(idx_name) - strlen(\".pack\"), \".idx\");\n\tret = check_packed_git_idx(idx_name, p);\n\tfree(idx_name);\n\treturn ret;\n}\n\nstatic void scan_windows(struct packed_git *p,\n\tstruct packed_git **lru_p,\n\tstruct pack_window **lru_w,\n\tstruct pack_window **lru_l)\n{\n\tstruct pack_window *w, *w_l;\n\n\tfor (w_l = NULL, w = p->windows; w; w = w->next) {\n\t\tif (!w->inuse_cnt) {\n\t\t\tif (!*lru_w || w->last_used < (*lru_w)->last_used) {\n\t\t\t\t*lru_p = p;\n\t\t\t\t*lru_w = w;\n\t\t\t\t*lru_l = w_l;\n\t\t\t}\n\t\t}\n\t\tw_l = w;\n\t}\n}\n\nstatic int unuse_one_window(struct packed_git *current, int keep_fd)\n{\n\tstruct packed_git *p, *lru_p = NULL;\n\tstruct pack_window *lru_w = NULL, *lru_l = NULL;\n\n\tif (current)\n\t\tscan_windows(current, &lru_p, &lru_w, &lru_l);\n\tfor (p = packed_git; p; p = p->next)\n\t\tscan_windows(p, &lru_p, &lru_w, &lru_l);\n\tif (lru_p) {\n\t\tmunmap(lru_w->base, lru_w->len);\n\t\tpack_mapped -= lru_w->len;\n\t\tif (lru_l)\n\t\t\tlru_l->next = lru_w->next;\n\t\telse {\n\t\t\tlru_p->windows = lru_w->next;\n\t\t\tif (!lru_p->windows && lru_p->pack_fd != keep_fd) {\n\t\t\t\tclose(lru_p->pack_fd);\n\t\t\t\tlru_p->pack_fd = -1;\n\t\t\t}\n\t\t}\n\t\tfree(lru_w);\n\t\tpack_open_windows--;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nvoid release_pack_memory(size_t need, int fd)\n{\n\tsize_t cur = pack_mapped;\n\twhile (need >= (cur - pack_mapped) && unuse_one_window(NULL, fd))\n\t\t; /* nothing */\n}\n\nvoid close_pack_windows(struct packed_git *p)\n{\n\twhile (p->windows) {\n\t\tstruct pack_window *w = p->windows;\n\n\t\tif (w->inuse_cnt)\n\t\t\tdie(\"pack '%s' still has open windows to it\",\n\t\t\t    p->pack_name);\n\t\tmunmap(w->base, w->len);\n\t\tpack_mapped -= w->len;\n\t\tpack_open_windows--;\n\t\tp->windows = w->next;\n\t\tfree(w);\n\t}\n}\n\nvoid unuse_pack(struct pack_window **w_cursor)\n{\n\tstruct pack_window *w = *w_cursor;\n\tif (w) {\n\t\tw->inuse_cnt--;\n\t\t*w_cursor = NULL;\n\t}\n}\n\n/*\n * This is used by git-repack in case a newly created pack happens to\n * contain the same set of objects as an existing one.  In that case\n * the resulting file might be different even if its name would be the\n * same.  It is best to close any reference to the old pack before it is\n * replaced on disk.  Of course no index pointers nor windows for given pack\n * must subsist at this point.  If ever objects from this pack are requested\n * again, the new version of the pack will be reinitialized through\n * reprepare_packed_git().\n */\nvoid free_pack_by_name(const char *pack_name)\n{\n\tstruct packed_git *p, **pp = &packed_git;\n\n\twhile (*pp) {\n\t\tp = *pp;\n\t\tif (strcmp(pack_name, p->pack_name) == 0) {\n\t\t\tclear_delta_base_cache();\n\t\t\tclose_pack_windows(p);\n\t\t\tif (p->pack_fd != -1)\n\t\t\t\tclose(p->pack_fd);\n\t\t\tif (p->index_data)\n\t\t\t\tmunmap((void *)p->index_data, p->index_size);\n\t\t\tfree(p->bad_object_sha1);\n\t\t\t*pp = p->next;\n\t\t\tfree(p);\n\t\t\treturn;\n\t\t}\n\t\tpp = &p->next;\n\t}\n}\n\n/*\n * Do not call this directly as this leaks p->pack_fd on error return;\n * call open_packed_git() instead.\n */\nstatic int open_packed_git_1(struct packed_git *p)\n{\n\tstruct stat st;\n\tstruct pack_header hdr;\n\tunsigned char sha1[20];\n\tunsigned char *idx_sha1;\n\tlong fd_flag;\n\n\tif (!p->index_data && open_pack_index(p))\n\t\treturn error(\"packfile %s index unavailable\", p->pack_name);\n\n\tp->pack_fd = open(p->pack_name, O_RDONLY);\n\twhile (p->pack_fd < 0 && errno == EMFILE && unuse_one_window(p, -1))\n\t\tp->pack_fd = open(p->pack_name, O_RDONLY);\n\tif (p->pack_fd < 0 || fstat(p->pack_fd, &st))\n\t\treturn -1;\n\n\t/* If we created the struct before we had the pack we lack size. */\n\tif (!p->pack_size) {\n\t\tif (!S_ISREG(st.st_mode))\n\t\t\treturn error(\"packfile %s not a regular file\", p->pack_name);\n\t\tp->pack_size = st.st_size;\n\t} else if (p->pack_size != st.st_size)\n\t\treturn error(\"packfile %s size changed\", p->pack_name);\n\n\t/* We leave these file descriptors open with sliding mmap;\n\t * there is no point keeping them open across exec(), though.\n\t */\n\tfd_flag = fcntl(p->pack_fd, F_GETFD, 0);\n\tif (fd_flag < 0)\n\t\treturn error(\"cannot determine file descriptor flags\");\n\tfd_flag |= FD_CLOEXEC;\n\tif (fcntl(p->pack_fd, F_SETFD, fd_flag) == -1)\n\t\treturn error(\"cannot set FD_CLOEXEC\");\n\n\t/* Verify we recognize this pack file format. */\n\tif (read_in_full(p->pack_fd, &hdr, sizeof(hdr)) != sizeof(hdr))\n\t\treturn error(\"file %s is far too short to be a packfile\", p->pack_name);\n\tif (hdr.hdr_signature != htonl(PACK_SIGNATURE))\n\t\treturn error(\"file %s is not a GIT packfile\", p->pack_name);\n\tif (!pack_version_ok(hdr.hdr_version))\n\t\treturn error(\"packfile %s is version %\"PRIu32\" and not\"\n\t\t\t\" supported (try upgrading GIT to a newer version)\",\n\t\t\tp->pack_name, ntohl(hdr.hdr_version));\n\n\t/* Verify the pack matches its index. */\n\tif (p->num_objects != ntohl(hdr.hdr_entries))\n\t\treturn error(\"packfile %s claims to have %\"PRIu32\" objects\"\n\t\t\t     \" while index indicates %\"PRIu32\" objects\",\n\t\t\t     p->pack_name, ntohl(hdr.hdr_entries),\n\t\t\t     p->num_objects);\n\tif (lseek(p->pack_fd, p->pack_size - sizeof(sha1), SEEK_SET) == -1)\n\t\treturn error(\"end of packfile %s is unavailable\", p->pack_name);\n\tif (read_in_full(p->pack_fd, sha1, sizeof(sha1)) != sizeof(sha1))\n\t\treturn error(\"packfile %s signature is unavailable\", p->pack_name);\n\tidx_sha1 = ((unsigned char *)p->index_data) + p->index_size - 40;\n\tif (hashcmp(sha1, idx_sha1))\n\t\treturn error(\"packfile %s does not match index\", p->pack_name);\n\treturn 0;\n}\n\nstatic int open_packed_git(struct packed_git *p)\n{\n\tif (!open_packed_git_1(p))\n\t\treturn 0;\n\tif (p->pack_fd != -1) {\n\t\tclose(p->pack_fd);\n\t\tp->pack_fd = -1;\n\t}\n\treturn -1;\n}\n\nstatic int in_window(struct pack_window *win, off_t offset)\n{\n\t/* We must promise at least 20 bytes (one hash) after the\n\t * offset is available from this window, otherwise the offset\n\t * is not actually in this window and a different window (which\n\t * has that one hash excess) must be used.  This is to support\n\t * the object header and delta base parsing routines below.\n\t */\n\toff_t win_off = win->offset;\n\treturn win_off <= offset\n\t\t&& (offset + 20) <= (win_off + win->len);\n}\n\nunsigned char *use_pack(struct packed_git *p,\n\t\tstruct pack_window **w_cursor,\n\t\toff_t offset,\n\t\tunsigned int *left)\n{\n\tstruct pack_window *win = *w_cursor;\n\n\tif (p->pack_fd == -1 && open_packed_git(p))\n\t\tdie(\"packfile %s cannot be accessed\", p->pack_name);\n\n\t/* Since packfiles end in a hash of their content and it's\n\t * pointless to ask for an offset into the middle of that\n\t * hash, and the in_window function above wouldn't match\n\t * don't allow an offset too close to the end of the file.\n\t */\n\tif (offset > (p->pack_size - 20))\n\t\tdie(\"offset beyond end of packfile (truncated pack?)\");\n\n\tif (!win || !in_window(win, offset)) {\n\t\tif (win)\n\t\t\twin->inuse_cnt--;\n\t\tfor (win = p->windows; win; win = win->next) {\n\t\t\tif (in_window(win, offset))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!win) {\n\t\t\tsize_t window_align = packed_git_window_size / 2;\n\t\t\toff_t len;\n\t\t\twin = xcalloc(1, sizeof(*win));\n\t\t\twin->offset = (offset / window_align) * window_align;\n\t\t\tlen = p->pack_size - win->offset;\n\t\t\tif (len > packed_git_window_size)\n\t\t\t\tlen = packed_git_window_size;\n\t\t\twin->len = (size_t)len;\n\t\t\tpack_mapped += win->len;\n\t\t\twhile (packed_git_limit < pack_mapped\n\t\t\t\t&& unuse_one_window(p, p->pack_fd))\n\t\t\t\t; /* nothing */\n\t\t\twin->base = xmmap(NULL, win->len,\n\t\t\t\tPROT_READ, MAP_PRIVATE,\n\t\t\t\tp->pack_fd, win->offset);\n\t\t\tif (win->base == MAP_FAILED)\n\t\t\t\tdie(\"packfile %s cannot be mapped: %s\",\n\t\t\t\t\tp->pack_name,\n\t\t\t\t\tstrerror(errno));\n\t\t\tpack_mmap_calls++;\n\t\t\tpack_open_windows++;\n\t\t\tif (pack_mapped > peak_pack_mapped)\n\t\t\t\tpeak_pack_mapped = pack_mapped;\n\t\t\tif (pack_open_windows > peak_pack_open_windows)\n\t\t\t\tpeak_pack_open_windows = pack_open_windows;\n\t\t\twin->next = p->windows;\n\t\t\tp->windows = win;\n\t\t}\n\t}\n\tif (win != *w_cursor) {\n\t\twin->last_used = pack_used_ctr++;\n\t\twin->inuse_cnt++;\n\t\t*w_cursor = win;\n\t}\n\toffset -= win->offset;\n\tif (left)\n\t\t*left = win->len - xsize_t(offset);\n\treturn win->base + offset;\n}\n\nstatic struct packed_git *alloc_packed_git(int extra)\n{\n\tstruct packed_git *p = xmalloc(sizeof(*p) + extra);\n\tmemset(p, 0, sizeof(*p));\n\tp->pack_fd = -1;\n\treturn p;\n}\n\nstruct packed_git *add_packed_git(const char *path, int path_len, int local)\n{\n\tstruct stat st;\n\tstruct packed_git *p = alloc_packed_git(path_len + 2);\n\n\t/*\n\t * Make sure a corresponding .pack file exists and that\n\t * the index looks sane.\n\t */\n\tpath_len -= strlen(\".idx\");\n\tif (path_len < 1) {\n\t\tfree(p);\n\t\treturn NULL;\n\t}\n\tmemcpy(p->pack_name, path, path_len);\n\n\tstrcpy(p->pack_name + path_len, \".keep\");\n\tif (!access(p->pack_name, F_OK))\n\t\tp->pack_keep = 1;\n\n\tstrcpy(p->pack_name + path_len, \".pack\");\n\tif (stat(p->pack_name, &st) || !S_ISREG(st.st_mode)) {\n\t\tfree(p);\n\t\treturn NULL;\n\t}\n\n\t/* ok, it looks sane as far as we can check without\n\t * actually mapping the pack file.\n\t */\n\tp->pack_size = st.st_size;\n\tp->pack_local = local;\n\tp->mtime = st.st_mtime;\n\tif (path_len < 40 || get_sha1_hex(path + path_len - 40, p->sha1))\n\t\thashclr(p->sha1);\n\treturn p;\n}\n\nstruct packed_git *parse_pack_index(unsigned char *sha1)\n{\n\tconst char *idx_path = sha1_pack_index_name(sha1);\n\tconst char *path = sha1_pack_name(sha1);\n\tstruct packed_git *p = alloc_packed_git(strlen(path) + 1);\n\n\tstrcpy(p->pack_name, path);\n\thashcpy(p->sha1, sha1);\n\tif (check_packed_git_idx(idx_path, p)) {\n\t\tfree(p);\n\t\treturn NULL;\n\t}\n\n\treturn p;\n}\n\nvoid install_packed_git(struct packed_git *pack)\n{\n\tpack->next = packed_git;\n\tpacked_git = pack;\n}\n\nstatic void prepare_packed_git_one(char *objdir, int local)\n{\n\t/* Ensure that this buffer is large enough so that we can\n\t   append \"/pack/\" without clobbering the stack even if\n\t   strlen(objdir) were PATH_MAX.  */\n\tchar path[PATH_MAX + 1 + 4 + 1 + 1];\n\tint len;\n\tDIR *dir;\n\tstruct dirent *de;\n\n\tsprintf(path, \"%s/pack\", objdir);\n\tlen = strlen(path);\n\tdir = opendir(path);\n\twhile (!dir && errno == EMFILE && unuse_one_window(packed_git, -1))\n\t\tdir = opendir(path);\n\tif (!dir) {\n\t\tif (errno != ENOENT)\n\t\t\terror(\"unable to open object pack directory: %s: %s\",\n\t\t\t      path, strerror(errno));\n\t\treturn;\n\t}\n\tpath[len++] = '/';\n\twhile ((de = readdir(dir)) != NULL) {\n\t\tint namelen = strlen(de->d_name);\n\t\tstruct packed_git *p;\n\n\t\tif (!has_extension(de->d_name, \".idx\"))\n\t\t\tcontinue;\n\n\t\tif (len + namelen + 1 > sizeof(path))\n\t\t\tcontinue;\n\n\t\t/* Don't reopen a pack we already have. */\n\t\tstrcpy(path + len, de->d_name);\n\t\tfor (p = packed_git; p; p = p->next) {\n\t\t\tif (!memcmp(path, p->pack_name, len + namelen - 4))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (p)\n\t\t\tcontinue;\n\t\t/* See if it really is a valid .idx file with corresponding\n\t\t * .pack file that we can map.\n\t\t */\n\t\tp = add_packed_git(path, len + namelen, local);\n\t\tif (!p)\n\t\t\tcontinue;\n\t\tinstall_packed_git(p);\n\t}\n\tclosedir(dir);\n}\n\nstatic int sort_pack(const void *a_, const void *b_)\n{\n\tstruct packed_git *a = *((struct packed_git **)a_);\n\tstruct packed_git *b = *((struct packed_git **)b_);\n\tint st;\n\n\t/*\n\t * Local packs tend to contain objects specific to our\n\t * variant of the project than remote ones.  In addition,\n\t * remote ones could be on a network mounted filesystem.\n\t * Favor local ones for these reasons.\n\t */\n\tst = a->pack_local - b->pack_local;\n\tif (st)\n\t\treturn -st;\n\n\t/*\n\t * Younger packs tend to contain more recent objects,\n\t * and more recent objects tend to get accessed more\n\t * often.\n\t */\n\tif (a->mtime < b->mtime)\n\t\treturn 1;\n\telse if (a->mtime == b->mtime)\n\t\treturn 0;\n\treturn -1;\n}\n\nstatic void rearrange_packed_git(void)\n{\n\tstruct packed_git **ary, *p;\n\tint i, n;\n\n\tfor (n = 0, p = packed_git; p; p = p->next)\n\t\tn++;\n\tif (n < 2)\n\t\treturn;\n\n\t/* prepare an array of packed_git for easier sorting */\n\tary = xcalloc(n, sizeof(struct packed_git *));\n\tfor (n = 0, p = packed_git; p; p = p->next)\n\t\tary[n++] = p;\n\n\tqsort(ary, n, sizeof(struct packed_git *), sort_pack);\n\n\t/* link them back again */\n\tfor (i = 0; i < n - 1; i++)\n\t\tary[i]->next = ary[i + 1];\n\tary[n - 1]->next = NULL;\n\tpacked_git = ary[0];\n\n\tfree(ary);\n}\n\nstatic int prepare_packed_git_run_once = 0;\nvoid prepare_packed_git(void)\n{\n\tstruct alternate_object_database *alt;\n\n\tif (prepare_packed_git_run_once)\n\t\treturn;\n\tprepare_packed_git_one(get_object_directory(), 1);\n\tprepare_alt_odb();\n\tfor (alt = alt_odb_list; alt; alt = alt->next) {\n\t\talt->name[-1] = 0;\n\t\tprepare_packed_git_one(alt->base, 0);\n\t\talt->name[-1] = '/';\n\t}\n\trearrange_packed_git();\n\tprepare_packed_git_run_once = 1;\n}\n\nvoid reprepare_packed_git(void)\n{\n\tdiscard_revindex();\n\tprepare_packed_git_run_once = 0;\n\tprepare_packed_git();\n}\n\nstatic void mark_bad_packed_object(struct packed_git *p,\n\t\t\t\t   const unsigned char *sha1)\n{\n\tunsigned i;\n\tfor (i = 0; i < p->num_bad_objects; i++)\n\t\tif (!hashcmp(sha1, p->bad_object_sha1 + 20 * i))\n\t\t\treturn;\n\tp->bad_object_sha1 = xrealloc(p->bad_object_sha1, 20 * (p->num_bad_objects + 1));\n\thashcpy(p->bad_object_sha1 + 20 * p->num_bad_objects, sha1);\n\tp->num_bad_objects++;\n}\n\nstatic int has_packed_and_bad(const unsigned char *sha1)\n{\n\tstruct packed_git *p;\n\tunsigned i;\n\n\tfor (p = packed_git; p; p = p->next)\n\t\tfor (i = 0; i < p->num_bad_objects; i++)\n\t\t\tif (!hashcmp(sha1, p->bad_object_sha1 + 20 * i))\n\t\t\t\treturn 1;\n\treturn 0;\n}\n\nint check_sha1_signature(const unsigned char *sha1, void *map, unsigned long size, const char *type)\n{\n\tunsigned char real_sha1[20];\n\thash_sha1_file(map, size, type, real_sha1);\n\treturn hashcmp(sha1, real_sha1) ? -1 : 0;\n}\n\nstatic int git_open_noatime(const char *name)\n{\n\tstatic int sha1_file_open_flag = O_NOATIME;\n\tint fd = open(name, O_RDONLY | sha1_file_open_flag);\n\n\t/* Might the failure be due to O_NOATIME? */\n\tif (fd < 0 && errno != ENOENT && sha1_file_open_flag) {\n\t\tfd = open(name, O_RDONLY);\n\t\tif (fd >= 0)\n\t\t\tsha1_file_open_flag = 0;\n\t}\n\treturn fd;\n}\n\nstatic int open_sha1_file(const unsigned char *sha1)\n{\n\tint fd;\n\tchar *name = sha1_file_name(sha1);\n\tstruct alternate_object_database *alt;\n\n\tfd = git_open_noatime(name);\n\tif (fd >= 0)\n\t\treturn fd;\n\n\tprepare_alt_odb();\n\terrno = ENOENT;\n\tfor (alt = alt_odb_list; alt; alt = alt->next) {\n\t\tname = alt->name;\n\t\tfill_sha1_path(name, sha1);\n\t\tfd = git_open_noatime(alt->base);\n\t\tif (fd >= 0)\n\t\t\treturn fd;\n\t}\n\treturn -1;\n}\n\nstatic void *map_sha1_file(const unsigned char *sha1, unsigned long *size)\n{\n\tvoid *map;\n\tint fd;\n\n\tfd = open_sha1_file(sha1);\n\tmap = NULL;\n\tif (fd >= 0) {\n\t\tstruct stat st;\n\n\t\tif (!fstat(fd, &st)) {\n\t\t\t*size = xsize_t(st.st_size);\n\t\t\tmap = xmmap(NULL, *size, PROT_READ, MAP_PRIVATE, fd, 0);\n\t\t}\n\t\tclose(fd);\n\t}\n\treturn map;\n}\n\nstatic int legacy_loose_object(unsigned char *map)\n{\n\tunsigned int word;\n\n\t/*\n\t * Is it a zlib-compressed buffer? If so, the first byte\n\t * must be 0x78 (15-bit window size, deflated), and the\n\t * first 16-bit word is evenly divisible by 31\n\t */\n\tword = (map[0] << 8) + map[1];\n\tif (map[0] == 0x78 && !(word % 31))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nunsigned long unpack_object_header_buffer(const unsigned char *buf,\n\t\tunsigned long len, enum object_type *type, unsigned long *sizep)\n{\n\tunsigned shift;\n\tunsigned long size, c;\n\tunsigned long used = 0;\n\n\tc = buf[used++];\n\t*type = (c >> 4) & 7;\n\tsize = c & 15;\n\tshift = 4;\n\twhile (c & 0x80) {\n\t\tif (len <= used || bitsizeof(long) <= shift) {\n\t\t\terror(\"bad object header\");\n\t\t\treturn 0;\n\t\t}\n\t\tc = buf[used++];\n\t\tsize += (c & 0x7f) << shift;\n\t\tshift += 7;\n\t}\n\t*sizep = size;\n\treturn used;\n}\n\nstatic int unpack_sha1_header(z_stream *stream, unsigned char *map, unsigned long mapsize, void *buffer, unsigned long bufsiz)\n{\n\tunsigned long size, used;\n\tstatic const char valid_loose_object_type[8] = {\n\t\t0, /* OBJ_EXT */\n\t\t1, 1, 1, 1, /* \"commit\", \"tree\", \"blob\", \"tag\" */\n\t\t0, /* \"delta\" and others are invalid in a loose object */\n\t};\n\tenum object_type type;\n\n\t/* Get the data stream */\n\tmemset(stream, 0, sizeof(*stream));\n\tstream->next_in = map;\n\tstream->avail_in = mapsize;\n\tstream->next_out = buffer;\n\tstream->avail_out = bufsiz;\n\n\tif (legacy_loose_object(map)) {\n\t\tgit_inflate_init(stream);\n\t\treturn git_inflate(stream, 0);\n\t}\n\n\n\t/*\n\t * There used to be a second loose object header format which\n\t * was meant to mimic the in-pack format, allowing for direct\n\t * copy of the object data.  This format turned up not to be\n\t * really worth it and we don't write it any longer.  But we\n\t * can still read it.\n\t */\n\tused = unpack_object_header_buffer(map, mapsize, &type, &size);\n\tif (!used || !valid_loose_object_type[type])\n\t\treturn -1;\n\tmap += used;\n\tmapsize -= used;\n\n\t/* Set up the stream for the rest.. */\n\tstream->next_in = map;\n\tstream->avail_in = mapsize;\n\tgit_inflate_init(stream);\n\n\t/* And generate the fake traditional header */\n\tstream->total_out = 1 + snprintf(buffer, bufsiz, \"%s %lu\",\n\t\t\t\t\t typename(type), size);\n\treturn 0;\n}\n\nstatic void *unpack_sha1_rest(z_stream *stream, void *buffer, unsigned long size, const unsigned char *sha1)\n{\n\tint bytes = strlen(buffer) + 1;\n\tunsigned char *buf = xmallocz(size);\n\tunsigned long n;\n\tint status = Z_OK;\n\n\tn = stream->total_out - bytes;\n\tif (n > size)\n\t\tn = size;\n\tmemcpy(buf, (char *) buffer + bytes, n);\n\tbytes = n;\n\tif (bytes <= size) {\n\t\t/*\n\t\t * The above condition must be (bytes <= size), not\n\t\t * (bytes < size).  In other words, even though we\n\t\t * expect no more output and set avail_out to zer0,\n\t\t * the input zlib stream may have bytes that express\n\t\t * \"this concludes the stream\", and we *do* want to\n\t\t * eat that input.\n\t\t *\n\t\t * Otherwise we would not be able to test that we\n\t\t * consumed all the input to reach the expected size;\n\t\t * we also want to check that zlib tells us that all\n\t\t * went well with status == Z_STREAM_END at the end.\n\t\t */\n\t\tstream->next_out = buf + bytes;\n\t\tstream->avail_out = size - bytes;\n\t\twhile (status == Z_OK)\n\t\t\tstatus = git_inflate(stream, Z_FINISH);\n\t}\n\tif (status == Z_STREAM_END && !stream->avail_in) {\n\t\tgit_inflate_end(stream);\n\t\treturn buf;\n\t}\n\n\tif (status < 0)\n\t\terror(\"corrupt loose object '%s'\", sha1_to_hex(sha1));\n\telse if (stream->avail_in)\n\t\terror(\"garbage at end of loose object '%s'\",\n\t\t      sha1_to_hex(sha1));\n\tfree(buf);\n\treturn NULL;\n}\n\n/*\n * We used to just use \"sscanf()\", but that's actually way\n * too permissive for what we want to check. So do an anal\n * object header parse by hand.\n */\nstatic int parse_sha1_header(const char *hdr, unsigned long *sizep)\n{\n\tchar type[10];\n\tint i;\n\tunsigned long size;\n\n\t/*\n\t * The type can be at most ten bytes (including the\n\t * terminating '\\0' that we add), and is followed by\n\t * a space.\n\t */\n\ti = 0;\n\tfor (;;) {\n\t\tchar c = *hdr++;\n\t\tif (c == ' ')\n\t\t\tbreak;\n\t\ttype[i++] = c;\n\t\tif (i >= sizeof(type))\n\t\t\treturn -1;\n\t}\n\ttype[i] = 0;\n\n\t/*\n\t * The length must follow immediately, and be in canonical\n\t * decimal format (ie \"010\" is not valid).\n\t */\n\tsize = *hdr++ - '0';\n\tif (size > 9)\n\t\treturn -1;\n\tif (size) {\n\t\tfor (;;) {\n\t\t\tunsigned long c = *hdr - '0';\n\t\t\tif (c > 9)\n\t\t\t\tbreak;\n\t\t\thdr++;\n\t\t\tsize = size * 10 + c;\n\t\t}\n\t}\n\t*sizep = size;\n\n\t/*\n\t * The length must be followed by a zero byte\n\t */\n\treturn *hdr ? -1 : type_from_string(type);\n}\n\nstatic void *unpack_sha1_file(void *map, unsigned long mapsize, enum object_type *type, unsigned long *size, const unsigned char *sha1)\n{\n\tint ret;\n\tz_stream stream;\n\tchar hdr[8192];\n\n\tret = unpack_sha1_header(&stream, map, mapsize, hdr, sizeof(hdr));\n\tif (ret < Z_OK || (*type = parse_sha1_header(hdr, size)) < 0)\n\t\treturn NULL;\n\n\treturn unpack_sha1_rest(&stream, hdr, *size, sha1);\n}\n\nunsigned long get_size_from_delta(struct packed_git *p,\n\t\t\t\t  struct pack_window **w_curs,\n\t\t\t          off_t curpos)\n{\n\tconst unsigned char *data;\n\tunsigned char delta_head[20], *in;\n\tz_stream stream;\n\tint st;\n\n\tmemset(&stream, 0, sizeof(stream));\n\tstream.next_out = delta_head;\n\tstream.avail_out = sizeof(delta_head);\n\n\tgit_inflate_init(&stream);\n\tdo {\n\t\tin = use_pack(p, w_curs, curpos, &stream.avail_in);\n\t\tstream.next_in = in;\n\t\tst = git_inflate(&stream, Z_FINISH);\n\t\tcurpos += stream.next_in - in;\n\t} while ((st == Z_OK || st == Z_BUF_ERROR) &&\n\t\t stream.total_out < sizeof(delta_head));\n\tgit_inflate_end(&stream);\n\tif ((st != Z_STREAM_END) && stream.total_out != sizeof(delta_head)) {\n\t\terror(\"delta data unpack-initial failed\");\n\t\treturn 0;\n\t}\n\n\t/* Examine the initial part of the delta to figure out\n\t * the result size.\n\t */\n\tdata = delta_head;\n\n\t/* ignore base size */\n\tget_delta_hdr_size(&data, delta_head+sizeof(delta_head));\n\n\t/* Read the result size */\n\treturn get_delta_hdr_size(&data, delta_head+sizeof(delta_head));\n}\n\nstatic off_t get_delta_base(struct packed_git *p,\n\t\t\t\t    struct pack_window **w_curs,\n\t\t\t\t    off_t *curpos,\n\t\t\t\t    enum object_type type,\n\t\t\t\t    off_t delta_obj_offset)\n{\n\tunsigned char *base_info = use_pack(p, w_curs, *curpos, NULL);\n\toff_t base_offset;\n\n\t/* use_pack() assured us we have [base_info, base_info + 20)\n\t * as a range that we can look at without walking off the\n\t * end of the mapped window.  Its actually the hash size\n\t * that is assured.  An OFS_DELTA longer than the hash size\n\t * is stupid, as then a REF_DELTA would be smaller to store.\n\t */\n\tif (type == OBJ_OFS_DELTA) {\n\t\tunsigned used = 0;\n\t\tunsigned char c = base_info[used++];\n\t\tbase_offset = c & 127;\n\t\twhile (c & 128) {\n\t\t\tbase_offset += 1;\n\t\t\tif (!base_offset || MSB(base_offset, 7))\n\t\t\t\treturn 0;  /* overflow */\n\t\t\tc = base_info[used++];\n\t\t\tbase_offset = (base_offset << 7) + (c & 127);\n\t\t}\n\t\tbase_offset = delta_obj_offset - base_offset;\n\t\tif (base_offset <= 0 || base_offset >= delta_obj_offset)\n\t\t\treturn 0;  /* out of bound */\n\t\t*curpos += used;\n\t} else if (type == OBJ_REF_DELTA) {\n\t\t/* The base entry _must_ be in the same pack */\n\t\tbase_offset = find_pack_entry_one(base_info, p);\n\t\t*curpos += 20;\n\t} else\n\t\tdie(\"I am totally screwed\");\n\treturn base_offset;\n}\n\n/* forward declaration for a mutually recursive function */\nstatic int packed_object_info(struct packed_git *p, off_t offset,\n\t\t\t      unsigned long *sizep);\n\nstatic int packed_delta_info(struct packed_git *p,\n\t\t\t     struct pack_window **w_curs,\n\t\t\t     off_t curpos,\n\t\t\t     enum object_type type,\n\t\t\t     off_t obj_offset,\n\t\t\t     unsigned long *sizep)\n{\n\toff_t base_offset;\n\n\tbase_offset = get_delta_base(p, w_curs, &curpos, type, obj_offset);\n\tif (!base_offset)\n\t\treturn OBJ_BAD;\n\ttype = packed_object_info(p, base_offset, NULL);\n\tif (type <= OBJ_NONE) {\n\t\tstruct revindex_entry *revidx;\n\t\tconst unsigned char *base_sha1;\n\t\trevidx = find_pack_revindex(p, base_offset);\n\t\tif (!revidx)\n\t\t\treturn OBJ_BAD;\n\t\tbase_sha1 = nth_packed_object_sha1(p, revidx->nr);\n\t\tmark_bad_packed_object(p, base_sha1);\n\t\ttype = sha1_object_info(base_sha1, NULL);\n\t\tif (type <= OBJ_NONE)\n\t\t\treturn OBJ_BAD;\n\t}\n\n\t/* We choose to only get the type of the base object and\n\t * ignore potentially corrupt pack file that expects the delta\n\t * based on a base with a wrong size.  This saves tons of\n\t * inflate() calls.\n\t */\n\tif (sizep) {\n\t\t*sizep = get_size_from_delta(p, w_curs, curpos);\n\t\tif (*sizep == 0)\n\t\t\ttype = OBJ_BAD;\n\t}\n\n\treturn type;\n}\n\nstatic int unpack_object_header(struct packed_git *p,\n\t\t\t\tstruct pack_window **w_curs,\n\t\t\t\toff_t *curpos,\n\t\t\t\tunsigned long *sizep)\n{\n\tunsigned char *base;\n\tunsigned int left;\n\tunsigned long used;\n\tenum object_type type;\n\n\t/* use_pack() assures us we have [base, base + 20) available\n\t * as a range that we can look at at.  (Its actually the hash\n\t * size that is assured.)  With our object header encoding\n\t * the maximum deflated object size is 2^137, which is just\n\t * insane, so we know won't exceed what we have been given.\n\t */\n\tbase = use_pack(p, w_curs, *curpos, &left);\n\tused = unpack_object_header_buffer(base, left, &type, sizep);\n\tif (!used) {\n\t\ttype = OBJ_BAD;\n\t} else\n\t\t*curpos += used;\n\n\treturn type;\n}\n\nconst char *packed_object_info_detail(struct packed_git *p,\n\t\t\t\t      off_t obj_offset,\n\t\t\t\t      unsigned long *size,\n\t\t\t\t      unsigned long *store_size,\n\t\t\t\t      unsigned int *delta_chain_length,\n\t\t\t\t      unsigned char *base_sha1)\n{\n\tstruct pack_window *w_curs = NULL;\n\toff_t curpos;\n\tunsigned long dummy;\n\tunsigned char *next_sha1;\n\tenum object_type type;\n\tstruct revindex_entry *revidx;\n\n\t*delta_chain_length = 0;\n\tcurpos = obj_offset;\n\ttype = unpack_object_header(p, &w_curs, &curpos, size);\n\n\trevidx = find_pack_revindex(p, obj_offset);\n\t*store_size = revidx[1].offset - obj_offset;\n\n\tfor (;;) {\n\t\tswitch (type) {\n\t\tdefault:\n\t\t\tdie(\"pack %s contains unknown object type %d\",\n\t\t\t    p->pack_name, type);\n\t\tcase OBJ_COMMIT:\n\t\tcase OBJ_TREE:\n\t\tcase OBJ_BLOB:\n\t\tcase OBJ_TAG:\n\t\t\tunuse_pack(&w_curs);\n\t\t\treturn typename(type);\n\t\tcase OBJ_OFS_DELTA:\n\t\t\tobj_offset = get_delta_base(p, &w_curs, &curpos, type, obj_offset);\n\t\t\tif (!obj_offset)\n\t\t\t\tdie(\"pack %s contains bad delta base reference of type %s\",\n\t\t\t\t    p->pack_name, typename(type));\n\t\t\tif (*delta_chain_length == 0) {\n\t\t\t\trevidx = find_pack_revindex(p, obj_offset);\n\t\t\t\thashcpy(base_sha1, nth_packed_object_sha1(p, revidx->nr));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OBJ_REF_DELTA:\n\t\t\tnext_sha1 = use_pack(p, &w_curs, curpos, NULL);\n\t\t\tif (*delta_chain_length == 0)\n\t\t\t\thashcpy(base_sha1, next_sha1);\n\t\t\tobj_offset = find_pack_entry_one(next_sha1, p);\n\t\t\tbreak;\n\t\t}\n\t\t(*delta_chain_length)++;\n\t\tcurpos = obj_offset;\n\t\ttype = unpack_object_header(p, &w_curs, &curpos, &dummy);\n\t}\n}\n\nstatic int packed_object_info(struct packed_git *p, off_t obj_offset,\n\t\t\t      unsigned long *sizep)\n{\n\tstruct pack_window *w_curs = NULL;\n\tunsigned long size;\n\toff_t curpos = obj_offset;\n\tenum object_type type;\n\n\ttype = unpack_object_header(p, &w_curs, &curpos, &size);\n\n\tswitch (type) {\n\tcase OBJ_OFS_DELTA:\n\tcase OBJ_REF_DELTA:\n\t\ttype = packed_delta_info(p, &w_curs, curpos,\n\t\t\t\t\t type, obj_offset, sizep);\n\t\tbreak;\n\tcase OBJ_COMMIT:\n\tcase OBJ_TREE:\n\tcase OBJ_BLOB:\n\tcase OBJ_TAG:\n\t\tif (sizep)\n\t\t\t*sizep = size;\n\t\tbreak;\n\tdefault:\n\t\terror(\"unknown object type %i at offset %\"PRIuMAX\" in %s\",\n\t\t      type, (uintmax_t)obj_offset, p->pack_name);\n\t\ttype = OBJ_BAD;\n\t}\n\tunuse_pack(&w_curs);\n\treturn type;\n}\n\nstatic void *unpack_compressed_entry(struct packed_git *p,\n\t\t\t\t    struct pack_window **w_curs,\n\t\t\t\t    off_t curpos,\n\t\t\t\t    unsigned long size)\n{\n\tint st;\n\tz_stream stream;\n\tunsigned char *buffer, *in;\n\n\tbuffer = xmallocz(size);\n\tmemset(&stream, 0, sizeof(stream));\n\tstream.next_out = buffer;\n\tstream.avail_out = size + 1;\n\n\tgit_inflate_init(&stream);\n\tdo {\n\t\tin = use_pack(p, w_curs, curpos, &stream.avail_in);\n\t\tstream.next_in = in;\n\t\tst = git_inflate(&stream, Z_FINISH);\n\t\tif (!stream.avail_out)\n\t\t\tbreak; /* the payload is larger than it should be */\n\t\tcurpos += stream.next_in - in;\n\t} while (st == Z_OK || st == Z_BUF_ERROR);\n\tgit_inflate_end(&stream);\n\tif ((st != Z_STREAM_END) || stream.total_out != size) {\n\t\tfree(buffer);\n\t\treturn NULL;\n\t}\n\n\treturn buffer;\n}\n\n#define MAX_DELTA_CACHE (256)\n\nstatic size_t delta_base_cached;\n\nstatic struct delta_base_cache_lru_list {\n\tstruct delta_base_cache_lru_list *prev;\n\tstruct delta_base_cache_lru_list *next;\n} delta_base_cache_lru = { &delta_base_cache_lru, &delta_base_cache_lru };\n\nstatic struct delta_base_cache_entry {\n\tstruct delta_base_cache_lru_list lru;\n\tvoid *data;\n\tstruct packed_git *p;\n\toff_t base_offset;\n\tunsigned long size;\n\tenum object_type type;\n} delta_base_cache[MAX_DELTA_CACHE];\n\nstatic unsigned long pack_entry_hash(struct packed_git *p, off_t base_offset)\n{\n\tunsigned long hash;\n\n\thash = (unsigned long)p + (unsigned long)base_offset;\n\thash += (hash >> 8) + (hash >> 16);\n\treturn hash % MAX_DELTA_CACHE;\n}\n\nstatic void *cache_or_unpack_entry(struct packed_git *p, off_t base_offset,\n\tunsigned long *base_size, enum object_type *type, int keep_cache)\n{\n\tvoid *ret;\n\tunsigned long hash = pack_entry_hash(p, base_offset);\n\tstruct delta_base_cache_entry *ent = delta_base_cache + hash;\n\n\tret = ent->data;\n\tif (!ret || ent->p != p || ent->base_offset != base_offset)\n\t\treturn unpack_entry(p, base_offset, type, base_size);\n\n\tif (!keep_cache) {\n\t\tent->data = NULL;\n\t\tent->lru.next->prev = ent->lru.prev;\n\t\tent->lru.prev->next = ent->lru.next;\n\t\tdelta_base_cached -= ent->size;\n\t} else {\n\t\tret = xmemdupz(ent->data, ent->size);\n\t}\n\t*type = ent->type;\n\t*base_size = ent->size;\n\treturn ret;\n}\n\nstatic inline void release_delta_base_cache(struct delta_base_cache_entry *ent)\n{\n\tif (ent->data) {\n\t\tfree(ent->data);\n\t\tent->data = NULL;\n\t\tent->lru.next->prev = ent->lru.prev;\n\t\tent->lru.prev->next = ent->lru.next;\n\t\tdelta_base_cached -= ent->size;\n\t}\n}\n\nvoid clear_delta_base_cache(void)\n{\n\tunsigned long p;\n\tfor (p = 0; p < MAX_DELTA_CACHE; p++)\n\t\trelease_delta_base_cache(&delta_base_cache[p]);\n}\n\nstatic void add_delta_base_cache(struct packed_git *p, off_t base_offset,\n\tvoid *base, unsigned long base_size, enum object_type type)\n{\n\tunsigned long hash = pack_entry_hash(p, base_offset);\n\tstruct delta_base_cache_entry *ent = delta_base_cache + hash;\n\tstruct delta_base_cache_lru_list *lru;\n\n\trelease_delta_base_cache(ent);\n\tdelta_base_cached += base_size;\n\n\tfor (lru = delta_base_cache_lru.next;\n\t     delta_base_cached > delta_base_cache_limit\n\t     && lru != &delta_base_cache_lru;\n\t     lru = lru->next) {\n\t\tstruct delta_base_cache_entry *f = (void *)lru;\n\t\tif (f->type == OBJ_BLOB)\n\t\t\trelease_delta_base_cache(f);\n\t}\n\tfor (lru = delta_base_cache_lru.next;\n\t     delta_base_cached > delta_base_cache_limit\n\t     && lru != &delta_base_cache_lru;\n\t     lru = lru->next) {\n\t\tstruct delta_base_cache_entry *f = (void *)lru;\n\t\trelease_delta_base_cache(f);\n\t}\n\n\tent->p = p;\n\tent->base_offset = base_offset;\n\tent->type = type;\n\tent->data = base;\n\tent->size = base_size;\n\tent->lru.next = &delta_base_cache_lru;\n\tent->lru.prev = delta_base_cache_lru.prev;\n\tdelta_base_cache_lru.prev->next = &ent->lru;\n\tdelta_base_cache_lru.prev = &ent->lru;\n}\n\nstatic void *read_object(const unsigned char *sha1, enum object_type *type,\n\t\t\t unsigned long *size);\n\nstatic void *unpack_delta_entry(struct packed_git *p,\n\t\t\t\tstruct pack_window **w_curs,\n\t\t\t\toff_t curpos,\n\t\t\t\tunsigned long delta_size,\n\t\t\t\toff_t obj_offset,\n\t\t\t\tenum object_type *type,\n\t\t\t\tunsigned long *sizep)\n{\n\tvoid *delta_data, *result, *base;\n\tunsigned long base_size;\n\toff_t base_offset;\n\n\tbase_offset = get_delta_base(p, w_curs, &curpos, *type, obj_offset);\n\tif (!base_offset) {\n\t\terror(\"failed to validate delta base reference \"\n\t\t      \"at offset %\"PRIuMAX\" from %s\",\n\t\t      (uintmax_t)curpos, p->pack_name);\n\t\treturn NULL;\n\t}\n\tunuse_pack(w_curs);\n\tbase = cache_or_unpack_entry(p, base_offset, &base_size, type, 0);\n\tif (!base) {\n\t\t/*\n\t\t * We're probably in deep shit, but let's try to fetch\n\t\t * the required base anyway from another pack or loose.\n\t\t * This is costly but should happen only in the presence\n\t\t * of a corrupted pack, and is better than failing outright.\n\t\t */\n\t\tstruct revindex_entry *revidx;\n\t\tconst unsigned char *base_sha1;\n\t\trevidx = find_pack_revindex(p, base_offset);\n\t\tif (!revidx)\n\t\t\treturn NULL;\n\t\tbase_sha1 = nth_packed_object_sha1(p, revidx->nr);\n\t\terror(\"failed to read delta base object %s\"\n\t\t      \" at offset %\"PRIuMAX\" from %s\",\n\t\t      sha1_to_hex(base_sha1), (uintmax_t)base_offset,\n\t\t      p->pack_name);\n\t\tmark_bad_packed_object(p, base_sha1);\n\t\tbase = read_object(base_sha1, type, &base_size);\n\t\tif (!base)\n\t\t\treturn NULL;\n\t}\n\n\tdelta_data = unpack_compressed_entry(p, w_curs, curpos, delta_size);\n\tif (!delta_data) {\n\t\terror(\"failed to unpack compressed delta \"\n\t\t      \"at offset %\"PRIuMAX\" from %s\",\n\t\t      (uintmax_t)curpos, p->pack_name);\n\t\tfree(base);\n\t\treturn NULL;\n\t}\n\tresult = patch_delta(base, base_size,\n\t\t\t     delta_data, delta_size,\n\t\t\t     sizep);\n\tif (!result)\n\t\tdie(\"failed to apply delta\");\n\tfree(delta_data);\n\tadd_delta_base_cache(p, base_offset, base, base_size, *type);\n\treturn result;\n}\n\nint do_check_packed_object_crc;\n\nvoid *unpack_entry(struct packed_git *p, off_t obj_offset,\n\t\t   enum object_type *type, unsigned long *sizep)\n{\n\tstruct pack_window *w_curs = NULL;\n\toff_t curpos = obj_offset;\n\tvoid *data;\n\n\tif (do_check_packed_object_crc && p->index_version > 1) {\n\t\tstruct revindex_entry *revidx = find_pack_revindex(p, obj_offset);\n\t\tunsigned long len = revidx[1].offset - obj_offset;\n\t\tif (check_pack_crc(p, &w_curs, obj_offset, len, revidx->nr)) {\n\t\t\tconst unsigned char *sha1 =\n\t\t\t\tnth_packed_object_sha1(p, revidx->nr);\n\t\t\terror(\"bad packed object CRC for %s\",\n\t\t\t      sha1_to_hex(sha1));\n\t\t\tmark_bad_packed_object(p, sha1);\n\t\t\tunuse_pack(&w_curs);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t*type = unpack_object_header(p, &w_curs, &curpos, sizep);\n\tswitch (*type) {\n\tcase OBJ_OFS_DELTA:\n\tcase OBJ_REF_DELTA:\n\t\tdata = unpack_delta_entry(p, &w_curs, curpos, *sizep,\n\t\t\t\t\t  obj_offset, type, sizep);\n\t\tbreak;\n\tcase OBJ_COMMIT:\n\tcase OBJ_TREE:\n\tcase OBJ_BLOB:\n\tcase OBJ_TAG:\n\t\tdata = unpack_compressed_entry(p, &w_curs, curpos, *sizep);\n\t\tbreak;\n\tdefault:\n\t\tdata = NULL;\n\t\terror(\"unknown object type %i at offset %\"PRIuMAX\" in %s\",\n\t\t      *type, (uintmax_t)obj_offset, p->pack_name);\n\t}\n\tunuse_pack(&w_curs);\n\treturn data;\n}\n\nconst unsigned char *nth_packed_object_sha1(struct packed_git *p,\n\t\t\t\t\t    uint32_t n)\n{\n\tconst unsigned char *index = p->index_data;\n\tif (!index) {\n\t\tif (open_pack_index(p))\n\t\t\treturn NULL;\n\t\tindex = p->index_data;\n\t}\n\tif (n >= p->num_objects)\n\t\treturn NULL;\n\tindex += 4 * 256;\n\tif (p->index_version == 1) {\n\t\treturn index + 24 * n + 4;\n\t} else {\n\t\tindex += 8;\n\t\treturn index + 20 * n;\n\t}\n}\n\noff_t nth_packed_object_offset(const struct packed_git *p, uint32_t n)\n{\n\tconst unsigned char *index = p->index_data;\n\tindex += 4 * 256;\n\tif (p->index_version == 1) {\n\t\treturn ntohl(*((uint32_t *)(index + 24 * n)));\n\t} else {\n\t\tuint32_t off;\n\t\tindex += 8 + p->num_objects * (20 + 4);\n\t\toff = ntohl(*((uint32_t *)(index + 4 * n)));\n\t\tif (!(off & 0x80000000))\n\t\t\treturn off;\n\t\tindex += p->num_objects * 4 + (off & 0x7fffffff) * 8;\n\t\treturn (((uint64_t)ntohl(*((uint32_t *)(index + 0)))) << 32) |\n\t\t\t\t   ntohl(*((uint32_t *)(index + 4)));\n\t}\n}\n\noff_t find_pack_entry_one(const unsigned char *sha1,\n\t\t\t\t  struct packed_git *p)\n{\n\tconst uint32_t *level1_ofs = p->index_data;\n\tconst unsigned char *index = p->index_data;\n\tunsigned hi, lo, stride;\n\tstatic int use_lookup = -1;\n\tstatic int debug_lookup = -1;\n\n\tif (debug_lookup < 0)\n\t\tdebug_lookup = !!getenv(\"GIT_DEBUG_LOOKUP\");\n\n\tif (!index) {\n\t\tif (open_pack_index(p))\n\t\t\treturn 0;\n\t\tlevel1_ofs = p->index_data;\n\t\tindex = p->index_data;\n\t}\n\tif (p->index_version > 1) {\n\t\tlevel1_ofs += 2;\n\t\tindex += 8;\n\t}\n\tindex += 4 * 256;\n\thi = ntohl(level1_ofs[*sha1]);\n\tlo = ((*sha1 == 0x0) ? 0 : ntohl(level1_ofs[*sha1 - 1]));\n\tif (p->index_version > 1) {\n\t\tstride = 20;\n\t} else {\n\t\tstride = 24;\n\t\tindex += 4;\n\t}\n\n\tif (debug_lookup)\n\t\tprintf(\"%02x%02x%02x... lo %u hi %u nr %\"PRIu32\"\\n\",\n\t\t       sha1[0], sha1[1], sha1[2], lo, hi, p->num_objects);\n\n\tif (use_lookup < 0)\n\t\tuse_lookup = !!getenv(\"GIT_USE_LOOKUP\");\n\tif (use_lookup) {\n\t\tint pos = sha1_entry_pos(index, stride, 0,\n\t\t\t\t\t lo, hi, p->num_objects, sha1);\n\t\tif (pos < 0)\n\t\t\treturn 0;\n\t\treturn nth_packed_object_offset(p, pos);\n\t}\n\n\tdo {\n\t\tunsigned mi = (lo + hi) / 2;\n\t\tint cmp = hashcmp(index + mi * stride, sha1);\n\n\t\tif (debug_lookup)\n\t\t\tprintf(\"lo %u hi %u rg %u mi %u\\n\",\n\t\t\t       lo, hi, hi - lo, mi);\n\t\tif (!cmp)\n\t\t\treturn nth_packed_object_offset(p, mi);\n\t\tif (cmp > 0)\n\t\t\thi = mi;\n\t\telse\n\t\t\tlo = mi+1;\n\t} while (lo < hi);\n\treturn 0;\n}\n\nstatic int find_pack_entry(const unsigned char *sha1, struct pack_entry *e)\n{\n\tstatic struct packed_git *last_found = (void *)1;\n\tstruct packed_git *p;\n\toff_t offset;\n\n\tprepare_packed_git();\n\tif (!packed_git)\n\t\treturn 0;\n\tp = (last_found == (void *)1) ? packed_git : last_found;\n\n\tdo {\n\t\tif (p->num_bad_objects) {\n\t\t\tunsigned i;\n\t\t\tfor (i = 0; i < p->num_bad_objects; i++)\n\t\t\t\tif (!hashcmp(sha1, p->bad_object_sha1 + 20 * i))\n\t\t\t\t\tgoto next;\n\t\t}\n\n\t\toffset = find_pack_entry_one(sha1, p);\n\t\tif (offset) {\n\t\t\t/*\n\t\t\t * We are about to tell the caller where they can\n\t\t\t * locate the requested object.  We better make\n\t\t\t * sure the packfile is still here and can be\n\t\t\t * accessed before supplying that answer, as\n\t\t\t * it may have been deleted since the index\n\t\t\t * was loaded!\n\t\t\t */\n\t\t\tif (p->pack_fd == -1 && open_packed_git(p)) {\n\t\t\t\terror(\"packfile %s cannot be accessed\", p->pack_name);\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\te->offset = offset;\n\t\t\te->p = p;\n\t\t\thashcpy(e->sha1, sha1);\n\t\t\tlast_found = p;\n\t\t\treturn 1;\n\t\t}\n\n\t\tnext:\n\t\tif (p == last_found)\n\t\t\tp = packed_git;\n\t\telse\n\t\t\tp = p->next;\n\t\tif (p == last_found)\n\t\t\tp = p->next;\n\t} while (p);\n\treturn 0;\n}\n\nstruct packed_git *find_sha1_pack(const unsigned char *sha1,\n\t\t\t\t  struct packed_git *packs)\n{\n\tstruct packed_git *p;\n\n\tfor (p = packs; p; p = p->next) {\n\t\tif (find_pack_entry_one(sha1, p))\n\t\t\treturn p;\n\t}\n\treturn NULL;\n\n}\n\nstatic int sha1_loose_object_info(const unsigned char *sha1, unsigned long *sizep)\n{\n\tint status;\n\tunsigned long mapsize, size;\n\tvoid *map;\n\tz_stream stream;\n\tchar hdr[32];\n\n\tmap = map_sha1_file(sha1, &mapsize);\n\tif (!map)\n\t\treturn error(\"unable to find %s\", sha1_to_hex(sha1));\n\tif (unpack_sha1_header(&stream, map, mapsize, hdr, sizeof(hdr)) < 0)\n\t\tstatus = error(\"unable to unpack %s header\",\n\t\t\t       sha1_to_hex(sha1));\n\telse if ((status = parse_sha1_header(hdr, &size)) < 0)\n\t\tstatus = error(\"unable to parse %s header\", sha1_to_hex(sha1));\n\telse if (sizep)\n\t\t*sizep = size;\n\tgit_inflate_end(&stream);\n\tmunmap(map, mapsize);\n\treturn status;\n}\n\nint sha1_object_info(const unsigned char *sha1, unsigned long *sizep)\n{\n\tstruct pack_entry e;\n\tint status;\n\n\tif (!find_pack_entry(sha1, &e)) {\n\t\t/* Most likely it's a loose object. */\n\t\tstatus = sha1_loose_object_info(sha1, sizep);\n\t\tif (status >= 0)\n\t\t\treturn status;\n\n\t\t/* Not a loose object; someone else may have just packed it. */\n\t\treprepare_packed_git();\n\t\tif (!find_pack_entry(sha1, &e))\n\t\t\treturn status;\n\t}\n\n\tstatus = packed_object_info(e.p, e.offset, sizep);\n\tif (status < 0) {\n\t\tmark_bad_packed_object(e.p, sha1);\n\t\tstatus = sha1_object_info(sha1, sizep);\n\t}\n\n\treturn status;\n}\n\nstatic void *read_packed_sha1(const unsigned char *sha1,\n\t\t\t      enum object_type *type, unsigned long *size)\n{\n\tstruct pack_entry e;\n\tvoid *data;\n\n\tif (!find_pack_entry(sha1, &e))\n\t\treturn NULL;\n\tdata = cache_or_unpack_entry(e.p, e.offset, size, type, 1);\n\tif (!data) {\n\t\t/*\n\t\t * We're probably in deep shit, but let's try to fetch\n\t\t * the required object anyway from another pack or loose.\n\t\t * This should happen only in the presence of a corrupted\n\t\t * pack, and is better than failing outright.\n\t\t */\n\t\terror(\"failed to read object %s at offset %\"PRIuMAX\" from %s\",\n\t\t      sha1_to_hex(sha1), (uintmax_t)e.offset, e.p->pack_name);\n\t\tmark_bad_packed_object(e.p, sha1);\n\t\tdata = read_object(sha1, type, size);\n\t}\n\treturn data;\n}\n\n/*\n * This is meant to hold a *small* number of objects that you would\n * want read_sha1_file() to be able to return, but yet you do not want\n * to write them into the object store (e.g. a browse-only\n * application).\n */\nstatic struct cached_object {\n\tunsigned char sha1[20];\n\tenum object_type type;\n\tvoid *buf;\n\tunsigned long size;\n} *cached_objects;\nstatic int cached_object_nr, cached_object_alloc;\n\nstatic struct cached_object empty_tree = {\n\tEMPTY_TREE_SHA1_BIN,\n\tOBJ_TREE,\n\t\"\",\n\t0\n};\n\nstatic struct cached_object *find_cached_object(const unsigned char *sha1)\n{\n\tint i;\n\tstruct cached_object *co = cached_objects;\n\n\tfor (i = 0; i < cached_object_nr; i++, co++) {\n\t\tif (!hashcmp(co->sha1, sha1))\n\t\t\treturn co;\n\t}\n\tif (!hashcmp(sha1, empty_tree.sha1))\n\t\treturn &empty_tree;\n\treturn NULL;\n}\n\nint pretend_sha1_file(void *buf, unsigned long len, enum object_type type,\n\t\t      unsigned char *sha1)\n{\n\tstruct cached_object *co;\n\n\thash_sha1_file(buf, len, typename(type), sha1);\n\tif (has_sha1_file(sha1) || find_cached_object(sha1))\n\t\treturn 0;\n\tif (cached_object_alloc <= cached_object_nr) {\n\t\tcached_object_alloc = alloc_nr(cached_object_alloc);\n\t\tcached_objects = xrealloc(cached_objects,\n\t\t\t\t\t  sizeof(*cached_objects) *\n\t\t\t\t\t  cached_object_alloc);\n\t}\n\tco = &cached_objects[cached_object_nr++];\n\tco->size = len;\n\tco->type = type;\n\tco->buf = xmalloc(len);\n\tmemcpy(co->buf, buf, len);\n\thashcpy(co->sha1, sha1);\n\treturn 0;\n}\n\nstatic void *read_object(const unsigned char *sha1, enum object_type *type,\n\t\t\t unsigned long *size)\n{\n\tunsigned long mapsize;\n\tvoid *map, *buf;\n\tstruct cached_object *co;\n\n\tco = find_cached_object(sha1);\n\tif (co) {\n\t\t*type = co->type;\n\t\t*size = co->size;\n\t\treturn xmemdupz(co->buf, co->size);\n\t}\n\n\tbuf = read_packed_sha1(sha1, type, size);\n\tif (buf)\n\t\treturn buf;\n\tmap = map_sha1_file(sha1, &mapsize);\n\tif (map) {\n\t\tbuf = unpack_sha1_file(map, mapsize, type, size, sha1);\n\t\tmunmap(map, mapsize);\n\t\treturn buf;\n\t}\n\treprepare_packed_git();\n\treturn read_packed_sha1(sha1, type, size);\n}\n\nvoid *read_sha1_file_repl(const unsigned char *sha1,\n\t\t\t  enum object_type *type,\n\t\t\t  unsigned long *size,\n\t\t\t  const unsigned char **replacement)\n{\n\tconst unsigned char *repl = lookup_replace_object(sha1);\n\tvoid *data = read_object(repl, type, size);\n\n\t/* die if we replaced an object with one that does not exist */\n\tif (!data && repl != sha1)\n\t\tdie(\"replacement %s not found for %s\",\n\t\t    sha1_to_hex(repl), sha1_to_hex(sha1));\n\n\t/* legacy behavior is to die on corrupted objects */\n\tif (!data && (has_loose_object(repl) || has_packed_and_bad(repl)))\n\t\tdie(\"object %s is corrupted\", sha1_to_hex(repl));\n\n\tif (replacement)\n\t\t*replacement = repl;\n\n\treturn data;\n}\n\nvoid *read_object_with_reference(const unsigned char *sha1,\n\t\t\t\t const char *required_type_name,\n\t\t\t\t unsigned long *size,\n\t\t\t\t unsigned char *actual_sha1_return)\n{\n\tenum object_type type, required_type;\n\tvoid *buffer;\n\tunsigned long isize;\n\tunsigned char actual_sha1[20];\n\n\trequired_type = type_from_string(required_type_name);\n\thashcpy(actual_sha1, sha1);\n\twhile (1) {\n\t\tint ref_length = -1;\n\t\tconst char *ref_type = NULL;\n\n\t\tbuffer = read_sha1_file(actual_sha1, &type, &isize);\n\t\tif (!buffer)\n\t\t\treturn NULL;\n\t\tif (type == required_type) {\n\t\t\t*size = isize;\n\t\t\tif (actual_sha1_return)\n\t\t\t\thashcpy(actual_sha1_return, actual_sha1);\n\t\t\treturn buffer;\n\t\t}\n\t\t/* Handle references */\n\t\telse if (type == OBJ_COMMIT)\n\t\t\tref_type = \"tree \";\n\t\telse if (type == OBJ_TAG)\n\t\t\tref_type = \"object \";\n\t\telse {\n\t\t\tfree(buffer);\n\t\t\treturn NULL;\n\t\t}\n\t\tref_length = strlen(ref_type);\n\n\t\tif (ref_length + 40 > isize ||\n\t\t    memcmp(buffer, ref_type, ref_length) ||\n\t\t    get_sha1_hex((char *) buffer + ref_length, actual_sha1)) {\n\t\t\tfree(buffer);\n\t\t\treturn NULL;\n\t\t}\n\t\tfree(buffer);\n\t\t/* Now we have the ID of the referred-to object in\n\t\t * actual_sha1.  Check again. */\n\t}\n}\n\nstatic void write_sha1_file_prepare(const void *buf, unsigned long len,\n                                    const char *type, unsigned char *sha1,\n                                    char *hdr, int *hdrlen)\n{\n\tgit_SHA_CTX c;\n\n\t/* Generate the header */\n\t*hdrlen = sprintf(hdr, \"%s %lu\", type, len)+1;\n\n\t/* Sha1.. */\n\tgit_SHA1_Init(&c);\n\tgit_SHA1_Update(&c, hdr, *hdrlen);\n\tgit_SHA1_Update(&c, buf, len);\n\tgit_SHA1_Final(sha1, &c);\n}\n\n/*\n * Move the just written object into its final resting place.\n * NEEDSWORK: this should be renamed to finalize_temp_file() as\n * \"moving\" is only a part of what it does, when no patch between\n * master to pu changes the call sites of this function.\n */\nint move_temp_to_file(const char *tmpfile, const char *filename)\n{\n\tint ret = 0;\n\n\tif (object_creation_mode == OBJECT_CREATION_USES_RENAMES)\n\t\tgoto try_rename;\n\telse if (link(tmpfile, filename))\n\t\tret = errno;\n\n\t/*\n\t * Coda hack - coda doesn't like cross-directory links,\n\t * so we fall back to a rename, which will mean that it\n\t * won't be able to check collisions, but that's not a\n\t * big deal.\n\t *\n\t * The same holds for FAT formatted media.\n\t *\n\t * When this succeeds, we just return.  We have nothing\n\t * left to unlink.\n\t */\n\tif (ret && ret != EEXIST) {\n\ttry_rename:\n\t\tif (!rename(tmpfile, filename))\n\t\t\tgoto out;\n\t\tret = errno;\n\t}\n\tunlink_or_warn(tmpfile);\n\tif (ret) {\n\t\tif (ret != EEXIST) {\n\t\t\treturn error(\"unable to write sha1 filename %s: %s\\n\", filename, strerror(ret));\n\t\t}\n\t\t/* FIXME!!! Collision check here ? */\n\t}\n\nout:\n\tif (set_shared_perm(filename, (S_IFREG|0444)))\n\t\treturn error(\"unable to set permission to '%s'\", filename);\n\treturn 0;\n}\n\nstatic int write_buffer(int fd, const void *buf, size_t len)\n{\n\tif (write_in_full(fd, buf, len) < 0)\n\t\treturn error(\"file write error (%s)\", strerror(errno));\n\treturn 0;\n}\n\nint hash_sha1_file(const void *buf, unsigned long len, const char *type,\n                   unsigned char *sha1)\n{\n\tchar hdr[32];\n\tint hdrlen;\n\twrite_sha1_file_prepare(buf, len, type, sha1, hdr, &hdrlen);\n\treturn 0;\n}\n\n/* Finalize a file on disk, and close it. */\nstatic void close_sha1_file(int fd)\n{\n\tif (fsync_object_files)\n\t\tfsync_or_die(fd, \"sha1 file\");\n\tif (close(fd) != 0)\n\t\tdie_errno(\"error when closing sha1 file\");\n}\n\n/* Size of directory component, including the ending '/' */\nstatic inline int directory_size(const char *filename)\n{\n\tconst char *s = strrchr(filename, '/');\n\tif (!s)\n\t\treturn 0;\n\treturn s - filename + 1;\n}\n\n/*\n * This creates a temporary file in the same directory as the final\n * 'filename'\n *\n * We want to avoid cross-directory filename renames, because those\n * can have problems on various filesystems (FAT, NFS, Coda).\n */\nstatic int create_tmpfile(char *buffer, size_t bufsiz, const char *filename)\n{\n\tint fd, dirlen = directory_size(filename);\n\n\tif (dirlen + 20 > bufsiz) {\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\tmemcpy(buffer, filename, dirlen);\n\tstrcpy(buffer + dirlen, \"tmp_obj_XXXXXX\");\n\tfd = mkstemp(buffer);\n\tif (fd < 0 && dirlen && errno == ENOENT) {\n\t\t/* Make sure the directory exists */\n\t\tmemcpy(buffer, filename, dirlen);\n\t\tbuffer[dirlen-1] = 0;\n\t\tif (mkdir(buffer, 0777) || adjust_shared_perm(buffer))\n\t\t\treturn -1;\n\n\t\t/* Try again */\n\t\tstrcpy(buffer + dirlen - 1, \"/tmp_obj_XXXXXX\");\n\t\tfd = mkstemp(buffer);\n\t}\n\treturn fd;\n}\n\nstatic int write_loose_object(const unsigned char *sha1, char *hdr, int hdrlen,\n\t\t\t      void *buf, unsigned long len, time_t mtime)\n{\n\tint fd, ret;\n\tunsigned char compressed[4096];\n\tz_stream stream;\n\tgit_SHA_CTX c;\n\tunsigned char parano_sha1[20];\n\tchar *filename;\n\tstatic char tmpfile[PATH_MAX];\n\n\tfilename = sha1_file_name(sha1);\n\tfd = create_tmpfile(tmpfile, sizeof(tmpfile), filename);\n\twhile (fd < 0 && errno == EMFILE && unuse_one_window(packed_git, -1))\n\t\tfd = create_tmpfile(tmpfile, sizeof(tmpfile), filename);\n\tif (fd < 0) {\n\t\tif (errno == EACCES)\n\t\t\treturn error(\"insufficient permission for adding an object to repository database %s\\n\", get_object_directory());\n\t\telse\n\t\t\treturn error(\"unable to create temporary sha1 filename %s: %s\\n\", tmpfile, strerror(errno));\n\t}\n\n\t/* Set it up */\n\tmemset(&stream, 0, sizeof(stream));\n\tdeflateInit(&stream, zlib_compression_level);\n\tstream.next_out = compressed;\n\tstream.avail_out = sizeof(compressed);\n\tgit_SHA1_Init(&c);\n\n\t/* First header.. */\n\tstream.next_in = (unsigned char *)hdr;\n\tstream.avail_in = hdrlen;\n\twhile (deflate(&stream, 0) == Z_OK)\n\t\t/* nothing */;\n\tgit_SHA1_Update(&c, hdr, hdrlen);\n\n\t/* Then the data itself.. */\n\tstream.next_in = buf;\n\tstream.avail_in = len;\n\tdo {\n\t\tunsigned char *in0 = stream.next_in;\n\t\tret = deflate(&stream, Z_FINISH);\n\t\tgit_SHA1_Update(&c, in0, stream.next_in - in0);\n\t\tif (write_buffer(fd, compressed, stream.next_out - compressed) < 0)\n\t\t\tdie(\"unable to write sha1 file\");\n\t\tstream.next_out = compressed;\n\t\tstream.avail_out = sizeof(compressed);\n\t} while (ret == Z_OK);\n\n\tif (ret != Z_STREAM_END)\n\t\tdie(\"unable to deflate new object %s (%d)\", sha1_to_hex(sha1), ret);\n\tret = deflateEnd(&stream);\n\tif (ret != Z_OK)\n\t\tdie(\"deflateEnd on object %s failed (%d)\", sha1_to_hex(sha1), ret);\n\tgit_SHA1_Final(parano_sha1, &c);\n\tif (hashcmp(sha1, parano_sha1) != 0)\n\t\tdie(\"confused by unstable object source data for %s\", sha1_to_hex(sha1));\n\n\tclose_sha1_file(fd);\n\n\tif (mtime) {\n\t\tstruct utimbuf utb;\n\t\tutb.actime = mtime;\n\t\tutb.modtime = mtime;\n\t\tif (utime(tmpfile, &utb) < 0)\n\t\t\twarning(\"failed utime() on %s: %s\",\n\t\t\t\ttmpfile, strerror(errno));\n\t}\n\n\treturn move_temp_to_file(tmpfile, filename);\n}\n\nint write_sha1_file(void *buf, unsigned long len, const char *type, unsigned char *returnsha1)\n{\n\tunsigned char sha1[20];\n\tchar hdr[32];\n\tint hdrlen;\n\n\t/* Normally if we have it in the pack then we do not bother writing\n\t * it out into .git/objects/??/?{38} file.\n\t */\n\twrite_sha1_file_prepare(buf, len, type, sha1, hdr, &hdrlen);\n\tif (returnsha1)\n\t\thashcpy(returnsha1, sha1);\n\tif (has_sha1_file(sha1))\n\t\treturn 0;\n\treturn write_loose_object(sha1, hdr, hdrlen, buf, len, 0);\n}\n\nint force_object_loose(const unsigned char *sha1, time_t mtime)\n{\n\tvoid *buf;\n\tunsigned long len;\n\tenum object_type type;\n\tchar hdr[32];\n\tint hdrlen;\n\tint ret;\n\n\tif (has_loose_object(sha1))\n\t\treturn 0;\n\tbuf = read_packed_sha1(sha1, &type, &len);\n\tif (!buf)\n\t\treturn error(\"cannot read sha1_file for %s\", sha1_to_hex(sha1));\n\thdrlen = sprintf(hdr, \"%s %lu\", typename(type), len) + 1;\n\tret = write_loose_object(sha1, hdr, hdrlen, buf, len, mtime);\n\tfree(buf);\n\n\treturn ret;\n}\n\nint has_pack_index(const unsigned char *sha1)\n{\n\tstruct stat st;\n\tif (stat(sha1_pack_index_name(sha1), &st))\n\t\treturn 0;\n\treturn 1;\n}\n\nint has_sha1_pack(const unsigned char *sha1)\n{\n\tstruct pack_entry e;\n\treturn find_pack_entry(sha1, &e);\n}\n\nint has_sha1_file(const unsigned char *sha1)\n{\n\tstruct pack_entry e;\n\n\tif (find_pack_entry(sha1, &e))\n\t\treturn 1;\n\treturn has_loose_object(sha1);\n}\n\nstatic int index_mem(unsigned char *sha1, void *buf, size_t size,\n\t\t     int write_object, enum object_type type, const char *path)\n{\n\tint ret, re_allocated = 0;\n\n\tif (!type)\n\t\ttype = OBJ_BLOB;\n\n\t/*\n\t * Convert blobs to git internal format\n\t */\n\tif ((type == OBJ_BLOB) && path) {\n\t\tstruct strbuf nbuf = STRBUF_INIT;\n\t\tif (convert_to_git(path, buf, size, &nbuf,\n\t\t                   write_object ? safe_crlf : 0)) {\n\t\t\tbuf = strbuf_detach(&nbuf, &size);\n\t\t\tre_allocated = 1;\n\t\t}\n\t}\n\n\tif (write_object)\n\t\tret = write_sha1_file(buf, size, typename(type), sha1);\n\telse\n\t\tret = hash_sha1_file(buf, size, typename(type), sha1);\n\tif (re_allocated)\n\t\tfree(buf);\n\treturn ret;\n}\n\n#define SMALL_FILE_SIZE (32*1024)\n\nint index_fd(unsigned char *sha1, int fd, struct stat *st, int write_object,\n\t     enum object_type type, const char *path)\n{\n\tint ret;\n\tsize_t size = xsize_t(st->st_size);\n\n\tif (!S_ISREG(st->st_mode)) {\n\t\tstruct strbuf sbuf = STRBUF_INIT;\n\t\tif (strbuf_read(&sbuf, fd, 4096) >= 0)\n\t\t\tret = index_mem(sha1, sbuf.buf, sbuf.len, write_object,\n\t\t\t\t\ttype, path);\n\t\telse\n\t\t\tret = -1;\n\t\tstrbuf_release(&sbuf);\n\t} else if (size <= SMALL_FILE_SIZE) {\n\t\tchar *buf = xmalloc(size);\n\t\tif (size == read_in_full(fd, buf, size))\n\t\t\tret = index_mem(sha1, buf, size, write_object, type,\n\t\t\t\t\tpath);\n\t\telse\n\t\t\tret = error(\"short read %s\", strerror(errno));\n\t\tfree(buf);\n\t} else if (size) {\n\t\tvoid *buf = xmmap(NULL, size, PROT_READ, MAP_PRIVATE, fd, 0);\n\t\tret = index_mem(sha1, buf, size, write_object, type, path);\n\t\tmunmap(buf, size);\n\t} else\n\t\tret = index_mem(sha1, NULL, size, write_object, type, path);\n\tclose(fd);\n\treturn ret;\n}\n\nint index_path(unsigned char *sha1, const char *path, struct stat *st, int write_object)\n{\n\tint fd;\n\tstruct strbuf sb = STRBUF_INIT;\n\n\tswitch (st->st_mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tfd = open(path, O_RDONLY);\n\t\tif (fd < 0)\n\t\t\treturn error(\"open(\\\"%s\\\"): %s\", path,\n\t\t\t\t     strerror(errno));\n\t\tif (index_fd(sha1, fd, st, write_object, OBJ_BLOB, path) < 0)\n\t\t\treturn error(\"%s: failed to insert into database\",\n\t\t\t\t     path);\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tif (strbuf_readlink(&sb, path, st->st_size)) {\n\t\t\tchar *errstr = strerror(errno);\n\t\t\treturn error(\"readlink(\\\"%s\\\"): %s\", path,\n\t\t\t             errstr);\n\t\t}\n\t\tif (!write_object)\n\t\t\thash_sha1_file(sb.buf, sb.len, blob_type, sha1);\n\t\telse if (write_sha1_file(sb.buf, sb.len, blob_type, sha1))\n\t\t\treturn error(\"%s: failed to insert into database\",\n\t\t\t\t     path);\n\t\tstrbuf_release(&sb);\n\t\tbreak;\n\tcase S_IFDIR:\n\t\treturn resolve_gitlink_ref(path, \"HEAD\", sha1);\n\tdefault:\n\t\treturn error(\"%s: unsupported file type\", path);\n\t}\n\treturn 0;\n}\n\nint read_pack_header(int fd, struct pack_header *header)\n{\n\tif (read_in_full(fd, header, sizeof(*header)) < sizeof(*header))\n\t\t/* \"eof before pack header was fully read\" */\n\t\treturn PH_ERROR_EOF;\n\n\tif (header->hdr_signature != htonl(PACK_SIGNATURE))\n\t\t/* \"protocol error (pack signature mismatch detected)\" */\n\t\treturn PH_ERROR_PACK_SIGNATURE;\n\tif (!pack_version_ok(header->hdr_version))\n\t\t/* \"protocol error (pack version unsupported)\" */\n\t\treturn PH_ERROR_PROTOCOL;\n\treturn 0;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "006321e009b321db6cf4f7bf35d8385017a7076a",
  "sha1_ok": true,
  "size": 64946
}
