{
  "content": {
    "base64": "LyoKICogQnVpbHRpbiAiZ2l0IG5vdGVzIgogKgogKiBDb3B5cmlnaHQgKGMpIDIwMTAgSm9oYW4gSGVybGFuZCA8am9oYW5AaGVybGFuZC5uZXQ+CiAqCiAqIEJhc2VkIG9uIGdpdC1ub3Rlcy5zaCBieSBKb2hhbm5lcyBTY2hpbmRlbGluLAogKiBhbmQgYnVpbHRpbi10YWcuYyBieSBLcmlzdGlhbiBIw7hnc2JlcmcgYW5kIENhcmxvcyBSaWNhLgogKi8KCiNpbmNsdWRlICJjYWNoZS5oIgojaW5jbHVkZSAiYnVpbHRpbi5oIgojaW5jbHVkZSAibm90ZXMuaCIKI2luY2x1ZGUgImJsb2IuaCIKI2luY2x1ZGUgImNvbW1pdC5oIgojaW5jbHVkZSAicmVmcy5oIgojaW5jbHVkZSAiZXhlY19jbWQuaCIKI2luY2x1ZGUgInJ1bi1jb21tYW5kLmgiCiNpbmNsdWRlICJwYXJzZS1vcHRpb25zLmgiCgpzdGF0aWMgY29uc3QgY2hhciAqIGNvbnN0IGdpdF9ub3Rlc191c2FnZVtdID0gewoJImdpdCBub3RlcyBbbGlzdCBbPG9iamVjdD5dXSIsCgkiZ2l0IG5vdGVzIGFkZCBbLWZdIFstbSA8bXNnPiB8IC1GIDxmaWxlPl0gWzxvYmplY3Q+XSIsCgkiZ2l0IG5vdGVzIGVkaXQgWy1tIDxtc2c+IHwgLUYgPGZpbGU+XSBbPG9iamVjdD5dIiwKCSJnaXQgbm90ZXMgc2hvdyBbPG9iamVjdD5dIiwKCSJnaXQgbm90ZXMgcmVtb3ZlIFs8b2JqZWN0Pl0iLAoJImdpdCBub3RlcyBwcnVuZSIsCglOVUxMCn07CgpzdGF0aWMgY29uc3QgY2hhciBub3RlX3RlbXBsYXRlW10gPQoJIlxuIgoJIiNcbiIKCSIjIFdyaXRlL2VkaXQgdGhlIG5vdGVzIGZvciB0aGUgZm9sbG93aW5nIG9iamVjdDpcbiIKCSIjXG4iOwoKc3RhdGljIGludCBsaXN0X2VhY2hfbm90ZShjb25zdCB1bnNpZ25lZCBjaGFyICpvYmplY3Rfc2hhMSwKCQljb25zdCB1bnNpZ25lZCBjaGFyICpub3RlX3NoYTEsIGNoYXIgKm5vdGVfcGF0aCwKCQl2b2lkICpjYl9kYXRhKQp7CglwcmludGYoIiVzICVzXG4iLCBzaGExX3RvX2hleChub3RlX3NoYTEpLCBzaGExX3RvX2hleChvYmplY3Rfc2hhMSkpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyB2b2lkIHdyaXRlX25vdGVfZGF0YShpbnQgZmQsIGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEpCnsKCXVuc2lnbmVkIGxvbmcgc2l6ZTsKCWVudW0gb2JqZWN0X3R5cGUgdHlwZTsKCWNoYXIgKmJ1ZiA9IHJlYWRfc2hhMV9maWxlKHNoYTEsICZ0eXBlLCAmc2l6ZSk7CglpZiAoYnVmKSB7CgkJaWYgKHNpemUpCgkJCXdyaXRlX29yX2RpZShmZCwgYnVmLCBzaXplKTsKCQlmcmVlKGJ1Zik7Cgl9Cn0KCnN0YXRpYyB2b2lkIHdyaXRlX2NvbW1lbnRlZF9vYmplY3QoaW50IGZkLCBjb25zdCB1bnNpZ25lZCBjaGFyICpvYmplY3QpCnsKCWNvbnN0IGNoYXIgKnNob3dfYXJnc1s1XSA9CgkJeyJzaG93IiwgIi0tc3RhdCIsICItLW5vLW5vdGVzIiwgc2hhMV90b19oZXgob2JqZWN0KSwgTlVMTH07CglzdHJ1Y3QgY2hpbGRfcHJvY2VzcyBzaG93OwoJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCUZJTEUgKnNob3dfb3V0OwoKCS8qIEludm9rZSAiZ2l0IHNob3cgLS1zdGF0IC0tbm8tbm90ZXMgJG9iamVjdCIgKi8KCW1lbXNldCgmc2hvdywgMCwgc2l6ZW9mKHNob3cpKTsKCXNob3cuYXJndiA9IHNob3dfYXJnczsKCXNob3cubm9fc3RkaW4gPSAxOwoJc2hvdy5vdXQgPSAtMTsKCXNob3cuZXJyID0gMDsKCXNob3cuZ2l0X2NtZCA9IDE7CglpZiAoc3RhcnRfY29tbWFuZCgmc2hvdykpCgkJZGllKCJ1bmFibGUgdG8gc3RhcnQgJ3Nob3cnIGZvciBvYmplY3QgJyVzJyIsCgkJICAgIHNoYTFfdG9faGV4KG9iamVjdCkpOwoKCS8qIE9wZW4gdGhlIG91dHB1dCBhcyBGSUxFKiBzbyBzdHJidWZfZ2V0bGluZSgpIGNhbiBiZSB1c2VkLiAqLwoJc2hvd19vdXQgPSB4ZmRvcGVuKHNob3cub3V0LCAiciIpOwoJaWYgKHNob3dfb3V0ID09IE5VTEwpCgkJZGllX2Vycm5vKCJjYW4ndCBmZG9wZW4gJ3Nob3cnIG91dHB1dCBmZCIpOwoKCS8qIFByZXBlbmQgIiMgIiB0byBlYWNoIG91dHB1dCBsaW5lIGFuZCB3cml0ZSByZXN1bHQgdG8gJ2ZkJyAqLwoJd2hpbGUgKHN0cmJ1Zl9nZXRsaW5lKCZidWYsIHNob3dfb3V0LCAnXG4nKSAhPSBFT0YpIHsKCQl3cml0ZV9vcl9kaWUoZmQsICIjICIsIDIpOwoJCXdyaXRlX29yX2RpZShmZCwgYnVmLmJ1ZiwgYnVmLmxlbik7CgkJd3JpdGVfb3JfZGllKGZkLCAiXG4iLCAxKTsKCX0KCXN0cmJ1Zl9yZWxlYXNlKCZidWYpOwoJaWYgKGZjbG9zZShzaG93X291dCkpCgkJZGllX2Vycm5vKCJmYWlsZWQgdG8gY2xvc2UgcGlwZSB0byAnc2hvdycgZm9yIG9iamVjdCAnJXMnIiwKCQkJICBzaGExX3RvX2hleChvYmplY3QpKTsKCWlmIChmaW5pc2hfY29tbWFuZCgmc2hvdykpCgkJZGllKCJmYWlsZWQgdG8gZmluaXNoICdzaG93JyBmb3Igb2JqZWN0ICclcyciLAoJCSAgICBzaGExX3RvX2hleChvYmplY3QpKTsKfQoKc3RhdGljIHZvaWQgY3JlYXRlX25vdGUoY29uc3QgdW5zaWduZWQgY2hhciAqb2JqZWN0LAoJCQlzdHJ1Y3Qgc3RyYnVmICpidWYsCgkJCWludCBza2lwX2VkaXRvciwKCQkJY29uc3QgdW5zaWduZWQgY2hhciAqcHJldiwKCQkJdW5zaWduZWQgY2hhciAqcmVzdWx0KQp7CgljaGFyICpwYXRoID0gTlVMTDsKCglpZiAoIXNraXBfZWRpdG9yKSB7CgkJaW50IGZkOwoKCQkvKiB3cml0ZSB0aGUgdGVtcGxhdGUgbWVzc2FnZSBiZWZvcmUgZWRpdGluZzogKi8KCQlwYXRoID0gZ2l0X3BhdGhkdXAoIk5PVEVTX0VESVRNU0ciKTsKCQlmZCA9IG9wZW4ocGF0aCwgT19DUkVBVCB8IE9fVFJVTkMgfCBPX1dST05MWSwgMDYwMCk7CgkJaWYgKGZkIDwgMCkKCQkJZGllX2Vycm5vKCJjb3VsZCBub3QgY3JlYXRlIGZpbGUgJyVzJyIsIHBhdGgpOwoKCQlpZiAocHJldikKCQkJd3JpdGVfbm90ZV9kYXRhKGZkLCBwcmV2KTsKCQl3cml0ZV9vcl9kaWUoZmQsIG5vdGVfdGVtcGxhdGUsIHN0cmxlbihub3RlX3RlbXBsYXRlKSk7CgoJCXdyaXRlX2NvbW1lbnRlZF9vYmplY3QoZmQsIG9iamVjdCk7CgoJCWNsb3NlKGZkKTsKCgkJaWYgKGxhdW5jaF9lZGl0b3IocGF0aCwgYnVmLCBOVUxMKSkgewoJCQlkaWUoIlBsZWFzZSBzdXBwbHkgdGhlIG5vdGUgY29udGVudHMgdXNpbmcgZWl0aGVyIC1tIiBcCgkJCSAgICAiIG9yIC1GIG9wdGlvbiIpOwoJCX0KCX0KCglzdHJpcHNwYWNlKGJ1ZiwgMSk7CgoJaWYgKCFidWYtPmxlbikgewoJCWZwcmludGYoc3RkZXJyLCAiUmVtb3Zpbmcgbm90ZSBmb3Igb2JqZWN0ICVzXG4iLAoJCQlzaGExX3RvX2hleChvYmplY3QpKTsKCQloYXNoY2xyKHJlc3VsdCk7Cgl9IGVsc2UgewoJCWlmICh3cml0ZV9zaGExX2ZpbGUoYnVmLT5idWYsIGJ1Zi0+bGVuLCBibG9iX3R5cGUsIHJlc3VsdCkpIHsKCQkJZXJyb3IoInVuYWJsZSB0byB3cml0ZSBub3RlIG9iamVjdCIpOwoJCQlpZiAocGF0aCkKCQkJCWVycm9yKCJUaGUgbm90ZSBjb250ZW50cyBoYXMgYmVlbiBsZWZ0IGluICVzIiwKCQkJCSAgICAgIHBhdGgpOwoJCQlleGl0KDEyOCk7CgkJfQoJfQoKCWlmIChwYXRoKSB7CgkJdW5saW5rX29yX3dhcm4ocGF0aCk7CgkJZnJlZShwYXRoKTsKCX0KfQoKc3RydWN0IG1zZ19hcmcgewoJaW50IGdpdmVuOwoJc3RydWN0IHN0cmJ1ZiBidWY7Cn07CgpzdGF0aWMgaW50IHBhcnNlX21zZ19hcmcoY29uc3Qgc3RydWN0IG9wdGlvbiAqb3B0LCBjb25zdCBjaGFyICphcmcsIGludCB1bnNldCkKewoJc3RydWN0IG1zZ19hcmcgKm1zZyA9IG9wdC0+dmFsdWU7CgoJaWYgKCFhcmcpCgkJcmV0dXJuIC0xOwoJaWYgKG1zZy0+YnVmLmxlbikKCQlzdHJidWZfYWRkc3RyKCYobXNnLT5idWYpLCAiXG5cbiIpOwoJc3RyYnVmX2FkZHN0cigmKG1zZy0+YnVmKSwgYXJnKTsKCW1zZy0+Z2l2ZW4gPSAxOwoJcmV0dXJuIDA7Cn0KCmludCBjb21taXRfbm90ZXMoc3RydWN0IG5vdGVzX3RyZWUgKnQsIGNvbnN0IGNoYXIgKm1zZykKewoJc3RydWN0IGNvbW1pdF9saXN0ICpwYXJlbnQ7Cgl1bnNpZ25lZCBjaGFyIHRyZWVfc2hhMVsyMF0sIHByZXZfY29tbWl0WzIwXSwgbmV3X2NvbW1pdFsyMF07CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoKCWlmICghdCkKCQl0ID0gJmRlZmF1bHRfbm90ZXNfdHJlZTsKCWlmICghdC0+aW5pdGlhbGl6ZWQgfHwgIXQtPnJlZiB8fCAhKnQtPnJlZikKCQlkaWUoIkNhbm5vdCBjb21taXQgdW5pbml0aWFsaXplZC91bnJlZmVyZW5jZWQgbm90ZXMgdHJlZSIpOwoKCS8qIFByZXBhcmUgY29tbWl0IG1lc3NhZ2UgYW5kIHJlZmxvZyBtZXNzYWdlICovCglzdHJidWZfYWRkc3RyKCZidWYsICJub3RlczogIik7IC8qIGNvbW1pdCBtZXNzYWdlIHN0YXJ0cyBhdCBpbmRleCA3ICovCglzdHJidWZfYWRkc3RyKCZidWYsIG1zZyk7CglpZiAoYnVmLmJ1ZltidWYubGVuIC0gMV0gIT0gJ1xuJykKCQlzdHJidWZfYWRkY2goJmJ1ZiwgJ1xuJyk7IC8qIE1ha2Ugc3VyZSBtc2cgZW5kcyB3aXRoIG5ld2xpbmUgKi8KCgkvKiBDb252ZXJ0IG5vdGVzIHRyZWUgdG8gdHJlZSBvYmplY3QgKi8KCWlmICh3cml0ZV9ub3Rlc190cmVlKHQsIHRyZWVfc2hhMSkpCgkJZGllKCJGYWlsZWQgdG8gd3JpdGUgY3VycmVudCBub3RlcyB0cmVlIHRvIGRhdGFiYXNlIik7CgoJLyogQ3JlYXRlIG5ldyBjb21taXQgZm9yIHRoZSB0cmVlIG9iamVjdCAqLwoJaWYgKCFyZWFkX3JlZih0LT5yZWYsIHByZXZfY29tbWl0KSkgeyAvKiByZXRyaWV2ZSBwYXJlbnQgY29tbWl0ICovCgkJcGFyZW50ID0geG1hbGxvYyhzaXplb2YoKnBhcmVudCkpOwoJCXBhcmVudC0+aXRlbSA9IGxvb2t1cF9jb21taXQocHJldl9jb21taXQpOwoJCXBhcmVudC0+bmV4dCA9IE5VTEw7Cgl9IGVsc2UgewoJCWhhc2hjbHIocHJldl9jb21taXQpOwoJCXBhcmVudCA9IE5VTEw7Cgl9CglpZiAoY29tbWl0X3RyZWUoYnVmLmJ1ZiArIDcsIHRyZWVfc2hhMSwgcGFyZW50LCBuZXdfY29tbWl0LCBOVUxMKSkKCQlkaWUoIkZhaWxlZCB0byBjb21taXQgbm90ZXMgdHJlZSB0byBkYXRhYmFzZSIpOwoKCS8qIFVwZGF0ZSBub3RlcyByZWYgd2l0aCBuZXcgY29tbWl0ICovCgl1cGRhdGVfcmVmKGJ1Zi5idWYsIHQtPnJlZiwgbmV3X2NvbW1pdCwgcHJldl9jb21taXQsIDAsIERJRV9PTl9FUlIpOwoKCXN0cmJ1Zl9yZWxlYXNlKCZidWYpOwoJcmV0dXJuIDA7Cn0KCmludCBjbWRfbm90ZXMoaW50IGFyZ2MsIGNvbnN0IGNoYXIgKiphcmd2LCBjb25zdCBjaGFyICpwcmVmaXgpCnsKCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3Qgbm90ZXNfdHJlZSAqdDsKCXVuc2lnbmVkIGNoYXIgb2JqZWN0WzIwXSwgbmV3X25vdGVbMjBdOwoJY29uc3QgdW5zaWduZWQgY2hhciAqbm90ZTsKCWNvbnN0IGNoYXIgKm9iamVjdF9yZWY7CgljaGFyIGxvZ21zZ1sxMDBdOwoKCWludCBsaXN0ID0gMCwgYWRkID0gMCwgZWRpdCA9IDAsIHNob3cgPSAwLCByZW1vdmUgPSAwLCBwcnVuZSA9IDAsCgkgICAgZm9yY2UgPSAwOwoJaW50IGdpdmVuX29iamVjdDsKCWNvbnN0IGNoYXIgKm1zZ2ZpbGUgPSBOVUxMOwoJc3RydWN0IG1zZ19hcmcgbXNnID0geyAwLCBTVFJCVUZfSU5JVCB9OwoJc3RydWN0IG9wdGlvbiBvcHRpb25zW10gPSB7CgkJT1BUX0dST1VQKCJOb3RlcyBlZGl0IG9wdGlvbnMiKSwKCQlPUFRfQ0FMTEJBQ0soJ20nLCAibWVzc2FnZSIsICZtc2csICJtc2ciLAoJCQkgICAgICJub3RlIGNvbnRlbnRzIGFzIGEgc3RyaW5nIiwgcGFyc2VfbXNnX2FyZyksCgkJT1BUX0ZJTEVOQU1FKCdGJywgImZpbGUiLCAmbXNnZmlsZSwgIm5vdGUgY29udGVudHMgaW4gYSBmaWxlIiksCgkJT1BUX0JPT0xFQU4oJ2YnLCAiZm9yY2UiLCAmZm9yY2UsICJyZXBsYWNlIGV4aXN0aW5nIG5vdGVzIiksCgkJT1BUX0VORCgpCgl9OwoKCWdpdF9jb25maWcoZ2l0X2RlZmF1bHRfY29uZmlnLCBOVUxMKTsKCglhcmdjID0gcGFyc2Vfb3B0aW9ucyhhcmdjLCBhcmd2LCBwcmVmaXgsIG9wdGlvbnMsIGdpdF9ub3Rlc191c2FnZSwgMCk7CgoJaWYgKGFyZ2MgJiYgIXN0cmNtcChhcmd2WzBdLCAibGlzdCIpKQoJCWxpc3QgPSAxOwoJZWxzZSBpZiAoYXJnYyAmJiAhc3RyY21wKGFyZ3ZbMF0sICJhZGQiKSkKCQlhZGQgPSAxOwoJZWxzZSBpZiAoYXJnYyAmJiAhc3RyY21wKGFyZ3ZbMF0sICJlZGl0IikpCgkJZWRpdCA9IDE7CgllbHNlIGlmIChhcmdjICYmICFzdHJjbXAoYXJndlswXSwgInNob3ciKSkKCQlzaG93ID0gMTsKCWVsc2UgaWYgKGFyZ2MgJiYgIXN0cmNtcChhcmd2WzBdLCAicmVtb3ZlIikpCgkJcmVtb3ZlID0gMTsKCWVsc2UgaWYgKGFyZ2MgJiYgIXN0cmNtcChhcmd2WzBdLCAicHJ1bmUiKSkKCQlwcnVuZSA9IDE7CgllbHNlIGlmICghYXJnYykKCQlsaXN0ID0gMTsgLyogRGVmYXVsdCB0byAnbGlzdCcgaWYgbm8gb3RoZXIgc3ViY29tbWFuZCBnaXZlbiAqLwoKCWlmIChsaXN0ICsgYWRkICsgZWRpdCArIHNob3cgKyByZW1vdmUgKyBwcnVuZSAhPSAxKQoJCXVzYWdlX3dpdGhfb3B0aW9ucyhnaXRfbm90ZXNfdXNhZ2UsIG9wdGlvbnMpOwoKCWlmICgobXNnLmdpdmVuIHx8IG1zZ2ZpbGUpICYmICEoYWRkIHx8IGVkaXQpKSB7CgkJZXJyb3IoImNhbm5vdCB1c2UgLW0vLUYgb3B0aW9ucyB3aXRoICVzIHN1YmNvbW1hbmQuIiwgYXJndlswXSk7CgkJdXNhZ2Vfd2l0aF9vcHRpb25zKGdpdF9ub3Rlc191c2FnZSwgb3B0aW9ucyk7Cgl9CgoJaWYgKG1zZy5naXZlbiAmJiBtc2dmaWxlKSB7CgkJZXJyb3IoIm1peGluZyAtbSBhbmQgLUYgb3B0aW9ucyBpcyBub3QgYWxsb3dlZC4iKTsKCQl1c2FnZV93aXRoX29wdGlvbnMoZ2l0X25vdGVzX3VzYWdlLCBvcHRpb25zKTsKCX0KCglpZiAoZm9yY2UgJiYgIWFkZCkgewoJCWVycm9yKCJjYW5ub3QgdXNlIC1mIG9wdGlvbiB3aXRoICVzIHN1YmNvbW1hbmQuIiwgYXJndlswXSk7CgkJdXNhZ2Vfd2l0aF9vcHRpb25zKGdpdF9ub3Rlc191c2FnZSwgb3B0aW9ucyk7Cgl9CgoJZ2l2ZW5fb2JqZWN0ID0gYXJnYyA9PSAyOwoJb2JqZWN0X3JlZiA9IGdpdmVuX29iamVjdCA/IGFyZ3ZbMV0gOiAiSEVBRCI7CglpZiAoYXJnYyA+IDIgfHwgKHBydW5lICYmIGFyZ2MgPiAxKSkgewoJCWVycm9yKCJ0b28gbWFueSBwYXJhbWV0ZXJzIik7CgkJdXNhZ2Vfd2l0aF9vcHRpb25zKGdpdF9ub3Rlc191c2FnZSwgb3B0aW9ucyk7Cgl9CgoJaWYgKGdldF9zaGExKG9iamVjdF9yZWYsIG9iamVjdCkpCgkJZGllKCJGYWlsZWQgdG8gcmVzb2x2ZSAnJXMnIGFzIGEgdmFsaWQgcmVmLiIsIG9iamVjdF9yZWYpOwoKCWluaXRfbm90ZXMoTlVMTCwgTlVMTCwgTlVMTCwgMCk7Cgl0ID0gJmRlZmF1bHRfbm90ZXNfdHJlZTsKCglpZiAocHJlZml4Y21wKHQtPnJlZiwgInJlZnMvbm90ZXMvIikpCgkJZGllKCJSZWZ1c2luZyB0byAlcyBub3RlcyBpbiAlcyAob3V0c2lkZSBvZiByZWZzL25vdGVzLykiLAoJCSAgICBhcmd2WzBdLCB0LT5yZWYpOwoKCW5vdGUgPSBnZXRfbm90ZSh0LCBvYmplY3QpOwoKCS8qIGxpc3QgY29tbWFuZCAqLwoKCWlmIChsaXN0KSB7CgkJaWYgKGdpdmVuX29iamVjdCkgewoJCQlpZiAobm90ZSkgewoJCQkJcHV0cyhzaGExX3RvX2hleChub3RlKSk7CgkJCQlyZXR1cm4gMDsKCQkJfQoJCX0gZWxzZQoJCQlyZXR1cm4gZm9yX2VhY2hfbm90ZSh0LCAwLCBsaXN0X2VhY2hfbm90ZSwgTlVMTCk7Cgl9CgoJLyogc2hvdyBjb21tYW5kICovCgoJaWYgKChsaXN0IHx8IHNob3cpICYmICFub3RlKSB7CgkJZXJyb3IoIk5vIG5vdGUgZm91bmQgZm9yIG9iamVjdCAlcy4iLCBzaGExX3RvX2hleChvYmplY3QpKTsKCQlyZXR1cm4gMTsKCX0gZWxzZSBpZiAoc2hvdykgewoJCWNvbnN0IGNoYXIgKnNob3dfYXJnc1szXSA9IHsic2hvdyIsIHNoYTFfdG9faGV4KG5vdGUpLCBOVUxMfTsKCQlyZXR1cm4gZXhlY3ZfZ2l0X2NtZChzaG93X2FyZ3MpOwoJfQoKCS8qIGFkZC9lZGl0L3JlbW92ZS9wcnVuZSBjb21tYW5kICovCgoJaWYgKGFkZCAmJiBub3RlKSB7CgkJaWYgKGZvcmNlKQoJCQlmcHJpbnRmKHN0ZGVyciwgIk92ZXJ3cml0aW5nIGV4aXN0aW5nIG5vdGVzIGZvciBvYmplY3QgJXNcbiIsCgkJCQlzaGExX3RvX2hleChvYmplY3QpKTsKCQllbHNlIHsKCQkJZXJyb3IoIkNhbm5vdCBhZGQgbm90ZXMuIEZvdW5kIGV4aXN0aW5nIG5vdGVzIGZvciBvYmplY3QgJXMuICIKCQkJICAgICAgIlVzZSAnLWYnIHRvIG92ZXJ3cml0ZSBleGlzdGluZyBub3RlcyIsCgkJCSAgICAgIHNoYTFfdG9faGV4KG9iamVjdCkpOwoJCQlyZXR1cm4gMTsKCQl9Cgl9CgoJaWYgKHJlbW92ZSkKCQlzdHJidWZfcmVzZXQoJmJ1Zik7CgllbHNlIGlmIChtc2cuZ2l2ZW4pCgkJc3RyYnVmX2FkZGJ1ZigmYnVmLCAmKG1zZy5idWYpKTsKCWVsc2UgaWYgKG1zZ2ZpbGUpIHsKCQlpZiAoIXN0cmNtcChtc2dmaWxlLCAiLSIpKSB7CgkJCWlmIChzdHJidWZfcmVhZCgmYnVmLCAwLCAxMDI0KSA8IDApCgkJCQlkaWVfZXJybm8oImNhbm5vdCByZWFkICclcyciLCBtc2dmaWxlKTsKCQl9IGVsc2UgaWYgKHN0cmJ1Zl9yZWFkX2ZpbGUoJmJ1ZiwgbXNnZmlsZSwgMTAyNCkgPCAwKQoJCQlkaWVfZXJybm8oImNvdWxkIG5vdCBvcGVuIG9yIHJlYWQgJyVzJyIsIG1zZ2ZpbGUpOwoJfQoKCWlmIChwcnVuZSkgewoJCWhhc2hjbHIobmV3X25vdGUpOwoJCXBydW5lX25vdGVzKHQpOwoJfSBlbHNlIHsKCQljcmVhdGVfbm90ZShvYmplY3QsICZidWYsIG1zZy5naXZlbiB8fCBtc2dmaWxlIHx8IHJlbW92ZSwgbm90ZSwKCQkJICAgIG5ld19ub3RlKTsKCQlpZiAoaXNfbnVsbF9zaGExKG5ld19ub3RlKSkKCQkJcmVtb3ZlX25vdGUodCwgb2JqZWN0KTsKCQllbHNlCgkJCWFkZF9ub3RlKHQsIG9iamVjdCwgbmV3X25vdGUsIGNvbWJpbmVfbm90ZXNfb3ZlcndyaXRlKTsKCX0KCXNucHJpbnRmKGxvZ21zZywgc2l6ZW9mKGxvZ21zZyksICJOb3RlICVzIGJ5ICdnaXQgbm90ZXMgJXMnIiwKCQkgaXNfbnVsbF9zaGExKG5ld19ub3RlKSA/ICJyZW1vdmVkIiA6ICJhZGRlZCIsIGFyZ3ZbMF0pOwoJY29tbWl0X25vdGVzKHQsIGxvZ21zZyk7CgoJZnJlZV9ub3Rlcyh0KTsKCXN0cmJ1Zl9yZWxlYXNlKCZidWYpOwoJcmV0dXJuIDA7Cn0K",
    "text": "/*\n * Builtin \"git notes\"\n *\n * Copyright (c) 2010 Johan Herland <johan@herland.net>\n *\n * Based on git-notes.sh by Johannes Schindelin,\n * and builtin-tag.c by Kristian H\u00f8gsberg and Carlos Rica.\n */\n\n#include \"cache.h\"\n#include \"builtin.h\"\n#include \"notes.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"refs.h\"\n#include \"exec_cmd.h\"\n#include \"run-command.h\"\n#include \"parse-options.h\"\n\nstatic const char * const git_notes_usage[] = {\n\t\"git notes [list [<object>]]\",\n\t\"git notes add [-f] [-m <msg> | -F <file>] [<object>]\",\n\t\"git notes edit [-m <msg> | -F <file>] [<object>]\",\n\t\"git notes show [<object>]\",\n\t\"git notes remove [<object>]\",\n\t\"git notes prune\",\n\tNULL\n};\n\nstatic const char note_template[] =\n\t\"\\n\"\n\t\"#\\n\"\n\t\"# Write/edit the notes for the following object:\\n\"\n\t\"#\\n\";\n\nstatic int list_each_note(const unsigned char *object_sha1,\n\t\tconst unsigned char *note_sha1, char *note_path,\n\t\tvoid *cb_data)\n{\n\tprintf(\"%s %s\\n\", sha1_to_hex(note_sha1), sha1_to_hex(object_sha1));\n\treturn 0;\n}\n\nstatic void write_note_data(int fd, const unsigned char *sha1)\n{\n\tunsigned long size;\n\tenum object_type type;\n\tchar *buf = read_sha1_file(sha1, &type, &size);\n\tif (buf) {\n\t\tif (size)\n\t\t\twrite_or_die(fd, buf, size);\n\t\tfree(buf);\n\t}\n}\n\nstatic void write_commented_object(int fd, const unsigned char *object)\n{\n\tconst char *show_args[5] =\n\t\t{\"show\", \"--stat\", \"--no-notes\", sha1_to_hex(object), NULL};\n\tstruct child_process show;\n\tstruct strbuf buf = STRBUF_INIT;\n\tFILE *show_out;\n\n\t/* Invoke \"git show --stat --no-notes $object\" */\n\tmemset(&show, 0, sizeof(show));\n\tshow.argv = show_args;\n\tshow.no_stdin = 1;\n\tshow.out = -1;\n\tshow.err = 0;\n\tshow.git_cmd = 1;\n\tif (start_command(&show))\n\t\tdie(\"unable to start 'show' for object '%s'\",\n\t\t    sha1_to_hex(object));\n\n\t/* Open the output as FILE* so strbuf_getline() can be used. */\n\tshow_out = xfdopen(show.out, \"r\");\n\tif (show_out == NULL)\n\t\tdie_errno(\"can't fdopen 'show' output fd\");\n\n\t/* Prepend \"# \" to each output line and write result to 'fd' */\n\twhile (strbuf_getline(&buf, show_out, '\\n') != EOF) {\n\t\twrite_or_die(fd, \"# \", 2);\n\t\twrite_or_die(fd, buf.buf, buf.len);\n\t\twrite_or_die(fd, \"\\n\", 1);\n\t}\n\tstrbuf_release(&buf);\n\tif (fclose(show_out))\n\t\tdie_errno(\"failed to close pipe to 'show' for object '%s'\",\n\t\t\t  sha1_to_hex(object));\n\tif (finish_command(&show))\n\t\tdie(\"failed to finish 'show' for object '%s'\",\n\t\t    sha1_to_hex(object));\n}\n\nstatic void create_note(const unsigned char *object,\n\t\t\tstruct strbuf *buf,\n\t\t\tint skip_editor,\n\t\t\tconst unsigned char *prev,\n\t\t\tunsigned char *result)\n{\n\tchar *path = NULL;\n\n\tif (!skip_editor) {\n\t\tint fd;\n\n\t\t/* write the template message before editing: */\n\t\tpath = git_pathdup(\"NOTES_EDITMSG\");\n\t\tfd = open(path, O_CREAT | O_TRUNC | O_WRONLY, 0600);\n\t\tif (fd < 0)\n\t\t\tdie_errno(\"could not create file '%s'\", path);\n\n\t\tif (prev)\n\t\t\twrite_note_data(fd, prev);\n\t\twrite_or_die(fd, note_template, strlen(note_template));\n\n\t\twrite_commented_object(fd, object);\n\n\t\tclose(fd);\n\n\t\tif (launch_editor(path, buf, NULL)) {\n\t\t\tdie(\"Please supply the note contents using either -m\" \\\n\t\t\t    \" or -F option\");\n\t\t}\n\t}\n\n\tstripspace(buf, 1);\n\n\tif (!buf->len) {\n\t\tfprintf(stderr, \"Removing note for object %s\\n\",\n\t\t\tsha1_to_hex(object));\n\t\thashclr(result);\n\t} else {\n\t\tif (write_sha1_file(buf->buf, buf->len, blob_type, result)) {\n\t\t\terror(\"unable to write note object\");\n\t\t\tif (path)\n\t\t\t\terror(\"The note contents has been left in %s\",\n\t\t\t\t      path);\n\t\t\texit(128);\n\t\t}\n\t}\n\n\tif (path) {\n\t\tunlink_or_warn(path);\n\t\tfree(path);\n\t}\n}\n\nstruct msg_arg {\n\tint given;\n\tstruct strbuf buf;\n};\n\nstatic int parse_msg_arg(const struct option *opt, const char *arg, int unset)\n{\n\tstruct msg_arg *msg = opt->value;\n\n\tif (!arg)\n\t\treturn -1;\n\tif (msg->buf.len)\n\t\tstrbuf_addstr(&(msg->buf), \"\\n\\n\");\n\tstrbuf_addstr(&(msg->buf), arg);\n\tmsg->given = 1;\n\treturn 0;\n}\n\nint commit_notes(struct notes_tree *t, const char *msg)\n{\n\tstruct commit_list *parent;\n\tunsigned char tree_sha1[20], prev_commit[20], new_commit[20];\n\tstruct strbuf buf = STRBUF_INIT;\n\n\tif (!t)\n\t\tt = &default_notes_tree;\n\tif (!t->initialized || !t->ref || !*t->ref)\n\t\tdie(\"Cannot commit uninitialized/unreferenced notes tree\");\n\n\t/* Prepare commit message and reflog message */\n\tstrbuf_addstr(&buf, \"notes: \"); /* commit message starts at index 7 */\n\tstrbuf_addstr(&buf, msg);\n\tif (buf.buf[buf.len - 1] != '\\n')\n\t\tstrbuf_addch(&buf, '\\n'); /* Make sure msg ends with newline */\n\n\t/* Convert notes tree to tree object */\n\tif (write_notes_tree(t, tree_sha1))\n\t\tdie(\"Failed to write current notes tree to database\");\n\n\t/* Create new commit for the tree object */\n\tif (!read_ref(t->ref, prev_commit)) { /* retrieve parent commit */\n\t\tparent = xmalloc(sizeof(*parent));\n\t\tparent->item = lookup_commit(prev_commit);\n\t\tparent->next = NULL;\n\t} else {\n\t\thashclr(prev_commit);\n\t\tparent = NULL;\n\t}\n\tif (commit_tree(buf.buf + 7, tree_sha1, parent, new_commit, NULL))\n\t\tdie(\"Failed to commit notes tree to database\");\n\n\t/* Update notes ref with new commit */\n\tupdate_ref(buf.buf, t->ref, new_commit, prev_commit, 0, DIE_ON_ERR);\n\n\tstrbuf_release(&buf);\n\treturn 0;\n}\n\nint cmd_notes(int argc, const char **argv, const char *prefix)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tstruct notes_tree *t;\n\tunsigned char object[20], new_note[20];\n\tconst unsigned char *note;\n\tconst char *object_ref;\n\tchar logmsg[100];\n\n\tint list = 0, add = 0, edit = 0, show = 0, remove = 0, prune = 0,\n\t    force = 0;\n\tint given_object;\n\tconst char *msgfile = NULL;\n\tstruct msg_arg msg = { 0, STRBUF_INIT };\n\tstruct option options[] = {\n\t\tOPT_GROUP(\"Notes edit options\"),\n\t\tOPT_CALLBACK('m', \"message\", &msg, \"msg\",\n\t\t\t     \"note contents as a string\", parse_msg_arg),\n\t\tOPT_FILENAME('F', \"file\", &msgfile, \"note contents in a file\"),\n\t\tOPT_BOOLEAN('f', \"force\", &force, \"replace existing notes\"),\n\t\tOPT_END()\n\t};\n\n\tgit_config(git_default_config, NULL);\n\n\targc = parse_options(argc, argv, prefix, options, git_notes_usage, 0);\n\n\tif (argc && !strcmp(argv[0], \"list\"))\n\t\tlist = 1;\n\telse if (argc && !strcmp(argv[0], \"add\"))\n\t\tadd = 1;\n\telse if (argc && !strcmp(argv[0], \"edit\"))\n\t\tedit = 1;\n\telse if (argc && !strcmp(argv[0], \"show\"))\n\t\tshow = 1;\n\telse if (argc && !strcmp(argv[0], \"remove\"))\n\t\tremove = 1;\n\telse if (argc && !strcmp(argv[0], \"prune\"))\n\t\tprune = 1;\n\telse if (!argc)\n\t\tlist = 1; /* Default to 'list' if no other subcommand given */\n\n\tif (list + add + edit + show + remove + prune != 1)\n\t\tusage_with_options(git_notes_usage, options);\n\n\tif ((msg.given || msgfile) && !(add || edit)) {\n\t\terror(\"cannot use -m/-F options with %s subcommand.\", argv[0]);\n\t\tusage_with_options(git_notes_usage, options);\n\t}\n\n\tif (msg.given && msgfile) {\n\t\terror(\"mixing -m and -F options is not allowed.\");\n\t\tusage_with_options(git_notes_usage, options);\n\t}\n\n\tif (force && !add) {\n\t\terror(\"cannot use -f option with %s subcommand.\", argv[0]);\n\t\tusage_with_options(git_notes_usage, options);\n\t}\n\n\tgiven_object = argc == 2;\n\tobject_ref = given_object ? argv[1] : \"HEAD\";\n\tif (argc > 2 || (prune && argc > 1)) {\n\t\terror(\"too many parameters\");\n\t\tusage_with_options(git_notes_usage, options);\n\t}\n\n\tif (get_sha1(object_ref, object))\n\t\tdie(\"Failed to resolve '%s' as a valid ref.\", object_ref);\n\n\tinit_notes(NULL, NULL, NULL, 0);\n\tt = &default_notes_tree;\n\n\tif (prefixcmp(t->ref, \"refs/notes/\"))\n\t\tdie(\"Refusing to %s notes in %s (outside of refs/notes/)\",\n\t\t    argv[0], t->ref);\n\n\tnote = get_note(t, object);\n\n\t/* list command */\n\n\tif (list) {\n\t\tif (given_object) {\n\t\t\tif (note) {\n\t\t\t\tputs(sha1_to_hex(note));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else\n\t\t\treturn for_each_note(t, 0, list_each_note, NULL);\n\t}\n\n\t/* show command */\n\n\tif ((list || show) && !note) {\n\t\terror(\"No note found for object %s.\", sha1_to_hex(object));\n\t\treturn 1;\n\t} else if (show) {\n\t\tconst char *show_args[3] = {\"show\", sha1_to_hex(note), NULL};\n\t\treturn execv_git_cmd(show_args);\n\t}\n\n\t/* add/edit/remove/prune command */\n\n\tif (add && note) {\n\t\tif (force)\n\t\t\tfprintf(stderr, \"Overwriting existing notes for object %s\\n\",\n\t\t\t\tsha1_to_hex(object));\n\t\telse {\n\t\t\terror(\"Cannot add notes. Found existing notes for object %s. \"\n\t\t\t      \"Use '-f' to overwrite existing notes\",\n\t\t\t      sha1_to_hex(object));\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (remove)\n\t\tstrbuf_reset(&buf);\n\telse if (msg.given)\n\t\tstrbuf_addbuf(&buf, &(msg.buf));\n\telse if (msgfile) {\n\t\tif (!strcmp(msgfile, \"-\")) {\n\t\t\tif (strbuf_read(&buf, 0, 1024) < 0)\n\t\t\t\tdie_errno(\"cannot read '%s'\", msgfile);\n\t\t} else if (strbuf_read_file(&buf, msgfile, 1024) < 0)\n\t\t\tdie_errno(\"could not open or read '%s'\", msgfile);\n\t}\n\n\tif (prune) {\n\t\thashclr(new_note);\n\t\tprune_notes(t);\n\t} else {\n\t\tcreate_note(object, &buf, msg.given || msgfile || remove, note,\n\t\t\t    new_note);\n\t\tif (is_null_sha1(new_note))\n\t\t\tremove_note(t, object);\n\t\telse\n\t\t\tadd_note(t, object, new_note, combine_notes_overwrite);\n\t}\n\tsnprintf(logmsg, sizeof(logmsg), \"Note %s by 'git notes %s'\",\n\t\t is_null_sha1(new_note) ? \"removed\" : \"added\", argv[0]);\n\tcommit_notes(t, logmsg);\n\n\tfree_notes(t);\n\tstrbuf_release(&buf);\n\treturn 0;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "006edf6b1945de1962cf17185cb7639fe41ad494",
  "sha1_ok": true,
  "size": 8961
}
