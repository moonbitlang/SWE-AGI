{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJvYmplY3QuaCIKI2luY2x1ZGUgInJlcGxhY2Utb2JqZWN0LmgiCiNpbmNsdWRlICJvYmplY3Qtc3RvcmUuaCIKI2luY2x1ZGUgImJsb2IuaCIKI2luY2x1ZGUgInRyZWUuaCIKI2luY2x1ZGUgImNvbW1pdC5oIgojaW5jbHVkZSAidGFnLmgiCiNpbmNsdWRlICJhbGxvYy5oIgojaW5jbHVkZSAib2JqZWN0LXN0b3JlLmgiCiNpbmNsdWRlICJwYWNrZmlsZS5oIgoKdW5zaWduZWQgaW50IGdldF9tYXhfb2JqZWN0X2luZGV4KHZvaWQpCnsKCXJldHVybiB0aGVfcmVwb3NpdG9yeS0+cGFyc2VkX29iamVjdHMtPm9ial9oYXNoX3NpemU7Cn0KCnN0cnVjdCBvYmplY3QgKmdldF9pbmRleGVkX29iamVjdCh1bnNpZ25lZCBpbnQgaWR4KQp7CglyZXR1cm4gdGhlX3JlcG9zaXRvcnktPnBhcnNlZF9vYmplY3RzLT5vYmpfaGFzaFtpZHhdOwp9CgpzdGF0aWMgY29uc3QgY2hhciAqb2JqZWN0X3R5cGVfc3RyaW5nc1tdID0gewoJTlVMTCwJCS8qIE9CSl9OT05FID0gMCAqLwoJImNvbW1pdCIsCS8qIE9CSl9DT01NSVQgPSAxICovCgkidHJlZSIsCQkvKiBPQkpfVFJFRSA9IDIgKi8KCSJibG9iIiwJCS8qIE9CSl9CTE9CID0gMyAqLwoJInRhZyIsCQkvKiBPQkpfVEFHID0gNCAqLwp9OwoKY29uc3QgY2hhciAqdHlwZV9uYW1lKHVuc2lnbmVkIGludCB0eXBlKQp7CglpZiAodHlwZSA+PSBBUlJBWV9TSVpFKG9iamVjdF90eXBlX3N0cmluZ3MpKQoJCXJldHVybiBOVUxMOwoJcmV0dXJuIG9iamVjdF90eXBlX3N0cmluZ3NbdHlwZV07Cn0KCmludCB0eXBlX2Zyb21fc3RyaW5nX2dlbnRseShjb25zdCBjaGFyICpzdHIsIHNzaXplX3QgbGVuLCBpbnQgZ2VudGxlKQp7CglpbnQgaTsKCglpZiAobGVuIDwgMCkKCQlsZW4gPSBzdHJsZW4oc3RyKTsKCglmb3IgKGkgPSAxOyBpIDwgQVJSQVlfU0laRShvYmplY3RfdHlwZV9zdHJpbmdzKTsgaSsrKQoJCWlmICghc3RybmNtcChzdHIsIG9iamVjdF90eXBlX3N0cmluZ3NbaV0sIGxlbikgJiYKCQkgICAgb2JqZWN0X3R5cGVfc3RyaW5nc1tpXVtsZW5dID09ICdcMCcpCgkJCXJldHVybiBpOwoKCWlmIChnZW50bGUpCgkJcmV0dXJuIC0xOwoKCWRpZSgiaW52YWxpZCBvYmplY3QgdHlwZSBcIiVzXCIiLCBzdHIpOwp9CgovKgogKiBSZXR1cm4gYSBudW1lcmljYWwgaGFzaCB2YWx1ZSBiZXR3ZWVuIDAgYW5kIG4tMSBmb3IgdGhlIG9iamVjdCB3aXRoCiAqIHRoZSBzcGVjaWZpZWQgc2hhMS4gIG4gbXVzdCBiZSBhIHBvd2VyIG9mIDIuICBQbGVhc2Ugbm90ZSB0aGF0IHRoZQogKiByZXR1cm4gdmFsdWUgaXMgKm5vdCogY29uc2lzdGVudCBhY3Jvc3MgY29tcHV0ZXIgYXJjaGl0ZWN0dXJlcy4KICovCnN0YXRpYyB1bnNpZ25lZCBpbnQgaGFzaF9vYmooY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwgdW5zaWduZWQgaW50IG4pCnsKCXJldHVybiBzaGExaGFzaChzaGExKSAmIChuIC0gMSk7Cn0KCi8qCiAqIEluc2VydCBvYmogaW50byB0aGUgaGFzaCB0YWJsZSBoYXNoLCB3aGljaCBoYXMgbGVuZ3RoIHNpemUgKHdoaWNoCiAqIG11c3QgYmUgYSBwb3dlciBvZiAyKS4gIE9uIGNvbGxpc2lvbnMsIHNpbXBseSBvdmVyZmxvdyB0byB0aGUgbmV4dAogKiBlbXB0eSBidWNrZXQuCiAqLwpzdGF0aWMgdm9pZCBpbnNlcnRfb2JqX2hhc2goc3RydWN0IG9iamVjdCAqb2JqLCBzdHJ1Y3Qgb2JqZWN0ICoqaGFzaCwgdW5zaWduZWQgaW50IHNpemUpCnsKCXVuc2lnbmVkIGludCBqID0gaGFzaF9vYmoob2JqLT5vaWQuaGFzaCwgc2l6ZSk7CgoJd2hpbGUgKGhhc2hbal0pIHsKCQlqKys7CgkJaWYgKGogPj0gc2l6ZSkKCQkJaiA9IDA7Cgl9CgloYXNoW2pdID0gb2JqOwp9CgovKgogKiBMb29rIHVwIHRoZSByZWNvcmQgZm9yIHRoZSBnaXZlbiBzaGExIGluIHRoZSBoYXNoIG1hcCBzdG9yZWQgaW4KICogb2JqX2hhc2guICBSZXR1cm4gTlVMTCBpZiBpdCB3YXMgbm90IGZvdW5kLgogKi8Kc3RydWN0IG9iamVjdCAqbG9va3VwX29iamVjdF90aGVfcmVwb3NpdG9yeShjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExKQp7Cgl1bnNpZ25lZCBpbnQgaSwgZmlyc3Q7CglzdHJ1Y3Qgb2JqZWN0ICpvYmo7CgoJaWYgKCF0aGVfcmVwb3NpdG9yeS0+cGFyc2VkX29iamVjdHMtPm9ial9oYXNoKQoJCXJldHVybiBOVUxMOwoKCWZpcnN0ID0gaSA9IGhhc2hfb2JqKHNoYTEsCgkJCSAgICAgdGhlX3JlcG9zaXRvcnktPnBhcnNlZF9vYmplY3RzLT5vYmpfaGFzaF9zaXplKTsKCXdoaWxlICgob2JqID0gdGhlX3JlcG9zaXRvcnktPnBhcnNlZF9vYmplY3RzLT5vYmpfaGFzaFtpXSkgIT0gTlVMTCkgewoJCWlmICghaGFzaGNtcChzaGExLCBvYmotPm9pZC5oYXNoKSkKCQkJYnJlYWs7CgkJaSsrOwoJCWlmIChpID09IHRoZV9yZXBvc2l0b3J5LT5wYXJzZWRfb2JqZWN0cy0+b2JqX2hhc2hfc2l6ZSkKCQkJaSA9IDA7Cgl9CglpZiAob2JqICYmIGkgIT0gZmlyc3QpIHsKCQkvKgoJCSAqIE1vdmUgb2JqZWN0IHRvIHdoZXJlIHdlIHN0YXJ0ZWQgdG8gbG9vayBmb3IgaXQgc28KCQkgKiB0aGF0IHdlIGRvIG5vdCBuZWVkIHRvIHdhbGsgdGhlIGhhc2ggdGFibGUgdGhlIG5leHQKCQkgKiB0aW1lIHdlIGxvb2sgZm9yIGl0LgoJCSAqLwoJCVNXQVAodGhlX3JlcG9zaXRvcnktPnBhcnNlZF9vYmplY3RzLT5vYmpfaGFzaFtpXSwKCQkgICAgIHRoZV9yZXBvc2l0b3J5LT5wYXJzZWRfb2JqZWN0cy0+b2JqX2hhc2hbZmlyc3RdKTsKCX0KCXJldHVybiBvYmo7Cn0KCi8qCiAqIEluY3JlYXNlIHRoZSBzaXplIG9mIHRoZSBoYXNoIG1hcCBzdG9yZWQgaW4gb2JqX2hhc2ggdG8gdGhlIG5leHQKICogcG93ZXIgb2YgMiAoYnV0IGF0IGxlYXN0IDMyKS4gIENvcHkgdGhlIGV4aXN0aW5nIHZhbHVlcyB0byB0aGUgbmV3CiAqIGhhc2ggbWFwLgogKi8Kc3RhdGljIHZvaWQgZ3Jvd19vYmplY3RfaGFzaChzdHJ1Y3QgcmVwb3NpdG9yeSAqcikKewoJaW50IGk7CgkvKgoJICogTm90ZSB0aGF0IHRoaXMgc2l6ZSBtdXN0IGFsd2F5cyBiZSBwb3dlci1vZi0yIHRvIG1hdGNoIGhhc2hfb2JqCgkgKiBhYm92ZS4KCSAqLwoJaW50IG5ld19oYXNoX3NpemUgPSByLT5wYXJzZWRfb2JqZWN0cy0+b2JqX2hhc2hfc2l6ZSA8IDMyID8gMzIgOiAyICogci0+cGFyc2VkX29iamVjdHMtPm9ial9oYXNoX3NpemU7CglzdHJ1Y3Qgb2JqZWN0ICoqbmV3X2hhc2g7CgoJbmV3X2hhc2ggPSB4Y2FsbG9jKG5ld19oYXNoX3NpemUsIHNpemVvZihzdHJ1Y3Qgb2JqZWN0ICopKTsKCWZvciAoaSA9IDA7IGkgPCByLT5wYXJzZWRfb2JqZWN0cy0+b2JqX2hhc2hfc2l6ZTsgaSsrKSB7CgkJc3RydWN0IG9iamVjdCAqb2JqID0gci0+cGFyc2VkX29iamVjdHMtPm9ial9oYXNoW2ldOwoKCQlpZiAoIW9iaikKCQkJY29udGludWU7CgkJaW5zZXJ0X29ial9oYXNoKG9iaiwgbmV3X2hhc2gsIG5ld19oYXNoX3NpemUpOwoJfQoJZnJlZShyLT5wYXJzZWRfb2JqZWN0cy0+b2JqX2hhc2gpOwoJci0+cGFyc2VkX29iamVjdHMtPm9ial9oYXNoID0gbmV3X2hhc2g7CglyLT5wYXJzZWRfb2JqZWN0cy0+b2JqX2hhc2hfc2l6ZSA9IG5ld19oYXNoX3NpemU7Cn0KCnZvaWQgKmNyZWF0ZV9vYmplY3Qoc3RydWN0IHJlcG9zaXRvcnkgKnIsIGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEsIHZvaWQgKm8pCnsKCXN0cnVjdCBvYmplY3QgKm9iaiA9IG87CgoJb2JqLT5wYXJzZWQgPSAwOwoJb2JqLT5mbGFncyA9IDA7CgloYXNoY3B5KG9iai0+b2lkLmhhc2gsIHNoYTEpOwoKCWlmIChyLT5wYXJzZWRfb2JqZWN0cy0+b2JqX2hhc2hfc2l6ZSAtIDEgPD0gci0+cGFyc2VkX29iamVjdHMtPm5yX29ianMgKiAyKQoJCWdyb3dfb2JqZWN0X2hhc2gocik7CgoJaW5zZXJ0X29ial9oYXNoKG9iaiwgci0+cGFyc2VkX29iamVjdHMtPm9ial9oYXNoLAoJCQlyLT5wYXJzZWRfb2JqZWN0cy0+b2JqX2hhc2hfc2l6ZSk7CglyLT5wYXJzZWRfb2JqZWN0cy0+bnJfb2JqcysrOwoJcmV0dXJuIG9iajsKfQoKdm9pZCAqb2JqZWN0X2FzX3R5cGUoc3RydWN0IG9iamVjdCAqb2JqLCBlbnVtIG9iamVjdF90eXBlIHR5cGUsIGludCBxdWlldCkKewoJaWYgKG9iai0+dHlwZSA9PSB0eXBlKQoJCXJldHVybiBvYmo7CgllbHNlIGlmIChvYmotPnR5cGUgPT0gT0JKX05PTkUpIHsKCQlpZiAodHlwZSA9PSBPQkpfQ09NTUlUKQoJCQkoKHN0cnVjdCBjb21taXQgKilvYmopLT5pbmRleCA9IGFsbG9jX2NvbW1pdF9pbmRleCh0aGVfcmVwb3NpdG9yeSk7CgkJb2JqLT50eXBlID0gdHlwZTsKCQlyZXR1cm4gb2JqOwoJfQoJZWxzZSB7CgkJaWYgKCFxdWlldCkKCQkJZXJyb3IoIm9iamVjdCAlcyBpcyBhICVzLCBub3QgYSAlcyIsCgkJCSAgICAgIG9pZF90b19oZXgoJm9iai0+b2lkKSwKCQkJICAgICAgdHlwZV9uYW1lKG9iai0+dHlwZSksIHR5cGVfbmFtZSh0eXBlKSk7CgkJcmV0dXJuIE5VTEw7Cgl9Cn0KCnN0cnVjdCBvYmplY3QgKmxvb2t1cF91bmtub3duX29iamVjdChjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExKQp7CglzdHJ1Y3Qgb2JqZWN0ICpvYmogPSBsb29rdXBfb2JqZWN0KHRoZV9yZXBvc2l0b3J5LCBzaGExKTsKCWlmICghb2JqKQoJCW9iaiA9IGNyZWF0ZV9vYmplY3QodGhlX3JlcG9zaXRvcnksIHNoYTEsCgkJCQkgICAgYWxsb2Nfb2JqZWN0X25vZGUodGhlX3JlcG9zaXRvcnkpKTsKCXJldHVybiBvYmo7Cn0KCnN0cnVjdCBvYmplY3QgKnBhcnNlX29iamVjdF9idWZmZXIoY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLCBlbnVtIG9iamVjdF90eXBlIHR5cGUsIHVuc2lnbmVkIGxvbmcgc2l6ZSwgdm9pZCAqYnVmZmVyLCBpbnQgKmVhdGVuX3ApCnsKCXN0cnVjdCBvYmplY3QgKm9iajsKCSplYXRlbl9wID0gMDsKCglvYmogPSBOVUxMOwoJaWYgKHR5cGUgPT0gT0JKX0JMT0IpIHsKCQlzdHJ1Y3QgYmxvYiAqYmxvYiA9IGxvb2t1cF9ibG9iKG9pZCk7CgkJaWYgKGJsb2IpIHsKCQkJaWYgKHBhcnNlX2Jsb2JfYnVmZmVyKGJsb2IsIGJ1ZmZlciwgc2l6ZSkpCgkJCQlyZXR1cm4gTlVMTDsKCQkJb2JqID0gJmJsb2ItPm9iamVjdDsKCQl9Cgl9IGVsc2UgaWYgKHR5cGUgPT0gT0JKX1RSRUUpIHsKCQlzdHJ1Y3QgdHJlZSAqdHJlZSA9IGxvb2t1cF90cmVlKG9pZCk7CgkJaWYgKHRyZWUpIHsKCQkJb2JqID0gJnRyZWUtPm9iamVjdDsKCQkJaWYgKCF0cmVlLT5idWZmZXIpCgkJCQl0cmVlLT5vYmplY3QucGFyc2VkID0gMDsKCQkJaWYgKCF0cmVlLT5vYmplY3QucGFyc2VkKSB7CgkJCQlpZiAocGFyc2VfdHJlZV9idWZmZXIodHJlZSwgYnVmZmVyLCBzaXplKSkKCQkJCQlyZXR1cm4gTlVMTDsKCQkJCSplYXRlbl9wID0gMTsKCQkJfQoJCX0KCX0gZWxzZSBpZiAodHlwZSA9PSBPQkpfQ09NTUlUKSB7CgkJc3RydWN0IGNvbW1pdCAqY29tbWl0ID0gbG9va3VwX2NvbW1pdChvaWQpOwoJCWlmIChjb21taXQpIHsKCQkJaWYgKHBhcnNlX2NvbW1pdF9idWZmZXIoY29tbWl0LCBidWZmZXIsIHNpemUsIDEpKQoJCQkJcmV0dXJuIE5VTEw7CgkJCWlmICghZ2V0X2NhY2hlZF9jb21taXRfYnVmZmVyKGNvbW1pdCwgTlVMTCkpIHsKCQkJCXNldF9jb21taXRfYnVmZmVyKGNvbW1pdCwgYnVmZmVyLCBzaXplKTsKCQkJCSplYXRlbl9wID0gMTsKCQkJfQoJCQlvYmogPSAmY29tbWl0LT5vYmplY3Q7CgkJfQoJfSBlbHNlIGlmICh0eXBlID09IE9CSl9UQUcpIHsKCQlzdHJ1Y3QgdGFnICp0YWcgPSBsb29rdXBfdGFnKG9pZCk7CgkJaWYgKHRhZykgewoJCQlpZiAocGFyc2VfdGFnX2J1ZmZlcih0YWcsIGJ1ZmZlciwgc2l6ZSkpCgkJCSAgICAgICByZXR1cm4gTlVMTDsKCQkJb2JqID0gJnRhZy0+b2JqZWN0OwoJCX0KCX0gZWxzZSB7CgkJd2FybmluZygib2JqZWN0ICVzIGhhcyB1bmtub3duIHR5cGUgaWQgJWQiLCBvaWRfdG9faGV4KG9pZCksIHR5cGUpOwoJCW9iaiA9IE5VTEw7Cgl9CglyZXR1cm4gb2JqOwp9CgpzdHJ1Y3Qgb2JqZWN0ICpwYXJzZV9vYmplY3Rfb3JfZGllKGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwKCQkJCSAgIGNvbnN0IGNoYXIgKm5hbWUpCnsKCXN0cnVjdCBvYmplY3QgKm8gPSBwYXJzZV9vYmplY3QodGhlX3JlcG9zaXRvcnksIG9pZCk7CglpZiAobykKCQlyZXR1cm4gbzsKCglkaWUoXygidW5hYmxlIHRvIHBhcnNlIG9iamVjdDogJXMiKSwgbmFtZSA/IG5hbWUgOiBvaWRfdG9faGV4KG9pZCkpOwp9CgpzdHJ1Y3Qgb2JqZWN0ICpwYXJzZV9vYmplY3RfdGhlX3JlcG9zaXRvcnkoY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkKQp7Cgl1bnNpZ25lZCBsb25nIHNpemU7CgllbnVtIG9iamVjdF90eXBlIHR5cGU7CglpbnQgZWF0ZW47Cgljb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpyZXBsID0gbG9va3VwX3JlcGxhY2Vfb2JqZWN0KHRoZV9yZXBvc2l0b3J5LCBvaWQpOwoJdm9pZCAqYnVmZmVyOwoJc3RydWN0IG9iamVjdCAqb2JqOwoKCW9iaiA9IGxvb2t1cF9vYmplY3QodGhlX3JlcG9zaXRvcnksIG9pZC0+aGFzaCk7CglpZiAob2JqICYmIG9iai0+cGFyc2VkKQoJCXJldHVybiBvYmo7CgoJaWYgKChvYmogJiYgb2JqLT50eXBlID09IE9CSl9CTE9CICYmIGhhc19vYmplY3RfZmlsZShvaWQpKSB8fAoJICAgICghb2JqICYmIGhhc19vYmplY3RfZmlsZShvaWQpICYmCgkgICAgIG9pZF9vYmplY3RfaW5mbyh0aGVfcmVwb3NpdG9yeSwgb2lkLCBOVUxMKSA9PSBPQkpfQkxPQikpIHsKCQlpZiAoY2hlY2tfb2JqZWN0X3NpZ25hdHVyZShyZXBsLCBOVUxMLCAwLCBOVUxMKSA8IDApIHsKCQkJZXJyb3IoInNoYTEgbWlzbWF0Y2ggJXMiLCBvaWRfdG9faGV4KG9pZCkpOwoJCQlyZXR1cm4gTlVMTDsKCQl9CgkJcGFyc2VfYmxvYl9idWZmZXIobG9va3VwX2Jsb2Iob2lkKSwgTlVMTCwgMCk7CgkJcmV0dXJuIGxvb2t1cF9vYmplY3QodGhlX3JlcG9zaXRvcnksIG9pZC0+aGFzaCk7Cgl9CgoJYnVmZmVyID0gcmVhZF9vYmplY3RfZmlsZShvaWQsICZ0eXBlLCAmc2l6ZSk7CglpZiAoYnVmZmVyKSB7CgkJaWYgKGNoZWNrX29iamVjdF9zaWduYXR1cmUocmVwbCwgYnVmZmVyLCBzaXplLCB0eXBlX25hbWUodHlwZSkpIDwgMCkgewoJCQlmcmVlKGJ1ZmZlcik7CgkJCWVycm9yKCJzaGExIG1pc21hdGNoICVzIiwgb2lkX3RvX2hleChyZXBsKSk7CgkJCXJldHVybiBOVUxMOwoJCX0KCgkJb2JqID0gcGFyc2Vfb2JqZWN0X2J1ZmZlcihvaWQsIHR5cGUsIHNpemUsIGJ1ZmZlciwgJmVhdGVuKTsKCQlpZiAoIWVhdGVuKQoJCQlmcmVlKGJ1ZmZlcik7CgkJcmV0dXJuIG9iajsKCX0KCXJldHVybiBOVUxMOwp9CgpzdHJ1Y3Qgb2JqZWN0X2xpc3QgKm9iamVjdF9saXN0X2luc2VydChzdHJ1Y3Qgb2JqZWN0ICppdGVtLAoJCQkJICAgICAgIHN0cnVjdCBvYmplY3RfbGlzdCAqKmxpc3RfcCkKewoJc3RydWN0IG9iamVjdF9saXN0ICpuZXdfbGlzdCA9IHhtYWxsb2Moc2l6ZW9mKHN0cnVjdCBvYmplY3RfbGlzdCkpOwoJbmV3X2xpc3QtPml0ZW0gPSBpdGVtOwoJbmV3X2xpc3QtPm5leHQgPSAqbGlzdF9wOwoJKmxpc3RfcCA9IG5ld19saXN0OwoJcmV0dXJuIG5ld19saXN0Owp9CgppbnQgb2JqZWN0X2xpc3RfY29udGFpbnMoc3RydWN0IG9iamVjdF9saXN0ICpsaXN0LCBzdHJ1Y3Qgb2JqZWN0ICpvYmopCnsKCXdoaWxlIChsaXN0KSB7CgkJaWYgKGxpc3QtPml0ZW0gPT0gb2JqKQoJCQlyZXR1cm4gMTsKCQlsaXN0ID0gbGlzdC0+bmV4dDsKCX0KCXJldHVybiAwOwp9CgovKgogKiBBIHplcm8tbGVuZ3RoIHN0cmluZyB0byB3aGljaCBvYmplY3RfYXJyYXlfZW50cnk6Om5hbWUgY2FuIGJlCiAqIGluaXRpYWxpemVkIHdpdGhvdXQgcmVxdWlyaW5nIGEgbWFsbG9jL2ZyZWUuCiAqLwpzdGF0aWMgY2hhciBvYmplY3RfYXJyYXlfc2xvcGJ1ZlsxXTsKCnZvaWQgYWRkX29iamVjdF9hcnJheV93aXRoX3BhdGgoc3RydWN0IG9iamVjdCAqb2JqLCBjb25zdCBjaGFyICpuYW1lLAoJCQkJc3RydWN0IG9iamVjdF9hcnJheSAqYXJyYXksCgkJCQl1bnNpZ25lZCBtb2RlLCBjb25zdCBjaGFyICpwYXRoKQp7Cgl1bnNpZ25lZCBuciA9IGFycmF5LT5ucjsKCXVuc2lnbmVkIGFsbG9jID0gYXJyYXktPmFsbG9jOwoJc3RydWN0IG9iamVjdF9hcnJheV9lbnRyeSAqb2JqZWN0cyA9IGFycmF5LT5vYmplY3RzOwoJc3RydWN0IG9iamVjdF9hcnJheV9lbnRyeSAqZW50cnk7CgoJaWYgKG5yID49IGFsbG9jKSB7CgkJYWxsb2MgPSAoYWxsb2MgKyAzMikgKiAyOwoJCVJFQUxMT0NfQVJSQVkob2JqZWN0cywgYWxsb2MpOwoJCWFycmF5LT5hbGxvYyA9IGFsbG9jOwoJCWFycmF5LT5vYmplY3RzID0gb2JqZWN0czsKCX0KCWVudHJ5ID0gJm9iamVjdHNbbnJdOwoJZW50cnktPml0ZW0gPSBvYmo7CglpZiAoIW5hbWUpCgkJZW50cnktPm5hbWUgPSBOVUxMOwoJZWxzZSBpZiAoISpuYW1lKQoJCS8qIFVzZSBvdXIgb3duIGVtcHR5IHN0cmluZyBpbnN0ZWFkIG9mIGFsbG9jYXRpbmcgb25lOiAqLwoJCWVudHJ5LT5uYW1lID0gb2JqZWN0X2FycmF5X3Nsb3BidWY7CgllbHNlCgkJZW50cnktPm5hbWUgPSB4c3RyZHVwKG5hbWUpOwoJZW50cnktPm1vZGUgPSBtb2RlOwoJaWYgKHBhdGgpCgkJZW50cnktPnBhdGggPSB4c3RyZHVwKHBhdGgpOwoJZWxzZQoJCWVudHJ5LT5wYXRoID0gTlVMTDsKCWFycmF5LT5uciA9ICsrbnI7Cn0KCnZvaWQgYWRkX29iamVjdF9hcnJheShzdHJ1Y3Qgb2JqZWN0ICpvYmosIGNvbnN0IGNoYXIgKm5hbWUsIHN0cnVjdCBvYmplY3RfYXJyYXkgKmFycmF5KQp7CglhZGRfb2JqZWN0X2FycmF5X3dpdGhfcGF0aChvYmosIG5hbWUsIGFycmF5LCBTX0lGSU5WQUxJRCwgTlVMTCk7Cn0KCi8qCiAqIEZyZWUgYWxsIG1lbW9yeSBhc3NvY2lhdGVkIHdpdGggYW4gZW50cnk7IHRoZSByZXN1bHQgaXMKICogaW4gYW4gdW5zcGVjaWZpZWQgc3RhdGUgYW5kIHNob3VsZCBub3QgYmUgZXhhbWluZWQuCiAqLwpzdGF0aWMgdm9pZCBvYmplY3RfYXJyYXlfcmVsZWFzZV9lbnRyeShzdHJ1Y3Qgb2JqZWN0X2FycmF5X2VudHJ5ICplbnQpCnsKCWlmIChlbnQtPm5hbWUgIT0gb2JqZWN0X2FycmF5X3Nsb3BidWYpCgkJZnJlZShlbnQtPm5hbWUpOwoJZnJlZShlbnQtPnBhdGgpOwp9CgpzdHJ1Y3Qgb2JqZWN0ICpvYmplY3RfYXJyYXlfcG9wKHN0cnVjdCBvYmplY3RfYXJyYXkgKmFycmF5KQp7CglzdHJ1Y3Qgb2JqZWN0ICpyZXQ7CgoJaWYgKCFhcnJheS0+bnIpCgkJcmV0dXJuIE5VTEw7CgoJcmV0ID0gYXJyYXktPm9iamVjdHNbYXJyYXktPm5yIC0gMV0uaXRlbTsKCW9iamVjdF9hcnJheV9yZWxlYXNlX2VudHJ5KCZhcnJheS0+b2JqZWN0c1thcnJheS0+bnIgLSAxXSk7CglhcnJheS0+bnItLTsKCXJldHVybiByZXQ7Cn0KCnZvaWQgb2JqZWN0X2FycmF5X2ZpbHRlcihzdHJ1Y3Qgb2JqZWN0X2FycmF5ICphcnJheSwKCQkJIG9iamVjdF9hcnJheV9lYWNoX2Z1bmNfdCB3YW50LCB2b2lkICpjYl9kYXRhKQp7Cgl1bnNpZ25lZCBuciA9IGFycmF5LT5uciwgc3JjLCBkc3Q7CglzdHJ1Y3Qgb2JqZWN0X2FycmF5X2VudHJ5ICpvYmplY3RzID0gYXJyYXktPm9iamVjdHM7CgoJZm9yIChzcmMgPSBkc3QgPSAwOyBzcmMgPCBucjsgc3JjKyspIHsKCQlpZiAod2FudCgmb2JqZWN0c1tzcmNdLCBjYl9kYXRhKSkgewoJCQlpZiAoc3JjICE9IGRzdCkKCQkJCW9iamVjdHNbZHN0XSA9IG9iamVjdHNbc3JjXTsKCQkJZHN0Kys7CgkJfSBlbHNlIHsKCQkJb2JqZWN0X2FycmF5X3JlbGVhc2VfZW50cnkoJm9iamVjdHNbc3JjXSk7CgkJfQoJfQoJYXJyYXktPm5yID0gZHN0Owp9Cgp2b2lkIG9iamVjdF9hcnJheV9jbGVhcihzdHJ1Y3Qgb2JqZWN0X2FycmF5ICphcnJheSkKewoJaW50IGk7Cglmb3IgKGkgPSAwOyBpIDwgYXJyYXktPm5yOyBpKyspCgkJb2JqZWN0X2FycmF5X3JlbGVhc2VfZW50cnkoJmFycmF5LT5vYmplY3RzW2ldKTsKCUZSRUVfQU5EX05VTEwoYXJyYXktPm9iamVjdHMpOwoJYXJyYXktPm5yID0gYXJyYXktPmFsbG9jID0gMDsKfQoKLyoKICogUmV0dXJuIHRydWUgaWZmIGFycmF5IGFscmVhZHkgY29udGFpbnMgYW4gZW50cnkgd2l0aCBuYW1lLgogKi8Kc3RhdGljIGludCBjb250YWluc19uYW1lKHN0cnVjdCBvYmplY3RfYXJyYXkgKmFycmF5LCBjb25zdCBjaGFyICpuYW1lKQp7Cgl1bnNpZ25lZCBuciA9IGFycmF5LT5uciwgaTsKCXN0cnVjdCBvYmplY3RfYXJyYXlfZW50cnkgKm9iamVjdCA9IGFycmF5LT5vYmplY3RzOwoKCWZvciAoaSA9IDA7IGkgPCBucjsgaSsrLCBvYmplY3QrKykKCQlpZiAoIXN0cmNtcChvYmplY3QtPm5hbWUsIG5hbWUpKQoJCQlyZXR1cm4gMTsKCXJldHVybiAwOwp9Cgp2b2lkIG9iamVjdF9hcnJheV9yZW1vdmVfZHVwbGljYXRlcyhzdHJ1Y3Qgb2JqZWN0X2FycmF5ICphcnJheSkKewoJdW5zaWduZWQgbnIgPSBhcnJheS0+bnIsIHNyYzsKCXN0cnVjdCBvYmplY3RfYXJyYXlfZW50cnkgKm9iamVjdHMgPSBhcnJheS0+b2JqZWN0czsKCglhcnJheS0+bnIgPSAwOwoJZm9yIChzcmMgPSAwOyBzcmMgPCBucjsgc3JjKyspIHsKCQlpZiAoIWNvbnRhaW5zX25hbWUoYXJyYXksIG9iamVjdHNbc3JjXS5uYW1lKSkgewoJCQlpZiAoc3JjICE9IGFycmF5LT5ucikKCQkJCW9iamVjdHNbYXJyYXktPm5yXSA9IG9iamVjdHNbc3JjXTsKCQkJYXJyYXktPm5yKys7CgkJfSBlbHNlIHsKCQkJb2JqZWN0X2FycmF5X3JlbGVhc2VfZW50cnkoJm9iamVjdHNbc3JjXSk7CgkJfQoJfQp9Cgp2b2lkIGNsZWFyX29iamVjdF9mbGFncyh1bnNpZ25lZCBmbGFncykKewoJaW50IGk7CgoJZm9yIChpPTA7IGkgPCB0aGVfcmVwb3NpdG9yeS0+cGFyc2VkX29iamVjdHMtPm9ial9oYXNoX3NpemU7IGkrKykgewoJCXN0cnVjdCBvYmplY3QgKm9iaiA9IHRoZV9yZXBvc2l0b3J5LT5wYXJzZWRfb2JqZWN0cy0+b2JqX2hhc2hbaV07CgkJaWYgKG9iaikKCQkJb2JqLT5mbGFncyAmPSB+ZmxhZ3M7Cgl9Cn0KCnZvaWQgY2xlYXJfY29tbWl0X21hcmtzX2FsbCh1bnNpZ25lZCBpbnQgZmxhZ3MpCnsKCWludCBpOwoKCWZvciAoaSA9IDA7IGkgPCB0aGVfcmVwb3NpdG9yeS0+cGFyc2VkX29iamVjdHMtPm9ial9oYXNoX3NpemU7IGkrKykgewoJCXN0cnVjdCBvYmplY3QgKm9iaiA9IHRoZV9yZXBvc2l0b3J5LT5wYXJzZWRfb2JqZWN0cy0+b2JqX2hhc2hbaV07CgkJaWYgKG9iaiAmJiBvYmotPnR5cGUgPT0gT0JKX0NPTU1JVCkKCQkJb2JqLT5mbGFncyAmPSB+ZmxhZ3M7Cgl9Cn0KCnN0cnVjdCBwYXJzZWRfb2JqZWN0X3Bvb2wgKnBhcnNlZF9vYmplY3RfcG9vbF9uZXcodm9pZCkKewoJc3RydWN0IHBhcnNlZF9vYmplY3RfcG9vbCAqbyA9IHhtYWxsb2Moc2l6ZW9mKCpvKSk7CgltZW1zZXQobywgMCwgc2l6ZW9mKCpvKSk7CgoJby0+YmxvYl9zdGF0ZSA9IGFsbG9jYXRlX2FsbG9jX3N0YXRlKCk7CglvLT50cmVlX3N0YXRlID0gYWxsb2NhdGVfYWxsb2Nfc3RhdGUoKTsKCW8tPmNvbW1pdF9zdGF0ZSA9IGFsbG9jYXRlX2FsbG9jX3N0YXRlKCk7CglvLT50YWdfc3RhdGUgPSBhbGxvY2F0ZV9hbGxvY19zdGF0ZSgpOwoJby0+b2JqZWN0X3N0YXRlID0gYWxsb2NhdGVfYWxsb2Nfc3RhdGUoKTsKCglvLT5pc19zaGFsbG93ID0gLTE7CglvLT5zaGFsbG93X3N0YXQgPSB4Y2FsbG9jKDEsIHNpemVvZigqby0+c2hhbGxvd19zdGF0KSk7CgoJcmV0dXJuIG87Cn0KCnN0cnVjdCByYXdfb2JqZWN0X3N0b3JlICpyYXdfb2JqZWN0X3N0b3JlX25ldyh2b2lkKQp7CglzdHJ1Y3QgcmF3X29iamVjdF9zdG9yZSAqbyA9IHhtYWxsb2Moc2l6ZW9mKCpvKSk7CgoJbWVtc2V0KG8sIDAsIHNpemVvZigqbykpOwoJSU5JVF9MSVNUX0hFQUQoJm8tPnBhY2tlZF9naXRfbXJ1KTsKCXJldHVybiBvOwp9CgpzdGF0aWMgdm9pZCBmcmVlX2FsdF9vZGIoc3RydWN0IGFsdGVybmF0ZV9vYmplY3RfZGF0YWJhc2UgKmFsdCkKewoJc3RyYnVmX3JlbGVhc2UoJmFsdC0+c2NyYXRjaCk7CglvaWRfYXJyYXlfY2xlYXIoJmFsdC0+bG9vc2Vfb2JqZWN0c19jYWNoZSk7CglmcmVlKGFsdCk7Cn0KCnN0YXRpYyB2b2lkIGZyZWVfYWx0X29kYnMoc3RydWN0IHJhd19vYmplY3Rfc3RvcmUgKm8pCnsKCXdoaWxlIChvLT5hbHRfb2RiX2xpc3QpIHsKCQlzdHJ1Y3QgYWx0ZXJuYXRlX29iamVjdF9kYXRhYmFzZSAqbmV4dDsKCgkJbmV4dCA9IG8tPmFsdF9vZGJfbGlzdC0+bmV4dDsKCQlmcmVlX2FsdF9vZGIoby0+YWx0X29kYl9saXN0KTsKCQlvLT5hbHRfb2RiX2xpc3QgPSBuZXh0OwoJfQp9Cgp2b2lkIHJhd19vYmplY3Rfc3RvcmVfY2xlYXIoc3RydWN0IHJhd19vYmplY3Rfc3RvcmUgKm8pCnsKCUZSRUVfQU5EX05VTEwoby0+b2JqZWN0ZGlyKTsKCUZSRUVfQU5EX05VTEwoby0+YWx0ZXJuYXRlX2RiKTsKCglvaWRtYXBfZnJlZShvLT5yZXBsYWNlX21hcCwgMSk7CglGUkVFX0FORF9OVUxMKG8tPnJlcGxhY2VfbWFwKTsKCglmcmVlX2FsdF9vZGJzKG8pOwoJby0+YWx0X29kYl90YWlsID0gTlVMTDsKCglJTklUX0xJU1RfSEVBRCgmby0+cGFja2VkX2dpdF9tcnUpOwoJY2xvc2VfYWxsX3BhY2tzKG8pOwoJby0+cGFja2VkX2dpdCA9IE5VTEw7Cn0KCnZvaWQgcGFyc2VkX29iamVjdF9wb29sX2NsZWFyKHN0cnVjdCBwYXJzZWRfb2JqZWN0X3Bvb2wgKm8pCnsKCS8qCgkgKiBBcyBvYmplY3RzIGFyZSBhbGxvY2F0ZWQgaW4gc2xhYnMgKHNlZSBhbGxvYy5jKSwgd2UgZG8KCSAqIG5vdCBuZWVkIHRvIGZyZWUgZWFjaCBvYmplY3QsIGJ1dCBlYWNoIHNsYWIgaW5zdGVhZC4KCSAqCgkgKiBCZWZvcmUgZG9pbmcgc28sIHdlIG5lZWQgdG8gZnJlZSBhbnkgYWRkaXRpb25hbCBtZW1vcnkKCSAqIHRoZSBvYmplY3RzIG1heSBob2xkLgoJICovCgl1bnNpZ25lZCBpOwoKCWZvciAoaSA9IDA7IGkgPCBvLT5vYmpfaGFzaF9zaXplOyBpKyspIHsKCQlzdHJ1Y3Qgb2JqZWN0ICpvYmogPSBvLT5vYmpfaGFzaFtpXTsKCgkJaWYgKCFvYmopCgkJCWNvbnRpbnVlOwoKCQlpZiAob2JqLT50eXBlID09IE9CSl9UUkVFKQoJCQlmcmVlX3RyZWVfYnVmZmVyKChzdHJ1Y3QgdHJlZSopb2JqKTsKCQllbHNlIGlmIChvYmotPnR5cGUgPT0gT0JKX0NPTU1JVCkKCQkJcmVsZWFzZV9jb21taXRfbWVtb3J5KChzdHJ1Y3QgY29tbWl0KilvYmopOwoJCWVsc2UgaWYgKG9iai0+dHlwZSA9PSBPQkpfVEFHKQoJCQlyZWxlYXNlX3RhZ19tZW1vcnkoKHN0cnVjdCB0YWcqKW9iaik7Cgl9CgoJRlJFRV9BTkRfTlVMTChvLT5vYmpfaGFzaCk7CglvLT5vYmpfaGFzaF9zaXplID0gMDsKCgljbGVhcl9hbGxvY19zdGF0ZShvLT5ibG9iX3N0YXRlKTsKCWNsZWFyX2FsbG9jX3N0YXRlKG8tPnRyZWVfc3RhdGUpOwoJY2xlYXJfYWxsb2Nfc3RhdGUoby0+Y29tbWl0X3N0YXRlKTsKCWNsZWFyX2FsbG9jX3N0YXRlKG8tPnRhZ19zdGF0ZSk7CgljbGVhcl9hbGxvY19zdGF0ZShvLT5vYmplY3Rfc3RhdGUpOwoJRlJFRV9BTkRfTlVMTChvLT5ibG9iX3N0YXRlKTsKCUZSRUVfQU5EX05VTEwoby0+dHJlZV9zdGF0ZSk7CglGUkVFX0FORF9OVUxMKG8tPmNvbW1pdF9zdGF0ZSk7CglGUkVFX0FORF9OVUxMKG8tPnRhZ19zdGF0ZSk7CglGUkVFX0FORF9OVUxMKG8tPm9iamVjdF9zdGF0ZSk7Cn0K",
    "text": "#include \"cache.h\"\n#include \"object.h\"\n#include \"replace-object.h\"\n#include \"object-store.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"tag.h\"\n#include \"alloc.h\"\n#include \"object-store.h\"\n#include \"packfile.h\"\n\nunsigned int get_max_object_index(void)\n{\n\treturn the_repository->parsed_objects->obj_hash_size;\n}\n\nstruct object *get_indexed_object(unsigned int idx)\n{\n\treturn the_repository->parsed_objects->obj_hash[idx];\n}\n\nstatic const char *object_type_strings[] = {\n\tNULL,\t\t/* OBJ_NONE = 0 */\n\t\"commit\",\t/* OBJ_COMMIT = 1 */\n\t\"tree\",\t\t/* OBJ_TREE = 2 */\n\t\"blob\",\t\t/* OBJ_BLOB = 3 */\n\t\"tag\",\t\t/* OBJ_TAG = 4 */\n};\n\nconst char *type_name(unsigned int type)\n{\n\tif (type >= ARRAY_SIZE(object_type_strings))\n\t\treturn NULL;\n\treturn object_type_strings[type];\n}\n\nint type_from_string_gently(const char *str, ssize_t len, int gentle)\n{\n\tint i;\n\n\tif (len < 0)\n\t\tlen = strlen(str);\n\n\tfor (i = 1; i < ARRAY_SIZE(object_type_strings); i++)\n\t\tif (!strncmp(str, object_type_strings[i], len) &&\n\t\t    object_type_strings[i][len] == '\\0')\n\t\t\treturn i;\n\n\tif (gentle)\n\t\treturn -1;\n\n\tdie(\"invalid object type \\\"%s\\\"\", str);\n}\n\n/*\n * Return a numerical hash value between 0 and n-1 for the object with\n * the specified sha1.  n must be a power of 2.  Please note that the\n * return value is *not* consistent across computer architectures.\n */\nstatic unsigned int hash_obj(const unsigned char *sha1, unsigned int n)\n{\n\treturn sha1hash(sha1) & (n - 1);\n}\n\n/*\n * Insert obj into the hash table hash, which has length size (which\n * must be a power of 2).  On collisions, simply overflow to the next\n * empty bucket.\n */\nstatic void insert_obj_hash(struct object *obj, struct object **hash, unsigned int size)\n{\n\tunsigned int j = hash_obj(obj->oid.hash, size);\n\n\twhile (hash[j]) {\n\t\tj++;\n\t\tif (j >= size)\n\t\t\tj = 0;\n\t}\n\thash[j] = obj;\n}\n\n/*\n * Look up the record for the given sha1 in the hash map stored in\n * obj_hash.  Return NULL if it was not found.\n */\nstruct object *lookup_object_the_repository(const unsigned char *sha1)\n{\n\tunsigned int i, first;\n\tstruct object *obj;\n\n\tif (!the_repository->parsed_objects->obj_hash)\n\t\treturn NULL;\n\n\tfirst = i = hash_obj(sha1,\n\t\t\t     the_repository->parsed_objects->obj_hash_size);\n\twhile ((obj = the_repository->parsed_objects->obj_hash[i]) != NULL) {\n\t\tif (!hashcmp(sha1, obj->oid.hash))\n\t\t\tbreak;\n\t\ti++;\n\t\tif (i == the_repository->parsed_objects->obj_hash_size)\n\t\t\ti = 0;\n\t}\n\tif (obj && i != first) {\n\t\t/*\n\t\t * Move object to where we started to look for it so\n\t\t * that we do not need to walk the hash table the next\n\t\t * time we look for it.\n\t\t */\n\t\tSWAP(the_repository->parsed_objects->obj_hash[i],\n\t\t     the_repository->parsed_objects->obj_hash[first]);\n\t}\n\treturn obj;\n}\n\n/*\n * Increase the size of the hash map stored in obj_hash to the next\n * power of 2 (but at least 32).  Copy the existing values to the new\n * hash map.\n */\nstatic void grow_object_hash(struct repository *r)\n{\n\tint i;\n\t/*\n\t * Note that this size must always be power-of-2 to match hash_obj\n\t * above.\n\t */\n\tint new_hash_size = r->parsed_objects->obj_hash_size < 32 ? 32 : 2 * r->parsed_objects->obj_hash_size;\n\tstruct object **new_hash;\n\n\tnew_hash = xcalloc(new_hash_size, sizeof(struct object *));\n\tfor (i = 0; i < r->parsed_objects->obj_hash_size; i++) {\n\t\tstruct object *obj = r->parsed_objects->obj_hash[i];\n\n\t\tif (!obj)\n\t\t\tcontinue;\n\t\tinsert_obj_hash(obj, new_hash, new_hash_size);\n\t}\n\tfree(r->parsed_objects->obj_hash);\n\tr->parsed_objects->obj_hash = new_hash;\n\tr->parsed_objects->obj_hash_size = new_hash_size;\n}\n\nvoid *create_object(struct repository *r, const unsigned char *sha1, void *o)\n{\n\tstruct object *obj = o;\n\n\tobj->parsed = 0;\n\tobj->flags = 0;\n\thashcpy(obj->oid.hash, sha1);\n\n\tif (r->parsed_objects->obj_hash_size - 1 <= r->parsed_objects->nr_objs * 2)\n\t\tgrow_object_hash(r);\n\n\tinsert_obj_hash(obj, r->parsed_objects->obj_hash,\n\t\t\tr->parsed_objects->obj_hash_size);\n\tr->parsed_objects->nr_objs++;\n\treturn obj;\n}\n\nvoid *object_as_type(struct object *obj, enum object_type type, int quiet)\n{\n\tif (obj->type == type)\n\t\treturn obj;\n\telse if (obj->type == OBJ_NONE) {\n\t\tif (type == OBJ_COMMIT)\n\t\t\t((struct commit *)obj)->index = alloc_commit_index(the_repository);\n\t\tobj->type = type;\n\t\treturn obj;\n\t}\n\telse {\n\t\tif (!quiet)\n\t\t\terror(\"object %s is a %s, not a %s\",\n\t\t\t      oid_to_hex(&obj->oid),\n\t\t\t      type_name(obj->type), type_name(type));\n\t\treturn NULL;\n\t}\n}\n\nstruct object *lookup_unknown_object(const unsigned char *sha1)\n{\n\tstruct object *obj = lookup_object(the_repository, sha1);\n\tif (!obj)\n\t\tobj = create_object(the_repository, sha1,\n\t\t\t\t    alloc_object_node(the_repository));\n\treturn obj;\n}\n\nstruct object *parse_object_buffer(const struct object_id *oid, enum object_type type, unsigned long size, void *buffer, int *eaten_p)\n{\n\tstruct object *obj;\n\t*eaten_p = 0;\n\n\tobj = NULL;\n\tif (type == OBJ_BLOB) {\n\t\tstruct blob *blob = lookup_blob(oid);\n\t\tif (blob) {\n\t\t\tif (parse_blob_buffer(blob, buffer, size))\n\t\t\t\treturn NULL;\n\t\t\tobj = &blob->object;\n\t\t}\n\t} else if (type == OBJ_TREE) {\n\t\tstruct tree *tree = lookup_tree(oid);\n\t\tif (tree) {\n\t\t\tobj = &tree->object;\n\t\t\tif (!tree->buffer)\n\t\t\t\ttree->object.parsed = 0;\n\t\t\tif (!tree->object.parsed) {\n\t\t\t\tif (parse_tree_buffer(tree, buffer, size))\n\t\t\t\t\treturn NULL;\n\t\t\t\t*eaten_p = 1;\n\t\t\t}\n\t\t}\n\t} else if (type == OBJ_COMMIT) {\n\t\tstruct commit *commit = lookup_commit(oid);\n\t\tif (commit) {\n\t\t\tif (parse_commit_buffer(commit, buffer, size, 1))\n\t\t\t\treturn NULL;\n\t\t\tif (!get_cached_commit_buffer(commit, NULL)) {\n\t\t\t\tset_commit_buffer(commit, buffer, size);\n\t\t\t\t*eaten_p = 1;\n\t\t\t}\n\t\t\tobj = &commit->object;\n\t\t}\n\t} else if (type == OBJ_TAG) {\n\t\tstruct tag *tag = lookup_tag(oid);\n\t\tif (tag) {\n\t\t\tif (parse_tag_buffer(tag, buffer, size))\n\t\t\t       return NULL;\n\t\t\tobj = &tag->object;\n\t\t}\n\t} else {\n\t\twarning(\"object %s has unknown type id %d\", oid_to_hex(oid), type);\n\t\tobj = NULL;\n\t}\n\treturn obj;\n}\n\nstruct object *parse_object_or_die(const struct object_id *oid,\n\t\t\t\t   const char *name)\n{\n\tstruct object *o = parse_object(the_repository, oid);\n\tif (o)\n\t\treturn o;\n\n\tdie(_(\"unable to parse object: %s\"), name ? name : oid_to_hex(oid));\n}\n\nstruct object *parse_object_the_repository(const struct object_id *oid)\n{\n\tunsigned long size;\n\tenum object_type type;\n\tint eaten;\n\tconst struct object_id *repl = lookup_replace_object(the_repository, oid);\n\tvoid *buffer;\n\tstruct object *obj;\n\n\tobj = lookup_object(the_repository, oid->hash);\n\tif (obj && obj->parsed)\n\t\treturn obj;\n\n\tif ((obj && obj->type == OBJ_BLOB && has_object_file(oid)) ||\n\t    (!obj && has_object_file(oid) &&\n\t     oid_object_info(the_repository, oid, NULL) == OBJ_BLOB)) {\n\t\tif (check_object_signature(repl, NULL, 0, NULL) < 0) {\n\t\t\terror(\"sha1 mismatch %s\", oid_to_hex(oid));\n\t\t\treturn NULL;\n\t\t}\n\t\tparse_blob_buffer(lookup_blob(oid), NULL, 0);\n\t\treturn lookup_object(the_repository, oid->hash);\n\t}\n\n\tbuffer = read_object_file(oid, &type, &size);\n\tif (buffer) {\n\t\tif (check_object_signature(repl, buffer, size, type_name(type)) < 0) {\n\t\t\tfree(buffer);\n\t\t\terror(\"sha1 mismatch %s\", oid_to_hex(repl));\n\t\t\treturn NULL;\n\t\t}\n\n\t\tobj = parse_object_buffer(oid, type, size, buffer, &eaten);\n\t\tif (!eaten)\n\t\t\tfree(buffer);\n\t\treturn obj;\n\t}\n\treturn NULL;\n}\n\nstruct object_list *object_list_insert(struct object *item,\n\t\t\t\t       struct object_list **list_p)\n{\n\tstruct object_list *new_list = xmalloc(sizeof(struct object_list));\n\tnew_list->item = item;\n\tnew_list->next = *list_p;\n\t*list_p = new_list;\n\treturn new_list;\n}\n\nint object_list_contains(struct object_list *list, struct object *obj)\n{\n\twhile (list) {\n\t\tif (list->item == obj)\n\t\t\treturn 1;\n\t\tlist = list->next;\n\t}\n\treturn 0;\n}\n\n/*\n * A zero-length string to which object_array_entry::name can be\n * initialized without requiring a malloc/free.\n */\nstatic char object_array_slopbuf[1];\n\nvoid add_object_array_with_path(struct object *obj, const char *name,\n\t\t\t\tstruct object_array *array,\n\t\t\t\tunsigned mode, const char *path)\n{\n\tunsigned nr = array->nr;\n\tunsigned alloc = array->alloc;\n\tstruct object_array_entry *objects = array->objects;\n\tstruct object_array_entry *entry;\n\n\tif (nr >= alloc) {\n\t\talloc = (alloc + 32) * 2;\n\t\tREALLOC_ARRAY(objects, alloc);\n\t\tarray->alloc = alloc;\n\t\tarray->objects = objects;\n\t}\n\tentry = &objects[nr];\n\tentry->item = obj;\n\tif (!name)\n\t\tentry->name = NULL;\n\telse if (!*name)\n\t\t/* Use our own empty string instead of allocating one: */\n\t\tentry->name = object_array_slopbuf;\n\telse\n\t\tentry->name = xstrdup(name);\n\tentry->mode = mode;\n\tif (path)\n\t\tentry->path = xstrdup(path);\n\telse\n\t\tentry->path = NULL;\n\tarray->nr = ++nr;\n}\n\nvoid add_object_array(struct object *obj, const char *name, struct object_array *array)\n{\n\tadd_object_array_with_path(obj, name, array, S_IFINVALID, NULL);\n}\n\n/*\n * Free all memory associated with an entry; the result is\n * in an unspecified state and should not be examined.\n */\nstatic void object_array_release_entry(struct object_array_entry *ent)\n{\n\tif (ent->name != object_array_slopbuf)\n\t\tfree(ent->name);\n\tfree(ent->path);\n}\n\nstruct object *object_array_pop(struct object_array *array)\n{\n\tstruct object *ret;\n\n\tif (!array->nr)\n\t\treturn NULL;\n\n\tret = array->objects[array->nr - 1].item;\n\tobject_array_release_entry(&array->objects[array->nr - 1]);\n\tarray->nr--;\n\treturn ret;\n}\n\nvoid object_array_filter(struct object_array *array,\n\t\t\t object_array_each_func_t want, void *cb_data)\n{\n\tunsigned nr = array->nr, src, dst;\n\tstruct object_array_entry *objects = array->objects;\n\n\tfor (src = dst = 0; src < nr; src++) {\n\t\tif (want(&objects[src], cb_data)) {\n\t\t\tif (src != dst)\n\t\t\t\tobjects[dst] = objects[src];\n\t\t\tdst++;\n\t\t} else {\n\t\t\tobject_array_release_entry(&objects[src]);\n\t\t}\n\t}\n\tarray->nr = dst;\n}\n\nvoid object_array_clear(struct object_array *array)\n{\n\tint i;\n\tfor (i = 0; i < array->nr; i++)\n\t\tobject_array_release_entry(&array->objects[i]);\n\tFREE_AND_NULL(array->objects);\n\tarray->nr = array->alloc = 0;\n}\n\n/*\n * Return true iff array already contains an entry with name.\n */\nstatic int contains_name(struct object_array *array, const char *name)\n{\n\tunsigned nr = array->nr, i;\n\tstruct object_array_entry *object = array->objects;\n\n\tfor (i = 0; i < nr; i++, object++)\n\t\tif (!strcmp(object->name, name))\n\t\t\treturn 1;\n\treturn 0;\n}\n\nvoid object_array_remove_duplicates(struct object_array *array)\n{\n\tunsigned nr = array->nr, src;\n\tstruct object_array_entry *objects = array->objects;\n\n\tarray->nr = 0;\n\tfor (src = 0; src < nr; src++) {\n\t\tif (!contains_name(array, objects[src].name)) {\n\t\t\tif (src != array->nr)\n\t\t\t\tobjects[array->nr] = objects[src];\n\t\t\tarray->nr++;\n\t\t} else {\n\t\t\tobject_array_release_entry(&objects[src]);\n\t\t}\n\t}\n}\n\nvoid clear_object_flags(unsigned flags)\n{\n\tint i;\n\n\tfor (i=0; i < the_repository->parsed_objects->obj_hash_size; i++) {\n\t\tstruct object *obj = the_repository->parsed_objects->obj_hash[i];\n\t\tif (obj)\n\t\t\tobj->flags &= ~flags;\n\t}\n}\n\nvoid clear_commit_marks_all(unsigned int flags)\n{\n\tint i;\n\n\tfor (i = 0; i < the_repository->parsed_objects->obj_hash_size; i++) {\n\t\tstruct object *obj = the_repository->parsed_objects->obj_hash[i];\n\t\tif (obj && obj->type == OBJ_COMMIT)\n\t\t\tobj->flags &= ~flags;\n\t}\n}\n\nstruct parsed_object_pool *parsed_object_pool_new(void)\n{\n\tstruct parsed_object_pool *o = xmalloc(sizeof(*o));\n\tmemset(o, 0, sizeof(*o));\n\n\to->blob_state = allocate_alloc_state();\n\to->tree_state = allocate_alloc_state();\n\to->commit_state = allocate_alloc_state();\n\to->tag_state = allocate_alloc_state();\n\to->object_state = allocate_alloc_state();\n\n\to->is_shallow = -1;\n\to->shallow_stat = xcalloc(1, sizeof(*o->shallow_stat));\n\n\treturn o;\n}\n\nstruct raw_object_store *raw_object_store_new(void)\n{\n\tstruct raw_object_store *o = xmalloc(sizeof(*o));\n\n\tmemset(o, 0, sizeof(*o));\n\tINIT_LIST_HEAD(&o->packed_git_mru);\n\treturn o;\n}\n\nstatic void free_alt_odb(struct alternate_object_database *alt)\n{\n\tstrbuf_release(&alt->scratch);\n\toid_array_clear(&alt->loose_objects_cache);\n\tfree(alt);\n}\n\nstatic void free_alt_odbs(struct raw_object_store *o)\n{\n\twhile (o->alt_odb_list) {\n\t\tstruct alternate_object_database *next;\n\n\t\tnext = o->alt_odb_list->next;\n\t\tfree_alt_odb(o->alt_odb_list);\n\t\to->alt_odb_list = next;\n\t}\n}\n\nvoid raw_object_store_clear(struct raw_object_store *o)\n{\n\tFREE_AND_NULL(o->objectdir);\n\tFREE_AND_NULL(o->alternate_db);\n\n\toidmap_free(o->replace_map, 1);\n\tFREE_AND_NULL(o->replace_map);\n\n\tfree_alt_odbs(o);\n\to->alt_odb_tail = NULL;\n\n\tINIT_LIST_HEAD(&o->packed_git_mru);\n\tclose_all_packs(o);\n\to->packed_git = NULL;\n}\n\nvoid parsed_object_pool_clear(struct parsed_object_pool *o)\n{\n\t/*\n\t * As objects are allocated in slabs (see alloc.c), we do\n\t * not need to free each object, but each slab instead.\n\t *\n\t * Before doing so, we need to free any additional memory\n\t * the objects may hold.\n\t */\n\tunsigned i;\n\n\tfor (i = 0; i < o->obj_hash_size; i++) {\n\t\tstruct object *obj = o->obj_hash[i];\n\n\t\tif (!obj)\n\t\t\tcontinue;\n\n\t\tif (obj->type == OBJ_TREE)\n\t\t\tfree_tree_buffer((struct tree*)obj);\n\t\telse if (obj->type == OBJ_COMMIT)\n\t\t\trelease_commit_memory((struct commit*)obj);\n\t\telse if (obj->type == OBJ_TAG)\n\t\t\trelease_tag_memory((struct tag*)obj);\n\t}\n\n\tFREE_AND_NULL(o->obj_hash);\n\to->obj_hash_size = 0;\n\n\tclear_alloc_state(o->blob_state);\n\tclear_alloc_state(o->tree_state);\n\tclear_alloc_state(o->commit_state);\n\tclear_alloc_state(o->tag_state);\n\tclear_alloc_state(o->object_state);\n\tFREE_AND_NULL(o->blob_state);\n\tFREE_AND_NULL(o->tree_state);\n\tFREE_AND_NULL(o->commit_state);\n\tFREE_AND_NULL(o->tag_state);\n\tFREE_AND_NULL(o->object_state);\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "002ebb69e3ba8c215f5ec7688afb4045543d5151",
  "sha1_ok": true,
  "size": 13434
}
