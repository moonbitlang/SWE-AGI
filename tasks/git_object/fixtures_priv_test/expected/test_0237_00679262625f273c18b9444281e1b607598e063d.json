{
  "content": {
    "base64": "LyoKICogVGhlIGJhY2tlbmQtaW5kZXBlbmRlbnQgcGFydCBvZiB0aGUgcmVmZXJlbmNlIG1vZHVsZS4KICovCgojaW5jbHVkZSAiY2FjaGUuaCIKI2luY2x1ZGUgImNvbmZpZy5oIgojaW5jbHVkZSAiaGFzaG1hcC5oIgojaW5jbHVkZSAibG9ja2ZpbGUuaCIKI2luY2x1ZGUgIml0ZXJhdG9yLmgiCiNpbmNsdWRlICJyZWZzLmgiCiNpbmNsdWRlICJyZWZzL3JlZnMtaW50ZXJuYWwuaCIKI2luY2x1ZGUgInJ1bi1jb21tYW5kLmgiCiNpbmNsdWRlICJvYmplY3Qtc3RvcmUuaCIKI2luY2x1ZGUgIm9iamVjdC5oIgojaW5jbHVkZSAidGFnLmgiCiNpbmNsdWRlICJzdWJtb2R1bGUuaCIKI2luY2x1ZGUgIndvcmt0cmVlLmgiCiNpbmNsdWRlICJzdHJ2ZWMuaCIKI2luY2x1ZGUgInJlcG9zaXRvcnkuaCIKI2luY2x1ZGUgInNpZ2NoYWluLmgiCgovKgogKiBMaXN0IG9mIGFsbCBhdmFpbGFibGUgYmFja2VuZHMKICovCnN0YXRpYyBzdHJ1Y3QgcmVmX3N0b3JhZ2VfYmUgKnJlZnNfYmFja2VuZHMgPSAmcmVmc19iZV9maWxlczsKCnN0YXRpYyBzdHJ1Y3QgcmVmX3N0b3JhZ2VfYmUgKmZpbmRfcmVmX3N0b3JhZ2VfYmFja2VuZChjb25zdCBjaGFyICpuYW1lKQp7CglzdHJ1Y3QgcmVmX3N0b3JhZ2VfYmUgKmJlOwoJZm9yIChiZSA9IHJlZnNfYmFja2VuZHM7IGJlOyBiZSA9IGJlLT5uZXh0KQoJCWlmICghc3RyY21wKGJlLT5uYW1lLCBuYW1lKSkKCQkJcmV0dXJuIGJlOwoJcmV0dXJuIE5VTEw7Cn0KCmludCByZWZfc3RvcmFnZV9iYWNrZW5kX2V4aXN0cyhjb25zdCBjaGFyICpuYW1lKQp7CglyZXR1cm4gZmluZF9yZWZfc3RvcmFnZV9iYWNrZW5kKG5hbWUpICE9IE5VTEw7Cn0KCi8qCiAqIEhvdyB0byBoYW5kbGUgdmFyaW91cyBjaGFyYWN0ZXJzIGluIHJlZm5hbWVzOgogKiAwOiBBbiBhY2NlcHRhYmxlIGNoYXJhY3RlciBmb3IgcmVmcwogKiAxOiBFbmQtb2YtY29tcG9uZW50CiAqIDI6IC4sIGxvb2sgZm9yIGEgcHJlY2VkaW5nIC4gdG8gcmVqZWN0IC4uIGluIHJlZnMKICogMzogeywgbG9vayBmb3IgYSBwcmVjZWRpbmcgQCB0byByZWplY3QgQHsgaW4gcmVmcwogKiA0OiBBIGJhZCBjaGFyYWN0ZXI6IEFTQ0lJIGNvbnRyb2wgY2hhcmFjdGVycywgYW5kCiAqICAgICI6IiwgIj8iLCAiWyIsICJcIiwgIl4iLCAifiIsIFNQLCBvciBUQUIKICogNTogKiwgcmVqZWN0IHVubGVzcyBSRUZOQU1FX1JFRlNQRUNfUEFUVEVSTiBpcyBzZXQKICovCnN0YXRpYyB1bnNpZ25lZCBjaGFyIHJlZm5hbWVfZGlzcG9zaXRpb25bMjU2XSA9IHsKCTEsIDQsIDQsIDQsIDQsIDQsIDQsIDQsIDQsIDQsIDQsIDQsIDQsIDQsIDQsIDQsCgk0LCA0LCA0LCA0LCA0LCA0LCA0LCA0LCA0LCA0LCA0LCA0LCA0LCA0LCA0LCA0LAoJNCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgNSwgMCwgMCwgMCwgMiwgMSwKCTAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDQsIDAsIDAsIDAsIDAsIDQsCgkwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLAoJMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgNCwgNCwgMCwgNCwgMCwKCTAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsCgkwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAzLCAwLCAwLCA0LCA0Cn07CgovKgogKiBUcnkgdG8gcmVhZCBvbmUgcmVmbmFtZSBjb21wb25lbnQgZnJvbSB0aGUgZnJvbnQgb2YgcmVmbmFtZS4KICogUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGNvbXBvbmVudCBmb3VuZCwgb3IgLTEgaWYgdGhlIGNvbXBvbmVudCBpcwogKiBub3QgbGVnYWwuICBJdCBpcyBsZWdhbCBpZiBpdCBpcyBzb21ldGhpbmcgcmVhc29uYWJsZSB0byBoYXZlIHVuZGVyCiAqICIuZ2l0L3JlZnMvIjsgV2UgZG8gbm90IGxpa2UgaXQgaWY6CiAqCiAqIC0gaXQgYmVnaW5zIHdpdGggIi4iLCBvcgogKiAtIGl0IGhhcyBkb3VibGUgZG90cyAiLi4iLCBvcgogKiAtIGl0IGhhcyBBU0NJSSBjb250cm9sIGNoYXJhY3RlcnMsIG9yCiAqIC0gaXQgaGFzICI6IiwgIj8iLCAiWyIsICJcIiwgIl4iLCAifiIsIFNQLCBvciBUQUIgYW55d2hlcmUsIG9yCiAqIC0gaXQgaGFzICIqIiBhbnl3aGVyZSB1bmxlc3MgUkVGTkFNRV9SRUZTUEVDX1BBVFRFUk4gaXMgc2V0LCBvcgogKiAtIGl0IGVuZHMgd2l0aCBhICIvIiwgb3IKICogLSBpdCBlbmRzIHdpdGggIi5sb2NrIiwgb3IKICogLSBpdCBjb250YWlucyBhICJAeyIgcG9ydGlvbgogKgogKiBXaGVuIHNhbml0aXplZCBpcyBub3QgTlVMTCwgaW5zdGVhZCBvZiByZWplY3RpbmcgdGhlIGlucHV0IHJlZm5hbWUKICogYXMgYW4gZXJyb3IsIHRyeSB0byBjb21lIHVwIHdpdGggYSB1c2FibGUgcmVwbGFjZW1lbnQgZm9yIHRoZSBpbnB1dAogKiByZWZuYW1lIGluIGl0LgogKi8Kc3RhdGljIGludCBjaGVja19yZWZuYW1lX2NvbXBvbmVudChjb25zdCBjaGFyICpyZWZuYW1lLCBpbnQgKmZsYWdzLAoJCQkJICAgc3RydWN0IHN0cmJ1ZiAqc2FuaXRpemVkKQp7Cgljb25zdCBjaGFyICpjcDsKCWNoYXIgbGFzdCA9ICdcMCc7CglzaXplX3QgY29tcG9uZW50X3N0YXJ0ID0gMDsgLyogZ2FyYmFnZSAtIG5vdCBhIHJlYXNvbmFibGUgaW5pdGlhbCB2YWx1ZSAqLwoKCWlmIChzYW5pdGl6ZWQpCgkJY29tcG9uZW50X3N0YXJ0ID0gc2FuaXRpemVkLT5sZW47CgoJZm9yIChjcCA9IHJlZm5hbWU7IDsgY3ArKykgewoJCWludCBjaCA9ICpjcCAmIDI1NTsKCQl1bnNpZ25lZCBjaGFyIGRpc3AgPSByZWZuYW1lX2Rpc3Bvc2l0aW9uW2NoXTsKCgkJaWYgKHNhbml0aXplZCAmJiBkaXNwICE9IDEpCgkJCXN0cmJ1Zl9hZGRjaChzYW5pdGl6ZWQsIGNoKTsKCgkJc3dpdGNoIChkaXNwKSB7CgkJY2FzZSAxOgoJCQlnb3RvIG91dDsKCQljYXNlIDI6CgkJCWlmIChsYXN0ID09ICcuJykgeyAvKiBSZWZuYW1lIGNvbnRhaW5zICIuLiIuICovCgkJCQlpZiAoc2FuaXRpemVkKQoJCQkJCS8qIGNvbGxhcHNlICIuLiIgdG8gc2luZ2xlICIuIiAqLwoJCQkJCXN0cmJ1Zl9zZXRsZW4oc2FuaXRpemVkLCBzYW5pdGl6ZWQtPmxlbiAtIDEpOwoJCQkJZWxzZQoJCQkJCXJldHVybiAtMTsKCQkJfQoJCQlicmVhazsKCQljYXNlIDM6CgkJCWlmIChsYXN0ID09ICdAJykgeyAvKiBSZWZuYW1lIGNvbnRhaW5zICJAeyIuICovCgkJCQlpZiAoc2FuaXRpemVkKQoJCQkJCXNhbml0aXplZC0+YnVmW3Nhbml0aXplZC0+bGVuLTFdID0gJy0nOwoJCQkJZWxzZQoJCQkJCXJldHVybiAtMTsKCQkJfQoJCQlicmVhazsKCQljYXNlIDQ6CgkJCS8qIGZvcmJpZGRlbiBjaGFyICovCgkJCWlmIChzYW5pdGl6ZWQpCgkJCQlzYW5pdGl6ZWQtPmJ1ZltzYW5pdGl6ZWQtPmxlbi0xXSA9ICctJzsKCQkJZWxzZQoJCQkJcmV0dXJuIC0xOwoJCQlicmVhazsKCQljYXNlIDU6CgkJCWlmICghKCpmbGFncyAmIFJFRk5BTUVfUkVGU1BFQ19QQVRURVJOKSkgewoJCQkJLyogcmVmc3BlYyBjYW4ndCBiZSBhIHBhdHRlcm4gKi8KCQkJCWlmIChzYW5pdGl6ZWQpCgkJCQkJc2FuaXRpemVkLT5idWZbc2FuaXRpemVkLT5sZW4tMV0gPSAnLSc7CgkJCQllbHNlCgkJCQkJcmV0dXJuIC0xOwoJCQl9CgoJCQkvKgoJCQkgKiBVbnNldCB0aGUgcGF0dGVybiBmbGFnIHNvIHRoYXQgd2Ugb25seSBhY2NlcHQKCQkJICogYSBzaW5nbGUgYXN0ZXJpc2sgZm9yIG9uZSBzaWRlIG9mIHJlZnNwZWMuCgkJCSAqLwoJCQkqZmxhZ3MgJj0gfiBSRUZOQU1FX1JFRlNQRUNfUEFUVEVSTjsKCQkJYnJlYWs7CgkJfQoJCWxhc3QgPSBjaDsKCX0Kb3V0OgoJaWYgKGNwID09IHJlZm5hbWUpCgkJcmV0dXJuIDA7IC8qIENvbXBvbmVudCBoYXMgemVybyBsZW5ndGguICovCgoJaWYgKHJlZm5hbWVbMF0gPT0gJy4nKSB7IC8qIENvbXBvbmVudCBzdGFydHMgd2l0aCAnLicuICovCgkJaWYgKHNhbml0aXplZCkKCQkJc2FuaXRpemVkLT5idWZbY29tcG9uZW50X3N0YXJ0XSA9ICctJzsKCQllbHNlCgkJCXJldHVybiAtMTsKCX0KCWlmIChjcCAtIHJlZm5hbWUgPj0gTE9DS19TVUZGSVhfTEVOICYmCgkgICAgIW1lbWNtcChjcCAtIExPQ0tfU1VGRklYX0xFTiwgTE9DS19TVUZGSVgsIExPQ0tfU1VGRklYX0xFTikpIHsKCQlpZiAoIXNhbml0aXplZCkKCQkJcmV0dXJuIC0xOwoJCS8qIFJlZm5hbWUgZW5kcyB3aXRoICIubG9jayIuICovCgkJd2hpbGUgKHN0cmJ1Zl9zdHJpcF9zdWZmaXgoc2FuaXRpemVkLCBMT0NLX1NVRkZJWCkpIHsKCQkJLyogdHJ5IGFnYWluIGluIGNhc2Ugd2UgaGF2ZSAubG9jay5sb2NrICovCgkJfQoJfQoJcmV0dXJuIGNwIC0gcmVmbmFtZTsKfQoKc3RhdGljIGludCBjaGVja19vcl9zYW5pdGl6ZV9yZWZuYW1lKGNvbnN0IGNoYXIgKnJlZm5hbWUsIGludCBmbGFncywKCQkJCSAgICAgc3RydWN0IHN0cmJ1ZiAqc2FuaXRpemVkKQp7CglpbnQgY29tcG9uZW50X2xlbiwgY29tcG9uZW50X2NvdW50ID0gMDsKCglpZiAoIXN0cmNtcChyZWZuYW1lLCAiQCIpKSB7CgkJLyogUmVmbmFtZSBpcyBhIHNpbmdsZSBjaGFyYWN0ZXIgJ0AnLiAqLwoJCWlmIChzYW5pdGl6ZWQpCgkJCXN0cmJ1Zl9hZGRjaChzYW5pdGl6ZWQsICctJyk7CgkJZWxzZQoJCQlyZXR1cm4gLTE7Cgl9CgoJd2hpbGUgKDEpIHsKCQlpZiAoc2FuaXRpemVkICYmIHNhbml0aXplZC0+bGVuKQoJCQlzdHJidWZfY29tcGxldGUoc2FuaXRpemVkLCAnLycpOwoKCQkvKiBXZSBhcmUgYXQgdGhlIHN0YXJ0IG9mIGEgcGF0aCBjb21wb25lbnQuICovCgkJY29tcG9uZW50X2xlbiA9IGNoZWNrX3JlZm5hbWVfY29tcG9uZW50KHJlZm5hbWUsICZmbGFncywKCQkJCQkJCXNhbml0aXplZCk7CgkJaWYgKHNhbml0aXplZCAmJiBjb21wb25lbnRfbGVuID09IDApCgkJCTsgLyogT0ssIG9taXQgZW1wdHkgY29tcG9uZW50ICovCgkJZWxzZSBpZiAoY29tcG9uZW50X2xlbiA8PSAwKQoJCQlyZXR1cm4gLTE7CgoJCWNvbXBvbmVudF9jb3VudCsrOwoJCWlmIChyZWZuYW1lW2NvbXBvbmVudF9sZW5dID09ICdcMCcpCgkJCWJyZWFrOwoJCS8qIFNraXAgdG8gbmV4dCBjb21wb25lbnQuICovCgkJcmVmbmFtZSArPSBjb21wb25lbnRfbGVuICsgMTsKCX0KCglpZiAocmVmbmFtZVtjb21wb25lbnRfbGVuIC0gMV0gPT0gJy4nKSB7CgkJLyogUmVmbmFtZSBlbmRzIHdpdGggJy4nLiAqLwoJCWlmIChzYW5pdGl6ZWQpCgkJCTsgLyogb21pdCBlbmRpbmcgZG90ICovCgkJZWxzZQoJCQlyZXR1cm4gLTE7Cgl9CglpZiAoIShmbGFncyAmIFJFRk5BTUVfQUxMT1dfT05FTEVWRUwpICYmIGNvbXBvbmVudF9jb3VudCA8IDIpCgkJcmV0dXJuIC0xOyAvKiBSZWZuYW1lIGhhcyBvbmx5IG9uZSBjb21wb25lbnQuICovCglyZXR1cm4gMDsKfQoKaW50IGNoZWNrX3JlZm5hbWVfZm9ybWF0KGNvbnN0IGNoYXIgKnJlZm5hbWUsIGludCBmbGFncykKewoJcmV0dXJuIGNoZWNrX29yX3Nhbml0aXplX3JlZm5hbWUocmVmbmFtZSwgZmxhZ3MsIE5VTEwpOwp9Cgp2b2lkIHNhbml0aXplX3JlZm5hbWVfY29tcG9uZW50KGNvbnN0IGNoYXIgKnJlZm5hbWUsIHN0cnVjdCBzdHJidWYgKm91dCkKewoJaWYgKGNoZWNrX29yX3Nhbml0aXplX3JlZm5hbWUocmVmbmFtZSwgUkVGTkFNRV9BTExPV19PTkVMRVZFTCwgb3V0KSkKCQlCVUcoInNhbml0aXppbmcgcmVmbmFtZSAnJXMnIGNoZWNrIHJldHVybmVkIGVycm9yIiwgcmVmbmFtZSk7Cn0KCmludCByZWZuYW1lX2lzX3NhZmUoY29uc3QgY2hhciAqcmVmbmFtZSkKewoJY29uc3QgY2hhciAqcmVzdDsKCglpZiAoc2tpcF9wcmVmaXgocmVmbmFtZSwgInJlZnMvIiwgJnJlc3QpKSB7CgkJY2hhciAqYnVmOwoJCWludCByZXN1bHQ7CgkJc2l6ZV90IHJlc3RsZW4gPSBzdHJsZW4ocmVzdCk7CgoJCS8qIHJlc3QgbXVzdCBub3QgYmUgZW1wdHksIG9yIHN0YXJ0IG9yIGVuZCB3aXRoICIvIiAqLwoJCWlmICghcmVzdGxlbiB8fCAqcmVzdCA9PSAnLycgfHwgcmVzdFtyZXN0bGVuIC0gMV0gPT0gJy8nKQoJCQlyZXR1cm4gMDsKCgkJLyoKCQkgKiBEb2VzIHRoZSByZWZuYW1lIHRyeSB0byBlc2NhcGUgcmVmcy8/CgkJICogRm9yIGV4YW1wbGU6IHJlZnMvZm9vLy4uL2JhciBpcyBzYWZlIGJ1dCByZWZzL2Zvby8uLi8uLi9iYXIKCQkgKiBpcyBub3QuCgkJICovCgkJYnVmID0geG1hbGxvY3oocmVzdGxlbik7CgkJcmVzdWx0ID0gIW5vcm1hbGl6ZV9wYXRoX2NvcHkoYnVmLCByZXN0KSAmJiAhc3RyY21wKGJ1ZiwgcmVzdCk7CgkJZnJlZShidWYpOwoJCXJldHVybiByZXN1bHQ7Cgl9CgoJZG8gewoJCWlmICghaXN1cHBlcigqcmVmbmFtZSkgJiYgKnJlZm5hbWUgIT0gJ18nKQoJCQlyZXR1cm4gMDsKCQlyZWZuYW1lKys7Cgl9IHdoaWxlICgqcmVmbmFtZSk7CglyZXR1cm4gMTsKfQoKLyoKICogUmV0dXJuIHRydWUgaWYgcmVmbmFtZSwgd2hpY2ggaGFzIHRoZSBzcGVjaWZpZWQgb2lkIGFuZCBmbGFncywgY2FuCiAqIGJlIHJlc29sdmVkIHRvIGFuIG9iamVjdCBpbiB0aGUgZGF0YWJhc2UuIElmIHRoZSByZWZlcnJlZC10byBvYmplY3QKICogZG9lcyBub3QgZXhpc3QsIGVtaXQgYSB3YXJuaW5nIGFuZCByZXR1cm4gZmFsc2UuCiAqLwppbnQgcmVmX3Jlc29sdmVzX3RvX29iamVjdChjb25zdCBjaGFyICpyZWZuYW1lLAoJCQkgICBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsCgkJCSAgIHVuc2lnbmVkIGludCBmbGFncykKewoJaWYgKGZsYWdzICYgUkVGX0lTQlJPS0VOKQoJCXJldHVybiAwOwoJaWYgKCFoYXNfb2JqZWN0X2ZpbGUob2lkKSkgewoJCWVycm9yKF8oIiVzIGRvZXMgbm90IHBvaW50IHRvIGEgdmFsaWQgb2JqZWN0ISIpLCByZWZuYW1lKTsKCQlyZXR1cm4gMDsKCX0KCXJldHVybiAxOwp9CgpjaGFyICpyZWZzX3Jlc29sdmVfcmVmZHVwKHN0cnVjdCByZWZfc3RvcmUgKnJlZnMsCgkJCSAgY29uc3QgY2hhciAqcmVmbmFtZSwgaW50IHJlc29sdmVfZmxhZ3MsCgkJCSAgc3RydWN0IG9iamVjdF9pZCAqb2lkLCBpbnQgKmZsYWdzKQp7Cgljb25zdCBjaGFyICpyZXN1bHQ7CgoJcmVzdWx0ID0gcmVmc19yZXNvbHZlX3JlZl91bnNhZmUocmVmcywgcmVmbmFtZSwgcmVzb2x2ZV9mbGFncywKCQkJCQkgb2lkLCBmbGFncyk7CglyZXR1cm4geHN0cmR1cF9vcl9udWxsKHJlc3VsdCk7Cn0KCmNoYXIgKnJlc29sdmVfcmVmZHVwKGNvbnN0IGNoYXIgKnJlZm5hbWUsIGludCByZXNvbHZlX2ZsYWdzLAoJCSAgICAgc3RydWN0IG9iamVjdF9pZCAqb2lkLCBpbnQgKmZsYWdzKQp7CglyZXR1cm4gcmVmc19yZXNvbHZlX3JlZmR1cChnZXRfbWFpbl9yZWZfc3RvcmUodGhlX3JlcG9zaXRvcnkpLAoJCQkJICAgcmVmbmFtZSwgcmVzb2x2ZV9mbGFncywKCQkJCSAgIG9pZCwgZmxhZ3MpOwp9CgovKiBUaGUgYXJndW1lbnQgdG8gZmlsdGVyX3JlZnMgKi8Kc3RydWN0IHJlZl9maWx0ZXIgewoJY29uc3QgY2hhciAqcGF0dGVybjsKCWNvbnN0IGNoYXIgKnByZWZpeDsKCWVhY2hfcmVmX2ZuICpmbjsKCXZvaWQgKmNiX2RhdGE7Cn07CgppbnQgcmVmc19yZWFkX3JlZl9mdWxsKHN0cnVjdCByZWZfc3RvcmUgKnJlZnMsIGNvbnN0IGNoYXIgKnJlZm5hbWUsCgkJICAgICAgIGludCByZXNvbHZlX2ZsYWdzLCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsIGludCAqZmxhZ3MpCnsKCWlmIChyZWZzX3Jlc29sdmVfcmVmX3Vuc2FmZShyZWZzLCByZWZuYW1lLCByZXNvbHZlX2ZsYWdzLCBvaWQsIGZsYWdzKSkKCQlyZXR1cm4gMDsKCXJldHVybiAtMTsKfQoKaW50IHJlYWRfcmVmX2Z1bGwoY29uc3QgY2hhciAqcmVmbmFtZSwgaW50IHJlc29sdmVfZmxhZ3MsIHN0cnVjdCBvYmplY3RfaWQgKm9pZCwgaW50ICpmbGFncykKewoJcmV0dXJuIHJlZnNfcmVhZF9yZWZfZnVsbChnZXRfbWFpbl9yZWZfc3RvcmUodGhlX3JlcG9zaXRvcnkpLCByZWZuYW1lLAoJCQkJICByZXNvbHZlX2ZsYWdzLCBvaWQsIGZsYWdzKTsKfQoKaW50IHJlYWRfcmVmKGNvbnN0IGNoYXIgKnJlZm5hbWUsIHN0cnVjdCBvYmplY3RfaWQgKm9pZCkKewoJcmV0dXJuIHJlYWRfcmVmX2Z1bGwocmVmbmFtZSwgUkVTT0xWRV9SRUZfUkVBRElORywgb2lkLCBOVUxMKTsKfQoKc3RhdGljIGludCByZWZzX3JlZl9leGlzdHMoc3RydWN0IHJlZl9zdG9yZSAqcmVmcywgY29uc3QgY2hhciAqcmVmbmFtZSkKewoJcmV0dXJuICEhcmVmc19yZXNvbHZlX3JlZl91bnNhZmUocmVmcywgcmVmbmFtZSwgUkVTT0xWRV9SRUZfUkVBRElORywgTlVMTCwgTlVMTCk7Cn0KCmludCByZWZfZXhpc3RzKGNvbnN0IGNoYXIgKnJlZm5hbWUpCnsKCXJldHVybiByZWZzX3JlZl9leGlzdHMoZ2V0X21haW5fcmVmX3N0b3JlKHRoZV9yZXBvc2l0b3J5KSwgcmVmbmFtZSk7Cn0KCnN0YXRpYyBpbnQgZmlsdGVyX3JlZnMoY29uc3QgY2hhciAqcmVmbmFtZSwgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLAoJCQkgICBpbnQgZmxhZ3MsIHZvaWQgKmRhdGEpCnsKCXN0cnVjdCByZWZfZmlsdGVyICpmaWx0ZXIgPSAoc3RydWN0IHJlZl9maWx0ZXIgKilkYXRhOwoKCWlmICh3aWxkbWF0Y2goZmlsdGVyLT5wYXR0ZXJuLCByZWZuYW1lLCAwKSkKCQlyZXR1cm4gMDsKCWlmIChmaWx0ZXItPnByZWZpeCkKCQlza2lwX3ByZWZpeChyZWZuYW1lLCBmaWx0ZXItPnByZWZpeCwgJnJlZm5hbWUpOwoJcmV0dXJuIGZpbHRlci0+Zm4ocmVmbmFtZSwgb2lkLCBmbGFncywgZmlsdGVyLT5jYl9kYXRhKTsKfQoKZW51bSBwZWVsX3N0YXR1cyBwZWVsX29iamVjdChjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpuYW1lLCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQpCnsKCXN0cnVjdCBvYmplY3QgKm8gPSBsb29rdXBfdW5rbm93bl9vYmplY3QobmFtZSk7CgoJaWYgKG8tPnR5cGUgPT0gT0JKX05PTkUpIHsKCQlpbnQgdHlwZSA9IG9pZF9vYmplY3RfaW5mbyh0aGVfcmVwb3NpdG9yeSwgbmFtZSwgTlVMTCk7CgkJaWYgKHR5cGUgPCAwIHx8ICFvYmplY3RfYXNfdHlwZShvLCB0eXBlLCAwKSkKCQkJcmV0dXJuIFBFRUxfSU5WQUxJRDsKCX0KCglpZiAoby0+dHlwZSAhPSBPQkpfVEFHKQoJCXJldHVybiBQRUVMX05PTl9UQUc7CgoJbyA9IGRlcmVmX3RhZ19ub3ZlcmlmeShvKTsKCWlmICghbykKCQlyZXR1cm4gUEVFTF9JTlZBTElEOwoKCW9pZGNweShvaWQsICZvLT5vaWQpOwoJcmV0dXJuIFBFRUxfUEVFTEVEOwp9CgpzdHJ1Y3Qgd2Fybl9pZl9kYW5nbGluZ19kYXRhIHsKCUZJTEUgKmZwOwoJY29uc3QgY2hhciAqcmVmbmFtZTsKCWNvbnN0IHN0cnVjdCBzdHJpbmdfbGlzdCAqcmVmbmFtZXM7Cgljb25zdCBjaGFyICptc2dfZm10Owp9OwoKc3RhdGljIGludCB3YXJuX2lmX2RhbmdsaW5nX3N5bXJlZihjb25zdCBjaGFyICpyZWZuYW1lLCBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsCgkJCQkgICBpbnQgZmxhZ3MsIHZvaWQgKmNiX2RhdGEpCnsKCXN0cnVjdCB3YXJuX2lmX2RhbmdsaW5nX2RhdGEgKmQgPSBjYl9kYXRhOwoJY29uc3QgY2hhciAqcmVzb2x2ZXNfdG87CgoJaWYgKCEoZmxhZ3MgJiBSRUZfSVNTWU1SRUYpKQoJCXJldHVybiAwOwoKCXJlc29sdmVzX3RvID0gcmVzb2x2ZV9yZWZfdW5zYWZlKHJlZm5hbWUsIDAsIE5VTEwsIE5VTEwpOwoJaWYgKCFyZXNvbHZlc190bwoJICAgIHx8IChkLT5yZWZuYW1lCgkJPyBzdHJjbXAocmVzb2x2ZXNfdG8sIGQtPnJlZm5hbWUpCgkJOiAhc3RyaW5nX2xpc3RfaGFzX3N0cmluZyhkLT5yZWZuYW1lcywgcmVzb2x2ZXNfdG8pKSkgewoJCXJldHVybiAwOwoJfQoKCWZwcmludGYoZC0+ZnAsIGQtPm1zZ19mbXQsIHJlZm5hbWUpOwoJZnB1dGMoJ1xuJywgZC0+ZnApOwoJcmV0dXJuIDA7Cn0KCnZvaWQgd2Fybl9kYW5nbGluZ19zeW1yZWYoRklMRSAqZnAsIGNvbnN0IGNoYXIgKm1zZ19mbXQsIGNvbnN0IGNoYXIgKnJlZm5hbWUpCnsKCXN0cnVjdCB3YXJuX2lmX2RhbmdsaW5nX2RhdGEgZGF0YTsKCglkYXRhLmZwID0gZnA7CglkYXRhLnJlZm5hbWUgPSByZWZuYW1lOwoJZGF0YS5yZWZuYW1lcyA9IE5VTEw7CglkYXRhLm1zZ19mbXQgPSBtc2dfZm10OwoJZm9yX2VhY2hfcmF3cmVmKHdhcm5faWZfZGFuZ2xpbmdfc3ltcmVmLCAmZGF0YSk7Cn0KCnZvaWQgd2Fybl9kYW5nbGluZ19zeW1yZWZzKEZJTEUgKmZwLCBjb25zdCBjaGFyICptc2dfZm10LCBjb25zdCBzdHJ1Y3Qgc3RyaW5nX2xpc3QgKnJlZm5hbWVzKQp7CglzdHJ1Y3Qgd2Fybl9pZl9kYW5nbGluZ19kYXRhIGRhdGE7CgoJZGF0YS5mcCA9IGZwOwoJZGF0YS5yZWZuYW1lID0gTlVMTDsKCWRhdGEucmVmbmFtZXMgPSByZWZuYW1lczsKCWRhdGEubXNnX2ZtdCA9IG1zZ19mbXQ7Cglmb3JfZWFjaF9yYXdyZWYod2Fybl9pZl9kYW5nbGluZ19zeW1yZWYsICZkYXRhKTsKfQoKaW50IHJlZnNfZm9yX2VhY2hfdGFnX3JlZihzdHJ1Y3QgcmVmX3N0b3JlICpyZWZzLCBlYWNoX3JlZl9mbiBmbiwgdm9pZCAqY2JfZGF0YSkKewoJcmV0dXJuIHJlZnNfZm9yX2VhY2hfcmVmX2luKHJlZnMsICJyZWZzL3RhZ3MvIiwgZm4sIGNiX2RhdGEpOwp9CgppbnQgZm9yX2VhY2hfdGFnX3JlZihlYWNoX3JlZl9mbiBmbiwgdm9pZCAqY2JfZGF0YSkKewoJcmV0dXJuIHJlZnNfZm9yX2VhY2hfdGFnX3JlZihnZXRfbWFpbl9yZWZfc3RvcmUodGhlX3JlcG9zaXRvcnkpLCBmbiwgY2JfZGF0YSk7Cn0KCmludCByZWZzX2Zvcl9lYWNoX2JyYW5jaF9yZWYoc3RydWN0IHJlZl9zdG9yZSAqcmVmcywgZWFjaF9yZWZfZm4gZm4sIHZvaWQgKmNiX2RhdGEpCnsKCXJldHVybiByZWZzX2Zvcl9lYWNoX3JlZl9pbihyZWZzLCAicmVmcy9oZWFkcy8iLCBmbiwgY2JfZGF0YSk7Cn0KCmludCBmb3JfZWFjaF9icmFuY2hfcmVmKGVhY2hfcmVmX2ZuIGZuLCB2b2lkICpjYl9kYXRhKQp7CglyZXR1cm4gcmVmc19mb3JfZWFjaF9icmFuY2hfcmVmKGdldF9tYWluX3JlZl9zdG9yZSh0aGVfcmVwb3NpdG9yeSksIGZuLCBjYl9kYXRhKTsKfQoKaW50IHJlZnNfZm9yX2VhY2hfcmVtb3RlX3JlZihzdHJ1Y3QgcmVmX3N0b3JlICpyZWZzLCBlYWNoX3JlZl9mbiBmbiwgdm9pZCAqY2JfZGF0YSkKewoJcmV0dXJuIHJlZnNfZm9yX2VhY2hfcmVmX2luKHJlZnMsICJyZWZzL3JlbW90ZXMvIiwgZm4sIGNiX2RhdGEpOwp9CgppbnQgZm9yX2VhY2hfcmVtb3RlX3JlZihlYWNoX3JlZl9mbiBmbiwgdm9pZCAqY2JfZGF0YSkKewoJcmV0dXJuIHJlZnNfZm9yX2VhY2hfcmVtb3RlX3JlZihnZXRfbWFpbl9yZWZfc3RvcmUodGhlX3JlcG9zaXRvcnkpLCBmbiwgY2JfZGF0YSk7Cn0KCmludCBoZWFkX3JlZl9uYW1lc3BhY2VkKGVhY2hfcmVmX2ZuIGZuLCB2b2lkICpjYl9kYXRhKQp7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoJaW50IHJldCA9IDA7CglzdHJ1Y3Qgb2JqZWN0X2lkIG9pZDsKCWludCBmbGFnOwoKCXN0cmJ1Zl9hZGRmKCZidWYsICIlc0hFQUQiLCBnZXRfZ2l0X25hbWVzcGFjZSgpKTsKCWlmICghcmVhZF9yZWZfZnVsbChidWYuYnVmLCBSRVNPTFZFX1JFRl9SRUFESU5HLCAmb2lkLCAmZmxhZykpCgkJcmV0ID0gZm4oYnVmLmJ1ZiwgJm9pZCwgZmxhZywgY2JfZGF0YSk7CglzdHJidWZfcmVsZWFzZSgmYnVmKTsKCglyZXR1cm4gcmV0Owp9Cgp2b2lkIG5vcm1hbGl6ZV9nbG9iX3JlZihzdHJ1Y3Qgc3RyaW5nX2xpc3RfaXRlbSAqaXRlbSwgY29uc3QgY2hhciAqcHJlZml4LAoJCQljb25zdCBjaGFyICpwYXR0ZXJuKQp7CglzdHJ1Y3Qgc3RyYnVmIG5vcm1hbGl6ZWRfcGF0dGVybiA9IFNUUkJVRl9JTklUOwoKCWlmICgqcGF0dGVybiA9PSAnLycpCgkJQlVHKCJwYXR0ZXJuIG11c3Qgbm90IHN0YXJ0IHdpdGggJy8nIik7CgoJaWYgKHByZWZpeCkgewoJCXN0cmJ1Zl9hZGRzdHIoJm5vcm1hbGl6ZWRfcGF0dGVybiwgcHJlZml4KTsKCX0KCWVsc2UgaWYgKCFzdGFydHNfd2l0aChwYXR0ZXJuLCAicmVmcy8iKSkKCQlzdHJidWZfYWRkc3RyKCZub3JtYWxpemVkX3BhdHRlcm4sICJyZWZzLyIpOwoJc3RyYnVmX2FkZHN0cigmbm9ybWFsaXplZF9wYXR0ZXJuLCBwYXR0ZXJuKTsKCXN0cmJ1Zl9zdHJpcF9zdWZmaXgoJm5vcm1hbGl6ZWRfcGF0dGVybiwgIi8iKTsKCglpdGVtLT5zdHJpbmcgPSBzdHJidWZfZGV0YWNoKCZub3JtYWxpemVkX3BhdHRlcm4sIE5VTEwpOwoJaXRlbS0+dXRpbCA9IGhhc19nbG9iX3NwZWNpYWxzKHBhdHRlcm4pID8gTlVMTCA6IGl0ZW0tPnN0cmluZzsKCXN0cmJ1Zl9yZWxlYXNlKCZub3JtYWxpemVkX3BhdHRlcm4pOwp9CgppbnQgZm9yX2VhY2hfZ2xvYl9yZWZfaW4oZWFjaF9yZWZfZm4gZm4sIGNvbnN0IGNoYXIgKnBhdHRlcm4sCgljb25zdCBjaGFyICpwcmVmaXgsIHZvaWQgKmNiX2RhdGEpCnsKCXN0cnVjdCBzdHJidWYgcmVhbF9wYXR0ZXJuID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3QgcmVmX2ZpbHRlciBmaWx0ZXI7CglpbnQgcmV0OwoKCWlmICghcHJlZml4ICYmICFzdGFydHNfd2l0aChwYXR0ZXJuLCAicmVmcy8iKSkKCQlzdHJidWZfYWRkc3RyKCZyZWFsX3BhdHRlcm4sICJyZWZzLyIpOwoJZWxzZSBpZiAocHJlZml4KQoJCXN0cmJ1Zl9hZGRzdHIoJnJlYWxfcGF0dGVybiwgcHJlZml4KTsKCXN0cmJ1Zl9hZGRzdHIoJnJlYWxfcGF0dGVybiwgcGF0dGVybik7CgoJaWYgKCFoYXNfZ2xvYl9zcGVjaWFscyhwYXR0ZXJuKSkgewoJCS8qIEFwcGVuZCBpbXBsaWVkICcvJyAnKicgaWYgbm90IHByZXNlbnQuICovCgkJc3RyYnVmX2NvbXBsZXRlKCZyZWFsX3BhdHRlcm4sICcvJyk7CgkJLyogTm8gbmVlZCB0byBjaGVjayBmb3IgJyonLCB0aGVyZSBpcyBub25lLiAqLwoJCXN0cmJ1Zl9hZGRjaCgmcmVhbF9wYXR0ZXJuLCAnKicpOwoJfQoKCWZpbHRlci5wYXR0ZXJuID0gcmVhbF9wYXR0ZXJuLmJ1ZjsKCWZpbHRlci5wcmVmaXggPSBwcmVmaXg7CglmaWx0ZXIuZm4gPSBmbjsKCWZpbHRlci5jYl9kYXRhID0gY2JfZGF0YTsKCXJldCA9IGZvcl9lYWNoX3JlZihmaWx0ZXJfcmVmcywgJmZpbHRlcik7CgoJc3RyYnVmX3JlbGVhc2UoJnJlYWxfcGF0dGVybik7CglyZXR1cm4gcmV0Owp9CgppbnQgZm9yX2VhY2hfZ2xvYl9yZWYoZWFjaF9yZWZfZm4gZm4sIGNvbnN0IGNoYXIgKnBhdHRlcm4sIHZvaWQgKmNiX2RhdGEpCnsKCXJldHVybiBmb3JfZWFjaF9nbG9iX3JlZl9pbihmbiwgcGF0dGVybiwgTlVMTCwgY2JfZGF0YSk7Cn0KCmNvbnN0IGNoYXIgKnByZXR0aWZ5X3JlZm5hbWUoY29uc3QgY2hhciAqbmFtZSkKewoJaWYgKHNraXBfcHJlZml4KG5hbWUsICJyZWZzL2hlYWRzLyIsICZuYW1lKSB8fAoJICAgIHNraXBfcHJlZml4KG5hbWUsICJyZWZzL3RhZ3MvIiwgJm5hbWUpIHx8CgkgICAgc2tpcF9wcmVmaXgobmFtZSwgInJlZnMvcmVtb3Rlcy8iLCAmbmFtZSkpCgkJOyAvKiBub3RoaW5nICovCglyZXR1cm4gbmFtZTsKfQoKc3RhdGljIGNvbnN0IGNoYXIgKnJlZl9yZXZfcGFyc2VfcnVsZXNbXSA9IHsKCSIlLipzIiwKCSJyZWZzLyUuKnMiLAoJInJlZnMvdGFncy8lLipzIiwKCSJyZWZzL2hlYWRzLyUuKnMiLAoJInJlZnMvcmVtb3Rlcy8lLipzIiwKCSJyZWZzL3JlbW90ZXMvJS4qcy9IRUFEIiwKCU5VTEwKfTsKCiNkZWZpbmUgTlVNX1JFVl9QQVJTRV9SVUxFUyAoQVJSQVlfU0laRShyZWZfcmV2X3BhcnNlX3J1bGVzKSAtIDEpCgovKgogKiBJcyBpdCBwb3NzaWJsZSB0aGF0IHRoZSBjYWxsZXIgbWVhbnQgZnVsbF9uYW1lIHdpdGggYWJicmV2X25hbWU/CiAqIElmIHNvIHJldHVybiBhIG5vbi16ZXJvIHZhbHVlIHRvIHNpZ25hbCAieWVzIjsgdGhlIG1hZ25pdHVkZSBvZgogKiB0aGUgcmV0dXJuZWQgdmFsdWUgZ2l2ZXMgdGhlIHByZWNlZGVuY2UgdXNlZCBmb3IgZGlzYW1iaWd1YXRpb24uCiAqCiAqIElmIGFiYnJldl9uYW1lIGNhbm5vdCBtZWFuIGZ1bGxfbmFtZSwgcmV0dXJuIDAuCiAqLwppbnQgcmVmbmFtZV9tYXRjaChjb25zdCBjaGFyICphYmJyZXZfbmFtZSwgY29uc3QgY2hhciAqZnVsbF9uYW1lKQp7Cgljb25zdCBjaGFyICoqcDsKCWNvbnN0IGludCBhYmJyZXZfbmFtZV9sZW4gPSBzdHJsZW4oYWJicmV2X25hbWUpOwoJY29uc3QgaW50IG51bV9ydWxlcyA9IE5VTV9SRVZfUEFSU0VfUlVMRVM7CgoJZm9yIChwID0gcmVmX3Jldl9wYXJzZV9ydWxlczsgKnA7IHArKykKCQlpZiAoIXN0cmNtcChmdWxsX25hbWUsIG1rcGF0aCgqcCwgYWJicmV2X25hbWVfbGVuLCBhYmJyZXZfbmFtZSkpKQoJCQlyZXR1cm4gJnJlZl9yZXZfcGFyc2VfcnVsZXNbbnVtX3J1bGVzXSAtIHA7CgoJcmV0dXJuIDA7Cn0KCi8qCiAqIEdpdmVuIGEgJ3ByZWZpeCcgZXhwYW5kIGl0IGJ5IHRoZSBydWxlcyBpbiAncmVmX3Jldl9wYXJzZV9ydWxlcycgYW5kIGFkZAogKiB0aGUgcmVzdWx0cyB0byAncHJlZml4ZXMnCiAqLwp2b2lkIGV4cGFuZF9yZWZfcHJlZml4KHN0cnVjdCBhcmd2X2FycmF5ICpwcmVmaXhlcywgY29uc3QgY2hhciAqcHJlZml4KQp7Cgljb25zdCBjaGFyICoqcDsKCWludCBsZW4gPSBzdHJsZW4ocHJlZml4KTsKCglmb3IgKHAgPSByZWZfcmV2X3BhcnNlX3J1bGVzOyAqcDsgcCsrKQoJCWFyZ3ZfYXJyYXlfcHVzaGYocHJlZml4ZXMsICpwLCBsZW4sIHByZWZpeCk7Cn0KCmNoYXIgKnJlcG9fZGVmYXVsdF9icmFuY2hfbmFtZShzdHJ1Y3QgcmVwb3NpdG9yeSAqcikKewoJY29uc3QgY2hhciAqY29uZmlnX2tleSA9ICJpbml0LmRlZmF1bHRicmFuY2giOwoJY29uc3QgY2hhciAqY29uZmlnX2Rpc3BsYXlfa2V5ID0gImluaXQuZGVmYXVsdEJyYW5jaCI7CgljaGFyICpyZXQgPSBOVUxMLCAqZnVsbF9yZWY7CgoJaWYgKHJlcG9fY29uZmlnX2dldF9zdHJpbmcociwgY29uZmlnX2tleSwgJnJldCkgPCAwKQoJCWRpZShfKCJjb3VsZCBub3QgcmV0cmlldmUgYCVzYCIpLCBjb25maWdfZGlzcGxheV9rZXkpOwoKCWlmICghcmV0KQoJCXJldCA9IHhzdHJkdXAoIm1hc3RlciIpOwoKCWZ1bGxfcmVmID0geHN0cmZtdCgicmVmcy9oZWFkcy8lcyIsIHJldCk7CglpZiAoY2hlY2tfcmVmbmFtZV9mb3JtYXQoZnVsbF9yZWYsIDApKQoJCWRpZShfKCJpbnZhbGlkIGJyYW5jaCBuYW1lOiAlcyA9ICVzIiksIGNvbmZpZ19kaXNwbGF5X2tleSwgcmV0KTsKCWZyZWUoZnVsbF9yZWYpOwoKCXJldHVybiByZXQ7Cn0KCmNvbnN0IGNoYXIgKmdpdF9kZWZhdWx0X2JyYW5jaF9uYW1lKHZvaWQpCnsKCXN0YXRpYyBjaGFyICpyZXQ7CgoJaWYgKCFyZXQpCgkJcmV0ID0gcmVwb19kZWZhdWx0X2JyYW5jaF9uYW1lKHRoZV9yZXBvc2l0b3J5KTsKCglyZXR1cm4gcmV0Owp9CgovKgogKiAqc3RyaW5nIGFuZCAqbGVuIHdpbGwgb25seSBiZSBzdWJzdGl0dXRlZCwgYW5kICpzdHJpbmcgcmV0dXJuZWQgKGZvcgogKiBsYXRlciBmcmVlKClpbmcpIGlmIHRoZSBzdHJpbmcgcGFzc2VkIGluIGlzIGEgbWFnaWMgc2hvcnQtaGFuZCBmb3JtCiAqIHRvIG5hbWUgYSBicmFuY2guCiAqLwpzdGF0aWMgY2hhciAqc3Vic3RpdHV0ZV9icmFuY2hfbmFtZShzdHJ1Y3QgcmVwb3NpdG9yeSAqciwKCQkJCSAgICBjb25zdCBjaGFyICoqc3RyaW5nLCBpbnQgKmxlbikKewoJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCWludCByZXQgPSByZXBvX2ludGVycHJldF9icmFuY2hfbmFtZShyLCAqc3RyaW5nLCAqbGVuLCAmYnVmLCAwKTsKCglpZiAocmV0ID09ICpsZW4pIHsKCQlzaXplX3Qgc2l6ZTsKCQkqc3RyaW5nID0gc3RyYnVmX2RldGFjaCgmYnVmLCAmc2l6ZSk7CgkJKmxlbiA9IHNpemU7CgkJcmV0dXJuIChjaGFyICopKnN0cmluZzsKCX0KCglyZXR1cm4gTlVMTDsKfQoKaW50IHJlcG9fZHdpbV9yZWYoc3RydWN0IHJlcG9zaXRvcnkgKnIsIGNvbnN0IGNoYXIgKnN0ciwgaW50IGxlbiwKCQkgIHN0cnVjdCBvYmplY3RfaWQgKm9pZCwgY2hhciAqKnJlZikKewoJY2hhciAqbGFzdF9icmFuY2ggPSBzdWJzdGl0dXRlX2JyYW5jaF9uYW1lKHIsICZzdHIsICZsZW4pOwoJaW50ICAgcmVmc19mb3VuZCAgPSBleHBhbmRfcmVmKHIsIHN0ciwgbGVuLCBvaWQsIHJlZik7CglmcmVlKGxhc3RfYnJhbmNoKTsKCXJldHVybiByZWZzX2ZvdW5kOwp9CgppbnQgZHdpbV9yZWYoY29uc3QgY2hhciAqc3RyLCBpbnQgbGVuLCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsIGNoYXIgKipyZWYpCnsKCXJldHVybiByZXBvX2R3aW1fcmVmKHRoZV9yZXBvc2l0b3J5LCBzdHIsIGxlbiwgb2lkLCByZWYpOwp9CgppbnQgZXhwYW5kX3JlZihzdHJ1Y3QgcmVwb3NpdG9yeSAqcmVwbywgY29uc3QgY2hhciAqc3RyLCBpbnQgbGVuLAoJICAgICAgIHN0cnVjdCBvYmplY3RfaWQgKm9pZCwgY2hhciAqKnJlZikKewoJY29uc3QgY2hhciAqKnAsICpyOwoJaW50IHJlZnNfZm91bmQgPSAwOwoJc3RydWN0IHN0cmJ1ZiBmdWxscmVmID0gU1RSQlVGX0lOSVQ7CgoJKnJlZiA9IE5VTEw7Cglmb3IgKHAgPSByZWZfcmV2X3BhcnNlX3J1bGVzOyAqcDsgcCsrKSB7CgkJc3RydWN0IG9iamVjdF9pZCBvaWRfZnJvbV9yZWY7CgkJc3RydWN0IG9iamVjdF9pZCAqdGhpc19yZXN1bHQ7CgkJaW50IGZsYWc7CgoJCXRoaXNfcmVzdWx0ID0gcmVmc19mb3VuZCA/ICZvaWRfZnJvbV9yZWYgOiBvaWQ7CgkJc3RyYnVmX3Jlc2V0KCZmdWxscmVmKTsKCQlzdHJidWZfYWRkZigmZnVsbHJlZiwgKnAsIGxlbiwgc3RyKTsKCQlyID0gcmVmc19yZXNvbHZlX3JlZl91bnNhZmUoZ2V0X21haW5fcmVmX3N0b3JlKHJlcG8pLAoJCQkJCSAgICBmdWxscmVmLmJ1ZiwgUkVTT0xWRV9SRUZfUkVBRElORywKCQkJCQkgICAgdGhpc19yZXN1bHQsICZmbGFnKTsKCQlpZiAocikgewoJCQlpZiAoIXJlZnNfZm91bmQrKykKCQkJCSpyZWYgPSB4c3RyZHVwKHIpOwoJCQlpZiAoIXdhcm5fYW1iaWd1b3VzX3JlZnMpCgkJCQlicmVhazsKCQl9IGVsc2UgaWYgKChmbGFnICYgUkVGX0lTU1lNUkVGKSAmJiBzdHJjbXAoZnVsbHJlZi5idWYsICJIRUFEIikpIHsKCQkJd2FybmluZyhfKCJpZ25vcmluZyBkYW5nbGluZyBzeW1yZWYgJXMiKSwgZnVsbHJlZi5idWYpOwoJCX0gZWxzZSBpZiAoKGZsYWcgJiBSRUZfSVNCUk9LRU4pICYmIHN0cmNocihmdWxscmVmLmJ1ZiwgJy8nKSkgewoJCQl3YXJuaW5nKF8oImlnbm9yaW5nIGJyb2tlbiByZWYgJXMiKSwgZnVsbHJlZi5idWYpOwoJCX0KCX0KCXN0cmJ1Zl9yZWxlYXNlKCZmdWxscmVmKTsKCXJldHVybiByZWZzX2ZvdW5kOwp9CgppbnQgcmVwb19kd2ltX2xvZyhzdHJ1Y3QgcmVwb3NpdG9yeSAqciwgY29uc3QgY2hhciAqc3RyLCBpbnQgbGVuLAoJCSAgc3RydWN0IG9iamVjdF9pZCAqb2lkLCBjaGFyICoqbG9nKQp7CglzdHJ1Y3QgcmVmX3N0b3JlICpyZWZzID0gZ2V0X21haW5fcmVmX3N0b3JlKHIpOwoJY2hhciAqbGFzdF9icmFuY2ggPSBzdWJzdGl0dXRlX2JyYW5jaF9uYW1lKHIsICZzdHIsICZsZW4pOwoJY29uc3QgY2hhciAqKnA7CglpbnQgbG9nc19mb3VuZCA9IDA7CglzdHJ1Y3Qgc3RyYnVmIHBhdGggPSBTVFJCVUZfSU5JVDsKCgkqbG9nID0gTlVMTDsKCWZvciAocCA9IHJlZl9yZXZfcGFyc2VfcnVsZXM7ICpwOyBwKyspIHsKCQlzdHJ1Y3Qgb2JqZWN0X2lkIGhhc2g7CgkJY29uc3QgY2hhciAqcmVmLCAqaXQ7CgoJCXN0cmJ1Zl9yZXNldCgmcGF0aCk7CgkJc3RyYnVmX2FkZGYoJnBhdGgsICpwLCBsZW4sIHN0cik7CgkJcmVmID0gcmVmc19yZXNvbHZlX3JlZl91bnNhZmUocmVmcywgcGF0aC5idWYsCgkJCQkJICAgICAgUkVTT0xWRV9SRUZfUkVBRElORywKCQkJCQkgICAgICAmaGFzaCwgTlVMTCk7CgkJaWYgKCFyZWYpCgkJCWNvbnRpbnVlOwoJCWlmIChyZWZzX3JlZmxvZ19leGlzdHMocmVmcywgcGF0aC5idWYpKQoJCQlpdCA9IHBhdGguYnVmOwoJCWVsc2UgaWYgKHN0cmNtcChyZWYsIHBhdGguYnVmKSAmJgoJCQkgcmVmc19yZWZsb2dfZXhpc3RzKHJlZnMsIHJlZikpCgkJCWl0ID0gcmVmOwoJCWVsc2UKCQkJY29udGludWU7CgkJaWYgKCFsb2dzX2ZvdW5kKyspIHsKCQkJKmxvZyA9IHhzdHJkdXAoaXQpOwoJCQlvaWRjcHkob2lkLCAmaGFzaCk7CgkJfQoJCWlmICghd2Fybl9hbWJpZ3VvdXNfcmVmcykKCQkJYnJlYWs7Cgl9CglzdHJidWZfcmVsZWFzZSgmcGF0aCk7CglmcmVlKGxhc3RfYnJhbmNoKTsKCXJldHVybiBsb2dzX2ZvdW5kOwp9CgppbnQgZHdpbV9sb2coY29uc3QgY2hhciAqc3RyLCBpbnQgbGVuLCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsIGNoYXIgKipsb2cpCnsKCXJldHVybiByZXBvX2R3aW1fbG9nKHRoZV9yZXBvc2l0b3J5LCBzdHIsIGxlbiwgb2lkLCBsb2cpOwp9CgpzdGF0aWMgaW50IGlzX3Blcl93b3JrdHJlZV9yZWYoY29uc3QgY2hhciAqcmVmbmFtZSkKewoJcmV0dXJuICFzdHJjbXAocmVmbmFtZSwgIkhFQUQiKSB8fAoJCXN0YXJ0c193aXRoKHJlZm5hbWUsICJyZWZzL3dvcmt0cmVlLyIpIHx8CgkJc3RhcnRzX3dpdGgocmVmbmFtZSwgInJlZnMvYmlzZWN0LyIpIHx8CgkJc3RhcnRzX3dpdGgocmVmbmFtZSwgInJlZnMvcmV3cml0dGVuLyIpOwp9CgpzdGF0aWMgaW50IGlzX3BzZXVkb3JlZl9zeW50YXgoY29uc3QgY2hhciAqcmVmbmFtZSkKewoJY29uc3QgY2hhciAqYzsKCglmb3IgKGMgPSByZWZuYW1lOyAqYzsgYysrKSB7CgkJaWYgKCFpc3VwcGVyKCpjKSAmJiAqYyAhPSAnLScgJiYgKmMgIT0gJ18nKQoJCQlyZXR1cm4gMDsKCX0KCglyZXR1cm4gMTsKfQoKc3RhdGljIGludCBpc19tYWluX3BzZXVkb3JlZl9zeW50YXgoY29uc3QgY2hhciAqcmVmbmFtZSkKewoJcmV0dXJuIHNraXBfcHJlZml4KHJlZm5hbWUsICJtYWluLXdvcmt0cmVlLyIsICZyZWZuYW1lKSAmJgoJCSpyZWZuYW1lICYmCgkJaXNfcHNldWRvcmVmX3N5bnRheChyZWZuYW1lKTsKfQoKc3RhdGljIGludCBpc19vdGhlcl9wc2V1ZG9yZWZfc3ludGF4KGNvbnN0IGNoYXIgKnJlZm5hbWUpCnsKCWlmICghc2tpcF9wcmVmaXgocmVmbmFtZSwgIndvcmt0cmVlcy8iLCAmcmVmbmFtZSkpCgkJcmV0dXJuIDA7CglyZWZuYW1lID0gc3RyY2hyKHJlZm5hbWUsICcvJyk7CglpZiAoIXJlZm5hbWUgfHwgIXJlZm5hbWVbMV0pCgkJcmV0dXJuIDA7CglyZXR1cm4gaXNfcHNldWRvcmVmX3N5bnRheChyZWZuYW1lICsgMSk7Cn0KCmVudW0gcmVmX3R5cGUgcmVmX3R5cGUoY29uc3QgY2hhciAqcmVmbmFtZSkKewoJaWYgKGlzX3Blcl93b3JrdHJlZV9yZWYocmVmbmFtZSkpCgkJcmV0dXJuIFJFRl9UWVBFX1BFUl9XT1JLVFJFRTsKCWlmIChpc19wc2V1ZG9yZWZfc3ludGF4KHJlZm5hbWUpKQoJCXJldHVybiBSRUZfVFlQRV9QU0VVRE9SRUY7CglpZiAoaXNfbWFpbl9wc2V1ZG9yZWZfc3ludGF4KHJlZm5hbWUpKQoJCXJldHVybiBSRUZfVFlQRV9NQUlOX1BTRVVET1JFRjsKCWlmIChpc19vdGhlcl9wc2V1ZG9yZWZfc3ludGF4KHJlZm5hbWUpKQoJCXJldHVybiBSRUZfVFlQRV9PVEhFUl9QU0VVRE9SRUY7CglyZXR1cm4gUkVGX1RZUEVfTk9STUFMOwp9Cgpsb25nIGdldF9maWxlc19yZWZfbG9ja190aW1lb3V0X21zKHZvaWQpCnsKCXN0YXRpYyBpbnQgY29uZmlndXJlZCA9IDA7CgoJLyogVGhlIGRlZmF1bHQgdGltZW91dCBpcyAxMDAgbXM6ICovCglzdGF0aWMgaW50IHRpbWVvdXRfbXMgPSAxMDA7CgoJaWYgKCFjb25maWd1cmVkKSB7CgkJZ2l0X2NvbmZpZ19nZXRfaW50KCJjb3JlLmZpbGVzcmVmbG9ja3RpbWVvdXQiLCAmdGltZW91dF9tcyk7CgkJY29uZmlndXJlZCA9IDE7Cgl9CgoJcmV0dXJuIHRpbWVvdXRfbXM7Cn0KCnN0YXRpYyBpbnQgd3JpdGVfcHNldWRvcmVmKGNvbnN0IGNoYXIgKnBzZXVkb3JlZiwgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLAoJCQkgICBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvbGRfb2lkLCBzdHJ1Y3Qgc3RyYnVmICplcnIpCnsKCWNvbnN0IGNoYXIgKmZpbGVuYW1lOwoJaW50IGZkOwoJc3RydWN0IGxvY2tfZmlsZSBsb2NrID0gTE9DS19JTklUOwoJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCWludCByZXQgPSAtMTsKCglpZiAoIW9pZCkKCQlyZXR1cm4gMDsKCglzdHJidWZfYWRkZigmYnVmLCAiJXNcbiIsIG9pZF90b19oZXgob2lkKSk7CgoJZmlsZW5hbWUgPSBnaXRfcGF0aCgiJXMiLCBwc2V1ZG9yZWYpOwoJZmQgPSBob2xkX2xvY2tfZmlsZV9mb3JfdXBkYXRlX3RpbWVvdXQoJmxvY2ssIGZpbGVuYW1lLCAwLAoJCQkJCSAgICAgICBnZXRfZmlsZXNfcmVmX2xvY2tfdGltZW91dF9tcygpKTsKCWlmIChmZCA8IDApIHsKCQlzdHJidWZfYWRkZihlcnIsIF8oImNvdWxkIG5vdCBvcGVuICclcycgZm9yIHdyaXRpbmc6ICVzIiksCgkJCSAgICBmaWxlbmFtZSwgc3RyZXJyb3IoZXJybm8pKTsKCQlnb3RvIGRvbmU7Cgl9CgoJaWYgKG9sZF9vaWQpIHsKCQlzdHJ1Y3Qgb2JqZWN0X2lkIGFjdHVhbF9vbGRfb2lkOwoKCQlpZiAocmVhZF9yZWYocHNldWRvcmVmLCAmYWN0dWFsX29sZF9vaWQpKSB7CgkJCWlmICghaXNfbnVsbF9vaWQob2xkX29pZCkpIHsKCQkJCXN0cmJ1Zl9hZGRmKGVyciwgXygiY291bGQgbm90IHJlYWQgcmVmICclcyciKSwKCQkJCQkgICAgcHNldWRvcmVmKTsKCQkJCXJvbGxiYWNrX2xvY2tfZmlsZSgmbG9jayk7CgkJCQlnb3RvIGRvbmU7CgkJCX0KCQl9IGVsc2UgaWYgKGlzX251bGxfb2lkKG9sZF9vaWQpKSB7CgkJCXN0cmJ1Zl9hZGRmKGVyciwgXygicmVmICclcycgYWxyZWFkeSBleGlzdHMiKSwKCQkJCSAgICBwc2V1ZG9yZWYpOwoJCQlyb2xsYmFja19sb2NrX2ZpbGUoJmxvY2spOwoJCQlnb3RvIGRvbmU7CgkJfSBlbHNlIGlmICghb2lkZXEoJmFjdHVhbF9vbGRfb2lkLCBvbGRfb2lkKSkgewoJCQlzdHJidWZfYWRkZihlcnIsIF8oInVuZXhwZWN0ZWQgb2JqZWN0IElEIHdoZW4gd3JpdGluZyAnJXMnIiksCgkJCQkgICAgcHNldWRvcmVmKTsKCQkJcm9sbGJhY2tfbG9ja19maWxlKCZsb2NrKTsKCQkJZ290byBkb25lOwoJCX0KCX0KCglpZiAod3JpdGVfaW5fZnVsbChmZCwgYnVmLmJ1ZiwgYnVmLmxlbikgPCAwKSB7CgkJc3RyYnVmX2FkZGYoZXJyLCBfKCJjb3VsZCBub3Qgd3JpdGUgdG8gJyVzJyIpLCBmaWxlbmFtZSk7CgkJcm9sbGJhY2tfbG9ja19maWxlKCZsb2NrKTsKCQlnb3RvIGRvbmU7Cgl9CgoJY29tbWl0X2xvY2tfZmlsZSgmbG9jayk7CglyZXQgPSAwOwpkb25lOgoJc3RyYnVmX3JlbGVhc2UoJmJ1Zik7CglyZXR1cm4gcmV0Owp9CgpzdGF0aWMgaW50IGRlbGV0ZV9wc2V1ZG9yZWYoY29uc3QgY2hhciAqcHNldWRvcmVmLCBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvbGRfb2lkKQp7Cgljb25zdCBjaGFyICpmaWxlbmFtZTsKCglmaWxlbmFtZSA9IGdpdF9wYXRoKCIlcyIsIHBzZXVkb3JlZik7CgoJaWYgKG9sZF9vaWQgJiYgIWlzX251bGxfb2lkKG9sZF9vaWQpKSB7CgkJc3RydWN0IGxvY2tfZmlsZSBsb2NrID0gTE9DS19JTklUOwoJCWludCBmZDsKCQlzdHJ1Y3Qgb2JqZWN0X2lkIGFjdHVhbF9vbGRfb2lkOwoKCQlmZCA9IGhvbGRfbG9ja19maWxlX2Zvcl91cGRhdGVfdGltZW91dCgKCQkJCSZsb2NrLCBmaWxlbmFtZSwgMCwKCQkJCWdldF9maWxlc19yZWZfbG9ja190aW1lb3V0X21zKCkpOwoJCWlmIChmZCA8IDApIHsKCQkJZXJyb3JfZXJybm8oXygiY291bGQgbm90IG9wZW4gJyVzJyBmb3Igd3JpdGluZyIpLAoJCQkJICAgIGZpbGVuYW1lKTsKCQkJcmV0dXJuIC0xOwoJCX0KCQlpZiAocmVhZF9yZWYocHNldWRvcmVmLCAmYWN0dWFsX29sZF9vaWQpKQoJCQlkaWUoXygiY291bGQgbm90IHJlYWQgcmVmICclcyciKSwgcHNldWRvcmVmKTsKCQlpZiAoIW9pZGVxKCZhY3R1YWxfb2xkX29pZCwgb2xkX29pZCkpIHsKCQkJZXJyb3IoXygidW5leHBlY3RlZCBvYmplY3QgSUQgd2hlbiBkZWxldGluZyAnJXMnIiksCgkJCSAgICAgIHBzZXVkb3JlZik7CgkJCXJvbGxiYWNrX2xvY2tfZmlsZSgmbG9jayk7CgkJCXJldHVybiAtMTsKCQl9CgoJCXVubGluayhmaWxlbmFtZSk7CgkJcm9sbGJhY2tfbG9ja19maWxlKCZsb2NrKTsKCX0gZWxzZSB7CgkJdW5saW5rKGZpbGVuYW1lKTsKCX0KCglyZXR1cm4gMDsKfQoKaW50IHJlZnNfZGVsZXRlX3JlZihzdHJ1Y3QgcmVmX3N0b3JlICpyZWZzLCBjb25zdCBjaGFyICptc2csCgkJICAgIGNvbnN0IGNoYXIgKnJlZm5hbWUsCgkJICAgIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9sZF9vaWQsCgkJICAgIHVuc2lnbmVkIGludCBmbGFncykKewoJc3RydWN0IHJlZl90cmFuc2FjdGlvbiAqdHJhbnNhY3Rpb247CglzdHJ1Y3Qgc3RyYnVmIGVyciA9IFNUUkJVRl9JTklUOwoKCWlmIChyZWZfdHlwZShyZWZuYW1lKSA9PSBSRUZfVFlQRV9QU0VVRE9SRUYpIHsKCQlhc3NlcnQocmVmcyA9PSBnZXRfbWFpbl9yZWZfc3RvcmUodGhlX3JlcG9zaXRvcnkpKTsKCQlyZXR1cm4gZGVsZXRlX3BzZXVkb3JlZihyZWZuYW1lLCBvbGRfb2lkKTsKCX0KCgl0cmFuc2FjdGlvbiA9IHJlZl9zdG9yZV90cmFuc2FjdGlvbl9iZWdpbihyZWZzLCAmZXJyKTsKCWlmICghdHJhbnNhY3Rpb24gfHwKCSAgICByZWZfdHJhbnNhY3Rpb25fZGVsZXRlKHRyYW5zYWN0aW9uLCByZWZuYW1lLCBvbGRfb2lkLAoJCQkJICAgZmxhZ3MsIG1zZywgJmVycikgfHwKCSAgICByZWZfdHJhbnNhY3Rpb25fY29tbWl0KHRyYW5zYWN0aW9uLCAmZXJyKSkgewoJCWVycm9yKCIlcyIsIGVyci5idWYpOwoJCXJlZl90cmFuc2FjdGlvbl9mcmVlKHRyYW5zYWN0aW9uKTsKCQlzdHJidWZfcmVsZWFzZSgmZXJyKTsKCQlyZXR1cm4gMTsKCX0KCXJlZl90cmFuc2FjdGlvbl9mcmVlKHRyYW5zYWN0aW9uKTsKCXN0cmJ1Zl9yZWxlYXNlKCZlcnIpOwoJcmV0dXJuIDA7Cn0KCmludCBkZWxldGVfcmVmKGNvbnN0IGNoYXIgKm1zZywgY29uc3QgY2hhciAqcmVmbmFtZSwKCSAgICAgICBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvbGRfb2lkLCB1bnNpZ25lZCBpbnQgZmxhZ3MpCnsKCXJldHVybiByZWZzX2RlbGV0ZV9yZWYoZ2V0X21haW5fcmVmX3N0b3JlKHRoZV9yZXBvc2l0b3J5KSwgbXNnLCByZWZuYW1lLAoJCQkgICAgICAgb2xkX29pZCwgZmxhZ3MpOwp9Cgp2b2lkIGNvcHlfcmVmbG9nX21zZyhzdHJ1Y3Qgc3RyYnVmICpzYiwgY29uc3QgY2hhciAqbXNnKQp7CgljaGFyIGM7CglpbnQgd2Fzc3BhY2UgPSAxOwoKCXN0cmJ1Zl9hZGRjaChzYiwgJ1x0Jyk7Cgl3aGlsZSAoKGMgPSAqbXNnKyspKSB7CgkJaWYgKHdhc3NwYWNlICYmIGlzc3BhY2UoYykpCgkJCWNvbnRpbnVlOwoJCXdhc3NwYWNlID0gaXNzcGFjZShjKTsKCQlpZiAod2Fzc3BhY2UpCgkJCWMgPSAnICc7CgkJc3RyYnVmX2FkZGNoKHNiLCBjKTsKCX0KCXN0cmJ1Zl9ydHJpbShzYik7Cn0KCmludCBzaG91bGRfYXV0b2NyZWF0ZV9yZWZsb2coY29uc3QgY2hhciAqcmVmbmFtZSkKewoJc3dpdGNoIChsb2dfYWxsX3JlZl91cGRhdGVzKSB7CgljYXNlIExPR19SRUZTX0FMV0FZUzoKCQlyZXR1cm4gMTsKCWNhc2UgTE9HX1JFRlNfTk9STUFMOgoJCXJldHVybiBzdGFydHNfd2l0aChyZWZuYW1lLCAicmVmcy9oZWFkcy8iKSB8fAoJCQlzdGFydHNfd2l0aChyZWZuYW1lLCAicmVmcy9yZW1vdGVzLyIpIHx8CgkJCXN0YXJ0c193aXRoKHJlZm5hbWUsICJyZWZzL25vdGVzLyIpIHx8CgkJCSFzdHJjbXAocmVmbmFtZSwgIkhFQUQiKTsKCWRlZmF1bHQ6CgkJcmV0dXJuIDA7Cgl9Cn0KCmludCBpc19icmFuY2goY29uc3QgY2hhciAqcmVmbmFtZSkKewoJcmV0dXJuICFzdHJjbXAocmVmbmFtZSwgIkhFQUQiKSB8fCBzdGFydHNfd2l0aChyZWZuYW1lLCAicmVmcy9oZWFkcy8iKTsKfQoKc3RydWN0IHJlYWRfcmVmX2F0X2NiIHsKCWNvbnN0IGNoYXIgKnJlZm5hbWU7Cgl0aW1lc3RhbXBfdCBhdF90aW1lOwoJaW50IGNudDsKCWludCByZWNjbnQ7CglzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQ7CglpbnQgZm91bmRfaXQ7CgoJc3RydWN0IG9iamVjdF9pZCBvb2lkOwoJc3RydWN0IG9iamVjdF9pZCBub2lkOwoJaW50IHR6OwoJdGltZXN0YW1wX3QgZGF0ZTsKCWNoYXIgKiptc2c7Cgl0aW1lc3RhbXBfdCAqY3V0b2ZmX3RpbWU7CglpbnQgKmN1dG9mZl90ejsKCWludCAqY3V0b2ZmX2NudDsKfTsKCnN0YXRpYyBpbnQgcmVhZF9yZWZfYXRfZW50KHN0cnVjdCBvYmplY3RfaWQgKm9vaWQsIHN0cnVjdCBvYmplY3RfaWQgKm5vaWQsCgkJY29uc3QgY2hhciAqZW1haWwsIHRpbWVzdGFtcF90IHRpbWVzdGFtcCwgaW50IHR6LAoJCWNvbnN0IGNoYXIgKm1lc3NhZ2UsIHZvaWQgKmNiX2RhdGEpCnsKCXN0cnVjdCByZWFkX3JlZl9hdF9jYiAqY2IgPSBjYl9kYXRhOwoKCWNiLT5yZWNjbnQrKzsKCWNiLT50eiA9IHR6OwoJY2ItPmRhdGUgPSB0aW1lc3RhbXA7CgoJaWYgKHRpbWVzdGFtcCA8PSBjYi0+YXRfdGltZSB8fCBjYi0+Y250ID09IDApIHsKCQlpZiAoY2ItPm1zZykKCQkJKmNiLT5tc2cgPSB4c3RyZHVwKG1lc3NhZ2UpOwoJCWlmIChjYi0+Y3V0b2ZmX3RpbWUpCgkJCSpjYi0+Y3V0b2ZmX3RpbWUgPSB0aW1lc3RhbXA7CgkJaWYgKGNiLT5jdXRvZmZfdHopCgkJCSpjYi0+Y3V0b2ZmX3R6ID0gdHo7CgkJaWYgKGNiLT5jdXRvZmZfY250KQoJCQkqY2ItPmN1dG9mZl9jbnQgPSBjYi0+cmVjY250IC0gMTsKCQkvKgoJCSAqIHdlIGhhdmUgbm90IHlldCB1cGRhdGVkIGNiLT5bbnxvXW9pZCBzbyB0aGV5IHN0aWxsCgkJICogaG9sZCB0aGUgdmFsdWVzIGZvciB0aGUgcHJldmlvdXMgcmVjb3JkLgoJCSAqLwoJCWlmICghaXNfbnVsbF9vaWQoJmNiLT5vb2lkKSkgewoJCQlvaWRjcHkoY2ItPm9pZCwgbm9pZCk7CgkJCWlmICghb2lkZXEoJmNiLT5vb2lkLCBub2lkKSkKCQkJCXdhcm5pbmcoXygibG9nIGZvciByZWYgJXMgaGFzIGdhcCBhZnRlciAlcyIpLAoJCQkJCWNiLT5yZWZuYW1lLCBzaG93X2RhdGUoY2ItPmRhdGUsIGNiLT50eiwgREFURV9NT0RFKFJGQzI4MjIpKSk7CgkJfQoJCWVsc2UgaWYgKGNiLT5kYXRlID09IGNiLT5hdF90aW1lKQoJCQlvaWRjcHkoY2ItPm9pZCwgbm9pZCk7CgkJZWxzZSBpZiAoIW9pZGVxKG5vaWQsIGNiLT5vaWQpKQoJCQl3YXJuaW5nKF8oImxvZyBmb3IgcmVmICVzIHVuZXhwZWN0ZWRseSBlbmRlZCBvbiAlcyIpLAoJCQkJY2ItPnJlZm5hbWUsIHNob3dfZGF0ZShjYi0+ZGF0ZSwgY2ItPnR6LAoJCQkJCQkgICAgICAgREFURV9NT0RFKFJGQzI4MjIpKSk7CgkJb2lkY3B5KCZjYi0+b29pZCwgb29pZCk7CgkJb2lkY3B5KCZjYi0+bm9pZCwgbm9pZCk7CgkJY2ItPmZvdW5kX2l0ID0gMTsKCQlyZXR1cm4gMTsKCX0KCW9pZGNweSgmY2ItPm9vaWQsIG9vaWQpOwoJb2lkY3B5KCZjYi0+bm9pZCwgbm9pZCk7CglpZiAoY2ItPmNudCA+IDApCgkJY2ItPmNudC0tOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgcmVhZF9yZWZfYXRfZW50X29sZGVzdChzdHJ1Y3Qgb2JqZWN0X2lkICpvb2lkLCBzdHJ1Y3Qgb2JqZWN0X2lkICpub2lkLAoJCQkJICBjb25zdCBjaGFyICplbWFpbCwgdGltZXN0YW1wX3QgdGltZXN0YW1wLAoJCQkJICBpbnQgdHosIGNvbnN0IGNoYXIgKm1lc3NhZ2UsIHZvaWQgKmNiX2RhdGEpCnsKCXN0cnVjdCByZWFkX3JlZl9hdF9jYiAqY2IgPSBjYl9kYXRhOwoKCWlmIChjYi0+bXNnKQoJCSpjYi0+bXNnID0geHN0cmR1cChtZXNzYWdlKTsKCWlmIChjYi0+Y3V0b2ZmX3RpbWUpCgkJKmNiLT5jdXRvZmZfdGltZSA9IHRpbWVzdGFtcDsKCWlmIChjYi0+Y3V0b2ZmX3R6KQoJCSpjYi0+Y3V0b2ZmX3R6ID0gdHo7CglpZiAoY2ItPmN1dG9mZl9jbnQpCgkJKmNiLT5jdXRvZmZfY250ID0gY2ItPnJlY2NudDsKCW9pZGNweShjYi0+b2lkLCBvb2lkKTsKCWlmIChpc19udWxsX29pZChjYi0+b2lkKSkKCQlvaWRjcHkoY2ItPm9pZCwgbm9pZCk7CgkvKiBXZSBqdXN0IHdhbnQgdGhlIGZpcnN0IGVudHJ5ICovCglyZXR1cm4gMTsKfQoKaW50IHJlYWRfcmVmX2F0KHN0cnVjdCByZWZfc3RvcmUgKnJlZnMsIGNvbnN0IGNoYXIgKnJlZm5hbWUsCgkJdW5zaWduZWQgaW50IGZsYWdzLCB0aW1lc3RhbXBfdCBhdF90aW1lLCBpbnQgY250LAoJCXN0cnVjdCBvYmplY3RfaWQgKm9pZCwgY2hhciAqKm1zZywKCQl0aW1lc3RhbXBfdCAqY3V0b2ZmX3RpbWUsIGludCAqY3V0b2ZmX3R6LCBpbnQgKmN1dG9mZl9jbnQpCnsKCXN0cnVjdCByZWFkX3JlZl9hdF9jYiBjYjsKCgltZW1zZXQoJmNiLCAwLCBzaXplb2YoY2IpKTsKCWNiLnJlZm5hbWUgPSByZWZuYW1lOwoJY2IuYXRfdGltZSA9IGF0X3RpbWU7CgljYi5jbnQgPSBjbnQ7CgljYi5tc2cgPSBtc2c7CgljYi5jdXRvZmZfdGltZSA9IGN1dG9mZl90aW1lOwoJY2IuY3V0b2ZmX3R6ID0gY3V0b2ZmX3R6OwoJY2IuY3V0b2ZmX2NudCA9IGN1dG9mZl9jbnQ7CgljYi5vaWQgPSBvaWQ7CgoJcmVmc19mb3JfZWFjaF9yZWZsb2dfZW50X3JldmVyc2UocmVmcywgcmVmbmFtZSwgcmVhZF9yZWZfYXRfZW50LCAmY2IpOwoKCWlmICghY2IucmVjY250KSB7CgkJaWYgKGZsYWdzICYgR0VUX09JRF9RVUlFVExZKQoJCQlleGl0KDEyOCk7CgkJZWxzZQoJCQlkaWUoXygibG9nIGZvciAlcyBpcyBlbXB0eSIpLCByZWZuYW1lKTsKCX0KCWlmIChjYi5mb3VuZF9pdCkKCQlyZXR1cm4gMDsKCglyZWZzX2Zvcl9lYWNoX3JlZmxvZ19lbnQocmVmcywgcmVmbmFtZSwgcmVhZF9yZWZfYXRfZW50X29sZGVzdCwgJmNiKTsKCglyZXR1cm4gMTsKfQoKc3RydWN0IHJlZl90cmFuc2FjdGlvbiAqcmVmX3N0b3JlX3RyYW5zYWN0aW9uX2JlZ2luKHN0cnVjdCByZWZfc3RvcmUgKnJlZnMsCgkJCQkJCSAgICBzdHJ1Y3Qgc3RyYnVmICplcnIpCnsKCXN0cnVjdCByZWZfdHJhbnNhY3Rpb24gKnRyOwoJYXNzZXJ0KGVycik7CgoJdHIgPSB4Y2FsbG9jKDEsIHNpemVvZihzdHJ1Y3QgcmVmX3RyYW5zYWN0aW9uKSk7Cgl0ci0+cmVmX3N0b3JlID0gcmVmczsKCXJldHVybiB0cjsKfQoKc3RydWN0IHJlZl90cmFuc2FjdGlvbiAqcmVmX3RyYW5zYWN0aW9uX2JlZ2luKHN0cnVjdCBzdHJidWYgKmVycikKewoJcmV0dXJuIHJlZl9zdG9yZV90cmFuc2FjdGlvbl9iZWdpbihnZXRfbWFpbl9yZWZfc3RvcmUodGhlX3JlcG9zaXRvcnkpLCBlcnIpOwp9Cgp2b2lkIHJlZl90cmFuc2FjdGlvbl9mcmVlKHN0cnVjdCByZWZfdHJhbnNhY3Rpb24gKnRyYW5zYWN0aW9uKQp7CglzaXplX3QgaTsKCglpZiAoIXRyYW5zYWN0aW9uKQoJCXJldHVybjsKCglzd2l0Y2ggKHRyYW5zYWN0aW9uLT5zdGF0ZSkgewoJY2FzZSBSRUZfVFJBTlNBQ1RJT05fT1BFTjoKCWNhc2UgUkVGX1RSQU5TQUNUSU9OX0NMT1NFRDoKCQkvKiBPSyAqLwoJCWJyZWFrOwoJY2FzZSBSRUZfVFJBTlNBQ1RJT05fUFJFUEFSRUQ6CgkJQlVHKCJmcmVlIGNhbGxlZCBvbiBhIHByZXBhcmVkIHJlZmVyZW5jZSB0cmFuc2FjdGlvbiIpOwoJCWJyZWFrOwoJZGVmYXVsdDoKCQlCVUcoInVuZXhwZWN0ZWQgcmVmZXJlbmNlIHRyYW5zYWN0aW9uIHN0YXRlIik7CgkJYnJlYWs7Cgl9CgoJZm9yIChpID0gMDsgaSA8IHRyYW5zYWN0aW9uLT5ucjsgaSsrKSB7CgkJZnJlZSh0cmFuc2FjdGlvbi0+dXBkYXRlc1tpXS0+bXNnKTsKCQlmcmVlKHRyYW5zYWN0aW9uLT51cGRhdGVzW2ldKTsKCX0KCWZyZWUodHJhbnNhY3Rpb24tPnVwZGF0ZXMpOwoJZnJlZSh0cmFuc2FjdGlvbik7Cn0KCnN0cnVjdCByZWZfdXBkYXRlICpyZWZfdHJhbnNhY3Rpb25fYWRkX3VwZGF0ZSgKCQlzdHJ1Y3QgcmVmX3RyYW5zYWN0aW9uICp0cmFuc2FjdGlvbiwKCQljb25zdCBjaGFyICpyZWZuYW1lLCB1bnNpZ25lZCBpbnQgZmxhZ3MsCgkJY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqbmV3X29pZCwKCQljb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvbGRfb2lkLAoJCWNvbnN0IGNoYXIgKm1zZykKewoJc3RydWN0IHJlZl91cGRhdGUgKnVwZGF0ZTsKCglpZiAodHJhbnNhY3Rpb24tPnN0YXRlICE9IFJFRl9UUkFOU0FDVElPTl9PUEVOKQoJCUJVRygidXBkYXRlIGNhbGxlZCBmb3IgdHJhbnNhY3Rpb24gdGhhdCBpcyBub3Qgb3BlbiIpOwoKCUZMRVhfQUxMT0NfU1RSKHVwZGF0ZSwgcmVmbmFtZSwgcmVmbmFtZSk7CglBTExPQ19HUk9XKHRyYW5zYWN0aW9uLT51cGRhdGVzLCB0cmFuc2FjdGlvbi0+bnIgKyAxLCB0cmFuc2FjdGlvbi0+YWxsb2MpOwoJdHJhbnNhY3Rpb24tPnVwZGF0ZXNbdHJhbnNhY3Rpb24tPm5yKytdID0gdXBkYXRlOwoKCXVwZGF0ZS0+ZmxhZ3MgPSBmbGFnczsKCglpZiAoZmxhZ3MgJiBSRUZfSEFWRV9ORVcpCgkJb2lkY3B5KCZ1cGRhdGUtPm5ld19vaWQsIG5ld19vaWQpOwoJaWYgKGZsYWdzICYgUkVGX0hBVkVfT0xEKQoJCW9pZGNweSgmdXBkYXRlLT5vbGRfb2lkLCBvbGRfb2lkKTsKCXVwZGF0ZS0+bXNnID0geHN0cmR1cF9vcl9udWxsKG1zZyk7CglyZXR1cm4gdXBkYXRlOwp9CgppbnQgcmVmX3RyYW5zYWN0aW9uX3VwZGF0ZShzdHJ1Y3QgcmVmX3RyYW5zYWN0aW9uICp0cmFuc2FjdGlvbiwKCQkJICAgY29uc3QgY2hhciAqcmVmbmFtZSwKCQkJICAgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqbmV3X29pZCwKCQkJICAgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2xkX29pZCwKCQkJICAgdW5zaWduZWQgaW50IGZsYWdzLCBjb25zdCBjaGFyICptc2csCgkJCSAgIHN0cnVjdCBzdHJidWYgKmVycikKewoJYXNzZXJ0KGVycik7CgoJaWYgKChuZXdfb2lkICYmICFpc19udWxsX29pZChuZXdfb2lkKSkgPwoJICAgIGNoZWNrX3JlZm5hbWVfZm9ybWF0KHJlZm5hbWUsIFJFRk5BTUVfQUxMT1dfT05FTEVWRUwpIDoKCSAgICAhcmVmbmFtZV9pc19zYWZlKHJlZm5hbWUpKSB7CgkJc3RyYnVmX2FkZGYoZXJyLCBfKCJyZWZ1c2luZyB0byB1cGRhdGUgcmVmIHdpdGggYmFkIG5hbWUgJyVzJyIpLAoJCQkgICAgcmVmbmFtZSk7CgkJcmV0dXJuIC0xOwoJfQoKCWlmIChmbGFncyAmIH5SRUZfVFJBTlNBQ1RJT05fVVBEQVRFX0FMTE9XRURfRkxBR1MpCgkJQlVHKCJpbGxlZ2FsIGZsYWdzIDB4JXggcGFzc2VkIHRvIHJlZl90cmFuc2FjdGlvbl91cGRhdGUoKSIsIGZsYWdzKTsKCglmbGFncyB8PSAobmV3X29pZCA/IFJFRl9IQVZFX05FVyA6IDApIHwgKG9sZF9vaWQgPyBSRUZfSEFWRV9PTEQgOiAwKTsKCglyZWZfdHJhbnNhY3Rpb25fYWRkX3VwZGF0ZSh0cmFuc2FjdGlvbiwgcmVmbmFtZSwgZmxhZ3MsCgkJCQkgICBuZXdfb2lkLCBvbGRfb2lkLCBtc2cpOwoJcmV0dXJuIDA7Cn0KCmludCByZWZfdHJhbnNhY3Rpb25fY3JlYXRlKHN0cnVjdCByZWZfdHJhbnNhY3Rpb24gKnRyYW5zYWN0aW9uLAoJCQkgICBjb25zdCBjaGFyICpyZWZuYW1lLAoJCQkgICBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpuZXdfb2lkLAoJCQkgICB1bnNpZ25lZCBpbnQgZmxhZ3MsIGNvbnN0IGNoYXIgKm1zZywKCQkJICAgc3RydWN0IHN0cmJ1ZiAqZXJyKQp7CglpZiAoIW5ld19vaWQgfHwgaXNfbnVsbF9vaWQobmV3X29pZCkpCgkJQlVHKCJjcmVhdGUgY2FsbGVkIHdpdGhvdXQgdmFsaWQgbmV3X29pZCIpOwoJcmV0dXJuIHJlZl90cmFuc2FjdGlvbl91cGRhdGUodHJhbnNhY3Rpb24sIHJlZm5hbWUsIG5ld19vaWQsCgkJCQkgICAgICAmbnVsbF9vaWQsIGZsYWdzLCBtc2csIGVycik7Cn0KCmludCByZWZfdHJhbnNhY3Rpb25fZGVsZXRlKHN0cnVjdCByZWZfdHJhbnNhY3Rpb24gKnRyYW5zYWN0aW9uLAoJCQkgICBjb25zdCBjaGFyICpyZWZuYW1lLAoJCQkgICBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvbGRfb2lkLAoJCQkgICB1bnNpZ25lZCBpbnQgZmxhZ3MsIGNvbnN0IGNoYXIgKm1zZywKCQkJICAgc3RydWN0IHN0cmJ1ZiAqZXJyKQp7CglpZiAob2xkX29pZCAmJiBpc19udWxsX29pZChvbGRfb2lkKSkKCQlCVUcoImRlbGV0ZSBjYWxsZWQgd2l0aCBvbGRfb2lkIHNldCB0byB6ZXJvcyIpOwoJcmV0dXJuIHJlZl90cmFuc2FjdGlvbl91cGRhdGUodHJhbnNhY3Rpb24sIHJlZm5hbWUsCgkJCQkgICAgICAmbnVsbF9vaWQsIG9sZF9vaWQsCgkJCQkgICAgICBmbGFncywgbXNnLCBlcnIpOwp9CgppbnQgcmVmX3RyYW5zYWN0aW9uX3ZlcmlmeShzdHJ1Y3QgcmVmX3RyYW5zYWN0aW9uICp0cmFuc2FjdGlvbiwKCQkJICAgY29uc3QgY2hhciAqcmVmbmFtZSwKCQkJICAgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2xkX29pZCwKCQkJICAgdW5zaWduZWQgaW50IGZsYWdzLAoJCQkgICBzdHJ1Y3Qgc3RyYnVmICplcnIpCnsKCWlmICghb2xkX29pZCkKCQlCVUcoInZlcmlmeSBjYWxsZWQgd2l0aCBvbGRfb2lkIHNldCB0byBOVUxMIik7CglyZXR1cm4gcmVmX3RyYW5zYWN0aW9uX3VwZGF0ZSh0cmFuc2FjdGlvbiwgcmVmbmFtZSwKCQkJCSAgICAgIE5VTEwsIG9sZF9vaWQsCgkJCQkgICAgICBmbGFncywgTlVMTCwgZXJyKTsKfQoKaW50IHJlZnNfdXBkYXRlX3JlZihzdHJ1Y3QgcmVmX3N0b3JlICpyZWZzLCBjb25zdCBjaGFyICptc2csCgkJICAgIGNvbnN0IGNoYXIgKnJlZm5hbWUsIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm5ld19vaWQsCgkJICAgIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9sZF9vaWQsIHVuc2lnbmVkIGludCBmbGFncywKCQkgICAgZW51bSBhY3Rpb25fb25fZXJyIG9uZXJyKQp7CglzdHJ1Y3QgcmVmX3RyYW5zYWN0aW9uICp0ID0gTlVMTDsKCXN0cnVjdCBzdHJidWYgZXJyID0gU1RSQlVGX0lOSVQ7CglpbnQgcmV0ID0gMDsKCglpZiAocmVmX3R5cGUocmVmbmFtZSkgPT0gUkVGX1RZUEVfUFNFVURPUkVGKSB7CgkJYXNzZXJ0KHJlZnMgPT0gZ2V0X21haW5fcmVmX3N0b3JlKHRoZV9yZXBvc2l0b3J5KSk7CgkJcmV0ID0gd3JpdGVfcHNldWRvcmVmKHJlZm5hbWUsIG5ld19vaWQsIG9sZF9vaWQsICZlcnIpOwoJfSBlbHNlIHsKCQl0ID0gcmVmX3N0b3JlX3RyYW5zYWN0aW9uX2JlZ2luKHJlZnMsICZlcnIpOwoJCWlmICghdCB8fAoJCSAgICByZWZfdHJhbnNhY3Rpb25fdXBkYXRlKHQsIHJlZm5hbWUsIG5ld19vaWQsIG9sZF9vaWQsCgkJCQkJICAgZmxhZ3MsIG1zZywgJmVycikgfHwKCQkgICAgcmVmX3RyYW5zYWN0aW9uX2NvbW1pdCh0LCAmZXJyKSkgewoJCQlyZXQgPSAxOwoJCQlyZWZfdHJhbnNhY3Rpb25fZnJlZSh0KTsKCQl9Cgl9CglpZiAocmV0KSB7CgkJY29uc3QgY2hhciAqc3RyID0gXygidXBkYXRlX3JlZiBmYWlsZWQgZm9yIHJlZiAnJXMnOiAlcyIpOwoKCQlzd2l0Y2ggKG9uZXJyKSB7CgkJY2FzZSBVUERBVEVfUkVGU19NU0dfT05fRVJSOgoJCQllcnJvcihzdHIsIHJlZm5hbWUsIGVyci5idWYpOwoJCQlicmVhazsKCQljYXNlIFVQREFURV9SRUZTX0RJRV9PTl9FUlI6CgkJCWRpZShzdHIsIHJlZm5hbWUsIGVyci5idWYpOwoJCQlicmVhazsKCQljYXNlIFVQREFURV9SRUZTX1FVSUVUX09OX0VSUjoKCQkJYnJlYWs7CgkJfQoJCXN0cmJ1Zl9yZWxlYXNlKCZlcnIpOwoJCXJldHVybiAxOwoJfQoJc3RyYnVmX3JlbGVhc2UoJmVycik7CglpZiAodCkKCQlyZWZfdHJhbnNhY3Rpb25fZnJlZSh0KTsKCXJldHVybiAwOwp9CgppbnQgdXBkYXRlX3JlZihjb25zdCBjaGFyICptc2csIGNvbnN0IGNoYXIgKnJlZm5hbWUsCgkgICAgICAgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqbmV3X29pZCwKCSAgICAgICBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvbGRfb2lkLAoJICAgICAgIHVuc2lnbmVkIGludCBmbGFncywgZW51bSBhY3Rpb25fb25fZXJyIG9uZXJyKQp7CglyZXR1cm4gcmVmc191cGRhdGVfcmVmKGdldF9tYWluX3JlZl9zdG9yZSh0aGVfcmVwb3NpdG9yeSksIG1zZywgcmVmbmFtZSwgbmV3X29pZCwKCQkJICAgICAgIG9sZF9vaWQsIGZsYWdzLCBvbmVycik7Cn0KCmNoYXIgKnJlZnNfc2hvcnRlbl91bmFtYmlndW91c19yZWYoc3RydWN0IHJlZl9zdG9yZSAqcmVmcywKCQkJCSAgIGNvbnN0IGNoYXIgKnJlZm5hbWUsIGludCBzdHJpY3QpCnsKCWludCBpOwoJc3RhdGljIGNoYXIgKipzY2FuZl9mbXRzOwoJc3RhdGljIGludCBucl9ydWxlczsKCWNoYXIgKnNob3J0X25hbWU7CglzdHJ1Y3Qgc3RyYnVmIHJlc29sdmVkX2J1ZiA9IFNUUkJVRl9JTklUOwoKCWlmICghbnJfcnVsZXMpIHsKCQkvKgoJCSAqIFByZS1nZW5lcmF0ZSBzY2FuZiBmb3JtYXRzIGZyb20gcmVmX3Jldl9wYXJzZV9ydWxlc1tdLgoJCSAqIEdlbmVyYXRlIGEgZm9ybWF0IHN1aXRhYmxlIGZvciBzY2FuZiBmcm9tIGEKCQkgKiByZWZfcmV2X3BhcnNlX3J1bGVzIHJ1bGUgYnkgaW50ZXJwb2xhdGluZyAiJXMiIGF0IHRoZQoJCSAqIGxvY2F0aW9uIG9mIHRoZSAiJS4qcyIuCgkJICovCgkJc2l6ZV90IHRvdGFsX2xlbiA9IDA7CgkJc2l6ZV90IG9mZnNldCA9IDA7CgoJCS8qIHRoZSBydWxlIGxpc3QgaXMgTlVMTCB0ZXJtaW5hdGVkLCBjb3VudCB0aGVtIGZpcnN0ICovCgkJZm9yIChucl9ydWxlcyA9IDA7IHJlZl9yZXZfcGFyc2VfcnVsZXNbbnJfcnVsZXNdOyBucl9ydWxlcysrKQoJCQkvKiAtMiBmb3Igc3RybGVuKCIlLipzIikgLSBzdHJsZW4oIiVzIik7ICsxIGZvciBOVUwgKi8KCQkJdG90YWxfbGVuICs9IHN0cmxlbihyZWZfcmV2X3BhcnNlX3J1bGVzW25yX3J1bGVzXSkgLSAyICsgMTsKCgkJc2NhbmZfZm10cyA9IHhtYWxsb2Moc3RfYWRkKHN0X211bHQoc2l6ZW9mKGNoYXIgKiksIG5yX3J1bGVzKSwgdG90YWxfbGVuKSk7CgoJCW9mZnNldCA9IDA7CgkJZm9yIChpID0gMDsgaSA8IG5yX3J1bGVzOyBpKyspIHsKCQkJYXNzZXJ0KG9mZnNldCA8IHRvdGFsX2xlbik7CgkJCXNjYW5mX2ZtdHNbaV0gPSAoY2hhciAqKSZzY2FuZl9mbXRzW25yX3J1bGVzXSArIG9mZnNldDsKCQkJb2Zmc2V0ICs9IHhzbnByaW50ZihzY2FuZl9mbXRzW2ldLCB0b3RhbF9sZW4gLSBvZmZzZXQsCgkJCQkJICAgIHJlZl9yZXZfcGFyc2VfcnVsZXNbaV0sIDIsICIlcyIpICsgMTsKCQl9Cgl9CgoJLyogYmFpbCBvdXQgaWYgdGhlcmUgYXJlIG5vIHJ1bGVzICovCglpZiAoIW5yX3J1bGVzKQoJCXJldHVybiB4c3RyZHVwKHJlZm5hbWUpOwoKCS8qIGJ1ZmZlciBmb3Igc2NhbmYgcmVzdWx0LCBhdCBtb3N0IHJlZm5hbWUgbXVzdCBmaXQgKi8KCXNob3J0X25hbWUgPSB4c3RyZHVwKHJlZm5hbWUpOwoKCS8qIHNraXAgZmlyc3QgcnVsZSwgaXQgd2lsbCBhbHdheXMgbWF0Y2ggKi8KCWZvciAoaSA9IG5yX3J1bGVzIC0gMTsgaSA+IDAgOyAtLWkpIHsKCQlpbnQgajsKCQlpbnQgcnVsZXNfdG9fZmFpbCA9IGk7CgkJaW50IHNob3J0X25hbWVfbGVuOwoKCQlpZiAoMSAhPSBzc2NhbmYocmVmbmFtZSwgc2NhbmZfZm10c1tpXSwgc2hvcnRfbmFtZSkpCgkJCWNvbnRpbnVlOwoKCQlzaG9ydF9uYW1lX2xlbiA9IHN0cmxlbihzaG9ydF9uYW1lKTsKCgkJLyoKCQkgKiBpbiBzdHJpY3QgbW9kZSwgYWxsIChleGNlcHQgdGhlIG1hdGNoZWQgb25lKSBydWxlcwoJCSAqIG11c3QgZmFpbCB0byByZXNvbHZlIHRvIGEgdmFsaWQgbm9uLWFtYmlndW91cyByZWYKCQkgKi8KCQlpZiAoc3RyaWN0KQoJCQlydWxlc190b19mYWlsID0gbnJfcnVsZXM7CgoJCS8qCgkJICogY2hlY2sgaWYgdGhlIHNob3J0IG5hbWUgcmVzb2x2ZXMgdG8gYSB2YWxpZCByZWYsCgkJICogYnV0IHVzZSBvbmx5IHJ1bGVzIHByaW9yIHRvIHRoZSBtYXRjaGVkIG9uZQoJCSAqLwoJCWZvciAoaiA9IDA7IGogPCBydWxlc190b19mYWlsOyBqKyspIHsKCQkJY29uc3QgY2hhciAqcnVsZSA9IHJlZl9yZXZfcGFyc2VfcnVsZXNbal07CgoJCQkvKiBza2lwIG1hdGNoZWQgcnVsZSAqLwoJCQlpZiAoaSA9PSBqKQoJCQkJY29udGludWU7CgoJCQkvKgoJCQkgKiB0aGUgc2hvcnQgbmFtZSBpcyBhbWJpZ3VvdXMsIGlmIGl0IHJlc29sdmVzCgkJCSAqICh3aXRoIHRoaXMgcHJldmlvdXMgcnVsZSkgdG8gYSB2YWxpZCByZWYKCQkJICogcmVhZF9yZWYoKSByZXR1cm5zIDAgb24gc3VjY2VzcwoJCQkgKi8KCQkJc3RyYnVmX3Jlc2V0KCZyZXNvbHZlZF9idWYpOwoJCQlzdHJidWZfYWRkZigmcmVzb2x2ZWRfYnVmLCBydWxlLAoJCQkJICAgIHNob3J0X25hbWVfbGVuLCBzaG9ydF9uYW1lKTsKCQkJaWYgKHJlZnNfcmVmX2V4aXN0cyhyZWZzLCByZXNvbHZlZF9idWYuYnVmKSkKCQkJCWJyZWFrOwoJCX0KCgkJLyoKCQkgKiBzaG9ydCBuYW1lIGlzIG5vbi1hbWJpZ3VvdXMgaWYgYWxsIHByZXZpb3VzIHJ1bGVzCgkJICogaGF2ZW4ndCByZXNvbHZlZCB0byBhIHZhbGlkIHJlZgoJCSAqLwoJCWlmIChqID09IHJ1bGVzX3RvX2ZhaWwpIHsKCQkJc3RyYnVmX3JlbGVhc2UoJnJlc29sdmVkX2J1Zik7CgkJCXJldHVybiBzaG9ydF9uYW1lOwoJCX0KCX0KCglzdHJidWZfcmVsZWFzZSgmcmVzb2x2ZWRfYnVmKTsKCWZyZWUoc2hvcnRfbmFtZSk7CglyZXR1cm4geHN0cmR1cChyZWZuYW1lKTsKfQoKY2hhciAqc2hvcnRlbl91bmFtYmlndW91c19yZWYoY29uc3QgY2hhciAqcmVmbmFtZSwgaW50IHN0cmljdCkKewoJcmV0dXJuIHJlZnNfc2hvcnRlbl91bmFtYmlndW91c19yZWYoZ2V0X21haW5fcmVmX3N0b3JlKHRoZV9yZXBvc2l0b3J5KSwKCQkJCQkgICAgcmVmbmFtZSwgc3RyaWN0KTsKfQoKc3RhdGljIHN0cnVjdCBzdHJpbmdfbGlzdCAqaGlkZV9yZWZzOwoKaW50IHBhcnNlX2hpZGVfcmVmc19jb25maWcoY29uc3QgY2hhciAqdmFyLCBjb25zdCBjaGFyICp2YWx1ZSwgY29uc3QgY2hhciAqc2VjdGlvbikKewoJY29uc3QgY2hhciAqa2V5OwoJaWYgKCFzdHJjbXAoInRyYW5zZmVyLmhpZGVyZWZzIiwgdmFyKSB8fAoJICAgICghcGFyc2VfY29uZmlnX2tleSh2YXIsIHNlY3Rpb24sIE5VTEwsIE5VTEwsICZrZXkpICYmCgkgICAgICFzdHJjbXAoa2V5LCAiaGlkZXJlZnMiKSkpIHsKCQljaGFyICpyZWY7CgkJaW50IGxlbjsKCgkJaWYgKCF2YWx1ZSkKCQkJcmV0dXJuIGNvbmZpZ19lcnJvcl9ub25ib29sKHZhcik7CgkJcmVmID0geHN0cmR1cCh2YWx1ZSk7CgkJbGVuID0gc3RybGVuKHJlZik7CgkJd2hpbGUgKGxlbiAmJiByZWZbbGVuIC0gMV0gPT0gJy8nKQoJCQlyZWZbLS1sZW5dID0gJ1wwJzsKCQlpZiAoIWhpZGVfcmVmcykgewoJCQloaWRlX3JlZnMgPSB4Y2FsbG9jKDEsIHNpemVvZigqaGlkZV9yZWZzKSk7CgkJCWhpZGVfcmVmcy0+c3RyZHVwX3N0cmluZ3MgPSAxOwoJCX0KCQlzdHJpbmdfbGlzdF9hcHBlbmQoaGlkZV9yZWZzLCByZWYpOwoJfQoJcmV0dXJuIDA7Cn0KCmludCByZWZfaXNfaGlkZGVuKGNvbnN0IGNoYXIgKnJlZm5hbWUsIGNvbnN0IGNoYXIgKnJlZm5hbWVfZnVsbCkKewoJaW50IGk7CgoJaWYgKCFoaWRlX3JlZnMpCgkJcmV0dXJuIDA7Cglmb3IgKGkgPSBoaWRlX3JlZnMtPm5yIC0gMTsgaSA+PSAwOyBpLS0pIHsKCQljb25zdCBjaGFyICptYXRjaCA9IGhpZGVfcmVmcy0+aXRlbXNbaV0uc3RyaW5nOwoJCWNvbnN0IGNoYXIgKnN1YmplY3Q7CgkJaW50IG5lZyA9IDA7CgkJY29uc3QgY2hhciAqcDsKCgkJaWYgKCptYXRjaCA9PSAnIScpIHsKCQkJbmVnID0gMTsKCQkJbWF0Y2grKzsKCQl9CgoJCWlmICgqbWF0Y2ggPT0gJ14nKSB7CgkJCXN1YmplY3QgPSByZWZuYW1lX2Z1bGw7CgkJCW1hdGNoKys7CgkJfSBlbHNlIHsKCQkJc3ViamVjdCA9IHJlZm5hbWU7CgkJfQoKCQkvKiByZWZuYW1lIGNhbiBiZSBOVUxMIHdoZW4gbmFtZXNwYWNlcyBhcmUgdXNlZC4gKi8KCQlpZiAoc3ViamVjdCAmJgoJCSAgICBza2lwX3ByZWZpeChzdWJqZWN0LCBtYXRjaCwgJnApICYmCgkJICAgICghKnAgfHwgKnAgPT0gJy8nKSkKCQkJcmV0dXJuICFuZWc7Cgl9CglyZXR1cm4gMDsKfQoKY29uc3QgY2hhciAqZmluZF9kZXNjZW5kYW50X3JlZihjb25zdCBjaGFyICpkaXJuYW1lLAoJCQkJY29uc3Qgc3RydWN0IHN0cmluZ19saXN0ICpleHRyYXMsCgkJCQljb25zdCBzdHJ1Y3Qgc3RyaW5nX2xpc3QgKnNraXApCnsKCWludCBwb3M7CgoJaWYgKCFleHRyYXMpCgkJcmV0dXJuIE5VTEw7CgoJLyoKCSAqIExvb2sgYXQgdGhlIHBsYWNlIHdoZXJlIGRpcm5hbWUgd291bGQgYmUgaW5zZXJ0ZWQgaW50bwoJICogZXh0cmFzLiBJZiB0aGVyZSBpcyBhbiBlbnRyeSBhdCB0aGF0IHBvc2l0aW9uIHRoYXQgc3RhcnRzCgkgKiB3aXRoIGRpcm5hbWUgKHJlbWVtYmVyLCBkaXJuYW1lIGluY2x1ZGVzIHRoZSB0cmFpbGluZwoJICogc2xhc2gpIGFuZCBpcyBub3QgaW4gc2tpcCwgdGhlbiB3ZSBoYXZlIGEgY29uZmxpY3QuCgkgKi8KCWZvciAocG9zID0gc3RyaW5nX2xpc3RfZmluZF9pbnNlcnRfaW5kZXgoZXh0cmFzLCBkaXJuYW1lLCAwKTsKCSAgICAgcG9zIDwgZXh0cmFzLT5ucjsgcG9zKyspIHsKCQljb25zdCBjaGFyICpleHRyYV9yZWZuYW1lID0gZXh0cmFzLT5pdGVtc1twb3NdLnN0cmluZzsKCgkJaWYgKCFzdGFydHNfd2l0aChleHRyYV9yZWZuYW1lLCBkaXJuYW1lKSkKCQkJYnJlYWs7CgoJCWlmICghc2tpcCB8fCAhc3RyaW5nX2xpc3RfaGFzX3N0cmluZyhza2lwLCBleHRyYV9yZWZuYW1lKSkKCQkJcmV0dXJuIGV4dHJhX3JlZm5hbWU7Cgl9CglyZXR1cm4gTlVMTDsKfQoKaW50IHJlZnNfcmVuYW1lX3JlZl9hdmFpbGFibGUoc3RydWN0IHJlZl9zdG9yZSAqcmVmcywKCQkJICAgICAgY29uc3QgY2hhciAqb2xkX3JlZm5hbWUsCgkJCSAgICAgIGNvbnN0IGNoYXIgKm5ld19yZWZuYW1lKQp7CglzdHJ1Y3Qgc3RyaW5nX2xpc3Qgc2tpcCA9IFNUUklOR19MSVNUX0lOSVRfTk9EVVA7CglzdHJ1Y3Qgc3RyYnVmIGVyciA9IFNUUkJVRl9JTklUOwoJaW50IG9rOwoKCXN0cmluZ19saXN0X2luc2VydCgmc2tpcCwgb2xkX3JlZm5hbWUpOwoJb2sgPSAhcmVmc192ZXJpZnlfcmVmbmFtZV9hdmFpbGFibGUocmVmcywgbmV3X3JlZm5hbWUsCgkJCQkJICAgIE5VTEwsICZza2lwLCAmZXJyKTsKCWlmICghb2spCgkJZXJyb3IoIiVzIiwgZXJyLmJ1Zik7CgoJc3RyaW5nX2xpc3RfY2xlYXIoJnNraXAsIDApOwoJc3RyYnVmX3JlbGVhc2UoJmVycik7CglyZXR1cm4gb2s7Cn0KCmludCByZWZzX2hlYWRfcmVmKHN0cnVjdCByZWZfc3RvcmUgKnJlZnMsIGVhY2hfcmVmX2ZuIGZuLCB2b2lkICpjYl9kYXRhKQp7CglzdHJ1Y3Qgb2JqZWN0X2lkIG9pZDsKCWludCBmbGFnOwoKCWlmICghcmVmc19yZWFkX3JlZl9mdWxsKHJlZnMsICJIRUFEIiwgUkVTT0xWRV9SRUZfUkVBRElORywKCQkJCSZvaWQsICZmbGFnKSkKCQlyZXR1cm4gZm4oIkhFQUQiLCAmb2lkLCBmbGFnLCBjYl9kYXRhKTsKCglyZXR1cm4gMDsKfQoKaW50IGhlYWRfcmVmKGVhY2hfcmVmX2ZuIGZuLCB2b2lkICpjYl9kYXRhKQp7CglyZXR1cm4gcmVmc19oZWFkX3JlZihnZXRfbWFpbl9yZWZfc3RvcmUodGhlX3JlcG9zaXRvcnkpLCBmbiwgY2JfZGF0YSk7Cn0KCnN0cnVjdCByZWZfaXRlcmF0b3IgKnJlZnNfcmVmX2l0ZXJhdG9yX2JlZ2luKAoJCXN0cnVjdCByZWZfc3RvcmUgKnJlZnMsCgkJY29uc3QgY2hhciAqcHJlZml4LCBpbnQgdHJpbSwgaW50IGZsYWdzKQp7CglzdHJ1Y3QgcmVmX2l0ZXJhdG9yICppdGVyOwoKCWlmIChyZWZfcGFyYW5vaWEgPCAwKQoJCXJlZl9wYXJhbm9pYSA9IGdpdF9lbnZfYm9vbCgiR0lUX1JFRl9QQVJBTk9JQSIsIDApOwoJaWYgKHJlZl9wYXJhbm9pYSkKCQlmbGFncyB8PSBET19GT1JfRUFDSF9JTkNMVURFX0JST0tFTjsKCglpdGVyID0gcmVmcy0+YmUtPml0ZXJhdG9yX2JlZ2luKHJlZnMsIHByZWZpeCwgZmxhZ3MpOwoKCS8qCgkgKiBgaXRlcmF0b3JfYmVnaW4oKWAgYWxyZWFkeSB0YWtlcyBjYXJlIG9mIHByZWZpeCwgYnV0IHdlCgkgKiBtaWdodCBuZWVkIHRvIGRvIHNvbWUgdHJpbW1pbmc6CgkgKi8KCWlmICh0cmltKQoJCWl0ZXIgPSBwcmVmaXhfcmVmX2l0ZXJhdG9yX2JlZ2luKGl0ZXIsICIiLCB0cmltKTsKCgkvKiBTYW5pdHkgY2hlY2sgZm9yIHN1YmNsYXNzZXM6ICovCglpZiAoIWl0ZXItPm9yZGVyZWQpCgkJQlVHKCJyZWZlcmVuY2UgaXRlcmF0b3IgaXMgbm90IG9yZGVyZWQiKTsKCglyZXR1cm4gaXRlcjsKfQoKLyoKICogQ2FsbCBmbiBmb3IgZWFjaCByZWZlcmVuY2UgaW4gdGhlIHNwZWNpZmllZCBzdWJtb2R1bGUgZm9yIHdoaWNoIHRoZQogKiByZWZuYW1lIGJlZ2lucyB3aXRoIHByZWZpeC4gSWYgdHJpbSBpcyBub24temVybywgdGhlbiB0cmltIHRoYXQKICogbWFueSBjaGFyYWN0ZXJzIG9mZiB0aGUgYmVnaW5uaW5nIG9mIGVhY2ggcmVmbmFtZSBiZWZvcmUgcGFzc2luZwogKiB0aGUgcmVmbmFtZSB0byBmbi4gZmxhZ3MgY2FuIGJlIERPX0ZPUl9FQUNIX0lOQ0xVREVfQlJPS0VOIHRvCiAqIGluY2x1ZGUgYnJva2VuIHJlZmVyZW5jZXMgaW4gdGhlIGl0ZXJhdGlvbi4gSWYgZm4gZXZlciByZXR1cm5zIGEKICogbm9uLXplcm8gdmFsdWUsIHN0b3AgdGhlIGl0ZXJhdGlvbiBhbmQgcmV0dXJuIHRoYXQgdmFsdWU7CiAqIG90aGVyd2lzZSwgcmV0dXJuIDAuCiAqLwpzdGF0aWMgaW50IGRvX2Zvcl9lYWNoX3JlcG9fcmVmKHN0cnVjdCByZXBvc2l0b3J5ICpyLCBjb25zdCBjaGFyICpwcmVmaXgsCgkJCQllYWNoX3JlcG9fcmVmX2ZuIGZuLCBpbnQgdHJpbSwgaW50IGZsYWdzLAoJCQkJdm9pZCAqY2JfZGF0YSkKewoJc3RydWN0IHJlZl9pdGVyYXRvciAqaXRlcjsKCXN0cnVjdCByZWZfc3RvcmUgKnJlZnMgPSBnZXRfbWFpbl9yZWZfc3RvcmUocik7CgoJaWYgKCFyZWZzKQoJCXJldHVybiAwOwoKCWl0ZXIgPSByZWZzX3JlZl9pdGVyYXRvcl9iZWdpbihyZWZzLCBwcmVmaXgsIHRyaW0sIGZsYWdzKTsKCglyZXR1cm4gZG9fZm9yX2VhY2hfcmVwb19yZWZfaXRlcmF0b3IociwgaXRlciwgZm4sIGNiX2RhdGEpOwp9CgpzdHJ1Y3QgZG9fZm9yX2VhY2hfcmVmX2hlbHAgewoJZWFjaF9yZWZfZm4gKmZuOwoJdm9pZCAqY2JfZGF0YTsKfTsKCnN0YXRpYyBpbnQgZG9fZm9yX2VhY2hfcmVmX2hlbHBlcihzdHJ1Y3QgcmVwb3NpdG9yeSAqciwKCQkJCSAgY29uc3QgY2hhciAqcmVmbmFtZSwKCQkJCSAgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLAoJCQkJICBpbnQgZmxhZ3MsCgkJCQkgIHZvaWQgKmNiX2RhdGEpCnsKCXN0cnVjdCBkb19mb3JfZWFjaF9yZWZfaGVscCAqaHAgPSBjYl9kYXRhOwoKCXJldHVybiBocC0+Zm4ocmVmbmFtZSwgb2lkLCBmbGFncywgaHAtPmNiX2RhdGEpOwp9CgpzdGF0aWMgaW50IGRvX2Zvcl9lYWNoX3JlZihzdHJ1Y3QgcmVmX3N0b3JlICpyZWZzLCBjb25zdCBjaGFyICpwcmVmaXgsCgkJCSAgIGVhY2hfcmVmX2ZuIGZuLCBpbnQgdHJpbSwgaW50IGZsYWdzLCB2b2lkICpjYl9kYXRhKQp7CglzdHJ1Y3QgcmVmX2l0ZXJhdG9yICppdGVyOwoJc3RydWN0IGRvX2Zvcl9lYWNoX3JlZl9oZWxwIGhwID0geyBmbiwgY2JfZGF0YSB9OwoKCWlmICghcmVmcykKCQlyZXR1cm4gMDsKCglpdGVyID0gcmVmc19yZWZfaXRlcmF0b3JfYmVnaW4ocmVmcywgcHJlZml4LCB0cmltLCBmbGFncyk7CgoJcmV0dXJuIGRvX2Zvcl9lYWNoX3JlcG9fcmVmX2l0ZXJhdG9yKHRoZV9yZXBvc2l0b3J5LCBpdGVyLAoJCQkJCWRvX2Zvcl9lYWNoX3JlZl9oZWxwZXIsICZocCk7Cn0KCmludCByZWZzX2Zvcl9lYWNoX3JlZihzdHJ1Y3QgcmVmX3N0b3JlICpyZWZzLCBlYWNoX3JlZl9mbiBmbiwgdm9pZCAqY2JfZGF0YSkKewoJcmV0dXJuIGRvX2Zvcl9lYWNoX3JlZihyZWZzLCAiIiwgZm4sIDAsIDAsIGNiX2RhdGEpOwp9CgppbnQgZm9yX2VhY2hfcmVmKGVhY2hfcmVmX2ZuIGZuLCB2b2lkICpjYl9kYXRhKQp7CglyZXR1cm4gcmVmc19mb3JfZWFjaF9yZWYoZ2V0X21haW5fcmVmX3N0b3JlKHRoZV9yZXBvc2l0b3J5KSwgZm4sIGNiX2RhdGEpOwp9CgppbnQgcmVmc19mb3JfZWFjaF9yZWZfaW4oc3RydWN0IHJlZl9zdG9yZSAqcmVmcywgY29uc3QgY2hhciAqcHJlZml4LAoJCQkgZWFjaF9yZWZfZm4gZm4sIHZvaWQgKmNiX2RhdGEpCnsKCXJldHVybiBkb19mb3JfZWFjaF9yZWYocmVmcywgcHJlZml4LCBmbiwgc3RybGVuKHByZWZpeCksIDAsIGNiX2RhdGEpOwp9CgppbnQgZm9yX2VhY2hfcmVmX2luKGNvbnN0IGNoYXIgKnByZWZpeCwgZWFjaF9yZWZfZm4gZm4sIHZvaWQgKmNiX2RhdGEpCnsKCXJldHVybiByZWZzX2Zvcl9lYWNoX3JlZl9pbihnZXRfbWFpbl9yZWZfc3RvcmUodGhlX3JlcG9zaXRvcnkpLCBwcmVmaXgsIGZuLCBjYl9kYXRhKTsKfQoKaW50IGZvcl9lYWNoX2Z1bGxyZWZfaW4oY29uc3QgY2hhciAqcHJlZml4LCBlYWNoX3JlZl9mbiBmbiwgdm9pZCAqY2JfZGF0YSwgdW5zaWduZWQgaW50IGJyb2tlbikKewoJdW5zaWduZWQgaW50IGZsYWcgPSAwOwoKCWlmIChicm9rZW4pCgkJZmxhZyA9IERPX0ZPUl9FQUNIX0lOQ0xVREVfQlJPS0VOOwoJcmV0dXJuIGRvX2Zvcl9lYWNoX3JlZihnZXRfbWFpbl9yZWZfc3RvcmUodGhlX3JlcG9zaXRvcnkpLAoJCQkgICAgICAgcHJlZml4LCBmbiwgMCwgZmxhZywgY2JfZGF0YSk7Cn0KCmludCByZWZzX2Zvcl9lYWNoX2Z1bGxyZWZfaW4oc3RydWN0IHJlZl9zdG9yZSAqcmVmcywgY29uc3QgY2hhciAqcHJlZml4LAoJCQkgICAgIGVhY2hfcmVmX2ZuIGZuLCB2b2lkICpjYl9kYXRhLAoJCQkgICAgIHVuc2lnbmVkIGludCBicm9rZW4pCnsKCXVuc2lnbmVkIGludCBmbGFnID0gMDsKCglpZiAoYnJva2VuKQoJCWZsYWcgPSBET19GT1JfRUFDSF9JTkNMVURFX0JST0tFTjsKCXJldHVybiBkb19mb3JfZWFjaF9yZWYocmVmcywgcHJlZml4LCBmbiwgMCwgZmxhZywgY2JfZGF0YSk7Cn0KCmludCBmb3JfZWFjaF9yZXBsYWNlX3JlZihzdHJ1Y3QgcmVwb3NpdG9yeSAqciwgZWFjaF9yZXBvX3JlZl9mbiBmbiwgdm9pZCAqY2JfZGF0YSkKewoJcmV0dXJuIGRvX2Zvcl9lYWNoX3JlcG9fcmVmKHIsIGdpdF9yZXBsYWNlX3JlZl9iYXNlLCBmbiwKCQkJCSAgICBzdHJsZW4oZ2l0X3JlcGxhY2VfcmVmX2Jhc2UpLAoJCQkJICAgIERPX0ZPUl9FQUNIX0lOQ0xVREVfQlJPS0VOLCBjYl9kYXRhKTsKfQoKaW50IGZvcl9lYWNoX25hbWVzcGFjZWRfcmVmKGVhY2hfcmVmX2ZuIGZuLCB2b2lkICpjYl9kYXRhKQp7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoJaW50IHJldDsKCXN0cmJ1Zl9hZGRmKCZidWYsICIlc3JlZnMvIiwgZ2V0X2dpdF9uYW1lc3BhY2UoKSk7CglyZXQgPSBkb19mb3JfZWFjaF9yZWYoZ2V0X21haW5fcmVmX3N0b3JlKHRoZV9yZXBvc2l0b3J5KSwKCQkJICAgICAgYnVmLmJ1ZiwgZm4sIDAsIDAsIGNiX2RhdGEpOwoJc3RyYnVmX3JlbGVhc2UoJmJ1Zik7CglyZXR1cm4gcmV0Owp9CgppbnQgcmVmc19mb3JfZWFjaF9yYXdyZWYoc3RydWN0IHJlZl9zdG9yZSAqcmVmcywgZWFjaF9yZWZfZm4gZm4sIHZvaWQgKmNiX2RhdGEpCnsKCXJldHVybiBkb19mb3JfZWFjaF9yZWYocmVmcywgIiIsIGZuLCAwLAoJCQkgICAgICAgRE9fRk9SX0VBQ0hfSU5DTFVERV9CUk9LRU4sIGNiX2RhdGEpOwp9CgppbnQgZm9yX2VhY2hfcmF3cmVmKGVhY2hfcmVmX2ZuIGZuLCB2b2lkICpjYl9kYXRhKQp7CglyZXR1cm4gcmVmc19mb3JfZWFjaF9yYXdyZWYoZ2V0X21haW5fcmVmX3N0b3JlKHRoZV9yZXBvc2l0b3J5KSwgZm4sIGNiX2RhdGEpOwp9CgppbnQgcmVmc19yZWFkX3Jhd19yZWYoc3RydWN0IHJlZl9zdG9yZSAqcmVmX3N0b3JlLAoJCSAgICAgIGNvbnN0IGNoYXIgKnJlZm5hbWUsIHN0cnVjdCBvYmplY3RfaWQgKm9pZCwKCQkgICAgICBzdHJ1Y3Qgc3RyYnVmICpyZWZlcmVudCwgdW5zaWduZWQgaW50ICp0eXBlKQp7CglyZXR1cm4gcmVmX3N0b3JlLT5iZS0+cmVhZF9yYXdfcmVmKHJlZl9zdG9yZSwgcmVmbmFtZSwgb2lkLCByZWZlcmVudCwgdHlwZSk7Cn0KCi8qIFRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gcmV0dXJuIGEgbWVhbmluZ2Z1bCBlcnJubyBvbiBmYWlsdXJlICovCmNvbnN0IGNoYXIgKnJlZnNfcmVzb2x2ZV9yZWZfdW5zYWZlKHN0cnVjdCByZWZfc3RvcmUgKnJlZnMsCgkJCQkgICAgY29uc3QgY2hhciAqcmVmbmFtZSwKCQkJCSAgICBpbnQgcmVzb2x2ZV9mbGFncywKCQkJCSAgICBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsIGludCAqZmxhZ3MpCnsKCXN0YXRpYyBzdHJ1Y3Qgc3RyYnVmIHNiX3JlZm5hbWUgPSBTVFJCVUZfSU5JVDsKCXN0cnVjdCBvYmplY3RfaWQgdW51c2VkX29pZDsKCWludCB1bnVzZWRfZmxhZ3M7CglpbnQgc3ltcmVmX2NvdW50OwoKCWlmICghb2lkKQoJCW9pZCA9ICZ1bnVzZWRfb2lkOwoJaWYgKCFmbGFncykKCQlmbGFncyA9ICZ1bnVzZWRfZmxhZ3M7CgoJKmZsYWdzID0gMDsKCglpZiAoY2hlY2tfcmVmbmFtZV9mb3JtYXQocmVmbmFtZSwgUkVGTkFNRV9BTExPV19PTkVMRVZFTCkpIHsKCQlpZiAoIShyZXNvbHZlX2ZsYWdzICYgUkVTT0xWRV9SRUZfQUxMT1dfQkFEX05BTUUpIHx8CgkJICAgICFyZWZuYW1lX2lzX3NhZmUocmVmbmFtZSkpIHsKCQkJZXJybm8gPSBFSU5WQUw7CgkJCXJldHVybiBOVUxMOwoJCX0KCgkJLyoKCQkgKiBkd2ltX3JlZigpIHVzZXMgUkVGX0lTQlJPS0VOIHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4KCQkgKiBtaXNzaW5nIHJlZnMgYW5kIHJlZnMgdGhhdCB3ZXJlIHByZXNlbnQgYnV0IGludmFsaWQsCgkJICogdG8gY29tcGxhaW4gYWJvdXQgdGhlIGxhdHRlciB0byBzdGRlcnIuCgkJICoKCQkgKiBXZSBkb24ndCBrbm93IHdoZXRoZXIgdGhlIHJlZiBleGlzdHMsIHNvIGRvbid0IHNldAoJCSAqIFJFRl9JU0JST0tFTiB5ZXQuCgkJICovCgkJKmZsYWdzIHw9IFJFRl9CQURfTkFNRTsKCX0KCglmb3IgKHN5bXJlZl9jb3VudCA9IDA7IHN5bXJlZl9jb3VudCA8IFNZTVJFRl9NQVhERVBUSDsgc3ltcmVmX2NvdW50KyspIHsKCQl1bnNpZ25lZCBpbnQgcmVhZF9mbGFncyA9IDA7CgoJCWlmIChyZWZzX3JlYWRfcmF3X3JlZihyZWZzLCByZWZuYW1lLAoJCQkJICAgICAgb2lkLCAmc2JfcmVmbmFtZSwgJnJlYWRfZmxhZ3MpKSB7CgkJCSpmbGFncyB8PSByZWFkX2ZsYWdzOwoKCQkJLyogSW4gcmVhZGluZyBtb2RlLCByZWZzIG11c3QgZXZlbnR1YWxseSByZXNvbHZlICovCgkJCWlmIChyZXNvbHZlX2ZsYWdzICYgUkVTT0xWRV9SRUZfUkVBRElORykKCQkJCXJldHVybiBOVUxMOwoKCQkJLyoKCQkJICogT3RoZXJ3aXNlIGEgbWlzc2luZyByZWYgaXMgT0suIEJ1dCB0aGUgZmlsZXMgYmFja2VuZAoJCQkgKiBtYXkgc2hvdyBlcnJvcnMgYmVzaWRlcyBFTk9FTlQgaWYgdGhlcmUgYXJlCgkJCSAqIHNpbWlsYXJseS1uYW1lZCByZWZzLgoJCQkgKi8KCQkJaWYgKGVycm5vICE9IEVOT0VOVCAmJgoJCQkgICAgZXJybm8gIT0gRUlTRElSICYmCgkJCSAgICBlcnJubyAhPSBFTk9URElSKQoJCQkJcmV0dXJuIE5VTEw7CgoJCQlvaWRjbHIob2lkKTsKCQkJaWYgKCpmbGFncyAmIFJFRl9CQURfTkFNRSkKCQkJCSpmbGFncyB8PSBSRUZfSVNCUk9LRU47CgkJCXJldHVybiByZWZuYW1lOwoJCX0KCgkJKmZsYWdzIHw9IHJlYWRfZmxhZ3M7CgoJCWlmICghKHJlYWRfZmxhZ3MgJiBSRUZfSVNTWU1SRUYpKSB7CgkJCWlmICgqZmxhZ3MgJiBSRUZfQkFEX05BTUUpIHsKCQkJCW9pZGNscihvaWQpOwoJCQkJKmZsYWdzIHw9IFJFRl9JU0JST0tFTjsKCQkJfQoJCQlyZXR1cm4gcmVmbmFtZTsKCQl9CgoJCXJlZm5hbWUgPSBzYl9yZWZuYW1lLmJ1ZjsKCQlpZiAocmVzb2x2ZV9mbGFncyAmIFJFU09MVkVfUkVGX05PX1JFQ1VSU0UpIHsKCQkJb2lkY2xyKG9pZCk7CgkJCXJldHVybiByZWZuYW1lOwoJCX0KCQlpZiAoY2hlY2tfcmVmbmFtZV9mb3JtYXQocmVmbmFtZSwgUkVGTkFNRV9BTExPV19PTkVMRVZFTCkpIHsKCQkJaWYgKCEocmVzb2x2ZV9mbGFncyAmIFJFU09MVkVfUkVGX0FMTE9XX0JBRF9OQU1FKSB8fAoJCQkgICAgIXJlZm5hbWVfaXNfc2FmZShyZWZuYW1lKSkgewoJCQkJZXJybm8gPSBFSU5WQUw7CgkJCQlyZXR1cm4gTlVMTDsKCQkJfQoKCQkJKmZsYWdzIHw9IFJFRl9JU0JST0tFTiB8IFJFRl9CQURfTkFNRTsKCQl9Cgl9CgoJZXJybm8gPSBFTE9PUDsKCXJldHVybiBOVUxMOwp9CgovKiBiYWNrZW5kIGZ1bmN0aW9ucyAqLwppbnQgcmVmc19pbml0X2RiKHN0cnVjdCBzdHJidWYgKmVycikKewoJc3RydWN0IHJlZl9zdG9yZSAqcmVmcyA9IGdldF9tYWluX3JlZl9zdG9yZSh0aGVfcmVwb3NpdG9yeSk7CgoJcmV0dXJuIHJlZnMtPmJlLT5pbml0X2RiKHJlZnMsIGVycik7Cn0KCmNvbnN0IGNoYXIgKnJlc29sdmVfcmVmX3Vuc2FmZShjb25zdCBjaGFyICpyZWZuYW1lLCBpbnQgcmVzb2x2ZV9mbGFncywKCQkJICAgICAgIHN0cnVjdCBvYmplY3RfaWQgKm9pZCwgaW50ICpmbGFncykKewoJcmV0dXJuIHJlZnNfcmVzb2x2ZV9yZWZfdW5zYWZlKGdldF9tYWluX3JlZl9zdG9yZSh0aGVfcmVwb3NpdG9yeSksIHJlZm5hbWUsCgkJCQkgICAgICAgcmVzb2x2ZV9mbGFncywgb2lkLCBmbGFncyk7Cn0KCmludCByZXNvbHZlX2dpdGxpbmtfcmVmKGNvbnN0IGNoYXIgKnN1Ym1vZHVsZSwgY29uc3QgY2hhciAqcmVmbmFtZSwKCQkJc3RydWN0IG9iamVjdF9pZCAqb2lkKQp7CglzdHJ1Y3QgcmVmX3N0b3JlICpyZWZzOwoJaW50IGZsYWdzOwoKCXJlZnMgPSBnZXRfc3VibW9kdWxlX3JlZl9zdG9yZShzdWJtb2R1bGUpOwoKCWlmICghcmVmcykKCQlyZXR1cm4gLTE7CgoJaWYgKCFyZWZzX3Jlc29sdmVfcmVmX3Vuc2FmZShyZWZzLCByZWZuYW1lLCAwLCBvaWQsICZmbGFncykgfHwKCSAgICBpc19udWxsX29pZChvaWQpKQoJCXJldHVybiAtMTsKCXJldHVybiAwOwp9CgpzdHJ1Y3QgcmVmX3N0b3JlX2hhc2hfZW50cnkKewoJc3RydWN0IGhhc2htYXBfZW50cnkgZW50OwoKCXN0cnVjdCByZWZfc3RvcmUgKnJlZnM7CgoJLyogTlVMLXRlcm1pbmF0ZWQgaWRlbnRpZmllciBvZiB0aGUgcmVmIHN0b3JlOiAqLwoJY2hhciBuYW1lW0ZMRVhfQVJSQVldOwp9OwoKc3RhdGljIGludCByZWZfc3RvcmVfaGFzaF9jbXAoY29uc3Qgdm9pZCAqdW51c2VkX2NtcF9kYXRhLAoJCQkgICAgICBjb25zdCBzdHJ1Y3QgaGFzaG1hcF9lbnRyeSAqZXB0ciwKCQkJICAgICAgY29uc3Qgc3RydWN0IGhhc2htYXBfZW50cnkgKmVudHJ5X29yX2tleSwKCQkJICAgICAgY29uc3Qgdm9pZCAqa2V5ZGF0YSkKewoJY29uc3Qgc3RydWN0IHJlZl9zdG9yZV9oYXNoX2VudHJ5ICplMSwgKmUyOwoJY29uc3QgY2hhciAqbmFtZTsKCgllMSA9IGNvbnRhaW5lcl9vZihlcHRyLCBjb25zdCBzdHJ1Y3QgcmVmX3N0b3JlX2hhc2hfZW50cnksIGVudCk7CgllMiA9IGNvbnRhaW5lcl9vZihlbnRyeV9vcl9rZXksIGNvbnN0IHN0cnVjdCByZWZfc3RvcmVfaGFzaF9lbnRyeSwgZW50KTsKCW5hbWUgPSBrZXlkYXRhID8ga2V5ZGF0YSA6IGUyLT5uYW1lOwoKCXJldHVybiBzdHJjbXAoZTEtPm5hbWUsIG5hbWUpOwp9CgpzdGF0aWMgc3RydWN0IHJlZl9zdG9yZV9oYXNoX2VudHJ5ICphbGxvY19yZWZfc3RvcmVfaGFzaF9lbnRyeSgKCQljb25zdCBjaGFyICpuYW1lLCBzdHJ1Y3QgcmVmX3N0b3JlICpyZWZzKQp7CglzdHJ1Y3QgcmVmX3N0b3JlX2hhc2hfZW50cnkgKmVudHJ5OwoKCUZMRVhfQUxMT0NfU1RSKGVudHJ5LCBuYW1lLCBuYW1lKTsKCWhhc2htYXBfZW50cnlfaW5pdCgmZW50cnktPmVudCwgc3RyaGFzaChuYW1lKSk7CgllbnRyeS0+cmVmcyA9IHJlZnM7CglyZXR1cm4gZW50cnk7Cn0KCi8qIEEgaGFzaG1hcCBvZiByZWZfc3RvcmVzLCBzdG9yZWQgYnkgc3VibW9kdWxlIG5hbWU6ICovCnN0YXRpYyBzdHJ1Y3QgaGFzaG1hcCBzdWJtb2R1bGVfcmVmX3N0b3JlczsKCi8qIEEgaGFzaG1hcCBvZiByZWZfc3RvcmVzLCBzdG9yZWQgYnkgd29ya3RyZWUgaWQ6ICovCnN0YXRpYyBzdHJ1Y3QgaGFzaG1hcCB3b3JrdHJlZV9yZWZfc3RvcmVzOwoKLyoKICogTG9vayB1cCBhIHJlZiBzdG9yZSBieSBuYW1lLiBJZiB0aGF0IHJlZl9zdG9yZSBoYXNuJ3QgYmVlbgogKiByZWdpc3RlcmVkIHlldCwgcmV0dXJuIE5VTEwuCiAqLwpzdGF0aWMgc3RydWN0IHJlZl9zdG9yZSAqbG9va3VwX3JlZl9zdG9yZV9tYXAoc3RydWN0IGhhc2htYXAgKm1hcCwKCQkJCQkgICAgICBjb25zdCBjaGFyICpuYW1lKQp7CglzdHJ1Y3QgcmVmX3N0b3JlX2hhc2hfZW50cnkgKmVudHJ5OwoJdW5zaWduZWQgaW50IGhhc2g7CgoJaWYgKCFtYXAtPnRhYmxlc2l6ZSkKCQkvKiBJdCdzIGluaXRpYWxpemVkIG9uIGRlbWFuZCBpbiByZWdpc3Rlcl9yZWZfc3RvcmUoKS4gKi8KCQlyZXR1cm4gTlVMTDsKCgloYXNoID0gc3RyaGFzaChuYW1lKTsKCWVudHJ5ID0gaGFzaG1hcF9nZXRfZW50cnlfZnJvbV9oYXNoKG1hcCwgaGFzaCwgbmFtZSwKCQkJCQlzdHJ1Y3QgcmVmX3N0b3JlX2hhc2hfZW50cnksIGVudCk7CglyZXR1cm4gZW50cnkgPyBlbnRyeS0+cmVmcyA6IE5VTEw7Cn0KCi8qCiAqIENyZWF0ZSwgcmVjb3JkLCBhbmQgcmV0dXJuIGEgcmVmX3N0b3JlIGluc3RhbmNlIGZvciB0aGUgc3BlY2lmaWVkCiAqIGdpdGRpci4KICovCnN0YXRpYyBzdHJ1Y3QgcmVmX3N0b3JlICpyZWZfc3RvcmVfaW5pdChjb25zdCBjaGFyICpnaXRkaXIsCgkJCQkJdW5zaWduZWQgaW50IGZsYWdzKQp7Cgljb25zdCBjaGFyICpiZV9uYW1lID0gImZpbGVzIjsKCXN0cnVjdCByZWZfc3RvcmFnZV9iZSAqYmUgPSBmaW5kX3JlZl9zdG9yYWdlX2JhY2tlbmQoYmVfbmFtZSk7CglzdHJ1Y3QgcmVmX3N0b3JlICpyZWZzOwoKCWlmICghYmUpCgkJQlVHKCJyZWZlcmVuY2UgYmFja2VuZCAlcyBpcyB1bmtub3duIiwgYmVfbmFtZSk7CgoJcmVmcyA9IGJlLT5pbml0KGdpdGRpciwgZmxhZ3MpOwoJcmV0dXJuIHJlZnM7Cn0KCnN0cnVjdCByZWZfc3RvcmUgKmdldF9tYWluX3JlZl9zdG9yZShzdHJ1Y3QgcmVwb3NpdG9yeSAqcikKewoJaWYgKHItPnJlZnNfcHJpdmF0ZSkKCQlyZXR1cm4gci0+cmVmc19wcml2YXRlOwoKCWlmICghci0+Z2l0ZGlyKQoJCUJVRygiYXR0ZW1wdGluZyB0byBnZXQgbWFpbl9yZWZfc3RvcmUgb3V0c2lkZSBvZiByZXBvc2l0b3J5Iik7CgoJci0+cmVmc19wcml2YXRlID0gcmVmX3N0b3JlX2luaXQoci0+Z2l0ZGlyLCBSRUZfU1RPUkVfQUxMX0NBUFMpOwoJcmV0dXJuIHItPnJlZnNfcHJpdmF0ZTsKfQoKLyoKICogQXNzb2NpYXRlIGEgcmVmIHN0b3JlIHdpdGggYSBuYW1lLiBJdCBpcyBhIGZhdGFsIGVycm9yIHRvIGNhbGwgdGhpcwogKiBmdW5jdGlvbiB0d2ljZSBmb3IgdGhlIHNhbWUgbmFtZS4KICovCnN0YXRpYyB2b2lkIHJlZ2lzdGVyX3JlZl9zdG9yZV9tYXAoc3RydWN0IGhhc2htYXAgKm1hcCwKCQkJCSAgIGNvbnN0IGNoYXIgKnR5cGUsCgkJCQkgICBzdHJ1Y3QgcmVmX3N0b3JlICpyZWZzLAoJCQkJICAgY29uc3QgY2hhciAqbmFtZSkKewoJc3RydWN0IHJlZl9zdG9yZV9oYXNoX2VudHJ5ICplbnRyeTsKCglpZiAoIW1hcC0+dGFibGVzaXplKQoJCWhhc2htYXBfaW5pdChtYXAsIHJlZl9zdG9yZV9oYXNoX2NtcCwgTlVMTCwgMCk7CgoJZW50cnkgPSBhbGxvY19yZWZfc3RvcmVfaGFzaF9lbnRyeShuYW1lLCByZWZzKTsKCWlmIChoYXNobWFwX3B1dChtYXAsICZlbnRyeS0+ZW50KSkKCQlCVUcoIiVzIHJlZl9zdG9yZSAnJXMnIGluaXRpYWxpemVkIHR3aWNlIiwgdHlwZSwgbmFtZSk7Cn0KCnN0cnVjdCByZWZfc3RvcmUgKmdldF9zdWJtb2R1bGVfcmVmX3N0b3JlKGNvbnN0IGNoYXIgKnN1Ym1vZHVsZSkKewoJc3RydWN0IHN0cmJ1ZiBzdWJtb2R1bGVfc2IgPSBTVFJCVUZfSU5JVDsKCXN0cnVjdCByZWZfc3RvcmUgKnJlZnM7CgljaGFyICp0b19mcmVlID0gTlVMTDsKCXNpemVfdCBsZW47CgoJaWYgKCFzdWJtb2R1bGUpCgkJcmV0dXJuIE5VTEw7CgoJbGVuID0gc3RybGVuKHN1Ym1vZHVsZSk7Cgl3aGlsZSAobGVuICYmIGlzX2Rpcl9zZXAoc3VibW9kdWxlW2xlbiAtIDFdKSkKCQlsZW4tLTsKCWlmICghbGVuKQoJCXJldHVybiBOVUxMOwoKCWlmIChzdWJtb2R1bGVbbGVuXSkKCQkvKiBXZSBuZWVkIHRvIHN0cmlwIG9mZiBvbmUgb3IgbW9yZSB0cmFpbGluZyBzbGFzaGVzICovCgkJc3VibW9kdWxlID0gdG9fZnJlZSA9IHhtZW1kdXB6KHN1Ym1vZHVsZSwgbGVuKTsKCglyZWZzID0gbG9va3VwX3JlZl9zdG9yZV9tYXAoJnN1Ym1vZHVsZV9yZWZfc3RvcmVzLCBzdWJtb2R1bGUpOwoJaWYgKHJlZnMpCgkJZ290byBkb25lOwoKCXN0cmJ1Zl9hZGRzdHIoJnN1Ym1vZHVsZV9zYiwgc3VibW9kdWxlKTsKCWlmICghaXNfbm9uYmFyZV9yZXBvc2l0b3J5X2Rpcigmc3VibW9kdWxlX3NiKSkKCQlnb3RvIGRvbmU7CgoJaWYgKHN1Ym1vZHVsZV90b19naXRkaXIoJnN1Ym1vZHVsZV9zYiwgc3VibW9kdWxlKSkKCQlnb3RvIGRvbmU7CgoJLyogYXNzdW1lIHRoYXQgYWRkX3N1Ym1vZHVsZV9vZGIoKSBoYXMgYmVlbiBjYWxsZWQgKi8KCXJlZnMgPSByZWZfc3RvcmVfaW5pdChzdWJtb2R1bGVfc2IuYnVmLAoJCQkgICAgICBSRUZfU1RPUkVfUkVBRCB8IFJFRl9TVE9SRV9PREIpOwoJcmVnaXN0ZXJfcmVmX3N0b3JlX21hcCgmc3VibW9kdWxlX3JlZl9zdG9yZXMsICJzdWJtb2R1bGUiLAoJCQkgICAgICAgcmVmcywgc3VibW9kdWxlKTsKCmRvbmU6CglzdHJidWZfcmVsZWFzZSgmc3VibW9kdWxlX3NiKTsKCWZyZWUodG9fZnJlZSk7CgoJcmV0dXJuIHJlZnM7Cn0KCnN0cnVjdCByZWZfc3RvcmUgKmdldF93b3JrdHJlZV9yZWZfc3RvcmUoY29uc3Qgc3RydWN0IHdvcmt0cmVlICp3dCkKewoJc3RydWN0IHJlZl9zdG9yZSAqcmVmczsKCWNvbnN0IGNoYXIgKmlkOwoKCWlmICh3dC0+aXNfY3VycmVudCkKCQlyZXR1cm4gZ2V0X21haW5fcmVmX3N0b3JlKHRoZV9yZXBvc2l0b3J5KTsKCglpZCA9IHd0LT5pZCA/IHd0LT5pZCA6ICIvIjsKCXJlZnMgPSBsb29rdXBfcmVmX3N0b3JlX21hcCgmd29ya3RyZWVfcmVmX3N0b3JlcywgaWQpOwoJaWYgKHJlZnMpCgkJcmV0dXJuIHJlZnM7CgoJaWYgKHd0LT5pZCkKCQlyZWZzID0gcmVmX3N0b3JlX2luaXQoZ2l0X2NvbW1vbl9wYXRoKCJ3b3JrdHJlZXMvJXMiLCB3dC0+aWQpLAoJCQkJICAgICAgUkVGX1NUT1JFX0FMTF9DQVBTKTsKCWVsc2UKCQlyZWZzID0gcmVmX3N0b3JlX2luaXQoZ2V0X2dpdF9jb21tb25fZGlyKCksCgkJCQkgICAgICBSRUZfU1RPUkVfQUxMX0NBUFMpOwoKCWlmIChyZWZzKQoJCXJlZ2lzdGVyX3JlZl9zdG9yZV9tYXAoJndvcmt0cmVlX3JlZl9zdG9yZXMsICJ3b3JrdHJlZSIsCgkJCQkgICAgICAgcmVmcywgaWQpOwoJcmV0dXJuIHJlZnM7Cn0KCnZvaWQgYmFzZV9yZWZfc3RvcmVfaW5pdChzdHJ1Y3QgcmVmX3N0b3JlICpyZWZzLAoJCQkgY29uc3Qgc3RydWN0IHJlZl9zdG9yYWdlX2JlICpiZSkKewoJcmVmcy0+YmUgPSBiZTsKfQoKLyogYmFja2VuZCBmdW5jdGlvbnMgKi8KaW50IHJlZnNfcGFja19yZWZzKHN0cnVjdCByZWZfc3RvcmUgKnJlZnMsIHVuc2lnbmVkIGludCBmbGFncykKewoJcmV0dXJuIHJlZnMtPmJlLT5wYWNrX3JlZnMocmVmcywgZmxhZ3MpOwp9CgppbnQgcmVmc19wZWVsX3JlZihzdHJ1Y3QgcmVmX3N0b3JlICpyZWZzLCBjb25zdCBjaGFyICpyZWZuYW1lLAoJCSAgc3RydWN0IG9iamVjdF9pZCAqb2lkKQp7CglpbnQgZmxhZzsKCXN0cnVjdCBvYmplY3RfaWQgYmFzZTsKCglpZiAoY3VycmVudF9yZWZfaXRlciAmJiBjdXJyZW50X3JlZl9pdGVyLT5yZWZuYW1lID09IHJlZm5hbWUpIHsKCQlzdHJ1Y3Qgb2JqZWN0X2lkIHBlZWxlZDsKCgkJaWYgKHJlZl9pdGVyYXRvcl9wZWVsKGN1cnJlbnRfcmVmX2l0ZXIsICZwZWVsZWQpKQoJCQlyZXR1cm4gLTE7CgkJb2lkY3B5KG9pZCwgJnBlZWxlZCk7CgkJcmV0dXJuIDA7Cgl9CgoJaWYgKHJlZnNfcmVhZF9yZWZfZnVsbChyZWZzLCByZWZuYW1lLAoJCQkgICAgICAgUkVTT0xWRV9SRUZfUkVBRElORywgJmJhc2UsICZmbGFnKSkKCQlyZXR1cm4gLTE7CgoJcmV0dXJuIHBlZWxfb2JqZWN0KCZiYXNlLCBvaWQpOwp9CgppbnQgcGVlbF9yZWYoY29uc3QgY2hhciAqcmVmbmFtZSwgc3RydWN0IG9iamVjdF9pZCAqb2lkKQp7CglyZXR1cm4gcmVmc19wZWVsX3JlZihnZXRfbWFpbl9yZWZfc3RvcmUodGhlX3JlcG9zaXRvcnkpLCByZWZuYW1lLCBvaWQpOwp9CgppbnQgcmVmc19jcmVhdGVfc3ltcmVmKHN0cnVjdCByZWZfc3RvcmUgKnJlZnMsCgkJICAgICAgIGNvbnN0IGNoYXIgKnJlZl90YXJnZXQsCgkJICAgICAgIGNvbnN0IGNoYXIgKnJlZnNfaGVhZHNfbWFzdGVyLAoJCSAgICAgICBjb25zdCBjaGFyICpsb2dtc2cpCnsKCXJldHVybiByZWZzLT5iZS0+Y3JlYXRlX3N5bXJlZihyZWZzLCByZWZfdGFyZ2V0LAoJCQkJICAgICAgIHJlZnNfaGVhZHNfbWFzdGVyLAoJCQkJICAgICAgIGxvZ21zZyk7Cn0KCmludCBjcmVhdGVfc3ltcmVmKGNvbnN0IGNoYXIgKnJlZl90YXJnZXQsIGNvbnN0IGNoYXIgKnJlZnNfaGVhZHNfbWFzdGVyLAoJCSAgY29uc3QgY2hhciAqbG9nbXNnKQp7CglyZXR1cm4gcmVmc19jcmVhdGVfc3ltcmVmKGdldF9tYWluX3JlZl9zdG9yZSh0aGVfcmVwb3NpdG9yeSksIHJlZl90YXJnZXQsCgkJCQkgIHJlZnNfaGVhZHNfbWFzdGVyLCBsb2dtc2cpOwp9CgppbnQgcmVmX3VwZGF0ZV9yZWplY3RfZHVwbGljYXRlcyhzdHJ1Y3Qgc3RyaW5nX2xpc3QgKnJlZm5hbWVzLAoJCQkJIHN0cnVjdCBzdHJidWYgKmVycikKewoJc2l6ZV90IGksIG4gPSByZWZuYW1lcy0+bnI7CgoJYXNzZXJ0KGVycik7CgoJZm9yIChpID0gMTsgaSA8IG47IGkrKykgewoJCWludCBjbXAgPSBzdHJjbXAocmVmbmFtZXMtPml0ZW1zW2kgLSAxXS5zdHJpbmcsCgkJCQkgcmVmbmFtZXMtPml0ZW1zW2ldLnN0cmluZyk7CgoJCWlmICghY21wKSB7CgkJCXN0cmJ1Zl9hZGRmKGVyciwKCQkJCSAgICBfKCJtdWx0aXBsZSB1cGRhdGVzIGZvciByZWYgJyVzJyBub3QgYWxsb3dlZCIpLAoJCQkJICAgIHJlZm5hbWVzLT5pdGVtc1tpXS5zdHJpbmcpOwoJCQlyZXR1cm4gMTsKCQl9IGVsc2UgaWYgKGNtcCA+IDApIHsKCQkJQlVHKCJyZWZfdXBkYXRlX3JlamVjdF9kdXBsaWNhdGVzKCkgcmVjZWl2ZWQgdW5zb3J0ZWQgbGlzdCIpOwoJCX0KCX0KCXJldHVybiAwOwp9CgpzdGF0aWMgY29uc3QgY2hhciBob29rX25vdF9mb3VuZDsKc3RhdGljIGNvbnN0IGNoYXIgKmhvb2s7CgpzdGF0aWMgaW50IHJ1bl90cmFuc2FjdGlvbl9ob29rKHN0cnVjdCByZWZfdHJhbnNhY3Rpb24gKnRyYW5zYWN0aW9uLAoJCQkJY29uc3QgY2hhciAqc3RhdGUpCnsKCXN0cnVjdCBjaGlsZF9wcm9jZXNzIHByb2MgPSBDSElMRF9QUk9DRVNTX0lOSVQ7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoJaW50IHJldCA9IDAsIGk7CgoJaWYgKGhvb2sgPT0gJmhvb2tfbm90X2ZvdW5kKQoJCXJldHVybiByZXQ7CglpZiAoIWhvb2spCgkJaG9vayA9IGZpbmRfaG9vaygicmVmZXJlbmNlLXRyYW5zYWN0aW9uIik7CglpZiAoIWhvb2spIHsKCQlob29rID0gJmhvb2tfbm90X2ZvdW5kOwoJCXJldHVybiByZXQ7Cgl9CgoJYXJndl9hcnJheV9wdXNobCgmcHJvYy5hcmdzLCBob29rLCBzdGF0ZSwgTlVMTCk7Cglwcm9jLmluID0gLTE7Cglwcm9jLnN0ZG91dF90b19zdGRlcnIgPSAxOwoJcHJvYy50cmFjZTJfaG9va19uYW1lID0gInJlZmVyZW5jZS10cmFuc2FjdGlvbiI7CgoJcmV0ID0gc3RhcnRfY29tbWFuZCgmcHJvYyk7CglpZiAocmV0KQoJCXJldHVybiByZXQ7CgoJc2lnY2hhaW5fcHVzaChTSUdQSVBFLCBTSUdfSUdOKTsKCglmb3IgKGkgPSAwOyBpIDwgdHJhbnNhY3Rpb24tPm5yOyBpKyspIHsKCQlzdHJ1Y3QgcmVmX3VwZGF0ZSAqdXBkYXRlID0gdHJhbnNhY3Rpb24tPnVwZGF0ZXNbaV07CgoJCXN0cmJ1Zl9yZXNldCgmYnVmKTsKCQlzdHJidWZfYWRkZigmYnVmLCAiJXMgJXMgJXNcbiIsCgkJCSAgICBvaWRfdG9faGV4KCZ1cGRhdGUtPm9sZF9vaWQpLAoJCQkgICAgb2lkX3RvX2hleCgmdXBkYXRlLT5uZXdfb2lkKSwKCQkJICAgIHVwZGF0ZS0+cmVmbmFtZSk7CgoJCWlmICh3cml0ZV9pbl9mdWxsKHByb2MuaW4sIGJ1Zi5idWYsIGJ1Zi5sZW4pIDwgMCkgewoJCQlpZiAoZXJybm8gIT0gRVBJUEUpCgkJCQlyZXQgPSAtMTsKCQkJYnJlYWs7CgkJfQoJfQoKCWNsb3NlKHByb2MuaW4pOwoJc2lnY2hhaW5fcG9wKFNJR1BJUEUpOwoJc3RyYnVmX3JlbGVhc2UoJmJ1Zik7CgoJcmV0IHw9IGZpbmlzaF9jb21tYW5kKCZwcm9jKTsKCXJldHVybiByZXQ7Cn0KCmludCByZWZfdHJhbnNhY3Rpb25fcHJlcGFyZShzdHJ1Y3QgcmVmX3RyYW5zYWN0aW9uICp0cmFuc2FjdGlvbiwKCQkJICAgIHN0cnVjdCBzdHJidWYgKmVycikKewoJc3RydWN0IHJlZl9zdG9yZSAqcmVmcyA9IHRyYW5zYWN0aW9uLT5yZWZfc3RvcmU7CglpbnQgcmV0OwoKCXN3aXRjaCAodHJhbnNhY3Rpb24tPnN0YXRlKSB7CgljYXNlIFJFRl9UUkFOU0FDVElPTl9PUEVOOgoJCS8qIEdvb2QuICovCgkJYnJlYWs7CgljYXNlIFJFRl9UUkFOU0FDVElPTl9QUkVQQVJFRDoKCQlCVUcoInByZXBhcmUgY2FsbGVkIHR3aWNlIG9uIHJlZmVyZW5jZSB0cmFuc2FjdGlvbiIpOwoJCWJyZWFrOwoJY2FzZSBSRUZfVFJBTlNBQ1RJT05fQ0xPU0VEOgoJCUJVRygicHJlcGFyZSBjYWxsZWQgb24gYSBjbG9zZWQgcmVmZXJlbmNlIHRyYW5zYWN0aW9uIik7CgkJYnJlYWs7CglkZWZhdWx0OgoJCUJVRygidW5leHBlY3RlZCByZWZlcmVuY2UgdHJhbnNhY3Rpb24gc3RhdGUiKTsKCQlicmVhazsKCX0KCglpZiAoZ2V0ZW52KEdJVF9RVUFSQU5USU5FX0VOVklST05NRU5UKSkgewoJCXN0cmJ1Zl9hZGRzdHIoZXJyLAoJCQkgICAgICBfKCJyZWYgdXBkYXRlcyBmb3JiaWRkZW4gaW5zaWRlIHF1YXJhbnRpbmUgZW52aXJvbm1lbnQiKSk7CgkJcmV0dXJuIC0xOwoJfQoKCXJldCA9IHJlZnMtPmJlLT50cmFuc2FjdGlvbl9wcmVwYXJlKHJlZnMsIHRyYW5zYWN0aW9uLCBlcnIpOwoJaWYgKHJldCkKCQlyZXR1cm4gcmV0OwoKCXJldCA9IHJ1bl90cmFuc2FjdGlvbl9ob29rKHRyYW5zYWN0aW9uLCAicHJlcGFyZWQiKTsKCWlmIChyZXQpIHsKCQlyZWZfdHJhbnNhY3Rpb25fYWJvcnQodHJhbnNhY3Rpb24sIGVycik7CgkJZGllKF8oInJlZiB1cGRhdGVzIGFib3J0ZWQgYnkgaG9vayIpKTsKCX0KCglyZXR1cm4gMDsKfQoKaW50IHJlZl90cmFuc2FjdGlvbl9hYm9ydChzdHJ1Y3QgcmVmX3RyYW5zYWN0aW9uICp0cmFuc2FjdGlvbiwKCQkJICBzdHJ1Y3Qgc3RyYnVmICplcnIpCnsKCXN0cnVjdCByZWZfc3RvcmUgKnJlZnMgPSB0cmFuc2FjdGlvbi0+cmVmX3N0b3JlOwoJaW50IHJldCA9IDA7CgoJc3dpdGNoICh0cmFuc2FjdGlvbi0+c3RhdGUpIHsKCWNhc2UgUkVGX1RSQU5TQUNUSU9OX09QRU46CgkJLyogTm8gbmVlZCB0byBhYm9ydCBleHBsaWNpdGx5LiAqLwoJCWJyZWFrOwoJY2FzZSBSRUZfVFJBTlNBQ1RJT05fUFJFUEFSRUQ6CgkJcmV0ID0gcmVmcy0+YmUtPnRyYW5zYWN0aW9uX2Fib3J0KHJlZnMsIHRyYW5zYWN0aW9uLCBlcnIpOwoJCWJyZWFrOwoJY2FzZSBSRUZfVFJBTlNBQ1RJT05fQ0xPU0VEOgoJCUJVRygiYWJvcnQgY2FsbGVkIG9uIGEgY2xvc2VkIHJlZmVyZW5jZSB0cmFuc2FjdGlvbiIpOwoJCWJyZWFrOwoJZGVmYXVsdDoKCQlCVUcoInVuZXhwZWN0ZWQgcmVmZXJlbmNlIHRyYW5zYWN0aW9uIHN0YXRlIik7CgkJYnJlYWs7Cgl9CgoJcnVuX3RyYW5zYWN0aW9uX2hvb2sodHJhbnNhY3Rpb24sICJhYm9ydGVkIik7CgoJcmVmX3RyYW5zYWN0aW9uX2ZyZWUodHJhbnNhY3Rpb24pOwoJcmV0dXJuIHJldDsKfQoKaW50IHJlZl90cmFuc2FjdGlvbl9jb21taXQoc3RydWN0IHJlZl90cmFuc2FjdGlvbiAqdHJhbnNhY3Rpb24sCgkJCSAgIHN0cnVjdCBzdHJidWYgKmVycikKewoJc3RydWN0IHJlZl9zdG9yZSAqcmVmcyA9IHRyYW5zYWN0aW9uLT5yZWZfc3RvcmU7CglpbnQgcmV0OwoKCXN3aXRjaCAodHJhbnNhY3Rpb24tPnN0YXRlKSB7CgljYXNlIFJFRl9UUkFOU0FDVElPTl9PUEVOOgoJCS8qIE5lZWQgdG8gcHJlcGFyZSBmaXJzdC4gKi8KCQlyZXQgPSByZWZfdHJhbnNhY3Rpb25fcHJlcGFyZSh0cmFuc2FjdGlvbiwgZXJyKTsKCQlpZiAocmV0KQoJCQlyZXR1cm4gcmV0OwoJCWJyZWFrOwoJY2FzZSBSRUZfVFJBTlNBQ1RJT05fUFJFUEFSRUQ6CgkJLyogRmFsbCB0aHJvdWdoIHRvIGZpbmlzaC4gKi8KCQlicmVhazsKCWNhc2UgUkVGX1RSQU5TQUNUSU9OX0NMT1NFRDoKCQlCVUcoImNvbW1pdCBjYWxsZWQgb24gYSBjbG9zZWQgcmVmZXJlbmNlIHRyYW5zYWN0aW9uIik7CgkJYnJlYWs7CglkZWZhdWx0OgoJCUJVRygidW5leHBlY3RlZCByZWZlcmVuY2UgdHJhbnNhY3Rpb24gc3RhdGUiKTsKCQlicmVhazsKCX0KCglyZXQgPSByZWZzLT5iZS0+dHJhbnNhY3Rpb25fZmluaXNoKHJlZnMsIHRyYW5zYWN0aW9uLCBlcnIpOwoJaWYgKCFyZXQpCgkJcnVuX3RyYW5zYWN0aW9uX2hvb2sodHJhbnNhY3Rpb24sICJjb21taXR0ZWQiKTsKCXJldHVybiByZXQ7Cn0KCmludCByZWZzX3ZlcmlmeV9yZWZuYW1lX2F2YWlsYWJsZShzdHJ1Y3QgcmVmX3N0b3JlICpyZWZzLAoJCQkJICBjb25zdCBjaGFyICpyZWZuYW1lLAoJCQkJICBjb25zdCBzdHJ1Y3Qgc3RyaW5nX2xpc3QgKmV4dHJhcywKCQkJCSAgY29uc3Qgc3RydWN0IHN0cmluZ19saXN0ICpza2lwLAoJCQkJICBzdHJ1Y3Qgc3RyYnVmICplcnIpCnsKCWNvbnN0IGNoYXIgKnNsYXNoOwoJY29uc3QgY2hhciAqZXh0cmFfcmVmbmFtZTsKCXN0cnVjdCBzdHJidWYgZGlybmFtZSA9IFNUUkJVRl9JTklUOwoJc3RydWN0IHN0cmJ1ZiByZWZlcmVudCA9IFNUUkJVRl9JTklUOwoJc3RydWN0IG9iamVjdF9pZCBvaWQ7Cgl1bnNpZ25lZCBpbnQgdHlwZTsKCXN0cnVjdCByZWZfaXRlcmF0b3IgKml0ZXI7CglpbnQgb2s7CglpbnQgcmV0ID0gLTE7CgoJLyoKCSAqIEZvciB0aGUgc2FrZSBvZiBjb21tZW50cyBpbiB0aGlzIGZ1bmN0aW9uLCBzdXBwb3NlIHRoYXQKCSAqIHJlZm5hbWUgaXMgInJlZnMvZm9vL2JhciIuCgkgKi8KCglhc3NlcnQoZXJyKTsKCglzdHJidWZfZ3JvdygmZGlybmFtZSwgc3RybGVuKHJlZm5hbWUpICsgMSk7Cglmb3IgKHNsYXNoID0gc3RyY2hyKHJlZm5hbWUsICcvJyk7IHNsYXNoOyBzbGFzaCA9IHN0cmNocihzbGFzaCArIDEsICcvJykpIHsKCQkvKiBFeHBhbmQgZGlybmFtZSB0byB0aGUgbmV3IHByZWZpeCwgbm90IGluY2x1ZGluZyB0aGUgdHJhaWxpbmcgc2xhc2g6ICovCgkJc3RyYnVmX2FkZCgmZGlybmFtZSwgcmVmbmFtZSArIGRpcm5hbWUubGVuLCBzbGFzaCAtIHJlZm5hbWUgLSBkaXJuYW1lLmxlbik7CgoJCS8qCgkJICogV2UgYXJlIHN0aWxsIGF0IGEgbGVhZGluZyBkaXIgb2YgdGhlIHJlZm5hbWUgKGUuZy4sCgkJICogInJlZnMvZm9vIjsgaWYgdGhlcmUgaXMgYSByZWZlcmVuY2Ugd2l0aCB0aGF0IG5hbWUsCgkJICogaXQgaXMgYSBjb25mbGljdCwgKnVubGVzcyogaXQgaXMgaW4gc2tpcC4KCQkgKi8KCQlpZiAoc2tpcCAmJiBzdHJpbmdfbGlzdF9oYXNfc3RyaW5nKHNraXAsIGRpcm5hbWUuYnVmKSkKCQkJY29udGludWU7CgoJCWlmICghcmVmc19yZWFkX3Jhd19yZWYocmVmcywgZGlybmFtZS5idWYsICZvaWQsICZyZWZlcmVudCwgJnR5cGUpKSB7CgkJCXN0cmJ1Zl9hZGRmKGVyciwgXygiJyVzJyBleGlzdHM7IGNhbm5vdCBjcmVhdGUgJyVzJyIpLAoJCQkJICAgIGRpcm5hbWUuYnVmLCByZWZuYW1lKTsKCQkJZ290byBjbGVhbnVwOwoJCX0KCgkJaWYgKGV4dHJhcyAmJiBzdHJpbmdfbGlzdF9oYXNfc3RyaW5nKGV4dHJhcywgZGlybmFtZS5idWYpKSB7CgkJCXN0cmJ1Zl9hZGRmKGVyciwgXygiY2Fubm90IHByb2Nlc3MgJyVzJyBhbmQgJyVzJyBhdCB0aGUgc2FtZSB0aW1lIiksCgkJCQkgICAgcmVmbmFtZSwgZGlybmFtZS5idWYpOwoJCQlnb3RvIGNsZWFudXA7CgkJfQoJfQoKCS8qCgkgKiBXZSBhcmUgYXQgdGhlIGxlYWYgb2Ygb3VyIHJlZm5hbWUgKGUuZy4sICJyZWZzL2Zvby9iYXIiKS4KCSAqIFRoZXJlIGlzIG5vIHBvaW50IGluIHNlYXJjaGluZyBmb3IgYSByZWZlcmVuY2Ugd2l0aCB0aGF0CgkgKiBuYW1lLCBiZWNhdXNlIGEgcmVmbmFtZSBpc24ndCBjb25zaWRlcmVkIHRvIGNvbmZsaWN0IHdpdGgKCSAqIGl0c2VsZi4gQnV0IHdlIHN0aWxsIG5lZWQgdG8gY2hlY2sgZm9yIHJlZmVyZW5jZXMgd2hvc2UKCSAqIG5hbWVzIGFyZSBpbiB0aGUgInJlZnMvZm9vL2Jhci8iIG5hbWVzcGFjZSwgYmVjYXVzZSB0aGV5CgkgKiAqZG8qIGNvbmZsaWN0LgoJICovCglzdHJidWZfYWRkc3RyKCZkaXJuYW1lLCByZWZuYW1lICsgZGlybmFtZS5sZW4pOwoJc3RyYnVmX2FkZGNoKCZkaXJuYW1lLCAnLycpOwoKCWl0ZXIgPSByZWZzX3JlZl9pdGVyYXRvcl9iZWdpbihyZWZzLCBkaXJuYW1lLmJ1ZiwgMCwKCQkJCSAgICAgICBET19GT1JfRUFDSF9JTkNMVURFX0JST0tFTik7Cgl3aGlsZSAoKG9rID0gcmVmX2l0ZXJhdG9yX2FkdmFuY2UoaXRlcikpID09IElURVJfT0spIHsKCQlpZiAoc2tpcCAmJgoJCSAgICBzdHJpbmdfbGlzdF9oYXNfc3RyaW5nKHNraXAsIGl0ZXItPnJlZm5hbWUpKQoJCQljb250aW51ZTsKCgkJc3RyYnVmX2FkZGYoZXJyLCBfKCInJXMnIGV4aXN0czsgY2Fubm90IGNyZWF0ZSAnJXMnIiksCgkJCSAgICBpdGVyLT5yZWZuYW1lLCByZWZuYW1lKTsKCQlyZWZfaXRlcmF0b3JfYWJvcnQoaXRlcik7CgkJZ290byBjbGVhbnVwOwoJfQoKCWlmIChvayAhPSBJVEVSX0RPTkUpCgkJQlVHKCJlcnJvciB3aGlsZSBpdGVyYXRpbmcgb3ZlciByZWZlcmVuY2VzIik7CgoJZXh0cmFfcmVmbmFtZSA9IGZpbmRfZGVzY2VuZGFudF9yZWYoZGlybmFtZS5idWYsIGV4dHJhcywgc2tpcCk7CglpZiAoZXh0cmFfcmVmbmFtZSkKCQlzdHJidWZfYWRkZihlcnIsIF8oImNhbm5vdCBwcm9jZXNzICclcycgYW5kICclcycgYXQgdGhlIHNhbWUgdGltZSIpLAoJCQkgICAgcmVmbmFtZSwgZXh0cmFfcmVmbmFtZSk7CgllbHNlCgkJcmV0ID0gMDsKCmNsZWFudXA6CglzdHJidWZfcmVsZWFzZSgmcmVmZXJlbnQpOwoJc3RyYnVmX3JlbGVhc2UoJmRpcm5hbWUpOwoJcmV0dXJuIHJldDsKfQoKaW50IHJlZnNfZm9yX2VhY2hfcmVmbG9nKHN0cnVjdCByZWZfc3RvcmUgKnJlZnMsIGVhY2hfcmVmX2ZuIGZuLCB2b2lkICpjYl9kYXRhKQp7CglzdHJ1Y3QgcmVmX2l0ZXJhdG9yICppdGVyOwoJc3RydWN0IGRvX2Zvcl9lYWNoX3JlZl9oZWxwIGhwID0geyBmbiwgY2JfZGF0YSB9OwoKCWl0ZXIgPSByZWZzLT5iZS0+cmVmbG9nX2l0ZXJhdG9yX2JlZ2luKHJlZnMpOwoKCXJldHVybiBkb19mb3JfZWFjaF9yZXBvX3JlZl9pdGVyYXRvcih0aGVfcmVwb3NpdG9yeSwgaXRlciwKCQkJCQkgICAgIGRvX2Zvcl9lYWNoX3JlZl9oZWxwZXIsICZocCk7Cn0KCmludCBmb3JfZWFjaF9yZWZsb2coZWFjaF9yZWZfZm4gZm4sIHZvaWQgKmNiX2RhdGEpCnsKCXJldHVybiByZWZzX2Zvcl9lYWNoX3JlZmxvZyhnZXRfbWFpbl9yZWZfc3RvcmUodGhlX3JlcG9zaXRvcnkpLCBmbiwgY2JfZGF0YSk7Cn0KCmludCByZWZzX2Zvcl9lYWNoX3JlZmxvZ19lbnRfcmV2ZXJzZShzdHJ1Y3QgcmVmX3N0b3JlICpyZWZzLAoJCQkJICAgICBjb25zdCBjaGFyICpyZWZuYW1lLAoJCQkJICAgICBlYWNoX3JlZmxvZ19lbnRfZm4gZm4sCgkJCQkgICAgIHZvaWQgKmNiX2RhdGEpCnsKCXJldHVybiByZWZzLT5iZS0+Zm9yX2VhY2hfcmVmbG9nX2VudF9yZXZlcnNlKHJlZnMsIHJlZm5hbWUsCgkJCQkJCSAgICAgZm4sIGNiX2RhdGEpOwp9CgppbnQgZm9yX2VhY2hfcmVmbG9nX2VudF9yZXZlcnNlKGNvbnN0IGNoYXIgKnJlZm5hbWUsIGVhY2hfcmVmbG9nX2VudF9mbiBmbiwKCQkJCXZvaWQgKmNiX2RhdGEpCnsKCXJldHVybiByZWZzX2Zvcl9lYWNoX3JlZmxvZ19lbnRfcmV2ZXJzZShnZXRfbWFpbl9yZWZfc3RvcmUodGhlX3JlcG9zaXRvcnkpLAoJCQkJCQlyZWZuYW1lLCBmbiwgY2JfZGF0YSk7Cn0KCmludCByZWZzX2Zvcl9lYWNoX3JlZmxvZ19lbnQoc3RydWN0IHJlZl9zdG9yZSAqcmVmcywgY29uc3QgY2hhciAqcmVmbmFtZSwKCQkJICAgICBlYWNoX3JlZmxvZ19lbnRfZm4gZm4sIHZvaWQgKmNiX2RhdGEpCnsKCXJldHVybiByZWZzLT5iZS0+Zm9yX2VhY2hfcmVmbG9nX2VudChyZWZzLCByZWZuYW1lLCBmbiwgY2JfZGF0YSk7Cn0KCmludCBmb3JfZWFjaF9yZWZsb2dfZW50KGNvbnN0IGNoYXIgKnJlZm5hbWUsIGVhY2hfcmVmbG9nX2VudF9mbiBmbiwKCQkJdm9pZCAqY2JfZGF0YSkKewoJcmV0dXJuIHJlZnNfZm9yX2VhY2hfcmVmbG9nX2VudChnZXRfbWFpbl9yZWZfc3RvcmUodGhlX3JlcG9zaXRvcnkpLCByZWZuYW1lLAoJCQkJCWZuLCBjYl9kYXRhKTsKfQoKaW50IHJlZnNfcmVmbG9nX2V4aXN0cyhzdHJ1Y3QgcmVmX3N0b3JlICpyZWZzLCBjb25zdCBjaGFyICpyZWZuYW1lKQp7CglyZXR1cm4gcmVmcy0+YmUtPnJlZmxvZ19leGlzdHMocmVmcywgcmVmbmFtZSk7Cn0KCmludCByZWZsb2dfZXhpc3RzKGNvbnN0IGNoYXIgKnJlZm5hbWUpCnsKCXJldHVybiByZWZzX3JlZmxvZ19leGlzdHMoZ2V0X21haW5fcmVmX3N0b3JlKHRoZV9yZXBvc2l0b3J5KSwgcmVmbmFtZSk7Cn0KCmludCByZWZzX2NyZWF0ZV9yZWZsb2coc3RydWN0IHJlZl9zdG9yZSAqcmVmcywgY29uc3QgY2hhciAqcmVmbmFtZSwKCQkgICAgICAgaW50IGZvcmNlX2NyZWF0ZSwgc3RydWN0IHN0cmJ1ZiAqZXJyKQp7CglyZXR1cm4gcmVmcy0+YmUtPmNyZWF0ZV9yZWZsb2cocmVmcywgcmVmbmFtZSwgZm9yY2VfY3JlYXRlLCBlcnIpOwp9CgppbnQgc2FmZV9jcmVhdGVfcmVmbG9nKGNvbnN0IGNoYXIgKnJlZm5hbWUsIGludCBmb3JjZV9jcmVhdGUsCgkJICAgICAgIHN0cnVjdCBzdHJidWYgKmVycikKewoJcmV0dXJuIHJlZnNfY3JlYXRlX3JlZmxvZyhnZXRfbWFpbl9yZWZfc3RvcmUodGhlX3JlcG9zaXRvcnkpLCByZWZuYW1lLAoJCQkJICBmb3JjZV9jcmVhdGUsIGVycik7Cn0KCmludCByZWZzX2RlbGV0ZV9yZWZsb2coc3RydWN0IHJlZl9zdG9yZSAqcmVmcywgY29uc3QgY2hhciAqcmVmbmFtZSkKewoJcmV0dXJuIHJlZnMtPmJlLT5kZWxldGVfcmVmbG9nKHJlZnMsIHJlZm5hbWUpOwp9CgppbnQgZGVsZXRlX3JlZmxvZyhjb25zdCBjaGFyICpyZWZuYW1lKQp7CglyZXR1cm4gcmVmc19kZWxldGVfcmVmbG9nKGdldF9tYWluX3JlZl9zdG9yZSh0aGVfcmVwb3NpdG9yeSksIHJlZm5hbWUpOwp9CgppbnQgcmVmc19yZWZsb2dfZXhwaXJlKHN0cnVjdCByZWZfc3RvcmUgKnJlZnMsCgkJICAgICAgIGNvbnN0IGNoYXIgKnJlZm5hbWUsIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwKCQkgICAgICAgdW5zaWduZWQgaW50IGZsYWdzLAoJCSAgICAgICByZWZsb2dfZXhwaXJ5X3ByZXBhcmVfZm4gcHJlcGFyZV9mbiwKCQkgICAgICAgcmVmbG9nX2V4cGlyeV9zaG91bGRfcHJ1bmVfZm4gc2hvdWxkX3BydW5lX2ZuLAoJCSAgICAgICByZWZsb2dfZXhwaXJ5X2NsZWFudXBfZm4gY2xlYW51cF9mbiwKCQkgICAgICAgdm9pZCAqcG9saWN5X2NiX2RhdGEpCnsKCXJldHVybiByZWZzLT5iZS0+cmVmbG9nX2V4cGlyZShyZWZzLCByZWZuYW1lLCBvaWQsIGZsYWdzLAoJCQkJICAgICAgIHByZXBhcmVfZm4sIHNob3VsZF9wcnVuZV9mbiwKCQkJCSAgICAgICBjbGVhbnVwX2ZuLCBwb2xpY3lfY2JfZGF0YSk7Cn0KCmludCByZWZsb2dfZXhwaXJlKGNvbnN0IGNoYXIgKnJlZm5hbWUsIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwKCQkgIHVuc2lnbmVkIGludCBmbGFncywKCQkgIHJlZmxvZ19leHBpcnlfcHJlcGFyZV9mbiBwcmVwYXJlX2ZuLAoJCSAgcmVmbG9nX2V4cGlyeV9zaG91bGRfcHJ1bmVfZm4gc2hvdWxkX3BydW5lX2ZuLAoJCSAgcmVmbG9nX2V4cGlyeV9jbGVhbnVwX2ZuIGNsZWFudXBfZm4sCgkJICB2b2lkICpwb2xpY3lfY2JfZGF0YSkKewoJcmV0dXJuIHJlZnNfcmVmbG9nX2V4cGlyZShnZXRfbWFpbl9yZWZfc3RvcmUodGhlX3JlcG9zaXRvcnkpLAoJCQkJICByZWZuYW1lLCBvaWQsIGZsYWdzLAoJCQkJICBwcmVwYXJlX2ZuLCBzaG91bGRfcHJ1bmVfZm4sCgkJCQkgIGNsZWFudXBfZm4sIHBvbGljeV9jYl9kYXRhKTsKfQoKaW50IGluaXRpYWxfcmVmX3RyYW5zYWN0aW9uX2NvbW1pdChzdHJ1Y3QgcmVmX3RyYW5zYWN0aW9uICp0cmFuc2FjdGlvbiwKCQkJCSAgIHN0cnVjdCBzdHJidWYgKmVycikKewoJc3RydWN0IHJlZl9zdG9yZSAqcmVmcyA9IHRyYW5zYWN0aW9uLT5yZWZfc3RvcmU7CgoJcmV0dXJuIHJlZnMtPmJlLT5pbml0aWFsX3RyYW5zYWN0aW9uX2NvbW1pdChyZWZzLCB0cmFuc2FjdGlvbiwgZXJyKTsKfQoKaW50IHJlZnNfZGVsZXRlX3JlZnMoc3RydWN0IHJlZl9zdG9yZSAqcmVmcywgY29uc3QgY2hhciAqbXNnLAoJCSAgICAgc3RydWN0IHN0cmluZ19saXN0ICpyZWZuYW1lcywgdW5zaWduZWQgaW50IGZsYWdzKQp7CglyZXR1cm4gcmVmcy0+YmUtPmRlbGV0ZV9yZWZzKHJlZnMsIG1zZywgcmVmbmFtZXMsIGZsYWdzKTsKfQoKaW50IGRlbGV0ZV9yZWZzKGNvbnN0IGNoYXIgKm1zZywgc3RydWN0IHN0cmluZ19saXN0ICpyZWZuYW1lcywKCQl1bnNpZ25lZCBpbnQgZmxhZ3MpCnsKCXJldHVybiByZWZzX2RlbGV0ZV9yZWZzKGdldF9tYWluX3JlZl9zdG9yZSh0aGVfcmVwb3NpdG9yeSksIG1zZywgcmVmbmFtZXMsIGZsYWdzKTsKfQoKaW50IHJlZnNfcmVuYW1lX3JlZihzdHJ1Y3QgcmVmX3N0b3JlICpyZWZzLCBjb25zdCBjaGFyICpvbGRyZWYsCgkJICAgIGNvbnN0IGNoYXIgKm5ld3JlZiwgY29uc3QgY2hhciAqbG9nbXNnKQp7CglyZXR1cm4gcmVmcy0+YmUtPnJlbmFtZV9yZWYocmVmcywgb2xkcmVmLCBuZXdyZWYsIGxvZ21zZyk7Cn0KCmludCByZW5hbWVfcmVmKGNvbnN0IGNoYXIgKm9sZHJlZiwgY29uc3QgY2hhciAqbmV3cmVmLCBjb25zdCBjaGFyICpsb2dtc2cpCnsKCXJldHVybiByZWZzX3JlbmFtZV9yZWYoZ2V0X21haW5fcmVmX3N0b3JlKHRoZV9yZXBvc2l0b3J5KSwgb2xkcmVmLCBuZXdyZWYsIGxvZ21zZyk7Cn0KCmludCByZWZzX2NvcHlfZXhpc3RpbmdfcmVmKHN0cnVjdCByZWZfc3RvcmUgKnJlZnMsIGNvbnN0IGNoYXIgKm9sZHJlZiwKCQkgICAgY29uc3QgY2hhciAqbmV3cmVmLCBjb25zdCBjaGFyICpsb2dtc2cpCnsKCXJldHVybiByZWZzLT5iZS0+Y29weV9yZWYocmVmcywgb2xkcmVmLCBuZXdyZWYsIGxvZ21zZyk7Cn0KCmludCBjb3B5X2V4aXN0aW5nX3JlZihjb25zdCBjaGFyICpvbGRyZWYsIGNvbnN0IGNoYXIgKm5ld3JlZiwgY29uc3QgY2hhciAqbG9nbXNnKQp7CglyZXR1cm4gcmVmc19jb3B5X2V4aXN0aW5nX3JlZihnZXRfbWFpbl9yZWZfc3RvcmUodGhlX3JlcG9zaXRvcnkpLCBvbGRyZWYsIG5ld3JlZiwgbG9nbXNnKTsKfQo=",
    "text": "/*\n * The backend-independent part of the reference module.\n */\n\n#include \"cache.h\"\n#include \"config.h\"\n#include \"hashmap.h\"\n#include \"lockfile.h\"\n#include \"iterator.h\"\n#include \"refs.h\"\n#include \"refs/refs-internal.h\"\n#include \"run-command.h\"\n#include \"object-store.h\"\n#include \"object.h\"\n#include \"tag.h\"\n#include \"submodule.h\"\n#include \"worktree.h\"\n#include \"strvec.h\"\n#include \"repository.h\"\n#include \"sigchain.h\"\n\n/*\n * List of all available backends\n */\nstatic struct ref_storage_be *refs_backends = &refs_be_files;\n\nstatic struct ref_storage_be *find_ref_storage_backend(const char *name)\n{\n\tstruct ref_storage_be *be;\n\tfor (be = refs_backends; be; be = be->next)\n\t\tif (!strcmp(be->name, name))\n\t\t\treturn be;\n\treturn NULL;\n}\n\nint ref_storage_backend_exists(const char *name)\n{\n\treturn find_ref_storage_backend(name) != NULL;\n}\n\n/*\n * How to handle various characters in refnames:\n * 0: An acceptable character for refs\n * 1: End-of-component\n * 2: ., look for a preceding . to reject .. in refs\n * 3: {, look for a preceding @ to reject @{ in refs\n * 4: A bad character: ASCII control characters, and\n *    \":\", \"?\", \"[\", \"\\\", \"^\", \"~\", SP, or TAB\n * 5: *, reject unless REFNAME_REFSPEC_PATTERN is set\n */\nstatic unsigned char refname_disposition[256] = {\n\t1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n\t4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n\t4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 2, 1,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 4,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 4, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 4, 4\n};\n\n/*\n * Try to read one refname component from the front of refname.\n * Return the length of the component found, or -1 if the component is\n * not legal.  It is legal if it is something reasonable to have under\n * \".git/refs/\"; We do not like it if:\n *\n * - it begins with \".\", or\n * - it has double dots \"..\", or\n * - it has ASCII control characters, or\n * - it has \":\", \"?\", \"[\", \"\\\", \"^\", \"~\", SP, or TAB anywhere, or\n * - it has \"*\" anywhere unless REFNAME_REFSPEC_PATTERN is set, or\n * - it ends with a \"/\", or\n * - it ends with \".lock\", or\n * - it contains a \"@{\" portion\n *\n * When sanitized is not NULL, instead of rejecting the input refname\n * as an error, try to come up with a usable replacement for the input\n * refname in it.\n */\nstatic int check_refname_component(const char *refname, int *flags,\n\t\t\t\t   struct strbuf *sanitized)\n{\n\tconst char *cp;\n\tchar last = '\\0';\n\tsize_t component_start = 0; /* garbage - not a reasonable initial value */\n\n\tif (sanitized)\n\t\tcomponent_start = sanitized->len;\n\n\tfor (cp = refname; ; cp++) {\n\t\tint ch = *cp & 255;\n\t\tunsigned char disp = refname_disposition[ch];\n\n\t\tif (sanitized && disp != 1)\n\t\t\tstrbuf_addch(sanitized, ch);\n\n\t\tswitch (disp) {\n\t\tcase 1:\n\t\t\tgoto out;\n\t\tcase 2:\n\t\t\tif (last == '.') { /* Refname contains \"..\". */\n\t\t\t\tif (sanitized)\n\t\t\t\t\t/* collapse \"..\" to single \".\" */\n\t\t\t\t\tstrbuf_setlen(sanitized, sanitized->len - 1);\n\t\t\t\telse\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (last == '@') { /* Refname contains \"@{\". */\n\t\t\t\tif (sanitized)\n\t\t\t\t\tsanitized->buf[sanitized->len-1] = '-';\n\t\t\t\telse\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\t/* forbidden char */\n\t\t\tif (sanitized)\n\t\t\t\tsanitized->buf[sanitized->len-1] = '-';\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tif (!(*flags & REFNAME_REFSPEC_PATTERN)) {\n\t\t\t\t/* refspec can't be a pattern */\n\t\t\t\tif (sanitized)\n\t\t\t\t\tsanitized->buf[sanitized->len-1] = '-';\n\t\t\t\telse\n\t\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Unset the pattern flag so that we only accept\n\t\t\t * a single asterisk for one side of refspec.\n\t\t\t */\n\t\t\t*flags &= ~ REFNAME_REFSPEC_PATTERN;\n\t\t\tbreak;\n\t\t}\n\t\tlast = ch;\n\t}\nout:\n\tif (cp == refname)\n\t\treturn 0; /* Component has zero length. */\n\n\tif (refname[0] == '.') { /* Component starts with '.'. */\n\t\tif (sanitized)\n\t\t\tsanitized->buf[component_start] = '-';\n\t\telse\n\t\t\treturn -1;\n\t}\n\tif (cp - refname >= LOCK_SUFFIX_LEN &&\n\t    !memcmp(cp - LOCK_SUFFIX_LEN, LOCK_SUFFIX, LOCK_SUFFIX_LEN)) {\n\t\tif (!sanitized)\n\t\t\treturn -1;\n\t\t/* Refname ends with \".lock\". */\n\t\twhile (strbuf_strip_suffix(sanitized, LOCK_SUFFIX)) {\n\t\t\t/* try again in case we have .lock.lock */\n\t\t}\n\t}\n\treturn cp - refname;\n}\n\nstatic int check_or_sanitize_refname(const char *refname, int flags,\n\t\t\t\t     struct strbuf *sanitized)\n{\n\tint component_len, component_count = 0;\n\n\tif (!strcmp(refname, \"@\")) {\n\t\t/* Refname is a single character '@'. */\n\t\tif (sanitized)\n\t\t\tstrbuf_addch(sanitized, '-');\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\twhile (1) {\n\t\tif (sanitized && sanitized->len)\n\t\t\tstrbuf_complete(sanitized, '/');\n\n\t\t/* We are at the start of a path component. */\n\t\tcomponent_len = check_refname_component(refname, &flags,\n\t\t\t\t\t\t\tsanitized);\n\t\tif (sanitized && component_len == 0)\n\t\t\t; /* OK, omit empty component */\n\t\telse if (component_len <= 0)\n\t\t\treturn -1;\n\n\t\tcomponent_count++;\n\t\tif (refname[component_len] == '\\0')\n\t\t\tbreak;\n\t\t/* Skip to next component. */\n\t\trefname += component_len + 1;\n\t}\n\n\tif (refname[component_len - 1] == '.') {\n\t\t/* Refname ends with '.'. */\n\t\tif (sanitized)\n\t\t\t; /* omit ending dot */\n\t\telse\n\t\t\treturn -1;\n\t}\n\tif (!(flags & REFNAME_ALLOW_ONELEVEL) && component_count < 2)\n\t\treturn -1; /* Refname has only one component. */\n\treturn 0;\n}\n\nint check_refname_format(const char *refname, int flags)\n{\n\treturn check_or_sanitize_refname(refname, flags, NULL);\n}\n\nvoid sanitize_refname_component(const char *refname, struct strbuf *out)\n{\n\tif (check_or_sanitize_refname(refname, REFNAME_ALLOW_ONELEVEL, out))\n\t\tBUG(\"sanitizing refname '%s' check returned error\", refname);\n}\n\nint refname_is_safe(const char *refname)\n{\n\tconst char *rest;\n\n\tif (skip_prefix(refname, \"refs/\", &rest)) {\n\t\tchar *buf;\n\t\tint result;\n\t\tsize_t restlen = strlen(rest);\n\n\t\t/* rest must not be empty, or start or end with \"/\" */\n\t\tif (!restlen || *rest == '/' || rest[restlen - 1] == '/')\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * Does the refname try to escape refs/?\n\t\t * For example: refs/foo/../bar is safe but refs/foo/../../bar\n\t\t * is not.\n\t\t */\n\t\tbuf = xmallocz(restlen);\n\t\tresult = !normalize_path_copy(buf, rest) && !strcmp(buf, rest);\n\t\tfree(buf);\n\t\treturn result;\n\t}\n\n\tdo {\n\t\tif (!isupper(*refname) && *refname != '_')\n\t\t\treturn 0;\n\t\trefname++;\n\t} while (*refname);\n\treturn 1;\n}\n\n/*\n * Return true if refname, which has the specified oid and flags, can\n * be resolved to an object in the database. If the referred-to object\n * does not exist, emit a warning and return false.\n */\nint ref_resolves_to_object(const char *refname,\n\t\t\t   const struct object_id *oid,\n\t\t\t   unsigned int flags)\n{\n\tif (flags & REF_ISBROKEN)\n\t\treturn 0;\n\tif (!has_object_file(oid)) {\n\t\terror(_(\"%s does not point to a valid object!\"), refname);\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nchar *refs_resolve_refdup(struct ref_store *refs,\n\t\t\t  const char *refname, int resolve_flags,\n\t\t\t  struct object_id *oid, int *flags)\n{\n\tconst char *result;\n\n\tresult = refs_resolve_ref_unsafe(refs, refname, resolve_flags,\n\t\t\t\t\t oid, flags);\n\treturn xstrdup_or_null(result);\n}\n\nchar *resolve_refdup(const char *refname, int resolve_flags,\n\t\t     struct object_id *oid, int *flags)\n{\n\treturn refs_resolve_refdup(get_main_ref_store(the_repository),\n\t\t\t\t   refname, resolve_flags,\n\t\t\t\t   oid, flags);\n}\n\n/* The argument to filter_refs */\nstruct ref_filter {\n\tconst char *pattern;\n\tconst char *prefix;\n\teach_ref_fn *fn;\n\tvoid *cb_data;\n};\n\nint refs_read_ref_full(struct ref_store *refs, const char *refname,\n\t\t       int resolve_flags, struct object_id *oid, int *flags)\n{\n\tif (refs_resolve_ref_unsafe(refs, refname, resolve_flags, oid, flags))\n\t\treturn 0;\n\treturn -1;\n}\n\nint read_ref_full(const char *refname, int resolve_flags, struct object_id *oid, int *flags)\n{\n\treturn refs_read_ref_full(get_main_ref_store(the_repository), refname,\n\t\t\t\t  resolve_flags, oid, flags);\n}\n\nint read_ref(const char *refname, struct object_id *oid)\n{\n\treturn read_ref_full(refname, RESOLVE_REF_READING, oid, NULL);\n}\n\nstatic int refs_ref_exists(struct ref_store *refs, const char *refname)\n{\n\treturn !!refs_resolve_ref_unsafe(refs, refname, RESOLVE_REF_READING, NULL, NULL);\n}\n\nint ref_exists(const char *refname)\n{\n\treturn refs_ref_exists(get_main_ref_store(the_repository), refname);\n}\n\nstatic int filter_refs(const char *refname, const struct object_id *oid,\n\t\t\t   int flags, void *data)\n{\n\tstruct ref_filter *filter = (struct ref_filter *)data;\n\n\tif (wildmatch(filter->pattern, refname, 0))\n\t\treturn 0;\n\tif (filter->prefix)\n\t\tskip_prefix(refname, filter->prefix, &refname);\n\treturn filter->fn(refname, oid, flags, filter->cb_data);\n}\n\nenum peel_status peel_object(const struct object_id *name, struct object_id *oid)\n{\n\tstruct object *o = lookup_unknown_object(name);\n\n\tif (o->type == OBJ_NONE) {\n\t\tint type = oid_object_info(the_repository, name, NULL);\n\t\tif (type < 0 || !object_as_type(o, type, 0))\n\t\t\treturn PEEL_INVALID;\n\t}\n\n\tif (o->type != OBJ_TAG)\n\t\treturn PEEL_NON_TAG;\n\n\to = deref_tag_noverify(o);\n\tif (!o)\n\t\treturn PEEL_INVALID;\n\n\toidcpy(oid, &o->oid);\n\treturn PEEL_PEELED;\n}\n\nstruct warn_if_dangling_data {\n\tFILE *fp;\n\tconst char *refname;\n\tconst struct string_list *refnames;\n\tconst char *msg_fmt;\n};\n\nstatic int warn_if_dangling_symref(const char *refname, const struct object_id *oid,\n\t\t\t\t   int flags, void *cb_data)\n{\n\tstruct warn_if_dangling_data *d = cb_data;\n\tconst char *resolves_to;\n\n\tif (!(flags & REF_ISSYMREF))\n\t\treturn 0;\n\n\tresolves_to = resolve_ref_unsafe(refname, 0, NULL, NULL);\n\tif (!resolves_to\n\t    || (d->refname\n\t\t? strcmp(resolves_to, d->refname)\n\t\t: !string_list_has_string(d->refnames, resolves_to))) {\n\t\treturn 0;\n\t}\n\n\tfprintf(d->fp, d->msg_fmt, refname);\n\tfputc('\\n', d->fp);\n\treturn 0;\n}\n\nvoid warn_dangling_symref(FILE *fp, const char *msg_fmt, const char *refname)\n{\n\tstruct warn_if_dangling_data data;\n\n\tdata.fp = fp;\n\tdata.refname = refname;\n\tdata.refnames = NULL;\n\tdata.msg_fmt = msg_fmt;\n\tfor_each_rawref(warn_if_dangling_symref, &data);\n}\n\nvoid warn_dangling_symrefs(FILE *fp, const char *msg_fmt, const struct string_list *refnames)\n{\n\tstruct warn_if_dangling_data data;\n\n\tdata.fp = fp;\n\tdata.refname = NULL;\n\tdata.refnames = refnames;\n\tdata.msg_fmt = msg_fmt;\n\tfor_each_rawref(warn_if_dangling_symref, &data);\n}\n\nint refs_for_each_tag_ref(struct ref_store *refs, each_ref_fn fn, void *cb_data)\n{\n\treturn refs_for_each_ref_in(refs, \"refs/tags/\", fn, cb_data);\n}\n\nint for_each_tag_ref(each_ref_fn fn, void *cb_data)\n{\n\treturn refs_for_each_tag_ref(get_main_ref_store(the_repository), fn, cb_data);\n}\n\nint refs_for_each_branch_ref(struct ref_store *refs, each_ref_fn fn, void *cb_data)\n{\n\treturn refs_for_each_ref_in(refs, \"refs/heads/\", fn, cb_data);\n}\n\nint for_each_branch_ref(each_ref_fn fn, void *cb_data)\n{\n\treturn refs_for_each_branch_ref(get_main_ref_store(the_repository), fn, cb_data);\n}\n\nint refs_for_each_remote_ref(struct ref_store *refs, each_ref_fn fn, void *cb_data)\n{\n\treturn refs_for_each_ref_in(refs, \"refs/remotes/\", fn, cb_data);\n}\n\nint for_each_remote_ref(each_ref_fn fn, void *cb_data)\n{\n\treturn refs_for_each_remote_ref(get_main_ref_store(the_repository), fn, cb_data);\n}\n\nint head_ref_namespaced(each_ref_fn fn, void *cb_data)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tint ret = 0;\n\tstruct object_id oid;\n\tint flag;\n\n\tstrbuf_addf(&buf, \"%sHEAD\", get_git_namespace());\n\tif (!read_ref_full(buf.buf, RESOLVE_REF_READING, &oid, &flag))\n\t\tret = fn(buf.buf, &oid, flag, cb_data);\n\tstrbuf_release(&buf);\n\n\treturn ret;\n}\n\nvoid normalize_glob_ref(struct string_list_item *item, const char *prefix,\n\t\t\tconst char *pattern)\n{\n\tstruct strbuf normalized_pattern = STRBUF_INIT;\n\n\tif (*pattern == '/')\n\t\tBUG(\"pattern must not start with '/'\");\n\n\tif (prefix) {\n\t\tstrbuf_addstr(&normalized_pattern, prefix);\n\t}\n\telse if (!starts_with(pattern, \"refs/\"))\n\t\tstrbuf_addstr(&normalized_pattern, \"refs/\");\n\tstrbuf_addstr(&normalized_pattern, pattern);\n\tstrbuf_strip_suffix(&normalized_pattern, \"/\");\n\n\titem->string = strbuf_detach(&normalized_pattern, NULL);\n\titem->util = has_glob_specials(pattern) ? NULL : item->string;\n\tstrbuf_release(&normalized_pattern);\n}\n\nint for_each_glob_ref_in(each_ref_fn fn, const char *pattern,\n\tconst char *prefix, void *cb_data)\n{\n\tstruct strbuf real_pattern = STRBUF_INIT;\n\tstruct ref_filter filter;\n\tint ret;\n\n\tif (!prefix && !starts_with(pattern, \"refs/\"))\n\t\tstrbuf_addstr(&real_pattern, \"refs/\");\n\telse if (prefix)\n\t\tstrbuf_addstr(&real_pattern, prefix);\n\tstrbuf_addstr(&real_pattern, pattern);\n\n\tif (!has_glob_specials(pattern)) {\n\t\t/* Append implied '/' '*' if not present. */\n\t\tstrbuf_complete(&real_pattern, '/');\n\t\t/* No need to check for '*', there is none. */\n\t\tstrbuf_addch(&real_pattern, '*');\n\t}\n\n\tfilter.pattern = real_pattern.buf;\n\tfilter.prefix = prefix;\n\tfilter.fn = fn;\n\tfilter.cb_data = cb_data;\n\tret = for_each_ref(filter_refs, &filter);\n\n\tstrbuf_release(&real_pattern);\n\treturn ret;\n}\n\nint for_each_glob_ref(each_ref_fn fn, const char *pattern, void *cb_data)\n{\n\treturn for_each_glob_ref_in(fn, pattern, NULL, cb_data);\n}\n\nconst char *prettify_refname(const char *name)\n{\n\tif (skip_prefix(name, \"refs/heads/\", &name) ||\n\t    skip_prefix(name, \"refs/tags/\", &name) ||\n\t    skip_prefix(name, \"refs/remotes/\", &name))\n\t\t; /* nothing */\n\treturn name;\n}\n\nstatic const char *ref_rev_parse_rules[] = {\n\t\"%.*s\",\n\t\"refs/%.*s\",\n\t\"refs/tags/%.*s\",\n\t\"refs/heads/%.*s\",\n\t\"refs/remotes/%.*s\",\n\t\"refs/remotes/%.*s/HEAD\",\n\tNULL\n};\n\n#define NUM_REV_PARSE_RULES (ARRAY_SIZE(ref_rev_parse_rules) - 1)\n\n/*\n * Is it possible that the caller meant full_name with abbrev_name?\n * If so return a non-zero value to signal \"yes\"; the magnitude of\n * the returned value gives the precedence used for disambiguation.\n *\n * If abbrev_name cannot mean full_name, return 0.\n */\nint refname_match(const char *abbrev_name, const char *full_name)\n{\n\tconst char **p;\n\tconst int abbrev_name_len = strlen(abbrev_name);\n\tconst int num_rules = NUM_REV_PARSE_RULES;\n\n\tfor (p = ref_rev_parse_rules; *p; p++)\n\t\tif (!strcmp(full_name, mkpath(*p, abbrev_name_len, abbrev_name)))\n\t\t\treturn &ref_rev_parse_rules[num_rules] - p;\n\n\treturn 0;\n}\n\n/*\n * Given a 'prefix' expand it by the rules in 'ref_rev_parse_rules' and add\n * the results to 'prefixes'\n */\nvoid expand_ref_prefix(struct argv_array *prefixes, const char *prefix)\n{\n\tconst char **p;\n\tint len = strlen(prefix);\n\n\tfor (p = ref_rev_parse_rules; *p; p++)\n\t\targv_array_pushf(prefixes, *p, len, prefix);\n}\n\nchar *repo_default_branch_name(struct repository *r)\n{\n\tconst char *config_key = \"init.defaultbranch\";\n\tconst char *config_display_key = \"init.defaultBranch\";\n\tchar *ret = NULL, *full_ref;\n\n\tif (repo_config_get_string(r, config_key, &ret) < 0)\n\t\tdie(_(\"could not retrieve `%s`\"), config_display_key);\n\n\tif (!ret)\n\t\tret = xstrdup(\"master\");\n\n\tfull_ref = xstrfmt(\"refs/heads/%s\", ret);\n\tif (check_refname_format(full_ref, 0))\n\t\tdie(_(\"invalid branch name: %s = %s\"), config_display_key, ret);\n\tfree(full_ref);\n\n\treturn ret;\n}\n\nconst char *git_default_branch_name(void)\n{\n\tstatic char *ret;\n\n\tif (!ret)\n\t\tret = repo_default_branch_name(the_repository);\n\n\treturn ret;\n}\n\n/*\n * *string and *len will only be substituted, and *string returned (for\n * later free()ing) if the string passed in is a magic short-hand form\n * to name a branch.\n */\nstatic char *substitute_branch_name(struct repository *r,\n\t\t\t\t    const char **string, int *len)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tint ret = repo_interpret_branch_name(r, *string, *len, &buf, 0);\n\n\tif (ret == *len) {\n\t\tsize_t size;\n\t\t*string = strbuf_detach(&buf, &size);\n\t\t*len = size;\n\t\treturn (char *)*string;\n\t}\n\n\treturn NULL;\n}\n\nint repo_dwim_ref(struct repository *r, const char *str, int len,\n\t\t  struct object_id *oid, char **ref)\n{\n\tchar *last_branch = substitute_branch_name(r, &str, &len);\n\tint   refs_found  = expand_ref(r, str, len, oid, ref);\n\tfree(last_branch);\n\treturn refs_found;\n}\n\nint dwim_ref(const char *str, int len, struct object_id *oid, char **ref)\n{\n\treturn repo_dwim_ref(the_repository, str, len, oid, ref);\n}\n\nint expand_ref(struct repository *repo, const char *str, int len,\n\t       struct object_id *oid, char **ref)\n{\n\tconst char **p, *r;\n\tint refs_found = 0;\n\tstruct strbuf fullref = STRBUF_INIT;\n\n\t*ref = NULL;\n\tfor (p = ref_rev_parse_rules; *p; p++) {\n\t\tstruct object_id oid_from_ref;\n\t\tstruct object_id *this_result;\n\t\tint flag;\n\n\t\tthis_result = refs_found ? &oid_from_ref : oid;\n\t\tstrbuf_reset(&fullref);\n\t\tstrbuf_addf(&fullref, *p, len, str);\n\t\tr = refs_resolve_ref_unsafe(get_main_ref_store(repo),\n\t\t\t\t\t    fullref.buf, RESOLVE_REF_READING,\n\t\t\t\t\t    this_result, &flag);\n\t\tif (r) {\n\t\t\tif (!refs_found++)\n\t\t\t\t*ref = xstrdup(r);\n\t\t\tif (!warn_ambiguous_refs)\n\t\t\t\tbreak;\n\t\t} else if ((flag & REF_ISSYMREF) && strcmp(fullref.buf, \"HEAD\")) {\n\t\t\twarning(_(\"ignoring dangling symref %s\"), fullref.buf);\n\t\t} else if ((flag & REF_ISBROKEN) && strchr(fullref.buf, '/')) {\n\t\t\twarning(_(\"ignoring broken ref %s\"), fullref.buf);\n\t\t}\n\t}\n\tstrbuf_release(&fullref);\n\treturn refs_found;\n}\n\nint repo_dwim_log(struct repository *r, const char *str, int len,\n\t\t  struct object_id *oid, char **log)\n{\n\tstruct ref_store *refs = get_main_ref_store(r);\n\tchar *last_branch = substitute_branch_name(r, &str, &len);\n\tconst char **p;\n\tint logs_found = 0;\n\tstruct strbuf path = STRBUF_INIT;\n\n\t*log = NULL;\n\tfor (p = ref_rev_parse_rules; *p; p++) {\n\t\tstruct object_id hash;\n\t\tconst char *ref, *it;\n\n\t\tstrbuf_reset(&path);\n\t\tstrbuf_addf(&path, *p, len, str);\n\t\tref = refs_resolve_ref_unsafe(refs, path.buf,\n\t\t\t\t\t      RESOLVE_REF_READING,\n\t\t\t\t\t      &hash, NULL);\n\t\tif (!ref)\n\t\t\tcontinue;\n\t\tif (refs_reflog_exists(refs, path.buf))\n\t\t\tit = path.buf;\n\t\telse if (strcmp(ref, path.buf) &&\n\t\t\t refs_reflog_exists(refs, ref))\n\t\t\tit = ref;\n\t\telse\n\t\t\tcontinue;\n\t\tif (!logs_found++) {\n\t\t\t*log = xstrdup(it);\n\t\t\toidcpy(oid, &hash);\n\t\t}\n\t\tif (!warn_ambiguous_refs)\n\t\t\tbreak;\n\t}\n\tstrbuf_release(&path);\n\tfree(last_branch);\n\treturn logs_found;\n}\n\nint dwim_log(const char *str, int len, struct object_id *oid, char **log)\n{\n\treturn repo_dwim_log(the_repository, str, len, oid, log);\n}\n\nstatic int is_per_worktree_ref(const char *refname)\n{\n\treturn !strcmp(refname, \"HEAD\") ||\n\t\tstarts_with(refname, \"refs/worktree/\") ||\n\t\tstarts_with(refname, \"refs/bisect/\") ||\n\t\tstarts_with(refname, \"refs/rewritten/\");\n}\n\nstatic int is_pseudoref_syntax(const char *refname)\n{\n\tconst char *c;\n\n\tfor (c = refname; *c; c++) {\n\t\tif (!isupper(*c) && *c != '-' && *c != '_')\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int is_main_pseudoref_syntax(const char *refname)\n{\n\treturn skip_prefix(refname, \"main-worktree/\", &refname) &&\n\t\t*refname &&\n\t\tis_pseudoref_syntax(refname);\n}\n\nstatic int is_other_pseudoref_syntax(const char *refname)\n{\n\tif (!skip_prefix(refname, \"worktrees/\", &refname))\n\t\treturn 0;\n\trefname = strchr(refname, '/');\n\tif (!refname || !refname[1])\n\t\treturn 0;\n\treturn is_pseudoref_syntax(refname + 1);\n}\n\nenum ref_type ref_type(const char *refname)\n{\n\tif (is_per_worktree_ref(refname))\n\t\treturn REF_TYPE_PER_WORKTREE;\n\tif (is_pseudoref_syntax(refname))\n\t\treturn REF_TYPE_PSEUDOREF;\n\tif (is_main_pseudoref_syntax(refname))\n\t\treturn REF_TYPE_MAIN_PSEUDOREF;\n\tif (is_other_pseudoref_syntax(refname))\n\t\treturn REF_TYPE_OTHER_PSEUDOREF;\n\treturn REF_TYPE_NORMAL;\n}\n\nlong get_files_ref_lock_timeout_ms(void)\n{\n\tstatic int configured = 0;\n\n\t/* The default timeout is 100 ms: */\n\tstatic int timeout_ms = 100;\n\n\tif (!configured) {\n\t\tgit_config_get_int(\"core.filesreflocktimeout\", &timeout_ms);\n\t\tconfigured = 1;\n\t}\n\n\treturn timeout_ms;\n}\n\nstatic int write_pseudoref(const char *pseudoref, const struct object_id *oid,\n\t\t\t   const struct object_id *old_oid, struct strbuf *err)\n{\n\tconst char *filename;\n\tint fd;\n\tstruct lock_file lock = LOCK_INIT;\n\tstruct strbuf buf = STRBUF_INIT;\n\tint ret = -1;\n\n\tif (!oid)\n\t\treturn 0;\n\n\tstrbuf_addf(&buf, \"%s\\n\", oid_to_hex(oid));\n\n\tfilename = git_path(\"%s\", pseudoref);\n\tfd = hold_lock_file_for_update_timeout(&lock, filename, 0,\n\t\t\t\t\t       get_files_ref_lock_timeout_ms());\n\tif (fd < 0) {\n\t\tstrbuf_addf(err, _(\"could not open '%s' for writing: %s\"),\n\t\t\t    filename, strerror(errno));\n\t\tgoto done;\n\t}\n\n\tif (old_oid) {\n\t\tstruct object_id actual_old_oid;\n\n\t\tif (read_ref(pseudoref, &actual_old_oid)) {\n\t\t\tif (!is_null_oid(old_oid)) {\n\t\t\t\tstrbuf_addf(err, _(\"could not read ref '%s'\"),\n\t\t\t\t\t    pseudoref);\n\t\t\t\trollback_lock_file(&lock);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t} else if (is_null_oid(old_oid)) {\n\t\t\tstrbuf_addf(err, _(\"ref '%s' already exists\"),\n\t\t\t\t    pseudoref);\n\t\t\trollback_lock_file(&lock);\n\t\t\tgoto done;\n\t\t} else if (!oideq(&actual_old_oid, old_oid)) {\n\t\t\tstrbuf_addf(err, _(\"unexpected object ID when writing '%s'\"),\n\t\t\t\t    pseudoref);\n\t\t\trollback_lock_file(&lock);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (write_in_full(fd, buf.buf, buf.len) < 0) {\n\t\tstrbuf_addf(err, _(\"could not write to '%s'\"), filename);\n\t\trollback_lock_file(&lock);\n\t\tgoto done;\n\t}\n\n\tcommit_lock_file(&lock);\n\tret = 0;\ndone:\n\tstrbuf_release(&buf);\n\treturn ret;\n}\n\nstatic int delete_pseudoref(const char *pseudoref, const struct object_id *old_oid)\n{\n\tconst char *filename;\n\n\tfilename = git_path(\"%s\", pseudoref);\n\n\tif (old_oid && !is_null_oid(old_oid)) {\n\t\tstruct lock_file lock = LOCK_INIT;\n\t\tint fd;\n\t\tstruct object_id actual_old_oid;\n\n\t\tfd = hold_lock_file_for_update_timeout(\n\t\t\t\t&lock, filename, 0,\n\t\t\t\tget_files_ref_lock_timeout_ms());\n\t\tif (fd < 0) {\n\t\t\terror_errno(_(\"could not open '%s' for writing\"),\n\t\t\t\t    filename);\n\t\t\treturn -1;\n\t\t}\n\t\tif (read_ref(pseudoref, &actual_old_oid))\n\t\t\tdie(_(\"could not read ref '%s'\"), pseudoref);\n\t\tif (!oideq(&actual_old_oid, old_oid)) {\n\t\t\terror(_(\"unexpected object ID when deleting '%s'\"),\n\t\t\t      pseudoref);\n\t\t\trollback_lock_file(&lock);\n\t\t\treturn -1;\n\t\t}\n\n\t\tunlink(filename);\n\t\trollback_lock_file(&lock);\n\t} else {\n\t\tunlink(filename);\n\t}\n\n\treturn 0;\n}\n\nint refs_delete_ref(struct ref_store *refs, const char *msg,\n\t\t    const char *refname,\n\t\t    const struct object_id *old_oid,\n\t\t    unsigned int flags)\n{\n\tstruct ref_transaction *transaction;\n\tstruct strbuf err = STRBUF_INIT;\n\n\tif (ref_type(refname) == REF_TYPE_PSEUDOREF) {\n\t\tassert(refs == get_main_ref_store(the_repository));\n\t\treturn delete_pseudoref(refname, old_oid);\n\t}\n\n\ttransaction = ref_store_transaction_begin(refs, &err);\n\tif (!transaction ||\n\t    ref_transaction_delete(transaction, refname, old_oid,\n\t\t\t\t   flags, msg, &err) ||\n\t    ref_transaction_commit(transaction, &err)) {\n\t\terror(\"%s\", err.buf);\n\t\tref_transaction_free(transaction);\n\t\tstrbuf_release(&err);\n\t\treturn 1;\n\t}\n\tref_transaction_free(transaction);\n\tstrbuf_release(&err);\n\treturn 0;\n}\n\nint delete_ref(const char *msg, const char *refname,\n\t       const struct object_id *old_oid, unsigned int flags)\n{\n\treturn refs_delete_ref(get_main_ref_store(the_repository), msg, refname,\n\t\t\t       old_oid, flags);\n}\n\nvoid copy_reflog_msg(struct strbuf *sb, const char *msg)\n{\n\tchar c;\n\tint wasspace = 1;\n\n\tstrbuf_addch(sb, '\\t');\n\twhile ((c = *msg++)) {\n\t\tif (wasspace && isspace(c))\n\t\t\tcontinue;\n\t\twasspace = isspace(c);\n\t\tif (wasspace)\n\t\t\tc = ' ';\n\t\tstrbuf_addch(sb, c);\n\t}\n\tstrbuf_rtrim(sb);\n}\n\nint should_autocreate_reflog(const char *refname)\n{\n\tswitch (log_all_ref_updates) {\n\tcase LOG_REFS_ALWAYS:\n\t\treturn 1;\n\tcase LOG_REFS_NORMAL:\n\t\treturn starts_with(refname, \"refs/heads/\") ||\n\t\t\tstarts_with(refname, \"refs/remotes/\") ||\n\t\t\tstarts_with(refname, \"refs/notes/\") ||\n\t\t\t!strcmp(refname, \"HEAD\");\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nint is_branch(const char *refname)\n{\n\treturn !strcmp(refname, \"HEAD\") || starts_with(refname, \"refs/heads/\");\n}\n\nstruct read_ref_at_cb {\n\tconst char *refname;\n\ttimestamp_t at_time;\n\tint cnt;\n\tint reccnt;\n\tstruct object_id *oid;\n\tint found_it;\n\n\tstruct object_id ooid;\n\tstruct object_id noid;\n\tint tz;\n\ttimestamp_t date;\n\tchar **msg;\n\ttimestamp_t *cutoff_time;\n\tint *cutoff_tz;\n\tint *cutoff_cnt;\n};\n\nstatic int read_ref_at_ent(struct object_id *ooid, struct object_id *noid,\n\t\tconst char *email, timestamp_t timestamp, int tz,\n\t\tconst char *message, void *cb_data)\n{\n\tstruct read_ref_at_cb *cb = cb_data;\n\n\tcb->reccnt++;\n\tcb->tz = tz;\n\tcb->date = timestamp;\n\n\tif (timestamp <= cb->at_time || cb->cnt == 0) {\n\t\tif (cb->msg)\n\t\t\t*cb->msg = xstrdup(message);\n\t\tif (cb->cutoff_time)\n\t\t\t*cb->cutoff_time = timestamp;\n\t\tif (cb->cutoff_tz)\n\t\t\t*cb->cutoff_tz = tz;\n\t\tif (cb->cutoff_cnt)\n\t\t\t*cb->cutoff_cnt = cb->reccnt - 1;\n\t\t/*\n\t\t * we have not yet updated cb->[n|o]oid so they still\n\t\t * hold the values for the previous record.\n\t\t */\n\t\tif (!is_null_oid(&cb->ooid)) {\n\t\t\toidcpy(cb->oid, noid);\n\t\t\tif (!oideq(&cb->ooid, noid))\n\t\t\t\twarning(_(\"log for ref %s has gap after %s\"),\n\t\t\t\t\tcb->refname, show_date(cb->date, cb->tz, DATE_MODE(RFC2822)));\n\t\t}\n\t\telse if (cb->date == cb->at_time)\n\t\t\toidcpy(cb->oid, noid);\n\t\telse if (!oideq(noid, cb->oid))\n\t\t\twarning(_(\"log for ref %s unexpectedly ended on %s\"),\n\t\t\t\tcb->refname, show_date(cb->date, cb->tz,\n\t\t\t\t\t\t       DATE_MODE(RFC2822)));\n\t\toidcpy(&cb->ooid, ooid);\n\t\toidcpy(&cb->noid, noid);\n\t\tcb->found_it = 1;\n\t\treturn 1;\n\t}\n\toidcpy(&cb->ooid, ooid);\n\toidcpy(&cb->noid, noid);\n\tif (cb->cnt > 0)\n\t\tcb->cnt--;\n\treturn 0;\n}\n\nstatic int read_ref_at_ent_oldest(struct object_id *ooid, struct object_id *noid,\n\t\t\t\t  const char *email, timestamp_t timestamp,\n\t\t\t\t  int tz, const char *message, void *cb_data)\n{\n\tstruct read_ref_at_cb *cb = cb_data;\n\n\tif (cb->msg)\n\t\t*cb->msg = xstrdup(message);\n\tif (cb->cutoff_time)\n\t\t*cb->cutoff_time = timestamp;\n\tif (cb->cutoff_tz)\n\t\t*cb->cutoff_tz = tz;\n\tif (cb->cutoff_cnt)\n\t\t*cb->cutoff_cnt = cb->reccnt;\n\toidcpy(cb->oid, ooid);\n\tif (is_null_oid(cb->oid))\n\t\toidcpy(cb->oid, noid);\n\t/* We just want the first entry */\n\treturn 1;\n}\n\nint read_ref_at(struct ref_store *refs, const char *refname,\n\t\tunsigned int flags, timestamp_t at_time, int cnt,\n\t\tstruct object_id *oid, char **msg,\n\t\ttimestamp_t *cutoff_time, int *cutoff_tz, int *cutoff_cnt)\n{\n\tstruct read_ref_at_cb cb;\n\n\tmemset(&cb, 0, sizeof(cb));\n\tcb.refname = refname;\n\tcb.at_time = at_time;\n\tcb.cnt = cnt;\n\tcb.msg = msg;\n\tcb.cutoff_time = cutoff_time;\n\tcb.cutoff_tz = cutoff_tz;\n\tcb.cutoff_cnt = cutoff_cnt;\n\tcb.oid = oid;\n\n\trefs_for_each_reflog_ent_reverse(refs, refname, read_ref_at_ent, &cb);\n\n\tif (!cb.reccnt) {\n\t\tif (flags & GET_OID_QUIETLY)\n\t\t\texit(128);\n\t\telse\n\t\t\tdie(_(\"log for %s is empty\"), refname);\n\t}\n\tif (cb.found_it)\n\t\treturn 0;\n\n\trefs_for_each_reflog_ent(refs, refname, read_ref_at_ent_oldest, &cb);\n\n\treturn 1;\n}\n\nstruct ref_transaction *ref_store_transaction_begin(struct ref_store *refs,\n\t\t\t\t\t\t    struct strbuf *err)\n{\n\tstruct ref_transaction *tr;\n\tassert(err);\n\n\ttr = xcalloc(1, sizeof(struct ref_transaction));\n\ttr->ref_store = refs;\n\treturn tr;\n}\n\nstruct ref_transaction *ref_transaction_begin(struct strbuf *err)\n{\n\treturn ref_store_transaction_begin(get_main_ref_store(the_repository), err);\n}\n\nvoid ref_transaction_free(struct ref_transaction *transaction)\n{\n\tsize_t i;\n\n\tif (!transaction)\n\t\treturn;\n\n\tswitch (transaction->state) {\n\tcase REF_TRANSACTION_OPEN:\n\tcase REF_TRANSACTION_CLOSED:\n\t\t/* OK */\n\t\tbreak;\n\tcase REF_TRANSACTION_PREPARED:\n\t\tBUG(\"free called on a prepared reference transaction\");\n\t\tbreak;\n\tdefault:\n\t\tBUG(\"unexpected reference transaction state\");\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < transaction->nr; i++) {\n\t\tfree(transaction->updates[i]->msg);\n\t\tfree(transaction->updates[i]);\n\t}\n\tfree(transaction->updates);\n\tfree(transaction);\n}\n\nstruct ref_update *ref_transaction_add_update(\n\t\tstruct ref_transaction *transaction,\n\t\tconst char *refname, unsigned int flags,\n\t\tconst struct object_id *new_oid,\n\t\tconst struct object_id *old_oid,\n\t\tconst char *msg)\n{\n\tstruct ref_update *update;\n\n\tif (transaction->state != REF_TRANSACTION_OPEN)\n\t\tBUG(\"update called for transaction that is not open\");\n\n\tFLEX_ALLOC_STR(update, refname, refname);\n\tALLOC_GROW(transaction->updates, transaction->nr + 1, transaction->alloc);\n\ttransaction->updates[transaction->nr++] = update;\n\n\tupdate->flags = flags;\n\n\tif (flags & REF_HAVE_NEW)\n\t\toidcpy(&update->new_oid, new_oid);\n\tif (flags & REF_HAVE_OLD)\n\t\toidcpy(&update->old_oid, old_oid);\n\tupdate->msg = xstrdup_or_null(msg);\n\treturn update;\n}\n\nint ref_transaction_update(struct ref_transaction *transaction,\n\t\t\t   const char *refname,\n\t\t\t   const struct object_id *new_oid,\n\t\t\t   const struct object_id *old_oid,\n\t\t\t   unsigned int flags, const char *msg,\n\t\t\t   struct strbuf *err)\n{\n\tassert(err);\n\n\tif ((new_oid && !is_null_oid(new_oid)) ?\n\t    check_refname_format(refname, REFNAME_ALLOW_ONELEVEL) :\n\t    !refname_is_safe(refname)) {\n\t\tstrbuf_addf(err, _(\"refusing to update ref with bad name '%s'\"),\n\t\t\t    refname);\n\t\treturn -1;\n\t}\n\n\tif (flags & ~REF_TRANSACTION_UPDATE_ALLOWED_FLAGS)\n\t\tBUG(\"illegal flags 0x%x passed to ref_transaction_update()\", flags);\n\n\tflags |= (new_oid ? REF_HAVE_NEW : 0) | (old_oid ? REF_HAVE_OLD : 0);\n\n\tref_transaction_add_update(transaction, refname, flags,\n\t\t\t\t   new_oid, old_oid, msg);\n\treturn 0;\n}\n\nint ref_transaction_create(struct ref_transaction *transaction,\n\t\t\t   const char *refname,\n\t\t\t   const struct object_id *new_oid,\n\t\t\t   unsigned int flags, const char *msg,\n\t\t\t   struct strbuf *err)\n{\n\tif (!new_oid || is_null_oid(new_oid))\n\t\tBUG(\"create called without valid new_oid\");\n\treturn ref_transaction_update(transaction, refname, new_oid,\n\t\t\t\t      &null_oid, flags, msg, err);\n}\n\nint ref_transaction_delete(struct ref_transaction *transaction,\n\t\t\t   const char *refname,\n\t\t\t   const struct object_id *old_oid,\n\t\t\t   unsigned int flags, const char *msg,\n\t\t\t   struct strbuf *err)\n{\n\tif (old_oid && is_null_oid(old_oid))\n\t\tBUG(\"delete called with old_oid set to zeros\");\n\treturn ref_transaction_update(transaction, refname,\n\t\t\t\t      &null_oid, old_oid,\n\t\t\t\t      flags, msg, err);\n}\n\nint ref_transaction_verify(struct ref_transaction *transaction,\n\t\t\t   const char *refname,\n\t\t\t   const struct object_id *old_oid,\n\t\t\t   unsigned int flags,\n\t\t\t   struct strbuf *err)\n{\n\tif (!old_oid)\n\t\tBUG(\"verify called with old_oid set to NULL\");\n\treturn ref_transaction_update(transaction, refname,\n\t\t\t\t      NULL, old_oid,\n\t\t\t\t      flags, NULL, err);\n}\n\nint refs_update_ref(struct ref_store *refs, const char *msg,\n\t\t    const char *refname, const struct object_id *new_oid,\n\t\t    const struct object_id *old_oid, unsigned int flags,\n\t\t    enum action_on_err onerr)\n{\n\tstruct ref_transaction *t = NULL;\n\tstruct strbuf err = STRBUF_INIT;\n\tint ret = 0;\n\n\tif (ref_type(refname) == REF_TYPE_PSEUDOREF) {\n\t\tassert(refs == get_main_ref_store(the_repository));\n\t\tret = write_pseudoref(refname, new_oid, old_oid, &err);\n\t} else {\n\t\tt = ref_store_transaction_begin(refs, &err);\n\t\tif (!t ||\n\t\t    ref_transaction_update(t, refname, new_oid, old_oid,\n\t\t\t\t\t   flags, msg, &err) ||\n\t\t    ref_transaction_commit(t, &err)) {\n\t\t\tret = 1;\n\t\t\tref_transaction_free(t);\n\t\t}\n\t}\n\tif (ret) {\n\t\tconst char *str = _(\"update_ref failed for ref '%s': %s\");\n\n\t\tswitch (onerr) {\n\t\tcase UPDATE_REFS_MSG_ON_ERR:\n\t\t\terror(str, refname, err.buf);\n\t\t\tbreak;\n\t\tcase UPDATE_REFS_DIE_ON_ERR:\n\t\t\tdie(str, refname, err.buf);\n\t\t\tbreak;\n\t\tcase UPDATE_REFS_QUIET_ON_ERR:\n\t\t\tbreak;\n\t\t}\n\t\tstrbuf_release(&err);\n\t\treturn 1;\n\t}\n\tstrbuf_release(&err);\n\tif (t)\n\t\tref_transaction_free(t);\n\treturn 0;\n}\n\nint update_ref(const char *msg, const char *refname,\n\t       const struct object_id *new_oid,\n\t       const struct object_id *old_oid,\n\t       unsigned int flags, enum action_on_err onerr)\n{\n\treturn refs_update_ref(get_main_ref_store(the_repository), msg, refname, new_oid,\n\t\t\t       old_oid, flags, onerr);\n}\n\nchar *refs_shorten_unambiguous_ref(struct ref_store *refs,\n\t\t\t\t   const char *refname, int strict)\n{\n\tint i;\n\tstatic char **scanf_fmts;\n\tstatic int nr_rules;\n\tchar *short_name;\n\tstruct strbuf resolved_buf = STRBUF_INIT;\n\n\tif (!nr_rules) {\n\t\t/*\n\t\t * Pre-generate scanf formats from ref_rev_parse_rules[].\n\t\t * Generate a format suitable for scanf from a\n\t\t * ref_rev_parse_rules rule by interpolating \"%s\" at the\n\t\t * location of the \"%.*s\".\n\t\t */\n\t\tsize_t total_len = 0;\n\t\tsize_t offset = 0;\n\n\t\t/* the rule list is NULL terminated, count them first */\n\t\tfor (nr_rules = 0; ref_rev_parse_rules[nr_rules]; nr_rules++)\n\t\t\t/* -2 for strlen(\"%.*s\") - strlen(\"%s\"); +1 for NUL */\n\t\t\ttotal_len += strlen(ref_rev_parse_rules[nr_rules]) - 2 + 1;\n\n\t\tscanf_fmts = xmalloc(st_add(st_mult(sizeof(char *), nr_rules), total_len));\n\n\t\toffset = 0;\n\t\tfor (i = 0; i < nr_rules; i++) {\n\t\t\tassert(offset < total_len);\n\t\t\tscanf_fmts[i] = (char *)&scanf_fmts[nr_rules] + offset;\n\t\t\toffset += xsnprintf(scanf_fmts[i], total_len - offset,\n\t\t\t\t\t    ref_rev_parse_rules[i], 2, \"%s\") + 1;\n\t\t}\n\t}\n\n\t/* bail out if there are no rules */\n\tif (!nr_rules)\n\t\treturn xstrdup(refname);\n\n\t/* buffer for scanf result, at most refname must fit */\n\tshort_name = xstrdup(refname);\n\n\t/* skip first rule, it will always match */\n\tfor (i = nr_rules - 1; i > 0 ; --i) {\n\t\tint j;\n\t\tint rules_to_fail = i;\n\t\tint short_name_len;\n\n\t\tif (1 != sscanf(refname, scanf_fmts[i], short_name))\n\t\t\tcontinue;\n\n\t\tshort_name_len = strlen(short_name);\n\n\t\t/*\n\t\t * in strict mode, all (except the matched one) rules\n\t\t * must fail to resolve to a valid non-ambiguous ref\n\t\t */\n\t\tif (strict)\n\t\t\trules_to_fail = nr_rules;\n\n\t\t/*\n\t\t * check if the short name resolves to a valid ref,\n\t\t * but use only rules prior to the matched one\n\t\t */\n\t\tfor (j = 0; j < rules_to_fail; j++) {\n\t\t\tconst char *rule = ref_rev_parse_rules[j];\n\n\t\t\t/* skip matched rule */\n\t\t\tif (i == j)\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * the short name is ambiguous, if it resolves\n\t\t\t * (with this previous rule) to a valid ref\n\t\t\t * read_ref() returns 0 on success\n\t\t\t */\n\t\t\tstrbuf_reset(&resolved_buf);\n\t\t\tstrbuf_addf(&resolved_buf, rule,\n\t\t\t\t    short_name_len, short_name);\n\t\t\tif (refs_ref_exists(refs, resolved_buf.buf))\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * short name is non-ambiguous if all previous rules\n\t\t * haven't resolved to a valid ref\n\t\t */\n\t\tif (j == rules_to_fail) {\n\t\t\tstrbuf_release(&resolved_buf);\n\t\t\treturn short_name;\n\t\t}\n\t}\n\n\tstrbuf_release(&resolved_buf);\n\tfree(short_name);\n\treturn xstrdup(refname);\n}\n\nchar *shorten_unambiguous_ref(const char *refname, int strict)\n{\n\treturn refs_shorten_unambiguous_ref(get_main_ref_store(the_repository),\n\t\t\t\t\t    refname, strict);\n}\n\nstatic struct string_list *hide_refs;\n\nint parse_hide_refs_config(const char *var, const char *value, const char *section)\n{\n\tconst char *key;\n\tif (!strcmp(\"transfer.hiderefs\", var) ||\n\t    (!parse_config_key(var, section, NULL, NULL, &key) &&\n\t     !strcmp(key, \"hiderefs\"))) {\n\t\tchar *ref;\n\t\tint len;\n\n\t\tif (!value)\n\t\t\treturn config_error_nonbool(var);\n\t\tref = xstrdup(value);\n\t\tlen = strlen(ref);\n\t\twhile (len && ref[len - 1] == '/')\n\t\t\tref[--len] = '\\0';\n\t\tif (!hide_refs) {\n\t\t\thide_refs = xcalloc(1, sizeof(*hide_refs));\n\t\t\thide_refs->strdup_strings = 1;\n\t\t}\n\t\tstring_list_append(hide_refs, ref);\n\t}\n\treturn 0;\n}\n\nint ref_is_hidden(const char *refname, const char *refname_full)\n{\n\tint i;\n\n\tif (!hide_refs)\n\t\treturn 0;\n\tfor (i = hide_refs->nr - 1; i >= 0; i--) {\n\t\tconst char *match = hide_refs->items[i].string;\n\t\tconst char *subject;\n\t\tint neg = 0;\n\t\tconst char *p;\n\n\t\tif (*match == '!') {\n\t\t\tneg = 1;\n\t\t\tmatch++;\n\t\t}\n\n\t\tif (*match == '^') {\n\t\t\tsubject = refname_full;\n\t\t\tmatch++;\n\t\t} else {\n\t\t\tsubject = refname;\n\t\t}\n\n\t\t/* refname can be NULL when namespaces are used. */\n\t\tif (subject &&\n\t\t    skip_prefix(subject, match, &p) &&\n\t\t    (!*p || *p == '/'))\n\t\t\treturn !neg;\n\t}\n\treturn 0;\n}\n\nconst char *find_descendant_ref(const char *dirname,\n\t\t\t\tconst struct string_list *extras,\n\t\t\t\tconst struct string_list *skip)\n{\n\tint pos;\n\n\tif (!extras)\n\t\treturn NULL;\n\n\t/*\n\t * Look at the place where dirname would be inserted into\n\t * extras. If there is an entry at that position that starts\n\t * with dirname (remember, dirname includes the trailing\n\t * slash) and is not in skip, then we have a conflict.\n\t */\n\tfor (pos = string_list_find_insert_index(extras, dirname, 0);\n\t     pos < extras->nr; pos++) {\n\t\tconst char *extra_refname = extras->items[pos].string;\n\n\t\tif (!starts_with(extra_refname, dirname))\n\t\t\tbreak;\n\n\t\tif (!skip || !string_list_has_string(skip, extra_refname))\n\t\t\treturn extra_refname;\n\t}\n\treturn NULL;\n}\n\nint refs_rename_ref_available(struct ref_store *refs,\n\t\t\t      const char *old_refname,\n\t\t\t      const char *new_refname)\n{\n\tstruct string_list skip = STRING_LIST_INIT_NODUP;\n\tstruct strbuf err = STRBUF_INIT;\n\tint ok;\n\n\tstring_list_insert(&skip, old_refname);\n\tok = !refs_verify_refname_available(refs, new_refname,\n\t\t\t\t\t    NULL, &skip, &err);\n\tif (!ok)\n\t\terror(\"%s\", err.buf);\n\n\tstring_list_clear(&skip, 0);\n\tstrbuf_release(&err);\n\treturn ok;\n}\n\nint refs_head_ref(struct ref_store *refs, each_ref_fn fn, void *cb_data)\n{\n\tstruct object_id oid;\n\tint flag;\n\n\tif (!refs_read_ref_full(refs, \"HEAD\", RESOLVE_REF_READING,\n\t\t\t\t&oid, &flag))\n\t\treturn fn(\"HEAD\", &oid, flag, cb_data);\n\n\treturn 0;\n}\n\nint head_ref(each_ref_fn fn, void *cb_data)\n{\n\treturn refs_head_ref(get_main_ref_store(the_repository), fn, cb_data);\n}\n\nstruct ref_iterator *refs_ref_iterator_begin(\n\t\tstruct ref_store *refs,\n\t\tconst char *prefix, int trim, int flags)\n{\n\tstruct ref_iterator *iter;\n\n\tif (ref_paranoia < 0)\n\t\tref_paranoia = git_env_bool(\"GIT_REF_PARANOIA\", 0);\n\tif (ref_paranoia)\n\t\tflags |= DO_FOR_EACH_INCLUDE_BROKEN;\n\n\titer = refs->be->iterator_begin(refs, prefix, flags);\n\n\t/*\n\t * `iterator_begin()` already takes care of prefix, but we\n\t * might need to do some trimming:\n\t */\n\tif (trim)\n\t\titer = prefix_ref_iterator_begin(iter, \"\", trim);\n\n\t/* Sanity check for subclasses: */\n\tif (!iter->ordered)\n\t\tBUG(\"reference iterator is not ordered\");\n\n\treturn iter;\n}\n\n/*\n * Call fn for each reference in the specified submodule for which the\n * refname begins with prefix. If trim is non-zero, then trim that\n * many characters off the beginning of each refname before passing\n * the refname to fn. flags can be DO_FOR_EACH_INCLUDE_BROKEN to\n * include broken references in the iteration. If fn ever returns a\n * non-zero value, stop the iteration and return that value;\n * otherwise, return 0.\n */\nstatic int do_for_each_repo_ref(struct repository *r, const char *prefix,\n\t\t\t\teach_repo_ref_fn fn, int trim, int flags,\n\t\t\t\tvoid *cb_data)\n{\n\tstruct ref_iterator *iter;\n\tstruct ref_store *refs = get_main_ref_store(r);\n\n\tif (!refs)\n\t\treturn 0;\n\n\titer = refs_ref_iterator_begin(refs, prefix, trim, flags);\n\n\treturn do_for_each_repo_ref_iterator(r, iter, fn, cb_data);\n}\n\nstruct do_for_each_ref_help {\n\teach_ref_fn *fn;\n\tvoid *cb_data;\n};\n\nstatic int do_for_each_ref_helper(struct repository *r,\n\t\t\t\t  const char *refname,\n\t\t\t\t  const struct object_id *oid,\n\t\t\t\t  int flags,\n\t\t\t\t  void *cb_data)\n{\n\tstruct do_for_each_ref_help *hp = cb_data;\n\n\treturn hp->fn(refname, oid, flags, hp->cb_data);\n}\n\nstatic int do_for_each_ref(struct ref_store *refs, const char *prefix,\n\t\t\t   each_ref_fn fn, int trim, int flags, void *cb_data)\n{\n\tstruct ref_iterator *iter;\n\tstruct do_for_each_ref_help hp = { fn, cb_data };\n\n\tif (!refs)\n\t\treturn 0;\n\n\titer = refs_ref_iterator_begin(refs, prefix, trim, flags);\n\n\treturn do_for_each_repo_ref_iterator(the_repository, iter,\n\t\t\t\t\tdo_for_each_ref_helper, &hp);\n}\n\nint refs_for_each_ref(struct ref_store *refs, each_ref_fn fn, void *cb_data)\n{\n\treturn do_for_each_ref(refs, \"\", fn, 0, 0, cb_data);\n}\n\nint for_each_ref(each_ref_fn fn, void *cb_data)\n{\n\treturn refs_for_each_ref(get_main_ref_store(the_repository), fn, cb_data);\n}\n\nint refs_for_each_ref_in(struct ref_store *refs, const char *prefix,\n\t\t\t each_ref_fn fn, void *cb_data)\n{\n\treturn do_for_each_ref(refs, prefix, fn, strlen(prefix), 0, cb_data);\n}\n\nint for_each_ref_in(const char *prefix, each_ref_fn fn, void *cb_data)\n{\n\treturn refs_for_each_ref_in(get_main_ref_store(the_repository), prefix, fn, cb_data);\n}\n\nint for_each_fullref_in(const char *prefix, each_ref_fn fn, void *cb_data, unsigned int broken)\n{\n\tunsigned int flag = 0;\n\n\tif (broken)\n\t\tflag = DO_FOR_EACH_INCLUDE_BROKEN;\n\treturn do_for_each_ref(get_main_ref_store(the_repository),\n\t\t\t       prefix, fn, 0, flag, cb_data);\n}\n\nint refs_for_each_fullref_in(struct ref_store *refs, const char *prefix,\n\t\t\t     each_ref_fn fn, void *cb_data,\n\t\t\t     unsigned int broken)\n{\n\tunsigned int flag = 0;\n\n\tif (broken)\n\t\tflag = DO_FOR_EACH_INCLUDE_BROKEN;\n\treturn do_for_each_ref(refs, prefix, fn, 0, flag, cb_data);\n}\n\nint for_each_replace_ref(struct repository *r, each_repo_ref_fn fn, void *cb_data)\n{\n\treturn do_for_each_repo_ref(r, git_replace_ref_base, fn,\n\t\t\t\t    strlen(git_replace_ref_base),\n\t\t\t\t    DO_FOR_EACH_INCLUDE_BROKEN, cb_data);\n}\n\nint for_each_namespaced_ref(each_ref_fn fn, void *cb_data)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tint ret;\n\tstrbuf_addf(&buf, \"%srefs/\", get_git_namespace());\n\tret = do_for_each_ref(get_main_ref_store(the_repository),\n\t\t\t      buf.buf, fn, 0, 0, cb_data);\n\tstrbuf_release(&buf);\n\treturn ret;\n}\n\nint refs_for_each_rawref(struct ref_store *refs, each_ref_fn fn, void *cb_data)\n{\n\treturn do_for_each_ref(refs, \"\", fn, 0,\n\t\t\t       DO_FOR_EACH_INCLUDE_BROKEN, cb_data);\n}\n\nint for_each_rawref(each_ref_fn fn, void *cb_data)\n{\n\treturn refs_for_each_rawref(get_main_ref_store(the_repository), fn, cb_data);\n}\n\nint refs_read_raw_ref(struct ref_store *ref_store,\n\t\t      const char *refname, struct object_id *oid,\n\t\t      struct strbuf *referent, unsigned int *type)\n{\n\treturn ref_store->be->read_raw_ref(ref_store, refname, oid, referent, type);\n}\n\n/* This function needs to return a meaningful errno on failure */\nconst char *refs_resolve_ref_unsafe(struct ref_store *refs,\n\t\t\t\t    const char *refname,\n\t\t\t\t    int resolve_flags,\n\t\t\t\t    struct object_id *oid, int *flags)\n{\n\tstatic struct strbuf sb_refname = STRBUF_INIT;\n\tstruct object_id unused_oid;\n\tint unused_flags;\n\tint symref_count;\n\n\tif (!oid)\n\t\toid = &unused_oid;\n\tif (!flags)\n\t\tflags = &unused_flags;\n\n\t*flags = 0;\n\n\tif (check_refname_format(refname, REFNAME_ALLOW_ONELEVEL)) {\n\t\tif (!(resolve_flags & RESOLVE_REF_ALLOW_BAD_NAME) ||\n\t\t    !refname_is_safe(refname)) {\n\t\t\terrno = EINVAL;\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/*\n\t\t * dwim_ref() uses REF_ISBROKEN to distinguish between\n\t\t * missing refs and refs that were present but invalid,\n\t\t * to complain about the latter to stderr.\n\t\t *\n\t\t * We don't know whether the ref exists, so don't set\n\t\t * REF_ISBROKEN yet.\n\t\t */\n\t\t*flags |= REF_BAD_NAME;\n\t}\n\n\tfor (symref_count = 0; symref_count < SYMREF_MAXDEPTH; symref_count++) {\n\t\tunsigned int read_flags = 0;\n\n\t\tif (refs_read_raw_ref(refs, refname,\n\t\t\t\t      oid, &sb_refname, &read_flags)) {\n\t\t\t*flags |= read_flags;\n\n\t\t\t/* In reading mode, refs must eventually resolve */\n\t\t\tif (resolve_flags & RESOLVE_REF_READING)\n\t\t\t\treturn NULL;\n\n\t\t\t/*\n\t\t\t * Otherwise a missing ref is OK. But the files backend\n\t\t\t * may show errors besides ENOENT if there are\n\t\t\t * similarly-named refs.\n\t\t\t */\n\t\t\tif (errno != ENOENT &&\n\t\t\t    errno != EISDIR &&\n\t\t\t    errno != ENOTDIR)\n\t\t\t\treturn NULL;\n\n\t\t\toidclr(oid);\n\t\t\tif (*flags & REF_BAD_NAME)\n\t\t\t\t*flags |= REF_ISBROKEN;\n\t\t\treturn refname;\n\t\t}\n\n\t\t*flags |= read_flags;\n\n\t\tif (!(read_flags & REF_ISSYMREF)) {\n\t\t\tif (*flags & REF_BAD_NAME) {\n\t\t\t\toidclr(oid);\n\t\t\t\t*flags |= REF_ISBROKEN;\n\t\t\t}\n\t\t\treturn refname;\n\t\t}\n\n\t\trefname = sb_refname.buf;\n\t\tif (resolve_flags & RESOLVE_REF_NO_RECURSE) {\n\t\t\toidclr(oid);\n\t\t\treturn refname;\n\t\t}\n\t\tif (check_refname_format(refname, REFNAME_ALLOW_ONELEVEL)) {\n\t\t\tif (!(resolve_flags & RESOLVE_REF_ALLOW_BAD_NAME) ||\n\t\t\t    !refname_is_safe(refname)) {\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\t*flags |= REF_ISBROKEN | REF_BAD_NAME;\n\t\t}\n\t}\n\n\terrno = ELOOP;\n\treturn NULL;\n}\n\n/* backend functions */\nint refs_init_db(struct strbuf *err)\n{\n\tstruct ref_store *refs = get_main_ref_store(the_repository);\n\n\treturn refs->be->init_db(refs, err);\n}\n\nconst char *resolve_ref_unsafe(const char *refname, int resolve_flags,\n\t\t\t       struct object_id *oid, int *flags)\n{\n\treturn refs_resolve_ref_unsafe(get_main_ref_store(the_repository), refname,\n\t\t\t\t       resolve_flags, oid, flags);\n}\n\nint resolve_gitlink_ref(const char *submodule, const char *refname,\n\t\t\tstruct object_id *oid)\n{\n\tstruct ref_store *refs;\n\tint flags;\n\n\trefs = get_submodule_ref_store(submodule);\n\n\tif (!refs)\n\t\treturn -1;\n\n\tif (!refs_resolve_ref_unsafe(refs, refname, 0, oid, &flags) ||\n\t    is_null_oid(oid))\n\t\treturn -1;\n\treturn 0;\n}\n\nstruct ref_store_hash_entry\n{\n\tstruct hashmap_entry ent;\n\n\tstruct ref_store *refs;\n\n\t/* NUL-terminated identifier of the ref store: */\n\tchar name[FLEX_ARRAY];\n};\n\nstatic int ref_store_hash_cmp(const void *unused_cmp_data,\n\t\t\t      const struct hashmap_entry *eptr,\n\t\t\t      const struct hashmap_entry *entry_or_key,\n\t\t\t      const void *keydata)\n{\n\tconst struct ref_store_hash_entry *e1, *e2;\n\tconst char *name;\n\n\te1 = container_of(eptr, const struct ref_store_hash_entry, ent);\n\te2 = container_of(entry_or_key, const struct ref_store_hash_entry, ent);\n\tname = keydata ? keydata : e2->name;\n\n\treturn strcmp(e1->name, name);\n}\n\nstatic struct ref_store_hash_entry *alloc_ref_store_hash_entry(\n\t\tconst char *name, struct ref_store *refs)\n{\n\tstruct ref_store_hash_entry *entry;\n\n\tFLEX_ALLOC_STR(entry, name, name);\n\thashmap_entry_init(&entry->ent, strhash(name));\n\tentry->refs = refs;\n\treturn entry;\n}\n\n/* A hashmap of ref_stores, stored by submodule name: */\nstatic struct hashmap submodule_ref_stores;\n\n/* A hashmap of ref_stores, stored by worktree id: */\nstatic struct hashmap worktree_ref_stores;\n\n/*\n * Look up a ref store by name. If that ref_store hasn't been\n * registered yet, return NULL.\n */\nstatic struct ref_store *lookup_ref_store_map(struct hashmap *map,\n\t\t\t\t\t      const char *name)\n{\n\tstruct ref_store_hash_entry *entry;\n\tunsigned int hash;\n\n\tif (!map->tablesize)\n\t\t/* It's initialized on demand in register_ref_store(). */\n\t\treturn NULL;\n\n\thash = strhash(name);\n\tentry = hashmap_get_entry_from_hash(map, hash, name,\n\t\t\t\t\tstruct ref_store_hash_entry, ent);\n\treturn entry ? entry->refs : NULL;\n}\n\n/*\n * Create, record, and return a ref_store instance for the specified\n * gitdir.\n */\nstatic struct ref_store *ref_store_init(const char *gitdir,\n\t\t\t\t\tunsigned int flags)\n{\n\tconst char *be_name = \"files\";\n\tstruct ref_storage_be *be = find_ref_storage_backend(be_name);\n\tstruct ref_store *refs;\n\n\tif (!be)\n\t\tBUG(\"reference backend %s is unknown\", be_name);\n\n\trefs = be->init(gitdir, flags);\n\treturn refs;\n}\n\nstruct ref_store *get_main_ref_store(struct repository *r)\n{\n\tif (r->refs_private)\n\t\treturn r->refs_private;\n\n\tif (!r->gitdir)\n\t\tBUG(\"attempting to get main_ref_store outside of repository\");\n\n\tr->refs_private = ref_store_init(r->gitdir, REF_STORE_ALL_CAPS);\n\treturn r->refs_private;\n}\n\n/*\n * Associate a ref store with a name. It is a fatal error to call this\n * function twice for the same name.\n */\nstatic void register_ref_store_map(struct hashmap *map,\n\t\t\t\t   const char *type,\n\t\t\t\t   struct ref_store *refs,\n\t\t\t\t   const char *name)\n{\n\tstruct ref_store_hash_entry *entry;\n\n\tif (!map->tablesize)\n\t\thashmap_init(map, ref_store_hash_cmp, NULL, 0);\n\n\tentry = alloc_ref_store_hash_entry(name, refs);\n\tif (hashmap_put(map, &entry->ent))\n\t\tBUG(\"%s ref_store '%s' initialized twice\", type, name);\n}\n\nstruct ref_store *get_submodule_ref_store(const char *submodule)\n{\n\tstruct strbuf submodule_sb = STRBUF_INIT;\n\tstruct ref_store *refs;\n\tchar *to_free = NULL;\n\tsize_t len;\n\n\tif (!submodule)\n\t\treturn NULL;\n\n\tlen = strlen(submodule);\n\twhile (len && is_dir_sep(submodule[len - 1]))\n\t\tlen--;\n\tif (!len)\n\t\treturn NULL;\n\n\tif (submodule[len])\n\t\t/* We need to strip off one or more trailing slashes */\n\t\tsubmodule = to_free = xmemdupz(submodule, len);\n\n\trefs = lookup_ref_store_map(&submodule_ref_stores, submodule);\n\tif (refs)\n\t\tgoto done;\n\n\tstrbuf_addstr(&submodule_sb, submodule);\n\tif (!is_nonbare_repository_dir(&submodule_sb))\n\t\tgoto done;\n\n\tif (submodule_to_gitdir(&submodule_sb, submodule))\n\t\tgoto done;\n\n\t/* assume that add_submodule_odb() has been called */\n\trefs = ref_store_init(submodule_sb.buf,\n\t\t\t      REF_STORE_READ | REF_STORE_ODB);\n\tregister_ref_store_map(&submodule_ref_stores, \"submodule\",\n\t\t\t       refs, submodule);\n\ndone:\n\tstrbuf_release(&submodule_sb);\n\tfree(to_free);\n\n\treturn refs;\n}\n\nstruct ref_store *get_worktree_ref_store(const struct worktree *wt)\n{\n\tstruct ref_store *refs;\n\tconst char *id;\n\n\tif (wt->is_current)\n\t\treturn get_main_ref_store(the_repository);\n\n\tid = wt->id ? wt->id : \"/\";\n\trefs = lookup_ref_store_map(&worktree_ref_stores, id);\n\tif (refs)\n\t\treturn refs;\n\n\tif (wt->id)\n\t\trefs = ref_store_init(git_common_path(\"worktrees/%s\", wt->id),\n\t\t\t\t      REF_STORE_ALL_CAPS);\n\telse\n\t\trefs = ref_store_init(get_git_common_dir(),\n\t\t\t\t      REF_STORE_ALL_CAPS);\n\n\tif (refs)\n\t\tregister_ref_store_map(&worktree_ref_stores, \"worktree\",\n\t\t\t\t       refs, id);\n\treturn refs;\n}\n\nvoid base_ref_store_init(struct ref_store *refs,\n\t\t\t const struct ref_storage_be *be)\n{\n\trefs->be = be;\n}\n\n/* backend functions */\nint refs_pack_refs(struct ref_store *refs, unsigned int flags)\n{\n\treturn refs->be->pack_refs(refs, flags);\n}\n\nint refs_peel_ref(struct ref_store *refs, const char *refname,\n\t\t  struct object_id *oid)\n{\n\tint flag;\n\tstruct object_id base;\n\n\tif (current_ref_iter && current_ref_iter->refname == refname) {\n\t\tstruct object_id peeled;\n\n\t\tif (ref_iterator_peel(current_ref_iter, &peeled))\n\t\t\treturn -1;\n\t\toidcpy(oid, &peeled);\n\t\treturn 0;\n\t}\n\n\tif (refs_read_ref_full(refs, refname,\n\t\t\t       RESOLVE_REF_READING, &base, &flag))\n\t\treturn -1;\n\n\treturn peel_object(&base, oid);\n}\n\nint peel_ref(const char *refname, struct object_id *oid)\n{\n\treturn refs_peel_ref(get_main_ref_store(the_repository), refname, oid);\n}\n\nint refs_create_symref(struct ref_store *refs,\n\t\t       const char *ref_target,\n\t\t       const char *refs_heads_master,\n\t\t       const char *logmsg)\n{\n\treturn refs->be->create_symref(refs, ref_target,\n\t\t\t\t       refs_heads_master,\n\t\t\t\t       logmsg);\n}\n\nint create_symref(const char *ref_target, const char *refs_heads_master,\n\t\t  const char *logmsg)\n{\n\treturn refs_create_symref(get_main_ref_store(the_repository), ref_target,\n\t\t\t\t  refs_heads_master, logmsg);\n}\n\nint ref_update_reject_duplicates(struct string_list *refnames,\n\t\t\t\t struct strbuf *err)\n{\n\tsize_t i, n = refnames->nr;\n\n\tassert(err);\n\n\tfor (i = 1; i < n; i++) {\n\t\tint cmp = strcmp(refnames->items[i - 1].string,\n\t\t\t\t refnames->items[i].string);\n\n\t\tif (!cmp) {\n\t\t\tstrbuf_addf(err,\n\t\t\t\t    _(\"multiple updates for ref '%s' not allowed\"),\n\t\t\t\t    refnames->items[i].string);\n\t\t\treturn 1;\n\t\t} else if (cmp > 0) {\n\t\t\tBUG(\"ref_update_reject_duplicates() received unsorted list\");\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic const char hook_not_found;\nstatic const char *hook;\n\nstatic int run_transaction_hook(struct ref_transaction *transaction,\n\t\t\t\tconst char *state)\n{\n\tstruct child_process proc = CHILD_PROCESS_INIT;\n\tstruct strbuf buf = STRBUF_INIT;\n\tint ret = 0, i;\n\n\tif (hook == &hook_not_found)\n\t\treturn ret;\n\tif (!hook)\n\t\thook = find_hook(\"reference-transaction\");\n\tif (!hook) {\n\t\thook = &hook_not_found;\n\t\treturn ret;\n\t}\n\n\targv_array_pushl(&proc.args, hook, state, NULL);\n\tproc.in = -1;\n\tproc.stdout_to_stderr = 1;\n\tproc.trace2_hook_name = \"reference-transaction\";\n\n\tret = start_command(&proc);\n\tif (ret)\n\t\treturn ret;\n\n\tsigchain_push(SIGPIPE, SIG_IGN);\n\n\tfor (i = 0; i < transaction->nr; i++) {\n\t\tstruct ref_update *update = transaction->updates[i];\n\n\t\tstrbuf_reset(&buf);\n\t\tstrbuf_addf(&buf, \"%s %s %s\\n\",\n\t\t\t    oid_to_hex(&update->old_oid),\n\t\t\t    oid_to_hex(&update->new_oid),\n\t\t\t    update->refname);\n\n\t\tif (write_in_full(proc.in, buf.buf, buf.len) < 0) {\n\t\t\tif (errno != EPIPE)\n\t\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tclose(proc.in);\n\tsigchain_pop(SIGPIPE);\n\tstrbuf_release(&buf);\n\n\tret |= finish_command(&proc);\n\treturn ret;\n}\n\nint ref_transaction_prepare(struct ref_transaction *transaction,\n\t\t\t    struct strbuf *err)\n{\n\tstruct ref_store *refs = transaction->ref_store;\n\tint ret;\n\n\tswitch (transaction->state) {\n\tcase REF_TRANSACTION_OPEN:\n\t\t/* Good. */\n\t\tbreak;\n\tcase REF_TRANSACTION_PREPARED:\n\t\tBUG(\"prepare called twice on reference transaction\");\n\t\tbreak;\n\tcase REF_TRANSACTION_CLOSED:\n\t\tBUG(\"prepare called on a closed reference transaction\");\n\t\tbreak;\n\tdefault:\n\t\tBUG(\"unexpected reference transaction state\");\n\t\tbreak;\n\t}\n\n\tif (getenv(GIT_QUARANTINE_ENVIRONMENT)) {\n\t\tstrbuf_addstr(err,\n\t\t\t      _(\"ref updates forbidden inside quarantine environment\"));\n\t\treturn -1;\n\t}\n\n\tret = refs->be->transaction_prepare(refs, transaction, err);\n\tif (ret)\n\t\treturn ret;\n\n\tret = run_transaction_hook(transaction, \"prepared\");\n\tif (ret) {\n\t\tref_transaction_abort(transaction, err);\n\t\tdie(_(\"ref updates aborted by hook\"));\n\t}\n\n\treturn 0;\n}\n\nint ref_transaction_abort(struct ref_transaction *transaction,\n\t\t\t  struct strbuf *err)\n{\n\tstruct ref_store *refs = transaction->ref_store;\n\tint ret = 0;\n\n\tswitch (transaction->state) {\n\tcase REF_TRANSACTION_OPEN:\n\t\t/* No need to abort explicitly. */\n\t\tbreak;\n\tcase REF_TRANSACTION_PREPARED:\n\t\tret = refs->be->transaction_abort(refs, transaction, err);\n\t\tbreak;\n\tcase REF_TRANSACTION_CLOSED:\n\t\tBUG(\"abort called on a closed reference transaction\");\n\t\tbreak;\n\tdefault:\n\t\tBUG(\"unexpected reference transaction state\");\n\t\tbreak;\n\t}\n\n\trun_transaction_hook(transaction, \"aborted\");\n\n\tref_transaction_free(transaction);\n\treturn ret;\n}\n\nint ref_transaction_commit(struct ref_transaction *transaction,\n\t\t\t   struct strbuf *err)\n{\n\tstruct ref_store *refs = transaction->ref_store;\n\tint ret;\n\n\tswitch (transaction->state) {\n\tcase REF_TRANSACTION_OPEN:\n\t\t/* Need to prepare first. */\n\t\tret = ref_transaction_prepare(transaction, err);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase REF_TRANSACTION_PREPARED:\n\t\t/* Fall through to finish. */\n\t\tbreak;\n\tcase REF_TRANSACTION_CLOSED:\n\t\tBUG(\"commit called on a closed reference transaction\");\n\t\tbreak;\n\tdefault:\n\t\tBUG(\"unexpected reference transaction state\");\n\t\tbreak;\n\t}\n\n\tret = refs->be->transaction_finish(refs, transaction, err);\n\tif (!ret)\n\t\trun_transaction_hook(transaction, \"committed\");\n\treturn ret;\n}\n\nint refs_verify_refname_available(struct ref_store *refs,\n\t\t\t\t  const char *refname,\n\t\t\t\t  const struct string_list *extras,\n\t\t\t\t  const struct string_list *skip,\n\t\t\t\t  struct strbuf *err)\n{\n\tconst char *slash;\n\tconst char *extra_refname;\n\tstruct strbuf dirname = STRBUF_INIT;\n\tstruct strbuf referent = STRBUF_INIT;\n\tstruct object_id oid;\n\tunsigned int type;\n\tstruct ref_iterator *iter;\n\tint ok;\n\tint ret = -1;\n\n\t/*\n\t * For the sake of comments in this function, suppose that\n\t * refname is \"refs/foo/bar\".\n\t */\n\n\tassert(err);\n\n\tstrbuf_grow(&dirname, strlen(refname) + 1);\n\tfor (slash = strchr(refname, '/'); slash; slash = strchr(slash + 1, '/')) {\n\t\t/* Expand dirname to the new prefix, not including the trailing slash: */\n\t\tstrbuf_add(&dirname, refname + dirname.len, slash - refname - dirname.len);\n\n\t\t/*\n\t\t * We are still at a leading dir of the refname (e.g.,\n\t\t * \"refs/foo\"; if there is a reference with that name,\n\t\t * it is a conflict, *unless* it is in skip.\n\t\t */\n\t\tif (skip && string_list_has_string(skip, dirname.buf))\n\t\t\tcontinue;\n\n\t\tif (!refs_read_raw_ref(refs, dirname.buf, &oid, &referent, &type)) {\n\t\t\tstrbuf_addf(err, _(\"'%s' exists; cannot create '%s'\"),\n\t\t\t\t    dirname.buf, refname);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (extras && string_list_has_string(extras, dirname.buf)) {\n\t\t\tstrbuf_addf(err, _(\"cannot process '%s' and '%s' at the same time\"),\n\t\t\t\t    refname, dirname.buf);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t/*\n\t * We are at the leaf of our refname (e.g., \"refs/foo/bar\").\n\t * There is no point in searching for a reference with that\n\t * name, because a refname isn't considered to conflict with\n\t * itself. But we still need to check for references whose\n\t * names are in the \"refs/foo/bar/\" namespace, because they\n\t * *do* conflict.\n\t */\n\tstrbuf_addstr(&dirname, refname + dirname.len);\n\tstrbuf_addch(&dirname, '/');\n\n\titer = refs_ref_iterator_begin(refs, dirname.buf, 0,\n\t\t\t\t       DO_FOR_EACH_INCLUDE_BROKEN);\n\twhile ((ok = ref_iterator_advance(iter)) == ITER_OK) {\n\t\tif (skip &&\n\t\t    string_list_has_string(skip, iter->refname))\n\t\t\tcontinue;\n\n\t\tstrbuf_addf(err, _(\"'%s' exists; cannot create '%s'\"),\n\t\t\t    iter->refname, refname);\n\t\tref_iterator_abort(iter);\n\t\tgoto cleanup;\n\t}\n\n\tif (ok != ITER_DONE)\n\t\tBUG(\"error while iterating over references\");\n\n\textra_refname = find_descendant_ref(dirname.buf, extras, skip);\n\tif (extra_refname)\n\t\tstrbuf_addf(err, _(\"cannot process '%s' and '%s' at the same time\"),\n\t\t\t    refname, extra_refname);\n\telse\n\t\tret = 0;\n\ncleanup:\n\tstrbuf_release(&referent);\n\tstrbuf_release(&dirname);\n\treturn ret;\n}\n\nint refs_for_each_reflog(struct ref_store *refs, each_ref_fn fn, void *cb_data)\n{\n\tstruct ref_iterator *iter;\n\tstruct do_for_each_ref_help hp = { fn, cb_data };\n\n\titer = refs->be->reflog_iterator_begin(refs);\n\n\treturn do_for_each_repo_ref_iterator(the_repository, iter,\n\t\t\t\t\t     do_for_each_ref_helper, &hp);\n}\n\nint for_each_reflog(each_ref_fn fn, void *cb_data)\n{\n\treturn refs_for_each_reflog(get_main_ref_store(the_repository), fn, cb_data);\n}\n\nint refs_for_each_reflog_ent_reverse(struct ref_store *refs,\n\t\t\t\t     const char *refname,\n\t\t\t\t     each_reflog_ent_fn fn,\n\t\t\t\t     void *cb_data)\n{\n\treturn refs->be->for_each_reflog_ent_reverse(refs, refname,\n\t\t\t\t\t\t     fn, cb_data);\n}\n\nint for_each_reflog_ent_reverse(const char *refname, each_reflog_ent_fn fn,\n\t\t\t\tvoid *cb_data)\n{\n\treturn refs_for_each_reflog_ent_reverse(get_main_ref_store(the_repository),\n\t\t\t\t\t\trefname, fn, cb_data);\n}\n\nint refs_for_each_reflog_ent(struct ref_store *refs, const char *refname,\n\t\t\t     each_reflog_ent_fn fn, void *cb_data)\n{\n\treturn refs->be->for_each_reflog_ent(refs, refname, fn, cb_data);\n}\n\nint for_each_reflog_ent(const char *refname, each_reflog_ent_fn fn,\n\t\t\tvoid *cb_data)\n{\n\treturn refs_for_each_reflog_ent(get_main_ref_store(the_repository), refname,\n\t\t\t\t\tfn, cb_data);\n}\n\nint refs_reflog_exists(struct ref_store *refs, const char *refname)\n{\n\treturn refs->be->reflog_exists(refs, refname);\n}\n\nint reflog_exists(const char *refname)\n{\n\treturn refs_reflog_exists(get_main_ref_store(the_repository), refname);\n}\n\nint refs_create_reflog(struct ref_store *refs, const char *refname,\n\t\t       int force_create, struct strbuf *err)\n{\n\treturn refs->be->create_reflog(refs, refname, force_create, err);\n}\n\nint safe_create_reflog(const char *refname, int force_create,\n\t\t       struct strbuf *err)\n{\n\treturn refs_create_reflog(get_main_ref_store(the_repository), refname,\n\t\t\t\t  force_create, err);\n}\n\nint refs_delete_reflog(struct ref_store *refs, const char *refname)\n{\n\treturn refs->be->delete_reflog(refs, refname);\n}\n\nint delete_reflog(const char *refname)\n{\n\treturn refs_delete_reflog(get_main_ref_store(the_repository), refname);\n}\n\nint refs_reflog_expire(struct ref_store *refs,\n\t\t       const char *refname, const struct object_id *oid,\n\t\t       unsigned int flags,\n\t\t       reflog_expiry_prepare_fn prepare_fn,\n\t\t       reflog_expiry_should_prune_fn should_prune_fn,\n\t\t       reflog_expiry_cleanup_fn cleanup_fn,\n\t\t       void *policy_cb_data)\n{\n\treturn refs->be->reflog_expire(refs, refname, oid, flags,\n\t\t\t\t       prepare_fn, should_prune_fn,\n\t\t\t\t       cleanup_fn, policy_cb_data);\n}\n\nint reflog_expire(const char *refname, const struct object_id *oid,\n\t\t  unsigned int flags,\n\t\t  reflog_expiry_prepare_fn prepare_fn,\n\t\t  reflog_expiry_should_prune_fn should_prune_fn,\n\t\t  reflog_expiry_cleanup_fn cleanup_fn,\n\t\t  void *policy_cb_data)\n{\n\treturn refs_reflog_expire(get_main_ref_store(the_repository),\n\t\t\t\t  refname, oid, flags,\n\t\t\t\t  prepare_fn, should_prune_fn,\n\t\t\t\t  cleanup_fn, policy_cb_data);\n}\n\nint initial_ref_transaction_commit(struct ref_transaction *transaction,\n\t\t\t\t   struct strbuf *err)\n{\n\tstruct ref_store *refs = transaction->ref_store;\n\n\treturn refs->be->initial_transaction_commit(refs, transaction, err);\n}\n\nint refs_delete_refs(struct ref_store *refs, const char *msg,\n\t\t     struct string_list *refnames, unsigned int flags)\n{\n\treturn refs->be->delete_refs(refs, msg, refnames, flags);\n}\n\nint delete_refs(const char *msg, struct string_list *refnames,\n\t\tunsigned int flags)\n{\n\treturn refs_delete_refs(get_main_ref_store(the_repository), msg, refnames, flags);\n}\n\nint refs_rename_ref(struct ref_store *refs, const char *oldref,\n\t\t    const char *newref, const char *logmsg)\n{\n\treturn refs->be->rename_ref(refs, oldref, newref, logmsg);\n}\n\nint rename_ref(const char *oldref, const char *newref, const char *logmsg)\n{\n\treturn refs_rename_ref(get_main_ref_store(the_repository), oldref, newref, logmsg);\n}\n\nint refs_copy_existing_ref(struct ref_store *refs, const char *oldref,\n\t\t    const char *newref, const char *logmsg)\n{\n\treturn refs->be->copy_ref(refs, oldref, newref, logmsg);\n}\n\nint copy_existing_ref(const char *oldref, const char *newref, const char *logmsg)\n{\n\treturn refs_copy_existing_ref(get_main_ref_store(the_repository), oldref, newref, logmsg);\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00679262625f273c18b9444281e1b607598e063d",
  "sha1_ok": true,
  "size": 60374
}
