{
  "content": {
    "base64": "LyoKICogQnVpbHRpbiAiZ2l0IGxvZyIgYW5kIHJlbGF0ZWQgY29tbWFuZHMgKHNob3csIHdoYXRjaGFuZ2VkKQogKgogKiAoQykgQ29weXJpZ2h0IDIwMDYgTGludXMgVG9ydmFsZHMKICoJCSAyMDA2IEp1bmlvIEhhbWFubwogKi8KI2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJjb2xvci5oIgojaW5jbHVkZSAiY29tbWl0LmgiCiNpbmNsdWRlICJkaWZmLmgiCiNpbmNsdWRlICJyZXZpc2lvbi5oIgojaW5jbHVkZSAibG9nLXRyZWUuaCIKI2luY2x1ZGUgImJ1aWx0aW4uaCIKI2luY2x1ZGUgInRhZy5oIgojaW5jbHVkZSAicmVmbG9nLXdhbGsuaCIKI2luY2x1ZGUgInBhdGNoLWlkcy5oIgojaW5jbHVkZSAicnVuLWNvbW1hbmQuaCIKI2luY2x1ZGUgInNob3J0bG9nLmgiCiNpbmNsdWRlICJyZW1vdGUuaCIKI2luY2x1ZGUgInN0cmluZy1saXN0LmgiCiNpbmNsdWRlICJwYXJzZS1vcHRpb25zLmgiCiNpbmNsdWRlICJsaW5lLWxvZy5oIgojaW5jbHVkZSAiYnJhbmNoLmgiCiNpbmNsdWRlICJzdHJlYW1pbmcuaCIKI2luY2x1ZGUgInZlcnNpb24uaCIKI2luY2x1ZGUgIm1haWxtYXAuaCIKI2luY2x1ZGUgImdwZy1pbnRlcmZhY2UuaCIKCi8qIFNldCBhIGRlZmF1bHQgZGF0ZS10aW1lIGZvcm1hdCBmb3IgZ2l0IGxvZyAoImxvZy5kYXRlIiBjb25maWcgdmFyaWFibGUpICovCnN0YXRpYyBjb25zdCBjaGFyICpkZWZhdWx0X2RhdGVfbW9kZSA9IE5VTEw7CgpzdGF0aWMgaW50IGRlZmF1bHRfYWJicmV2X2NvbW1pdDsKc3RhdGljIGludCBkZWZhdWx0X3Nob3dfcm9vdCA9IDE7CnN0YXRpYyBpbnQgZGVjb3JhdGlvbl9zdHlsZTsKc3RhdGljIGludCBkZWNvcmF0aW9uX2dpdmVuOwpzdGF0aWMgaW50IHVzZV9tYWlsbWFwX2NvbmZpZzsKc3RhdGljIGNvbnN0IGNoYXIgKmZtdF9wYXRjaF9zdWJqZWN0X3ByZWZpeCA9ICJQQVRDSCI7CnN0YXRpYyBjb25zdCBjaGFyICpmbXRfcHJldHR5OwoKc3RhdGljIGNvbnN0IGNoYXIgKiBjb25zdCBidWlsdGluX2xvZ191c2FnZVtdID0gewoJTl8oImdpdCBsb2cgWzxvcHRpb25zPl0gWzxyZXZpc2lvbiByYW5nZT5dIFtbLS1dIDxwYXRoPi4uLl1cbiIpCglOXygiICAgb3I6IGdpdCBzaG93IFtvcHRpb25zXSA8b2JqZWN0Pi4uLiIpLAoJTlVMTAp9OwoKc3RydWN0IGxpbmVfb3B0X2NhbGxiYWNrX2RhdGEgewoJc3RydWN0IHJldl9pbmZvICpyZXY7Cgljb25zdCBjaGFyICpwcmVmaXg7CglzdHJ1Y3Qgc3RyaW5nX2xpc3QgYXJnczsKfTsKCnN0YXRpYyBpbnQgcGFyc2VfZGVjb3JhdGlvbl9zdHlsZShjb25zdCBjaGFyICp2YXIsIGNvbnN0IGNoYXIgKnZhbHVlKQp7Cglzd2l0Y2ggKGdpdF9jb25maWdfbWF5YmVfYm9vbCh2YXIsIHZhbHVlKSkgewoJY2FzZSAxOgoJCXJldHVybiBERUNPUkFURV9TSE9SVF9SRUZTOwoJY2FzZSAwOgoJCXJldHVybiAwOwoJZGVmYXVsdDoKCQlicmVhazsKCX0KCWlmICghc3RyY21wKHZhbHVlLCAiZnVsbCIpKQoJCXJldHVybiBERUNPUkFURV9GVUxMX1JFRlM7CgllbHNlIGlmICghc3RyY21wKHZhbHVlLCAic2hvcnQiKSkKCQlyZXR1cm4gREVDT1JBVEVfU0hPUlRfUkVGUzsKCXJldHVybiAtMTsKfQoKc3RhdGljIGludCBkZWNvcmF0ZV9jYWxsYmFjayhjb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHQsIGNvbnN0IGNoYXIgKmFyZywgaW50IHVuc2V0KQp7CglpZiAodW5zZXQpCgkJZGVjb3JhdGlvbl9zdHlsZSA9IDA7CgllbHNlIGlmIChhcmcpCgkJZGVjb3JhdGlvbl9zdHlsZSA9IHBhcnNlX2RlY29yYXRpb25fc3R5bGUoImNvbW1hbmQgbGluZSIsIGFyZyk7CgllbHNlCgkJZGVjb3JhdGlvbl9zdHlsZSA9IERFQ09SQVRFX1NIT1JUX1JFRlM7CgoJaWYgKGRlY29yYXRpb25fc3R5bGUgPCAwKQoJCWRpZSgiaW52YWxpZCAtLWRlY29yYXRlIG9wdGlvbjogJXMiLCBhcmcpOwoKCWRlY29yYXRpb25fZ2l2ZW4gPSAxOwoKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGxvZ19saW5lX3JhbmdlX2NhbGxiYWNrKGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdGlvbiwgY29uc3QgY2hhciAqYXJnLCBpbnQgdW5zZXQpCnsKCXN0cnVjdCBsaW5lX29wdF9jYWxsYmFja19kYXRhICpkYXRhID0gb3B0aW9uLT52YWx1ZTsKCglpZiAoIWFyZykKCQlyZXR1cm4gLTE7CgoJZGF0YS0+cmV2LT5saW5lX2xldmVsX3RyYXZlcnNlID0gMTsKCXN0cmluZ19saXN0X2FwcGVuZCgmZGF0YS0+YXJncywgYXJnKTsKCglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgY21kX2xvZ19pbml0X2RlZmF1bHRzKHN0cnVjdCByZXZfaW5mbyAqcmV2KQp7CglpZiAoZm10X3ByZXR0eSkKCQlnZXRfY29tbWl0X2Zvcm1hdChmbXRfcHJldHR5LCByZXYpOwoJcmV2LT52ZXJib3NlX2hlYWRlciA9IDE7CglESUZGX09QVF9TRVQoJnJldi0+ZGlmZm9wdCwgUkVDVVJTSVZFKTsKCXJldi0+ZGlmZm9wdC5zdGF0X3dpZHRoID0gLTE7IC8qIHVzZSBmdWxsIHRlcm1pbmFsIHdpZHRoICovCglyZXYtPmRpZmZvcHQuc3RhdF9ncmFwaF93aWR0aCA9IC0xOyAvKiByZXNwZWN0IHN0YXRHcmFwaFdpZHRoIGNvbmZpZyAqLwoJcmV2LT5hYmJyZXZfY29tbWl0ID0gZGVmYXVsdF9hYmJyZXZfY29tbWl0OwoJcmV2LT5zaG93X3Jvb3RfZGlmZiA9IGRlZmF1bHRfc2hvd19yb290OwoJcmV2LT5zdWJqZWN0X3ByZWZpeCA9IGZtdF9wYXRjaF9zdWJqZWN0X3ByZWZpeDsKCURJRkZfT1BUX1NFVCgmcmV2LT5kaWZmb3B0LCBBTExPV19URVhUQ09OVik7CgoJaWYgKGRlZmF1bHRfZGF0ZV9tb2RlKQoJCXJldi0+ZGF0ZV9tb2RlID0gcGFyc2VfZGF0ZV9mb3JtYXQoZGVmYXVsdF9kYXRlX21vZGUpOwoJcmV2LT5kaWZmb3B0LnRvdWNoZWRfZmxhZ3MgPSAwOwp9CgpzdGF0aWMgdm9pZCBjbWRfbG9nX2luaXRfZmluaXNoKGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndiwgY29uc3QgY2hhciAqcHJlZml4LAoJCQkgc3RydWN0IHJldl9pbmZvICpyZXYsIHN0cnVjdCBzZXR1cF9yZXZpc2lvbl9vcHQgKm9wdCkKewoJc3RydWN0IHVzZXJmb3JtYXRfd2FudCB3OwoJaW50IHF1aWV0ID0gMCwgc291cmNlID0gMCwgbWFpbG1hcCA9IDA7CglzdGF0aWMgc3RydWN0IGxpbmVfb3B0X2NhbGxiYWNrX2RhdGEgbGluZV9jYiA9IHtOVUxMLCBOVUxMLCBTVFJJTkdfTElTVF9JTklUX0RVUH07CgoJY29uc3Qgc3RydWN0IG9wdGlvbiBidWlsdGluX2xvZ19vcHRpb25zW10gPSB7CgkJT1BUX19RVUlFVCgmcXVpZXQsIE5fKCJzdXBwcmVzcyBkaWZmIG91dHB1dCIpKSwKCQlPUFRfQk9PTCgwLCAic291cmNlIiwgJnNvdXJjZSwgTl8oInNob3cgc291cmNlIikpLAoJCU9QVF9CT09MKDAsICJ1c2UtbWFpbG1hcCIsICZtYWlsbWFwLCBOXygiVXNlIG1haWwgbWFwIGZpbGUiKSksCgkJeyBPUFRJT05fQ0FMTEJBQ0ssIDAsICJkZWNvcmF0ZSIsIE5VTEwsIE5VTEwsIE5fKCJkZWNvcmF0ZSBvcHRpb25zIiksCgkJICBQQVJTRV9PUFRfT1BUQVJHLCBkZWNvcmF0ZV9jYWxsYmFja30sCgkJT1BUX0NBTExCQUNLKCdMJywgTlVMTCwgJmxpbmVfY2IsICJuLG06ZmlsZSIsCgkJCSAgICAgIlByb2Nlc3MgbGluZSByYW5nZSBuLG0gaW4gZmlsZSwgY291bnRpbmcgZnJvbSAxIiwKCQkJICAgICBsb2dfbGluZV9yYW5nZV9jYWxsYmFjayksCgkJT1BUX0VORCgpCgl9OwoKCWxpbmVfY2IucmV2ID0gcmV2OwoJbGluZV9jYi5wcmVmaXggPSBwcmVmaXg7CgoJbWFpbG1hcCA9IHVzZV9tYWlsbWFwX2NvbmZpZzsKCWFyZ2MgPSBwYXJzZV9vcHRpb25zKGFyZ2MsIGFyZ3YsIHByZWZpeCwKCQkJICAgICBidWlsdGluX2xvZ19vcHRpb25zLCBidWlsdGluX2xvZ191c2FnZSwKCQkJICAgICBQQVJTRV9PUFRfS0VFUF9BUkdWMCB8IFBBUlNFX09QVF9LRUVQX1VOS05PV04gfAoJCQkgICAgIFBBUlNFX09QVF9LRUVQX0RBU0hEQVNIKTsKCglpZiAocXVpZXQpCgkJcmV2LT5kaWZmb3B0Lm91dHB1dF9mb3JtYXQgfD0gRElGRl9GT1JNQVRfTk9fT1VUUFVUOwoJYXJnYyA9IHNldHVwX3JldmlzaW9ucyhhcmdjLCBhcmd2LCByZXYsIG9wdCk7CgoJLyogQW55IGFyZ3VtZW50cyBhdCB0aGlzIHBvaW50IGFyZSBub3QgcmVjb2duaXplZCAqLwoJaWYgKGFyZ2MgPiAxKQoJCWRpZSgidW5yZWNvZ25pemVkIGFyZ3VtZW50OiAlcyIsIGFyZ3ZbMV0pOwoKCW1lbXNldCgmdywgMCwgc2l6ZW9mKHcpKTsKCXVzZXJmb3JtYXRfZmluZF9yZXF1aXJlbWVudHMoTlVMTCwgJncpOwoKCWlmICghcmV2LT5zaG93X25vdGVzX2dpdmVuICYmICghcmV2LT5wcmV0dHlfZ2l2ZW4gfHwgdy5ub3RlcykpCgkJcmV2LT5zaG93X25vdGVzID0gMTsKCWlmIChyZXYtPnNob3dfbm90ZXMpCgkJaW5pdF9kaXNwbGF5X25vdGVzKCZyZXYtPm5vdGVzX29wdCk7CgoJaWYgKHJldi0+ZGlmZm9wdC5waWNrYXhlIHx8IHJldi0+ZGlmZm9wdC5maWx0ZXIgfHwKCSAgICBESUZGX09QVF9UU1QoJnJldi0+ZGlmZm9wdCwgRk9MTE9XX1JFTkFNRVMpKQoJCXJldi0+YWx3YXlzX3Nob3dfaGVhZGVyID0gMDsKCglpZiAoc291cmNlKQoJCXJldi0+c2hvd19zb3VyY2UgPSAxOwoKCWlmIChtYWlsbWFwKSB7CgkJcmV2LT5tYWlsbWFwID0geGNhbGxvYygxLCBzaXplb2Yoc3RydWN0IHN0cmluZ19saXN0KSk7CgkJcmVhZF9tYWlsbWFwKHJldi0+bWFpbG1hcCwgTlVMTCk7Cgl9CgoJaWYgKHJldi0+cHJldHR5X2dpdmVuICYmIHJldi0+Y29tbWl0X2Zvcm1hdCA9PSBDTUlUX0ZNVF9SQVcpIHsKCQkvKgoJCSAqICJsb2cgLS1wcmV0dHk9cmF3IiBpcyBzcGVjaWFsOyBpZ25vcmUgVUkgb3JpZW50ZWQKCQkgKiBjb25maWd1cmF0aW9uIHZhcmlhYmxlcyBzdWNoIGFzIGRlY29yYXRpb24uCgkJICovCgkJaWYgKCFkZWNvcmF0aW9uX2dpdmVuKQoJCQlkZWNvcmF0aW9uX3N0eWxlID0gMDsKCQlpZiAoIXJldi0+YWJicmV2X2NvbW1pdF9naXZlbikKCQkJcmV2LT5hYmJyZXZfY29tbWl0ID0gMDsKCX0KCglpZiAoZGVjb3JhdGlvbl9zdHlsZSkgewoJCXJldi0+c2hvd19kZWNvcmF0aW9ucyA9IDE7CgkJbG9hZF9yZWZfZGVjb3JhdGlvbnMoZGVjb3JhdGlvbl9zdHlsZSk7Cgl9CgoJaWYgKHJldi0+bGluZV9sZXZlbF90cmF2ZXJzZSkKCQlsaW5lX2xvZ19pbml0KHJldiwgbGluZV9jYi5wcmVmaXgsICZsaW5lX2NiLmFyZ3MpOwoKCXNldHVwX3BhZ2VyKCk7Cn0KCnN0YXRpYyB2b2lkIGNtZF9sb2dfaW5pdChpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsIGNvbnN0IGNoYXIgKnByZWZpeCwKCQkJIHN0cnVjdCByZXZfaW5mbyAqcmV2LCBzdHJ1Y3Qgc2V0dXBfcmV2aXNpb25fb3B0ICpvcHQpCnsKCWNtZF9sb2dfaW5pdF9kZWZhdWx0cyhyZXYpOwoJY21kX2xvZ19pbml0X2ZpbmlzaChhcmdjLCBhcmd2LCBwcmVmaXgsIHJldiwgb3B0KTsKfQoKLyoKICogVGhpcyBnaXZlcyBhIHJvdWdoIGVzdGltYXRlIGZvciBob3cgbWFueSBjb21taXRzIHdlCiAqIHdpbGwgcHJpbnQgb3V0IGluIHRoZSBsaXN0LgogKi8Kc3RhdGljIGludCBlc3RpbWF0ZV9jb21taXRfY291bnQoc3RydWN0IHJldl9pbmZvICpyZXYsIHN0cnVjdCBjb21taXRfbGlzdCAqbGlzdCkKewoJaW50IG4gPSAwOwoKCXdoaWxlIChsaXN0KSB7CgkJc3RydWN0IGNvbW1pdCAqY29tbWl0ID0gbGlzdC0+aXRlbTsKCQl1bnNpZ25lZCBpbnQgZmxhZ3MgPSBjb21taXQtPm9iamVjdC5mbGFnczsKCQlsaXN0ID0gbGlzdC0+bmV4dDsKCQlpZiAoIShmbGFncyAmIChUUkVFU0FNRSB8IFVOSU5URVJFU1RJTkcpKSkKCQkJbisrOwoJfQoJcmV0dXJuIG47Cn0KCnN0YXRpYyB2b2lkIHNob3dfZWFybHlfaGVhZGVyKHN0cnVjdCByZXZfaW5mbyAqcmV2LCBjb25zdCBjaGFyICpzdGFnZSwgaW50IG5yKQp7CglpZiAocmV2LT5zaG93bl9vbmUpIHsKCQlyZXYtPnNob3duX29uZSA9IDA7CgkJaWYgKHJldi0+Y29tbWl0X2Zvcm1hdCAhPSBDTUlUX0ZNVF9PTkVMSU5FKQoJCQlwdXRjaGFyKHJldi0+ZGlmZm9wdC5saW5lX3Rlcm1pbmF0aW9uKTsKCX0KCXByaW50ZihfKCJGaW5hbCBvdXRwdXQ6ICVkICVzXG4iKSwgbnIsIHN0YWdlKTsKfQoKc3RhdGljIHN0cnVjdCBpdGltZXJ2YWwgZWFybHlfb3V0cHV0X3RpbWVyOwoKc3RhdGljIHZvaWQgbG9nX3Nob3dfZWFybHkoc3RydWN0IHJldl9pbmZvICpyZXZzLCBzdHJ1Y3QgY29tbWl0X2xpc3QgKmxpc3QpCnsKCWludCBpID0gcmV2cy0+ZWFybHlfb3V0cHV0OwoJaW50IHNob3dfaGVhZGVyID0gMTsKCglzb3J0X2luX3RvcG9sb2dpY2FsX29yZGVyKCZsaXN0LCByZXZzLT5zb3J0X29yZGVyKTsKCXdoaWxlIChsaXN0ICYmIGkpIHsKCQlzdHJ1Y3QgY29tbWl0ICpjb21taXQgPSBsaXN0LT5pdGVtOwoJCXN3aXRjaCAoc2ltcGxpZnlfY29tbWl0KHJldnMsIGNvbW1pdCkpIHsKCQljYXNlIGNvbW1pdF9zaG93OgoJCQlpZiAoc2hvd19oZWFkZXIpIHsKCQkJCWludCBuID0gZXN0aW1hdGVfY29tbWl0X2NvdW50KHJldnMsIGxpc3QpOwoJCQkJc2hvd19lYXJseV9oZWFkZXIocmV2cywgImluY29tcGxldGUiLCBuKTsKCQkJCXNob3dfaGVhZGVyID0gMDsKCQkJfQoJCQlsb2dfdHJlZV9jb21taXQocmV2cywgY29tbWl0KTsKCQkJaS0tOwoJCQlicmVhazsKCQljYXNlIGNvbW1pdF9pZ25vcmU6CgkJCWJyZWFrOwoJCWNhc2UgY29tbWl0X2Vycm9yOgoJCQlyZXR1cm47CgkJfQoJCWxpc3QgPSBsaXN0LT5uZXh0OwoJfQoKCS8qIERpZCB3ZSBhbHJlYWR5IGdldCBlbm91Z2ggY29tbWl0cyBmb3IgdGhlIGVhcmx5IG91dHB1dD8gKi8KCWlmICghaSkKCQlyZXR1cm47CgoJLyoKCSAqIC4uaWYgbm8sIHRoZW4gcmVwZWF0IGl0IHR3aWNlIGEgc2Vjb25kIHVudGlsIHdlCgkgKiBkby4KCSAqCgkgKiBOT1RFISBXZSBkb24ndCB1c2UgIml0X2ludGVydmFsIiwgYmVjYXVzZSBpZiB0aGUKCSAqIHJlYWRlciBpc24ndCBsaXN0ZW5pbmcsIHdlIHdhbnQgb3VyIG91dHB1dCB0byBiZQoJICogdGhyb3R0bGVkIGJ5IHRoZSB3cml0aW5nLCBhbmQgbm90IGhhdmUgdGhlIHRpbWVyCgkgKiB0cmlnZ2VyIGV2ZXJ5IHNlY29uZCBldmVuIGlmIHdlJ3JlIGJsb2NrZWQgb24gYQoJICogcmVhZGVyIQoJICovCgllYXJseV9vdXRwdXRfdGltZXIuaXRfdmFsdWUudHZfc2VjID0gMDsKCWVhcmx5X291dHB1dF90aW1lci5pdF92YWx1ZS50dl91c2VjID0gNTAwMDAwOwoJc2V0aXRpbWVyKElUSU1FUl9SRUFMLCAmZWFybHlfb3V0cHV0X3RpbWVyLCBOVUxMKTsKfQoKc3RhdGljIHZvaWQgZWFybHlfb3V0cHV0KGludCBzaWduYWwpCnsKCXNob3dfZWFybHlfb3V0cHV0ID0gbG9nX3Nob3dfZWFybHk7Cn0KCnN0YXRpYyB2b2lkIHNldHVwX2Vhcmx5X291dHB1dChzdHJ1Y3QgcmV2X2luZm8gKnJldikKewoJc3RydWN0IHNpZ2FjdGlvbiBzYTsKCgkvKgoJICogU2V0IHVwIHRoZSBzaWduYWwgaGFuZGxlciwgbWluaW1hbGx5IGludHJ1c2l2ZWx5OgoJICogd2Ugb25seSBzZXQgYSBzaW5nbGUgdm9sYXRpbGUgaW50ZWdlciB3b3JkIChub3QKCSAqIHVzaW5nIHNpZ2F0b21pY190IC0gdHJ5aW5nIHRvIGF2b2lkIHVubmVjZXNzYXJ5CgkgKiBzeXN0ZW0gZGVwZW5kZW5jaWVzIGFuZCBoZWFkZXJzKSwgYW5kIHVzaW5nCgkgKiBTQV9SRVNUQVJULgoJICovCgltZW1zZXQoJnNhLCAwLCBzaXplb2Yoc2EpKTsKCXNhLnNhX2hhbmRsZXIgPSBlYXJseV9vdXRwdXQ7CglzaWdlbXB0eXNldCgmc2Euc2FfbWFzayk7CglzYS5zYV9mbGFncyA9IFNBX1JFU1RBUlQ7CglzaWdhY3Rpb24oU0lHQUxSTSwgJnNhLCBOVUxMKTsKCgkvKgoJICogSWYgd2UgY2FuIGdldCB0aGUgd2hvbGUgb3V0cHV0IGluIGxlc3MgdGhhbiBhCgkgKiB0ZW50aCBvZiBhIHNlY29uZCwgZG9uJ3QgZXZlbiBib3RoZXIgZG9pbmcgdGhlCgkgKiBlYXJseS1vdXRwdXQgdGhpbmcuLgoJICoKCSAqIFRoaXMgaXMgYSBvbmUtdGltZS1vbmx5IHRyaWdnZXIuCgkgKi8KCWVhcmx5X291dHB1dF90aW1lci5pdF92YWx1ZS50dl9zZWMgPSAwOwoJZWFybHlfb3V0cHV0X3RpbWVyLml0X3ZhbHVlLnR2X3VzZWMgPSAxMDAwMDA7CglzZXRpdGltZXIoSVRJTUVSX1JFQUwsICZlYXJseV9vdXRwdXRfdGltZXIsIE5VTEwpOwp9CgpzdGF0aWMgdm9pZCBmaW5pc2hfZWFybHlfb3V0cHV0KHN0cnVjdCByZXZfaW5mbyAqcmV2KQp7CglpbnQgbiA9IGVzdGltYXRlX2NvbW1pdF9jb3VudChyZXYsIHJldi0+Y29tbWl0cyk7CglzaWduYWwoU0lHQUxSTSwgU0lHX0lHTik7CglzaG93X2Vhcmx5X2hlYWRlcihyZXYsICJkb25lIiwgbik7Cn0KCnN0YXRpYyBpbnQgY21kX2xvZ193YWxrKHN0cnVjdCByZXZfaW5mbyAqcmV2KQp7CglzdHJ1Y3QgY29tbWl0ICpjb21taXQ7CglpbnQgc2F2ZWRfbnJsID0gMDsKCWludCBzYXZlZF9kY2N0YyA9IDA7CgoJaWYgKHJldi0+ZWFybHlfb3V0cHV0KQoJCXNldHVwX2Vhcmx5X291dHB1dChyZXYpOwoKCWlmIChwcmVwYXJlX3JldmlzaW9uX3dhbGsocmV2KSkKCQlkaWUoXygicmV2aXNpb24gd2FsayBzZXR1cCBmYWlsZWQiKSk7CgoJaWYgKHJldi0+ZWFybHlfb3V0cHV0KQoJCWZpbmlzaF9lYXJseV9vdXRwdXQocmV2KTsKCgkvKgoJICogRm9yIC0tY2hlY2sgYW5kIC0tZXhpdC1jb2RlLCB0aGUgZXhpdCBjb2RlIGlzIGJhc2VkIG9uIENIRUNLX0ZBSUxFRAoJICogYW5kIEhBU19DSEFOR0VTIGJlaW5nIGFjY3VtdWxhdGVkIGluIHJldi0+ZGlmZm9wdCwgc28gYmUgY2FyZWZ1bCB0bwoJICogcmV0YWluIHRoYXQgc3RhdGUgaW5mb3JtYXRpb24gaWYgcmVwbGFjaW5nIHJldi0+ZGlmZm9wdCBpbiB0aGlzIGxvb3AKCSAqLwoJd2hpbGUgKChjb21taXQgPSBnZXRfcmV2aXNpb24ocmV2KSkgIT0gTlVMTCkgewoJCWlmICghbG9nX3RyZWVfY29tbWl0KHJldiwgY29tbWl0KSAmJgoJCSAgICByZXYtPm1heF9jb3VudCA+PSAwKQoJCQkvKgoJCQkgKiBXZSBkZWNyZW1lbnRlZCBtYXhfY291bnQgaW4gZ2V0X3JldmlzaW9uLAoJCQkgKiBidXQgd2UgZGlkbid0IGFjdHVhbGx5IHNob3cgdGhlIGNvbW1pdC4KCQkJICovCgkJCXJldi0+bWF4X2NvdW50Kys7CgkJaWYgKCFyZXYtPnJlZmxvZ19pbmZvKSB7CgkJCS8qIHdlIGFsbG93IGN5Y2xlcyBpbiByZWZsb2cgYW5jZXN0cnkgKi8KCQkJZnJlZShjb21taXQtPmJ1ZmZlcik7CgkJCWNvbW1pdC0+YnVmZmVyID0gTlVMTDsKCQl9CgkJZnJlZV9jb21taXRfbGlzdChjb21taXQtPnBhcmVudHMpOwoJCWNvbW1pdC0+cGFyZW50cyA9IE5VTEw7CgkJaWYgKHNhdmVkX25ybCA8IHJldi0+ZGlmZm9wdC5uZWVkZWRfcmVuYW1lX2xpbWl0KQoJCQlzYXZlZF9ucmwgPSByZXYtPmRpZmZvcHQubmVlZGVkX3JlbmFtZV9saW1pdDsKCQlpZiAocmV2LT5kaWZmb3B0LmRlZ3JhZGVkX2NjX3RvX2MpCgkJCXNhdmVkX2RjY3RjID0gMTsKCX0KCXJldi0+ZGlmZm9wdC5kZWdyYWRlZF9jY190b19jID0gc2F2ZWRfZGNjdGM7CglyZXYtPmRpZmZvcHQubmVlZGVkX3JlbmFtZV9saW1pdCA9IHNhdmVkX25ybDsKCglpZiAocmV2LT5kaWZmb3B0Lm91dHB1dF9mb3JtYXQgJiBESUZGX0ZPUk1BVF9DSEVDS0RJRkYgJiYKCSAgICBESUZGX09QVF9UU1QoJnJldi0+ZGlmZm9wdCwgQ0hFQ0tfRkFJTEVEKSkgewoJCXJldHVybiAwMjsKCX0KCXJldHVybiBkaWZmX3Jlc3VsdF9jb2RlKCZyZXYtPmRpZmZvcHQsIDApOwp9CgpzdGF0aWMgaW50IGdpdF9sb2dfY29uZmlnKGNvbnN0IGNoYXIgKnZhciwgY29uc3QgY2hhciAqdmFsdWUsIHZvaWQgKmNiKQp7CglpZiAoIXN0cmNtcCh2YXIsICJmb3JtYXQucHJldHR5IikpCgkJcmV0dXJuIGdpdF9jb25maWdfc3RyaW5nKCZmbXRfcHJldHR5LCB2YXIsIHZhbHVlKTsKCWlmICghc3RyY21wKHZhciwgImZvcm1hdC5zdWJqZWN0cHJlZml4IikpCgkJcmV0dXJuIGdpdF9jb25maWdfc3RyaW5nKCZmbXRfcGF0Y2hfc3ViamVjdF9wcmVmaXgsIHZhciwgdmFsdWUpOwoJaWYgKCFzdHJjbXAodmFyLCAibG9nLmFiYnJldmNvbW1pdCIpKSB7CgkJZGVmYXVsdF9hYmJyZXZfY29tbWl0ID0gZ2l0X2NvbmZpZ19ib29sKHZhciwgdmFsdWUpOwoJCXJldHVybiAwOwoJfQoJaWYgKCFzdHJjbXAodmFyLCAibG9nLmRhdGUiKSkKCQlyZXR1cm4gZ2l0X2NvbmZpZ19zdHJpbmcoJmRlZmF1bHRfZGF0ZV9tb2RlLCB2YXIsIHZhbHVlKTsKCWlmICghc3RyY21wKHZhciwgImxvZy5kZWNvcmF0ZSIpKSB7CgkJZGVjb3JhdGlvbl9zdHlsZSA9IHBhcnNlX2RlY29yYXRpb25fc3R5bGUodmFyLCB2YWx1ZSk7CgkJaWYgKGRlY29yYXRpb25fc3R5bGUgPCAwKQoJCQlkZWNvcmF0aW9uX3N0eWxlID0gMDsgLyogbWF5YmUgd2Fybj8gKi8KCQlyZXR1cm4gMDsKCX0KCWlmICghc3RyY21wKHZhciwgImxvZy5zaG93cm9vdCIpKSB7CgkJZGVmYXVsdF9zaG93X3Jvb3QgPSBnaXRfY29uZmlnX2Jvb2wodmFyLCB2YWx1ZSk7CgkJcmV0dXJuIDA7Cgl9CglpZiAoIXByZWZpeGNtcCh2YXIsICJjb2xvci5kZWNvcmF0ZS4iKSkKCQlyZXR1cm4gcGFyc2VfZGVjb3JhdGVfY29sb3JfY29uZmlnKHZhciwgMTUsIHZhbHVlKTsKCWlmICghc3RyY21wKHZhciwgImxvZy5tYWlsbWFwIikpIHsKCQl1c2VfbWFpbG1hcF9jb25maWcgPSBnaXRfY29uZmlnX2Jvb2wodmFyLCB2YWx1ZSk7CgkJcmV0dXJuIDA7Cgl9CgoJaWYgKGdyZXBfY29uZmlnKHZhciwgdmFsdWUsIGNiKSA8IDApCgkJcmV0dXJuIC0xOwoJaWYgKGdpdF9ncGdfY29uZmlnKHZhciwgdmFsdWUsIGNiKSA8IDApCgkJcmV0dXJuIC0xOwoJcmV0dXJuIGdpdF9kaWZmX3VpX2NvbmZpZyh2YXIsIHZhbHVlLCBjYik7Cn0KCmludCBjbWRfd2hhdGNoYW5nZWQoaW50IGFyZ2MsIGNvbnN0IGNoYXIgKiphcmd2LCBjb25zdCBjaGFyICpwcmVmaXgpCnsKCXN0cnVjdCByZXZfaW5mbyByZXY7CglzdHJ1Y3Qgc2V0dXBfcmV2aXNpb25fb3B0IG9wdDsKCglpbml0X2dyZXBfZGVmYXVsdHMoKTsKCWdpdF9jb25maWcoZ2l0X2xvZ19jb25maWcsIE5VTEwpOwoKCWluaXRfcmV2aXNpb25zKCZyZXYsIHByZWZpeCk7CglyZXYuZGlmZiA9IDE7CglyZXYuc2ltcGxpZnlfaGlzdG9yeSA9IDA7CgltZW1zZXQoJm9wdCwgMCwgc2l6ZW9mKG9wdCkpOwoJb3B0LmRlZiA9ICJIRUFEIjsKCW9wdC5yZXZhcmdfb3B0ID0gUkVWQVJHX0NPTU1JVFRJU0g7CgljbWRfbG9nX2luaXQoYXJnYywgYXJndiwgcHJlZml4LCAmcmV2LCAmb3B0KTsKCWlmICghcmV2LmRpZmZvcHQub3V0cHV0X2Zvcm1hdCkKCQlyZXYuZGlmZm9wdC5vdXRwdXRfZm9ybWF0ID0gRElGRl9GT1JNQVRfUkFXOwoJcmV0dXJuIGNtZF9sb2dfd2FsaygmcmV2KTsKfQoKc3RhdGljIHZvaWQgc2hvd190YWdnZXIoY2hhciAqYnVmLCBpbnQgbGVuLCBzdHJ1Y3QgcmV2X2luZm8gKnJldikKewoJc3RydWN0IHN0cmJ1ZiBvdXQgPSBTVFJCVUZfSU5JVDsKCXN0cnVjdCBwcmV0dHlfcHJpbnRfY29udGV4dCBwcCA9IHswfTsKCglwcC5mbXQgPSByZXYtPmNvbW1pdF9mb3JtYXQ7CglwcC5kYXRlX21vZGUgPSByZXYtPmRhdGVfbW9kZTsKCXBwX3VzZXJfaW5mbygmcHAsICJUYWdnZXIiLCAmb3V0LCBidWYsIGdldF9sb2dfb3V0cHV0X2VuY29kaW5nKCkpOwoJcHJpbnRmKCIlcyIsIG91dC5idWYpOwoJc3RyYnVmX3JlbGVhc2UoJm91dCk7Cn0KCnN0YXRpYyBpbnQgc2hvd19ibG9iX29iamVjdChjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExLCBzdHJ1Y3QgcmV2X2luZm8gKnJldiwgY29uc3QgY2hhciAqb2JqX25hbWUpCnsKCXVuc2lnbmVkIGNoYXIgc2hhMWNbMjBdOwoJc3RydWN0IG9iamVjdF9jb250ZXh0IG9ial9jb250ZXh0OwoJY2hhciAqYnVmOwoJdW5zaWduZWQgbG9uZyBzaXplOwoKCWZmbHVzaChzdGRvdXQpOwoJaWYgKCFESUZGX09QVF9UT1VDSEVEKCZyZXYtPmRpZmZvcHQsIEFMTE9XX1RFWFRDT05WKSB8fAoJICAgICFESUZGX09QVF9UU1QoJnJldi0+ZGlmZm9wdCwgQUxMT1dfVEVYVENPTlYpKQoJCXJldHVybiBzdHJlYW1fYmxvYl90b19mZCgxLCBzaGExLCBOVUxMLCAwKTsKCglpZiAoZ2V0X3NoYTFfd2l0aF9jb250ZXh0KG9ial9uYW1lLCAwLCBzaGExYywgJm9ial9jb250ZXh0KSkKCQlkaWUoIk5vdCBhIHZhbGlkIG9iamVjdCBuYW1lICVzIiwgb2JqX25hbWUpOwoJaWYgKCFvYmpfY29udGV4dC5wYXRoWzBdIHx8CgkgICAgIXRleHRjb252X29iamVjdChvYmpfY29udGV4dC5wYXRoLCBvYmpfY29udGV4dC5tb2RlLCBzaGExYywgMSwgJmJ1ZiwgJnNpemUpKQoJCXJldHVybiBzdHJlYW1fYmxvYl90b19mZCgxLCBzaGExLCBOVUxMLCAwKTsKCglpZiAoIWJ1ZikKCQlkaWUoImdpdCBzaG93ICVzOiBiYWQgZmlsZSIsIG9ial9uYW1lKTsKCgl3cml0ZV9vcl9kaWUoMSwgYnVmLCBzaXplKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IHNob3dfdGFnX29iamVjdChjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExLCBzdHJ1Y3QgcmV2X2luZm8gKnJldikKewoJdW5zaWduZWQgbG9uZyBzaXplOwoJZW51bSBvYmplY3RfdHlwZSB0eXBlOwoJY2hhciAqYnVmID0gcmVhZF9zaGExX2ZpbGUoc2hhMSwgJnR5cGUsICZzaXplKTsKCWludCBvZmZzZXQgPSAwOwoKCWlmICghYnVmKQoJCXJldHVybiBlcnJvcihfKCJDb3VsZCBub3QgcmVhZCBvYmplY3QgJXMiKSwgc2hhMV90b19oZXgoc2hhMSkpOwoKCWFzc2VydCh0eXBlID09IE9CSl9UQUcpOwoJd2hpbGUgKG9mZnNldCA8IHNpemUgJiYgYnVmW29mZnNldF0gIT0gJ1xuJykgewoJCWludCBuZXdfb2Zmc2V0ID0gb2Zmc2V0ICsgMTsKCQl3aGlsZSAobmV3X29mZnNldCA8IHNpemUgJiYgYnVmW25ld19vZmZzZXQrK10gIT0gJ1xuJykKCQkJOyAvKiBkbyBub3RoaW5nICovCgkJaWYgKCFwcmVmaXhjbXAoYnVmICsgb2Zmc2V0LCAidGFnZ2VyICIpKQoJCQlzaG93X3RhZ2dlcihidWYgKyBvZmZzZXQgKyA3LAoJCQkJICAgIG5ld19vZmZzZXQgLSBvZmZzZXQgLSA3LCByZXYpOwoJCW9mZnNldCA9IG5ld19vZmZzZXQ7Cgl9CgoJaWYgKG9mZnNldCA8IHNpemUpCgkJZndyaXRlKGJ1ZiArIG9mZnNldCwgc2l6ZSAtIG9mZnNldCwgMSwgc3Rkb3V0KTsKCWZyZWUoYnVmKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IHNob3dfdHJlZV9vYmplY3QoY29uc3QgdW5zaWduZWQgY2hhciAqc2hhMSwKCQljb25zdCBjaGFyICpiYXNlLCBpbnQgYmFzZWxlbiwKCQljb25zdCBjaGFyICpwYXRobmFtZSwgdW5zaWduZWQgbW9kZSwgaW50IHN0YWdlLCB2b2lkICpjb250ZXh0KQp7CglwcmludGYoIiVzJXNcbiIsIHBhdGhuYW1lLCBTX0lTRElSKG1vZGUpID8gIi8iIDogIiIpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyB2b2lkIHNob3dfcmV2X3R3ZWFrX3JldihzdHJ1Y3QgcmV2X2luZm8gKnJldiwgc3RydWN0IHNldHVwX3JldmlzaW9uX29wdCAqb3B0KQp7CglpZiAocmV2LT5pZ25vcmVfbWVyZ2VzKSB7CgkJLyogVGhlcmUgd2FzIG5vICItbSIgb24gdGhlIGNvbW1hbmQgbGluZSAqLwoJCXJldi0+aWdub3JlX21lcmdlcyA9IDA7CgkJaWYgKCFyZXYtPmZpcnN0X3BhcmVudF9vbmx5ICYmICFyZXYtPmNvbWJpbmVfbWVyZ2VzKSB7CgkJCS8qIE5vICItLWZpcnN0LXBhcmVudCIsICItYyIsIG5vciAiLS1jYyIgKi8KCQkJcmV2LT5jb21iaW5lX21lcmdlcyA9IDE7CgkJCXJldi0+ZGVuc2VfY29tYmluZWRfbWVyZ2VzID0gMTsKCQl9Cgl9CglpZiAoIXJldi0+ZGlmZm9wdC5vdXRwdXRfZm9ybWF0KQoJCXJldi0+ZGlmZm9wdC5vdXRwdXRfZm9ybWF0ID0gRElGRl9GT1JNQVRfUEFUQ0g7Cn0KCmludCBjbWRfc2hvdyhpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsIGNvbnN0IGNoYXIgKnByZWZpeCkKewoJc3RydWN0IHJldl9pbmZvIHJldjsKCXN0cnVjdCBvYmplY3RfYXJyYXlfZW50cnkgKm9iamVjdHM7CglzdHJ1Y3Qgc2V0dXBfcmV2aXNpb25fb3B0IG9wdDsKCXN0cnVjdCBwYXRoc3BlYyBtYXRjaF9hbGw7CglpbnQgaSwgY291bnQsIHJldCA9IDA7CgoJaW5pdF9ncmVwX2RlZmF1bHRzKCk7CglnaXRfY29uZmlnKGdpdF9sb2dfY29uZmlnLCBOVUxMKTsKCgltZW1zZXQoJm1hdGNoX2FsbCwgMCwgc2l6ZW9mKG1hdGNoX2FsbCkpOwoJaW5pdF9yZXZpc2lvbnMoJnJldiwgcHJlZml4KTsKCXJldi5kaWZmID0gMTsKCXJldi5hbHdheXNfc2hvd19oZWFkZXIgPSAxOwoJcmV2Lm5vX3dhbGsgPSBSRVZJU0lPTl9XQUxLX05PX1dBTEtfU09SVEVEOwoJcmV2LmRpZmZvcHQuc3RhdF93aWR0aCA9IC0xOyAJLyogU2NhbGUgdG8gcmVhbCB0ZXJtaW5hbCBzaXplICovCgoJbWVtc2V0KCZvcHQsIDAsIHNpemVvZihvcHQpKTsKCW9wdC5kZWYgPSAiSEVBRCI7CglvcHQudHdlYWsgPSBzaG93X3Jldl90d2Vha19yZXY7CgljbWRfbG9nX2luaXQoYXJnYywgYXJndiwgcHJlZml4LCAmcmV2LCAmb3B0KTsKCglpZiAoIXJldi5ub193YWxrKQoJCXJldHVybiBjbWRfbG9nX3dhbGsoJnJldik7CgoJY291bnQgPSByZXYucGVuZGluZy5ucjsKCW9iamVjdHMgPSByZXYucGVuZGluZy5vYmplY3RzOwoJZm9yIChpID0gMDsgaSA8IGNvdW50ICYmICFyZXQ7IGkrKykgewoJCXN0cnVjdCBvYmplY3QgKm8gPSBvYmplY3RzW2ldLml0ZW07CgkJY29uc3QgY2hhciAqbmFtZSA9IG9iamVjdHNbaV0ubmFtZTsKCQlzd2l0Y2ggKG8tPnR5cGUpIHsKCQljYXNlIE9CSl9CTE9COgoJCQlyZXQgPSBzaG93X2Jsb2Jfb2JqZWN0KG8tPnNoYTEsICZyZXYsIG5hbWUpOwoJCQlicmVhazsKCQljYXNlIE9CSl9UQUc6IHsKCQkJc3RydWN0IHRhZyAqdCA9IChzdHJ1Y3QgdGFnICopbzsKCgkJCWlmIChyZXYuc2hvd25fb25lKQoJCQkJcHV0Y2hhcignXG4nKTsKCQkJcHJpbnRmKCIlc3RhZyAlcyVzXG4iLAoJCQkJCWRpZmZfZ2V0X2NvbG9yX29wdCgmcmV2LmRpZmZvcHQsIERJRkZfQ09NTUlUKSwKCQkJCQl0LT50YWcsCgkJCQkJZGlmZl9nZXRfY29sb3Jfb3B0KCZyZXYuZGlmZm9wdCwgRElGRl9SRVNFVCkpOwoJCQlyZXQgPSBzaG93X3RhZ19vYmplY3Qoby0+c2hhMSwgJnJldik7CgkJCXJldi5zaG93bl9vbmUgPSAxOwoJCQlpZiAocmV0KQoJCQkJYnJlYWs7CgkJCW8gPSBwYXJzZV9vYmplY3QodC0+dGFnZ2VkLT5zaGExKTsKCQkJaWYgKCFvKQoJCQkJcmV0ID0gZXJyb3IoXygiQ291bGQgbm90IHJlYWQgb2JqZWN0ICVzIiksCgkJCQkJICAgIHNoYTFfdG9faGV4KHQtPnRhZ2dlZC0+c2hhMSkpOwoJCQlvYmplY3RzW2ldLml0ZW0gPSBvOwoJCQlpLS07CgkJCWJyZWFrOwoJCX0KCQljYXNlIE9CSl9UUkVFOgoJCQlpZiAocmV2LnNob3duX29uZSkKCQkJCXB1dGNoYXIoJ1xuJyk7CgkJCXByaW50ZigiJXN0cmVlICVzJXNcblxuIiwKCQkJCQlkaWZmX2dldF9jb2xvcl9vcHQoJnJldi5kaWZmb3B0LCBESUZGX0NPTU1JVCksCgkJCQkJbmFtZSwKCQkJCQlkaWZmX2dldF9jb2xvcl9vcHQoJnJldi5kaWZmb3B0LCBESUZGX1JFU0VUKSk7CgkJCXJlYWRfdHJlZV9yZWN1cnNpdmUoKHN0cnVjdCB0cmVlICopbywgIiIsIDAsIDAsICZtYXRjaF9hbGwsCgkJCQkJc2hvd190cmVlX29iamVjdCwgTlVMTCk7CgkJCXJldi5zaG93bl9vbmUgPSAxOwoJCQlicmVhazsKCQljYXNlIE9CSl9DT01NSVQ6CgkJCXJldi5wZW5kaW5nLm5yID0gcmV2LnBlbmRpbmcuYWxsb2MgPSAwOwoJCQlyZXYucGVuZGluZy5vYmplY3RzID0gTlVMTDsKCQkJYWRkX29iamVjdF9hcnJheShvLCBuYW1lLCAmcmV2LnBlbmRpbmcpOwoJCQlyZXQgPSBjbWRfbG9nX3dhbGsoJnJldik7CgkJCWJyZWFrOwoJCWRlZmF1bHQ6CgkJCXJldCA9IGVycm9yKF8oIlVua25vd24gdHlwZTogJWQiKSwgby0+dHlwZSk7CgkJfQoJfQoJZnJlZShvYmplY3RzKTsKCXJldHVybiByZXQ7Cn0KCi8qCiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAiZ2l0IGxvZyAtZyAtLWFiYnJldi1jb21taXQgLS1wcmV0dHk9b25lbGluZSIKICovCmludCBjbWRfbG9nX3JlZmxvZyhpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsIGNvbnN0IGNoYXIgKnByZWZpeCkKewoJc3RydWN0IHJldl9pbmZvIHJldjsKCXN0cnVjdCBzZXR1cF9yZXZpc2lvbl9vcHQgb3B0OwoKCWluaXRfZ3JlcF9kZWZhdWx0cygpOwoJZ2l0X2NvbmZpZyhnaXRfbG9nX2NvbmZpZywgTlVMTCk7CgoJaW5pdF9yZXZpc2lvbnMoJnJldiwgcHJlZml4KTsKCWluaXRfcmVmbG9nX3dhbGsoJnJldi5yZWZsb2dfaW5mbyk7CglyZXYudmVyYm9zZV9oZWFkZXIgPSAxOwoJbWVtc2V0KCZvcHQsIDAsIHNpemVvZihvcHQpKTsKCW9wdC5kZWYgPSAiSEVBRCI7CgljbWRfbG9nX2luaXRfZGVmYXVsdHMoJnJldik7CglyZXYuYWJicmV2X2NvbW1pdCA9IDE7CglyZXYuY29tbWl0X2Zvcm1hdCA9IENNSVRfRk1UX09ORUxJTkU7CglyZXYudXNlX3Rlcm1pbmF0b3IgPSAxOwoJcmV2LmFsd2F5c19zaG93X2hlYWRlciA9IDE7CgljbWRfbG9nX2luaXRfZmluaXNoKGFyZ2MsIGFyZ3YsIHByZWZpeCwgJnJldiwgJm9wdCk7CgoJcmV0dXJuIGNtZF9sb2dfd2FsaygmcmV2KTsKfQoKaW50IGNtZF9sb2coaW50IGFyZ2MsIGNvbnN0IGNoYXIgKiphcmd2LCBjb25zdCBjaGFyICpwcmVmaXgpCnsKCXN0cnVjdCByZXZfaW5mbyByZXY7CglzdHJ1Y3Qgc2V0dXBfcmV2aXNpb25fb3B0IG9wdDsKCglpbml0X2dyZXBfZGVmYXVsdHMoKTsKCWdpdF9jb25maWcoZ2l0X2xvZ19jb25maWcsIE5VTEwpOwoKCWluaXRfcmV2aXNpb25zKCZyZXYsIHByZWZpeCk7CglyZXYuYWx3YXlzX3Nob3dfaGVhZGVyID0gMTsKCW1lbXNldCgmb3B0LCAwLCBzaXplb2Yob3B0KSk7CglvcHQuZGVmID0gIkhFQUQiOwoJb3B0LnJldmFyZ19vcHQgPSBSRVZBUkdfQ09NTUlUVElTSDsKCWNtZF9sb2dfaW5pdChhcmdjLCBhcmd2LCBwcmVmaXgsICZyZXYsICZvcHQpOwoJcmV0dXJuIGNtZF9sb2dfd2FsaygmcmV2KTsKfQoKLyogZm9ybWF0LXBhdGNoICovCgpzdGF0aWMgY29uc3QgY2hhciAqZm10X3BhdGNoX3N1ZmZpeCA9ICIucGF0Y2giOwpzdGF0aWMgaW50IG51bWJlcmVkID0gMDsKc3RhdGljIGludCBhdXRvX251bWJlciA9IDE7CgpzdGF0aWMgY2hhciAqZGVmYXVsdF9hdHRhY2ggPSBOVUxMOwoKc3RhdGljIHN0cnVjdCBzdHJpbmdfbGlzdCBleHRyYV9oZHI7CnN0YXRpYyBzdHJ1Y3Qgc3RyaW5nX2xpc3QgZXh0cmFfdG87CnN0YXRpYyBzdHJ1Y3Qgc3RyaW5nX2xpc3QgZXh0cmFfY2M7CgpzdGF0aWMgdm9pZCBhZGRfaGVhZGVyKGNvbnN0IGNoYXIgKnZhbHVlKQp7CglzdHJ1Y3Qgc3RyaW5nX2xpc3RfaXRlbSAqaXRlbTsKCWludCBsZW4gPSBzdHJsZW4odmFsdWUpOwoJd2hpbGUgKGxlbiAmJiB2YWx1ZVtsZW4gLSAxXSA9PSAnXG4nKQoJCWxlbi0tOwoKCWlmICghc3RybmNhc2VjbXAodmFsdWUsICJ0bzogIiwgNCkpIHsKCQlpdGVtID0gc3RyaW5nX2xpc3RfYXBwZW5kKCZleHRyYV90bywgdmFsdWUgKyA0KTsKCQlsZW4gLT0gNDsKCX0gZWxzZSBpZiAoIXN0cm5jYXNlY21wKHZhbHVlLCAiY2M6ICIsIDQpKSB7CgkJaXRlbSA9IHN0cmluZ19saXN0X2FwcGVuZCgmZXh0cmFfY2MsIHZhbHVlICsgNCk7CgkJbGVuIC09IDQ7Cgl9IGVsc2UgewoJCWl0ZW0gPSBzdHJpbmdfbGlzdF9hcHBlbmQoJmV4dHJhX2hkciwgdmFsdWUpOwoJfQoKCWl0ZW0tPnN0cmluZ1tsZW5dID0gJ1wwJzsKfQoKI2RlZmluZSBUSFJFQURfU0hBTExPVyAxCiNkZWZpbmUgVEhSRUFEX0RFRVAgMgpzdGF0aWMgaW50IHRocmVhZDsKc3RhdGljIGludCBkb19zaWdub2ZmOwpzdGF0aWMgY29uc3QgY2hhciAqc2lnbmF0dXJlID0gZ2l0X3ZlcnNpb25fc3RyaW5nOwpzdGF0aWMgaW50IGNvbmZpZ19jb3Zlcl9sZXR0ZXI7CgplbnVtIHsKCUNPVkVSX1VOU0VULAoJQ09WRVJfT0ZGLAoJQ09WRVJfT04sCglDT1ZFUl9BVVRPCn07CgpzdGF0aWMgaW50IGdpdF9mb3JtYXRfY29uZmlnKGNvbnN0IGNoYXIgKnZhciwgY29uc3QgY2hhciAqdmFsdWUsIHZvaWQgKmNiKQp7CglpZiAoIXN0cmNtcCh2YXIsICJmb3JtYXQuaGVhZGVycyIpKSB7CgkJaWYgKCF2YWx1ZSkKCQkJZGllKF8oImZvcm1hdC5oZWFkZXJzIHdpdGhvdXQgdmFsdWUiKSk7CgkJYWRkX2hlYWRlcih2YWx1ZSk7CgkJcmV0dXJuIDA7Cgl9CglpZiAoIXN0cmNtcCh2YXIsICJmb3JtYXQuc3VmZml4IikpCgkJcmV0dXJuIGdpdF9jb25maWdfc3RyaW5nKCZmbXRfcGF0Y2hfc3VmZml4LCB2YXIsIHZhbHVlKTsKCWlmICghc3RyY21wKHZhciwgImZvcm1hdC50byIpKSB7CgkJaWYgKCF2YWx1ZSkKCQkJcmV0dXJuIGNvbmZpZ19lcnJvcl9ub25ib29sKHZhcik7CgkJc3RyaW5nX2xpc3RfYXBwZW5kKCZleHRyYV90bywgdmFsdWUpOwoJCXJldHVybiAwOwoJfQoJaWYgKCFzdHJjbXAodmFyLCAiZm9ybWF0LmNjIikpIHsKCQlpZiAoIXZhbHVlKQoJCQlyZXR1cm4gY29uZmlnX2Vycm9yX25vbmJvb2wodmFyKTsKCQlzdHJpbmdfbGlzdF9hcHBlbmQoJmV4dHJhX2NjLCB2YWx1ZSk7CgkJcmV0dXJuIDA7Cgl9CglpZiAoIXN0cmNtcCh2YXIsICJkaWZmLmNvbG9yIikgfHwgIXN0cmNtcCh2YXIsICJjb2xvci5kaWZmIikgfHwKCSAgICAhc3RyY21wKHZhciwgImNvbG9yLnVpIikpIHsKCQlyZXR1cm4gMDsKCX0KCWlmICghc3RyY21wKHZhciwgImZvcm1hdC5udW1iZXJlZCIpKSB7CgkJaWYgKHZhbHVlICYmICFzdHJjYXNlY21wKHZhbHVlLCAiYXV0byIpKSB7CgkJCWF1dG9fbnVtYmVyID0gMTsKCQkJcmV0dXJuIDA7CgkJfQoJCW51bWJlcmVkID0gZ2l0X2NvbmZpZ19ib29sKHZhciwgdmFsdWUpOwoJCWF1dG9fbnVtYmVyID0gYXV0b19udW1iZXIgJiYgbnVtYmVyZWQ7CgkJcmV0dXJuIDA7Cgl9CglpZiAoIXN0cmNtcCh2YXIsICJmb3JtYXQuYXR0YWNoIikpIHsKCQlpZiAodmFsdWUgJiYgKnZhbHVlKQoJCQlkZWZhdWx0X2F0dGFjaCA9IHhzdHJkdXAodmFsdWUpOwoJCWVsc2UKCQkJZGVmYXVsdF9hdHRhY2ggPSB4c3RyZHVwKGdpdF92ZXJzaW9uX3N0cmluZyk7CgkJcmV0dXJuIDA7Cgl9CglpZiAoIXN0cmNtcCh2YXIsICJmb3JtYXQudGhyZWFkIikpIHsKCQlpZiAodmFsdWUgJiYgIXN0cmNhc2VjbXAodmFsdWUsICJkZWVwIikpIHsKCQkJdGhyZWFkID0gVEhSRUFEX0RFRVA7CgkJCXJldHVybiAwOwoJCX0KCQlpZiAodmFsdWUgJiYgIXN0cmNhc2VjbXAodmFsdWUsICJzaGFsbG93IikpIHsKCQkJdGhyZWFkID0gVEhSRUFEX1NIQUxMT1c7CgkJCXJldHVybiAwOwoJCX0KCQl0aHJlYWQgPSBnaXRfY29uZmlnX2Jvb2wodmFyLCB2YWx1ZSkgJiYgVEhSRUFEX1NIQUxMT1c7CgkJcmV0dXJuIDA7Cgl9CglpZiAoIXN0cmNtcCh2YXIsICJmb3JtYXQuc2lnbm9mZiIpKSB7CgkJZG9fc2lnbm9mZiA9IGdpdF9jb25maWdfYm9vbCh2YXIsIHZhbHVlKTsKCQlyZXR1cm4gMDsKCX0KCWlmICghc3RyY21wKHZhciwgImZvcm1hdC5zaWduYXR1cmUiKSkKCQlyZXR1cm4gZ2l0X2NvbmZpZ19zdHJpbmcoJnNpZ25hdHVyZSwgdmFyLCB2YWx1ZSk7CglpZiAoIXN0cmNtcCh2YXIsICJmb3JtYXQuY292ZXJsZXR0ZXIiKSkgewoJCWlmICh2YWx1ZSAmJiAhc3RyY2FzZWNtcCh2YWx1ZSwgImF1dG8iKSkgewoJCQljb25maWdfY292ZXJfbGV0dGVyID0gQ09WRVJfQVVUTzsKCQkJcmV0dXJuIDA7CgkJfQoJCWNvbmZpZ19jb3Zlcl9sZXR0ZXIgPSBnaXRfY29uZmlnX2Jvb2wodmFyLCB2YWx1ZSkgPyBDT1ZFUl9PTiA6IENPVkVSX09GRjsKCQlyZXR1cm4gMDsKCX0KCglyZXR1cm4gZ2l0X2xvZ19jb25maWcodmFyLCB2YWx1ZSwgY2IpOwp9CgpzdGF0aWMgRklMRSAqcmVhbHN0ZG91dCA9IE5VTEw7CnN0YXRpYyBjb25zdCBjaGFyICpvdXRwdXRfZGlyZWN0b3J5ID0gTlVMTDsKc3RhdGljIGludCBvdXRkaXJfb2Zmc2V0OwoKc3RhdGljIGludCByZW9wZW5fc3Rkb3V0KHN0cnVjdCBjb21taXQgKmNvbW1pdCwgY29uc3QgY2hhciAqc3ViamVjdCwKCQkJIHN0cnVjdCByZXZfaW5mbyAqcmV2LCBpbnQgcXVpZXQpCnsKCXN0cnVjdCBzdHJidWYgZmlsZW5hbWUgPSBTVFJCVUZfSU5JVDsKCWludCBzdWZmaXhfbGVuID0gc3RybGVuKHJldi0+cGF0Y2hfc3VmZml4KSArIDE7CgoJaWYgKG91dHB1dF9kaXJlY3RvcnkpIHsKCQlzdHJidWZfYWRkc3RyKCZmaWxlbmFtZSwgb3V0cHV0X2RpcmVjdG9yeSk7CgkJaWYgKGZpbGVuYW1lLmxlbiA+PQoJCSAgICBQQVRIX01BWCAtIEZPUk1BVF9QQVRDSF9OQU1FX01BWCAtIHN1ZmZpeF9sZW4pCgkJCXJldHVybiBlcnJvcihfKCJuYW1lIG9mIG91dHB1dCBkaXJlY3RvcnkgaXMgdG9vIGxvbmciKSk7CgkJaWYgKGZpbGVuYW1lLmJ1ZltmaWxlbmFtZS5sZW4gLSAxXSAhPSAnLycpCgkJCXN0cmJ1Zl9hZGRjaCgmZmlsZW5hbWUsICcvJyk7Cgl9CgoJaWYgKHJldi0+bnVtYmVyZWRfZmlsZXMpCgkJc3RyYnVmX2FkZGYoJmZpbGVuYW1lLCAiJWQiLCByZXYtPm5yKTsKCWVsc2UgaWYgKGNvbW1pdCkKCQlmbXRfb3V0cHV0X2NvbW1pdCgmZmlsZW5hbWUsIGNvbW1pdCwgcmV2KTsKCWVsc2UKCQlmbXRfb3V0cHV0X3N1YmplY3QoJmZpbGVuYW1lLCBzdWJqZWN0LCByZXYpOwoKCWlmICghcXVpZXQpCgkJZnByaW50ZihyZWFsc3Rkb3V0LCAiJXNcbiIsIGZpbGVuYW1lLmJ1ZiArIG91dGRpcl9vZmZzZXQpOwoKCWlmIChmcmVvcGVuKGZpbGVuYW1lLmJ1ZiwgInciLCBzdGRvdXQpID09IE5VTEwpCgkJcmV0dXJuIGVycm9yKF8oIkNhbm5vdCBvcGVuIHBhdGNoIGZpbGUgJXMiKSwgZmlsZW5hbWUuYnVmKTsKCglzdHJidWZfcmVsZWFzZSgmZmlsZW5hbWUpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyB2b2lkIGdldF9wYXRjaF9pZHMoc3RydWN0IHJldl9pbmZvICpyZXYsIHN0cnVjdCBwYXRjaF9pZHMgKmlkcykKewoJc3RydWN0IHJldl9pbmZvIGNoZWNrX3JldjsKCXN0cnVjdCBjb21taXQgKmNvbW1pdDsKCXN0cnVjdCBvYmplY3QgKm8xLCAqbzI7Cgl1bnNpZ25lZCBmbGFnczEsIGZsYWdzMjsKCglpZiAocmV2LT5wZW5kaW5nLm5yICE9IDIpCgkJZGllKF8oIk5lZWQgZXhhY3RseSBvbmUgcmFuZ2UuIikpOwoKCW8xID0gcmV2LT5wZW5kaW5nLm9iamVjdHNbMF0uaXRlbTsKCWZsYWdzMSA9IG8xLT5mbGFnczsKCW8yID0gcmV2LT5wZW5kaW5nLm9iamVjdHNbMV0uaXRlbTsKCWZsYWdzMiA9IG8yLT5mbGFnczsKCglpZiAoKGZsYWdzMSAmIFVOSU5URVJFU1RJTkcpID09IChmbGFnczIgJiBVTklOVEVSRVNUSU5HKSkKCQlkaWUoXygiTm90IGEgcmFuZ2UuIikpOwoKCWluaXRfcGF0Y2hfaWRzKGlkcyk7CgoJLyogZ2l2ZW4gYSByYW5nZSBhLi5iIGdldCBhbGwgcGF0Y2ggaWRzIGZvciBiLi5hICovCglpbml0X3JldmlzaW9ucygmY2hlY2tfcmV2LCByZXYtPnByZWZpeCk7CgljaGVja19yZXYubWF4X3BhcmVudHMgPSAxOwoJbzEtPmZsYWdzIF49IFVOSU5URVJFU1RJTkc7CglvMi0+ZmxhZ3MgXj0gVU5JTlRFUkVTVElORzsKCWFkZF9wZW5kaW5nX29iamVjdCgmY2hlY2tfcmV2LCBvMSwgIm8xIik7CglhZGRfcGVuZGluZ19vYmplY3QoJmNoZWNrX3JldiwgbzIsICJvMiIpOwoJaWYgKHByZXBhcmVfcmV2aXNpb25fd2FsaygmY2hlY2tfcmV2KSkKCQlkaWUoXygicmV2aXNpb24gd2FsayBzZXR1cCBmYWlsZWQiKSk7CgoJd2hpbGUgKChjb21taXQgPSBnZXRfcmV2aXNpb24oJmNoZWNrX3JldikpICE9IE5VTEwpIHsKCQlhZGRfY29tbWl0X3BhdGNoX2lkKGNvbW1pdCwgaWRzKTsKCX0KCgkvKiByZXNldCBmb3IgbmV4dCByZXZpc2lvbiB3YWxrICovCgljbGVhcl9jb21taXRfbWFya3MoKHN0cnVjdCBjb21taXQgKilvMSwKCQkJU0VFTiB8IFVOSU5URVJFU1RJTkcgfCBTSE9XTiB8IEFEREVEKTsKCWNsZWFyX2NvbW1pdF9tYXJrcygoc3RydWN0IGNvbW1pdCAqKW8yLAoJCQlTRUVOIHwgVU5JTlRFUkVTVElORyB8IFNIT1dOIHwgQURERUQpOwoJbzEtPmZsYWdzID0gZmxhZ3MxOwoJbzItPmZsYWdzID0gZmxhZ3MyOwp9CgpzdGF0aWMgdm9pZCBnZW5fbWVzc2FnZV9pZChzdHJ1Y3QgcmV2X2luZm8gKmluZm8sIGNoYXIgKmJhc2UpCnsKCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7CglzdHJidWZfYWRkZigmYnVmLCAiJXMuJWx1LmdpdC4lcyIsIGJhc2UsCgkJICAgICh1bnNpZ25lZCBsb25nKSB0aW1lKE5VTEwpLAoJCSAgICBnaXRfY29tbWl0dGVyX2luZm8oSURFTlRfTk9fTkFNRXxJREVOVF9OT19EQVRFfElERU5UX1NUUklDVCkpOwoJaW5mby0+bWVzc2FnZV9pZCA9IHN0cmJ1Zl9kZXRhY2goJmJ1ZiwgTlVMTCk7Cn0KCnN0YXRpYyB2b2lkIHByaW50X3NpZ25hdHVyZSh2b2lkKQp7CglpZiAoc2lnbmF0dXJlICYmICpzaWduYXR1cmUpCgkJcHJpbnRmKCItLSBcbiVzXG5cbiIsIHNpZ25hdHVyZSk7Cn0KCnN0YXRpYyB2b2lkIGFkZF9icmFuY2hfZGVzY3JpcHRpb24oc3RydWN0IHN0cmJ1ZiAqYnVmLCBjb25zdCBjaGFyICpicmFuY2hfbmFtZSkKewoJc3RydWN0IHN0cmJ1ZiBkZXNjID0gU1RSQlVGX0lOSVQ7CglpZiAoIWJyYW5jaF9uYW1lIHx8ICEqYnJhbmNoX25hbWUpCgkJcmV0dXJuOwoJcmVhZF9icmFuY2hfZGVzYygmZGVzYywgYnJhbmNoX25hbWUpOwoJaWYgKGRlc2MubGVuKSB7CgkJc3RyYnVmX2FkZGNoKGJ1ZiwgJ1xuJyk7CgkJc3RyYnVmX2FkZChidWYsIGRlc2MuYnVmLCBkZXNjLmxlbik7CgkJc3RyYnVmX2FkZGNoKGJ1ZiwgJ1xuJyk7Cgl9Cn0KCnN0YXRpYyBjaGFyICpmaW5kX2JyYW5jaF9uYW1lKHN0cnVjdCByZXZfaW5mbyAqcmV2KQp7CglpbnQgaSwgcG9zaXRpdmUgPSAtMTsKCXVuc2lnbmVkIGNoYXIgYnJhbmNoX3NoYTFbMjBdOwoJY29uc3QgdW5zaWduZWQgY2hhciAqdGlwX3NoYTE7Cgljb25zdCBjaGFyICpyZWY7CgljaGFyICpmdWxsX3JlZiwgKmJyYW5jaCA9IE5VTEw7CgoJZm9yIChpID0gMDsgaSA8IHJldi0+Y21kbGluZS5ucjsgaSsrKSB7CgkJaWYgKHJldi0+Y21kbGluZS5yZXZbaV0uZmxhZ3MgJiBVTklOVEVSRVNUSU5HKQoJCQljb250aW51ZTsKCQlpZiAocG9zaXRpdmUgPCAwKQoJCQlwb3NpdGl2ZSA9IGk7CgkJZWxzZQoJCQlyZXR1cm4gTlVMTDsKCX0KCWlmIChwb3NpdGl2ZSA8IDApCgkJcmV0dXJuIE5VTEw7CglyZWYgPSByZXYtPmNtZGxpbmUucmV2W3Bvc2l0aXZlXS5uYW1lOwoJdGlwX3NoYTEgPSByZXYtPmNtZGxpbmUucmV2W3Bvc2l0aXZlXS5pdGVtLT5zaGExOwoJaWYgKGR3aW1fcmVmKHJlZiwgc3RybGVuKHJlZiksIGJyYW5jaF9zaGExLCAmZnVsbF9yZWYpICYmCgkgICAgIXByZWZpeGNtcChmdWxsX3JlZiwgInJlZnMvaGVhZHMvIikgJiYKCSAgICAhaGFzaGNtcCh0aXBfc2hhMSwgYnJhbmNoX3NoYTEpKQoJCWJyYW5jaCA9IHhzdHJkdXAoZnVsbF9yZWYgKyBzdHJsZW4oInJlZnMvaGVhZHMvIikpOwoJZnJlZShmdWxsX3JlZik7CglyZXR1cm4gYnJhbmNoOwp9CgpzdGF0aWMgdm9pZCBtYWtlX2NvdmVyX2xldHRlcihzdHJ1Y3QgcmV2X2luZm8gKnJldiwgaW50IHVzZV9zdGRvdXQsCgkJCSAgICAgIHN0cnVjdCBjb21taXQgKm9yaWdpbiwKCQkJICAgICAgaW50IG5yLCBzdHJ1Y3QgY29tbWl0ICoqbGlzdCwKCQkJICAgICAgY29uc3QgY2hhciAqYnJhbmNoX25hbWUsCgkJCSAgICAgIGludCBxdWlldCkKewoJY29uc3QgY2hhciAqY29tbWl0dGVyOwoJY29uc3QgY2hhciAqYm9keSA9ICIqKiogU1VCSkVDVCBIRVJFICoqKlxuXG4qKiogQkxVUkIgSEVSRSAqKipcbiI7Cgljb25zdCBjaGFyICptc2c7CglzdHJ1Y3Qgc2hvcnRsb2cgbG9nOwoJc3RydWN0IHN0cmJ1ZiBzYiA9IFNUUkJVRl9JTklUOwoJaW50IGk7Cgljb25zdCBjaGFyICplbmNvZGluZyA9ICJVVEYtOCI7CglzdHJ1Y3QgZGlmZl9vcHRpb25zIG9wdHM7CglpbnQgbmVlZF84Yml0X2N0ZSA9IDA7CglzdHJ1Y3QgcHJldHR5X3ByaW50X2NvbnRleHQgcHAgPSB7MH07CglzdHJ1Y3QgY29tbWl0ICpoZWFkID0gbGlzdFswXTsKCglpZiAocmV2LT5jb21taXRfZm9ybWF0ICE9IENNSVRfRk1UX0VNQUlMKQoJCWRpZShfKCJDb3ZlciBsZXR0ZXIgbmVlZHMgZW1haWwgZm9ybWF0IikpOwoKCWNvbW1pdHRlciA9IGdpdF9jb21taXR0ZXJfaW5mbygwKTsKCglpZiAoIXVzZV9zdGRvdXQgJiYKCSAgICByZW9wZW5fc3Rkb3V0KE5VTEwsIHJldi0+bnVtYmVyZWRfZmlsZXMgPyBOVUxMIDogImNvdmVyLWxldHRlciIsIHJldiwgcXVpZXQpKQoJCXJldHVybjsKCglsb2dfd3JpdGVfZW1haWxfaGVhZGVycyhyZXYsIGhlYWQsICZwcC5zdWJqZWN0LCAmcHAuYWZ0ZXJfc3ViamVjdCwKCQkJCSZuZWVkXzhiaXRfY3RlKTsKCglmb3IgKGkgPSAwOyAhbmVlZF84Yml0X2N0ZSAmJiBpIDwgbnI7IGkrKykKCQlpZiAoaGFzX25vbl9hc2NpaShsaXN0W2ldLT5idWZmZXIpKQoJCQluZWVkXzhiaXRfY3RlID0gMTsKCglpZiAoIWJyYW5jaF9uYW1lKQoJCWJyYW5jaF9uYW1lID0gZmluZF9icmFuY2hfbmFtZShyZXYpOwoKCW1zZyA9IGJvZHk7CglwcC5mbXQgPSBDTUlUX0ZNVF9FTUFJTDsKCXBwLmRhdGVfbW9kZSA9IERBVEVfUkZDMjgyMjsKCXBwX3VzZXJfaW5mbygmcHAsIE5VTEwsICZzYiwgY29tbWl0dGVyLCBlbmNvZGluZyk7CglwcF90aXRsZV9saW5lKCZwcCwgJm1zZywgJnNiLCBlbmNvZGluZywgbmVlZF84Yml0X2N0ZSk7CglwcF9yZW1haW5kZXIoJnBwLCAmbXNnLCAmc2IsIDApOwoJYWRkX2JyYW5jaF9kZXNjcmlwdGlvbigmc2IsIGJyYW5jaF9uYW1lKTsKCXByaW50ZigiJXNcbiIsIHNiLmJ1Zik7CgoJc3RyYnVmX3JlbGVhc2UoJnNiKTsKCglzaG9ydGxvZ19pbml0KCZsb2cpOwoJbG9nLndyYXBfbGluZXMgPSAxOwoJbG9nLndyYXAgPSA3MjsKCWxvZy5pbjEgPSAyOwoJbG9nLmluMiA9IDQ7Cglmb3IgKGkgPSAwOyBpIDwgbnI7IGkrKykKCQlzaG9ydGxvZ19hZGRfY29tbWl0KCZsb2csIGxpc3RbaV0pOwoKCXNob3J0bG9nX291dHB1dCgmbG9nKTsKCgkvKgoJICogV2UgY2FuIG9ubHkgZG8gZGlmZnN0YXQgd2l0aCBhIHVuaXF1ZSByZWZlcmVuY2UgcG9pbnQKCSAqLwoJaWYgKCFvcmlnaW4pCgkJcmV0dXJuOwoKCW1lbWNweSgmb3B0cywgJnJldi0+ZGlmZm9wdCwgc2l6ZW9mKG9wdHMpKTsKCW9wdHMub3V0cHV0X2Zvcm1hdCA9IERJRkZfRk9STUFUX1NVTU1BUlkgfCBESUZGX0ZPUk1BVF9ESUZGU1RBVDsKCglkaWZmX3NldHVwX2RvbmUoJm9wdHMpOwoKCWRpZmZfdHJlZV9zaGExKG9yaWdpbi0+dHJlZS0+b2JqZWN0LnNoYTEsCgkJICAgICAgIGhlYWQtPnRyZWUtPm9iamVjdC5zaGExLAoJCSAgICAgICAiIiwgJm9wdHMpOwoJZGlmZmNvcmVfc3RkKCZvcHRzKTsKCWRpZmZfZmx1c2goJm9wdHMpOwoKCXByaW50ZigiXG4iKTsKCXByaW50X3NpZ25hdHVyZSgpOwp9CgpzdGF0aWMgY29uc3QgY2hhciAqY2xlYW5fbWVzc2FnZV9pZChjb25zdCBjaGFyICptc2dfaWQpCnsKCWNoYXIgY2g7Cgljb25zdCBjaGFyICphLCAqeiwgKm07CgoJbSA9IG1zZ19pZDsKCXdoaWxlICgoY2ggPSAqbSkgJiYgKGlzc3BhY2UoY2gpIHx8IChjaCA9PSAnPCcpKSkKCQltKys7CglhID0gbTsKCXogPSBOVUxMOwoJd2hpbGUgKChjaCA9ICptKSkgewoJCWlmICghaXNzcGFjZShjaCkgJiYgKGNoICE9ICc+JykpCgkJCXogPSBtOwoJCW0rKzsKCX0KCWlmICgheikKCQlkaWUoXygiaW5zYW5lIGluLXJlcGx5LXRvOiAlcyIpLCBtc2dfaWQpOwoJaWYgKCsreiA9PSBtKQoJCXJldHVybiBhOwoJcmV0dXJuIHhtZW1kdXB6KGEsIHogLSBhKTsKfQoKc3RhdGljIGNvbnN0IGNoYXIgKnNldF9vdXRkaXIoY29uc3QgY2hhciAqcHJlZml4LCBjb25zdCBjaGFyICpvdXRwdXRfZGlyZWN0b3J5KQp7CglpZiAob3V0cHV0X2RpcmVjdG9yeSAmJiBpc19hYnNvbHV0ZV9wYXRoKG91dHB1dF9kaXJlY3RvcnkpKQoJCXJldHVybiBvdXRwdXRfZGlyZWN0b3J5OwoKCWlmICghcHJlZml4IHx8ICEqcHJlZml4KSB7CgkJaWYgKG91dHB1dF9kaXJlY3RvcnkpCgkJCXJldHVybiBvdXRwdXRfZGlyZWN0b3J5OwoJCS8qIFRoZSB1c2VyIGRpZCBub3QgZXhwbGljaXRseSBhc2sgZm9yICIuLyIgKi8KCQlvdXRkaXJfb2Zmc2V0ID0gMjsKCQlyZXR1cm4gIi4vIjsKCX0KCglvdXRkaXJfb2Zmc2V0ID0gc3RybGVuKHByZWZpeCk7CglpZiAoIW91dHB1dF9kaXJlY3RvcnkpCgkJcmV0dXJuIHByZWZpeDsKCglyZXR1cm4geHN0cmR1cChwcmVmaXhfZmlsZW5hbWUocHJlZml4LCBvdXRkaXJfb2Zmc2V0LAoJCQkJICAgICAgIG91dHB1dF9kaXJlY3RvcnkpKTsKfQoKc3RhdGljIGNvbnN0IGNoYXIgKiBjb25zdCBidWlsdGluX2Zvcm1hdF9wYXRjaF91c2FnZVtdID0gewoJTl8oImdpdCBmb3JtYXQtcGF0Y2ggW29wdGlvbnNdIFs8c2luY2U+IHwgPHJldmlzaW9uIHJhbmdlPl0iKSwKCU5VTEwKfTsKCnN0YXRpYyBpbnQga2VlcF9zdWJqZWN0ID0gMDsKCnN0YXRpYyBpbnQga2VlcF9jYWxsYmFjayhjb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHQsIGNvbnN0IGNoYXIgKmFyZywgaW50IHVuc2V0KQp7CgkoKHN0cnVjdCByZXZfaW5mbyAqKW9wdC0+dmFsdWUpLT50b3RhbCA9IC0xOwoJa2VlcF9zdWJqZWN0ID0gMTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IHN1YmplY3RfcHJlZml4ID0gMDsKCnN0YXRpYyBpbnQgc3ViamVjdF9wcmVmaXhfY2FsbGJhY2soY29uc3Qgc3RydWN0IG9wdGlvbiAqb3B0LCBjb25zdCBjaGFyICphcmcsCgkJCSAgICBpbnQgdW5zZXQpCnsKCXN1YmplY3RfcHJlZml4ID0gMTsKCSgoc3RydWN0IHJldl9pbmZvICopb3B0LT52YWx1ZSktPnN1YmplY3RfcHJlZml4ID0gYXJnOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgbnVtYmVyZWRfY21kbGluZV9vcHQgPSAwOwoKc3RhdGljIGludCBudW1iZXJlZF9jYWxsYmFjayhjb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHQsIGNvbnN0IGNoYXIgKmFyZywKCQkJICAgICBpbnQgdW5zZXQpCnsKCSooaW50ICopb3B0LT52YWx1ZSA9IG51bWJlcmVkX2NtZGxpbmVfb3B0ID0gdW5zZXQgPyAwIDogMTsKCWlmICh1bnNldCkKCQlhdXRvX251bWJlciA9ICAwOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgbm9fbnVtYmVyZWRfY2FsbGJhY2soY29uc3Qgc3RydWN0IG9wdGlvbiAqb3B0LCBjb25zdCBjaGFyICphcmcsCgkJCQlpbnQgdW5zZXQpCnsKCXJldHVybiBudW1iZXJlZF9jYWxsYmFjayhvcHQsIGFyZywgMSk7Cn0KCnN0YXRpYyBpbnQgb3V0cHV0X2RpcmVjdG9yeV9jYWxsYmFjayhjb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHQsIGNvbnN0IGNoYXIgKmFyZywKCQkJICAgICAgaW50IHVuc2V0KQp7Cgljb25zdCBjaGFyICoqZGlyID0gKGNvbnN0IGNoYXIgKiopb3B0LT52YWx1ZTsKCWlmICgqZGlyKQoJCWRpZShfKCJUd28gb3V0cHV0IGRpcmVjdG9yaWVzPyIpKTsKCSpkaXIgPSBhcmc7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCB0aHJlYWRfY2FsbGJhY2soY29uc3Qgc3RydWN0IG9wdGlvbiAqb3B0LCBjb25zdCBjaGFyICphcmcsIGludCB1bnNldCkKewoJaW50ICp0aHJlYWQgPSAoaW50ICopb3B0LT52YWx1ZTsKCWlmICh1bnNldCkKCQkqdGhyZWFkID0gMDsKCWVsc2UgaWYgKCFhcmcgfHwgIXN0cmNtcChhcmcsICJzaGFsbG93IikpCgkJKnRocmVhZCA9IFRIUkVBRF9TSEFMTE9XOwoJZWxzZSBpZiAoIXN0cmNtcChhcmcsICJkZWVwIikpCgkJKnRocmVhZCA9IFRIUkVBRF9ERUVQOwoJZWxzZQoJCXJldHVybiAxOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgYXR0YWNoX2NhbGxiYWNrKGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdCwgY29uc3QgY2hhciAqYXJnLCBpbnQgdW5zZXQpCnsKCXN0cnVjdCByZXZfaW5mbyAqcmV2ID0gKHN0cnVjdCByZXZfaW5mbyAqKW9wdC0+dmFsdWU7CglpZiAodW5zZXQpCgkJcmV2LT5taW1lX2JvdW5kYXJ5ID0gTlVMTDsKCWVsc2UgaWYgKGFyZykKCQlyZXYtPm1pbWVfYm91bmRhcnkgPSBhcmc7CgllbHNlCgkJcmV2LT5taW1lX2JvdW5kYXJ5ID0gZ2l0X3ZlcnNpb25fc3RyaW5nOwoJcmV2LT5ub19pbmxpbmUgPSB1bnNldCA/IDAgOiAxOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgaW5saW5lX2NhbGxiYWNrKGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdCwgY29uc3QgY2hhciAqYXJnLCBpbnQgdW5zZXQpCnsKCXN0cnVjdCByZXZfaW5mbyAqcmV2ID0gKHN0cnVjdCByZXZfaW5mbyAqKW9wdC0+dmFsdWU7CglpZiAodW5zZXQpCgkJcmV2LT5taW1lX2JvdW5kYXJ5ID0gTlVMTDsKCWVsc2UgaWYgKGFyZykKCQlyZXYtPm1pbWVfYm91bmRhcnkgPSBhcmc7CgllbHNlCgkJcmV2LT5taW1lX2JvdW5kYXJ5ID0gZ2l0X3ZlcnNpb25fc3RyaW5nOwoJcmV2LT5ub19pbmxpbmUgPSAwOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgaGVhZGVyX2NhbGxiYWNrKGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdCwgY29uc3QgY2hhciAqYXJnLCBpbnQgdW5zZXQpCnsKCWlmICh1bnNldCkgewoJCXN0cmluZ19saXN0X2NsZWFyKCZleHRyYV9oZHIsIDApOwoJCXN0cmluZ19saXN0X2NsZWFyKCZleHRyYV90bywgMCk7CgkJc3RyaW5nX2xpc3RfY2xlYXIoJmV4dHJhX2NjLCAwKTsKCX0gZWxzZSB7CgkgICAgYWRkX2hlYWRlcihhcmcpOwoJfQoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgdG9fY2FsbGJhY2soY29uc3Qgc3RydWN0IG9wdGlvbiAqb3B0LCBjb25zdCBjaGFyICphcmcsIGludCB1bnNldCkKewoJaWYgKHVuc2V0KQoJCXN0cmluZ19saXN0X2NsZWFyKCZleHRyYV90bywgMCk7CgllbHNlCgkJc3RyaW5nX2xpc3RfYXBwZW5kKCZleHRyYV90bywgYXJnKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGNjX2NhbGxiYWNrKGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdCwgY29uc3QgY2hhciAqYXJnLCBpbnQgdW5zZXQpCnsKCWlmICh1bnNldCkKCQlzdHJpbmdfbGlzdF9jbGVhcigmZXh0cmFfY2MsIDApOwoJZWxzZQoJCXN0cmluZ19saXN0X2FwcGVuZCgmZXh0cmFfY2MsIGFyZyk7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBmcm9tX2NhbGxiYWNrKGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdCwgY29uc3QgY2hhciAqYXJnLCBpbnQgdW5zZXQpCnsKCWNoYXIgKipmcm9tID0gb3B0LT52YWx1ZTsKCglmcmVlKCpmcm9tKTsKCglpZiAodW5zZXQpCgkJKmZyb20gPSBOVUxMOwoJZWxzZSBpZiAoYXJnKQoJCSpmcm9tID0geHN0cmR1cChhcmcpOwoJZWxzZQoJCSpmcm9tID0geHN0cmR1cChnaXRfY29tbWl0dGVyX2luZm8oSURFTlRfTk9fREFURSkpOwoJcmV0dXJuIDA7Cn0KCmludCBjbWRfZm9ybWF0X3BhdGNoKGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndiwgY29uc3QgY2hhciAqcHJlZml4KQp7CglzdHJ1Y3QgY29tbWl0ICpjb21taXQ7CglzdHJ1Y3QgY29tbWl0ICoqbGlzdCA9IE5VTEw7CglzdHJ1Y3QgcmV2X2luZm8gcmV2OwoJc3RydWN0IHNldHVwX3JldmlzaW9uX29wdCBzX3Jfb3B0OwoJaW50IG5yID0gMCwgdG90YWwsIGk7CglpbnQgdXNlX3N0ZG91dCA9IDA7CglpbnQgc3RhcnRfbnVtYmVyID0gLTE7CglpbnQganVzdF9udW1iZXJzID0gMDsKCWludCBpZ25vcmVfaWZfaW5fdXBzdHJlYW0gPSAwOwoJaW50IGNvdmVyX2xldHRlciA9IC0xOwoJaW50IGJvdW5kYXJ5X2NvdW50ID0gMDsKCWludCBub19iaW5hcnlfZGlmZiA9IDA7CglzdHJ1Y3QgY29tbWl0ICpvcmlnaW4gPSBOVUxMOwoJY29uc3QgY2hhciAqaW5fcmVwbHlfdG8gPSBOVUxMOwoJc3RydWN0IHBhdGNoX2lkcyBpZHM7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoJaW50IHVzZV9wYXRjaF9mb3JtYXQgPSAwOwoJaW50IHF1aWV0ID0gMDsKCWludCByZXJvbGxfY291bnQgPSAtMTsKCWNoYXIgKmJyYW5jaF9uYW1lID0gTlVMTDsKCWNoYXIgKmZyb20gPSBOVUxMOwoJY29uc3Qgc3RydWN0IG9wdGlvbiBidWlsdGluX2Zvcm1hdF9wYXRjaF9vcHRpb25zW10gPSB7CgkJeyBPUFRJT05fQ0FMTEJBQ0ssICduJywgIm51bWJlcmVkIiwgJm51bWJlcmVkLCBOVUxMLAoJCQkgICAgTl8oInVzZSBbUEFUQ0ggbi9tXSBldmVuIHdpdGggYSBzaW5nbGUgcGF0Y2giKSwKCQkJICAgIFBBUlNFX09QVF9OT0FSRywgbnVtYmVyZWRfY2FsbGJhY2sgfSwKCQl7IE9QVElPTl9DQUxMQkFDSywgJ04nLCAibm8tbnVtYmVyZWQiLCAmbnVtYmVyZWQsIE5VTEwsCgkJCSAgICBOXygidXNlIFtQQVRDSF0gZXZlbiB3aXRoIG11bHRpcGxlIHBhdGNoZXMiKSwKCQkJICAgIFBBUlNFX09QVF9OT0FSRywgbm9fbnVtYmVyZWRfY2FsbGJhY2sgfSwKCQlPUFRfQk9PTCgncycsICJzaWdub2ZmIiwgJmRvX3NpZ25vZmYsIE5fKCJhZGQgU2lnbmVkLW9mZi1ieToiKSksCgkJT1BUX0JPT0woMCwgInN0ZG91dCIsICZ1c2Vfc3Rkb3V0LAoJCQkgICAgTl8oInByaW50IHBhdGNoZXMgdG8gc3RhbmRhcmQgb3V0IikpLAoJCU9QVF9CT09MKDAsICJjb3Zlci1sZXR0ZXIiLCAmY292ZXJfbGV0dGVyLAoJCQkgICAgTl8oImdlbmVyYXRlIGEgY292ZXIgbGV0dGVyIikpLAoJCU9QVF9CT09MKDAsICJudW1iZXJlZC1maWxlcyIsICZqdXN0X251bWJlcnMsCgkJCSAgICBOXygidXNlIHNpbXBsZSBudW1iZXIgc2VxdWVuY2UgZm9yIG91dHB1dCBmaWxlIG5hbWVzIikpLAoJCU9QVF9TVFJJTkcoMCwgInN1ZmZpeCIsICZmbXRfcGF0Y2hfc3VmZml4LCBOXygic2Z4IiksCgkJCSAgICBOXygidXNlIDxzZng+IGluc3RlYWQgb2YgJy5wYXRjaCciKSksCgkJT1BUX0lOVEVHRVIoMCwgInN0YXJ0LW51bWJlciIsICZzdGFydF9udW1iZXIsCgkJCSAgICBOXygic3RhcnQgbnVtYmVyaW5nIHBhdGNoZXMgYXQgPG4+IGluc3RlYWQgb2YgMSIpKSwKCQlPUFRfSU5URUdFUigndicsICJyZXJvbGwtY291bnQiLCAmcmVyb2xsX2NvdW50LAoJCQkgICAgTl8oIm1hcmsgdGhlIHNlcmllcyBhcyBOdGggcmUtcm9sbCIpKSwKCQl7IE9QVElPTl9DQUxMQkFDSywgMCwgInN1YmplY3QtcHJlZml4IiwgJnJldiwgTl8oInByZWZpeCIpLAoJCQkgICAgTl8oIlVzZSBbPHByZWZpeD5dIGluc3RlYWQgb2YgW1BBVENIXSIpLAoJCQkgICAgUEFSU0VfT1BUX05PTkVHLCBzdWJqZWN0X3ByZWZpeF9jYWxsYmFjayB9LAoJCXsgT1BUSU9OX0NBTExCQUNLLCAnbycsICJvdXRwdXQtZGlyZWN0b3J5IiwgJm91dHB1dF9kaXJlY3RvcnksCgkJCSAgICBOXygiZGlyIiksIE5fKCJzdG9yZSByZXN1bHRpbmcgZmlsZXMgaW4gPGRpcj4iKSwKCQkJICAgIFBBUlNFX09QVF9OT05FRywgb3V0cHV0X2RpcmVjdG9yeV9jYWxsYmFjayB9LAoJCXsgT1BUSU9OX0NBTExCQUNLLCAnaycsICJrZWVwLXN1YmplY3QiLCAmcmV2LCBOVUxMLAoJCQkgICAgTl8oImRvbid0IHN0cmlwL2FkZCBbUEFUQ0hdIiksCgkJCSAgICBQQVJTRV9PUFRfTk9BUkcgfCBQQVJTRV9PUFRfTk9ORUcsIGtlZXBfY2FsbGJhY2sgfSwKCQlPUFRfQk9PTCgwLCAibm8tYmluYXJ5IiwgJm5vX2JpbmFyeV9kaWZmLAoJCQkgTl8oImRvbid0IG91dHB1dCBiaW5hcnkgZGlmZnMiKSksCgkJT1BUX0JPT0woMCwgImlnbm9yZS1pZi1pbi11cHN0cmVhbSIsICZpZ25vcmVfaWZfaW5fdXBzdHJlYW0sCgkJCSBOXygiZG9uJ3QgaW5jbHVkZSBhIHBhdGNoIG1hdGNoaW5nIGEgY29tbWl0IHVwc3RyZWFtIikpLAoJCXsgT1BUSU9OX1NFVF9JTlQsICdwJywgIm5vLXN0YXQiLCAmdXNlX3BhdGNoX2Zvcm1hdCwgTlVMTCwKCQkgIE5fKCJzaG93IHBhdGNoIGZvcm1hdCBpbnN0ZWFkIG9mIGRlZmF1bHQgKHBhdGNoICsgc3RhdCkiKSwKCQkgIFBBUlNFX09QVF9OT05FRyB8IFBBUlNFX09QVF9OT0FSRywgTlVMTCwgMX0sCgkJT1BUX0dST1VQKE5fKCJNZXNzYWdpbmciKSksCgkJeyBPUFRJT05fQ0FMTEJBQ0ssIDAsICJhZGQtaGVhZGVyIiwgTlVMTCwgTl8oImhlYWRlciIpLAoJCQkgICAgTl8oImFkZCBlbWFpbCBoZWFkZXIiKSwgMCwgaGVhZGVyX2NhbGxiYWNrIH0sCgkJeyBPUFRJT05fQ0FMTEJBQ0ssIDAsICJ0byIsIE5VTEwsIE5fKCJlbWFpbCIpLCBOXygiYWRkIFRvOiBoZWFkZXIiKSwKCQkJICAgIDAsIHRvX2NhbGxiYWNrIH0sCgkJeyBPUFRJT05fQ0FMTEJBQ0ssIDAsICJjYyIsIE5VTEwsIE5fKCJlbWFpbCIpLCBOXygiYWRkIENjOiBoZWFkZXIiKSwKCQkJICAgIDAsIGNjX2NhbGxiYWNrIH0sCgkJeyBPUFRJT05fQ0FMTEJBQ0ssIDAsICJmcm9tIiwgJmZyb20sIE5fKCJpZGVudCIpLAoJCQkgICAgTl8oInNldCBGcm9tIGFkZHJlc3MgdG8gPGlkZW50PiAob3IgY29tbWl0dGVyIGlkZW50IGlmIGFic2VudCkiKSwKCQkJICAgIFBBUlNFX09QVF9PUFRBUkcsIGZyb21fY2FsbGJhY2sgfSwKCQlPUFRfU1RSSU5HKDAsICJpbi1yZXBseS10byIsICZpbl9yZXBseV90bywgTl8oIm1lc3NhZ2UtaWQiKSwKCQkJICAgIE5fKCJtYWtlIGZpcnN0IG1haWwgYSByZXBseSB0byA8bWVzc2FnZS1pZD4iKSksCgkJeyBPUFRJT05fQ0FMTEJBQ0ssIDAsICJhdHRhY2giLCAmcmV2LCBOXygiYm91bmRhcnkiKSwKCQkJICAgIE5fKCJhdHRhY2ggdGhlIHBhdGNoIiksIFBBUlNFX09QVF9PUFRBUkcsCgkJCSAgICBhdHRhY2hfY2FsbGJhY2sgfSwKCQl7IE9QVElPTl9DQUxMQkFDSywgMCwgImlubGluZSIsICZyZXYsIE5fKCJib3VuZGFyeSIpLAoJCQkgICAgTl8oImlubGluZSB0aGUgcGF0Y2giKSwKCQkJICAgIFBBUlNFX09QVF9PUFRBUkcgfCBQQVJTRV9PUFRfTk9ORUcsCgkJCSAgICBpbmxpbmVfY2FsbGJhY2sgfSwKCQl7IE9QVElPTl9DQUxMQkFDSywgMCwgInRocmVhZCIsICZ0aHJlYWQsIE5fKCJzdHlsZSIpLAoJCQkgICAgTl8oImVuYWJsZSBtZXNzYWdlIHRocmVhZGluZywgc3R5bGVzOiBzaGFsbG93LCBkZWVwIiksCgkJCSAgICBQQVJTRV9PUFRfT1BUQVJHLCB0aHJlYWRfY2FsbGJhY2sgfSwKCQlPUFRfU1RSSU5HKDAsICJzaWduYXR1cmUiLCAmc2lnbmF0dXJlLCBOXygic2lnbmF0dXJlIiksCgkJCSAgICBOXygiYWRkIGEgc2lnbmF0dXJlIikpLAoJCU9QVF9fUVVJRVQoJnF1aWV0LCBOXygiZG9uJ3QgcHJpbnQgdGhlIHBhdGNoIGZpbGVuYW1lcyIpKSwKCQlPUFRfRU5EKCkKCX07CgoJZXh0cmFfaGRyLnN0cmR1cF9zdHJpbmdzID0gMTsKCWV4dHJhX3RvLnN0cmR1cF9zdHJpbmdzID0gMTsKCWV4dHJhX2NjLnN0cmR1cF9zdHJpbmdzID0gMTsKCWluaXRfZ3JlcF9kZWZhdWx0cygpOwoJZ2l0X2NvbmZpZyhnaXRfZm9ybWF0X2NvbmZpZywgTlVMTCk7Cglpbml0X3JldmlzaW9ucygmcmV2LCBwcmVmaXgpOwoJcmV2LmNvbW1pdF9mb3JtYXQgPSBDTUlUX0ZNVF9FTUFJTDsKCXJldi52ZXJib3NlX2hlYWRlciA9IDE7CglyZXYuZGlmZiA9IDE7CglyZXYubWF4X3BhcmVudHMgPSAxOwoJRElGRl9PUFRfU0VUKCZyZXYuZGlmZm9wdCwgUkVDVVJTSVZFKTsKCXJldi5zdWJqZWN0X3ByZWZpeCA9IGZtdF9wYXRjaF9zdWJqZWN0X3ByZWZpeDsKCW1lbXNldCgmc19yX29wdCwgMCwgc2l6ZW9mKHNfcl9vcHQpKTsKCXNfcl9vcHQuZGVmID0gIkhFQUQiOwoJc19yX29wdC5yZXZhcmdfb3B0ID0gUkVWQVJHX0NPTU1JVFRJU0g7CgoJaWYgKGRlZmF1bHRfYXR0YWNoKSB7CgkJcmV2Lm1pbWVfYm91bmRhcnkgPSBkZWZhdWx0X2F0dGFjaDsKCQlyZXYubm9faW5saW5lID0gMTsKCX0KCgkvKgoJICogUGFyc2UgdGhlIGFyZ3VtZW50cyBiZWZvcmUgc2V0dXBfcmV2aXNpb25zKCksIG9yIHNvbWV0aGluZwoJICogbGlrZSAiZ2l0IGZvcm1hdC1wYXRjaCAtbyBhMTIzIEhFQUReLi4iIG1heSBmYWlsOyBhMTIzIGlzCgkgKiBwb3NzaWJseSBhIHZhbGlkIFNIQTEuCgkgKi8KCWFyZ2MgPSBwYXJzZV9vcHRpb25zKGFyZ2MsIGFyZ3YsIHByZWZpeCwgYnVpbHRpbl9mb3JtYXRfcGF0Y2hfb3B0aW9ucywKCQkJICAgICBidWlsdGluX2Zvcm1hdF9wYXRjaF91c2FnZSwKCQkJICAgICBQQVJTRV9PUFRfS0VFUF9BUkdWMCB8IFBBUlNFX09QVF9LRUVQX1VOS05PV04gfAoJCQkgICAgIFBBUlNFX09QVF9LRUVQX0RBU0hEQVNIKTsKCglpZiAoMCA8IHJlcm9sbF9jb3VudCkgewoJCXN0cnVjdCBzdHJidWYgc3ByZWZpeCA9IFNUUkJVRl9JTklUOwoJCXN0cmJ1Zl9hZGRmKCZzcHJlZml4LCAiJXMgdiVkIiwKCQkJICAgIHJldi5zdWJqZWN0X3ByZWZpeCwgcmVyb2xsX2NvdW50KTsKCQlyZXYucmVyb2xsX2NvdW50ID0gcmVyb2xsX2NvdW50OwoJCXJldi5zdWJqZWN0X3ByZWZpeCA9IHN0cmJ1Zl9kZXRhY2goJnNwcmVmaXgsIE5VTEwpOwoJfQoKCWZvciAoaSA9IDA7IGkgPCBleHRyYV9oZHIubnI7IGkrKykgewoJCXN0cmJ1Zl9hZGRzdHIoJmJ1ZiwgZXh0cmFfaGRyLml0ZW1zW2ldLnN0cmluZyk7CgkJc3RyYnVmX2FkZGNoKCZidWYsICdcbicpOwoJfQoKCWlmIChleHRyYV90by5ucikKCQlzdHJidWZfYWRkc3RyKCZidWYsICJUbzogIik7Cglmb3IgKGkgPSAwOyBpIDwgZXh0cmFfdG8ubnI7IGkrKykgewoJCWlmIChpKQoJCQlzdHJidWZfYWRkc3RyKCZidWYsICIgICAgIik7CgkJc3RyYnVmX2FkZHN0cigmYnVmLCBleHRyYV90by5pdGVtc1tpXS5zdHJpbmcpOwoJCWlmIChpICsgMSA8IGV4dHJhX3RvLm5yKQoJCQlzdHJidWZfYWRkY2goJmJ1ZiwgJywnKTsKCQlzdHJidWZfYWRkY2goJmJ1ZiwgJ1xuJyk7Cgl9CgoJaWYgKGV4dHJhX2NjLm5yKQoJCXN0cmJ1Zl9hZGRzdHIoJmJ1ZiwgIkNjOiAiKTsKCWZvciAoaSA9IDA7IGkgPCBleHRyYV9jYy5ucjsgaSsrKSB7CgkJaWYgKGkpCgkJCXN0cmJ1Zl9hZGRzdHIoJmJ1ZiwgIiAgICAiKTsKCQlzdHJidWZfYWRkc3RyKCZidWYsIGV4dHJhX2NjLml0ZW1zW2ldLnN0cmluZyk7CgkJaWYgKGkgKyAxIDwgZXh0cmFfY2MubnIpCgkJCXN0cmJ1Zl9hZGRjaCgmYnVmLCAnLCcpOwoJCXN0cmJ1Zl9hZGRjaCgmYnVmLCAnXG4nKTsKCX0KCglyZXYuZXh0cmFfaGVhZGVycyA9IHN0cmJ1Zl9kZXRhY2goJmJ1ZiwgTlVMTCk7CgoJaWYgKGZyb20pIHsKCQlpZiAoc3BsaXRfaWRlbnRfbGluZSgmcmV2LmZyb21faWRlbnQsIGZyb20sIHN0cmxlbihmcm9tKSkpCgkJCWRpZShfKCJpbnZhbGlkIGlkZW50IGxpbmU6ICVzIiksIGZyb20pOwoJfQoKCWlmIChzdGFydF9udW1iZXIgPCAwKQoJCXN0YXJ0X251bWJlciA9IDE7CgoJLyoKCSAqIElmIG51bWJlcmVkIGlzIHNldCBzb2xlbHkgZHVlIHRvIGZvcm1hdC5udW1iZXJlZCBpbiBjb25maWcsCgkgKiBhbmQgaXQgd291bGQgY29uZmxpY3Qgd2l0aCAtLWtlZXAtc3ViamVjdCAoLWspIGZyb20gdGhlCgkgKiBjb21tYW5kIGxpbmUsIHJlc2V0ICJudW1iZXJlZCIuCgkgKi8KCWlmIChudW1iZXJlZCAmJiBrZWVwX3N1YmplY3QgJiYgIW51bWJlcmVkX2NtZGxpbmVfb3B0KQoJCW51bWJlcmVkID0gMDsKCglpZiAobnVtYmVyZWQgJiYga2VlcF9zdWJqZWN0KQoJCWRpZSAoXygiLW4gYW5kIC1rIGFyZSBtdXR1YWxseSBleGNsdXNpdmUuIikpOwoJaWYgKGtlZXBfc3ViamVjdCAmJiBzdWJqZWN0X3ByZWZpeCkKCQlkaWUgKF8oIi0tc3ViamVjdC1wcmVmaXggYW5kIC1rIGFyZSBtdXR1YWxseSBleGNsdXNpdmUuIikpOwoJcmV2LnByZXNlcnZlX3N1YmplY3QgPSBrZWVwX3N1YmplY3Q7CgoJYXJnYyA9IHNldHVwX3JldmlzaW9ucyhhcmdjLCBhcmd2LCAmcmV2LCAmc19yX29wdCk7CglpZiAoYXJnYyA+IDEpCgkJZGllIChfKCJ1bnJlY29nbml6ZWQgYXJndW1lbnQ6ICVzIiksIGFyZ3ZbMV0pOwoKCWlmIChyZXYuZGlmZm9wdC5vdXRwdXRfZm9ybWF0ICYgRElGRl9GT1JNQVRfTkFNRSkKCQlkaWUoXygiLS1uYW1lLW9ubHkgZG9lcyBub3QgbWFrZSBzZW5zZSIpKTsKCWlmIChyZXYuZGlmZm9wdC5vdXRwdXRfZm9ybWF0ICYgRElGRl9GT1JNQVRfTkFNRV9TVEFUVVMpCgkJZGllKF8oIi0tbmFtZS1zdGF0dXMgZG9lcyBub3QgbWFrZSBzZW5zZSIpKTsKCWlmIChyZXYuZGlmZm9wdC5vdXRwdXRfZm9ybWF0ICYgRElGRl9GT1JNQVRfQ0hFQ0tESUZGKQoJCWRpZShfKCItLWNoZWNrIGRvZXMgbm90IG1ha2Ugc2Vuc2UiKSk7CgoJaWYgKCF1c2VfcGF0Y2hfZm9ybWF0ICYmCgkJKCFyZXYuZGlmZm9wdC5vdXRwdXRfZm9ybWF0IHx8CgkJIHJldi5kaWZmb3B0Lm91dHB1dF9mb3JtYXQgPT0gRElGRl9GT1JNQVRfUEFUQ0gpKQoJCXJldi5kaWZmb3B0Lm91dHB1dF9mb3JtYXQgPSBESUZGX0ZPUk1BVF9ESUZGU1RBVCB8IERJRkZfRk9STUFUX1NVTU1BUlk7CgoJLyogQWx3YXlzIGdlbmVyYXRlIGEgcGF0Y2ggKi8KCXJldi5kaWZmb3B0Lm91dHB1dF9mb3JtYXQgfD0gRElGRl9GT1JNQVRfUEFUQ0g7CgoJaWYgKCFESUZGX09QVF9UU1QoJnJldi5kaWZmb3B0LCBURVhUKSAmJiAhbm9fYmluYXJ5X2RpZmYpCgkJRElGRl9PUFRfU0VUKCZyZXYuZGlmZm9wdCwgQklOQVJZKTsKCglpZiAocmV2LnNob3dfbm90ZXMpCgkJaW5pdF9kaXNwbGF5X25vdGVzKCZyZXYubm90ZXNfb3B0KTsKCglpZiAoIXVzZV9zdGRvdXQpCgkJb3V0cHV0X2RpcmVjdG9yeSA9IHNldF9vdXRkaXIocHJlZml4LCBvdXRwdXRfZGlyZWN0b3J5KTsKCWVsc2UKCQlzZXR1cF9wYWdlcigpOwoKCWlmIChvdXRwdXRfZGlyZWN0b3J5KSB7CgkJaWYgKHVzZV9zdGRvdXQpCgkJCWRpZShfKCJzdGFuZGFyZCBvdXRwdXQsIG9yIGRpcmVjdG9yeSwgd2hpY2ggb25lPyIpKTsKCQlpZiAobWtkaXIob3V0cHV0X2RpcmVjdG9yeSwgMDc3NykgPCAwICYmIGVycm5vICE9IEVFWElTVCkKCQkJZGllX2Vycm5vKF8oIkNvdWxkIG5vdCBjcmVhdGUgZGlyZWN0b3J5ICclcyciKSwKCQkJCSAgb3V0cHV0X2RpcmVjdG9yeSk7Cgl9CgoJaWYgKHJldi5wZW5kaW5nLm5yID09IDEpIHsKCQlpbnQgY2hlY2tfaGVhZCA9IDA7CgoJCWlmIChyZXYubWF4X2NvdW50IDwgMCAmJiAhcmV2LnNob3dfcm9vdF9kaWZmKSB7CgkJCS8qCgkJCSAqIFRoaXMgaXMgdHJhZGl0aW9uYWwgYmVoYXZpb3VyIG9mICJnaXQgZm9ybWF0LXBhdGNoCgkJCSAqIG9yaWdpbiIgdGhhdCBwcmVwYXJlcyB3aGF0IHRoZSBvcmlnaW4gc2lkZSBzdGlsbAoJCQkgKiBkb2VzIG5vdCBoYXZlLgoJCQkgKi8KCQkJcmV2LnBlbmRpbmcub2JqZWN0c1swXS5pdGVtLT5mbGFncyB8PSBVTklOVEVSRVNUSU5HOwoJCQlhZGRfaGVhZF90b19wZW5kaW5nKCZyZXYpOwoJCQljaGVja19oZWFkID0gMTsKCQl9CgkJLyoKCQkgKiBPdGhlcndpc2UsIGl0IGlzICJmb3JtYXQtcGF0Y2ggLTIyIEhFQUQiLCBhbmQvb3IKCQkgKiAiZm9ybWF0LXBhdGNoIC0tcm9vdCBIRUFEIi4gIFRoZSB1c2VyIHdhbnRzCgkJICogZ2V0X3JldmlzaW9uKCkgdG8gZG8gdGhlIHVzdWFsIHRyYXZlcnNhbC4KCQkgKi8KCgkJaWYgKCFzdHJjbXAocmV2LnBlbmRpbmcub2JqZWN0c1swXS5uYW1lLCAiSEVBRCIpKQoJCQljaGVja19oZWFkID0gMTsKCgkJaWYgKGNoZWNrX2hlYWQpIHsKCQkJdW5zaWduZWQgY2hhciBzaGExWzIwXTsKCQkJY29uc3QgY2hhciAqcmVmOwoJCQlyZWYgPSByZXNvbHZlX3JlZl91bnNhZmUoIkhFQUQiLCBzaGExLCAxLCBOVUxMKTsKCQkJaWYgKHJlZiAmJiAhcHJlZml4Y21wKHJlZiwgInJlZnMvaGVhZHMvIikpCgkJCQlicmFuY2hfbmFtZSA9IHhzdHJkdXAocmVmICsgc3RybGVuKCJyZWZzL2hlYWRzLyIpKTsKCQkJZWxzZQoJCQkJYnJhbmNoX25hbWUgPSB4c3RyZHVwKCIiKTsgLyogbm8gYnJhbmNoICovCgkJfQoJfQoKCS8qCgkgKiBXZSBjYW5ub3QgbW92ZSB0aGlzIGFueXdoZXJlIGVhcmxpZXIgYmVjYXVzZSB3ZSBkbyB3YW50IHRvCgkgKiBrbm93IGlmIC0tcm9vdCB3YXMgZ2l2ZW4gZXhwbGljaXRseSBmcm9tIHRoZSBjb21tYW5kIGxpbmUuCgkgKi8KCXJldi5zaG93X3Jvb3RfZGlmZiA9IDE7CgoJaWYgKGlnbm9yZV9pZl9pbl91cHN0cmVhbSkgewoJCS8qIERvbid0IHNheSBhbnl0aGluZyBpZiBoZWFkIGFuZCB1cHN0cmVhbSBhcmUgdGhlIHNhbWUuICovCgkJaWYgKHJldi5wZW5kaW5nLm5yID09IDIpIHsKCQkJc3RydWN0IG9iamVjdF9hcnJheV9lbnRyeSAqbyA9IHJldi5wZW5kaW5nLm9iamVjdHM7CgkJCWlmIChoYXNoY21wKG9bMF0uaXRlbS0+c2hhMSwgb1sxXS5pdGVtLT5zaGExKSA9PSAwKQoJCQkJcmV0dXJuIDA7CgkJfQoJCWdldF9wYXRjaF9pZHMoJnJldiwgJmlkcyk7Cgl9CgoJaWYgKCF1c2Vfc3Rkb3V0KQoJCXJlYWxzdGRvdXQgPSB4ZmRvcGVuKHhkdXAoMSksICJ3Iik7CgoJaWYgKHByZXBhcmVfcmV2aXNpb25fd2FsaygmcmV2KSkKCQlkaWUoXygicmV2aXNpb24gd2FsayBzZXR1cCBmYWlsZWQiKSk7CglyZXYuYm91bmRhcnkgPSAxOwoJd2hpbGUgKChjb21taXQgPSBnZXRfcmV2aXNpb24oJnJldikpICE9IE5VTEwpIHsKCQlpZiAoY29tbWl0LT5vYmplY3QuZmxhZ3MgJiBCT1VOREFSWSkgewoJCQlib3VuZGFyeV9jb3VudCsrOwoJCQlvcmlnaW4gPSAoYm91bmRhcnlfY291bnQgPT0gMSkgPyBjb21taXQgOiBOVUxMOwoJCQljb250aW51ZTsKCQl9CgoJCWlmIChpZ25vcmVfaWZfaW5fdXBzdHJlYW0gJiYKCQkJCWhhc19jb21taXRfcGF0Y2hfaWQoY29tbWl0LCAmaWRzKSkKCQkJY29udGludWU7CgoJCW5yKys7CgkJbGlzdCA9IHhyZWFsbG9jKGxpc3QsIG5yICogc2l6ZW9mKGxpc3RbMF0pKTsKCQlsaXN0W25yIC0gMV0gPSBjb21taXQ7Cgl9CglpZiAobnIgPT0gMCkKCQkvKiBub3RoaW5nIHRvIGRvICovCgkJcmV0dXJuIDA7Cgl0b3RhbCA9IG5yOwoJaWYgKCFrZWVwX3N1YmplY3QgJiYgYXV0b19udW1iZXIgJiYgdG90YWwgPiAxKQoJCW51bWJlcmVkID0gMTsKCWlmIChudW1iZXJlZCkKCQlyZXYudG90YWwgPSB0b3RhbCArIHN0YXJ0X251bWJlciAtIDE7CglpZiAoY292ZXJfbGV0dGVyID09IC0xKSB7CgkJaWYgKGNvbmZpZ19jb3Zlcl9sZXR0ZXIgPT0gQ09WRVJfQVVUTykKCQkJY292ZXJfbGV0dGVyID0gKHRvdGFsID4gMSk7CgkJZWxzZQoJCQljb3Zlcl9sZXR0ZXIgPSAoY29uZmlnX2NvdmVyX2xldHRlciA9PSBDT1ZFUl9PTik7Cgl9CgoJaWYgKGluX3JlcGx5X3RvIHx8IHRocmVhZCB8fCBjb3Zlcl9sZXR0ZXIpCgkJcmV2LnJlZl9tZXNzYWdlX2lkcyA9IHhjYWxsb2MoMSwgc2l6ZW9mKHN0cnVjdCBzdHJpbmdfbGlzdCkpOwoJaWYgKGluX3JlcGx5X3RvKSB7CgkJY29uc3QgY2hhciAqbXNnaWQgPSBjbGVhbl9tZXNzYWdlX2lkKGluX3JlcGx5X3RvKTsKCQlzdHJpbmdfbGlzdF9hcHBlbmQocmV2LnJlZl9tZXNzYWdlX2lkcywgbXNnaWQpOwoJfQoJcmV2Lm51bWJlcmVkX2ZpbGVzID0ganVzdF9udW1iZXJzOwoJcmV2LnBhdGNoX3N1ZmZpeCA9IGZtdF9wYXRjaF9zdWZmaXg7CglpZiAoY292ZXJfbGV0dGVyKSB7CgkJaWYgKHRocmVhZCkKCQkJZ2VuX21lc3NhZ2VfaWQoJnJldiwgImNvdmVyIik7CgkJbWFrZV9jb3Zlcl9sZXR0ZXIoJnJldiwgdXNlX3N0ZG91dCwKCQkJCSAgb3JpZ2luLCBuciwgbGlzdCwgYnJhbmNoX25hbWUsIHF1aWV0KTsKCQl0b3RhbCsrOwoJCXN0YXJ0X251bWJlci0tOwoJfQoJcmV2LmFkZF9zaWdub2ZmID0gZG9fc2lnbm9mZjsKCXdoaWxlICgwIDw9IC0tbnIpIHsKCQlpbnQgc2hvd247CgkJY29tbWl0ID0gbGlzdFtucl07CgkJcmV2Lm5yID0gdG90YWwgLSBuciArIChzdGFydF9udW1iZXIgLSAxKTsKCQkvKiBNYWtlIHRoZSBzZWNvbmQgYW5kIHN1YnNlcXVlbnQgbWFpbHMgcmVwbGllcyB0byB0aGUgZmlyc3QgKi8KCQlpZiAodGhyZWFkKSB7CgkJCS8qIEhhdmUgd2UgYWxyZWFkeSBoYWQgYSBtZXNzYWdlIElEPyAqLwoJCQlpZiAocmV2Lm1lc3NhZ2VfaWQpIHsKCQkJCS8qCgkJCQkgKiBGb3IgZGVlcCB0aHJlYWRpbmc6IG1ha2UgZXZlcnkgbWFpbAoJCQkJICogYSByZXBseSB0byB0aGUgcHJldmlvdXMgb25lLCBubwoJCQkJICogbWF0dGVyIHdoYXQgb3RoZXIgb3B0aW9ucyBhcmUgc2V0LgoJCQkJICoKCQkJCSAqIEZvciBzaGFsbG93IHRocmVhZGluZzoKCQkJCSAqCgkJCQkgKiBXaXRob3V0IC0tY292ZXItbGV0dGVyIGFuZAoJCQkJICogLS1pbi1yZXBseS10bywgbWFrZSBldmVyeSBtYWlsIGEKCQkJCSAqIHJlcGx5IHRvIHRoZSBvbmUgYmVmb3JlLgoJCQkJICoKCQkJCSAqIFdpdGggLS1pbi1yZXBseS10byBidXQgbm8KCQkJCSAqIC0tY292ZXItbGV0dGVyLCBtYWtlIGV2ZXJ5IG1haWwgYQoJCQkJICogcmVwbHkgdG8gdGhlIDxyZXBseS10bz4uCgkJCQkgKgoJCQkJICogV2l0aCAtLWNvdmVyLWxldHRlciwgbWFrZSBldmVyeQoJCQkJICogbWFpbCBidXQgdGhlIGNvdmVyIGxldHRlciBhIHJlcGx5CgkJCQkgKiB0byB0aGUgY292ZXIgbGV0dGVyLiAgVGhlIGNvdmVyCgkJCQkgKiBsZXR0ZXIgaXMgYSByZXBseSB0byB0aGUKCQkJCSAqIC0taW4tcmVwbHktdG8sIGlmIHNwZWNpZmllZC4KCQkJCSAqLwoJCQkJaWYgKHRocmVhZCA9PSBUSFJFQURfU0hBTExPVwoJCQkJICAgICYmIHJldi5yZWZfbWVzc2FnZV9pZHMtPm5yID4gMAoJCQkJICAgICYmICghY292ZXJfbGV0dGVyIHx8IHJldi5uciA+IDEpKQoJCQkJCWZyZWUocmV2Lm1lc3NhZ2VfaWQpOwoJCQkJZWxzZQoJCQkJCXN0cmluZ19saXN0X2FwcGVuZChyZXYucmVmX21lc3NhZ2VfaWRzLAoJCQkJCQkJICAgcmV2Lm1lc3NhZ2VfaWQpOwoJCQl9CgkJCWdlbl9tZXNzYWdlX2lkKCZyZXYsIHNoYTFfdG9faGV4KGNvbW1pdC0+b2JqZWN0LnNoYTEpKTsKCQl9CgoJCWlmICghdXNlX3N0ZG91dCAmJgoJCSAgICByZW9wZW5fc3Rkb3V0KHJldi5udW1iZXJlZF9maWxlcyA/IE5VTEwgOiBjb21taXQsIE5VTEwsICZyZXYsIHF1aWV0KSkKCQkJZGllKF8oIkZhaWxlZCB0byBjcmVhdGUgb3V0cHV0IGZpbGVzIikpOwoJCXNob3duID0gbG9nX3RyZWVfY29tbWl0KCZyZXYsIGNvbW1pdCk7CgkJZnJlZShjb21taXQtPmJ1ZmZlcik7CgkJY29tbWl0LT5idWZmZXIgPSBOVUxMOwoKCQkvKiBXZSBwdXQgb25lIGV4dHJhIGJsYW5rIGxpbmUgYmV0d2VlbiBmb3JtYXR0ZWQKCQkgKiBwYXRjaGVzIGFuZCB0aGlzIGZsYWcgaXMgdXNlZCBieSBsb2ctdHJlZSBjb2RlCgkJICogdG8gc2VlIGlmIGl0IG5lZWRzIHRvIGVtaXQgYSBMRiBiZWZvcmUgc2hvd2luZwoJCSAqIHRoZSBsb2c7IHdoZW4gdXNpbmcgb25lIGZpbGUgcGVyIHBhdGNoLCB3ZSBkbwoJCSAqIG5vdCB3YW50IHRoZSBleHRyYSBibGFuayBsaW5lLgoJCSAqLwoJCWlmICghdXNlX3N0ZG91dCkKCQkJcmV2LnNob3duX29uZSA9IDA7CgkJaWYgKHNob3duKSB7CgkJCWlmIChyZXYubWltZV9ib3VuZGFyeSkKCQkJCXByaW50ZigiXG4tLSVzJXMtLVxuXG5cbiIsCgkJCQkgICAgICAgbWltZV9ib3VuZGFyeV9sZWFkZXIsCgkJCQkgICAgICAgcmV2Lm1pbWVfYm91bmRhcnkpOwoJCQllbHNlCgkJCQlwcmludF9zaWduYXR1cmUoKTsKCQl9CgkJaWYgKCF1c2Vfc3Rkb3V0KQoJCQlmY2xvc2Uoc3Rkb3V0KTsKCX0KCWZyZWUobGlzdCk7CglmcmVlKGJyYW5jaF9uYW1lKTsKCXN0cmluZ19saXN0X2NsZWFyKCZleHRyYV90bywgMCk7CglzdHJpbmdfbGlzdF9jbGVhcigmZXh0cmFfY2MsIDApOwoJc3RyaW5nX2xpc3RfY2xlYXIoJmV4dHJhX2hkciwgMCk7CglpZiAoaWdub3JlX2lmX2luX3Vwc3RyZWFtKQoJCWZyZWVfcGF0Y2hfaWRzKCZpZHMpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgYWRkX3BlbmRpbmdfY29tbWl0KGNvbnN0IGNoYXIgKmFyZywgc3RydWN0IHJldl9pbmZvICpyZXZzLCBpbnQgZmxhZ3MpCnsKCXVuc2lnbmVkIGNoYXIgc2hhMVsyMF07CglpZiAoZ2V0X3NoYTEoYXJnLCBzaGExKSA9PSAwKSB7CgkJc3RydWN0IGNvbW1pdCAqY29tbWl0ID0gbG9va3VwX2NvbW1pdF9yZWZlcmVuY2Uoc2hhMSk7CgkJaWYgKGNvbW1pdCkgewoJCQljb21taXQtPm9iamVjdC5mbGFncyB8PSBmbGFnczsKCQkJYWRkX3BlbmRpbmdfb2JqZWN0KHJldnMsICZjb21taXQtPm9iamVjdCwgYXJnKTsKCQkJcmV0dXJuIDA7CgkJfQoJfQoJcmV0dXJuIC0xOwp9CgpzdGF0aWMgY29uc3QgY2hhciAqIGNvbnN0IGNoZXJyeV91c2FnZVtdID0gewoJTl8oImdpdCBjaGVycnkgWy12XSBbPHVwc3RyZWFtPiBbPGhlYWQ+IFs8bGltaXQ+XV1dIiksCglOVUxMCn07CgpzdGF0aWMgdm9pZCBwcmludF9jb21taXQoY2hhciBzaWduLCBzdHJ1Y3QgY29tbWl0ICpjb21taXQsIGludCB2ZXJib3NlLAoJCQkgaW50IGFiYnJldikKewoJaWYgKCF2ZXJib3NlKSB7CgkJcHJpbnRmKCIlYyAlc1xuIiwgc2lnbiwKCQkgICAgICAgZmluZF91bmlxdWVfYWJicmV2KGNvbW1pdC0+b2JqZWN0LnNoYTEsIGFiYnJldikpOwoJfSBlbHNlIHsKCQlzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoJCXBwX2NvbW1pdF9lYXN5KENNSVRfRk1UX09ORUxJTkUsIGNvbW1pdCwgJmJ1Zik7CgkJcHJpbnRmKCIlYyAlcyAlc1xuIiwgc2lnbiwKCQkgICAgICAgZmluZF91bmlxdWVfYWJicmV2KGNvbW1pdC0+b2JqZWN0LnNoYTEsIGFiYnJldiksCgkJICAgICAgIGJ1Zi5idWYpOwoJCXN0cmJ1Zl9yZWxlYXNlKCZidWYpOwoJfQp9CgppbnQgY21kX2NoZXJyeShpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsIGNvbnN0IGNoYXIgKnByZWZpeCkKewoJc3RydWN0IHJldl9pbmZvIHJldnM7CglzdHJ1Y3QgcGF0Y2hfaWRzIGlkczsKCXN0cnVjdCBjb21taXQgKmNvbW1pdDsKCXN0cnVjdCBjb21taXRfbGlzdCAqbGlzdCA9IE5VTEw7CglzdHJ1Y3QgYnJhbmNoICpjdXJyZW50X2JyYW5jaDsKCWNvbnN0IGNoYXIgKnVwc3RyZWFtOwoJY29uc3QgY2hhciAqaGVhZCA9ICJIRUFEIjsKCWNvbnN0IGNoYXIgKmxpbWl0ID0gTlVMTDsKCWludCB2ZXJib3NlID0gMCwgYWJicmV2ID0gMDsKCglzdHJ1Y3Qgb3B0aW9uIG9wdGlvbnNbXSA9IHsKCQlPUFRfX0FCQlJFVigmYWJicmV2KSwKCQlPUFRfX1ZFUkJPU0UoJnZlcmJvc2UsIE5fKCJiZSB2ZXJib3NlIikpLAoJCU9QVF9FTkQoKQoJfTsKCglhcmdjID0gcGFyc2Vfb3B0aW9ucyhhcmdjLCBhcmd2LCBwcmVmaXgsIG9wdGlvbnMsIGNoZXJyeV91c2FnZSwgMCk7CgoJc3dpdGNoIChhcmdjKSB7CgljYXNlIDM6CgkJbGltaXQgPSBhcmd2WzJdOwoJCS8qIEZBTExUSFJPVUdIICovCgljYXNlIDI6CgkJaGVhZCA9IGFyZ3ZbMV07CgkJLyogRkFMTFRIUk9VR0ggKi8KCWNhc2UgMToKCQl1cHN0cmVhbSA9IGFyZ3ZbMF07CgkJYnJlYWs7CglkZWZhdWx0OgoJCWN1cnJlbnRfYnJhbmNoID0gYnJhbmNoX2dldChOVUxMKTsKCQlpZiAoIWN1cnJlbnRfYnJhbmNoIHx8ICFjdXJyZW50X2JyYW5jaC0+bWVyZ2UKCQkJCQl8fCAhY3VycmVudF9icmFuY2gtPm1lcmdlWzBdCgkJCQkJfHwgIWN1cnJlbnRfYnJhbmNoLT5tZXJnZVswXS0+ZHN0KSB7CgkJCWZwcmludGYoc3RkZXJyLCBfKCJDb3VsZCBub3QgZmluZCBhIHRyYWNrZWQiCgkJCQkJIiByZW1vdGUgYnJhbmNoLCBwbGVhc2UiCgkJCQkJIiBzcGVjaWZ5IDx1cHN0cmVhbT4gbWFudWFsbHkuXG4iKSk7CgkJCXVzYWdlX3dpdGhfb3B0aW9ucyhjaGVycnlfdXNhZ2UsIG9wdGlvbnMpOwoJCX0KCgkJdXBzdHJlYW0gPSBjdXJyZW50X2JyYW5jaC0+bWVyZ2VbMF0tPmRzdDsKCX0KCglpbml0X3JldmlzaW9ucygmcmV2cywgcHJlZml4KTsKCXJldnMubWF4X3BhcmVudHMgPSAxOwoKCWlmIChhZGRfcGVuZGluZ19jb21taXQoaGVhZCwgJnJldnMsIDApKQoJCWRpZShfKCJVbmtub3duIGNvbW1pdCAlcyIpLCBoZWFkKTsKCWlmIChhZGRfcGVuZGluZ19jb21taXQodXBzdHJlYW0sICZyZXZzLCBVTklOVEVSRVNUSU5HKSkKCQlkaWUoXygiVW5rbm93biBjb21taXQgJXMiKSwgdXBzdHJlYW0pOwoKCS8qIERvbid0IHNheSBhbnl0aGluZyBpZiBoZWFkIGFuZCB1cHN0cmVhbSBhcmUgdGhlIHNhbWUuICovCglpZiAocmV2cy5wZW5kaW5nLm5yID09IDIpIHsKCQlzdHJ1Y3Qgb2JqZWN0X2FycmF5X2VudHJ5ICpvID0gcmV2cy5wZW5kaW5nLm9iamVjdHM7CgkJaWYgKGhhc2hjbXAob1swXS5pdGVtLT5zaGExLCBvWzFdLml0ZW0tPnNoYTEpID09IDApCgkJCXJldHVybiAwOwoJfQoKCWdldF9wYXRjaF9pZHMoJnJldnMsICZpZHMpOwoKCWlmIChsaW1pdCAmJiBhZGRfcGVuZGluZ19jb21taXQobGltaXQsICZyZXZzLCBVTklOVEVSRVNUSU5HKSkKCQlkaWUoXygiVW5rbm93biBjb21taXQgJXMiKSwgbGltaXQpOwoKCS8qIHJldmVyc2UgdGhlIGxpc3Qgb2YgY29tbWl0cyAqLwoJaWYgKHByZXBhcmVfcmV2aXNpb25fd2FsaygmcmV2cykpCgkJZGllKF8oInJldmlzaW9uIHdhbGsgc2V0dXAgZmFpbGVkIikpOwoJd2hpbGUgKChjb21taXQgPSBnZXRfcmV2aXNpb24oJnJldnMpKSAhPSBOVUxMKSB7CgkJY29tbWl0X2xpc3RfaW5zZXJ0KGNvbW1pdCwgJmxpc3QpOwoJfQoKCXdoaWxlIChsaXN0KSB7CgkJY2hhciBzaWduID0gJysnOwoKCQljb21taXQgPSBsaXN0LT5pdGVtOwoJCWlmIChoYXNfY29tbWl0X3BhdGNoX2lkKGNvbW1pdCwgJmlkcykpCgkJCXNpZ24gPSAnLSc7CgkJcHJpbnRfY29tbWl0KHNpZ24sIGNvbW1pdCwgdmVyYm9zZSwgYWJicmV2KTsKCQlsaXN0ID0gbGlzdC0+bmV4dDsKCX0KCglmcmVlX3BhdGNoX2lkcygmaWRzKTsKCXJldHVybiAwOwp9Cg==",
    "text": "/*\n * Builtin \"git log\" and related commands (show, whatchanged)\n *\n * (C) Copyright 2006 Linus Torvalds\n *\t\t 2006 Junio Hamano\n */\n#include \"cache.h\"\n#include \"color.h\"\n#include \"commit.h\"\n#include \"diff.h\"\n#include \"revision.h\"\n#include \"log-tree.h\"\n#include \"builtin.h\"\n#include \"tag.h\"\n#include \"reflog-walk.h\"\n#include \"patch-ids.h\"\n#include \"run-command.h\"\n#include \"shortlog.h\"\n#include \"remote.h\"\n#include \"string-list.h\"\n#include \"parse-options.h\"\n#include \"line-log.h\"\n#include \"branch.h\"\n#include \"streaming.h\"\n#include \"version.h\"\n#include \"mailmap.h\"\n#include \"gpg-interface.h\"\n\n/* Set a default date-time format for git log (\"log.date\" config variable) */\nstatic const char *default_date_mode = NULL;\n\nstatic int default_abbrev_commit;\nstatic int default_show_root = 1;\nstatic int decoration_style;\nstatic int decoration_given;\nstatic int use_mailmap_config;\nstatic const char *fmt_patch_subject_prefix = \"PATCH\";\nstatic const char *fmt_pretty;\n\nstatic const char * const builtin_log_usage[] = {\n\tN_(\"git log [<options>] [<revision range>] [[--] <path>...]\\n\")\n\tN_(\"   or: git show [options] <object>...\"),\n\tNULL\n};\n\nstruct line_opt_callback_data {\n\tstruct rev_info *rev;\n\tconst char *prefix;\n\tstruct string_list args;\n};\n\nstatic int parse_decoration_style(const char *var, const char *value)\n{\n\tswitch (git_config_maybe_bool(var, value)) {\n\tcase 1:\n\t\treturn DECORATE_SHORT_REFS;\n\tcase 0:\n\t\treturn 0;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (!strcmp(value, \"full\"))\n\t\treturn DECORATE_FULL_REFS;\n\telse if (!strcmp(value, \"short\"))\n\t\treturn DECORATE_SHORT_REFS;\n\treturn -1;\n}\n\nstatic int decorate_callback(const struct option *opt, const char *arg, int unset)\n{\n\tif (unset)\n\t\tdecoration_style = 0;\n\telse if (arg)\n\t\tdecoration_style = parse_decoration_style(\"command line\", arg);\n\telse\n\t\tdecoration_style = DECORATE_SHORT_REFS;\n\n\tif (decoration_style < 0)\n\t\tdie(\"invalid --decorate option: %s\", arg);\n\n\tdecoration_given = 1;\n\n\treturn 0;\n}\n\nstatic int log_line_range_callback(const struct option *option, const char *arg, int unset)\n{\n\tstruct line_opt_callback_data *data = option->value;\n\n\tif (!arg)\n\t\treturn -1;\n\n\tdata->rev->line_level_traverse = 1;\n\tstring_list_append(&data->args, arg);\n\n\treturn 0;\n}\n\nstatic void cmd_log_init_defaults(struct rev_info *rev)\n{\n\tif (fmt_pretty)\n\t\tget_commit_format(fmt_pretty, rev);\n\trev->verbose_header = 1;\n\tDIFF_OPT_SET(&rev->diffopt, RECURSIVE);\n\trev->diffopt.stat_width = -1; /* use full terminal width */\n\trev->diffopt.stat_graph_width = -1; /* respect statGraphWidth config */\n\trev->abbrev_commit = default_abbrev_commit;\n\trev->show_root_diff = default_show_root;\n\trev->subject_prefix = fmt_patch_subject_prefix;\n\tDIFF_OPT_SET(&rev->diffopt, ALLOW_TEXTCONV);\n\n\tif (default_date_mode)\n\t\trev->date_mode = parse_date_format(default_date_mode);\n\trev->diffopt.touched_flags = 0;\n}\n\nstatic void cmd_log_init_finish(int argc, const char **argv, const char *prefix,\n\t\t\t struct rev_info *rev, struct setup_revision_opt *opt)\n{\n\tstruct userformat_want w;\n\tint quiet = 0, source = 0, mailmap = 0;\n\tstatic struct line_opt_callback_data line_cb = {NULL, NULL, STRING_LIST_INIT_DUP};\n\n\tconst struct option builtin_log_options[] = {\n\t\tOPT__QUIET(&quiet, N_(\"suppress diff output\")),\n\t\tOPT_BOOL(0, \"source\", &source, N_(\"show source\")),\n\t\tOPT_BOOL(0, \"use-mailmap\", &mailmap, N_(\"Use mail map file\")),\n\t\t{ OPTION_CALLBACK, 0, \"decorate\", NULL, NULL, N_(\"decorate options\"),\n\t\t  PARSE_OPT_OPTARG, decorate_callback},\n\t\tOPT_CALLBACK('L', NULL, &line_cb, \"n,m:file\",\n\t\t\t     \"Process line range n,m in file, counting from 1\",\n\t\t\t     log_line_range_callback),\n\t\tOPT_END()\n\t};\n\n\tline_cb.rev = rev;\n\tline_cb.prefix = prefix;\n\n\tmailmap = use_mailmap_config;\n\targc = parse_options(argc, argv, prefix,\n\t\t\t     builtin_log_options, builtin_log_usage,\n\t\t\t     PARSE_OPT_KEEP_ARGV0 | PARSE_OPT_KEEP_UNKNOWN |\n\t\t\t     PARSE_OPT_KEEP_DASHDASH);\n\n\tif (quiet)\n\t\trev->diffopt.output_format |= DIFF_FORMAT_NO_OUTPUT;\n\targc = setup_revisions(argc, argv, rev, opt);\n\n\t/* Any arguments at this point are not recognized */\n\tif (argc > 1)\n\t\tdie(\"unrecognized argument: %s\", argv[1]);\n\n\tmemset(&w, 0, sizeof(w));\n\tuserformat_find_requirements(NULL, &w);\n\n\tif (!rev->show_notes_given && (!rev->pretty_given || w.notes))\n\t\trev->show_notes = 1;\n\tif (rev->show_notes)\n\t\tinit_display_notes(&rev->notes_opt);\n\n\tif (rev->diffopt.pickaxe || rev->diffopt.filter ||\n\t    DIFF_OPT_TST(&rev->diffopt, FOLLOW_RENAMES))\n\t\trev->always_show_header = 0;\n\n\tif (source)\n\t\trev->show_source = 1;\n\n\tif (mailmap) {\n\t\trev->mailmap = xcalloc(1, sizeof(struct string_list));\n\t\tread_mailmap(rev->mailmap, NULL);\n\t}\n\n\tif (rev->pretty_given && rev->commit_format == CMIT_FMT_RAW) {\n\t\t/*\n\t\t * \"log --pretty=raw\" is special; ignore UI oriented\n\t\t * configuration variables such as decoration.\n\t\t */\n\t\tif (!decoration_given)\n\t\t\tdecoration_style = 0;\n\t\tif (!rev->abbrev_commit_given)\n\t\t\trev->abbrev_commit = 0;\n\t}\n\n\tif (decoration_style) {\n\t\trev->show_decorations = 1;\n\t\tload_ref_decorations(decoration_style);\n\t}\n\n\tif (rev->line_level_traverse)\n\t\tline_log_init(rev, line_cb.prefix, &line_cb.args);\n\n\tsetup_pager();\n}\n\nstatic void cmd_log_init(int argc, const char **argv, const char *prefix,\n\t\t\t struct rev_info *rev, struct setup_revision_opt *opt)\n{\n\tcmd_log_init_defaults(rev);\n\tcmd_log_init_finish(argc, argv, prefix, rev, opt);\n}\n\n/*\n * This gives a rough estimate for how many commits we\n * will print out in the list.\n */\nstatic int estimate_commit_count(struct rev_info *rev, struct commit_list *list)\n{\n\tint n = 0;\n\n\twhile (list) {\n\t\tstruct commit *commit = list->item;\n\t\tunsigned int flags = commit->object.flags;\n\t\tlist = list->next;\n\t\tif (!(flags & (TREESAME | UNINTERESTING)))\n\t\t\tn++;\n\t}\n\treturn n;\n}\n\nstatic void show_early_header(struct rev_info *rev, const char *stage, int nr)\n{\n\tif (rev->shown_one) {\n\t\trev->shown_one = 0;\n\t\tif (rev->commit_format != CMIT_FMT_ONELINE)\n\t\t\tputchar(rev->diffopt.line_termination);\n\t}\n\tprintf(_(\"Final output: %d %s\\n\"), nr, stage);\n}\n\nstatic struct itimerval early_output_timer;\n\nstatic void log_show_early(struct rev_info *revs, struct commit_list *list)\n{\n\tint i = revs->early_output;\n\tint show_header = 1;\n\n\tsort_in_topological_order(&list, revs->sort_order);\n\twhile (list && i) {\n\t\tstruct commit *commit = list->item;\n\t\tswitch (simplify_commit(revs, commit)) {\n\t\tcase commit_show:\n\t\t\tif (show_header) {\n\t\t\t\tint n = estimate_commit_count(revs, list);\n\t\t\t\tshow_early_header(revs, \"incomplete\", n);\n\t\t\t\tshow_header = 0;\n\t\t\t}\n\t\t\tlog_tree_commit(revs, commit);\n\t\t\ti--;\n\t\t\tbreak;\n\t\tcase commit_ignore:\n\t\t\tbreak;\n\t\tcase commit_error:\n\t\t\treturn;\n\t\t}\n\t\tlist = list->next;\n\t}\n\n\t/* Did we already get enough commits for the early output? */\n\tif (!i)\n\t\treturn;\n\n\t/*\n\t * ..if no, then repeat it twice a second until we\n\t * do.\n\t *\n\t * NOTE! We don't use \"it_interval\", because if the\n\t * reader isn't listening, we want our output to be\n\t * throttled by the writing, and not have the timer\n\t * trigger every second even if we're blocked on a\n\t * reader!\n\t */\n\tearly_output_timer.it_value.tv_sec = 0;\n\tearly_output_timer.it_value.tv_usec = 500000;\n\tsetitimer(ITIMER_REAL, &early_output_timer, NULL);\n}\n\nstatic void early_output(int signal)\n{\n\tshow_early_output = log_show_early;\n}\n\nstatic void setup_early_output(struct rev_info *rev)\n{\n\tstruct sigaction sa;\n\n\t/*\n\t * Set up the signal handler, minimally intrusively:\n\t * we only set a single volatile integer word (not\n\t * using sigatomic_t - trying to avoid unnecessary\n\t * system dependencies and headers), and using\n\t * SA_RESTART.\n\t */\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sa_handler = early_output;\n\tsigemptyset(&sa.sa_mask);\n\tsa.sa_flags = SA_RESTART;\n\tsigaction(SIGALRM, &sa, NULL);\n\n\t/*\n\t * If we can get the whole output in less than a\n\t * tenth of a second, don't even bother doing the\n\t * early-output thing..\n\t *\n\t * This is a one-time-only trigger.\n\t */\n\tearly_output_timer.it_value.tv_sec = 0;\n\tearly_output_timer.it_value.tv_usec = 100000;\n\tsetitimer(ITIMER_REAL, &early_output_timer, NULL);\n}\n\nstatic void finish_early_output(struct rev_info *rev)\n{\n\tint n = estimate_commit_count(rev, rev->commits);\n\tsignal(SIGALRM, SIG_IGN);\n\tshow_early_header(rev, \"done\", n);\n}\n\nstatic int cmd_log_walk(struct rev_info *rev)\n{\n\tstruct commit *commit;\n\tint saved_nrl = 0;\n\tint saved_dcctc = 0;\n\n\tif (rev->early_output)\n\t\tsetup_early_output(rev);\n\n\tif (prepare_revision_walk(rev))\n\t\tdie(_(\"revision walk setup failed\"));\n\n\tif (rev->early_output)\n\t\tfinish_early_output(rev);\n\n\t/*\n\t * For --check and --exit-code, the exit code is based on CHECK_FAILED\n\t * and HAS_CHANGES being accumulated in rev->diffopt, so be careful to\n\t * retain that state information if replacing rev->diffopt in this loop\n\t */\n\twhile ((commit = get_revision(rev)) != NULL) {\n\t\tif (!log_tree_commit(rev, commit) &&\n\t\t    rev->max_count >= 0)\n\t\t\t/*\n\t\t\t * We decremented max_count in get_revision,\n\t\t\t * but we didn't actually show the commit.\n\t\t\t */\n\t\t\trev->max_count++;\n\t\tif (!rev->reflog_info) {\n\t\t\t/* we allow cycles in reflog ancestry */\n\t\t\tfree(commit->buffer);\n\t\t\tcommit->buffer = NULL;\n\t\t}\n\t\tfree_commit_list(commit->parents);\n\t\tcommit->parents = NULL;\n\t\tif (saved_nrl < rev->diffopt.needed_rename_limit)\n\t\t\tsaved_nrl = rev->diffopt.needed_rename_limit;\n\t\tif (rev->diffopt.degraded_cc_to_c)\n\t\t\tsaved_dcctc = 1;\n\t}\n\trev->diffopt.degraded_cc_to_c = saved_dcctc;\n\trev->diffopt.needed_rename_limit = saved_nrl;\n\n\tif (rev->diffopt.output_format & DIFF_FORMAT_CHECKDIFF &&\n\t    DIFF_OPT_TST(&rev->diffopt, CHECK_FAILED)) {\n\t\treturn 02;\n\t}\n\treturn diff_result_code(&rev->diffopt, 0);\n}\n\nstatic int git_log_config(const char *var, const char *value, void *cb)\n{\n\tif (!strcmp(var, \"format.pretty\"))\n\t\treturn git_config_string(&fmt_pretty, var, value);\n\tif (!strcmp(var, \"format.subjectprefix\"))\n\t\treturn git_config_string(&fmt_patch_subject_prefix, var, value);\n\tif (!strcmp(var, \"log.abbrevcommit\")) {\n\t\tdefault_abbrev_commit = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\tif (!strcmp(var, \"log.date\"))\n\t\treturn git_config_string(&default_date_mode, var, value);\n\tif (!strcmp(var, \"log.decorate\")) {\n\t\tdecoration_style = parse_decoration_style(var, value);\n\t\tif (decoration_style < 0)\n\t\t\tdecoration_style = 0; /* maybe warn? */\n\t\treturn 0;\n\t}\n\tif (!strcmp(var, \"log.showroot\")) {\n\t\tdefault_show_root = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\tif (!prefixcmp(var, \"color.decorate.\"))\n\t\treturn parse_decorate_color_config(var, 15, value);\n\tif (!strcmp(var, \"log.mailmap\")) {\n\t\tuse_mailmap_config = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\n\tif (grep_config(var, value, cb) < 0)\n\t\treturn -1;\n\tif (git_gpg_config(var, value, cb) < 0)\n\t\treturn -1;\n\treturn git_diff_ui_config(var, value, cb);\n}\n\nint cmd_whatchanged(int argc, const char **argv, const char *prefix)\n{\n\tstruct rev_info rev;\n\tstruct setup_revision_opt opt;\n\n\tinit_grep_defaults();\n\tgit_config(git_log_config, NULL);\n\n\tinit_revisions(&rev, prefix);\n\trev.diff = 1;\n\trev.simplify_history = 0;\n\tmemset(&opt, 0, sizeof(opt));\n\topt.def = \"HEAD\";\n\topt.revarg_opt = REVARG_COMMITTISH;\n\tcmd_log_init(argc, argv, prefix, &rev, &opt);\n\tif (!rev.diffopt.output_format)\n\t\trev.diffopt.output_format = DIFF_FORMAT_RAW;\n\treturn cmd_log_walk(&rev);\n}\n\nstatic void show_tagger(char *buf, int len, struct rev_info *rev)\n{\n\tstruct strbuf out = STRBUF_INIT;\n\tstruct pretty_print_context pp = {0};\n\n\tpp.fmt = rev->commit_format;\n\tpp.date_mode = rev->date_mode;\n\tpp_user_info(&pp, \"Tagger\", &out, buf, get_log_output_encoding());\n\tprintf(\"%s\", out.buf);\n\tstrbuf_release(&out);\n}\n\nstatic int show_blob_object(const unsigned char *sha1, struct rev_info *rev, const char *obj_name)\n{\n\tunsigned char sha1c[20];\n\tstruct object_context obj_context;\n\tchar *buf;\n\tunsigned long size;\n\n\tfflush(stdout);\n\tif (!DIFF_OPT_TOUCHED(&rev->diffopt, ALLOW_TEXTCONV) ||\n\t    !DIFF_OPT_TST(&rev->diffopt, ALLOW_TEXTCONV))\n\t\treturn stream_blob_to_fd(1, sha1, NULL, 0);\n\n\tif (get_sha1_with_context(obj_name, 0, sha1c, &obj_context))\n\t\tdie(\"Not a valid object name %s\", obj_name);\n\tif (!obj_context.path[0] ||\n\t    !textconv_object(obj_context.path, obj_context.mode, sha1c, 1, &buf, &size))\n\t\treturn stream_blob_to_fd(1, sha1, NULL, 0);\n\n\tif (!buf)\n\t\tdie(\"git show %s: bad file\", obj_name);\n\n\twrite_or_die(1, buf, size);\n\treturn 0;\n}\n\nstatic int show_tag_object(const unsigned char *sha1, struct rev_info *rev)\n{\n\tunsigned long size;\n\tenum object_type type;\n\tchar *buf = read_sha1_file(sha1, &type, &size);\n\tint offset = 0;\n\n\tif (!buf)\n\t\treturn error(_(\"Could not read object %s\"), sha1_to_hex(sha1));\n\n\tassert(type == OBJ_TAG);\n\twhile (offset < size && buf[offset] != '\\n') {\n\t\tint new_offset = offset + 1;\n\t\twhile (new_offset < size && buf[new_offset++] != '\\n')\n\t\t\t; /* do nothing */\n\t\tif (!prefixcmp(buf + offset, \"tagger \"))\n\t\t\tshow_tagger(buf + offset + 7,\n\t\t\t\t    new_offset - offset - 7, rev);\n\t\toffset = new_offset;\n\t}\n\n\tif (offset < size)\n\t\tfwrite(buf + offset, size - offset, 1, stdout);\n\tfree(buf);\n\treturn 0;\n}\n\nstatic int show_tree_object(const unsigned char *sha1,\n\t\tconst char *base, int baselen,\n\t\tconst char *pathname, unsigned mode, int stage, void *context)\n{\n\tprintf(\"%s%s\\n\", pathname, S_ISDIR(mode) ? \"/\" : \"\");\n\treturn 0;\n}\n\nstatic void show_rev_tweak_rev(struct rev_info *rev, struct setup_revision_opt *opt)\n{\n\tif (rev->ignore_merges) {\n\t\t/* There was no \"-m\" on the command line */\n\t\trev->ignore_merges = 0;\n\t\tif (!rev->first_parent_only && !rev->combine_merges) {\n\t\t\t/* No \"--first-parent\", \"-c\", nor \"--cc\" */\n\t\t\trev->combine_merges = 1;\n\t\t\trev->dense_combined_merges = 1;\n\t\t}\n\t}\n\tif (!rev->diffopt.output_format)\n\t\trev->diffopt.output_format = DIFF_FORMAT_PATCH;\n}\n\nint cmd_show(int argc, const char **argv, const char *prefix)\n{\n\tstruct rev_info rev;\n\tstruct object_array_entry *objects;\n\tstruct setup_revision_opt opt;\n\tstruct pathspec match_all;\n\tint i, count, ret = 0;\n\n\tinit_grep_defaults();\n\tgit_config(git_log_config, NULL);\n\n\tmemset(&match_all, 0, sizeof(match_all));\n\tinit_revisions(&rev, prefix);\n\trev.diff = 1;\n\trev.always_show_header = 1;\n\trev.no_walk = REVISION_WALK_NO_WALK_SORTED;\n\trev.diffopt.stat_width = -1; \t/* Scale to real terminal size */\n\n\tmemset(&opt, 0, sizeof(opt));\n\topt.def = \"HEAD\";\n\topt.tweak = show_rev_tweak_rev;\n\tcmd_log_init(argc, argv, prefix, &rev, &opt);\n\n\tif (!rev.no_walk)\n\t\treturn cmd_log_walk(&rev);\n\n\tcount = rev.pending.nr;\n\tobjects = rev.pending.objects;\n\tfor (i = 0; i < count && !ret; i++) {\n\t\tstruct object *o = objects[i].item;\n\t\tconst char *name = objects[i].name;\n\t\tswitch (o->type) {\n\t\tcase OBJ_BLOB:\n\t\t\tret = show_blob_object(o->sha1, &rev, name);\n\t\t\tbreak;\n\t\tcase OBJ_TAG: {\n\t\t\tstruct tag *t = (struct tag *)o;\n\n\t\t\tif (rev.shown_one)\n\t\t\t\tputchar('\\n');\n\t\t\tprintf(\"%stag %s%s\\n\",\n\t\t\t\t\tdiff_get_color_opt(&rev.diffopt, DIFF_COMMIT),\n\t\t\t\t\tt->tag,\n\t\t\t\t\tdiff_get_color_opt(&rev.diffopt, DIFF_RESET));\n\t\t\tret = show_tag_object(o->sha1, &rev);\n\t\t\trev.shown_one = 1;\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\to = parse_object(t->tagged->sha1);\n\t\t\tif (!o)\n\t\t\t\tret = error(_(\"Could not read object %s\"),\n\t\t\t\t\t    sha1_to_hex(t->tagged->sha1));\n\t\t\tobjects[i].item = o;\n\t\t\ti--;\n\t\t\tbreak;\n\t\t}\n\t\tcase OBJ_TREE:\n\t\t\tif (rev.shown_one)\n\t\t\t\tputchar('\\n');\n\t\t\tprintf(\"%stree %s%s\\n\\n\",\n\t\t\t\t\tdiff_get_color_opt(&rev.diffopt, DIFF_COMMIT),\n\t\t\t\t\tname,\n\t\t\t\t\tdiff_get_color_opt(&rev.diffopt, DIFF_RESET));\n\t\t\tread_tree_recursive((struct tree *)o, \"\", 0, 0, &match_all,\n\t\t\t\t\tshow_tree_object, NULL);\n\t\t\trev.shown_one = 1;\n\t\t\tbreak;\n\t\tcase OBJ_COMMIT:\n\t\t\trev.pending.nr = rev.pending.alloc = 0;\n\t\t\trev.pending.objects = NULL;\n\t\t\tadd_object_array(o, name, &rev.pending);\n\t\t\tret = cmd_log_walk(&rev);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = error(_(\"Unknown type: %d\"), o->type);\n\t\t}\n\t}\n\tfree(objects);\n\treturn ret;\n}\n\n/*\n * This is equivalent to \"git log -g --abbrev-commit --pretty=oneline\"\n */\nint cmd_log_reflog(int argc, const char **argv, const char *prefix)\n{\n\tstruct rev_info rev;\n\tstruct setup_revision_opt opt;\n\n\tinit_grep_defaults();\n\tgit_config(git_log_config, NULL);\n\n\tinit_revisions(&rev, prefix);\n\tinit_reflog_walk(&rev.reflog_info);\n\trev.verbose_header = 1;\n\tmemset(&opt, 0, sizeof(opt));\n\topt.def = \"HEAD\";\n\tcmd_log_init_defaults(&rev);\n\trev.abbrev_commit = 1;\n\trev.commit_format = CMIT_FMT_ONELINE;\n\trev.use_terminator = 1;\n\trev.always_show_header = 1;\n\tcmd_log_init_finish(argc, argv, prefix, &rev, &opt);\n\n\treturn cmd_log_walk(&rev);\n}\n\nint cmd_log(int argc, const char **argv, const char *prefix)\n{\n\tstruct rev_info rev;\n\tstruct setup_revision_opt opt;\n\n\tinit_grep_defaults();\n\tgit_config(git_log_config, NULL);\n\n\tinit_revisions(&rev, prefix);\n\trev.always_show_header = 1;\n\tmemset(&opt, 0, sizeof(opt));\n\topt.def = \"HEAD\";\n\topt.revarg_opt = REVARG_COMMITTISH;\n\tcmd_log_init(argc, argv, prefix, &rev, &opt);\n\treturn cmd_log_walk(&rev);\n}\n\n/* format-patch */\n\nstatic const char *fmt_patch_suffix = \".patch\";\nstatic int numbered = 0;\nstatic int auto_number = 1;\n\nstatic char *default_attach = NULL;\n\nstatic struct string_list extra_hdr;\nstatic struct string_list extra_to;\nstatic struct string_list extra_cc;\n\nstatic void add_header(const char *value)\n{\n\tstruct string_list_item *item;\n\tint len = strlen(value);\n\twhile (len && value[len - 1] == '\\n')\n\t\tlen--;\n\n\tif (!strncasecmp(value, \"to: \", 4)) {\n\t\titem = string_list_append(&extra_to, value + 4);\n\t\tlen -= 4;\n\t} else if (!strncasecmp(value, \"cc: \", 4)) {\n\t\titem = string_list_append(&extra_cc, value + 4);\n\t\tlen -= 4;\n\t} else {\n\t\titem = string_list_append(&extra_hdr, value);\n\t}\n\n\titem->string[len] = '\\0';\n}\n\n#define THREAD_SHALLOW 1\n#define THREAD_DEEP 2\nstatic int thread;\nstatic int do_signoff;\nstatic const char *signature = git_version_string;\nstatic int config_cover_letter;\n\nenum {\n\tCOVER_UNSET,\n\tCOVER_OFF,\n\tCOVER_ON,\n\tCOVER_AUTO\n};\n\nstatic int git_format_config(const char *var, const char *value, void *cb)\n{\n\tif (!strcmp(var, \"format.headers\")) {\n\t\tif (!value)\n\t\t\tdie(_(\"format.headers without value\"));\n\t\tadd_header(value);\n\t\treturn 0;\n\t}\n\tif (!strcmp(var, \"format.suffix\"))\n\t\treturn git_config_string(&fmt_patch_suffix, var, value);\n\tif (!strcmp(var, \"format.to\")) {\n\t\tif (!value)\n\t\t\treturn config_error_nonbool(var);\n\t\tstring_list_append(&extra_to, value);\n\t\treturn 0;\n\t}\n\tif (!strcmp(var, \"format.cc\")) {\n\t\tif (!value)\n\t\t\treturn config_error_nonbool(var);\n\t\tstring_list_append(&extra_cc, value);\n\t\treturn 0;\n\t}\n\tif (!strcmp(var, \"diff.color\") || !strcmp(var, \"color.diff\") ||\n\t    !strcmp(var, \"color.ui\")) {\n\t\treturn 0;\n\t}\n\tif (!strcmp(var, \"format.numbered\")) {\n\t\tif (value && !strcasecmp(value, \"auto\")) {\n\t\t\tauto_number = 1;\n\t\t\treturn 0;\n\t\t}\n\t\tnumbered = git_config_bool(var, value);\n\t\tauto_number = auto_number && numbered;\n\t\treturn 0;\n\t}\n\tif (!strcmp(var, \"format.attach\")) {\n\t\tif (value && *value)\n\t\t\tdefault_attach = xstrdup(value);\n\t\telse\n\t\t\tdefault_attach = xstrdup(git_version_string);\n\t\treturn 0;\n\t}\n\tif (!strcmp(var, \"format.thread\")) {\n\t\tif (value && !strcasecmp(value, \"deep\")) {\n\t\t\tthread = THREAD_DEEP;\n\t\t\treturn 0;\n\t\t}\n\t\tif (value && !strcasecmp(value, \"shallow\")) {\n\t\t\tthread = THREAD_SHALLOW;\n\t\t\treturn 0;\n\t\t}\n\t\tthread = git_config_bool(var, value) && THREAD_SHALLOW;\n\t\treturn 0;\n\t}\n\tif (!strcmp(var, \"format.signoff\")) {\n\t\tdo_signoff = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\tif (!strcmp(var, \"format.signature\"))\n\t\treturn git_config_string(&signature, var, value);\n\tif (!strcmp(var, \"format.coverletter\")) {\n\t\tif (value && !strcasecmp(value, \"auto\")) {\n\t\t\tconfig_cover_letter = COVER_AUTO;\n\t\t\treturn 0;\n\t\t}\n\t\tconfig_cover_letter = git_config_bool(var, value) ? COVER_ON : COVER_OFF;\n\t\treturn 0;\n\t}\n\n\treturn git_log_config(var, value, cb);\n}\n\nstatic FILE *realstdout = NULL;\nstatic const char *output_directory = NULL;\nstatic int outdir_offset;\n\nstatic int reopen_stdout(struct commit *commit, const char *subject,\n\t\t\t struct rev_info *rev, int quiet)\n{\n\tstruct strbuf filename = STRBUF_INIT;\n\tint suffix_len = strlen(rev->patch_suffix) + 1;\n\n\tif (output_directory) {\n\t\tstrbuf_addstr(&filename, output_directory);\n\t\tif (filename.len >=\n\t\t    PATH_MAX - FORMAT_PATCH_NAME_MAX - suffix_len)\n\t\t\treturn error(_(\"name of output directory is too long\"));\n\t\tif (filename.buf[filename.len - 1] != '/')\n\t\t\tstrbuf_addch(&filename, '/');\n\t}\n\n\tif (rev->numbered_files)\n\t\tstrbuf_addf(&filename, \"%d\", rev->nr);\n\telse if (commit)\n\t\tfmt_output_commit(&filename, commit, rev);\n\telse\n\t\tfmt_output_subject(&filename, subject, rev);\n\n\tif (!quiet)\n\t\tfprintf(realstdout, \"%s\\n\", filename.buf + outdir_offset);\n\n\tif (freopen(filename.buf, \"w\", stdout) == NULL)\n\t\treturn error(_(\"Cannot open patch file %s\"), filename.buf);\n\n\tstrbuf_release(&filename);\n\treturn 0;\n}\n\nstatic void get_patch_ids(struct rev_info *rev, struct patch_ids *ids)\n{\n\tstruct rev_info check_rev;\n\tstruct commit *commit;\n\tstruct object *o1, *o2;\n\tunsigned flags1, flags2;\n\n\tif (rev->pending.nr != 2)\n\t\tdie(_(\"Need exactly one range.\"));\n\n\to1 = rev->pending.objects[0].item;\n\tflags1 = o1->flags;\n\to2 = rev->pending.objects[1].item;\n\tflags2 = o2->flags;\n\n\tif ((flags1 & UNINTERESTING) == (flags2 & UNINTERESTING))\n\t\tdie(_(\"Not a range.\"));\n\n\tinit_patch_ids(ids);\n\n\t/* given a range a..b get all patch ids for b..a */\n\tinit_revisions(&check_rev, rev->prefix);\n\tcheck_rev.max_parents = 1;\n\to1->flags ^= UNINTERESTING;\n\to2->flags ^= UNINTERESTING;\n\tadd_pending_object(&check_rev, o1, \"o1\");\n\tadd_pending_object(&check_rev, o2, \"o2\");\n\tif (prepare_revision_walk(&check_rev))\n\t\tdie(_(\"revision walk setup failed\"));\n\n\twhile ((commit = get_revision(&check_rev)) != NULL) {\n\t\tadd_commit_patch_id(commit, ids);\n\t}\n\n\t/* reset for next revision walk */\n\tclear_commit_marks((struct commit *)o1,\n\t\t\tSEEN | UNINTERESTING | SHOWN | ADDED);\n\tclear_commit_marks((struct commit *)o2,\n\t\t\tSEEN | UNINTERESTING | SHOWN | ADDED);\n\to1->flags = flags1;\n\to2->flags = flags2;\n}\n\nstatic void gen_message_id(struct rev_info *info, char *base)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tstrbuf_addf(&buf, \"%s.%lu.git.%s\", base,\n\t\t    (unsigned long) time(NULL),\n\t\t    git_committer_info(IDENT_NO_NAME|IDENT_NO_DATE|IDENT_STRICT));\n\tinfo->message_id = strbuf_detach(&buf, NULL);\n}\n\nstatic void print_signature(void)\n{\n\tif (signature && *signature)\n\t\tprintf(\"-- \\n%s\\n\\n\", signature);\n}\n\nstatic void add_branch_description(struct strbuf *buf, const char *branch_name)\n{\n\tstruct strbuf desc = STRBUF_INIT;\n\tif (!branch_name || !*branch_name)\n\t\treturn;\n\tread_branch_desc(&desc, branch_name);\n\tif (desc.len) {\n\t\tstrbuf_addch(buf, '\\n');\n\t\tstrbuf_add(buf, desc.buf, desc.len);\n\t\tstrbuf_addch(buf, '\\n');\n\t}\n}\n\nstatic char *find_branch_name(struct rev_info *rev)\n{\n\tint i, positive = -1;\n\tunsigned char branch_sha1[20];\n\tconst unsigned char *tip_sha1;\n\tconst char *ref;\n\tchar *full_ref, *branch = NULL;\n\n\tfor (i = 0; i < rev->cmdline.nr; i++) {\n\t\tif (rev->cmdline.rev[i].flags & UNINTERESTING)\n\t\t\tcontinue;\n\t\tif (positive < 0)\n\t\t\tpositive = i;\n\t\telse\n\t\t\treturn NULL;\n\t}\n\tif (positive < 0)\n\t\treturn NULL;\n\tref = rev->cmdline.rev[positive].name;\n\ttip_sha1 = rev->cmdline.rev[positive].item->sha1;\n\tif (dwim_ref(ref, strlen(ref), branch_sha1, &full_ref) &&\n\t    !prefixcmp(full_ref, \"refs/heads/\") &&\n\t    !hashcmp(tip_sha1, branch_sha1))\n\t\tbranch = xstrdup(full_ref + strlen(\"refs/heads/\"));\n\tfree(full_ref);\n\treturn branch;\n}\n\nstatic void make_cover_letter(struct rev_info *rev, int use_stdout,\n\t\t\t      struct commit *origin,\n\t\t\t      int nr, struct commit **list,\n\t\t\t      const char *branch_name,\n\t\t\t      int quiet)\n{\n\tconst char *committer;\n\tconst char *body = \"*** SUBJECT HERE ***\\n\\n*** BLURB HERE ***\\n\";\n\tconst char *msg;\n\tstruct shortlog log;\n\tstruct strbuf sb = STRBUF_INIT;\n\tint i;\n\tconst char *encoding = \"UTF-8\";\n\tstruct diff_options opts;\n\tint need_8bit_cte = 0;\n\tstruct pretty_print_context pp = {0};\n\tstruct commit *head = list[0];\n\n\tif (rev->commit_format != CMIT_FMT_EMAIL)\n\t\tdie(_(\"Cover letter needs email format\"));\n\n\tcommitter = git_committer_info(0);\n\n\tif (!use_stdout &&\n\t    reopen_stdout(NULL, rev->numbered_files ? NULL : \"cover-letter\", rev, quiet))\n\t\treturn;\n\n\tlog_write_email_headers(rev, head, &pp.subject, &pp.after_subject,\n\t\t\t\t&need_8bit_cte);\n\n\tfor (i = 0; !need_8bit_cte && i < nr; i++)\n\t\tif (has_non_ascii(list[i]->buffer))\n\t\t\tneed_8bit_cte = 1;\n\n\tif (!branch_name)\n\t\tbranch_name = find_branch_name(rev);\n\n\tmsg = body;\n\tpp.fmt = CMIT_FMT_EMAIL;\n\tpp.date_mode = DATE_RFC2822;\n\tpp_user_info(&pp, NULL, &sb, committer, encoding);\n\tpp_title_line(&pp, &msg, &sb, encoding, need_8bit_cte);\n\tpp_remainder(&pp, &msg, &sb, 0);\n\tadd_branch_description(&sb, branch_name);\n\tprintf(\"%s\\n\", sb.buf);\n\n\tstrbuf_release(&sb);\n\n\tshortlog_init(&log);\n\tlog.wrap_lines = 1;\n\tlog.wrap = 72;\n\tlog.in1 = 2;\n\tlog.in2 = 4;\n\tfor (i = 0; i < nr; i++)\n\t\tshortlog_add_commit(&log, list[i]);\n\n\tshortlog_output(&log);\n\n\t/*\n\t * We can only do diffstat with a unique reference point\n\t */\n\tif (!origin)\n\t\treturn;\n\n\tmemcpy(&opts, &rev->diffopt, sizeof(opts));\n\topts.output_format = DIFF_FORMAT_SUMMARY | DIFF_FORMAT_DIFFSTAT;\n\n\tdiff_setup_done(&opts);\n\n\tdiff_tree_sha1(origin->tree->object.sha1,\n\t\t       head->tree->object.sha1,\n\t\t       \"\", &opts);\n\tdiffcore_std(&opts);\n\tdiff_flush(&opts);\n\n\tprintf(\"\\n\");\n\tprint_signature();\n}\n\nstatic const char *clean_message_id(const char *msg_id)\n{\n\tchar ch;\n\tconst char *a, *z, *m;\n\n\tm = msg_id;\n\twhile ((ch = *m) && (isspace(ch) || (ch == '<')))\n\t\tm++;\n\ta = m;\n\tz = NULL;\n\twhile ((ch = *m)) {\n\t\tif (!isspace(ch) && (ch != '>'))\n\t\t\tz = m;\n\t\tm++;\n\t}\n\tif (!z)\n\t\tdie(_(\"insane in-reply-to: %s\"), msg_id);\n\tif (++z == m)\n\t\treturn a;\n\treturn xmemdupz(a, z - a);\n}\n\nstatic const char *set_outdir(const char *prefix, const char *output_directory)\n{\n\tif (output_directory && is_absolute_path(output_directory))\n\t\treturn output_directory;\n\n\tif (!prefix || !*prefix) {\n\t\tif (output_directory)\n\t\t\treturn output_directory;\n\t\t/* The user did not explicitly ask for \"./\" */\n\t\toutdir_offset = 2;\n\t\treturn \"./\";\n\t}\n\n\toutdir_offset = strlen(prefix);\n\tif (!output_directory)\n\t\treturn prefix;\n\n\treturn xstrdup(prefix_filename(prefix, outdir_offset,\n\t\t\t\t       output_directory));\n}\n\nstatic const char * const builtin_format_patch_usage[] = {\n\tN_(\"git format-patch [options] [<since> | <revision range>]\"),\n\tNULL\n};\n\nstatic int keep_subject = 0;\n\nstatic int keep_callback(const struct option *opt, const char *arg, int unset)\n{\n\t((struct rev_info *)opt->value)->total = -1;\n\tkeep_subject = 1;\n\treturn 0;\n}\n\nstatic int subject_prefix = 0;\n\nstatic int subject_prefix_callback(const struct option *opt, const char *arg,\n\t\t\t    int unset)\n{\n\tsubject_prefix = 1;\n\t((struct rev_info *)opt->value)->subject_prefix = arg;\n\treturn 0;\n}\n\nstatic int numbered_cmdline_opt = 0;\n\nstatic int numbered_callback(const struct option *opt, const char *arg,\n\t\t\t     int unset)\n{\n\t*(int *)opt->value = numbered_cmdline_opt = unset ? 0 : 1;\n\tif (unset)\n\t\tauto_number =  0;\n\treturn 0;\n}\n\nstatic int no_numbered_callback(const struct option *opt, const char *arg,\n\t\t\t\tint unset)\n{\n\treturn numbered_callback(opt, arg, 1);\n}\n\nstatic int output_directory_callback(const struct option *opt, const char *arg,\n\t\t\t      int unset)\n{\n\tconst char **dir = (const char **)opt->value;\n\tif (*dir)\n\t\tdie(_(\"Two output directories?\"));\n\t*dir = arg;\n\treturn 0;\n}\n\nstatic int thread_callback(const struct option *opt, const char *arg, int unset)\n{\n\tint *thread = (int *)opt->value;\n\tif (unset)\n\t\t*thread = 0;\n\telse if (!arg || !strcmp(arg, \"shallow\"))\n\t\t*thread = THREAD_SHALLOW;\n\telse if (!strcmp(arg, \"deep\"))\n\t\t*thread = THREAD_DEEP;\n\telse\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int attach_callback(const struct option *opt, const char *arg, int unset)\n{\n\tstruct rev_info *rev = (struct rev_info *)opt->value;\n\tif (unset)\n\t\trev->mime_boundary = NULL;\n\telse if (arg)\n\t\trev->mime_boundary = arg;\n\telse\n\t\trev->mime_boundary = git_version_string;\n\trev->no_inline = unset ? 0 : 1;\n\treturn 0;\n}\n\nstatic int inline_callback(const struct option *opt, const char *arg, int unset)\n{\n\tstruct rev_info *rev = (struct rev_info *)opt->value;\n\tif (unset)\n\t\trev->mime_boundary = NULL;\n\telse if (arg)\n\t\trev->mime_boundary = arg;\n\telse\n\t\trev->mime_boundary = git_version_string;\n\trev->no_inline = 0;\n\treturn 0;\n}\n\nstatic int header_callback(const struct option *opt, const char *arg, int unset)\n{\n\tif (unset) {\n\t\tstring_list_clear(&extra_hdr, 0);\n\t\tstring_list_clear(&extra_to, 0);\n\t\tstring_list_clear(&extra_cc, 0);\n\t} else {\n\t    add_header(arg);\n\t}\n\treturn 0;\n}\n\nstatic int to_callback(const struct option *opt, const char *arg, int unset)\n{\n\tif (unset)\n\t\tstring_list_clear(&extra_to, 0);\n\telse\n\t\tstring_list_append(&extra_to, arg);\n\treturn 0;\n}\n\nstatic int cc_callback(const struct option *opt, const char *arg, int unset)\n{\n\tif (unset)\n\t\tstring_list_clear(&extra_cc, 0);\n\telse\n\t\tstring_list_append(&extra_cc, arg);\n\treturn 0;\n}\n\nstatic int from_callback(const struct option *opt, const char *arg, int unset)\n{\n\tchar **from = opt->value;\n\n\tfree(*from);\n\n\tif (unset)\n\t\t*from = NULL;\n\telse if (arg)\n\t\t*from = xstrdup(arg);\n\telse\n\t\t*from = xstrdup(git_committer_info(IDENT_NO_DATE));\n\treturn 0;\n}\n\nint cmd_format_patch(int argc, const char **argv, const char *prefix)\n{\n\tstruct commit *commit;\n\tstruct commit **list = NULL;\n\tstruct rev_info rev;\n\tstruct setup_revision_opt s_r_opt;\n\tint nr = 0, total, i;\n\tint use_stdout = 0;\n\tint start_number = -1;\n\tint just_numbers = 0;\n\tint ignore_if_in_upstream = 0;\n\tint cover_letter = -1;\n\tint boundary_count = 0;\n\tint no_binary_diff = 0;\n\tstruct commit *origin = NULL;\n\tconst char *in_reply_to = NULL;\n\tstruct patch_ids ids;\n\tstruct strbuf buf = STRBUF_INIT;\n\tint use_patch_format = 0;\n\tint quiet = 0;\n\tint reroll_count = -1;\n\tchar *branch_name = NULL;\n\tchar *from = NULL;\n\tconst struct option builtin_format_patch_options[] = {\n\t\t{ OPTION_CALLBACK, 'n', \"numbered\", &numbered, NULL,\n\t\t\t    N_(\"use [PATCH n/m] even with a single patch\"),\n\t\t\t    PARSE_OPT_NOARG, numbered_callback },\n\t\t{ OPTION_CALLBACK, 'N', \"no-numbered\", &numbered, NULL,\n\t\t\t    N_(\"use [PATCH] even with multiple patches\"),\n\t\t\t    PARSE_OPT_NOARG, no_numbered_callback },\n\t\tOPT_BOOL('s', \"signoff\", &do_signoff, N_(\"add Signed-off-by:\")),\n\t\tOPT_BOOL(0, \"stdout\", &use_stdout,\n\t\t\t    N_(\"print patches to standard out\")),\n\t\tOPT_BOOL(0, \"cover-letter\", &cover_letter,\n\t\t\t    N_(\"generate a cover letter\")),\n\t\tOPT_BOOL(0, \"numbered-files\", &just_numbers,\n\t\t\t    N_(\"use simple number sequence for output file names\")),\n\t\tOPT_STRING(0, \"suffix\", &fmt_patch_suffix, N_(\"sfx\"),\n\t\t\t    N_(\"use <sfx> instead of '.patch'\")),\n\t\tOPT_INTEGER(0, \"start-number\", &start_number,\n\t\t\t    N_(\"start numbering patches at <n> instead of 1\")),\n\t\tOPT_INTEGER('v', \"reroll-count\", &reroll_count,\n\t\t\t    N_(\"mark the series as Nth re-roll\")),\n\t\t{ OPTION_CALLBACK, 0, \"subject-prefix\", &rev, N_(\"prefix\"),\n\t\t\t    N_(\"Use [<prefix>] instead of [PATCH]\"),\n\t\t\t    PARSE_OPT_NONEG, subject_prefix_callback },\n\t\t{ OPTION_CALLBACK, 'o', \"output-directory\", &output_directory,\n\t\t\t    N_(\"dir\"), N_(\"store resulting files in <dir>\"),\n\t\t\t    PARSE_OPT_NONEG, output_directory_callback },\n\t\t{ OPTION_CALLBACK, 'k', \"keep-subject\", &rev, NULL,\n\t\t\t    N_(\"don't strip/add [PATCH]\"),\n\t\t\t    PARSE_OPT_NOARG | PARSE_OPT_NONEG, keep_callback },\n\t\tOPT_BOOL(0, \"no-binary\", &no_binary_diff,\n\t\t\t N_(\"don't output binary diffs\")),\n\t\tOPT_BOOL(0, \"ignore-if-in-upstream\", &ignore_if_in_upstream,\n\t\t\t N_(\"don't include a patch matching a commit upstream\")),\n\t\t{ OPTION_SET_INT, 'p', \"no-stat\", &use_patch_format, NULL,\n\t\t  N_(\"show patch format instead of default (patch + stat)\"),\n\t\t  PARSE_OPT_NONEG | PARSE_OPT_NOARG, NULL, 1},\n\t\tOPT_GROUP(N_(\"Messaging\")),\n\t\t{ OPTION_CALLBACK, 0, \"add-header\", NULL, N_(\"header\"),\n\t\t\t    N_(\"add email header\"), 0, header_callback },\n\t\t{ OPTION_CALLBACK, 0, \"to\", NULL, N_(\"email\"), N_(\"add To: header\"),\n\t\t\t    0, to_callback },\n\t\t{ OPTION_CALLBACK, 0, \"cc\", NULL, N_(\"email\"), N_(\"add Cc: header\"),\n\t\t\t    0, cc_callback },\n\t\t{ OPTION_CALLBACK, 0, \"from\", &from, N_(\"ident\"),\n\t\t\t    N_(\"set From address to <ident> (or committer ident if absent)\"),\n\t\t\t    PARSE_OPT_OPTARG, from_callback },\n\t\tOPT_STRING(0, \"in-reply-to\", &in_reply_to, N_(\"message-id\"),\n\t\t\t    N_(\"make first mail a reply to <message-id>\")),\n\t\t{ OPTION_CALLBACK, 0, \"attach\", &rev, N_(\"boundary\"),\n\t\t\t    N_(\"attach the patch\"), PARSE_OPT_OPTARG,\n\t\t\t    attach_callback },\n\t\t{ OPTION_CALLBACK, 0, \"inline\", &rev, N_(\"boundary\"),\n\t\t\t    N_(\"inline the patch\"),\n\t\t\t    PARSE_OPT_OPTARG | PARSE_OPT_NONEG,\n\t\t\t    inline_callback },\n\t\t{ OPTION_CALLBACK, 0, \"thread\", &thread, N_(\"style\"),\n\t\t\t    N_(\"enable message threading, styles: shallow, deep\"),\n\t\t\t    PARSE_OPT_OPTARG, thread_callback },\n\t\tOPT_STRING(0, \"signature\", &signature, N_(\"signature\"),\n\t\t\t    N_(\"add a signature\")),\n\t\tOPT__QUIET(&quiet, N_(\"don't print the patch filenames\")),\n\t\tOPT_END()\n\t};\n\n\textra_hdr.strdup_strings = 1;\n\textra_to.strdup_strings = 1;\n\textra_cc.strdup_strings = 1;\n\tinit_grep_defaults();\n\tgit_config(git_format_config, NULL);\n\tinit_revisions(&rev, prefix);\n\trev.commit_format = CMIT_FMT_EMAIL;\n\trev.verbose_header = 1;\n\trev.diff = 1;\n\trev.max_parents = 1;\n\tDIFF_OPT_SET(&rev.diffopt, RECURSIVE);\n\trev.subject_prefix = fmt_patch_subject_prefix;\n\tmemset(&s_r_opt, 0, sizeof(s_r_opt));\n\ts_r_opt.def = \"HEAD\";\n\ts_r_opt.revarg_opt = REVARG_COMMITTISH;\n\n\tif (default_attach) {\n\t\trev.mime_boundary = default_attach;\n\t\trev.no_inline = 1;\n\t}\n\n\t/*\n\t * Parse the arguments before setup_revisions(), or something\n\t * like \"git format-patch -o a123 HEAD^..\" may fail; a123 is\n\t * possibly a valid SHA1.\n\t */\n\targc = parse_options(argc, argv, prefix, builtin_format_patch_options,\n\t\t\t     builtin_format_patch_usage,\n\t\t\t     PARSE_OPT_KEEP_ARGV0 | PARSE_OPT_KEEP_UNKNOWN |\n\t\t\t     PARSE_OPT_KEEP_DASHDASH);\n\n\tif (0 < reroll_count) {\n\t\tstruct strbuf sprefix = STRBUF_INIT;\n\t\tstrbuf_addf(&sprefix, \"%s v%d\",\n\t\t\t    rev.subject_prefix, reroll_count);\n\t\trev.reroll_count = reroll_count;\n\t\trev.subject_prefix = strbuf_detach(&sprefix, NULL);\n\t}\n\n\tfor (i = 0; i < extra_hdr.nr; i++) {\n\t\tstrbuf_addstr(&buf, extra_hdr.items[i].string);\n\t\tstrbuf_addch(&buf, '\\n');\n\t}\n\n\tif (extra_to.nr)\n\t\tstrbuf_addstr(&buf, \"To: \");\n\tfor (i = 0; i < extra_to.nr; i++) {\n\t\tif (i)\n\t\t\tstrbuf_addstr(&buf, \"    \");\n\t\tstrbuf_addstr(&buf, extra_to.items[i].string);\n\t\tif (i + 1 < extra_to.nr)\n\t\t\tstrbuf_addch(&buf, ',');\n\t\tstrbuf_addch(&buf, '\\n');\n\t}\n\n\tif (extra_cc.nr)\n\t\tstrbuf_addstr(&buf, \"Cc: \");\n\tfor (i = 0; i < extra_cc.nr; i++) {\n\t\tif (i)\n\t\t\tstrbuf_addstr(&buf, \"    \");\n\t\tstrbuf_addstr(&buf, extra_cc.items[i].string);\n\t\tif (i + 1 < extra_cc.nr)\n\t\t\tstrbuf_addch(&buf, ',');\n\t\tstrbuf_addch(&buf, '\\n');\n\t}\n\n\trev.extra_headers = strbuf_detach(&buf, NULL);\n\n\tif (from) {\n\t\tif (split_ident_line(&rev.from_ident, from, strlen(from)))\n\t\t\tdie(_(\"invalid ident line: %s\"), from);\n\t}\n\n\tif (start_number < 0)\n\t\tstart_number = 1;\n\n\t/*\n\t * If numbered is set solely due to format.numbered in config,\n\t * and it would conflict with --keep-subject (-k) from the\n\t * command line, reset \"numbered\".\n\t */\n\tif (numbered && keep_subject && !numbered_cmdline_opt)\n\t\tnumbered = 0;\n\n\tif (numbered && keep_subject)\n\t\tdie (_(\"-n and -k are mutually exclusive.\"));\n\tif (keep_subject && subject_prefix)\n\t\tdie (_(\"--subject-prefix and -k are mutually exclusive.\"));\n\trev.preserve_subject = keep_subject;\n\n\targc = setup_revisions(argc, argv, &rev, &s_r_opt);\n\tif (argc > 1)\n\t\tdie (_(\"unrecognized argument: %s\"), argv[1]);\n\n\tif (rev.diffopt.output_format & DIFF_FORMAT_NAME)\n\t\tdie(_(\"--name-only does not make sense\"));\n\tif (rev.diffopt.output_format & DIFF_FORMAT_NAME_STATUS)\n\t\tdie(_(\"--name-status does not make sense\"));\n\tif (rev.diffopt.output_format & DIFF_FORMAT_CHECKDIFF)\n\t\tdie(_(\"--check does not make sense\"));\n\n\tif (!use_patch_format &&\n\t\t(!rev.diffopt.output_format ||\n\t\t rev.diffopt.output_format == DIFF_FORMAT_PATCH))\n\t\trev.diffopt.output_format = DIFF_FORMAT_DIFFSTAT | DIFF_FORMAT_SUMMARY;\n\n\t/* Always generate a patch */\n\trev.diffopt.output_format |= DIFF_FORMAT_PATCH;\n\n\tif (!DIFF_OPT_TST(&rev.diffopt, TEXT) && !no_binary_diff)\n\t\tDIFF_OPT_SET(&rev.diffopt, BINARY);\n\n\tif (rev.show_notes)\n\t\tinit_display_notes(&rev.notes_opt);\n\n\tif (!use_stdout)\n\t\toutput_directory = set_outdir(prefix, output_directory);\n\telse\n\t\tsetup_pager();\n\n\tif (output_directory) {\n\t\tif (use_stdout)\n\t\t\tdie(_(\"standard output, or directory, which one?\"));\n\t\tif (mkdir(output_directory, 0777) < 0 && errno != EEXIST)\n\t\t\tdie_errno(_(\"Could not create directory '%s'\"),\n\t\t\t\t  output_directory);\n\t}\n\n\tif (rev.pending.nr == 1) {\n\t\tint check_head = 0;\n\n\t\tif (rev.max_count < 0 && !rev.show_root_diff) {\n\t\t\t/*\n\t\t\t * This is traditional behaviour of \"git format-patch\n\t\t\t * origin\" that prepares what the origin side still\n\t\t\t * does not have.\n\t\t\t */\n\t\t\trev.pending.objects[0].item->flags |= UNINTERESTING;\n\t\t\tadd_head_to_pending(&rev);\n\t\t\tcheck_head = 1;\n\t\t}\n\t\t/*\n\t\t * Otherwise, it is \"format-patch -22 HEAD\", and/or\n\t\t * \"format-patch --root HEAD\".  The user wants\n\t\t * get_revision() to do the usual traversal.\n\t\t */\n\n\t\tif (!strcmp(rev.pending.objects[0].name, \"HEAD\"))\n\t\t\tcheck_head = 1;\n\n\t\tif (check_head) {\n\t\t\tunsigned char sha1[20];\n\t\t\tconst char *ref;\n\t\t\tref = resolve_ref_unsafe(\"HEAD\", sha1, 1, NULL);\n\t\t\tif (ref && !prefixcmp(ref, \"refs/heads/\"))\n\t\t\t\tbranch_name = xstrdup(ref + strlen(\"refs/heads/\"));\n\t\t\telse\n\t\t\t\tbranch_name = xstrdup(\"\"); /* no branch */\n\t\t}\n\t}\n\n\t/*\n\t * We cannot move this anywhere earlier because we do want to\n\t * know if --root was given explicitly from the command line.\n\t */\n\trev.show_root_diff = 1;\n\n\tif (ignore_if_in_upstream) {\n\t\t/* Don't say anything if head and upstream are the same. */\n\t\tif (rev.pending.nr == 2) {\n\t\t\tstruct object_array_entry *o = rev.pending.objects;\n\t\t\tif (hashcmp(o[0].item->sha1, o[1].item->sha1) == 0)\n\t\t\t\treturn 0;\n\t\t}\n\t\tget_patch_ids(&rev, &ids);\n\t}\n\n\tif (!use_stdout)\n\t\trealstdout = xfdopen(xdup(1), \"w\");\n\n\tif (prepare_revision_walk(&rev))\n\t\tdie(_(\"revision walk setup failed\"));\n\trev.boundary = 1;\n\twhile ((commit = get_revision(&rev)) != NULL) {\n\t\tif (commit->object.flags & BOUNDARY) {\n\t\t\tboundary_count++;\n\t\t\torigin = (boundary_count == 1) ? commit : NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ignore_if_in_upstream &&\n\t\t\t\thas_commit_patch_id(commit, &ids))\n\t\t\tcontinue;\n\n\t\tnr++;\n\t\tlist = xrealloc(list, nr * sizeof(list[0]));\n\t\tlist[nr - 1] = commit;\n\t}\n\tif (nr == 0)\n\t\t/* nothing to do */\n\t\treturn 0;\n\ttotal = nr;\n\tif (!keep_subject && auto_number && total > 1)\n\t\tnumbered = 1;\n\tif (numbered)\n\t\trev.total = total + start_number - 1;\n\tif (cover_letter == -1) {\n\t\tif (config_cover_letter == COVER_AUTO)\n\t\t\tcover_letter = (total > 1);\n\t\telse\n\t\t\tcover_letter = (config_cover_letter == COVER_ON);\n\t}\n\n\tif (in_reply_to || thread || cover_letter)\n\t\trev.ref_message_ids = xcalloc(1, sizeof(struct string_list));\n\tif (in_reply_to) {\n\t\tconst char *msgid = clean_message_id(in_reply_to);\n\t\tstring_list_append(rev.ref_message_ids, msgid);\n\t}\n\trev.numbered_files = just_numbers;\n\trev.patch_suffix = fmt_patch_suffix;\n\tif (cover_letter) {\n\t\tif (thread)\n\t\t\tgen_message_id(&rev, \"cover\");\n\t\tmake_cover_letter(&rev, use_stdout,\n\t\t\t\t  origin, nr, list, branch_name, quiet);\n\t\ttotal++;\n\t\tstart_number--;\n\t}\n\trev.add_signoff = do_signoff;\n\twhile (0 <= --nr) {\n\t\tint shown;\n\t\tcommit = list[nr];\n\t\trev.nr = total - nr + (start_number - 1);\n\t\t/* Make the second and subsequent mails replies to the first */\n\t\tif (thread) {\n\t\t\t/* Have we already had a message ID? */\n\t\t\tif (rev.message_id) {\n\t\t\t\t/*\n\t\t\t\t * For deep threading: make every mail\n\t\t\t\t * a reply to the previous one, no\n\t\t\t\t * matter what other options are set.\n\t\t\t\t *\n\t\t\t\t * For shallow threading:\n\t\t\t\t *\n\t\t\t\t * Without --cover-letter and\n\t\t\t\t * --in-reply-to, make every mail a\n\t\t\t\t * reply to the one before.\n\t\t\t\t *\n\t\t\t\t * With --in-reply-to but no\n\t\t\t\t * --cover-letter, make every mail a\n\t\t\t\t * reply to the <reply-to>.\n\t\t\t\t *\n\t\t\t\t * With --cover-letter, make every\n\t\t\t\t * mail but the cover letter a reply\n\t\t\t\t * to the cover letter.  The cover\n\t\t\t\t * letter is a reply to the\n\t\t\t\t * --in-reply-to, if specified.\n\t\t\t\t */\n\t\t\t\tif (thread == THREAD_SHALLOW\n\t\t\t\t    && rev.ref_message_ids->nr > 0\n\t\t\t\t    && (!cover_letter || rev.nr > 1))\n\t\t\t\t\tfree(rev.message_id);\n\t\t\t\telse\n\t\t\t\t\tstring_list_append(rev.ref_message_ids,\n\t\t\t\t\t\t\t   rev.message_id);\n\t\t\t}\n\t\t\tgen_message_id(&rev, sha1_to_hex(commit->object.sha1));\n\t\t}\n\n\t\tif (!use_stdout &&\n\t\t    reopen_stdout(rev.numbered_files ? NULL : commit, NULL, &rev, quiet))\n\t\t\tdie(_(\"Failed to create output files\"));\n\t\tshown = log_tree_commit(&rev, commit);\n\t\tfree(commit->buffer);\n\t\tcommit->buffer = NULL;\n\n\t\t/* We put one extra blank line between formatted\n\t\t * patches and this flag is used by log-tree code\n\t\t * to see if it needs to emit a LF before showing\n\t\t * the log; when using one file per patch, we do\n\t\t * not want the extra blank line.\n\t\t */\n\t\tif (!use_stdout)\n\t\t\trev.shown_one = 0;\n\t\tif (shown) {\n\t\t\tif (rev.mime_boundary)\n\t\t\t\tprintf(\"\\n--%s%s--\\n\\n\\n\",\n\t\t\t\t       mime_boundary_leader,\n\t\t\t\t       rev.mime_boundary);\n\t\t\telse\n\t\t\t\tprint_signature();\n\t\t}\n\t\tif (!use_stdout)\n\t\t\tfclose(stdout);\n\t}\n\tfree(list);\n\tfree(branch_name);\n\tstring_list_clear(&extra_to, 0);\n\tstring_list_clear(&extra_cc, 0);\n\tstring_list_clear(&extra_hdr, 0);\n\tif (ignore_if_in_upstream)\n\t\tfree_patch_ids(&ids);\n\treturn 0;\n}\n\nstatic int add_pending_commit(const char *arg, struct rev_info *revs, int flags)\n{\n\tunsigned char sha1[20];\n\tif (get_sha1(arg, sha1) == 0) {\n\t\tstruct commit *commit = lookup_commit_reference(sha1);\n\t\tif (commit) {\n\t\t\tcommit->object.flags |= flags;\n\t\t\tadd_pending_object(revs, &commit->object, arg);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -1;\n}\n\nstatic const char * const cherry_usage[] = {\n\tN_(\"git cherry [-v] [<upstream> [<head> [<limit>]]]\"),\n\tNULL\n};\n\nstatic void print_commit(char sign, struct commit *commit, int verbose,\n\t\t\t int abbrev)\n{\n\tif (!verbose) {\n\t\tprintf(\"%c %s\\n\", sign,\n\t\t       find_unique_abbrev(commit->object.sha1, abbrev));\n\t} else {\n\t\tstruct strbuf buf = STRBUF_INIT;\n\t\tpp_commit_easy(CMIT_FMT_ONELINE, commit, &buf);\n\t\tprintf(\"%c %s %s\\n\", sign,\n\t\t       find_unique_abbrev(commit->object.sha1, abbrev),\n\t\t       buf.buf);\n\t\tstrbuf_release(&buf);\n\t}\n}\n\nint cmd_cherry(int argc, const char **argv, const char *prefix)\n{\n\tstruct rev_info revs;\n\tstruct patch_ids ids;\n\tstruct commit *commit;\n\tstruct commit_list *list = NULL;\n\tstruct branch *current_branch;\n\tconst char *upstream;\n\tconst char *head = \"HEAD\";\n\tconst char *limit = NULL;\n\tint verbose = 0, abbrev = 0;\n\n\tstruct option options[] = {\n\t\tOPT__ABBREV(&abbrev),\n\t\tOPT__VERBOSE(&verbose, N_(\"be verbose\")),\n\t\tOPT_END()\n\t};\n\n\targc = parse_options(argc, argv, prefix, options, cherry_usage, 0);\n\n\tswitch (argc) {\n\tcase 3:\n\t\tlimit = argv[2];\n\t\t/* FALLTHROUGH */\n\tcase 2:\n\t\thead = argv[1];\n\t\t/* FALLTHROUGH */\n\tcase 1:\n\t\tupstream = argv[0];\n\t\tbreak;\n\tdefault:\n\t\tcurrent_branch = branch_get(NULL);\n\t\tif (!current_branch || !current_branch->merge\n\t\t\t\t\t|| !current_branch->merge[0]\n\t\t\t\t\t|| !current_branch->merge[0]->dst) {\n\t\t\tfprintf(stderr, _(\"Could not find a tracked\"\n\t\t\t\t\t\" remote branch, please\"\n\t\t\t\t\t\" specify <upstream> manually.\\n\"));\n\t\t\tusage_with_options(cherry_usage, options);\n\t\t}\n\n\t\tupstream = current_branch->merge[0]->dst;\n\t}\n\n\tinit_revisions(&revs, prefix);\n\trevs.max_parents = 1;\n\n\tif (add_pending_commit(head, &revs, 0))\n\t\tdie(_(\"Unknown commit %s\"), head);\n\tif (add_pending_commit(upstream, &revs, UNINTERESTING))\n\t\tdie(_(\"Unknown commit %s\"), upstream);\n\n\t/* Don't say anything if head and upstream are the same. */\n\tif (revs.pending.nr == 2) {\n\t\tstruct object_array_entry *o = revs.pending.objects;\n\t\tif (hashcmp(o[0].item->sha1, o[1].item->sha1) == 0)\n\t\t\treturn 0;\n\t}\n\n\tget_patch_ids(&revs, &ids);\n\n\tif (limit && add_pending_commit(limit, &revs, UNINTERESTING))\n\t\tdie(_(\"Unknown commit %s\"), limit);\n\n\t/* reverse the list of commits */\n\tif (prepare_revision_walk(&revs))\n\t\tdie(_(\"revision walk setup failed\"));\n\twhile ((commit = get_revision(&revs)) != NULL) {\n\t\tcommit_list_insert(commit, &list);\n\t}\n\n\twhile (list) {\n\t\tchar sign = '+';\n\n\t\tcommit = list->item;\n\t\tif (has_commit_patch_id(commit, &ids))\n\t\t\tsign = '-';\n\t\tprint_commit(sign, commit, verbose, abbrev);\n\t\tlist = list->next;\n\t}\n\n\tfree_patch_ids(&ids);\n\treturn 0;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00a4ce602cc3f6784bb51784766c9ef2f655f0e9",
  "sha1_ok": true,
  "size": 43804
}
