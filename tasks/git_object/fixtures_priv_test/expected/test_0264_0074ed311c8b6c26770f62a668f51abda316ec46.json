{
  "content": {
    "base64": "LyoKICogQmxhbWUKICoKICogQ29weXJpZ2h0IChjKSAyMDA2LCAyMDE0IGJ5IGl0cyBhdXRob3JzCiAqIFNlZSBDT1BZSU5HIGZvciBsaWNlbnNpbmcgY29uZGl0aW9ucwogKi8KCiNpbmNsdWRlICJjYWNoZS5oIgojaW5jbHVkZSAiY29uZmlnLmgiCiNpbmNsdWRlICJjb2xvci5oIgojaW5jbHVkZSAiYnVpbHRpbi5oIgojaW5jbHVkZSAicmVwb3NpdG9yeS5oIgojaW5jbHVkZSAiY29tbWl0LmgiCiNpbmNsdWRlICJkaWZmLmgiCiNpbmNsdWRlICJyZXZpc2lvbi5oIgojaW5jbHVkZSAicXVvdGUuaCIKI2luY2x1ZGUgInN0cmluZy1saXN0LmgiCiNpbmNsdWRlICJtYWlsbWFwLmgiCiNpbmNsdWRlICJwYXJzZS1vcHRpb25zLmgiCiNpbmNsdWRlICJwcmlvLXF1ZXVlLmgiCiNpbmNsdWRlICJ1dGY4LmgiCiNpbmNsdWRlICJ1c2VyZGlmZi5oIgojaW5jbHVkZSAibGluZS1yYW5nZS5oIgojaW5jbHVkZSAibGluZS1sb2cuaCIKI2luY2x1ZGUgImRpci5oIgojaW5jbHVkZSAicHJvZ3Jlc3MuaCIKI2luY2x1ZGUgIm9iamVjdC1zdG9yZS5oIgojaW5jbHVkZSAiYmxhbWUuaCIKI2luY2x1ZGUgInN0cmluZy1saXN0LmgiCgpzdGF0aWMgY2hhciBibGFtZV91c2FnZVtdID0gTl8oImdpdCBibGFtZSBbPG9wdGlvbnM+XSBbPHJldi1vcHRzPl0gWzxyZXY+XSBbLS1dIDxmaWxlPiIpOwoKc3RhdGljIGNvbnN0IGNoYXIgKmJsYW1lX29wdF91c2FnZVtdID0gewoJYmxhbWVfdXNhZ2UsCgkiIiwKCU5fKCI8cmV2LW9wdHM+IGFyZSBkb2N1bWVudGVkIGluIGdpdC1yZXYtbGlzdCgxKSIpLAoJTlVMTAp9OwoKc3RhdGljIGludCBsb25nZXN0X2ZpbGU7CnN0YXRpYyBpbnQgbG9uZ2VzdF9hdXRob3I7CnN0YXRpYyBpbnQgbWF4X29yaWdfZGlnaXRzOwpzdGF0aWMgaW50IG1heF9kaWdpdHM7CnN0YXRpYyBpbnQgbWF4X3Njb3JlX2RpZ2l0czsKc3RhdGljIGludCBzaG93X3Jvb3Q7CnN0YXRpYyBpbnQgcmV2ZXJzZTsKc3RhdGljIGludCBibGFua19ib3VuZGFyeTsKc3RhdGljIGludCBpbmNyZW1lbnRhbDsKc3RhdGljIGludCB4ZGxfb3B0czsKc3RhdGljIGludCBhYmJyZXYgPSAtMTsKc3RhdGljIGludCBub193aG9sZV9maWxlX3JlbmFtZTsKc3RhdGljIGludCBzaG93X3Byb2dyZXNzOwpzdGF0aWMgY2hhciByZXBlYXRlZF9tZXRhX2NvbG9yW0NPTE9SX01BWExFTl07CnN0YXRpYyBpbnQgY29sb3JpbmdfbW9kZTsKCnN0YXRpYyBzdHJ1Y3QgZGF0ZV9tb2RlIGJsYW1lX2RhdGVfbW9kZSA9IHsgREFURV9JU084NjAxIH07CnN0YXRpYyBzaXplX3QgYmxhbWVfZGF0ZV93aWR0aDsKCnN0YXRpYyBzdHJ1Y3Qgc3RyaW5nX2xpc3QgbWFpbG1hcCA9IFNUUklOR19MSVNUX0lOSVRfTk9EVVA7CgojaWZuZGVmIERFQlVHCiNkZWZpbmUgREVCVUcgMAojZW5kaWYKCnN0YXRpYyB1bnNpZ25lZCBibGFtZV9tb3ZlX3Njb3JlOwpzdGF0aWMgdW5zaWduZWQgYmxhbWVfY29weV9zY29yZTsKCi8qIFJlbWVtYmVyIHRvIHVwZGF0ZSBvYmplY3QgZmxhZyBhbGxvY2F0aW9uIGluIG9iamVjdC5oICovCiNkZWZpbmUgTUVUQUlORk9fU0hPV04JCSgxdTw8MTIpCiNkZWZpbmUgTU9SRV9USEFOX09ORV9QQVRICSgxdTw8MTMpCgpzdHJ1Y3QgcHJvZ3Jlc3NfaW5mbyB7CglzdHJ1Y3QgcHJvZ3Jlc3MgKnByb2dyZXNzOwoJaW50IGJsYW1lZF9saW5lczsKfTsKCnN0YXRpYyBjb25zdCBjaGFyICpudGhfbGluZV9jYih2b2lkICpkYXRhLCBsb25nIGxubykKewoJcmV0dXJuIGJsYW1lX250aF9saW5lKChzdHJ1Y3QgYmxhbWVfc2NvcmVib2FyZCAqKWRhdGEsIGxubyk7Cn0KCi8qCiAqIEluZm9ybWF0aW9uIG9uIGNvbW1pdHMsIHVzZWQgZm9yIG91dHB1dC4KICovCnN0cnVjdCBjb21taXRfaW5mbyB7CglzdHJ1Y3Qgc3RyYnVmIGF1dGhvcjsKCXN0cnVjdCBzdHJidWYgYXV0aG9yX21haWw7Cgl0aW1lc3RhbXBfdCBhdXRob3JfdGltZTsKCXN0cnVjdCBzdHJidWYgYXV0aG9yX3R6OwoKCS8qIGZpbGxlZCBvbmx5IHdoZW4gYXNrZWQgZm9yIGRldGFpbHMgKi8KCXN0cnVjdCBzdHJidWYgY29tbWl0dGVyOwoJc3RydWN0IHN0cmJ1ZiBjb21taXR0ZXJfbWFpbDsKCXRpbWVzdGFtcF90IGNvbW1pdHRlcl90aW1lOwoJc3RydWN0IHN0cmJ1ZiBjb21taXR0ZXJfdHo7CgoJc3RydWN0IHN0cmJ1ZiBzdW1tYXJ5Owp9OwoKLyoKICogUGFyc2UgYXV0aG9yL2NvbW1pdHRlciBsaW5lIGluIHRoZSBjb21taXQgb2JqZWN0IGJ1ZmZlcgogKi8Kc3RhdGljIHZvaWQgZ2V0X2FjX2xpbmUoY29uc3QgY2hhciAqaW5idWYsIGNvbnN0IGNoYXIgKndoYXQsCglzdHJ1Y3Qgc3RyYnVmICpuYW1lLCBzdHJ1Y3Qgc3RyYnVmICptYWlsLAoJdGltZXN0YW1wX3QgKnRpbWUsIHN0cnVjdCBzdHJidWYgKnR6KQp7CglzdHJ1Y3QgaWRlbnRfc3BsaXQgaWRlbnQ7CglzaXplX3QgbGVuLCBtYWlsbGVuLCBuYW1lbGVuOwoJY2hhciAqdG1wLCAqZW5kcDsKCWNvbnN0IGNoYXIgKm5hbWVidWYsICptYWlsYnVmOwoKCXRtcCA9IHN0cnN0cihpbmJ1Ziwgd2hhdCk7CglpZiAoIXRtcCkKCQlnb3RvIGVycm9yX291dDsKCXRtcCArPSBzdHJsZW4od2hhdCk7CgllbmRwID0gc3RyY2hyKHRtcCwgJ1xuJyk7CglpZiAoIWVuZHApCgkJbGVuID0gc3RybGVuKHRtcCk7CgllbHNlCgkJbGVuID0gZW5kcCAtIHRtcDsKCglpZiAoc3BsaXRfaWRlbnRfbGluZSgmaWRlbnQsIHRtcCwgbGVuKSkgewoJZXJyb3Jfb3V0OgoJCS8qIFVnaCAqLwoJCXRtcCA9ICIodW5rbm93bikiOwoJCXN0cmJ1Zl9hZGRzdHIobmFtZSwgdG1wKTsKCQlzdHJidWZfYWRkc3RyKG1haWwsIHRtcCk7CgkJc3RyYnVmX2FkZHN0cih0eiwgdG1wKTsKCQkqdGltZSA9IDA7CgkJcmV0dXJuOwoJfQoKCW5hbWVsZW4gPSBpZGVudC5uYW1lX2VuZCAtIGlkZW50Lm5hbWVfYmVnaW47CgluYW1lYnVmID0gaWRlbnQubmFtZV9iZWdpbjsKCgltYWlsbGVuID0gaWRlbnQubWFpbF9lbmQgLSBpZGVudC5tYWlsX2JlZ2luOwoJbWFpbGJ1ZiA9IGlkZW50Lm1haWxfYmVnaW47CgoJaWYgKGlkZW50LmRhdGVfYmVnaW4gJiYgaWRlbnQuZGF0ZV9lbmQpCgkJKnRpbWUgPSBzdHJ0b3VsKGlkZW50LmRhdGVfYmVnaW4sIE5VTEwsIDEwKTsKCWVsc2UKCQkqdGltZSA9IDA7CgoJaWYgKGlkZW50LnR6X2JlZ2luICYmIGlkZW50LnR6X2VuZCkKCQlzdHJidWZfYWRkKHR6LCBpZGVudC50el9iZWdpbiwgaWRlbnQudHpfZW5kIC0gaWRlbnQudHpfYmVnaW4pOwoJZWxzZQoJCXN0cmJ1Zl9hZGRzdHIodHosICIodW5rbm93bikiKTsKCgkvKgoJICogTm93LCBjb252ZXJ0IGJvdGggbmFtZSBhbmQgZS1tYWlsIHVzaW5nIG1haWxtYXAKCSAqLwoJbWFwX3VzZXIoJm1haWxtYXAsICZtYWlsYnVmLCAmbWFpbGxlbiwKCQkgJm5hbWVidWYsICZuYW1lbGVuKTsKCglzdHJidWZfYWRkZihtYWlsLCAiPCUuKnM+IiwgKGludCltYWlsbGVuLCBtYWlsYnVmKTsKCXN0cmJ1Zl9hZGQobmFtZSwgbmFtZWJ1ZiwgbmFtZWxlbik7Cn0KCnN0YXRpYyB2b2lkIGNvbW1pdF9pbmZvX2luaXQoc3RydWN0IGNvbW1pdF9pbmZvICpjaSkKewoKCXN0cmJ1Zl9pbml0KCZjaS0+YXV0aG9yLCAwKTsKCXN0cmJ1Zl9pbml0KCZjaS0+YXV0aG9yX21haWwsIDApOwoJc3RyYnVmX2luaXQoJmNpLT5hdXRob3JfdHosIDApOwoJc3RyYnVmX2luaXQoJmNpLT5jb21taXR0ZXIsIDApOwoJc3RyYnVmX2luaXQoJmNpLT5jb21taXR0ZXJfbWFpbCwgMCk7CglzdHJidWZfaW5pdCgmY2ktPmNvbW1pdHRlcl90eiwgMCk7CglzdHJidWZfaW5pdCgmY2ktPnN1bW1hcnksIDApOwp9CgpzdGF0aWMgdm9pZCBjb21taXRfaW5mb19kZXN0cm95KHN0cnVjdCBjb21taXRfaW5mbyAqY2kpCnsKCglzdHJidWZfcmVsZWFzZSgmY2ktPmF1dGhvcik7CglzdHJidWZfcmVsZWFzZSgmY2ktPmF1dGhvcl9tYWlsKTsKCXN0cmJ1Zl9yZWxlYXNlKCZjaS0+YXV0aG9yX3R6KTsKCXN0cmJ1Zl9yZWxlYXNlKCZjaS0+Y29tbWl0dGVyKTsKCXN0cmJ1Zl9yZWxlYXNlKCZjaS0+Y29tbWl0dGVyX21haWwpOwoJc3RyYnVmX3JlbGVhc2UoJmNpLT5jb21taXR0ZXJfdHopOwoJc3RyYnVmX3JlbGVhc2UoJmNpLT5zdW1tYXJ5KTsKfQoKc3RhdGljIHZvaWQgZ2V0X2NvbW1pdF9pbmZvKHN0cnVjdCBjb21taXQgKmNvbW1pdCwKCQkJICAgIHN0cnVjdCBjb21taXRfaW5mbyAqcmV0LAoJCQkgICAgaW50IGRldGFpbGVkKQp7CglpbnQgbGVuOwoJY29uc3QgY2hhciAqc3ViamVjdCwgKmVuY29kaW5nOwoJY29uc3QgY2hhciAqbWVzc2FnZTsKCgljb21taXRfaW5mb19pbml0KHJldCk7CgoJZW5jb2RpbmcgPSBnZXRfbG9nX291dHB1dF9lbmNvZGluZygpOwoJbWVzc2FnZSA9IGxvZ21zZ19yZWVuY29kZShjb21taXQsIE5VTEwsIGVuY29kaW5nKTsKCWdldF9hY19saW5lKG1lc3NhZ2UsICJcbmF1dGhvciAiLAoJCSAgICAmcmV0LT5hdXRob3IsICZyZXQtPmF1dGhvcl9tYWlsLAoJCSAgICAmcmV0LT5hdXRob3JfdGltZSwgJnJldC0+YXV0aG9yX3R6KTsKCglpZiAoIWRldGFpbGVkKSB7CgkJdW51c2VfY29tbWl0X2J1ZmZlcihjb21taXQsIG1lc3NhZ2UpOwoJCXJldHVybjsKCX0KCglnZXRfYWNfbGluZShtZXNzYWdlLCAiXG5jb21taXR0ZXIgIiwKCQkgICAgJnJldC0+Y29tbWl0dGVyLCAmcmV0LT5jb21taXR0ZXJfbWFpbCwKCQkgICAgJnJldC0+Y29tbWl0dGVyX3RpbWUsICZyZXQtPmNvbW1pdHRlcl90eik7CgoJbGVuID0gZmluZF9jb21taXRfc3ViamVjdChtZXNzYWdlLCAmc3ViamVjdCk7CglpZiAobGVuKQoJCXN0cmJ1Zl9hZGQoJnJldC0+c3VtbWFyeSwgc3ViamVjdCwgbGVuKTsKCWVsc2UKCQlzdHJidWZfYWRkZigmcmV0LT5zdW1tYXJ5LCAiKCVzKSIsIG9pZF90b19oZXgoJmNvbW1pdC0+b2JqZWN0Lm9pZCkpOwoKCXVudXNlX2NvbW1pdF9idWZmZXIoY29tbWl0LCBtZXNzYWdlKTsKfQoKLyoKICogV3JpdGUgb3V0IGFueSBzdXNwZWN0IGluZm9ybWF0aW9uIHdoaWNoIGRlcGVuZHMgb24gdGhlIHBhdGguIFRoaXMgbXVzdCBiZQogKiBoYW5kbGVkIHNlcGFyYXRlbHkgZnJvbSBlbWl0X29uZV9zdXNwZWN0X2RldGFpbCgpLCBiZWNhdXNlIGEgZ2l2ZW4gY29tbWl0CiAqIG1heSBoYXZlIGNoYW5nZXMgaW4gbXVsdGlwbGUgcGF0aHMuIFNvIHRoaXMgbmVlZHMgdG8gYXBwZWFyIGVhY2ggdGltZQogKiB3ZSBtZW50aW9uIGEgbmV3IGdyb3VwLgogKgogKiBUbyBhbGxvdyBMRiBhbmQgb3RoZXIgbm9ucG9ydGFibGUgY2hhcmFjdGVycyBpbiBwYXRobmFtZXMsCiAqIHRoZXkgYXJlIGMtc3R5bGUgcXVvdGVkIGFzIG5lZWRlZC4KICovCnN0YXRpYyB2b2lkIHdyaXRlX2ZpbGVuYW1lX2luZm8oc3RydWN0IGJsYW1lX29yaWdpbiAqc3VzcGVjdCkKewoJaWYgKHN1c3BlY3QtPnByZXZpb3VzKSB7CgkJc3RydWN0IGJsYW1lX29yaWdpbiAqcHJldiA9IHN1c3BlY3QtPnByZXZpb3VzOwoJCXByaW50ZigicHJldmlvdXMgJXMgIiwgb2lkX3RvX2hleCgmcHJldi0+Y29tbWl0LT5vYmplY3Qub2lkKSk7CgkJd3JpdGVfbmFtZV9xdW90ZWQocHJldi0+cGF0aCwgc3Rkb3V0LCAnXG4nKTsKCX0KCXByaW50ZigiZmlsZW5hbWUgIik7Cgl3cml0ZV9uYW1lX3F1b3RlZChzdXNwZWN0LT5wYXRoLCBzdGRvdXQsICdcbicpOwp9CgovKgogKiBQb3JjZWxhaW4vSW5jcmVtZW50YWwgZm9ybWF0IHdhbnRzIHRvIHNob3cgYSBsb3Qgb2YgZGV0YWlscyBwZXIKICogY29tbWl0LiAgSW5zdGVhZCBvZiByZXBlYXRpbmcgdGhpcyBldmVyeSBsaW5lLCBlbWl0IGl0IG9ubHkgb25jZSwKICogdGhlIGZpcnN0IHRpbWUgZWFjaCBjb21taXQgYXBwZWFycyBpbiB0aGUgb3V0cHV0ICh1bmxlc3MgdGhlCiAqIHVzZXIgaGFzIHNwZWNpZmljYWxseSBhc2tlZCBmb3IgdXMgdG8gcmVwZWF0KS4KICovCnN0YXRpYyBpbnQgZW1pdF9vbmVfc3VzcGVjdF9kZXRhaWwoc3RydWN0IGJsYW1lX29yaWdpbiAqc3VzcGVjdCwgaW50IHJlcGVhdCkKewoJc3RydWN0IGNvbW1pdF9pbmZvIGNpOwoKCWlmICghcmVwZWF0ICYmIChzdXNwZWN0LT5jb21taXQtPm9iamVjdC5mbGFncyAmIE1FVEFJTkZPX1NIT1dOKSkKCQlyZXR1cm4gMDsKCglzdXNwZWN0LT5jb21taXQtPm9iamVjdC5mbGFncyB8PSBNRVRBSU5GT19TSE9XTjsKCWdldF9jb21taXRfaW5mbyhzdXNwZWN0LT5jb21taXQsICZjaSwgMSk7CglwcmludGYoImF1dGhvciAlc1xuIiwgY2kuYXV0aG9yLmJ1Zik7CglwcmludGYoImF1dGhvci1tYWlsICVzXG4iLCBjaS5hdXRob3JfbWFpbC5idWYpOwoJcHJpbnRmKCJhdXRob3ItdGltZSAlIlBSSXRpbWUiXG4iLCBjaS5hdXRob3JfdGltZSk7CglwcmludGYoImF1dGhvci10eiAlc1xuIiwgY2kuYXV0aG9yX3R6LmJ1Zik7CglwcmludGYoImNvbW1pdHRlciAlc1xuIiwgY2kuY29tbWl0dGVyLmJ1Zik7CglwcmludGYoImNvbW1pdHRlci1tYWlsICVzXG4iLCBjaS5jb21taXR0ZXJfbWFpbC5idWYpOwoJcHJpbnRmKCJjb21taXR0ZXItdGltZSAlIlBSSXRpbWUiXG4iLCBjaS5jb21taXR0ZXJfdGltZSk7CglwcmludGYoImNvbW1pdHRlci10eiAlc1xuIiwgY2kuY29tbWl0dGVyX3R6LmJ1Zik7CglwcmludGYoInN1bW1hcnkgJXNcbiIsIGNpLnN1bW1hcnkuYnVmKTsKCWlmIChzdXNwZWN0LT5jb21taXQtPm9iamVjdC5mbGFncyAmIFVOSU5URVJFU1RJTkcpCgkJcHJpbnRmKCJib3VuZGFyeVxuIik7CgoJY29tbWl0X2luZm9fZGVzdHJveSgmY2kpOwoKCXJldHVybiAxOwp9CgovKgogKiBUaGUgYmxhbWVfZW50cnkgaXMgZm91bmQgdG8gYmUgZ3VpbHR5IGZvciB0aGUgcmFuZ2UuCiAqIFNob3cgaXQgaW4gaW5jcmVtZW50YWwgb3V0cHV0LgogKi8Kc3RhdGljIHZvaWQgZm91bmRfZ3VpbHR5X2VudHJ5KHN0cnVjdCBibGFtZV9lbnRyeSAqZW50LCB2b2lkICpkYXRhKQp7CglzdHJ1Y3QgcHJvZ3Jlc3NfaW5mbyAqcGkgPSAoc3RydWN0IHByb2dyZXNzX2luZm8gKilkYXRhOwoKCWlmIChpbmNyZW1lbnRhbCkgewoJCXN0cnVjdCBibGFtZV9vcmlnaW4gKnN1c3BlY3QgPSBlbnQtPnN1c3BlY3Q7CgoJCXByaW50ZigiJXMgJWQgJWQgJWRcbiIsCgkJICAgICAgIG9pZF90b19oZXgoJnN1c3BlY3QtPmNvbW1pdC0+b2JqZWN0Lm9pZCksCgkJICAgICAgIGVudC0+c19sbm8gKyAxLCBlbnQtPmxubyArIDEsIGVudC0+bnVtX2xpbmVzKTsKCQllbWl0X29uZV9zdXNwZWN0X2RldGFpbChzdXNwZWN0LCAwKTsKCQl3cml0ZV9maWxlbmFtZV9pbmZvKHN1c3BlY3QpOwoJCW1heWJlX2ZsdXNoX29yX2RpZShzdGRvdXQsICJzdGRvdXQiKTsKCX0KCXBpLT5ibGFtZWRfbGluZXMgKz0gZW50LT5udW1fbGluZXM7CglkaXNwbGF5X3Byb2dyZXNzKHBpLT5wcm9ncmVzcywgcGktPmJsYW1lZF9saW5lcyk7Cn0KCnN0YXRpYyBjb25zdCBjaGFyICpmb3JtYXRfdGltZSh0aW1lc3RhbXBfdCB0aW1lLCBjb25zdCBjaGFyICp0el9zdHIsCgkJCSAgICAgICBpbnQgc2hvd19yYXdfdGltZSkKewoJc3RhdGljIHN0cnVjdCBzdHJidWYgdGltZV9idWYgPSBTVFJCVUZfSU5JVDsKCglzdHJidWZfcmVzZXQoJnRpbWVfYnVmKTsKCWlmIChzaG93X3Jhd190aW1lKSB7CgkJc3RyYnVmX2FkZGYoJnRpbWVfYnVmLCAiJSJQUkl0aW1lIiAlcyIsIHRpbWUsIHR6X3N0cik7Cgl9CgllbHNlIHsKCQljb25zdCBjaGFyICp0aW1lX3N0cjsKCQlzaXplX3QgdGltZV93aWR0aDsKCQlpbnQgdHo7CgkJdHogPSBhdG9pKHR6X3N0cik7CgkJdGltZV9zdHIgPSBzaG93X2RhdGUodGltZSwgdHosICZibGFtZV9kYXRlX21vZGUpOwoJCXN0cmJ1Zl9hZGRzdHIoJnRpbWVfYnVmLCB0aW1lX3N0cik7CgkJLyoKCQkgKiBBZGQgc3BhY2UgcGFkZGluZ3MgdG8gdGltZV9idWYgdG8gZGlzcGxheSBhIGZpeGVkIHdpZHRoCgkJICogc3RyaW5nLCBhbmQgdXNlIHRpbWVfd2lkdGggZm9yIGRpc3BsYXkgd2lkdGggY2FsaWJyYXRpb24uCgkJICovCgkJZm9yICh0aW1lX3dpZHRoID0gdXRmOF9zdHJ3aWR0aCh0aW1lX3N0cik7CgkJICAgICB0aW1lX3dpZHRoIDwgYmxhbWVfZGF0ZV93aWR0aDsKCQkgICAgIHRpbWVfd2lkdGgrKykKCQkJc3RyYnVmX2FkZGNoKCZ0aW1lX2J1ZiwgJyAnKTsKCX0KCXJldHVybiB0aW1lX2J1Zi5idWY7Cn0KCiNkZWZpbmUgT1VUUFVUX0FOTk9UQVRFX0NPTVBBVAkwMDEKI2RlZmluZSBPVVRQVVRfTE9OR19PQkpFQ1RfTkFNRQkwMDIKI2RlZmluZSBPVVRQVVRfUkFXX1RJTUVTVEFNUAkwMDQKI2RlZmluZSBPVVRQVVRfUE9SQ0VMQUlOCTAxMAojZGVmaW5lIE9VVFBVVF9TSE9XX05BTUUJMDIwCiNkZWZpbmUgT1VUUFVUX1NIT1dfTlVNQkVSCTA0MAojZGVmaW5lIE9VVFBVVF9TSE9XX1NDT1JFCTAxMDAKI2RlZmluZSBPVVRQVVRfTk9fQVVUSE9SCTAyMDAKI2RlZmluZSBPVVRQVVRfU0hPV19FTUFJTAkwNDAwCiNkZWZpbmUgT1VUUFVUX0xJTkVfUE9SQ0VMQUlOCTAxMDAwCiNkZWZpbmUgT1VUUFVUX0NPTE9SX0xJTkUJMDIwMDAKI2RlZmluZSBPVVRQVVRfU0hPV19BR0VfV0lUSF9DT0xPUgkwNDAwMAoKc3RhdGljIHZvaWQgZW1pdF9wb3JjZWxhaW5fZGV0YWlscyhzdHJ1Y3QgYmxhbWVfb3JpZ2luICpzdXNwZWN0LCBpbnQgcmVwZWF0KQp7CglpZiAoZW1pdF9vbmVfc3VzcGVjdF9kZXRhaWwoc3VzcGVjdCwgcmVwZWF0KSB8fAoJICAgIChzdXNwZWN0LT5jb21taXQtPm9iamVjdC5mbGFncyAmIE1PUkVfVEhBTl9PTkVfUEFUSCkpCgkJd3JpdGVfZmlsZW5hbWVfaW5mbyhzdXNwZWN0KTsKfQoKc3RhdGljIHZvaWQgZW1pdF9wb3JjZWxhaW4oc3RydWN0IGJsYW1lX3Njb3JlYm9hcmQgKnNiLCBzdHJ1Y3QgYmxhbWVfZW50cnkgKmVudCwKCQkJICAgaW50IG9wdCkKewoJaW50IHJlcGVhdCA9IG9wdCAmIE9VVFBVVF9MSU5FX1BPUkNFTEFJTjsKCWludCBjbnQ7Cgljb25zdCBjaGFyICpjcDsKCXN0cnVjdCBibGFtZV9vcmlnaW4gKnN1c3BlY3QgPSBlbnQtPnN1c3BlY3Q7CgljaGFyIGhleFtHSVRfTUFYX0hFWFNaICsgMV07CgoJb2lkX3RvX2hleF9yKGhleCwgJnN1c3BlY3QtPmNvbW1pdC0+b2JqZWN0Lm9pZCk7CglwcmludGYoIiVzICVkICVkICVkXG4iLAoJICAgICAgIGhleCwKCSAgICAgICBlbnQtPnNfbG5vICsgMSwKCSAgICAgICBlbnQtPmxubyArIDEsCgkgICAgICAgZW50LT5udW1fbGluZXMpOwoJZW1pdF9wb3JjZWxhaW5fZGV0YWlscyhzdXNwZWN0LCByZXBlYXQpOwoKCWNwID0gYmxhbWVfbnRoX2xpbmUoc2IsIGVudC0+bG5vKTsKCWZvciAoY250ID0gMDsgY250IDwgZW50LT5udW1fbGluZXM7IGNudCsrKSB7CgkJY2hhciBjaDsKCQlpZiAoY250KSB7CgkJCXByaW50ZigiJXMgJWQgJWRcbiIsIGhleCwKCQkJICAgICAgIGVudC0+c19sbm8gKyAxICsgY250LAoJCQkgICAgICAgZW50LT5sbm8gKyAxICsgY250KTsKCQkJaWYgKHJlcGVhdCkKCQkJCWVtaXRfcG9yY2VsYWluX2RldGFpbHMoc3VzcGVjdCwgMSk7CgkJfQoJCXB1dGNoYXIoJ1x0Jyk7CgkJZG8gewoJCQljaCA9ICpjcCsrOwoJCQlwdXRjaGFyKGNoKTsKCQl9IHdoaWxlIChjaCAhPSAnXG4nICYmCgkJCSBjcCA8IHNiLT5maW5hbF9idWYgKyBzYi0+ZmluYWxfYnVmX3NpemUpOwoJfQoKCWlmIChzYi0+ZmluYWxfYnVmX3NpemUgJiYgY3BbLTFdICE9ICdcbicpCgkJcHV0Y2hhcignXG4nKTsKfQoKc3RhdGljIHN0cnVjdCBjb2xvcl9maWVsZCB7Cgl0aW1lc3RhbXBfdCBob3A7CgljaGFyIGNvbFtDT0xPUl9NQVhMRU5dOwp9ICpjb2xvcmZpZWxkOwpzdGF0aWMgaW50IGNvbG9yZmllbGRfbnIsIGNvbG9yZmllbGRfYWxsb2M7CgpzdGF0aWMgdm9pZCBwYXJzZV9jb2xvcl9maWVsZHMoY29uc3QgY2hhciAqcykKewoJc3RydWN0IHN0cmluZ19saXN0IGwgPSBTVFJJTkdfTElTVF9JTklUX0RVUDsKCXN0cnVjdCBzdHJpbmdfbGlzdF9pdGVtICppdGVtOwoJZW51bSB7IEVYUEVDVF9EQVRFLCBFWFBFQ1RfQ09MT1IgfSBuZXh0ID0gRVhQRUNUX0NPTE9SOwoKCWNvbG9yZmllbGRfbnIgPSAwOwoKCS8qIElkZWFsbHkgdGhpcyB3b3VsZCBiZSBzdHJpcHBlZCBhbmQgc3BsaXQgYXQgdGhlIHNhbWUgdGltZT8gKi8KCXN0cmluZ19saXN0X3NwbGl0KCZsLCBzLCAnLCcsIC0xKTsKCUFMTE9DX0dST1coY29sb3JmaWVsZCwgY29sb3JmaWVsZF9uciArIDEsIGNvbG9yZmllbGRfYWxsb2MpOwoKCWZvcl9lYWNoX3N0cmluZ19saXN0X2l0ZW0oaXRlbSwgJmwpIHsKCQlzd2l0Y2ggKG5leHQpIHsKCQljYXNlIEVYUEVDVF9EQVRFOgoJCQljb2xvcmZpZWxkW2NvbG9yZmllbGRfbnJdLmhvcCA9IGFwcHJveGlkYXRlKGl0ZW0tPnN0cmluZyk7CgkJCW5leHQgPSBFWFBFQ1RfQ09MT1I7CgkJCWNvbG9yZmllbGRfbnIrKzsKCQkJQUxMT0NfR1JPVyhjb2xvcmZpZWxkLCBjb2xvcmZpZWxkX25yICsgMSwgY29sb3JmaWVsZF9hbGxvYyk7CgkJCWJyZWFrOwoJCWNhc2UgRVhQRUNUX0NPTE9SOgoJCQlpZiAoY29sb3JfcGFyc2UoaXRlbS0+c3RyaW5nLCBjb2xvcmZpZWxkW2NvbG9yZmllbGRfbnJdLmNvbCkpCgkJCQlkaWUoXygiZXhwZWN0aW5nIGEgY29sb3I6ICVzIiksIGl0ZW0tPnN0cmluZyk7CgkJCW5leHQgPSBFWFBFQ1RfREFURTsKCQkJYnJlYWs7CgkJfQoJfQoKCWlmIChuZXh0ID09IEVYUEVDVF9DT0xPUikKCQlkaWUoXygibXVzdCBlbmQgd2l0aCBhIGNvbG9yIikpOwoKCWNvbG9yZmllbGRbY29sb3JmaWVsZF9ucl0uaG9wID0gVElNRV9NQVg7CglzdHJpbmdfbGlzdF9jbGVhcigmbCwgMCk7Cn0KCnN0YXRpYyB2b2lkIHNldHVwX2RlZmF1bHRfY29sb3JfYnlfYWdlKHZvaWQpCnsKCXBhcnNlX2NvbG9yX2ZpZWxkcygiYmx1ZSwxMiBtb250aCBhZ28sd2hpdGUsMSBtb250aCBhZ28scmVkIik7Cn0KCnN0YXRpYyB2b2lkIGRldGVybWluZV9saW5lX2hlYXQoc3RydWN0IGJsYW1lX2VudHJ5ICplbnQsIGNvbnN0IGNoYXIgKipkZXN0X2NvbG9yKQp7CglpbnQgaSA9IDA7CglzdHJ1Y3QgY29tbWl0X2luZm8gY2k7CglnZXRfY29tbWl0X2luZm8oZW50LT5zdXNwZWN0LT5jb21taXQsICZjaSwgMSk7CgoJd2hpbGUgKGkgPCBjb2xvcmZpZWxkX25yICYmIGNpLmF1dGhvcl90aW1lID4gY29sb3JmaWVsZFtpXS5ob3ApCgkJaSsrOwoKCSpkZXN0X2NvbG9yID0gY29sb3JmaWVsZFtpXS5jb2w7Cn0KCnN0YXRpYyB2b2lkIGVtaXRfb3RoZXIoc3RydWN0IGJsYW1lX3Njb3JlYm9hcmQgKnNiLCBzdHJ1Y3QgYmxhbWVfZW50cnkgKmVudCwgaW50IG9wdCkKewoJaW50IGNudDsKCWNvbnN0IGNoYXIgKmNwOwoJc3RydWN0IGJsYW1lX29yaWdpbiAqc3VzcGVjdCA9IGVudC0+c3VzcGVjdDsKCXN0cnVjdCBjb21taXRfaW5mbyBjaTsKCWNoYXIgaGV4W0dJVF9NQVhfSEVYU1ogKyAxXTsKCWludCBzaG93X3Jhd190aW1lID0gISEob3B0ICYgT1VUUFVUX1JBV19USU1FU1RBTVApOwoJY29uc3QgY2hhciAqZGVmYXVsdF9jb2xvciA9IE5VTEwsICpjb2xvciA9IE5VTEwsICpyZXNldCA9IE5VTEw7CgoJZ2V0X2NvbW1pdF9pbmZvKHN1c3BlY3QtPmNvbW1pdCwgJmNpLCAxKTsKCW9pZF90b19oZXhfcihoZXgsICZzdXNwZWN0LT5jb21taXQtPm9iamVjdC5vaWQpOwoKCWNwID0gYmxhbWVfbnRoX2xpbmUoc2IsIGVudC0+bG5vKTsKCglpZiAob3B0ICYgT1VUUFVUX1NIT1dfQUdFX1dJVEhfQ09MT1IpIHsKCQlkZXRlcm1pbmVfbGluZV9oZWF0KGVudCwgJmRlZmF1bHRfY29sb3IpOwoJCWNvbG9yID0gZGVmYXVsdF9jb2xvcjsKCQlyZXNldCA9IEdJVF9DT0xPUl9SRVNFVDsKCX0KCglmb3IgKGNudCA9IDA7IGNudCA8IGVudC0+bnVtX2xpbmVzOyBjbnQrKykgewoJCWNoYXIgY2g7CgkJaW50IGxlbmd0aCA9IChvcHQgJiBPVVRQVVRfTE9OR19PQkpFQ1RfTkFNRSkgPyBHSVRfU0hBMV9IRVhTWiA6IGFiYnJldjsKCgkJaWYgKG9wdCAmIE9VVFBVVF9DT0xPUl9MSU5FKSB7CgkJCWlmIChjbnQgPiAwKSB7CgkJCQljb2xvciA9IHJlcGVhdGVkX21ldGFfY29sb3I7CgkJCQlyZXNldCA9IEdJVF9DT0xPUl9SRVNFVDsKCQkJfSBlbHNlICB7CgkJCQljb2xvciA9IGRlZmF1bHRfY29sb3IgPyBkZWZhdWx0X2NvbG9yIDogTlVMTDsKCQkJCXJlc2V0ID0gZGVmYXVsdF9jb2xvciA/IEdJVF9DT0xPUl9SRVNFVCA6IE5VTEw7CgkJCX0KCQl9CgkJaWYgKGNvbG9yKQoJCQlmcHV0cyhjb2xvciwgc3Rkb3V0KTsKCgkJaWYgKHN1c3BlY3QtPmNvbW1pdC0+b2JqZWN0LmZsYWdzICYgVU5JTlRFUkVTVElORykgewoJCQlpZiAoYmxhbmtfYm91bmRhcnkpCgkJCQltZW1zZXQoaGV4LCAnICcsIGxlbmd0aCk7CgkJCWVsc2UgaWYgKCEob3B0ICYgT1VUUFVUX0FOTk9UQVRFX0NPTVBBVCkpIHsKCQkJCWxlbmd0aC0tOwoJCQkJcHV0Y2hhcignXicpOwoJCQl9CgkJfQoKCQlwcmludGYoIiUuKnMiLCBsZW5ndGgsIGhleCk7CgkJaWYgKG9wdCAmIE9VVFBVVF9BTk5PVEFURV9DT01QQVQpIHsKCQkJY29uc3QgY2hhciAqbmFtZTsKCQkJaWYgKG9wdCAmIE9VVFBVVF9TSE9XX0VNQUlMKQoJCQkJbmFtZSA9IGNpLmF1dGhvcl9tYWlsLmJ1ZjsKCQkJZWxzZQoJCQkJbmFtZSA9IGNpLmF1dGhvci5idWY7CgkJCXByaW50ZigiXHQoJTEwc1x0JTEwc1x0JWQpIiwgbmFtZSwKCQkJICAgICAgIGZvcm1hdF90aW1lKGNpLmF1dGhvcl90aW1lLCBjaS5hdXRob3JfdHouYnVmLAoJCQkJCSAgIHNob3dfcmF3X3RpbWUpLAoJCQkgICAgICAgZW50LT5sbm8gKyAxICsgY250KTsKCQl9IGVsc2UgewoJCQlpZiAob3B0ICYgT1VUUFVUX1NIT1dfU0NPUkUpCgkJCQlwcmludGYoIiAlKmQgJTAyZCIsCgkJCQkgICAgICAgbWF4X3Njb3JlX2RpZ2l0cywgZW50LT5zY29yZSwKCQkJCSAgICAgICBlbnQtPnN1c3BlY3QtPnJlZmNudCk7CgkJCWlmIChvcHQgJiBPVVRQVVRfU0hPV19OQU1FKQoJCQkJcHJpbnRmKCIgJS0qLipzIiwgbG9uZ2VzdF9maWxlLCBsb25nZXN0X2ZpbGUsCgkJCQkgICAgICAgc3VzcGVjdC0+cGF0aCk7CgkJCWlmIChvcHQgJiBPVVRQVVRfU0hPV19OVU1CRVIpCgkJCQlwcmludGYoIiAlKmQiLCBtYXhfb3JpZ19kaWdpdHMsCgkJCQkgICAgICAgZW50LT5zX2xubyArIDEgKyBjbnQpOwoKCQkJaWYgKCEob3B0ICYgT1VUUFVUX05PX0FVVEhPUikpIHsKCQkJCWNvbnN0IGNoYXIgKm5hbWU7CgkJCQlpbnQgcGFkOwoJCQkJaWYgKG9wdCAmIE9VVFBVVF9TSE9XX0VNQUlMKQoJCQkJCW5hbWUgPSBjaS5hdXRob3JfbWFpbC5idWY7CgkJCQllbHNlCgkJCQkJbmFtZSA9IGNpLmF1dGhvci5idWY7CgkJCQlwYWQgPSBsb25nZXN0X2F1dGhvciAtIHV0Zjhfc3Ryd2lkdGgobmFtZSk7CgkJCQlwcmludGYoIiAoJXMlKnMgJTEwcyIsCgkJCQkgICAgICAgbmFtZSwgcGFkLCAiIiwKCQkJCSAgICAgICBmb3JtYXRfdGltZShjaS5hdXRob3JfdGltZSwKCQkJCQkJICAgY2kuYXV0aG9yX3R6LmJ1ZiwKCQkJCQkJICAgc2hvd19yYXdfdGltZSkpOwoJCQl9CgkJCXByaW50ZigiICUqZCkgIiwKCQkJICAgICAgIG1heF9kaWdpdHMsIGVudC0+bG5vICsgMSArIGNudCk7CgkJfQoJCWlmIChyZXNldCkKCQkJZnB1dHMocmVzZXQsIHN0ZG91dCk7CgkJZG8gewoJCQljaCA9ICpjcCsrOwoJCQlwdXRjaGFyKGNoKTsKCQl9IHdoaWxlIChjaCAhPSAnXG4nICYmCgkJCSBjcCA8IHNiLT5maW5hbF9idWYgKyBzYi0+ZmluYWxfYnVmX3NpemUpOwoJfQoKCWlmIChzYi0+ZmluYWxfYnVmX3NpemUgJiYgY3BbLTFdICE9ICdcbicpCgkJcHV0Y2hhcignXG4nKTsKCgljb21taXRfaW5mb19kZXN0cm95KCZjaSk7Cn0KCnN0YXRpYyB2b2lkIG91dHB1dChzdHJ1Y3QgYmxhbWVfc2NvcmVib2FyZCAqc2IsIGludCBvcHRpb24pCnsKCXN0cnVjdCBibGFtZV9lbnRyeSAqZW50OwoKCWlmIChvcHRpb24gJiBPVVRQVVRfUE9SQ0VMQUlOKSB7CgkJZm9yIChlbnQgPSBzYi0+ZW50OyBlbnQ7IGVudCA9IGVudC0+bmV4dCkgewoJCQlpbnQgY291bnQgPSAwOwoJCQlzdHJ1Y3QgYmxhbWVfb3JpZ2luICpzdXNwZWN0OwoJCQlzdHJ1Y3QgY29tbWl0ICpjb21taXQgPSBlbnQtPnN1c3BlY3QtPmNvbW1pdDsKCQkJaWYgKGNvbW1pdC0+b2JqZWN0LmZsYWdzICYgTU9SRV9USEFOX09ORV9QQVRIKQoJCQkJY29udGludWU7CgkJCWZvciAoc3VzcGVjdCA9IGdldF9ibGFtZV9zdXNwZWN0cyhjb21taXQpOyBzdXNwZWN0OyBzdXNwZWN0ID0gc3VzcGVjdC0+bmV4dCkgewoJCQkJaWYgKHN1c3BlY3QtPmd1aWx0eSAmJiBjb3VudCsrKSB7CgkJCQkJY29tbWl0LT5vYmplY3QuZmxhZ3MgfD0gTU9SRV9USEFOX09ORV9QQVRIOwoJCQkJCWJyZWFrOwoJCQkJfQoJCQl9CgkJfQoJfQoKCWZvciAoZW50ID0gc2ItPmVudDsgZW50OyBlbnQgPSBlbnQtPm5leHQpIHsKCQlpZiAob3B0aW9uICYgT1VUUFVUX1BPUkNFTEFJTikKCQkJZW1pdF9wb3JjZWxhaW4oc2IsIGVudCwgb3B0aW9uKTsKCQllbHNlIHsKCQkJZW1pdF9vdGhlcihzYiwgZW50LCBvcHRpb24pOwoJCX0KCX0KfQoKLyoKICogQWRkIHBob255IGdyYWZ0cyBmb3IgdXNlIHdpdGggLVM7IHRoaXMgaXMgcHJpbWFyaWx5IHRvCiAqIHN1cHBvcnQgZ2l0J3MgY3Zzc2VydmVyIHRoYXQgd2FudHMgdG8gZ2l2ZSBhIGxpbmVhciBoaXN0b3J5CiAqIHRvIGl0cyBjbGllbnRzLgogKi8Kc3RhdGljIGludCByZWFkX2FuY2VzdHJ5KGNvbnN0IGNoYXIgKmdyYWZ0X2ZpbGUpCnsKCUZJTEUgKmZwID0gZm9wZW5fb3Jfd2FybihncmFmdF9maWxlLCAiciIpOwoJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCWlmICghZnApCgkJcmV0dXJuIC0xOwoJd2hpbGUgKCFzdHJidWZfZ2V0d2hvbGVsaW5lKCZidWYsIGZwLCAnXG4nKSkgewoJCS8qIFRoZSBmb3JtYXQgaXMganVzdCAiQ29tbWl0IFBhcmVudDEgUGFyZW50MiAuLi5cbiIgKi8KCQlzdHJ1Y3QgY29tbWl0X2dyYWZ0ICpncmFmdCA9IHJlYWRfZ3JhZnRfbGluZSgmYnVmKTsKCQlpZiAoZ3JhZnQpCgkJCXJlZ2lzdGVyX2NvbW1pdF9ncmFmdCh0aGVfcmVwb3NpdG9yeSwgZ3JhZnQsIDApOwoJfQoJZmNsb3NlKGZwKTsKCXN0cmJ1Zl9yZWxlYXNlKCZidWYpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgdXBkYXRlX2F1dG9fYWJicmV2KGludCBhdXRvX2FiYnJldiwgc3RydWN0IGJsYW1lX29yaWdpbiAqc3VzcGVjdCkKewoJY29uc3QgY2hhciAqdW5pcSA9IGZpbmRfdW5pcXVlX2FiYnJldigmc3VzcGVjdC0+Y29tbWl0LT5vYmplY3Qub2lkLAoJCQkJCSAgICAgIGF1dG9fYWJicmV2KTsKCWludCBsZW4gPSBzdHJsZW4odW5pcSk7CglpZiAoYXV0b19hYmJyZXYgPCBsZW4pCgkJcmV0dXJuIGxlbjsKCXJldHVybiBhdXRvX2FiYnJldjsKfQoKLyoKICogSG93IG1hbnkgY29sdW1ucyBkbyB3ZSBuZWVkIHRvIHNob3cgbGluZSBudW1iZXJzLCBhdXRob3JzLAogKiBhbmQgZmlsZW5hbWVzPwogKi8Kc3RhdGljIHZvaWQgZmluZF9hbGlnbm1lbnQoc3RydWN0IGJsYW1lX3Njb3JlYm9hcmQgKnNiLCBpbnQgKm9wdGlvbikKewoJaW50IGxvbmdlc3Rfc3JjX2xpbmVzID0gMDsKCWludCBsb25nZXN0X2RzdF9saW5lcyA9IDA7Cgl1bnNpZ25lZCBsYXJnZXN0X3Njb3JlID0gMDsKCXN0cnVjdCBibGFtZV9lbnRyeSAqZTsKCWludCBjb21wdXRlX2F1dG9fYWJicmV2ID0gKGFiYnJldiA8IDApOwoJaW50IGF1dG9fYWJicmV2ID0gREVGQVVMVF9BQkJSRVY7CgoJZm9yIChlID0gc2ItPmVudDsgZTsgZSA9IGUtPm5leHQpIHsKCQlzdHJ1Y3QgYmxhbWVfb3JpZ2luICpzdXNwZWN0ID0gZS0+c3VzcGVjdDsKCQlpbnQgbnVtOwoKCQlpZiAoY29tcHV0ZV9hdXRvX2FiYnJldikKCQkJYXV0b19hYmJyZXYgPSB1cGRhdGVfYXV0b19hYmJyZXYoYXV0b19hYmJyZXYsIHN1c3BlY3QpOwoJCWlmIChzdHJjbXAoc3VzcGVjdC0+cGF0aCwgc2ItPnBhdGgpKQoJCQkqb3B0aW9uIHw9IE9VVFBVVF9TSE9XX05BTUU7CgkJbnVtID0gc3RybGVuKHN1c3BlY3QtPnBhdGgpOwoJCWlmIChsb25nZXN0X2ZpbGUgPCBudW0pCgkJCWxvbmdlc3RfZmlsZSA9IG51bTsKCQlpZiAoIShzdXNwZWN0LT5jb21taXQtPm9iamVjdC5mbGFncyAmIE1FVEFJTkZPX1NIT1dOKSkgewoJCQlzdHJ1Y3QgY29tbWl0X2luZm8gY2k7CgkJCXN1c3BlY3QtPmNvbW1pdC0+b2JqZWN0LmZsYWdzIHw9IE1FVEFJTkZPX1NIT1dOOwoJCQlnZXRfY29tbWl0X2luZm8oc3VzcGVjdC0+Y29tbWl0LCAmY2ksIDEpOwoJCQlpZiAoKm9wdGlvbiAmIE9VVFBVVF9TSE9XX0VNQUlMKQoJCQkJbnVtID0gdXRmOF9zdHJ3aWR0aChjaS5hdXRob3JfbWFpbC5idWYpOwoJCQllbHNlCgkJCQludW0gPSB1dGY4X3N0cndpZHRoKGNpLmF1dGhvci5idWYpOwoJCQlpZiAobG9uZ2VzdF9hdXRob3IgPCBudW0pCgkJCQlsb25nZXN0X2F1dGhvciA9IG51bTsKCQkJY29tbWl0X2luZm9fZGVzdHJveSgmY2kpOwoJCX0KCQludW0gPSBlLT5zX2xubyArIGUtPm51bV9saW5lczsKCQlpZiAobG9uZ2VzdF9zcmNfbGluZXMgPCBudW0pCgkJCWxvbmdlc3Rfc3JjX2xpbmVzID0gbnVtOwoJCW51bSA9IGUtPmxubyArIGUtPm51bV9saW5lczsKCQlpZiAobG9uZ2VzdF9kc3RfbGluZXMgPCBudW0pCgkJCWxvbmdlc3RfZHN0X2xpbmVzID0gbnVtOwoJCWlmIChsYXJnZXN0X3Njb3JlIDwgYmxhbWVfZW50cnlfc2NvcmUoc2IsIGUpKQoJCQlsYXJnZXN0X3Njb3JlID0gYmxhbWVfZW50cnlfc2NvcmUoc2IsIGUpOwoJfQoJbWF4X29yaWdfZGlnaXRzID0gZGVjaW1hbF93aWR0aChsb25nZXN0X3NyY19saW5lcyk7CgltYXhfZGlnaXRzID0gZGVjaW1hbF93aWR0aChsb25nZXN0X2RzdF9saW5lcyk7CgltYXhfc2NvcmVfZGlnaXRzID0gZGVjaW1hbF93aWR0aChsYXJnZXN0X3Njb3JlKTsKCglpZiAoY29tcHV0ZV9hdXRvX2FiYnJldikKCQkvKiBvbmUgbW9yZSBhYmJyZXYgbGVuZ3RoIGlzIG5lZWRlZCBmb3IgdGhlIGJvdW5kYXJ5IGNvbW1pdCAqLwoJCWFiYnJldiA9IGF1dG9fYWJicmV2ICsgMTsKfQoKc3RhdGljIHZvaWQgc2FuaXR5X2NoZWNrX29uX2ZhaWwoc3RydWN0IGJsYW1lX3Njb3JlYm9hcmQgKnNiLCBpbnQgYmFhKQp7CglpbnQgb3B0ID0gT1VUUFVUX1NIT1dfU0NPUkUgfCBPVVRQVVRfU0hPV19OVU1CRVIgfCBPVVRQVVRfU0hPV19OQU1FOwoJZmluZF9hbGlnbm1lbnQoc2IsICZvcHQpOwoJb3V0cHV0KHNiLCBvcHQpOwoJZGllKCJCYWEgJWQhIiwgYmFhKTsKfQoKc3RhdGljIHVuc2lnbmVkIHBhcnNlX3Njb3JlKGNvbnN0IGNoYXIgKmFyZykKewoJY2hhciAqZW5kOwoJdW5zaWduZWQgbG9uZyBzY29yZSA9IHN0cnRvdWwoYXJnLCAmZW5kLCAxMCk7CglpZiAoKmVuZCkKCQlyZXR1cm4gMDsKCXJldHVybiBzY29yZTsKfQoKc3RhdGljIGNvbnN0IGNoYXIgKmFkZF9wcmVmaXgoY29uc3QgY2hhciAqcHJlZml4LCBjb25zdCBjaGFyICpwYXRoKQp7CglyZXR1cm4gcHJlZml4X3BhdGgocHJlZml4LCBwcmVmaXggPyBzdHJsZW4ocHJlZml4KSA6IDAsIHBhdGgpOwp9CgpzdGF0aWMgaW50IGdpdF9ibGFtZV9jb25maWcoY29uc3QgY2hhciAqdmFyLCBjb25zdCBjaGFyICp2YWx1ZSwgdm9pZCAqY2IpCnsKCWlmICghc3RyY21wKHZhciwgImJsYW1lLnNob3dyb290IikpIHsKCQlzaG93X3Jvb3QgPSBnaXRfY29uZmlnX2Jvb2wodmFyLCB2YWx1ZSk7CgkJcmV0dXJuIDA7Cgl9CglpZiAoIXN0cmNtcCh2YXIsICJibGFtZS5ibGFua2JvdW5kYXJ5IikpIHsKCQlibGFua19ib3VuZGFyeSA9IGdpdF9jb25maWdfYm9vbCh2YXIsIHZhbHVlKTsKCQlyZXR1cm4gMDsKCX0KCWlmICghc3RyY21wKHZhciwgImJsYW1lLnNob3dlbWFpbCIpKSB7CgkJaW50ICpvdXRwdXRfb3B0aW9uID0gY2I7CgkJaWYgKGdpdF9jb25maWdfYm9vbCh2YXIsIHZhbHVlKSkKCQkJKm91dHB1dF9vcHRpb24gfD0gT1VUUFVUX1NIT1dfRU1BSUw7CgkJZWxzZQoJCQkqb3V0cHV0X29wdGlvbiAmPSB+T1VUUFVUX1NIT1dfRU1BSUw7CgkJcmV0dXJuIDA7Cgl9CglpZiAoIXN0cmNtcCh2YXIsICJibGFtZS5kYXRlIikpIHsKCQlpZiAoIXZhbHVlKQoJCQlyZXR1cm4gY29uZmlnX2Vycm9yX25vbmJvb2wodmFyKTsKCQlwYXJzZV9kYXRlX2Zvcm1hdCh2YWx1ZSwgJmJsYW1lX2RhdGVfbW9kZSk7CgkJcmV0dXJuIDA7Cgl9CglpZiAoIXN0cmNtcCh2YXIsICJjb2xvci5ibGFtZS5yZXBlYXRlZGxpbmVzIikpIHsKCQlpZiAoY29sb3JfcGFyc2VfbWVtKHZhbHVlLCBzdHJsZW4odmFsdWUpLCByZXBlYXRlZF9tZXRhX2NvbG9yKSkKCQkJd2FybmluZyhfKCJpbnZhbGlkIGNvbG9yICclcycgaW4gY29sb3IuYmxhbWUucmVwZWF0ZWRMaW5lcyIpLAoJCQkJdmFsdWUpOwoJCXJldHVybiAwOwoJfQoJaWYgKCFzdHJjbXAodmFyLCAiY29sb3IuYmxhbWUuaGlnaGxpZ2h0cmVjZW50IikpIHsKCQlwYXJzZV9jb2xvcl9maWVsZHModmFsdWUpOwoJCXJldHVybiAwOwoJfQoKCWlmICghc3RyY21wKHZhciwgImJsYW1lLmNvbG9yaW5nIikpIHsKCQlpZiAoIXN0cmNtcCh2YWx1ZSwgInJlcGVhdGVkTGluZXMiKSkgewoJCQljb2xvcmluZ19tb2RlIHw9IE9VVFBVVF9DT0xPUl9MSU5FOwoJCX0gZWxzZSBpZiAoIXN0cmNtcCh2YWx1ZSwgImhpZ2hsaWdodFJlY2VudCIpKSB7CgkJCWNvbG9yaW5nX21vZGUgfD0gT1VUUFVUX1NIT1dfQUdFX1dJVEhfQ09MT1I7CgkJfSBlbHNlIGlmICghc3RyY21wKHZhbHVlLCAibm9uZSIpKSB7CgkJCWNvbG9yaW5nX21vZGUgJj0gfihPVVRQVVRfQ09MT1JfTElORSB8CgkJCQkJICAgIE9VVFBVVF9TSE9XX0FHRV9XSVRIX0NPTE9SKTsKCQl9IGVsc2UgewoJCQl3YXJuaW5nKF8oImludmFsaWQgdmFsdWUgZm9yIGJsYW1lLmNvbG9yaW5nIikpOwoJCQlyZXR1cm4gMDsKCQl9Cgl9CgoJaWYgKGdpdF9kaWZmX2hldXJpc3RpY19jb25maWcodmFyLCB2YWx1ZSwgY2IpIDwgMCkKCQlyZXR1cm4gLTE7CglpZiAodXNlcmRpZmZfY29uZmlnKHZhciwgdmFsdWUpIDwgMCkKCQlyZXR1cm4gLTE7CgoJcmV0dXJuIGdpdF9kZWZhdWx0X2NvbmZpZyh2YXIsIHZhbHVlLCBjYik7Cn0KCnN0YXRpYyBpbnQgYmxhbWVfY29weV9jYWxsYmFjayhjb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHRpb24sIGNvbnN0IGNoYXIgKmFyZywgaW50IHVuc2V0KQp7CglpbnQgKm9wdCA9IG9wdGlvbi0+dmFsdWU7CgoJQlVHX09OX09QVF9ORUcodW5zZXQpOwoKCS8qCgkgKiAtQyBlbmFibGVzIGNvcHkgZnJvbSByZW1vdmVkIGZpbGVzOwoJICogLUMgLUMgZW5hYmxlcyBjb3B5IGZyb20gZXhpc3RpbmcgZmlsZXMsIGJ1dCBvbmx5CgkgKiAgICAgICB3aGVuIGJsYW1pbmcgYSBuZXcgZmlsZTsKCSAqIC1DIC1DIC1DIGVuYWJsZXMgY29weSBmcm9tIGV4aXN0aW5nIGZpbGVzIGZvcgoJICogICAgICAgICAgZXZlcnlib2R5CgkgKi8KCWlmICgqb3B0ICYgUElDS0FYRV9CTEFNRV9DT1BZX0hBUkRFUikKCQkqb3B0IHw9IFBJQ0tBWEVfQkxBTUVfQ09QWV9IQVJERVNUOwoJaWYgKCpvcHQgJiBQSUNLQVhFX0JMQU1FX0NPUFkpCgkJKm9wdCB8PSBQSUNLQVhFX0JMQU1FX0NPUFlfSEFSREVSOwoJKm9wdCB8PSBQSUNLQVhFX0JMQU1FX0NPUFkgfCBQSUNLQVhFX0JMQU1FX01PVkU7CgoJaWYgKGFyZykKCQlibGFtZV9jb3B5X3Njb3JlID0gcGFyc2Vfc2NvcmUoYXJnKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGJsYW1lX21vdmVfY2FsbGJhY2soY29uc3Qgc3RydWN0IG9wdGlvbiAqb3B0aW9uLCBjb25zdCBjaGFyICphcmcsIGludCB1bnNldCkKewoJaW50ICpvcHQgPSBvcHRpb24tPnZhbHVlOwoKCUJVR19PTl9PUFRfTkVHKHVuc2V0KTsKCgkqb3B0IHw9IFBJQ0tBWEVfQkxBTUVfTU9WRTsKCglpZiAoYXJnKQoJCWJsYW1lX21vdmVfc2NvcmUgPSBwYXJzZV9zY29yZShhcmcpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgaXNfYV9yZXYoY29uc3QgY2hhciAqbmFtZSkKewoJc3RydWN0IG9iamVjdF9pZCBvaWQ7CgoJaWYgKGdldF9vaWQobmFtZSwgJm9pZCkpCgkJcmV0dXJuIDA7CglyZXR1cm4gT0JKX05PTkUgPCBvaWRfb2JqZWN0X2luZm8odGhlX3JlcG9zaXRvcnksICZvaWQsIE5VTEwpOwp9CgppbnQgY21kX2JsYW1lKGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndiwgY29uc3QgY2hhciAqcHJlZml4KQp7CglzdHJ1Y3QgcmV2X2luZm8gcmV2czsKCWNvbnN0IGNoYXIgKnBhdGg7CglzdHJ1Y3QgYmxhbWVfc2NvcmVib2FyZCBzYjsKCXN0cnVjdCBibGFtZV9vcmlnaW4gKm87CglzdHJ1Y3QgYmxhbWVfZW50cnkgKmVudCA9IE5VTEw7Cglsb25nIGRhc2hkYXNoX3BvcywgbG5vOwoJc3RydWN0IHByb2dyZXNzX2luZm8gcGkgPSB7IE5VTEwsIDAgfTsKCglzdHJ1Y3Qgc3RyaW5nX2xpc3QgcmFuZ2VfbGlzdCA9IFNUUklOR19MSVNUX0lOSVRfTk9EVVA7CglpbnQgb3V0cHV0X29wdGlvbiA9IDAsIG9wdCA9IDA7CglpbnQgc2hvd19zdGF0cyA9IDA7Cgljb25zdCBjaGFyICpyZXZzX2ZpbGUgPSBOVUxMOwoJY29uc3QgY2hhciAqY29udGVudHNfZnJvbSA9IE5VTEw7Cgljb25zdCBzdHJ1Y3Qgb3B0aW9uIG9wdGlvbnNbXSA9IHsKCQlPUFRfQk9PTCgwLCAiaW5jcmVtZW50YWwiLCAmaW5jcmVtZW50YWwsIE5fKCJTaG93IGJsYW1lIGVudHJpZXMgYXMgd2UgZmluZCB0aGVtLCBpbmNyZW1lbnRhbGx5IikpLAoJCU9QVF9CT09MKCdiJywgTlVMTCwgJmJsYW5rX2JvdW5kYXJ5LCBOXygiU2hvdyBibGFuayBTSEEtMSBmb3IgYm91bmRhcnkgY29tbWl0cyAoRGVmYXVsdDogb2ZmKSIpKSwKCQlPUFRfQk9PTCgwLCAicm9vdCIsICZzaG93X3Jvb3QsIE5fKCJEbyBub3QgdHJlYXQgcm9vdCBjb21taXRzIGFzIGJvdW5kYXJpZXMgKERlZmF1bHQ6IG9mZikiKSksCgkJT1BUX0JPT0woMCwgInNob3ctc3RhdHMiLCAmc2hvd19zdGF0cywgTl8oIlNob3cgd29yayBjb3N0IHN0YXRpc3RpY3MiKSksCgkJT1BUX0JPT0woMCwgInByb2dyZXNzIiwgJnNob3dfcHJvZ3Jlc3MsIE5fKCJGb3JjZSBwcm9ncmVzcyByZXBvcnRpbmciKSksCgkJT1BUX0JJVCgwLCAic2NvcmUtZGVidWciLCAmb3V0cHV0X29wdGlvbiwgTl8oIlNob3cgb3V0cHV0IHNjb3JlIGZvciBibGFtZSBlbnRyaWVzIiksIE9VVFBVVF9TSE9XX1NDT1JFKSwKCQlPUFRfQklUKCdmJywgInNob3ctbmFtZSIsICZvdXRwdXRfb3B0aW9uLCBOXygiU2hvdyBvcmlnaW5hbCBmaWxlbmFtZSAoRGVmYXVsdDogYXV0bykiKSwgT1VUUFVUX1NIT1dfTkFNRSksCgkJT1BUX0JJVCgnbicsICJzaG93LW51bWJlciIsICZvdXRwdXRfb3B0aW9uLCBOXygiU2hvdyBvcmlnaW5hbCBsaW5lbnVtYmVyIChEZWZhdWx0OiBvZmYpIiksIE9VVFBVVF9TSE9XX05VTUJFUiksCgkJT1BUX0JJVCgncCcsICJwb3JjZWxhaW4iLCAmb3V0cHV0X29wdGlvbiwgTl8oIlNob3cgaW4gYSBmb3JtYXQgZGVzaWduZWQgZm9yIG1hY2hpbmUgY29uc3VtcHRpb24iKSwgT1VUUFVUX1BPUkNFTEFJTiksCgkJT1BUX0JJVCgwLCAibGluZS1wb3JjZWxhaW4iLCAmb3V0cHV0X29wdGlvbiwgTl8oIlNob3cgcG9yY2VsYWluIGZvcm1hdCB3aXRoIHBlci1saW5lIGNvbW1pdCBpbmZvcm1hdGlvbiIpLCBPVVRQVVRfUE9SQ0VMQUlOfE9VVFBVVF9MSU5FX1BPUkNFTEFJTiksCgkJT1BUX0JJVCgnYycsIE5VTEwsICZvdXRwdXRfb3B0aW9uLCBOXygiVXNlIHRoZSBzYW1lIG91dHB1dCBtb2RlIGFzIGdpdC1hbm5vdGF0ZSAoRGVmYXVsdDogb2ZmKSIpLCBPVVRQVVRfQU5OT1RBVEVfQ09NUEFUKSwKCQlPUFRfQklUKCd0JywgTlVMTCwgJm91dHB1dF9vcHRpb24sIE5fKCJTaG93IHJhdyB0aW1lc3RhbXAgKERlZmF1bHQ6IG9mZikiKSwgT1VUUFVUX1JBV19USU1FU1RBTVApLAoJCU9QVF9CSVQoJ2wnLCBOVUxMLCAmb3V0cHV0X29wdGlvbiwgTl8oIlNob3cgbG9uZyBjb21taXQgU0hBMSAoRGVmYXVsdDogb2ZmKSIpLCBPVVRQVVRfTE9OR19PQkpFQ1RfTkFNRSksCgkJT1BUX0JJVCgncycsIE5VTEwsICZvdXRwdXRfb3B0aW9uLCBOXygiU3VwcHJlc3MgYXV0aG9yIG5hbWUgYW5kIHRpbWVzdGFtcCAoRGVmYXVsdDogb2ZmKSIpLCBPVVRQVVRfTk9fQVVUSE9SKSwKCQlPUFRfQklUKCdlJywgInNob3ctZW1haWwiLCAmb3V0cHV0X29wdGlvbiwgTl8oIlNob3cgYXV0aG9yIGVtYWlsIGluc3RlYWQgb2YgbmFtZSAoRGVmYXVsdDogb2ZmKSIpLCBPVVRQVVRfU0hPV19FTUFJTCksCgkJT1BUX0JJVCgndycsIE5VTEwsICZ4ZGxfb3B0cywgTl8oIklnbm9yZSB3aGl0ZXNwYWNlIGRpZmZlcmVuY2VzIiksIFhERl9JR05PUkVfV0hJVEVTUEFDRSksCgkJT1BUX0JJVCgwLCAiY29sb3ItbGluZXMiLCAmb3V0cHV0X29wdGlvbiwgTl8oImNvbG9yIHJlZHVuZGFudCBtZXRhZGF0YSBmcm9tIHByZXZpb3VzIGxpbmUgZGlmZmVyZW50bHkiKSwgT1VUUFVUX0NPTE9SX0xJTkUpLAoJCU9QVF9CSVQoMCwgImNvbG9yLWJ5LWFnZSIsICZvdXRwdXRfb3B0aW9uLCBOXygiY29sb3IgbGluZXMgYnkgYWdlIiksIE9VVFBVVF9TSE9XX0FHRV9XSVRIX0NPTE9SKSwKCgkJLyoKCQkgKiBUaGUgZm9sbG93aW5nIHR3byBvcHRpb25zIGFyZSBwYXJzZWQgYnkgcGFyc2VfcmV2aXNpb25fb3B0KCkKCQkgKiBhbmQgYXJlIG9ubHkgaW5jbHVkZWQgaGVyZSB0byBnZXQgaW5jbHVkZWQgaW4gdGhlICItaCIKCQkgKiBvdXRwdXQ6CgkJICovCgkJeyBPUFRJT05fTE9XTEVWRUxfQ0FMTEJBQ0ssIDAsICJpbmRlbnQtaGV1cmlzdGljIiwgTlVMTCwgTlVMTCwgTl8oIlVzZSBhbiBleHBlcmltZW50YWwgaGV1cmlzdGljIHRvIGltcHJvdmUgZGlmZnMiKSwgUEFSU0VfT1BUX05PQVJHLCBwYXJzZV9vcHRfdW5rbm93bl9jYiB9LAoKCQlPUFRfQklUKDAsICJtaW5pbWFsIiwgJnhkbF9vcHRzLCBOXygiU3BlbmQgZXh0cmEgY3ljbGVzIHRvIGZpbmQgYmV0dGVyIG1hdGNoIiksIFhERl9ORUVEX01JTklNQUwpLAoJCU9QVF9TVFJJTkcoJ1MnLCBOVUxMLCAmcmV2c19maWxlLCBOXygiZmlsZSIpLCBOXygiVXNlIHJldmlzaW9ucyBmcm9tIDxmaWxlPiBpbnN0ZWFkIG9mIGNhbGxpbmcgZ2l0LXJldi1saXN0IikpLAoJCU9QVF9TVFJJTkcoMCwgImNvbnRlbnRzIiwgJmNvbnRlbnRzX2Zyb20sIE5fKCJmaWxlIiksIE5fKCJVc2UgPGZpbGU+J3MgY29udGVudHMgYXMgdGhlIGZpbmFsIGltYWdlIikpLAoJCXsgT1BUSU9OX0NBTExCQUNLLCAnQycsIE5VTEwsICZvcHQsIE5fKCJzY29yZSIpLCBOXygiRmluZCBsaW5lIGNvcGllcyB3aXRoaW4gYW5kIGFjcm9zcyBmaWxlcyIpLCBQQVJTRV9PUFRfT1BUQVJHLCBibGFtZV9jb3B5X2NhbGxiYWNrIH0sCgkJeyBPUFRJT05fQ0FMTEJBQ0ssICdNJywgTlVMTCwgJm9wdCwgTl8oInNjb3JlIiksIE5fKCJGaW5kIGxpbmUgbW92ZW1lbnRzIHdpdGhpbiBhbmQgYWNyb3NzIGZpbGVzIiksIFBBUlNFX09QVF9PUFRBUkcsIGJsYW1lX21vdmVfY2FsbGJhY2sgfSwKCQlPUFRfU1RSSU5HX0xJU1QoJ0wnLCBOVUxMLCAmcmFuZ2VfbGlzdCwgTl8oIm4sbSIpLCBOXygiUHJvY2VzcyBvbmx5IGxpbmUgcmFuZ2UgbixtLCBjb3VudGluZyBmcm9tIDEiKSksCgkJT1BUX19BQkJSRVYoJmFiYnJldiksCgkJT1BUX0VORCgpCgl9OwoKCXN0cnVjdCBwYXJzZV9vcHRfY3R4X3QgY3R4OwoJaW50IGNtZF9pc19hbm5vdGF0ZSA9ICFzdHJjbXAoYXJndlswXSwgImFubm90YXRlIik7CglzdHJ1Y3QgcmFuZ2Vfc2V0IHJhbmdlczsKCXVuc2lnbmVkIGludCByYW5nZV9pOwoJbG9uZyBhbmNob3I7CgoJc2V0dXBfZGVmYXVsdF9jb2xvcl9ieV9hZ2UoKTsKCWdpdF9jb25maWcoZ2l0X2JsYW1lX2NvbmZpZywgJm91dHB1dF9vcHRpb24pOwoJcmVwb19pbml0X3JldmlzaW9ucyh0aGVfcmVwb3NpdG9yeSwgJnJldnMsIE5VTEwpOwoJcmV2cy5kYXRlX21vZGUgPSBibGFtZV9kYXRlX21vZGU7CglyZXZzLmRpZmZvcHQuZmxhZ3MuYWxsb3dfdGV4dGNvbnYgPSAxOwoJcmV2cy5kaWZmb3B0LmZsYWdzLmZvbGxvd19yZW5hbWVzID0gMTsKCglzYXZlX2NvbW1pdF9idWZmZXIgPSAwOwoJZGFzaGRhc2hfcG9zID0gMDsKCXNob3dfcHJvZ3Jlc3MgPSAtMTsKCglwYXJzZV9vcHRpb25zX3N0YXJ0KCZjdHgsIGFyZ2MsIGFyZ3YsIHByZWZpeCwgb3B0aW9ucywKCQkJICAgIFBBUlNFX09QVF9LRUVQX0RBU0hEQVNIIHwgUEFSU0VfT1BUX0tFRVBfQVJHVjApOwoJZm9yICg7OykgewoJCXN3aXRjaCAocGFyc2Vfb3B0aW9uc19zdGVwKCZjdHgsIG9wdGlvbnMsIGJsYW1lX29wdF91c2FnZSkpIHsKCQljYXNlIFBBUlNFX09QVF9IRUxQOgoJCWNhc2UgUEFSU0VfT1BUX0VSUk9SOgoJCQlleGl0KDEyOSk7CgkJY2FzZSBQQVJTRV9PUFRfQ09NUExFVEU6CgkJCWV4aXQoMCk7CgkJY2FzZSBQQVJTRV9PUFRfRE9ORToKCQkJaWYgKGN0eC5hcmd2WzBdKQoJCQkJZGFzaGRhc2hfcG9zID0gY3R4LmNwaWR4OwoJCQlnb3RvIHBhcnNlX2RvbmU7CgkJfQoKCQlpZiAoIXN0cmNtcChjdHguYXJndlswXSwgIi0tcmV2ZXJzZSIpKSB7CgkJCWN0eC5hcmd2WzBdID0gIi0tY2hpbGRyZW4iOwoJCQlyZXZlcnNlID0gMTsKCQl9CgkJcGFyc2VfcmV2aXNpb25fb3B0KCZyZXZzLCAmY3R4LCBvcHRpb25zLCBibGFtZV9vcHRfdXNhZ2UpOwoJfQpwYXJzZV9kb25lOgoJbm9fd2hvbGVfZmlsZV9yZW5hbWUgPSAhcmV2cy5kaWZmb3B0LmZsYWdzLmZvbGxvd19yZW5hbWVzOwoJeGRsX29wdHMgfD0gcmV2cy5kaWZmb3B0LnhkbF9vcHRzICYgWERGX0lOREVOVF9IRVVSSVNUSUM7CglyZXZzLmRpZmZvcHQuZmxhZ3MuZm9sbG93X3JlbmFtZXMgPSAwOwoJYXJnYyA9IHBhcnNlX29wdGlvbnNfZW5kKCZjdHgpOwoKCWlmIChpbmNyZW1lbnRhbCB8fCAob3V0cHV0X29wdGlvbiAmIE9VVFBVVF9QT1JDRUxBSU4pKSB7CgkJaWYgKHNob3dfcHJvZ3Jlc3MgPiAwKQoJCQlkaWUoXygiLS1wcm9ncmVzcyBjYW4ndCBiZSB1c2VkIHdpdGggLS1pbmNyZW1lbnRhbCBvciBwb3JjZWxhaW4gZm9ybWF0cyIpKTsKCQlzaG93X3Byb2dyZXNzID0gMDsKCX0gZWxzZSBpZiAoc2hvd19wcm9ncmVzcyA8IDApCgkJc2hvd19wcm9ncmVzcyA9IGlzYXR0eSgyKTsKCglpZiAoMCA8IGFiYnJldiAmJiBhYmJyZXYgPCBHSVRfU0hBMV9IRVhTWikKCQkvKiBvbmUgbW9yZSBhYmJyZXYgbGVuZ3RoIGlzIG5lZWRlZCBmb3IgdGhlIGJvdW5kYXJ5IGNvbW1pdCAqLwoJCWFiYnJldisrOwoJZWxzZSBpZiAoIWFiYnJldikKCQlhYmJyZXYgPSBHSVRfU0hBMV9IRVhTWjsKCglpZiAocmV2c19maWxlICYmIHJlYWRfYW5jZXN0cnkocmV2c19maWxlKSkKCQlkaWVfZXJybm8oInJlYWRpbmcgZ3JhZnQgZmlsZSAnJXMnIGZhaWxlZCIsIHJldnNfZmlsZSk7CgoJaWYgKGNtZF9pc19hbm5vdGF0ZSkgewoJCW91dHB1dF9vcHRpb24gfD0gT1VUUFVUX0FOTk9UQVRFX0NPTVBBVDsKCQlibGFtZV9kYXRlX21vZGUudHlwZSA9IERBVEVfSVNPODYwMTsKCX0gZWxzZSB7CgkJYmxhbWVfZGF0ZV9tb2RlID0gcmV2cy5kYXRlX21vZGU7Cgl9CgoJLyogVGhlIG1heGltdW0gd2lkdGggdXNlZCB0byBzaG93IHRoZSBkYXRlcyAqLwoJc3dpdGNoIChibGFtZV9kYXRlX21vZGUudHlwZSkgewoJY2FzZSBEQVRFX1JGQzI4MjI6CgkJYmxhbWVfZGF0ZV93aWR0aCA9IHNpemVvZigiVGh1LCAxOSBPY3QgMjAwNiAxNjowMDowNCAtMDcwMCIpOwoJCWJyZWFrOwoJY2FzZSBEQVRFX0lTTzg2MDFfU1RSSUNUOgoJCWJsYW1lX2RhdGVfd2lkdGggPSBzaXplb2YoIjIwMDYtMTAtMTlUMTY6MDA6MDQtMDc6MDAiKTsKCQlicmVhazsKCWNhc2UgREFURV9JU084NjAxOgoJCWJsYW1lX2RhdGVfd2lkdGggPSBzaXplb2YoIjIwMDYtMTAtMTkgMTY6MDA6MDQgLTA3MDAiKTsKCQlicmVhazsKCWNhc2UgREFURV9SQVc6CgkJYmxhbWVfZGF0ZV93aWR0aCA9IHNpemVvZigiMTE2MTI5ODgwNCAtMDcwMCIpOwoJCWJyZWFrOwoJY2FzZSBEQVRFX1VOSVg6CgkJYmxhbWVfZGF0ZV93aWR0aCA9IHNpemVvZigiMTE2MTI5ODgwNCIpOwoJCWJyZWFrOwoJY2FzZSBEQVRFX1NIT1JUOgoJCWJsYW1lX2RhdGVfd2lkdGggPSBzaXplb2YoIjIwMDYtMTAtMTkiKTsKCQlicmVhazsKCWNhc2UgREFURV9SRUxBVElWRToKCQkvKgoJCSAqIFRSQU5TTEFUT1JTOiBUaGlzIHN0cmluZyBpcyB1c2VkIHRvIHRlbGwgdXMgdGhlCgkJICogbWF4aW11bSBkaXNwbGF5IHdpZHRoIGZvciBhIHJlbGF0aXZlIHRpbWVzdGFtcCBpbgoJCSAqICJnaXQgYmxhbWUiIG91dHB1dC4gIEZvciBDIGxvY2FsZSwgIjQgeWVhcnMsIDExCgkJICogbW9udGhzIGFnbyIsIHdoaWNoIHRha2VzIDIyIHBsYWNlcywgaXMgdGhlIGxvbmdlc3QKCQkgKiBhbW9uZyB2YXJpb3VzIGZvcm1zIG9mIHJlbGF0aXZlIHRpbWVzdGFtcHMsIGJ1dAoJCSAqIHlvdXIgbGFuZ3VhZ2UgbWF5IG5lZWQgbW9yZSBvciBmZXdlciBkaXNwbGF5CgkJICogY29sdW1ucy4KCQkgKi8KCQlibGFtZV9kYXRlX3dpZHRoID0gdXRmOF9zdHJ3aWR0aChfKCI0IHllYXJzLCAxMSBtb250aHMgYWdvIikpICsgMTsgLyogYWRkIHRoZSBudWxsICovCgkJYnJlYWs7CgljYXNlIERBVEVfTk9STUFMOgoJCWJsYW1lX2RhdGVfd2lkdGggPSBzaXplb2YoIlRodSBPY3QgMTkgMTY6MDA6MDQgMjAwNiAtMDcwMCIpOwoJCWJyZWFrOwoJY2FzZSBEQVRFX1NUUkZUSU1FOgoJCWJsYW1lX2RhdGVfd2lkdGggPSBzdHJsZW4oc2hvd19kYXRlKDAsIDAsICZibGFtZV9kYXRlX21vZGUpKSArIDE7IC8qIGFkZCB0aGUgbnVsbCAqLwoJCWJyZWFrOwoJfQoJYmxhbWVfZGF0ZV93aWR0aCAtPSAxOyAvKiBzdHJpcCB0aGUgbnVsbCAqLwoKCWlmIChyZXZzLmRpZmZvcHQuZmxhZ3MuZmluZF9jb3BpZXNfaGFyZGVyKQoJCW9wdCB8PSAoUElDS0FYRV9CTEFNRV9DT1BZIHwgUElDS0FYRV9CTEFNRV9NT1ZFIHwKCQkJUElDS0FYRV9CTEFNRV9DT1BZX0hBUkRFUik7CgoJLyoKCSAqIFdlIGhhdmUgY29sbGVjdGVkIG9wdGlvbnMgdW5rbm93biB0byB1cyBpbiBhcmd2WzEuLnVua10KCSAqIHdoaWNoIGFyZSB0byBiZSBwYXNzZWQgdG8gcmV2aXNpb24gbWFjaGluZXJ5IGlmIHdlIGFyZQoJICogZ29pbmcgdG8gZG8gdGhlICJib3R0b20iIHByb2Nlc3NpbmcuCgkgKgoJICogVGhlIHJlbWFpbmluZyBhcmU6CgkgKgoJICogKDEpIGlmIGRhc2hkYXNoX3BvcyAhPSAwLCBpdCBpcyBlaXRoZXIKCSAqICAgICAiYmxhbWUgW3JldmlzaW9uc10gLS0gPHBhdGg+IiBvcgoJICogICAgICJibGFtZSAtLSA8cGF0aD4gPHJldj4iCgkgKgoJICogKDIpIG90aGVyd2lzZSwgaXQgaXMgb25lIG9mIHRoZSB0d286CgkgKiAgICAgImJsYW1lIFtyZXZpc2lvbnNdIDxwYXRoPiIKCSAqICAgICAiYmxhbWUgPHBhdGg+IDxyZXY+IgoJICoKCSAqIE5vdGUgdGhhdCB3ZSBtdXN0IHN0cmlwIG91dCA8cGF0aD4gZnJvbSB0aGUgYXJndW1lbnRzOiB3ZSBkbyBub3QKCSAqIHdhbnQgdGhlIHBhdGggcHJ1bmluZyBidXQgd2UgbWF5IHdhbnQgImJvdHRvbSIgcHJvY2Vzc2luZy4KCSAqLwoJaWYgKGRhc2hkYXNoX3BvcykgewoJCXN3aXRjaCAoYXJnYyAtIGRhc2hkYXNoX3BvcyAtIDEpIHsKCQljYXNlIDI6IC8qICgxYikgKi8KCQkJaWYgKGFyZ2MgIT0gNCkKCQkJCXVzYWdlX3dpdGhfb3B0aW9ucyhibGFtZV9vcHRfdXNhZ2UsIG9wdGlvbnMpOwoJCQkvKiByZW9yZGVyIGZvciB0aGUgbmV3IHdheTogPHJldj4gLS0gPHBhdGg+ICovCgkJCWFyZ3ZbMV0gPSBhcmd2WzNdOwoJCQlhcmd2WzNdID0gYXJndlsyXTsKCQkJYXJndlsyXSA9ICItLSI7CgkJCS8qIEZBTExUSFJPVUdIICovCgkJY2FzZSAxOiAvKiAoMWEpICovCgkJCXBhdGggPSBhZGRfcHJlZml4KHByZWZpeCwgYXJndlstLWFyZ2NdKTsKCQkJYXJndlthcmdjXSA9IE5VTEw7CgkJCWJyZWFrOwoJCWRlZmF1bHQ6CgkJCXVzYWdlX3dpdGhfb3B0aW9ucyhibGFtZV9vcHRfdXNhZ2UsIG9wdGlvbnMpOwoJCX0KCX0gZWxzZSB7CgkJaWYgKGFyZ2MgPCAyKQoJCQl1c2FnZV93aXRoX29wdGlvbnMoYmxhbWVfb3B0X3VzYWdlLCBvcHRpb25zKTsKCQlpZiAoYXJnYyA9PSAzICYmIGlzX2FfcmV2KGFyZ3ZbYXJnYyAtIDFdKSkgeyAvKiAoMmIpICovCgkJCXBhdGggPSBhZGRfcHJlZml4KHByZWZpeCwgYXJndlsxXSk7CgkJCWFyZ3ZbMV0gPSBhcmd2WzJdOwoJCX0gZWxzZSB7CS8qICgyYSkgKi8KCQkJaWYgKGFyZ2MgPT0gMiAmJiBpc19hX3Jldihhcmd2WzFdKSAmJiAhZ2V0X2dpdF93b3JrX3RyZWUoKSkKCQkJCWRpZSgibWlzc2luZyA8cGF0aD4gdG8gYmxhbWUiKTsKCQkJcGF0aCA9IGFkZF9wcmVmaXgocHJlZml4LCBhcmd2W2FyZ2MgLSAxXSk7CgkJfQoJCWFyZ3ZbYXJnYyAtIDFdID0gIi0tIjsKCX0KCglyZXZzLmRpc2FibGVfc3RkaW4gPSAxOwoJc2V0dXBfcmV2aXNpb25zKGFyZ2MsIGFyZ3YsICZyZXZzLCBOVUxMKTsKCglpbml0X3Njb3JlYm9hcmQoJnNiKTsKCXNiLnJldnMgPSAmcmV2czsKCXNiLmNvbnRlbnRzX2Zyb20gPSBjb250ZW50c19mcm9tOwoJc2IucmV2ZXJzZSA9IHJldmVyc2U7CglzYi5yZXBvID0gdGhlX3JlcG9zaXRvcnk7CglzZXR1cF9zY29yZWJvYXJkKCZzYiwgcGF0aCwgJm8pOwoJbG5vID0gc2IubnVtX2xpbmVzOwoKCWlmIChsbm8gJiYgIXJhbmdlX2xpc3QubnIpCgkJc3RyaW5nX2xpc3RfYXBwZW5kKCZyYW5nZV9saXN0LCAiMSIpOwoKCWFuY2hvciA9IDE7CglyYW5nZV9zZXRfaW5pdCgmcmFuZ2VzLCByYW5nZV9saXN0Lm5yKTsKCWZvciAocmFuZ2VfaSA9IDA7IHJhbmdlX2kgPCByYW5nZV9saXN0Lm5yOyArK3JhbmdlX2kpIHsKCQlsb25nIGJvdHRvbSwgdG9wOwoJCWlmIChwYXJzZV9yYW5nZV9hcmcocmFuZ2VfbGlzdC5pdGVtc1tyYW5nZV9pXS5zdHJpbmcsCgkJCQkgICAgbnRoX2xpbmVfY2IsICZzYiwgbG5vLCBhbmNob3IsCgkJCQkgICAgJmJvdHRvbSwgJnRvcCwgc2IucGF0aCwKCQkJCSAgICB0aGVfcmVwb3NpdG9yeS0+aW5kZXgpKQoJCQl1c2FnZShibGFtZV91c2FnZSk7CgkJaWYgKCghbG5vICYmICh0b3AgfHwgYm90dG9tKSkgfHwgbG5vIDwgYm90dG9tKQoJCQlkaWUoUV8oImZpbGUgJXMgaGFzIG9ubHkgJWx1IGxpbmUiLAoJCQkgICAgICAgImZpbGUgJXMgaGFzIG9ubHkgJWx1IGxpbmVzIiwKCQkJICAgICAgIGxubyksIHBhdGgsIGxubyk7CgkJaWYgKGJvdHRvbSA8IDEpCgkJCWJvdHRvbSA9IDE7CgkJaWYgKHRvcCA8IDEgfHwgbG5vIDwgdG9wKQoJCQl0b3AgPSBsbm87CgkJYm90dG9tLS07CgkJcmFuZ2Vfc2V0X2FwcGVuZF91bnNhZmUoJnJhbmdlcywgYm90dG9tLCB0b3ApOwoJCWFuY2hvciA9IHRvcCArIDE7Cgl9Cglzb3J0X2FuZF9tZXJnZV9yYW5nZV9zZXQoJnJhbmdlcyk7CgoJZm9yIChyYW5nZV9pID0gcmFuZ2VzLm5yOyByYW5nZV9pID4gMDsgLS1yYW5nZV9pKSB7CgkJY29uc3Qgc3RydWN0IHJhbmdlICpyID0gJnJhbmdlcy5yYW5nZXNbcmFuZ2VfaSAtIDFdOwoJCWVudCA9IGJsYW1lX2VudHJ5X3ByZXBlbmQoZW50LCByLT5zdGFydCwgci0+ZW5kLCBvKTsKCX0KCglvLT5zdXNwZWN0cyA9IGVudDsKCXByaW9fcXVldWVfcHV0KCZzYi5jb21taXRzLCBvLT5jb21taXQpOwoKCWJsYW1lX29yaWdpbl9kZWNyZWYobyk7CgoJcmFuZ2Vfc2V0X3JlbGVhc2UoJnJhbmdlcyk7CglzdHJpbmdfbGlzdF9jbGVhcigmcmFuZ2VfbGlzdCwgMCk7CgoJc2IuZW50ID0gTlVMTDsKCXNiLnBhdGggPSBwYXRoOwoKCWlmIChibGFtZV9tb3ZlX3Njb3JlKQoJCXNiLm1vdmVfc2NvcmUgPSBibGFtZV9tb3ZlX3Njb3JlOwoJaWYgKGJsYW1lX2NvcHlfc2NvcmUpCgkJc2IuY29weV9zY29yZSA9IGJsYW1lX2NvcHlfc2NvcmU7CgoJc2IuZGVidWcgPSBERUJVRzsKCXNiLm9uX3Nhbml0eV9mYWlsID0gJnNhbml0eV9jaGVja19vbl9mYWlsOwoKCXNiLnNob3dfcm9vdCA9IHNob3dfcm9vdDsKCXNiLnhkbF9vcHRzID0geGRsX29wdHM7CglzYi5ub193aG9sZV9maWxlX3JlbmFtZSA9IG5vX3dob2xlX2ZpbGVfcmVuYW1lOwoKCXJlYWRfbWFpbG1hcCgmbWFpbG1hcCwgTlVMTCk7CgoJc2IuZm91bmRfZ3VpbHR5X2VudHJ5ID0gJmZvdW5kX2d1aWx0eV9lbnRyeTsKCXNiLmZvdW5kX2d1aWx0eV9lbnRyeV9kYXRhID0gJnBpOwoJaWYgKHNob3dfcHJvZ3Jlc3MpCgkJcGkucHJvZ3Jlc3MgPSBzdGFydF9kZWxheWVkX3Byb2dyZXNzKF8oIkJsYW1pbmcgbGluZXMiKSwgc2IubnVtX2xpbmVzKTsKCglhc3NpZ25fYmxhbWUoJnNiLCBvcHQpOwoKCXN0b3BfcHJvZ3Jlc3MoJnBpLnByb2dyZXNzKTsKCglpZiAoIWluY3JlbWVudGFsKQoJCXNldHVwX3BhZ2VyKCk7CgllbHNlCgkJcmV0dXJuIDA7CgoJYmxhbWVfc29ydF9maW5hbCgmc2IpOwoKCWJsYW1lX2NvYWxlc2NlKCZzYik7CgoJaWYgKCEob3V0cHV0X29wdGlvbiAmIChPVVRQVVRfQ09MT1JfTElORSB8IE9VVFBVVF9TSE9XX0FHRV9XSVRIX0NPTE9SKSkpCgkJb3V0cHV0X29wdGlvbiB8PSBjb2xvcmluZ19tb2RlOwoKCWlmICghKG91dHB1dF9vcHRpb24gJiBPVVRQVVRfUE9SQ0VMQUlOKSkgewoJCWZpbmRfYWxpZ25tZW50KCZzYiwgJm91dHB1dF9vcHRpb24pOwoJCWlmICghKnJlcGVhdGVkX21ldGFfY29sb3IgJiYKCQkgICAgKG91dHB1dF9vcHRpb24gJiBPVVRQVVRfQ09MT1JfTElORSkpCgkJCXhzbnByaW50ZihyZXBlYXRlZF9tZXRhX2NvbG9yLAoJCQkJICBzaXplb2YocmVwZWF0ZWRfbWV0YV9jb2xvciksCgkJCQkgICIlcyIsIEdJVF9DT0xPUl9DWUFOKTsKCX0KCWlmIChvdXRwdXRfb3B0aW9uICYgT1VUUFVUX0FOTk9UQVRFX0NPTVBBVCkKCQlvdXRwdXRfb3B0aW9uICY9IH4oT1VUUFVUX0NPTE9SX0xJTkUgfCBPVVRQVVRfU0hPV19BR0VfV0lUSF9DT0xPUik7CgoJb3V0cHV0KCZzYiwgb3V0cHV0X29wdGlvbik7CglmcmVlKCh2b2lkICopc2IuZmluYWxfYnVmKTsKCWZvciAoZW50ID0gc2IuZW50OyBlbnQ7ICkgewoJCXN0cnVjdCBibGFtZV9lbnRyeSAqZSA9IGVudC0+bmV4dDsKCQlmcmVlKGVudCk7CgkJZW50ID0gZTsKCX0KCglpZiAoc2hvd19zdGF0cykgewoJCXByaW50ZigibnVtIHJlYWQgYmxvYjogJWRcbiIsIHNiLm51bV9yZWFkX2Jsb2IpOwoJCXByaW50ZigibnVtIGdldCBwYXRjaDogJWRcbiIsIHNiLm51bV9nZXRfcGF0Y2gpOwoJCXByaW50ZigibnVtIGNvbW1pdHM6ICVkXG4iLCBzYi5udW1fY29tbWl0cyk7Cgl9CglyZXR1cm4gMDsKfQo=",
    "text": "/*\n * Blame\n *\n * Copyright (c) 2006, 2014 by its authors\n * See COPYING for licensing conditions\n */\n\n#include \"cache.h\"\n#include \"config.h\"\n#include \"color.h\"\n#include \"builtin.h\"\n#include \"repository.h\"\n#include \"commit.h\"\n#include \"diff.h\"\n#include \"revision.h\"\n#include \"quote.h\"\n#include \"string-list.h\"\n#include \"mailmap.h\"\n#include \"parse-options.h\"\n#include \"prio-queue.h\"\n#include \"utf8.h\"\n#include \"userdiff.h\"\n#include \"line-range.h\"\n#include \"line-log.h\"\n#include \"dir.h\"\n#include \"progress.h\"\n#include \"object-store.h\"\n#include \"blame.h\"\n#include \"string-list.h\"\n\nstatic char blame_usage[] = N_(\"git blame [<options>] [<rev-opts>] [<rev>] [--] <file>\");\n\nstatic const char *blame_opt_usage[] = {\n\tblame_usage,\n\t\"\",\n\tN_(\"<rev-opts> are documented in git-rev-list(1)\"),\n\tNULL\n};\n\nstatic int longest_file;\nstatic int longest_author;\nstatic int max_orig_digits;\nstatic int max_digits;\nstatic int max_score_digits;\nstatic int show_root;\nstatic int reverse;\nstatic int blank_boundary;\nstatic int incremental;\nstatic int xdl_opts;\nstatic int abbrev = -1;\nstatic int no_whole_file_rename;\nstatic int show_progress;\nstatic char repeated_meta_color[COLOR_MAXLEN];\nstatic int coloring_mode;\n\nstatic struct date_mode blame_date_mode = { DATE_ISO8601 };\nstatic size_t blame_date_width;\n\nstatic struct string_list mailmap = STRING_LIST_INIT_NODUP;\n\n#ifndef DEBUG\n#define DEBUG 0\n#endif\n\nstatic unsigned blame_move_score;\nstatic unsigned blame_copy_score;\n\n/* Remember to update object flag allocation in object.h */\n#define METAINFO_SHOWN\t\t(1u<<12)\n#define MORE_THAN_ONE_PATH\t(1u<<13)\n\nstruct progress_info {\n\tstruct progress *progress;\n\tint blamed_lines;\n};\n\nstatic const char *nth_line_cb(void *data, long lno)\n{\n\treturn blame_nth_line((struct blame_scoreboard *)data, lno);\n}\n\n/*\n * Information on commits, used for output.\n */\nstruct commit_info {\n\tstruct strbuf author;\n\tstruct strbuf author_mail;\n\ttimestamp_t author_time;\n\tstruct strbuf author_tz;\n\n\t/* filled only when asked for details */\n\tstruct strbuf committer;\n\tstruct strbuf committer_mail;\n\ttimestamp_t committer_time;\n\tstruct strbuf committer_tz;\n\n\tstruct strbuf summary;\n};\n\n/*\n * Parse author/committer line in the commit object buffer\n */\nstatic void get_ac_line(const char *inbuf, const char *what,\n\tstruct strbuf *name, struct strbuf *mail,\n\ttimestamp_t *time, struct strbuf *tz)\n{\n\tstruct ident_split ident;\n\tsize_t len, maillen, namelen;\n\tchar *tmp, *endp;\n\tconst char *namebuf, *mailbuf;\n\n\ttmp = strstr(inbuf, what);\n\tif (!tmp)\n\t\tgoto error_out;\n\ttmp += strlen(what);\n\tendp = strchr(tmp, '\\n');\n\tif (!endp)\n\t\tlen = strlen(tmp);\n\telse\n\t\tlen = endp - tmp;\n\n\tif (split_ident_line(&ident, tmp, len)) {\n\terror_out:\n\t\t/* Ugh */\n\t\ttmp = \"(unknown)\";\n\t\tstrbuf_addstr(name, tmp);\n\t\tstrbuf_addstr(mail, tmp);\n\t\tstrbuf_addstr(tz, tmp);\n\t\t*time = 0;\n\t\treturn;\n\t}\n\n\tnamelen = ident.name_end - ident.name_begin;\n\tnamebuf = ident.name_begin;\n\n\tmaillen = ident.mail_end - ident.mail_begin;\n\tmailbuf = ident.mail_begin;\n\n\tif (ident.date_begin && ident.date_end)\n\t\t*time = strtoul(ident.date_begin, NULL, 10);\n\telse\n\t\t*time = 0;\n\n\tif (ident.tz_begin && ident.tz_end)\n\t\tstrbuf_add(tz, ident.tz_begin, ident.tz_end - ident.tz_begin);\n\telse\n\t\tstrbuf_addstr(tz, \"(unknown)\");\n\n\t/*\n\t * Now, convert both name and e-mail using mailmap\n\t */\n\tmap_user(&mailmap, &mailbuf, &maillen,\n\t\t &namebuf, &namelen);\n\n\tstrbuf_addf(mail, \"<%.*s>\", (int)maillen, mailbuf);\n\tstrbuf_add(name, namebuf, namelen);\n}\n\nstatic void commit_info_init(struct commit_info *ci)\n{\n\n\tstrbuf_init(&ci->author, 0);\n\tstrbuf_init(&ci->author_mail, 0);\n\tstrbuf_init(&ci->author_tz, 0);\n\tstrbuf_init(&ci->committer, 0);\n\tstrbuf_init(&ci->committer_mail, 0);\n\tstrbuf_init(&ci->committer_tz, 0);\n\tstrbuf_init(&ci->summary, 0);\n}\n\nstatic void commit_info_destroy(struct commit_info *ci)\n{\n\n\tstrbuf_release(&ci->author);\n\tstrbuf_release(&ci->author_mail);\n\tstrbuf_release(&ci->author_tz);\n\tstrbuf_release(&ci->committer);\n\tstrbuf_release(&ci->committer_mail);\n\tstrbuf_release(&ci->committer_tz);\n\tstrbuf_release(&ci->summary);\n}\n\nstatic void get_commit_info(struct commit *commit,\n\t\t\t    struct commit_info *ret,\n\t\t\t    int detailed)\n{\n\tint len;\n\tconst char *subject, *encoding;\n\tconst char *message;\n\n\tcommit_info_init(ret);\n\n\tencoding = get_log_output_encoding();\n\tmessage = logmsg_reencode(commit, NULL, encoding);\n\tget_ac_line(message, \"\\nauthor \",\n\t\t    &ret->author, &ret->author_mail,\n\t\t    &ret->author_time, &ret->author_tz);\n\n\tif (!detailed) {\n\t\tunuse_commit_buffer(commit, message);\n\t\treturn;\n\t}\n\n\tget_ac_line(message, \"\\ncommitter \",\n\t\t    &ret->committer, &ret->committer_mail,\n\t\t    &ret->committer_time, &ret->committer_tz);\n\n\tlen = find_commit_subject(message, &subject);\n\tif (len)\n\t\tstrbuf_add(&ret->summary, subject, len);\n\telse\n\t\tstrbuf_addf(&ret->summary, \"(%s)\", oid_to_hex(&commit->object.oid));\n\n\tunuse_commit_buffer(commit, message);\n}\n\n/*\n * Write out any suspect information which depends on the path. This must be\n * handled separately from emit_one_suspect_detail(), because a given commit\n * may have changes in multiple paths. So this needs to appear each time\n * we mention a new group.\n *\n * To allow LF and other nonportable characters in pathnames,\n * they are c-style quoted as needed.\n */\nstatic void write_filename_info(struct blame_origin *suspect)\n{\n\tif (suspect->previous) {\n\t\tstruct blame_origin *prev = suspect->previous;\n\t\tprintf(\"previous %s \", oid_to_hex(&prev->commit->object.oid));\n\t\twrite_name_quoted(prev->path, stdout, '\\n');\n\t}\n\tprintf(\"filename \");\n\twrite_name_quoted(suspect->path, stdout, '\\n');\n}\n\n/*\n * Porcelain/Incremental format wants to show a lot of details per\n * commit.  Instead of repeating this every line, emit it only once,\n * the first time each commit appears in the output (unless the\n * user has specifically asked for us to repeat).\n */\nstatic int emit_one_suspect_detail(struct blame_origin *suspect, int repeat)\n{\n\tstruct commit_info ci;\n\n\tif (!repeat && (suspect->commit->object.flags & METAINFO_SHOWN))\n\t\treturn 0;\n\n\tsuspect->commit->object.flags |= METAINFO_SHOWN;\n\tget_commit_info(suspect->commit, &ci, 1);\n\tprintf(\"author %s\\n\", ci.author.buf);\n\tprintf(\"author-mail %s\\n\", ci.author_mail.buf);\n\tprintf(\"author-time %\"PRItime\"\\n\", ci.author_time);\n\tprintf(\"author-tz %s\\n\", ci.author_tz.buf);\n\tprintf(\"committer %s\\n\", ci.committer.buf);\n\tprintf(\"committer-mail %s\\n\", ci.committer_mail.buf);\n\tprintf(\"committer-time %\"PRItime\"\\n\", ci.committer_time);\n\tprintf(\"committer-tz %s\\n\", ci.committer_tz.buf);\n\tprintf(\"summary %s\\n\", ci.summary.buf);\n\tif (suspect->commit->object.flags & UNINTERESTING)\n\t\tprintf(\"boundary\\n\");\n\n\tcommit_info_destroy(&ci);\n\n\treturn 1;\n}\n\n/*\n * The blame_entry is found to be guilty for the range.\n * Show it in incremental output.\n */\nstatic void found_guilty_entry(struct blame_entry *ent, void *data)\n{\n\tstruct progress_info *pi = (struct progress_info *)data;\n\n\tif (incremental) {\n\t\tstruct blame_origin *suspect = ent->suspect;\n\n\t\tprintf(\"%s %d %d %d\\n\",\n\t\t       oid_to_hex(&suspect->commit->object.oid),\n\t\t       ent->s_lno + 1, ent->lno + 1, ent->num_lines);\n\t\temit_one_suspect_detail(suspect, 0);\n\t\twrite_filename_info(suspect);\n\t\tmaybe_flush_or_die(stdout, \"stdout\");\n\t}\n\tpi->blamed_lines += ent->num_lines;\n\tdisplay_progress(pi->progress, pi->blamed_lines);\n}\n\nstatic const char *format_time(timestamp_t time, const char *tz_str,\n\t\t\t       int show_raw_time)\n{\n\tstatic struct strbuf time_buf = STRBUF_INIT;\n\n\tstrbuf_reset(&time_buf);\n\tif (show_raw_time) {\n\t\tstrbuf_addf(&time_buf, \"%\"PRItime\" %s\", time, tz_str);\n\t}\n\telse {\n\t\tconst char *time_str;\n\t\tsize_t time_width;\n\t\tint tz;\n\t\ttz = atoi(tz_str);\n\t\ttime_str = show_date(time, tz, &blame_date_mode);\n\t\tstrbuf_addstr(&time_buf, time_str);\n\t\t/*\n\t\t * Add space paddings to time_buf to display a fixed width\n\t\t * string, and use time_width for display width calibration.\n\t\t */\n\t\tfor (time_width = utf8_strwidth(time_str);\n\t\t     time_width < blame_date_width;\n\t\t     time_width++)\n\t\t\tstrbuf_addch(&time_buf, ' ');\n\t}\n\treturn time_buf.buf;\n}\n\n#define OUTPUT_ANNOTATE_COMPAT\t001\n#define OUTPUT_LONG_OBJECT_NAME\t002\n#define OUTPUT_RAW_TIMESTAMP\t004\n#define OUTPUT_PORCELAIN\t010\n#define OUTPUT_SHOW_NAME\t020\n#define OUTPUT_SHOW_NUMBER\t040\n#define OUTPUT_SHOW_SCORE\t0100\n#define OUTPUT_NO_AUTHOR\t0200\n#define OUTPUT_SHOW_EMAIL\t0400\n#define OUTPUT_LINE_PORCELAIN\t01000\n#define OUTPUT_COLOR_LINE\t02000\n#define OUTPUT_SHOW_AGE_WITH_COLOR\t04000\n\nstatic void emit_porcelain_details(struct blame_origin *suspect, int repeat)\n{\n\tif (emit_one_suspect_detail(suspect, repeat) ||\n\t    (suspect->commit->object.flags & MORE_THAN_ONE_PATH))\n\t\twrite_filename_info(suspect);\n}\n\nstatic void emit_porcelain(struct blame_scoreboard *sb, struct blame_entry *ent,\n\t\t\t   int opt)\n{\n\tint repeat = opt & OUTPUT_LINE_PORCELAIN;\n\tint cnt;\n\tconst char *cp;\n\tstruct blame_origin *suspect = ent->suspect;\n\tchar hex[GIT_MAX_HEXSZ + 1];\n\n\toid_to_hex_r(hex, &suspect->commit->object.oid);\n\tprintf(\"%s %d %d %d\\n\",\n\t       hex,\n\t       ent->s_lno + 1,\n\t       ent->lno + 1,\n\t       ent->num_lines);\n\temit_porcelain_details(suspect, repeat);\n\n\tcp = blame_nth_line(sb, ent->lno);\n\tfor (cnt = 0; cnt < ent->num_lines; cnt++) {\n\t\tchar ch;\n\t\tif (cnt) {\n\t\t\tprintf(\"%s %d %d\\n\", hex,\n\t\t\t       ent->s_lno + 1 + cnt,\n\t\t\t       ent->lno + 1 + cnt);\n\t\t\tif (repeat)\n\t\t\t\temit_porcelain_details(suspect, 1);\n\t\t}\n\t\tputchar('\\t');\n\t\tdo {\n\t\t\tch = *cp++;\n\t\t\tputchar(ch);\n\t\t} while (ch != '\\n' &&\n\t\t\t cp < sb->final_buf + sb->final_buf_size);\n\t}\n\n\tif (sb->final_buf_size && cp[-1] != '\\n')\n\t\tputchar('\\n');\n}\n\nstatic struct color_field {\n\ttimestamp_t hop;\n\tchar col[COLOR_MAXLEN];\n} *colorfield;\nstatic int colorfield_nr, colorfield_alloc;\n\nstatic void parse_color_fields(const char *s)\n{\n\tstruct string_list l = STRING_LIST_INIT_DUP;\n\tstruct string_list_item *item;\n\tenum { EXPECT_DATE, EXPECT_COLOR } next = EXPECT_COLOR;\n\n\tcolorfield_nr = 0;\n\n\t/* Ideally this would be stripped and split at the same time? */\n\tstring_list_split(&l, s, ',', -1);\n\tALLOC_GROW(colorfield, colorfield_nr + 1, colorfield_alloc);\n\n\tfor_each_string_list_item(item, &l) {\n\t\tswitch (next) {\n\t\tcase EXPECT_DATE:\n\t\t\tcolorfield[colorfield_nr].hop = approxidate(item->string);\n\t\t\tnext = EXPECT_COLOR;\n\t\t\tcolorfield_nr++;\n\t\t\tALLOC_GROW(colorfield, colorfield_nr + 1, colorfield_alloc);\n\t\t\tbreak;\n\t\tcase EXPECT_COLOR:\n\t\t\tif (color_parse(item->string, colorfield[colorfield_nr].col))\n\t\t\t\tdie(_(\"expecting a color: %s\"), item->string);\n\t\t\tnext = EXPECT_DATE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (next == EXPECT_COLOR)\n\t\tdie(_(\"must end with a color\"));\n\n\tcolorfield[colorfield_nr].hop = TIME_MAX;\n\tstring_list_clear(&l, 0);\n}\n\nstatic void setup_default_color_by_age(void)\n{\n\tparse_color_fields(\"blue,12 month ago,white,1 month ago,red\");\n}\n\nstatic void determine_line_heat(struct blame_entry *ent, const char **dest_color)\n{\n\tint i = 0;\n\tstruct commit_info ci;\n\tget_commit_info(ent->suspect->commit, &ci, 1);\n\n\twhile (i < colorfield_nr && ci.author_time > colorfield[i].hop)\n\t\ti++;\n\n\t*dest_color = colorfield[i].col;\n}\n\nstatic void emit_other(struct blame_scoreboard *sb, struct blame_entry *ent, int opt)\n{\n\tint cnt;\n\tconst char *cp;\n\tstruct blame_origin *suspect = ent->suspect;\n\tstruct commit_info ci;\n\tchar hex[GIT_MAX_HEXSZ + 1];\n\tint show_raw_time = !!(opt & OUTPUT_RAW_TIMESTAMP);\n\tconst char *default_color = NULL, *color = NULL, *reset = NULL;\n\n\tget_commit_info(suspect->commit, &ci, 1);\n\toid_to_hex_r(hex, &suspect->commit->object.oid);\n\n\tcp = blame_nth_line(sb, ent->lno);\n\n\tif (opt & OUTPUT_SHOW_AGE_WITH_COLOR) {\n\t\tdetermine_line_heat(ent, &default_color);\n\t\tcolor = default_color;\n\t\treset = GIT_COLOR_RESET;\n\t}\n\n\tfor (cnt = 0; cnt < ent->num_lines; cnt++) {\n\t\tchar ch;\n\t\tint length = (opt & OUTPUT_LONG_OBJECT_NAME) ? GIT_SHA1_HEXSZ : abbrev;\n\n\t\tif (opt & OUTPUT_COLOR_LINE) {\n\t\t\tif (cnt > 0) {\n\t\t\t\tcolor = repeated_meta_color;\n\t\t\t\treset = GIT_COLOR_RESET;\n\t\t\t} else  {\n\t\t\t\tcolor = default_color ? default_color : NULL;\n\t\t\t\treset = default_color ? GIT_COLOR_RESET : NULL;\n\t\t\t}\n\t\t}\n\t\tif (color)\n\t\t\tfputs(color, stdout);\n\n\t\tif (suspect->commit->object.flags & UNINTERESTING) {\n\t\t\tif (blank_boundary)\n\t\t\t\tmemset(hex, ' ', length);\n\t\t\telse if (!(opt & OUTPUT_ANNOTATE_COMPAT)) {\n\t\t\t\tlength--;\n\t\t\t\tputchar('^');\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%.*s\", length, hex);\n\t\tif (opt & OUTPUT_ANNOTATE_COMPAT) {\n\t\t\tconst char *name;\n\t\t\tif (opt & OUTPUT_SHOW_EMAIL)\n\t\t\t\tname = ci.author_mail.buf;\n\t\t\telse\n\t\t\t\tname = ci.author.buf;\n\t\t\tprintf(\"\\t(%10s\\t%10s\\t%d)\", name,\n\t\t\t       format_time(ci.author_time, ci.author_tz.buf,\n\t\t\t\t\t   show_raw_time),\n\t\t\t       ent->lno + 1 + cnt);\n\t\t} else {\n\t\t\tif (opt & OUTPUT_SHOW_SCORE)\n\t\t\t\tprintf(\" %*d %02d\",\n\t\t\t\t       max_score_digits, ent->score,\n\t\t\t\t       ent->suspect->refcnt);\n\t\t\tif (opt & OUTPUT_SHOW_NAME)\n\t\t\t\tprintf(\" %-*.*s\", longest_file, longest_file,\n\t\t\t\t       suspect->path);\n\t\t\tif (opt & OUTPUT_SHOW_NUMBER)\n\t\t\t\tprintf(\" %*d\", max_orig_digits,\n\t\t\t\t       ent->s_lno + 1 + cnt);\n\n\t\t\tif (!(opt & OUTPUT_NO_AUTHOR)) {\n\t\t\t\tconst char *name;\n\t\t\t\tint pad;\n\t\t\t\tif (opt & OUTPUT_SHOW_EMAIL)\n\t\t\t\t\tname = ci.author_mail.buf;\n\t\t\t\telse\n\t\t\t\t\tname = ci.author.buf;\n\t\t\t\tpad = longest_author - utf8_strwidth(name);\n\t\t\t\tprintf(\" (%s%*s %10s\",\n\t\t\t\t       name, pad, \"\",\n\t\t\t\t       format_time(ci.author_time,\n\t\t\t\t\t\t   ci.author_tz.buf,\n\t\t\t\t\t\t   show_raw_time));\n\t\t\t}\n\t\t\tprintf(\" %*d) \",\n\t\t\t       max_digits, ent->lno + 1 + cnt);\n\t\t}\n\t\tif (reset)\n\t\t\tfputs(reset, stdout);\n\t\tdo {\n\t\t\tch = *cp++;\n\t\t\tputchar(ch);\n\t\t} while (ch != '\\n' &&\n\t\t\t cp < sb->final_buf + sb->final_buf_size);\n\t}\n\n\tif (sb->final_buf_size && cp[-1] != '\\n')\n\t\tputchar('\\n');\n\n\tcommit_info_destroy(&ci);\n}\n\nstatic void output(struct blame_scoreboard *sb, int option)\n{\n\tstruct blame_entry *ent;\n\n\tif (option & OUTPUT_PORCELAIN) {\n\t\tfor (ent = sb->ent; ent; ent = ent->next) {\n\t\t\tint count = 0;\n\t\t\tstruct blame_origin *suspect;\n\t\t\tstruct commit *commit = ent->suspect->commit;\n\t\t\tif (commit->object.flags & MORE_THAN_ONE_PATH)\n\t\t\t\tcontinue;\n\t\t\tfor (suspect = get_blame_suspects(commit); suspect; suspect = suspect->next) {\n\t\t\t\tif (suspect->guilty && count++) {\n\t\t\t\t\tcommit->object.flags |= MORE_THAN_ONE_PATH;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (ent = sb->ent; ent; ent = ent->next) {\n\t\tif (option & OUTPUT_PORCELAIN)\n\t\t\temit_porcelain(sb, ent, option);\n\t\telse {\n\t\t\temit_other(sb, ent, option);\n\t\t}\n\t}\n}\n\n/*\n * Add phony grafts for use with -S; this is primarily to\n * support git's cvsserver that wants to give a linear history\n * to its clients.\n */\nstatic int read_ancestry(const char *graft_file)\n{\n\tFILE *fp = fopen_or_warn(graft_file, \"r\");\n\tstruct strbuf buf = STRBUF_INIT;\n\tif (!fp)\n\t\treturn -1;\n\twhile (!strbuf_getwholeline(&buf, fp, '\\n')) {\n\t\t/* The format is just \"Commit Parent1 Parent2 ...\\n\" */\n\t\tstruct commit_graft *graft = read_graft_line(&buf);\n\t\tif (graft)\n\t\t\tregister_commit_graft(the_repository, graft, 0);\n\t}\n\tfclose(fp);\n\tstrbuf_release(&buf);\n\treturn 0;\n}\n\nstatic int update_auto_abbrev(int auto_abbrev, struct blame_origin *suspect)\n{\n\tconst char *uniq = find_unique_abbrev(&suspect->commit->object.oid,\n\t\t\t\t\t      auto_abbrev);\n\tint len = strlen(uniq);\n\tif (auto_abbrev < len)\n\t\treturn len;\n\treturn auto_abbrev;\n}\n\n/*\n * How many columns do we need to show line numbers, authors,\n * and filenames?\n */\nstatic void find_alignment(struct blame_scoreboard *sb, int *option)\n{\n\tint longest_src_lines = 0;\n\tint longest_dst_lines = 0;\n\tunsigned largest_score = 0;\n\tstruct blame_entry *e;\n\tint compute_auto_abbrev = (abbrev < 0);\n\tint auto_abbrev = DEFAULT_ABBREV;\n\n\tfor (e = sb->ent; e; e = e->next) {\n\t\tstruct blame_origin *suspect = e->suspect;\n\t\tint num;\n\n\t\tif (compute_auto_abbrev)\n\t\t\tauto_abbrev = update_auto_abbrev(auto_abbrev, suspect);\n\t\tif (strcmp(suspect->path, sb->path))\n\t\t\t*option |= OUTPUT_SHOW_NAME;\n\t\tnum = strlen(suspect->path);\n\t\tif (longest_file < num)\n\t\t\tlongest_file = num;\n\t\tif (!(suspect->commit->object.flags & METAINFO_SHOWN)) {\n\t\t\tstruct commit_info ci;\n\t\t\tsuspect->commit->object.flags |= METAINFO_SHOWN;\n\t\t\tget_commit_info(suspect->commit, &ci, 1);\n\t\t\tif (*option & OUTPUT_SHOW_EMAIL)\n\t\t\t\tnum = utf8_strwidth(ci.author_mail.buf);\n\t\t\telse\n\t\t\t\tnum = utf8_strwidth(ci.author.buf);\n\t\t\tif (longest_author < num)\n\t\t\t\tlongest_author = num;\n\t\t\tcommit_info_destroy(&ci);\n\t\t}\n\t\tnum = e->s_lno + e->num_lines;\n\t\tif (longest_src_lines < num)\n\t\t\tlongest_src_lines = num;\n\t\tnum = e->lno + e->num_lines;\n\t\tif (longest_dst_lines < num)\n\t\t\tlongest_dst_lines = num;\n\t\tif (largest_score < blame_entry_score(sb, e))\n\t\t\tlargest_score = blame_entry_score(sb, e);\n\t}\n\tmax_orig_digits = decimal_width(longest_src_lines);\n\tmax_digits = decimal_width(longest_dst_lines);\n\tmax_score_digits = decimal_width(largest_score);\n\n\tif (compute_auto_abbrev)\n\t\t/* one more abbrev length is needed for the boundary commit */\n\t\tabbrev = auto_abbrev + 1;\n}\n\nstatic void sanity_check_on_fail(struct blame_scoreboard *sb, int baa)\n{\n\tint opt = OUTPUT_SHOW_SCORE | OUTPUT_SHOW_NUMBER | OUTPUT_SHOW_NAME;\n\tfind_alignment(sb, &opt);\n\toutput(sb, opt);\n\tdie(\"Baa %d!\", baa);\n}\n\nstatic unsigned parse_score(const char *arg)\n{\n\tchar *end;\n\tunsigned long score = strtoul(arg, &end, 10);\n\tif (*end)\n\t\treturn 0;\n\treturn score;\n}\n\nstatic const char *add_prefix(const char *prefix, const char *path)\n{\n\treturn prefix_path(prefix, prefix ? strlen(prefix) : 0, path);\n}\n\nstatic int git_blame_config(const char *var, const char *value, void *cb)\n{\n\tif (!strcmp(var, \"blame.showroot\")) {\n\t\tshow_root = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\tif (!strcmp(var, \"blame.blankboundary\")) {\n\t\tblank_boundary = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\tif (!strcmp(var, \"blame.showemail\")) {\n\t\tint *output_option = cb;\n\t\tif (git_config_bool(var, value))\n\t\t\t*output_option |= OUTPUT_SHOW_EMAIL;\n\t\telse\n\t\t\t*output_option &= ~OUTPUT_SHOW_EMAIL;\n\t\treturn 0;\n\t}\n\tif (!strcmp(var, \"blame.date\")) {\n\t\tif (!value)\n\t\t\treturn config_error_nonbool(var);\n\t\tparse_date_format(value, &blame_date_mode);\n\t\treturn 0;\n\t}\n\tif (!strcmp(var, \"color.blame.repeatedlines\")) {\n\t\tif (color_parse_mem(value, strlen(value), repeated_meta_color))\n\t\t\twarning(_(\"invalid color '%s' in color.blame.repeatedLines\"),\n\t\t\t\tvalue);\n\t\treturn 0;\n\t}\n\tif (!strcmp(var, \"color.blame.highlightrecent\")) {\n\t\tparse_color_fields(value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(var, \"blame.coloring\")) {\n\t\tif (!strcmp(value, \"repeatedLines\")) {\n\t\t\tcoloring_mode |= OUTPUT_COLOR_LINE;\n\t\t} else if (!strcmp(value, \"highlightRecent\")) {\n\t\t\tcoloring_mode |= OUTPUT_SHOW_AGE_WITH_COLOR;\n\t\t} else if (!strcmp(value, \"none\")) {\n\t\t\tcoloring_mode &= ~(OUTPUT_COLOR_LINE |\n\t\t\t\t\t    OUTPUT_SHOW_AGE_WITH_COLOR);\n\t\t} else {\n\t\t\twarning(_(\"invalid value for blame.coloring\"));\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (git_diff_heuristic_config(var, value, cb) < 0)\n\t\treturn -1;\n\tif (userdiff_config(var, value) < 0)\n\t\treturn -1;\n\n\treturn git_default_config(var, value, cb);\n}\n\nstatic int blame_copy_callback(const struct option *option, const char *arg, int unset)\n{\n\tint *opt = option->value;\n\n\tBUG_ON_OPT_NEG(unset);\n\n\t/*\n\t * -C enables copy from removed files;\n\t * -C -C enables copy from existing files, but only\n\t *       when blaming a new file;\n\t * -C -C -C enables copy from existing files for\n\t *          everybody\n\t */\n\tif (*opt & PICKAXE_BLAME_COPY_HARDER)\n\t\t*opt |= PICKAXE_BLAME_COPY_HARDEST;\n\tif (*opt & PICKAXE_BLAME_COPY)\n\t\t*opt |= PICKAXE_BLAME_COPY_HARDER;\n\t*opt |= PICKAXE_BLAME_COPY | PICKAXE_BLAME_MOVE;\n\n\tif (arg)\n\t\tblame_copy_score = parse_score(arg);\n\treturn 0;\n}\n\nstatic int blame_move_callback(const struct option *option, const char *arg, int unset)\n{\n\tint *opt = option->value;\n\n\tBUG_ON_OPT_NEG(unset);\n\n\t*opt |= PICKAXE_BLAME_MOVE;\n\n\tif (arg)\n\t\tblame_move_score = parse_score(arg);\n\treturn 0;\n}\n\nstatic int is_a_rev(const char *name)\n{\n\tstruct object_id oid;\n\n\tif (get_oid(name, &oid))\n\t\treturn 0;\n\treturn OBJ_NONE < oid_object_info(the_repository, &oid, NULL);\n}\n\nint cmd_blame(int argc, const char **argv, const char *prefix)\n{\n\tstruct rev_info revs;\n\tconst char *path;\n\tstruct blame_scoreboard sb;\n\tstruct blame_origin *o;\n\tstruct blame_entry *ent = NULL;\n\tlong dashdash_pos, lno;\n\tstruct progress_info pi = { NULL, 0 };\n\n\tstruct string_list range_list = STRING_LIST_INIT_NODUP;\n\tint output_option = 0, opt = 0;\n\tint show_stats = 0;\n\tconst char *revs_file = NULL;\n\tconst char *contents_from = NULL;\n\tconst struct option options[] = {\n\t\tOPT_BOOL(0, \"incremental\", &incremental, N_(\"Show blame entries as we find them, incrementally\")),\n\t\tOPT_BOOL('b', NULL, &blank_boundary, N_(\"Show blank SHA-1 for boundary commits (Default: off)\")),\n\t\tOPT_BOOL(0, \"root\", &show_root, N_(\"Do not treat root commits as boundaries (Default: off)\")),\n\t\tOPT_BOOL(0, \"show-stats\", &show_stats, N_(\"Show work cost statistics\")),\n\t\tOPT_BOOL(0, \"progress\", &show_progress, N_(\"Force progress reporting\")),\n\t\tOPT_BIT(0, \"score-debug\", &output_option, N_(\"Show output score for blame entries\"), OUTPUT_SHOW_SCORE),\n\t\tOPT_BIT('f', \"show-name\", &output_option, N_(\"Show original filename (Default: auto)\"), OUTPUT_SHOW_NAME),\n\t\tOPT_BIT('n', \"show-number\", &output_option, N_(\"Show original linenumber (Default: off)\"), OUTPUT_SHOW_NUMBER),\n\t\tOPT_BIT('p', \"porcelain\", &output_option, N_(\"Show in a format designed for machine consumption\"), OUTPUT_PORCELAIN),\n\t\tOPT_BIT(0, \"line-porcelain\", &output_option, N_(\"Show porcelain format with per-line commit information\"), OUTPUT_PORCELAIN|OUTPUT_LINE_PORCELAIN),\n\t\tOPT_BIT('c', NULL, &output_option, N_(\"Use the same output mode as git-annotate (Default: off)\"), OUTPUT_ANNOTATE_COMPAT),\n\t\tOPT_BIT('t', NULL, &output_option, N_(\"Show raw timestamp (Default: off)\"), OUTPUT_RAW_TIMESTAMP),\n\t\tOPT_BIT('l', NULL, &output_option, N_(\"Show long commit SHA1 (Default: off)\"), OUTPUT_LONG_OBJECT_NAME),\n\t\tOPT_BIT('s', NULL, &output_option, N_(\"Suppress author name and timestamp (Default: off)\"), OUTPUT_NO_AUTHOR),\n\t\tOPT_BIT('e', \"show-email\", &output_option, N_(\"Show author email instead of name (Default: off)\"), OUTPUT_SHOW_EMAIL),\n\t\tOPT_BIT('w', NULL, &xdl_opts, N_(\"Ignore whitespace differences\"), XDF_IGNORE_WHITESPACE),\n\t\tOPT_BIT(0, \"color-lines\", &output_option, N_(\"color redundant metadata from previous line differently\"), OUTPUT_COLOR_LINE),\n\t\tOPT_BIT(0, \"color-by-age\", &output_option, N_(\"color lines by age\"), OUTPUT_SHOW_AGE_WITH_COLOR),\n\n\t\t/*\n\t\t * The following two options are parsed by parse_revision_opt()\n\t\t * and are only included here to get included in the \"-h\"\n\t\t * output:\n\t\t */\n\t\t{ OPTION_LOWLEVEL_CALLBACK, 0, \"indent-heuristic\", NULL, NULL, N_(\"Use an experimental heuristic to improve diffs\"), PARSE_OPT_NOARG, parse_opt_unknown_cb },\n\n\t\tOPT_BIT(0, \"minimal\", &xdl_opts, N_(\"Spend extra cycles to find better match\"), XDF_NEED_MINIMAL),\n\t\tOPT_STRING('S', NULL, &revs_file, N_(\"file\"), N_(\"Use revisions from <file> instead of calling git-rev-list\")),\n\t\tOPT_STRING(0, \"contents\", &contents_from, N_(\"file\"), N_(\"Use <file>'s contents as the final image\")),\n\t\t{ OPTION_CALLBACK, 'C', NULL, &opt, N_(\"score\"), N_(\"Find line copies within and across files\"), PARSE_OPT_OPTARG, blame_copy_callback },\n\t\t{ OPTION_CALLBACK, 'M', NULL, &opt, N_(\"score\"), N_(\"Find line movements within and across files\"), PARSE_OPT_OPTARG, blame_move_callback },\n\t\tOPT_STRING_LIST('L', NULL, &range_list, N_(\"n,m\"), N_(\"Process only line range n,m, counting from 1\")),\n\t\tOPT__ABBREV(&abbrev),\n\t\tOPT_END()\n\t};\n\n\tstruct parse_opt_ctx_t ctx;\n\tint cmd_is_annotate = !strcmp(argv[0], \"annotate\");\n\tstruct range_set ranges;\n\tunsigned int range_i;\n\tlong anchor;\n\n\tsetup_default_color_by_age();\n\tgit_config(git_blame_config, &output_option);\n\trepo_init_revisions(the_repository, &revs, NULL);\n\trevs.date_mode = blame_date_mode;\n\trevs.diffopt.flags.allow_textconv = 1;\n\trevs.diffopt.flags.follow_renames = 1;\n\n\tsave_commit_buffer = 0;\n\tdashdash_pos = 0;\n\tshow_progress = -1;\n\n\tparse_options_start(&ctx, argc, argv, prefix, options,\n\t\t\t    PARSE_OPT_KEEP_DASHDASH | PARSE_OPT_KEEP_ARGV0);\n\tfor (;;) {\n\t\tswitch (parse_options_step(&ctx, options, blame_opt_usage)) {\n\t\tcase PARSE_OPT_HELP:\n\t\tcase PARSE_OPT_ERROR:\n\t\t\texit(129);\n\t\tcase PARSE_OPT_COMPLETE:\n\t\t\texit(0);\n\t\tcase PARSE_OPT_DONE:\n\t\t\tif (ctx.argv[0])\n\t\t\t\tdashdash_pos = ctx.cpidx;\n\t\t\tgoto parse_done;\n\t\t}\n\n\t\tif (!strcmp(ctx.argv[0], \"--reverse\")) {\n\t\t\tctx.argv[0] = \"--children\";\n\t\t\treverse = 1;\n\t\t}\n\t\tparse_revision_opt(&revs, &ctx, options, blame_opt_usage);\n\t}\nparse_done:\n\tno_whole_file_rename = !revs.diffopt.flags.follow_renames;\n\txdl_opts |= revs.diffopt.xdl_opts & XDF_INDENT_HEURISTIC;\n\trevs.diffopt.flags.follow_renames = 0;\n\targc = parse_options_end(&ctx);\n\n\tif (incremental || (output_option & OUTPUT_PORCELAIN)) {\n\t\tif (show_progress > 0)\n\t\t\tdie(_(\"--progress can't be used with --incremental or porcelain formats\"));\n\t\tshow_progress = 0;\n\t} else if (show_progress < 0)\n\t\tshow_progress = isatty(2);\n\n\tif (0 < abbrev && abbrev < GIT_SHA1_HEXSZ)\n\t\t/* one more abbrev length is needed for the boundary commit */\n\t\tabbrev++;\n\telse if (!abbrev)\n\t\tabbrev = GIT_SHA1_HEXSZ;\n\n\tif (revs_file && read_ancestry(revs_file))\n\t\tdie_errno(\"reading graft file '%s' failed\", revs_file);\n\n\tif (cmd_is_annotate) {\n\t\toutput_option |= OUTPUT_ANNOTATE_COMPAT;\n\t\tblame_date_mode.type = DATE_ISO8601;\n\t} else {\n\t\tblame_date_mode = revs.date_mode;\n\t}\n\n\t/* The maximum width used to show the dates */\n\tswitch (blame_date_mode.type) {\n\tcase DATE_RFC2822:\n\t\tblame_date_width = sizeof(\"Thu, 19 Oct 2006 16:00:04 -0700\");\n\t\tbreak;\n\tcase DATE_ISO8601_STRICT:\n\t\tblame_date_width = sizeof(\"2006-10-19T16:00:04-07:00\");\n\t\tbreak;\n\tcase DATE_ISO8601:\n\t\tblame_date_width = sizeof(\"2006-10-19 16:00:04 -0700\");\n\t\tbreak;\n\tcase DATE_RAW:\n\t\tblame_date_width = sizeof(\"1161298804 -0700\");\n\t\tbreak;\n\tcase DATE_UNIX:\n\t\tblame_date_width = sizeof(\"1161298804\");\n\t\tbreak;\n\tcase DATE_SHORT:\n\t\tblame_date_width = sizeof(\"2006-10-19\");\n\t\tbreak;\n\tcase DATE_RELATIVE:\n\t\t/*\n\t\t * TRANSLATORS: This string is used to tell us the\n\t\t * maximum display width for a relative timestamp in\n\t\t * \"git blame\" output.  For C locale, \"4 years, 11\n\t\t * months ago\", which takes 22 places, is the longest\n\t\t * among various forms of relative timestamps, but\n\t\t * your language may need more or fewer display\n\t\t * columns.\n\t\t */\n\t\tblame_date_width = utf8_strwidth(_(\"4 years, 11 months ago\")) + 1; /* add the null */\n\t\tbreak;\n\tcase DATE_NORMAL:\n\t\tblame_date_width = sizeof(\"Thu Oct 19 16:00:04 2006 -0700\");\n\t\tbreak;\n\tcase DATE_STRFTIME:\n\t\tblame_date_width = strlen(show_date(0, 0, &blame_date_mode)) + 1; /* add the null */\n\t\tbreak;\n\t}\n\tblame_date_width -= 1; /* strip the null */\n\n\tif (revs.diffopt.flags.find_copies_harder)\n\t\topt |= (PICKAXE_BLAME_COPY | PICKAXE_BLAME_MOVE |\n\t\t\tPICKAXE_BLAME_COPY_HARDER);\n\n\t/*\n\t * We have collected options unknown to us in argv[1..unk]\n\t * which are to be passed to revision machinery if we are\n\t * going to do the \"bottom\" processing.\n\t *\n\t * The remaining are:\n\t *\n\t * (1) if dashdash_pos != 0, it is either\n\t *     \"blame [revisions] -- <path>\" or\n\t *     \"blame -- <path> <rev>\"\n\t *\n\t * (2) otherwise, it is one of the two:\n\t *     \"blame [revisions] <path>\"\n\t *     \"blame <path> <rev>\"\n\t *\n\t * Note that we must strip out <path> from the arguments: we do not\n\t * want the path pruning but we may want \"bottom\" processing.\n\t */\n\tif (dashdash_pos) {\n\t\tswitch (argc - dashdash_pos - 1) {\n\t\tcase 2: /* (1b) */\n\t\t\tif (argc != 4)\n\t\t\t\tusage_with_options(blame_opt_usage, options);\n\t\t\t/* reorder for the new way: <rev> -- <path> */\n\t\t\targv[1] = argv[3];\n\t\t\targv[3] = argv[2];\n\t\t\targv[2] = \"--\";\n\t\t\t/* FALLTHROUGH */\n\t\tcase 1: /* (1a) */\n\t\t\tpath = add_prefix(prefix, argv[--argc]);\n\t\t\targv[argc] = NULL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage_with_options(blame_opt_usage, options);\n\t\t}\n\t} else {\n\t\tif (argc < 2)\n\t\t\tusage_with_options(blame_opt_usage, options);\n\t\tif (argc == 3 && is_a_rev(argv[argc - 1])) { /* (2b) */\n\t\t\tpath = add_prefix(prefix, argv[1]);\n\t\t\targv[1] = argv[2];\n\t\t} else {\t/* (2a) */\n\t\t\tif (argc == 2 && is_a_rev(argv[1]) && !get_git_work_tree())\n\t\t\t\tdie(\"missing <path> to blame\");\n\t\t\tpath = add_prefix(prefix, argv[argc - 1]);\n\t\t}\n\t\targv[argc - 1] = \"--\";\n\t}\n\n\trevs.disable_stdin = 1;\n\tsetup_revisions(argc, argv, &revs, NULL);\n\n\tinit_scoreboard(&sb);\n\tsb.revs = &revs;\n\tsb.contents_from = contents_from;\n\tsb.reverse = reverse;\n\tsb.repo = the_repository;\n\tsetup_scoreboard(&sb, path, &o);\n\tlno = sb.num_lines;\n\n\tif (lno && !range_list.nr)\n\t\tstring_list_append(&range_list, \"1\");\n\n\tanchor = 1;\n\trange_set_init(&ranges, range_list.nr);\n\tfor (range_i = 0; range_i < range_list.nr; ++range_i) {\n\t\tlong bottom, top;\n\t\tif (parse_range_arg(range_list.items[range_i].string,\n\t\t\t\t    nth_line_cb, &sb, lno, anchor,\n\t\t\t\t    &bottom, &top, sb.path,\n\t\t\t\t    the_repository->index))\n\t\t\tusage(blame_usage);\n\t\tif ((!lno && (top || bottom)) || lno < bottom)\n\t\t\tdie(Q_(\"file %s has only %lu line\",\n\t\t\t       \"file %s has only %lu lines\",\n\t\t\t       lno), path, lno);\n\t\tif (bottom < 1)\n\t\t\tbottom = 1;\n\t\tif (top < 1 || lno < top)\n\t\t\ttop = lno;\n\t\tbottom--;\n\t\trange_set_append_unsafe(&ranges, bottom, top);\n\t\tanchor = top + 1;\n\t}\n\tsort_and_merge_range_set(&ranges);\n\n\tfor (range_i = ranges.nr; range_i > 0; --range_i) {\n\t\tconst struct range *r = &ranges.ranges[range_i - 1];\n\t\tent = blame_entry_prepend(ent, r->start, r->end, o);\n\t}\n\n\to->suspects = ent;\n\tprio_queue_put(&sb.commits, o->commit);\n\n\tblame_origin_decref(o);\n\n\trange_set_release(&ranges);\n\tstring_list_clear(&range_list, 0);\n\n\tsb.ent = NULL;\n\tsb.path = path;\n\n\tif (blame_move_score)\n\t\tsb.move_score = blame_move_score;\n\tif (blame_copy_score)\n\t\tsb.copy_score = blame_copy_score;\n\n\tsb.debug = DEBUG;\n\tsb.on_sanity_fail = &sanity_check_on_fail;\n\n\tsb.show_root = show_root;\n\tsb.xdl_opts = xdl_opts;\n\tsb.no_whole_file_rename = no_whole_file_rename;\n\n\tread_mailmap(&mailmap, NULL);\n\n\tsb.found_guilty_entry = &found_guilty_entry;\n\tsb.found_guilty_entry_data = &pi;\n\tif (show_progress)\n\t\tpi.progress = start_delayed_progress(_(\"Blaming lines\"), sb.num_lines);\n\n\tassign_blame(&sb, opt);\n\n\tstop_progress(&pi.progress);\n\n\tif (!incremental)\n\t\tsetup_pager();\n\telse\n\t\treturn 0;\n\n\tblame_sort_final(&sb);\n\n\tblame_coalesce(&sb);\n\n\tif (!(output_option & (OUTPUT_COLOR_LINE | OUTPUT_SHOW_AGE_WITH_COLOR)))\n\t\toutput_option |= coloring_mode;\n\n\tif (!(output_option & OUTPUT_PORCELAIN)) {\n\t\tfind_alignment(&sb, &output_option);\n\t\tif (!*repeated_meta_color &&\n\t\t    (output_option & OUTPUT_COLOR_LINE))\n\t\t\txsnprintf(repeated_meta_color,\n\t\t\t\t  sizeof(repeated_meta_color),\n\t\t\t\t  \"%s\", GIT_COLOR_CYAN);\n\t}\n\tif (output_option & OUTPUT_ANNOTATE_COMPAT)\n\t\toutput_option &= ~(OUTPUT_COLOR_LINE | OUTPUT_SHOW_AGE_WITH_COLOR);\n\n\toutput(&sb, output_option);\n\tfree((void *)sb.final_buf);\n\tfor (ent = sb.ent; ent; ) {\n\t\tstruct blame_entry *e = ent->next;\n\t\tfree(ent);\n\t\tent = e;\n\t}\n\n\tif (show_stats) {\n\t\tprintf(\"num read blob: %d\\n\", sb.num_read_blob);\n\t\tprintf(\"num get patch: %d\\n\", sb.num_get_patch);\n\t\tprintf(\"num commits: %d\\n\", sb.num_commits);\n\t}\n\treturn 0;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0074ed311c8b6c26770f62a668f51abda316ec46",
  "sha1_ok": true,
  "size": 30740
}
