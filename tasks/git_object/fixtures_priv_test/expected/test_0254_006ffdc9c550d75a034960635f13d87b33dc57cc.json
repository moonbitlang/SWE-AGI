{
  "content": {
    "base64": "I2luY2x1ZGUgImJ1aWx0aW4uaCIKI2luY2x1ZGUgImNvbmZpZy5oIgojaW5jbHVkZSAiZGVsdGEuaCIKI2luY2x1ZGUgImVudmlyb25tZW50LmgiCiNpbmNsdWRlICJnZXR0ZXh0LmgiCiNpbmNsdWRlICJoZXguaCIKI2luY2x1ZGUgInBhY2suaCIKI2luY2x1ZGUgImNzdW0tZmlsZS5oIgojaW5jbHVkZSAiYmxvYi5oIgojaW5jbHVkZSAiY29tbWl0LmgiCiNpbmNsdWRlICJ0YWcuaCIKI2luY2x1ZGUgInRyZWUuaCIKI2luY2x1ZGUgInByb2dyZXNzLmgiCiNpbmNsdWRlICJmc2NrLmgiCiNpbmNsdWRlICJleGVjLWNtZC5oIgojaW5jbHVkZSAic3RyYnVmLmgiCiNpbmNsdWRlICJzdHJlYW1pbmcuaCIKI2luY2x1ZGUgInRocmVhZC11dGlscy5oIgojaW5jbHVkZSAicGFja2ZpbGUuaCIKI2luY2x1ZGUgInBhY2stcmV2aW5kZXguaCIKI2luY2x1ZGUgIm9iamVjdC1maWxlLmgiCiNpbmNsdWRlICJvYmplY3Qtc3RvcmUtbGwuaCIKI2luY2x1ZGUgIm9pZC1hcnJheS5oIgojaW5jbHVkZSAicmVwbGFjZS1vYmplY3QuaCIKI2luY2x1ZGUgInByb21pc29yLXJlbW90ZS5oIgojaW5jbHVkZSAic2V0dXAuaCIKCnN0YXRpYyBjb25zdCBjaGFyIGluZGV4X3BhY2tfdXNhZ2VbXSA9CiJnaXQgaW5kZXgtcGFjayBbLXZdIFstbyA8aW5kZXgtZmlsZT5dIFstLWtlZXAgfCAtLWtlZXA9PG1zZz5dIFstLVtuby1dcmV2LWluZGV4XSBbLS12ZXJpZnldIFstLXN0cmljdF0gKDxwYWNrLWZpbGU+IHwgLS1zdGRpbiBbLS1maXgtdGhpbl0gWzxwYWNrLWZpbGU+XSkiOwoKc3RydWN0IG9iamVjdF9lbnRyeSB7CglzdHJ1Y3QgcGFja19pZHhfZW50cnkgaWR4OwoJdW5zaWduZWQgbG9uZyBzaXplOwoJdW5zaWduZWQgY2hhciBoZHJfc2l6ZTsKCXNpZ25lZCBjaGFyIHR5cGU7CglzaWduZWQgY2hhciByZWFsX3R5cGU7Cn07CgpzdHJ1Y3Qgb2JqZWN0X3N0YXQgewoJdW5zaWduZWQgZGVsdGFfZGVwdGg7CglpbnQgYmFzZV9vYmplY3Rfbm87Cn07CgpzdHJ1Y3QgYmFzZV9kYXRhIHsKCS8qIEluaXRpYWxpemVkIGJ5IG1ha2VfYmFzZSgpLiAqLwoJc3RydWN0IGJhc2VfZGF0YSAqYmFzZTsKCXN0cnVjdCBvYmplY3RfZW50cnkgKm9iajsKCWludCByZWZfZmlyc3QsIHJlZl9sYXN0OwoJaW50IG9mc19maXJzdCwgb2ZzX2xhc3Q7CgkvKgoJICogVGhyZWFkcyBzaG91bGQgaW5jcmVtZW50IHJldGFpbl9kYXRhIGlmIHRoZXkgYXJlIGFib3V0IHRvIGNhbGwKCSAqIHBhdGNoX2RlbHRhKCkgdXNpbmcgdGhpcyBzdHJ1Y3QncyBkYXRhIGFzIGEgYmFzZSwgYW5kIGRlY3JlbWVudCB0aGlzCgkgKiB3aGVuIHRoZXkgYXJlIGRvbmUuIFdoaWxlIHJldGFpbl9kYXRhIGlzIG5vbnplcm8sIHRoaXMgc3RydWN0J3MgZGF0YQoJICogd2lsbCBub3QgYmUgZnJlZWQgZXZlbiBpZiB0aGUgZGVsdGEgYmFzZSBjYWNoZSBsaW1pdCBpcyBleGNlZWRlZC4KCSAqLwoJaW50IHJldGFpbl9kYXRhOwoJLyoKCSAqIFRoZSBudW1iZXIgb2YgZGlyZWN0IGNoaWxkcmVuIHRoYXQgaGF2ZSBub3QgYmVlbiBmdWxseSBwcm9jZXNzZWQKCSAqIChlbnRlcmVkIHdvcmtfaGVhZCwgZW50ZXJlZCBkb25lX2hlYWQsIGxlZnQgZG9uZV9oZWFkKS4gV2hlbiB0aGlzCgkgKiBudW1iZXIgcmVhY2hlcyB6ZXJvLCB0aGlzIHN0cnVjdCBiYXNlX2RhdGEgY2FuIGJlIGZyZWVkLgoJICovCglpbnQgY2hpbGRyZW5fcmVtYWluaW5nOwoKCS8qIE5vdCBpbml0aWFsaXplZCBieSBtYWtlX2Jhc2UoKS4gKi8KCXN0cnVjdCBsaXN0X2hlYWQgbGlzdDsKCXZvaWQgKmRhdGE7Cgl1bnNpZ25lZCBsb25nIHNpemU7Cn07CgovKgogKiBTdGFjayBvZiBzdHJ1Y3QgYmFzZV9kYXRhIHRoYXQgaGF2ZSB1bnByb2Nlc3NlZCBjaGlsZHJlbi4KICogdGhyZWFkZWRfc2Vjb25kX3Bhc3MoKSB1c2VzIHRoaXMgYXMgYSBzb3VyY2Ugb2Ygd29yayAodGhlIG90aGVyIGJlaW5nIHRoZQogKiBvYmplY3RzIGFycmF5KS4KICoKICogR3VhcmRlZCBieSB3b3JrX211dGV4LgogKi8Kc3RhdGljIExJU1RfSEVBRCh3b3JrX2hlYWQpOwoKLyoKICogU3RhY2sgb2Ygc3RydWN0IGJhc2VfZGF0YSB0aGF0IGhhdmUgY2hpbGRyZW4sIGFsbCBvZiB3aG9tIGhhdmUgYmVlbgogKiBwcm9jZXNzZWQgb3IgYXJlIGJlaW5nIHByb2Nlc3NlZCwgYW5kIGF0IGxlYXN0IG9uZSBjaGlsZCBpcyBiZWluZyBwcm9jZXNzZWQuCiAqIFRoZXNlIHN0cnVjdCBiYXNlX2RhdGEgbXVzdCBiZSBrZXB0IGFyb3VuZCB1bnRpbCB0aGUgbGFzdCBjaGlsZCBpcwogKiBwcm9jZXNzZWQuCiAqCiAqIEd1YXJkZWQgYnkgd29ya19tdXRleC4KICovCnN0YXRpYyBMSVNUX0hFQUQoZG9uZV9oZWFkKTsKCi8qCiAqIEFsbCB0aHJlYWRzIHNoYXJlIG9uZSBkZWx0YSBiYXNlIGNhY2hlLgogKgogKiBiYXNlX2NhY2hlX3VzZWQgaXMgZ3VhcmRlZCBieSB3b3JrX211dGV4LCBhbmQgYmFzZV9jYWNoZV9saW1pdCBpcyByZWFkLW9ubHkKICogaW4gYSB0aHJlYWQuCiAqLwpzdGF0aWMgc2l6ZV90IGJhc2VfY2FjaGVfdXNlZDsKc3RhdGljIHNpemVfdCBiYXNlX2NhY2hlX2xpbWl0OwoKc3RydWN0IHRocmVhZF9sb2NhbCB7CglwdGhyZWFkX3QgdGhyZWFkOwoJaW50IHBhY2tfZmQ7Cn07CgovKiBSZW1lbWJlciB0byB1cGRhdGUgb2JqZWN0IGZsYWcgYWxsb2NhdGlvbiBpbiBvYmplY3QuaCAqLwojZGVmaW5lIEZMQUdfTElOSyAoMXU8PDIwKQojZGVmaW5lIEZMQUdfQ0hFQ0tFRCAoMXU8PDIxKQoKc3RydWN0IG9mc19kZWx0YV9lbnRyeSB7CglvZmZfdCBvZmZzZXQ7CglpbnQgb2JqX25vOwp9OwoKc3RydWN0IHJlZl9kZWx0YV9lbnRyeSB7CglzdHJ1Y3Qgb2JqZWN0X2lkIG9pZDsKCWludCBvYmpfbm87Cn07CgpzdGF0aWMgc3RydWN0IG9iamVjdF9lbnRyeSAqb2JqZWN0czsKc3RhdGljIHN0cnVjdCBvYmplY3Rfc3RhdCAqb2JqX3N0YXQ7CnN0YXRpYyBzdHJ1Y3Qgb2ZzX2RlbHRhX2VudHJ5ICpvZnNfZGVsdGFzOwpzdGF0aWMgc3RydWN0IHJlZl9kZWx0YV9lbnRyeSAqcmVmX2RlbHRhczsKc3RhdGljIHN0cnVjdCB0aHJlYWRfbG9jYWwgbm90aHJlYWRfZGF0YTsKc3RhdGljIGludCBucl9vYmplY3RzOwpzdGF0aWMgaW50IG5yX29mc19kZWx0YXM7CnN0YXRpYyBpbnQgbnJfcmVmX2RlbHRhczsKc3RhdGljIGludCByZWZfZGVsdGFzX2FsbG9jOwpzdGF0aWMgaW50IG5yX3Jlc29sdmVkX2RlbHRhczsKc3RhdGljIGludCBucl90aHJlYWRzOwoKc3RhdGljIGludCBmcm9tX3N0ZGluOwpzdGF0aWMgaW50IHN0cmljdDsKc3RhdGljIGludCBkb19mc2NrX29iamVjdDsKc3RhdGljIHN0cnVjdCBmc2NrX29wdGlvbnMgZnNja19vcHRpb25zID0gRlNDS19PUFRJT05TX01JU1NJTkdfR0lUTU9EVUxFUzsKc3RhdGljIGludCB2ZXJib3NlOwpzdGF0aWMgY29uc3QgY2hhciAqcHJvZ3Jlc3NfdGl0bGU7CnN0YXRpYyBpbnQgc2hvd19yZXNvbHZpbmdfcHJvZ3Jlc3M7CnN0YXRpYyBpbnQgc2hvd19zdGF0OwpzdGF0aWMgaW50IGNoZWNrX3NlbGZfY29udGFpbmVkX2FuZF9jb25uZWN0ZWQ7CgpzdGF0aWMgc3RydWN0IHByb2dyZXNzICpwcm9ncmVzczsKCi8qIFdlIGFsd2F5cyByZWFkIGluIDRrQiBjaHVua3MuICovCnN0YXRpYyB1bnNpZ25lZCBjaGFyIGlucHV0X2J1ZmZlcls0MDk2XTsKc3RhdGljIHVuc2lnbmVkIGludCBpbnB1dF9vZmZzZXQsIGlucHV0X2xlbjsKc3RhdGljIG9mZl90IGNvbnN1bWVkX2J5dGVzOwpzdGF0aWMgb2ZmX3QgbWF4X2lucHV0X3NpemU7CnN0YXRpYyB1bnNpZ25lZCBkZWVwZXN0X2RlbHRhOwpzdGF0aWMgZ2l0X2hhc2hfY3R4IGlucHV0X2N0eDsKc3RhdGljIHVpbnQzMl90IGlucHV0X2NyYzMyOwpzdGF0aWMgaW50IGlucHV0X2ZkLCBvdXRwdXRfZmQ7CnN0YXRpYyBjb25zdCBjaGFyICpjdXJyX3BhY2s7CgpzdGF0aWMgc3RydWN0IHRocmVhZF9sb2NhbCAqdGhyZWFkX2RhdGE7CnN0YXRpYyBpbnQgbnJfZGlzcGF0Y2hlZDsKc3RhdGljIGludCB0aHJlYWRzX2FjdGl2ZTsKCnN0YXRpYyBwdGhyZWFkX211dGV4X3QgcmVhZF9tdXRleDsKI2RlZmluZSByZWFkX2xvY2soKQkJbG9ja19tdXRleCgmcmVhZF9tdXRleCkKI2RlZmluZSByZWFkX3VubG9jaygpCQl1bmxvY2tfbXV0ZXgoJnJlYWRfbXV0ZXgpCgpzdGF0aWMgcHRocmVhZF9tdXRleF90IGNvdW50ZXJfbXV0ZXg7CiNkZWZpbmUgY291bnRlcl9sb2NrKCkJCWxvY2tfbXV0ZXgoJmNvdW50ZXJfbXV0ZXgpCiNkZWZpbmUgY291bnRlcl91bmxvY2soKQl1bmxvY2tfbXV0ZXgoJmNvdW50ZXJfbXV0ZXgpCgpzdGF0aWMgcHRocmVhZF9tdXRleF90IHdvcmtfbXV0ZXg7CiNkZWZpbmUgd29ya19sb2NrKCkJCWxvY2tfbXV0ZXgoJndvcmtfbXV0ZXgpCiNkZWZpbmUgd29ya191bmxvY2soKQkJdW5sb2NrX211dGV4KCZ3b3JrX211dGV4KQoKc3RhdGljIHB0aHJlYWRfbXV0ZXhfdCBkZWVwZXN0X2RlbHRhX211dGV4OwojZGVmaW5lIGRlZXBlc3RfZGVsdGFfbG9jaygpCWxvY2tfbXV0ZXgoJmRlZXBlc3RfZGVsdGFfbXV0ZXgpCiNkZWZpbmUgZGVlcGVzdF9kZWx0YV91bmxvY2soKQl1bmxvY2tfbXV0ZXgoJmRlZXBlc3RfZGVsdGFfbXV0ZXgpCgpzdGF0aWMgcHRocmVhZF9rZXlfdCBrZXk7CgpzdGF0aWMgaW5saW5lIHZvaWQgbG9ja19tdXRleChwdGhyZWFkX211dGV4X3QgKm11dGV4KQp7CglpZiAodGhyZWFkc19hY3RpdmUpCgkJcHRocmVhZF9tdXRleF9sb2NrKG11dGV4KTsKfQoKc3RhdGljIGlubGluZSB2b2lkIHVubG9ja19tdXRleChwdGhyZWFkX211dGV4X3QgKm11dGV4KQp7CglpZiAodGhyZWFkc19hY3RpdmUpCgkJcHRocmVhZF9tdXRleF91bmxvY2sobXV0ZXgpOwp9CgovKgogKiBNdXRleCBhbmQgY29uZGl0aW9uYWwgdmFyaWFibGUgY2FuJ3QgYmUgc3RhdGljYWxseS1pbml0aWFsaXplZCBvbiBXaW5kb3dzLgogKi8Kc3RhdGljIHZvaWQgaW5pdF90aHJlYWQodm9pZCkKewoJaW50IGk7Cglpbml0X3JlY3Vyc2l2ZV9tdXRleCgmcmVhZF9tdXRleCk7CglwdGhyZWFkX211dGV4X2luaXQoJmNvdW50ZXJfbXV0ZXgsIE5VTEwpOwoJcHRocmVhZF9tdXRleF9pbml0KCZ3b3JrX211dGV4LCBOVUxMKTsKCWlmIChzaG93X3N0YXQpCgkJcHRocmVhZF9tdXRleF9pbml0KCZkZWVwZXN0X2RlbHRhX211dGV4LCBOVUxMKTsKCXB0aHJlYWRfa2V5X2NyZWF0ZSgma2V5LCBOVUxMKTsKCUNBTExPQ19BUlJBWSh0aHJlYWRfZGF0YSwgbnJfdGhyZWFkcyk7Cglmb3IgKGkgPSAwOyBpIDwgbnJfdGhyZWFkczsgaSsrKSB7CgkJdGhyZWFkX2RhdGFbaV0ucGFja19mZCA9IHhvcGVuKGN1cnJfcGFjaywgT19SRE9OTFkpOwoJfQoKCXRocmVhZHNfYWN0aXZlID0gMTsKfQoKc3RhdGljIHZvaWQgY2xlYW51cF90aHJlYWQodm9pZCkKewoJaW50IGk7CglpZiAoIXRocmVhZHNfYWN0aXZlKQoJCXJldHVybjsKCXRocmVhZHNfYWN0aXZlID0gMDsKCXB0aHJlYWRfbXV0ZXhfZGVzdHJveSgmcmVhZF9tdXRleCk7CglwdGhyZWFkX211dGV4X2Rlc3Ryb3koJmNvdW50ZXJfbXV0ZXgpOwoJcHRocmVhZF9tdXRleF9kZXN0cm95KCZ3b3JrX211dGV4KTsKCWlmIChzaG93X3N0YXQpCgkJcHRocmVhZF9tdXRleF9kZXN0cm95KCZkZWVwZXN0X2RlbHRhX211dGV4KTsKCWZvciAoaSA9IDA7IGkgPCBucl90aHJlYWRzOyBpKyspCgkJY2xvc2UodGhyZWFkX2RhdGFbaV0ucGFja19mZCk7CglwdGhyZWFkX2tleV9kZWxldGUoa2V5KTsKCWZyZWUodGhyZWFkX2RhdGEpOwp9CgpzdGF0aWMgaW50IG1hcmtfbGluayhzdHJ1Y3Qgb2JqZWN0ICpvYmosIGVudW0gb2JqZWN0X3R5cGUgdHlwZSwKCQkgICAgIHZvaWQgKmRhdGEgVU5VU0VELAoJCSAgICAgc3RydWN0IGZzY2tfb3B0aW9ucyAqb3B0aW9ucyBVTlVTRUQpCnsKCWlmICghb2JqKQoJCXJldHVybiAtMTsKCglpZiAodHlwZSAhPSBPQkpfQU5ZICYmIG9iai0+dHlwZSAhPSB0eXBlKQoJCWRpZShfKCJvYmplY3QgdHlwZSBtaXNtYXRjaCBhdCAlcyIpLCBvaWRfdG9faGV4KCZvYmotPm9pZCkpOwoKCW9iai0+ZmxhZ3MgfD0gRkxBR19MSU5LOwoJcmV0dXJuIDA7Cn0KCi8qIFRoZSBjb250ZW50IG9mIGVhY2ggbGlua2VkIG9iamVjdCBtdXN0IGhhdmUgYmVlbiBjaGVja2VkCiAgIG9yIGl0IG11c3QgYmUgYWxyZWFkeSBwcmVzZW50IGluIHRoZSBvYmplY3QgZGF0YWJhc2UgKi8Kc3RhdGljIHVuc2lnbmVkIGNoZWNrX29iamVjdChzdHJ1Y3Qgb2JqZWN0ICpvYmopCnsKCWlmICghb2JqKQoJCXJldHVybiAwOwoKCWlmICghKG9iai0+ZmxhZ3MgJiBGTEFHX0xJTkspKQoJCXJldHVybiAwOwoKCWlmICghKG9iai0+ZmxhZ3MgJiBGTEFHX0NIRUNLRUQpKSB7CgkJdW5zaWduZWQgbG9uZyBzaXplOwoJCWludCB0eXBlID0gb2lkX29iamVjdF9pbmZvKHRoZV9yZXBvc2l0b3J5LCAmb2JqLT5vaWQsICZzaXplKTsKCQlpZiAodHlwZSA8PSAwKQoJCQlkaWUoXygiZGlkIG5vdCByZWNlaXZlIGV4cGVjdGVkIG9iamVjdCAlcyIpLAoJCQkgICAgICBvaWRfdG9faGV4KCZvYmotPm9pZCkpOwoJCWlmICh0eXBlICE9IG9iai0+dHlwZSkKCQkJZGllKF8oIm9iamVjdCAlczogZXhwZWN0ZWQgdHlwZSAlcywgZm91bmQgJXMiKSwKCQkJICAgIG9pZF90b19oZXgoJm9iai0+b2lkKSwKCQkJICAgIHR5cGVfbmFtZShvYmotPnR5cGUpLCB0eXBlX25hbWUodHlwZSkpOwoJCW9iai0+ZmxhZ3MgfD0gRkxBR19DSEVDS0VEOwoJCXJldHVybiAxOwoJfQoKCXJldHVybiAwOwp9CgpzdGF0aWMgdW5zaWduZWQgY2hlY2tfb2JqZWN0cyh2b2lkKQp7Cgl1bnNpZ25lZCBpLCBtYXgsIGZvcmVpZ25fbnIgPSAwOwoKCW1heCA9IGdldF9tYXhfb2JqZWN0X2luZGV4KCk7CgoJaWYgKHZlcmJvc2UpCgkJcHJvZ3Jlc3MgPSBzdGFydF9kZWxheWVkX3Byb2dyZXNzKF8oIkNoZWNraW5nIG9iamVjdHMiKSwgbWF4KTsKCglmb3IgKGkgPSAwOyBpIDwgbWF4OyBpKyspIHsKCQlmb3JlaWduX25yICs9IGNoZWNrX29iamVjdChnZXRfaW5kZXhlZF9vYmplY3QoaSkpOwoJCWRpc3BsYXlfcHJvZ3Jlc3MocHJvZ3Jlc3MsIGkgKyAxKTsKCX0KCglzdG9wX3Byb2dyZXNzKCZwcm9ncmVzcyk7CglyZXR1cm4gZm9yZWlnbl9ucjsKfQoKCi8qIERpc2NhcmQgY3VycmVudCBidWZmZXIgdXNlZCBjb250ZW50LiAqLwpzdGF0aWMgdm9pZCBmbHVzaCh2b2lkKQp7CglpZiAoaW5wdXRfb2Zmc2V0KSB7CgkJaWYgKG91dHB1dF9mZCA+PSAwKQoJCQl3cml0ZV9vcl9kaWUob3V0cHV0X2ZkLCBpbnB1dF9idWZmZXIsIGlucHV0X29mZnNldCk7CgkJdGhlX2hhc2hfYWxnby0+dXBkYXRlX2ZuKCZpbnB1dF9jdHgsIGlucHV0X2J1ZmZlciwgaW5wdXRfb2Zmc2V0KTsKCQltZW1tb3ZlKGlucHV0X2J1ZmZlciwgaW5wdXRfYnVmZmVyICsgaW5wdXRfb2Zmc2V0LCBpbnB1dF9sZW4pOwoJCWlucHV0X29mZnNldCA9IDA7Cgl9Cn0KCi8qCiAqIE1ha2Ugc3VyZSBhdCBsZWFzdCAibWluIiBieXRlcyBhcmUgYXZhaWxhYmxlIGluIHRoZSBidWZmZXIsIGFuZAogKiByZXR1cm4gdGhlIHBvaW50ZXIgdG8gdGhlIGJ1ZmZlci4KICovCnN0YXRpYyB2b2lkICpmaWxsKGludCBtaW4pCnsKCWlmIChtaW4gPD0gaW5wdXRfbGVuKQoJCXJldHVybiBpbnB1dF9idWZmZXIgKyBpbnB1dF9vZmZzZXQ7CglpZiAobWluID4gc2l6ZW9mKGlucHV0X2J1ZmZlcikpCgkJZGllKFFfKCJjYW5ub3QgZmlsbCAlZCBieXRlIiwKCQkgICAgICAgImNhbm5vdCBmaWxsICVkIGJ5dGVzIiwKCQkgICAgICAgbWluKSwKCQkgICAgbWluKTsKCWZsdXNoKCk7CglkbyB7CgkJc3NpemVfdCByZXQgPSB4cmVhZChpbnB1dF9mZCwgaW5wdXRfYnVmZmVyICsgaW5wdXRfbGVuLAoJCQkJc2l6ZW9mKGlucHV0X2J1ZmZlcikgLSBpbnB1dF9sZW4pOwoJCWlmIChyZXQgPD0gMCkgewoJCQlpZiAoIXJldCkKCQkJCWRpZShfKCJlYXJseSBFT0YiKSk7CgkJCWRpZV9lcnJubyhfKCJyZWFkIGVycm9yIG9uIGlucHV0IikpOwoJCX0KCQlpbnB1dF9sZW4gKz0gcmV0OwoJCWlmIChmcm9tX3N0ZGluKQoJCQlkaXNwbGF5X3Rocm91Z2hwdXQocHJvZ3Jlc3MsIGNvbnN1bWVkX2J5dGVzICsgaW5wdXRfbGVuKTsKCX0gd2hpbGUgKGlucHV0X2xlbiA8IG1pbik7CglyZXR1cm4gaW5wdXRfYnVmZmVyOwp9CgpzdGF0aWMgdm9pZCB1c2UoaW50IGJ5dGVzKQp7CglpZiAoYnl0ZXMgPiBpbnB1dF9sZW4pCgkJZGllKF8oInVzZWQgbW9yZSBieXRlcyB0aGFuIHdlcmUgYXZhaWxhYmxlIikpOwoJaW5wdXRfY3JjMzIgPSBjcmMzMihpbnB1dF9jcmMzMiwgaW5wdXRfYnVmZmVyICsgaW5wdXRfb2Zmc2V0LCBieXRlcyk7CglpbnB1dF9sZW4gLT0gYnl0ZXM7CglpbnB1dF9vZmZzZXQgKz0gYnl0ZXM7CgoJLyogbWFrZSBzdXJlIG9mZl90IGlzIHN1ZmZpY2llbnRseSBsYXJnZSBub3QgdG8gd3JhcCAqLwoJaWYgKHNpZ25lZF9hZGRfb3ZlcmZsb3dzKGNvbnN1bWVkX2J5dGVzLCBieXRlcykpCgkJZGllKF8oInBhY2sgdG9vIGxhcmdlIGZvciBjdXJyZW50IGRlZmluaXRpb24gb2Ygb2ZmX3QiKSk7Cgljb25zdW1lZF9ieXRlcyArPSBieXRlczsKCWlmIChtYXhfaW5wdXRfc2l6ZSAmJiBjb25zdW1lZF9ieXRlcyA+IG1heF9pbnB1dF9zaXplKSB7CgkJc3RydWN0IHN0cmJ1ZiBzaXplX2xpbWl0ID0gU1RSQlVGX0lOSVQ7CgkJc3RyYnVmX2h1bWFuaXNlX2J5dGVzKCZzaXplX2xpbWl0LCBtYXhfaW5wdXRfc2l6ZSk7CgkJZGllKF8oInBhY2sgZXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQgc2l6ZSAoJXMpIiksCgkJICAgIHNpemVfbGltaXQuYnVmKTsKCX0KfQoKc3RhdGljIGNvbnN0IGNoYXIgKm9wZW5fcGFja19maWxlKGNvbnN0IGNoYXIgKnBhY2tfbmFtZSkKewoJaWYgKGZyb21fc3RkaW4pIHsKCQlpbnB1dF9mZCA9IDA7CgkJaWYgKCFwYWNrX25hbWUpIHsKCQkJc3RydWN0IHN0cmJ1ZiB0bXBfZmlsZSA9IFNUUkJVRl9JTklUOwoJCQlvdXRwdXRfZmQgPSBvZGJfbWtzdGVtcCgmdG1wX2ZpbGUsCgkJCQkJCSJwYWNrL3RtcF9wYWNrX1hYWFhYWCIpOwoJCQlwYWNrX25hbWUgPSBzdHJidWZfZGV0YWNoKCZ0bXBfZmlsZSwgTlVMTCk7CgkJfSBlbHNlIHsKCQkJb3V0cHV0X2ZkID0geG9wZW4ocGFja19uYW1lLCBPX0NSRUFUfE9fRVhDTHxPX1JEV1IsIDA2MDApOwoJCX0KCQlub3RocmVhZF9kYXRhLnBhY2tfZmQgPSBvdXRwdXRfZmQ7Cgl9IGVsc2UgewoJCWlucHV0X2ZkID0geG9wZW4ocGFja19uYW1lLCBPX1JET05MWSk7CgkJb3V0cHV0X2ZkID0gLTE7CgkJbm90aHJlYWRfZGF0YS5wYWNrX2ZkID0gaW5wdXRfZmQ7Cgl9Cgl0aGVfaGFzaF9hbGdvLT5pbml0X2ZuKCZpbnB1dF9jdHgpOwoJcmV0dXJuIHBhY2tfbmFtZTsKfQoKc3RhdGljIHZvaWQgcGFyc2VfcGFja19oZWFkZXIodm9pZCkKewoJc3RydWN0IHBhY2tfaGVhZGVyICpoZHIgPSBmaWxsKHNpemVvZihzdHJ1Y3QgcGFja19oZWFkZXIpKTsKCgkvKiBIZWFkZXIgY29uc2lzdGVuY3kgY2hlY2sgKi8KCWlmIChoZHItPmhkcl9zaWduYXR1cmUgIT0gaHRvbmwoUEFDS19TSUdOQVRVUkUpKQoJCWRpZShfKCJwYWNrIHNpZ25hdHVyZSBtaXNtYXRjaCIpKTsKCWlmICghcGFja192ZXJzaW9uX29rKGhkci0+aGRyX3ZlcnNpb24pKQoJCWRpZShfKCJwYWNrIHZlcnNpb24gJSJQUkl1MzIiIHVuc3VwcG9ydGVkIiksCgkJCW50b2hsKGhkci0+aGRyX3ZlcnNpb24pKTsKCglucl9vYmplY3RzID0gbnRvaGwoaGRyLT5oZHJfZW50cmllcyk7Cgl1c2Uoc2l6ZW9mKHN0cnVjdCBwYWNrX2hlYWRlcikpOwp9CgpfX2F0dHJpYnV0ZV9fKChmb3JtYXQgKHByaW50ZiwgMiwgMykpKQpzdGF0aWMgTk9SRVRVUk4gdm9pZCBiYWRfb2JqZWN0KG9mZl90IG9mZnNldCwgY29uc3QgY2hhciAqZm9ybWF0LCAuLi4pCnsKCXZhX2xpc3QgcGFyYW1zOwoJY2hhciBidWZbMTAyNF07CgoJdmFfc3RhcnQocGFyYW1zLCBmb3JtYXQpOwoJdnNucHJpbnRmKGJ1Ziwgc2l6ZW9mKGJ1ZiksIGZvcm1hdCwgcGFyYW1zKTsKCXZhX2VuZChwYXJhbXMpOwoJZGllKF8oInBhY2sgaGFzIGJhZCBvYmplY3QgYXQgb2Zmc2V0ICUiUFJJdU1BWCI6ICVzIiksCgkgICAgKHVpbnRtYXhfdClvZmZzZXQsIGJ1Zik7Cn0KCnN0YXRpYyBpbmxpbmUgc3RydWN0IHRocmVhZF9sb2NhbCAqZ2V0X3RocmVhZF9kYXRhKHZvaWQpCnsKCWlmIChIQVZFX1RIUkVBRFMpIHsKCQlpZiAodGhyZWFkc19hY3RpdmUpCgkJCXJldHVybiBwdGhyZWFkX2dldHNwZWNpZmljKGtleSk7CgkJYXNzZXJ0KCF0aHJlYWRzX2FjdGl2ZSAmJgoJCSAgICAgICAiVGhpcyBzaG91bGQgb25seSBiZSByZWFjaGVkIHdoZW4gYWxsIHRocmVhZHMgYXJlIGdvbmUiKTsKCX0KCXJldHVybiAmbm90aHJlYWRfZGF0YTsKfQoKc3RhdGljIHZvaWQgc2V0X3RocmVhZF9kYXRhKHN0cnVjdCB0aHJlYWRfbG9jYWwgKmRhdGEpCnsKCWlmICh0aHJlYWRzX2FjdGl2ZSkKCQlwdGhyZWFkX3NldHNwZWNpZmljKGtleSwgZGF0YSk7Cn0KCnN0YXRpYyB2b2lkIGZyZWVfYmFzZV9kYXRhKHN0cnVjdCBiYXNlX2RhdGEgKmMpCnsKCWlmIChjLT5kYXRhKSB7CgkJRlJFRV9BTkRfTlVMTChjLT5kYXRhKTsKCQliYXNlX2NhY2hlX3VzZWQgLT0gYy0+c2l6ZTsKCX0KfQoKc3RhdGljIHZvaWQgcHJ1bmVfYmFzZV9kYXRhKHN0cnVjdCBiYXNlX2RhdGEgKnJldGFpbikKewoJc3RydWN0IGxpc3RfaGVhZCAqcG9zOwoKCWlmIChiYXNlX2NhY2hlX3VzZWQgPD0gYmFzZV9jYWNoZV9saW1pdCkKCQlyZXR1cm47CgoJbGlzdF9mb3JfZWFjaF9wcmV2KHBvcywgJmRvbmVfaGVhZCkgewoJCXN0cnVjdCBiYXNlX2RhdGEgKmIgPSBsaXN0X2VudHJ5KHBvcywgc3RydWN0IGJhc2VfZGF0YSwgbGlzdCk7CgkJaWYgKGItPnJldGFpbl9kYXRhIHx8IGIgPT0gcmV0YWluKQoJCQljb250aW51ZTsKCQlpZiAoYi0+ZGF0YSkgewoJCQlmcmVlX2Jhc2VfZGF0YShiKTsKCQkJaWYgKGJhc2VfY2FjaGVfdXNlZCA8PSBiYXNlX2NhY2hlX2xpbWl0KQoJCQkJcmV0dXJuOwoJCX0KCX0KCglsaXN0X2Zvcl9lYWNoX3ByZXYocG9zLCAmd29ya19oZWFkKSB7CgkJc3RydWN0IGJhc2VfZGF0YSAqYiA9IGxpc3RfZW50cnkocG9zLCBzdHJ1Y3QgYmFzZV9kYXRhLCBsaXN0KTsKCQlpZiAoYi0+cmV0YWluX2RhdGEgfHwgYiA9PSByZXRhaW4pCgkJCWNvbnRpbnVlOwoJCWlmIChiLT5kYXRhKSB7CgkJCWZyZWVfYmFzZV9kYXRhKGIpOwoJCQlpZiAoYmFzZV9jYWNoZV91c2VkIDw9IGJhc2VfY2FjaGVfbGltaXQpCgkJCQlyZXR1cm47CgkJfQoJfQp9CgpzdGF0aWMgaW50IGlzX2RlbHRhX3R5cGUoZW51bSBvYmplY3RfdHlwZSB0eXBlKQp7CglyZXR1cm4gKHR5cGUgPT0gT0JKX1JFRl9ERUxUQSB8fCB0eXBlID09IE9CSl9PRlNfREVMVEEpOwp9CgpzdGF0aWMgdm9pZCAqdW5wYWNrX2VudHJ5X2RhdGEob2ZmX3Qgb2Zmc2V0LCB1bnNpZ25lZCBsb25nIHNpemUsCgkJCSAgICAgICBlbnVtIG9iamVjdF90eXBlIHR5cGUsIHN0cnVjdCBvYmplY3RfaWQgKm9pZCkKewoJc3RhdGljIGNoYXIgZml4ZWRfYnVmWzgxOTJdOwoJaW50IHN0YXR1czsKCWdpdF96c3RyZWFtIHN0cmVhbTsKCXZvaWQgKmJ1ZjsKCWdpdF9oYXNoX2N0eCBjOwoJY2hhciBoZHJbMzJdOwoJaW50IGhkcmxlbjsKCglpZiAoIWlzX2RlbHRhX3R5cGUodHlwZSkpIHsKCQloZHJsZW4gPSBmb3JtYXRfb2JqZWN0X2hlYWRlcihoZHIsIHNpemVvZihoZHIpLCB0eXBlLCBzaXplKTsKCQl0aGVfaGFzaF9hbGdvLT5pbml0X2ZuKCZjKTsKCQl0aGVfaGFzaF9hbGdvLT51cGRhdGVfZm4oJmMsIGhkciwgaGRybGVuKTsKCX0gZWxzZQoJCW9pZCA9IE5VTEw7CglpZiAodHlwZSA9PSBPQkpfQkxPQiAmJiBzaXplID4gYmlnX2ZpbGVfdGhyZXNob2xkKQoJCWJ1ZiA9IGZpeGVkX2J1ZjsKCWVsc2UKCQlidWYgPSB4bWFsbG9jeihzaXplKTsKCgltZW1zZXQoJnN0cmVhbSwgMCwgc2l6ZW9mKHN0cmVhbSkpOwoJZ2l0X2luZmxhdGVfaW5pdCgmc3RyZWFtKTsKCXN0cmVhbS5uZXh0X291dCA9IGJ1ZjsKCXN0cmVhbS5hdmFpbF9vdXQgPSBidWYgPT0gZml4ZWRfYnVmID8gc2l6ZW9mKGZpeGVkX2J1ZikgOiBzaXplOwoKCWRvIHsKCQl1bnNpZ25lZCBjaGFyICpsYXN0X291dCA9IHN0cmVhbS5uZXh0X291dDsKCQlzdHJlYW0ubmV4dF9pbiA9IGZpbGwoMSk7CgkJc3RyZWFtLmF2YWlsX2luID0gaW5wdXRfbGVuOwoJCXN0YXR1cyA9IGdpdF9pbmZsYXRlKCZzdHJlYW0sIDApOwoJCXVzZShpbnB1dF9sZW4gLSBzdHJlYW0uYXZhaWxfaW4pOwoJCWlmIChvaWQpCgkJCXRoZV9oYXNoX2FsZ28tPnVwZGF0ZV9mbigmYywgbGFzdF9vdXQsIHN0cmVhbS5uZXh0X291dCAtIGxhc3Rfb3V0KTsKCQlpZiAoYnVmID09IGZpeGVkX2J1ZikgewoJCQlzdHJlYW0ubmV4dF9vdXQgPSBidWY7CgkJCXN0cmVhbS5hdmFpbF9vdXQgPSBzaXplb2YoZml4ZWRfYnVmKTsKCQl9Cgl9IHdoaWxlIChzdGF0dXMgPT0gWl9PSyk7CglpZiAoc3RyZWFtLnRvdGFsX291dCAhPSBzaXplIHx8IHN0YXR1cyAhPSBaX1NUUkVBTV9FTkQpCgkJYmFkX29iamVjdChvZmZzZXQsIF8oImluZmxhdGUgcmV0dXJuZWQgJWQiKSwgc3RhdHVzKTsKCWdpdF9pbmZsYXRlX2VuZCgmc3RyZWFtKTsKCWlmIChvaWQpCgkJdGhlX2hhc2hfYWxnby0+ZmluYWxfb2lkX2ZuKG9pZCwgJmMpOwoJcmV0dXJuIGJ1ZiA9PSBmaXhlZF9idWYgPyBOVUxMIDogYnVmOwp9CgpzdGF0aWMgdm9pZCAqdW5wYWNrX3Jhd19lbnRyeShzdHJ1Y3Qgb2JqZWN0X2VudHJ5ICpvYmosCgkJCSAgICAgIG9mZl90ICpvZnNfb2Zmc2V0LAoJCQkgICAgICBzdHJ1Y3Qgb2JqZWN0X2lkICpyZWZfb2lkLAoJCQkgICAgICBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQpCnsKCXVuc2lnbmVkIGNoYXIgKnA7Cgl1bnNpZ25lZCBsb25nIHNpemUsIGM7CglvZmZfdCBiYXNlX29mZnNldDsKCXVuc2lnbmVkIHNoaWZ0OwoJdm9pZCAqZGF0YTsKCglvYmotPmlkeC5vZmZzZXQgPSBjb25zdW1lZF9ieXRlczsKCWlucHV0X2NyYzMyID0gY3JjMzIoMCwgTlVMTCwgMCk7CgoJcCA9IGZpbGwoMSk7CgljID0gKnA7Cgl1c2UoMSk7CglvYmotPnR5cGUgPSAoYyA+PiA0KSAmIDc7CglzaXplID0gKGMgJiAxNSk7CglzaGlmdCA9IDQ7Cgl3aGlsZSAoYyAmIDB4ODApIHsKCQlwID0gZmlsbCgxKTsKCQljID0gKnA7CgkJdXNlKDEpOwoJCXNpemUgKz0gKGMgJiAweDdmKSA8PCBzaGlmdDsKCQlzaGlmdCArPSA3OwoJfQoJb2JqLT5zaXplID0gc2l6ZTsKCglzd2l0Y2ggKG9iai0+dHlwZSkgewoJY2FzZSBPQkpfUkVGX0RFTFRBOgoJCW9pZHJlYWQocmVmX29pZCwgZmlsbCh0aGVfaGFzaF9hbGdvLT5yYXdzeikpOwoJCXVzZSh0aGVfaGFzaF9hbGdvLT5yYXdzeik7CgkJYnJlYWs7CgljYXNlIE9CSl9PRlNfREVMVEE6CgkJcCA9IGZpbGwoMSk7CgkJYyA9ICpwOwoJCXVzZSgxKTsKCQliYXNlX29mZnNldCA9IGMgJiAxMjc7CgkJd2hpbGUgKGMgJiAxMjgpIHsKCQkJYmFzZV9vZmZzZXQgKz0gMTsKCQkJaWYgKCFiYXNlX29mZnNldCB8fCBNU0IoYmFzZV9vZmZzZXQsIDcpKQoJCQkJYmFkX29iamVjdChvYmotPmlkeC5vZmZzZXQsIF8oIm9mZnNldCB2YWx1ZSBvdmVyZmxvdyBmb3IgZGVsdGEgYmFzZSBvYmplY3QiKSk7CgkJCXAgPSBmaWxsKDEpOwoJCQljID0gKnA7CgkJCXVzZSgxKTsKCQkJYmFzZV9vZmZzZXQgPSAoYmFzZV9vZmZzZXQgPDwgNykgKyAoYyAmIDEyNyk7CgkJfQoJCSpvZnNfb2Zmc2V0ID0gb2JqLT5pZHgub2Zmc2V0IC0gYmFzZV9vZmZzZXQ7CgkJaWYgKCpvZnNfb2Zmc2V0IDw9IDAgfHwgKm9mc19vZmZzZXQgPj0gb2JqLT5pZHgub2Zmc2V0KQoJCQliYWRfb2JqZWN0KG9iai0+aWR4Lm9mZnNldCwgXygiZGVsdGEgYmFzZSBvZmZzZXQgaXMgb3V0IG9mIGJvdW5kIikpOwoJCWJyZWFrOwoJY2FzZSBPQkpfQ09NTUlUOgoJY2FzZSBPQkpfVFJFRToKCWNhc2UgT0JKX0JMT0I6CgljYXNlIE9CSl9UQUc6CgkJYnJlYWs7CglkZWZhdWx0OgoJCWJhZF9vYmplY3Qob2JqLT5pZHgub2Zmc2V0LCBfKCJ1bmtub3duIG9iamVjdCB0eXBlICVkIiksIG9iai0+dHlwZSk7Cgl9CglvYmotPmhkcl9zaXplID0gY29uc3VtZWRfYnl0ZXMgLSBvYmotPmlkeC5vZmZzZXQ7CgoJZGF0YSA9IHVucGFja19lbnRyeV9kYXRhKG9iai0+aWR4Lm9mZnNldCwgb2JqLT5zaXplLCBvYmotPnR5cGUsIG9pZCk7CglvYmotPmlkeC5jcmMzMiA9IGlucHV0X2NyYzMyOwoJcmV0dXJuIGRhdGE7Cn0KCnN0YXRpYyB2b2lkICp1bnBhY2tfZGF0YShzdHJ1Y3Qgb2JqZWN0X2VudHJ5ICpvYmosCgkJCSBpbnQgKCpjb25zdW1lKShjb25zdCB1bnNpZ25lZCBjaGFyICosIHVuc2lnbmVkIGxvbmcsIHZvaWQgKiksCgkJCSB2b2lkICpjYl9kYXRhKQp7CglvZmZfdCBmcm9tID0gb2JqWzBdLmlkeC5vZmZzZXQgKyBvYmpbMF0uaGRyX3NpemU7CglvZmZfdCBsZW4gPSBvYmpbMV0uaWR4Lm9mZnNldCAtIGZyb207Cgl1bnNpZ25lZCBjaGFyICpkYXRhLCAqaW5idWY7CglnaXRfenN0cmVhbSBzdHJlYW07CglpbnQgc3RhdHVzOwoKCWRhdGEgPSB4bWFsbG9jeihjb25zdW1lID8gNjQqMTAyNCA6IG9iai0+c2l6ZSk7CglpbmJ1ZiA9IHhtYWxsb2MoKGxlbiA8IDY0KjEwMjQpID8gKGludClsZW4gOiA2NCoxMDI0KTsKCgltZW1zZXQoJnN0cmVhbSwgMCwgc2l6ZW9mKHN0cmVhbSkpOwoJZ2l0X2luZmxhdGVfaW5pdCgmc3RyZWFtKTsKCXN0cmVhbS5uZXh0X291dCA9IGRhdGE7CglzdHJlYW0uYXZhaWxfb3V0ID0gY29uc3VtZSA/IDY0KjEwMjQgOiBvYmotPnNpemU7CgoJZG8gewoJCXNzaXplX3QgbiA9IChsZW4gPCA2NCoxMDI0KSA/IChzc2l6ZV90KWxlbiA6IDY0KjEwMjQ7CgkJbiA9IHhwcmVhZChnZXRfdGhyZWFkX2RhdGEoKS0+cGFja19mZCwgaW5idWYsIG4sIGZyb20pOwoJCWlmIChuIDwgMCkKCQkJZGllX2Vycm5vKF8oImNhbm5vdCBwcmVhZCBwYWNrIGZpbGUiKSk7CgkJaWYgKCFuKQoJCQlkaWUoUV8oInByZW1hdHVyZSBlbmQgb2YgcGFjayBmaWxlLCAlIlBSSXVNQVgiIGJ5dGUgbWlzc2luZyIsCgkJCSAgICAgICAicHJlbWF0dXJlIGVuZCBvZiBwYWNrIGZpbGUsICUiUFJJdU1BWCIgYnl0ZXMgbWlzc2luZyIsCgkJCSAgICAgICBsZW4pLAoJCQkgICAgKHVpbnRtYXhfdClsZW4pOwoJCWZyb20gKz0gbjsKCQlsZW4gLT0gbjsKCQlzdHJlYW0ubmV4dF9pbiA9IGluYnVmOwoJCXN0cmVhbS5hdmFpbF9pbiA9IG47CgkJaWYgKCFjb25zdW1lKQoJCQlzdGF0dXMgPSBnaXRfaW5mbGF0ZSgmc3RyZWFtLCAwKTsKCQllbHNlIHsKCQkJZG8gewoJCQkJc3RhdHVzID0gZ2l0X2luZmxhdGUoJnN0cmVhbSwgMCk7CgkJCQlpZiAoY29uc3VtZShkYXRhLCBzdHJlYW0ubmV4dF9vdXQgLSBkYXRhLCBjYl9kYXRhKSkgewoJCQkJCWZyZWUoaW5idWYpOwoJCQkJCWZyZWUoZGF0YSk7CgkJCQkJcmV0dXJuIE5VTEw7CgkJCQl9CgkJCQlzdHJlYW0ubmV4dF9vdXQgPSBkYXRhOwoJCQkJc3RyZWFtLmF2YWlsX291dCA9IDY0KjEwMjQ7CgkJCX0gd2hpbGUgKHN0YXR1cyA9PSBaX09LICYmIHN0cmVhbS5hdmFpbF9pbik7CgkJfQoJfSB3aGlsZSAobGVuICYmIHN0YXR1cyA9PSBaX09LICYmICFzdHJlYW0uYXZhaWxfaW4pOwoKCS8qIFRoaXMgaGFzIGJlZW4gaW5mbGF0ZWQgT0sgd2hlbiBmaXJzdCBlbmNvdW50ZXJlZCwgc28uLi4gKi8KCWlmIChzdGF0dXMgIT0gWl9TVFJFQU1fRU5EIHx8IHN0cmVhbS50b3RhbF9vdXQgIT0gb2JqLT5zaXplKQoJCWRpZShfKCJzZXJpb3VzIGluZmxhdGUgaW5jb25zaXN0ZW5jeSIpKTsKCglnaXRfaW5mbGF0ZV9lbmQoJnN0cmVhbSk7CglmcmVlKGluYnVmKTsKCWlmIChjb25zdW1lKSB7CgkJRlJFRV9BTkRfTlVMTChkYXRhKTsKCX0KCXJldHVybiBkYXRhOwp9CgpzdGF0aWMgdm9pZCAqZ2V0X2RhdGFfZnJvbV9wYWNrKHN0cnVjdCBvYmplY3RfZW50cnkgKm9iaikKewoJcmV0dXJuIHVucGFja19kYXRhKG9iaiwgTlVMTCwgTlVMTCk7Cn0KCnN0YXRpYyBpbnQgY29tcGFyZV9vZnNfZGVsdGFfYmFzZXMob2ZmX3Qgb2Zmc2V0MSwgb2ZmX3Qgb2Zmc2V0MiwKCQkJCSAgIGVudW0gb2JqZWN0X3R5cGUgdHlwZTEsCgkJCQkgICBlbnVtIG9iamVjdF90eXBlIHR5cGUyKQp7CglpbnQgY21wID0gdHlwZTEgLSB0eXBlMjsKCWlmIChjbXApCgkJcmV0dXJuIGNtcDsKCXJldHVybiBvZmZzZXQxIDwgb2Zmc2V0MiA/IC0xIDoKCSAgICAgICBvZmZzZXQxID4gb2Zmc2V0MiA/ICAxIDoKCSAgICAgICAwOwp9CgpzdGF0aWMgaW50IGZpbmRfb2ZzX2RlbHRhKGNvbnN0IG9mZl90IG9mZnNldCkKewoJaW50IGZpcnN0ID0gMCwgbGFzdCA9IG5yX29mc19kZWx0YXM7CgoJd2hpbGUgKGZpcnN0IDwgbGFzdCkgewoJCWludCBuZXh0ID0gZmlyc3QgKyAobGFzdCAtIGZpcnN0KSAvIDI7CgkJc3RydWN0IG9mc19kZWx0YV9lbnRyeSAqZGVsdGEgPSAmb2ZzX2RlbHRhc1tuZXh0XTsKCQlpbnQgY21wOwoKCQljbXAgPSBjb21wYXJlX29mc19kZWx0YV9iYXNlcyhvZmZzZXQsIGRlbHRhLT5vZmZzZXQsCgkJCQkJICAgICAgT0JKX09GU19ERUxUQSwKCQkJCQkgICAgICBvYmplY3RzW2RlbHRhLT5vYmpfbm9dLnR5cGUpOwoJCWlmICghY21wKQoJCQlyZXR1cm4gbmV4dDsKCQlpZiAoY21wIDwgMCkgewoJCQlsYXN0ID0gbmV4dDsKCQkJY29udGludWU7CgkJfQoJCWZpcnN0ID0gbmV4dCsxOwoJfQoJcmV0dXJuIC1maXJzdC0xOwp9CgpzdGF0aWMgdm9pZCBmaW5kX29mc19kZWx0YV9jaGlsZHJlbihvZmZfdCBvZmZzZXQsCgkJCQkgICAgaW50ICpmaXJzdF9pbmRleCwgaW50ICpsYXN0X2luZGV4KQp7CglpbnQgZmlyc3QgPSBmaW5kX29mc19kZWx0YShvZmZzZXQpOwoJaW50IGxhc3QgPSBmaXJzdDsKCWludCBlbmQgPSBucl9vZnNfZGVsdGFzIC0gMTsKCglpZiAoZmlyc3QgPCAwKSB7CgkJKmZpcnN0X2luZGV4ID0gMDsKCQkqbGFzdF9pbmRleCA9IC0xOwoJCXJldHVybjsKCX0KCXdoaWxlIChmaXJzdCA+IDAgJiYgb2ZzX2RlbHRhc1tmaXJzdCAtIDFdLm9mZnNldCA9PSBvZmZzZXQpCgkJLS1maXJzdDsKCXdoaWxlIChsYXN0IDwgZW5kICYmIG9mc19kZWx0YXNbbGFzdCArIDFdLm9mZnNldCA9PSBvZmZzZXQpCgkJKytsYXN0OwoJKmZpcnN0X2luZGV4ID0gZmlyc3Q7CgkqbGFzdF9pbmRleCA9IGxhc3Q7Cn0KCnN0YXRpYyBpbnQgY29tcGFyZV9yZWZfZGVsdGFfYmFzZXMoY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkMSwKCQkJCSAgIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZDIsCgkJCQkgICBlbnVtIG9iamVjdF90eXBlIHR5cGUxLAoJCQkJICAgZW51bSBvYmplY3RfdHlwZSB0eXBlMikKewoJaW50IGNtcCA9IHR5cGUxIC0gdHlwZTI7CglpZiAoY21wKQoJCXJldHVybiBjbXA7CglyZXR1cm4gb2lkY21wKG9pZDEsIG9pZDIpOwp9CgpzdGF0aWMgaW50IGZpbmRfcmVmX2RlbHRhKGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCkKewoJaW50IGZpcnN0ID0gMCwgbGFzdCA9IG5yX3JlZl9kZWx0YXM7CgoJd2hpbGUgKGZpcnN0IDwgbGFzdCkgewoJCWludCBuZXh0ID0gZmlyc3QgKyAobGFzdCAtIGZpcnN0KSAvIDI7CgkJc3RydWN0IHJlZl9kZWx0YV9lbnRyeSAqZGVsdGEgPSAmcmVmX2RlbHRhc1tuZXh0XTsKCQlpbnQgY21wOwoKCQljbXAgPSBjb21wYXJlX3JlZl9kZWx0YV9iYXNlcyhvaWQsICZkZWx0YS0+b2lkLAoJCQkJCSAgICAgIE9CSl9SRUZfREVMVEEsCgkJCQkJICAgICAgb2JqZWN0c1tkZWx0YS0+b2JqX25vXS50eXBlKTsKCQlpZiAoIWNtcCkKCQkJcmV0dXJuIG5leHQ7CgkJaWYgKGNtcCA8IDApIHsKCQkJbGFzdCA9IG5leHQ7CgkJCWNvbnRpbnVlOwoJCX0KCQlmaXJzdCA9IG5leHQrMTsKCX0KCXJldHVybiAtZmlyc3QtMTsKfQoKc3RhdGljIHZvaWQgZmluZF9yZWZfZGVsdGFfY2hpbGRyZW4oY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLAoJCQkJICAgIGludCAqZmlyc3RfaW5kZXgsIGludCAqbGFzdF9pbmRleCkKewoJaW50IGZpcnN0ID0gZmluZF9yZWZfZGVsdGEob2lkKTsKCWludCBsYXN0ID0gZmlyc3Q7CglpbnQgZW5kID0gbnJfcmVmX2RlbHRhcyAtIDE7CgoJaWYgKGZpcnN0IDwgMCkgewoJCSpmaXJzdF9pbmRleCA9IDA7CgkJKmxhc3RfaW5kZXggPSAtMTsKCQlyZXR1cm47Cgl9Cgl3aGlsZSAoZmlyc3QgPiAwICYmIG9pZGVxKCZyZWZfZGVsdGFzW2ZpcnN0IC0gMV0ub2lkLCBvaWQpKQoJCS0tZmlyc3Q7Cgl3aGlsZSAobGFzdCA8IGVuZCAmJiBvaWRlcSgmcmVmX2RlbHRhc1tsYXN0ICsgMV0ub2lkLCBvaWQpKQoJCSsrbGFzdDsKCSpmaXJzdF9pbmRleCA9IGZpcnN0OwoJKmxhc3RfaW5kZXggPSBsYXN0Owp9CgpzdHJ1Y3QgY29tcGFyZV9kYXRhIHsKCXN0cnVjdCBvYmplY3RfZW50cnkgKmVudHJ5OwoJc3RydWN0IGdpdF9pc3RyZWFtICpzdDsKCXVuc2lnbmVkIGNoYXIgKmJ1ZjsKCXVuc2lnbmVkIGxvbmcgYnVmX3NpemU7Cn07CgpzdGF0aWMgaW50IGNvbXBhcmVfb2JqZWN0cyhjb25zdCB1bnNpZ25lZCBjaGFyICpidWYsIHVuc2lnbmVkIGxvbmcgc2l6ZSwKCQkJICAgdm9pZCAqY2JfZGF0YSkKewoJc3RydWN0IGNvbXBhcmVfZGF0YSAqZGF0YSA9IGNiX2RhdGE7CgoJaWYgKGRhdGEtPmJ1Zl9zaXplIDwgc2l6ZSkgewoJCWZyZWUoZGF0YS0+YnVmKTsKCQlkYXRhLT5idWYgPSB4bWFsbG9jKHNpemUpOwoJCWRhdGEtPmJ1Zl9zaXplID0gc2l6ZTsKCX0KCgl3aGlsZSAoc2l6ZSkgewoJCXNzaXplX3QgbGVuID0gcmVhZF9pc3RyZWFtKGRhdGEtPnN0LCBkYXRhLT5idWYsIHNpemUpOwoJCWlmIChsZW4gPT0gMCkKCQkJZGllKF8oIlNIQTEgQ09MTElTSU9OIEZPVU5EIFdJVEggJXMgISIpLAoJCQkgICAgb2lkX3RvX2hleCgmZGF0YS0+ZW50cnktPmlkeC5vaWQpKTsKCQlpZiAobGVuIDwgMCkKCQkJZGllKF8oInVuYWJsZSB0byByZWFkICVzIiksCgkJCSAgICBvaWRfdG9faGV4KCZkYXRhLT5lbnRyeS0+aWR4Lm9pZCkpOwoJCWlmIChtZW1jbXAoYnVmLCBkYXRhLT5idWYsIGxlbikpCgkJCWRpZShfKCJTSEExIENPTExJU0lPTiBGT1VORCBXSVRIICVzICEiKSwKCQkJICAgIG9pZF90b19oZXgoJmRhdGEtPmVudHJ5LT5pZHgub2lkKSk7CgkJc2l6ZSAtPSBsZW47CgkJYnVmICs9IGxlbjsKCX0KCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGNoZWNrX2NvbGxpc29uKHN0cnVjdCBvYmplY3RfZW50cnkgKmVudHJ5KQp7CglzdHJ1Y3QgY29tcGFyZV9kYXRhIGRhdGE7CgllbnVtIG9iamVjdF90eXBlIHR5cGU7Cgl1bnNpZ25lZCBsb25nIHNpemU7CgoJaWYgKGVudHJ5LT5zaXplIDw9IGJpZ19maWxlX3RocmVzaG9sZCB8fCBlbnRyeS0+dHlwZSAhPSBPQkpfQkxPQikKCQlyZXR1cm4gLTE7CgoJbWVtc2V0KCZkYXRhLCAwLCBzaXplb2YoZGF0YSkpOwoJZGF0YS5lbnRyeSA9IGVudHJ5OwoJZGF0YS5zdCA9IG9wZW5faXN0cmVhbSh0aGVfcmVwb3NpdG9yeSwgJmVudHJ5LT5pZHgub2lkLCAmdHlwZSwgJnNpemUsCgkJCSAgICAgICBOVUxMKTsKCWlmICghZGF0YS5zdCkKCQlyZXR1cm4gLTE7CglpZiAoc2l6ZSAhPSBlbnRyeS0+c2l6ZSB8fCB0eXBlICE9IGVudHJ5LT50eXBlKQoJCWRpZShfKCJTSEExIENPTExJU0lPTiBGT1VORCBXSVRIICVzICEiKSwKCQkgICAgb2lkX3RvX2hleCgmZW50cnktPmlkeC5vaWQpKTsKCXVucGFja19kYXRhKGVudHJ5LCBjb21wYXJlX29iamVjdHMsICZkYXRhKTsKCWNsb3NlX2lzdHJlYW0oZGF0YS5zdCk7CglmcmVlKGRhdGEuYnVmKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgdm9pZCBzaGExX29iamVjdChjb25zdCB2b2lkICpkYXRhLCBzdHJ1Y3Qgb2JqZWN0X2VudHJ5ICpvYmpfZW50cnksCgkJCXVuc2lnbmVkIGxvbmcgc2l6ZSwgZW51bSBvYmplY3RfdHlwZSB0eXBlLAoJCQljb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQpCnsKCXZvaWQgKm5ld19kYXRhID0gTlVMTDsKCWludCBjb2xsaXNpb25fdGVzdF9uZWVkZWQgPSAwOwoKCWFzc2VydChkYXRhIHx8IG9ial9lbnRyeSk7CgoJaWYgKHN0YXJ0dXBfaW5mby0+aGF2ZV9yZXBvc2l0b3J5KSB7CgkJcmVhZF9sb2NrKCk7CgkJY29sbGlzaW9uX3Rlc3RfbmVlZGVkID0KCQkJcmVwb19oYXNfb2JqZWN0X2ZpbGVfd2l0aF9mbGFncyh0aGVfcmVwb3NpdG9yeSwgb2lkLAoJCQkJCQkJT0JKRUNUX0lORk9fUVVJQ0spOwoJCXJlYWRfdW5sb2NrKCk7Cgl9CgoJaWYgKGNvbGxpc2lvbl90ZXN0X25lZWRlZCAmJiAhZGF0YSkgewoJCXJlYWRfbG9jaygpOwoJCWlmICghY2hlY2tfY29sbGlzb24ob2JqX2VudHJ5KSkKCQkJY29sbGlzaW9uX3Rlc3RfbmVlZGVkID0gMDsKCQlyZWFkX3VubG9jaygpOwoJfQoJaWYgKGNvbGxpc2lvbl90ZXN0X25lZWRlZCkgewoJCXZvaWQgKmhhc19kYXRhOwoJCWVudW0gb2JqZWN0X3R5cGUgaGFzX3R5cGU7CgkJdW5zaWduZWQgbG9uZyBoYXNfc2l6ZTsKCQlyZWFkX2xvY2soKTsKCQloYXNfdHlwZSA9IG9pZF9vYmplY3RfaW5mbyh0aGVfcmVwb3NpdG9yeSwgb2lkLCAmaGFzX3NpemUpOwoJCWlmIChoYXNfdHlwZSA8IDApCgkJCWRpZShfKCJjYW5ub3QgcmVhZCBleGlzdGluZyBvYmplY3QgaW5mbyAlcyIpLCBvaWRfdG9faGV4KG9pZCkpOwoJCWlmIChoYXNfdHlwZSAhPSB0eXBlIHx8IGhhc19zaXplICE9IHNpemUpCgkJCWRpZShfKCJTSEExIENPTExJU0lPTiBGT1VORCBXSVRIICVzICEiKSwgb2lkX3RvX2hleChvaWQpKTsKCQloYXNfZGF0YSA9IHJlcG9fcmVhZF9vYmplY3RfZmlsZSh0aGVfcmVwb3NpdG9yeSwgb2lkLAoJCQkJCQkgJmhhc190eXBlLCAmaGFzX3NpemUpOwoJCXJlYWRfdW5sb2NrKCk7CgkJaWYgKCFkYXRhKQoJCQlkYXRhID0gbmV3X2RhdGEgPSBnZXRfZGF0YV9mcm9tX3BhY2sob2JqX2VudHJ5KTsKCQlpZiAoIWhhc19kYXRhKQoJCQlkaWUoXygiY2Fubm90IHJlYWQgZXhpc3Rpbmcgb2JqZWN0ICVzIiksIG9pZF90b19oZXgob2lkKSk7CgkJaWYgKHNpemUgIT0gaGFzX3NpemUgfHwgdHlwZSAhPSBoYXNfdHlwZSB8fAoJCSAgICBtZW1jbXAoZGF0YSwgaGFzX2RhdGEsIHNpemUpICE9IDApCgkJCWRpZShfKCJTSEExIENPTExJU0lPTiBGT1VORCBXSVRIICVzICEiKSwgb2lkX3RvX2hleChvaWQpKTsKCQlmcmVlKGhhc19kYXRhKTsKCX0KCglpZiAoc3RyaWN0IHx8IGRvX2ZzY2tfb2JqZWN0KSB7CgkJcmVhZF9sb2NrKCk7CgkJaWYgKHR5cGUgPT0gT0JKX0JMT0IpIHsKCQkJc3RydWN0IGJsb2IgKmJsb2IgPSBsb29rdXBfYmxvYih0aGVfcmVwb3NpdG9yeSwgb2lkKTsKCQkJaWYgKGJsb2IpCgkJCQlibG9iLT5vYmplY3QuZmxhZ3MgfD0gRkxBR19DSEVDS0VEOwoJCQllbHNlCgkJCQlkaWUoXygiaW52YWxpZCBibG9iIG9iamVjdCAlcyIpLCBvaWRfdG9faGV4KG9pZCkpOwoJCQlpZiAoZG9fZnNja19vYmplY3QgJiYKCQkJICAgIGZzY2tfb2JqZWN0KCZibG9iLT5vYmplY3QsICh2b2lkICopZGF0YSwgc2l6ZSwgJmZzY2tfb3B0aW9ucykpCgkJCQlkaWUoXygiZnNjayBlcnJvciBpbiBwYWNrZWQgb2JqZWN0IikpOwoJCX0gZWxzZSB7CgkJCXN0cnVjdCBvYmplY3QgKm9iajsKCQkJaW50IGVhdGVuOwoJCQl2b2lkICpidWYgPSAodm9pZCAqKSBkYXRhOwoKCQkJYXNzZXJ0KGRhdGEgJiYgImRhdGEgY2FuIG9ubHkgYmUgTlVMTCBmb3IgbGFyZ2UgX2Jsb2JzXyIpOwoKCQkJLyoKCQkJICogd2UgZG8gbm90IG5lZWQgdG8gZnJlZSB0aGUgbWVtb3J5IGhlcmUsIGFzIHRoZQoJCQkgKiBidWYgaXMgZGVsZXRlZCBieSB0aGUgY2FsbGVyLgoJCQkgKi8KCQkJb2JqID0gcGFyc2Vfb2JqZWN0X2J1ZmZlcih0aGVfcmVwb3NpdG9yeSwgb2lkLCB0eXBlLAoJCQkJCQkgIHNpemUsIGJ1ZiwKCQkJCQkJICAmZWF0ZW4pOwoJCQlpZiAoIW9iaikKCQkJCWRpZShfKCJpbnZhbGlkICVzIiksIHR5cGVfbmFtZSh0eXBlKSk7CgkJCWlmIChkb19mc2NrX29iamVjdCAmJgoJCQkgICAgZnNja19vYmplY3Qob2JqLCBidWYsIHNpemUsICZmc2NrX29wdGlvbnMpKQoJCQkJZGllKF8oImZzY2sgZXJyb3IgaW4gcGFja2VkIG9iamVjdCIpKTsKCQkJaWYgKHN0cmljdCAmJiBmc2NrX3dhbGsob2JqLCBOVUxMLCAmZnNja19vcHRpb25zKSkKCQkJCWRpZShfKCJOb3QgYWxsIGNoaWxkIG9iamVjdHMgb2YgJXMgYXJlIHJlYWNoYWJsZSIpLCBvaWRfdG9faGV4KCZvYmotPm9pZCkpOwoKCQkJaWYgKG9iai0+dHlwZSA9PSBPQkpfVFJFRSkgewoJCQkJc3RydWN0IHRyZWUgKml0ZW0gPSAoc3RydWN0IHRyZWUgKikgb2JqOwoJCQkJaXRlbS0+YnVmZmVyID0gTlVMTDsKCQkJCW9iai0+cGFyc2VkID0gMDsKCQkJfQoJCQlpZiAob2JqLT50eXBlID09IE9CSl9DT01NSVQpIHsKCQkJCXN0cnVjdCBjb21taXQgKmNvbW1pdCA9IChzdHJ1Y3QgY29tbWl0ICopIG9iajsKCQkJCWlmIChkZXRhY2hfY29tbWl0X2J1ZmZlcihjb21taXQsIE5VTEwpICE9IGRhdGEpCgkJCQkJQlVHKCJwYXJzZV9vYmplY3RfYnVmZmVyIHRyYW5zbW9ncmlmaWVkIG91ciBidWZmZXIiKTsKCQkJfQoJCQlvYmotPmZsYWdzIHw9IEZMQUdfQ0hFQ0tFRDsKCQl9CgkJcmVhZF91bmxvY2soKTsKCX0KCglmcmVlKG5ld19kYXRhKTsKfQoKLyoKICogRW5zdXJlIHRoYXQgdGhpcyBub2RlIGhhcyBiZWVuIHJlY29uc3RydWN0ZWQgYW5kIHJldHVybiBpdHMgY29udGVudHMuCiAqCiAqIEluIHRoZSB0eXBpY2FsIGFuZCBiZXN0IGNhc2UsIHRoaXMgbm9kZSB3b3VsZCBhbHJlYWR5IGJlIHJlY29uc3RydWN0ZWQKICogKHRocm91Z2ggdGhlIGludm9jYXRpb24gdG8gcmVzb2x2ZV9kZWx0YSgpIGluIHRocmVhZGVkX3NlY29uZF9wYXNzKCkpIGFuZCBpdAogKiB3b3VsZCBub3QgYmUgcHJ1bmVkLiBIb3dldmVyLCBpZiBwcnVuaW5nIG9mIHRoaXMgbm9kZSB3YXMgbmVjZXNzYXJ5IGR1ZSB0bwogKiByZWFjaGluZyBkZWx0YV9iYXNlX2NhY2hlX2xpbWl0LCB0aGlzIGZ1bmN0aW9uIHdpbGwgZmluZCB0aGUgY2xvc2VzdAogKiBhbmNlc3RvciB3aXRoIHJlY29uc3RydWN0ZWQgZGF0YSB0aGF0IGhhcyBub3QgYmVlbiBwcnVuZWQgKG9yIGlmIHRoZXJlIGlzCiAqIG5vbmUsIHRoZSB1bHRpbWF0ZSBiYXNlIG9iamVjdCksIGFuZCByZWNvbnN0cnVjdCBlYWNoIG5vZGUgaW4gdGhlIGRlbHRhCiAqIGNoYWluIGluIG9yZGVyIHRvIGdlbmVyYXRlIHRoZSByZWNvbnN0cnVjdGVkIGRhdGEgZm9yIHRoaXMgbm9kZS4KICovCnN0YXRpYyB2b2lkICpnZXRfYmFzZV9kYXRhKHN0cnVjdCBiYXNlX2RhdGEgKmMpCnsKCWlmICghYy0+ZGF0YSkgewoJCXN0cnVjdCBvYmplY3RfZW50cnkgKm9iaiA9IGMtPm9iajsKCQlzdHJ1Y3QgYmFzZV9kYXRhICoqZGVsdGEgPSBOVUxMOwoJCWludCBkZWx0YV9uciA9IDAsIGRlbHRhX2FsbG9jID0gMDsKCgkJd2hpbGUgKGlzX2RlbHRhX3R5cGUoYy0+b2JqLT50eXBlKSAmJiAhYy0+ZGF0YSkgewoJCQlBTExPQ19HUk9XKGRlbHRhLCBkZWx0YV9uciArIDEsIGRlbHRhX2FsbG9jKTsKCQkJZGVsdGFbZGVsdGFfbnIrK10gPSBjOwoJCQljID0gYy0+YmFzZTsKCQl9CgkJaWYgKCFkZWx0YV9ucikgewoJCQljLT5kYXRhID0gZ2V0X2RhdGFfZnJvbV9wYWNrKG9iaik7CgkJCWMtPnNpemUgPSBvYmotPnNpemU7CgkJCWJhc2VfY2FjaGVfdXNlZCArPSBjLT5zaXplOwoJCQlwcnVuZV9iYXNlX2RhdGEoYyk7CgkJfQoJCWZvciAoOyBkZWx0YV9uciA+IDA7IGRlbHRhX25yLS0pIHsKCQkJdm9pZCAqYmFzZSwgKnJhdzsKCQkJYyA9IGRlbHRhW2RlbHRhX25yIC0gMV07CgkJCW9iaiA9IGMtPm9iajsKCQkJYmFzZSA9IGdldF9iYXNlX2RhdGEoYy0+YmFzZSk7CgkJCXJhdyA9IGdldF9kYXRhX2Zyb21fcGFjayhvYmopOwoJCQljLT5kYXRhID0gcGF0Y2hfZGVsdGEoCgkJCQliYXNlLCBjLT5iYXNlLT5zaXplLAoJCQkJcmF3LCBvYmotPnNpemUsCgkJCQkmYy0+c2l6ZSk7CgkJCWZyZWUocmF3KTsKCQkJaWYgKCFjLT5kYXRhKQoJCQkJYmFkX29iamVjdChvYmotPmlkeC5vZmZzZXQsIF8oImZhaWxlZCB0byBhcHBseSBkZWx0YSIpKTsKCQkJYmFzZV9jYWNoZV91c2VkICs9IGMtPnNpemU7CgkJCXBydW5lX2Jhc2VfZGF0YShjKTsKCQl9CgkJZnJlZShkZWx0YSk7Cgl9CglyZXR1cm4gYy0+ZGF0YTsKfQoKc3RhdGljIHN0cnVjdCBiYXNlX2RhdGEgKm1ha2VfYmFzZShzdHJ1Y3Qgb2JqZWN0X2VudHJ5ICpvYmosCgkJCQkgICBzdHJ1Y3QgYmFzZV9kYXRhICpwYXJlbnQpCnsKCXN0cnVjdCBiYXNlX2RhdGEgKmJhc2UgPSB4Y2FsbG9jKDEsIHNpemVvZihzdHJ1Y3QgYmFzZV9kYXRhKSk7CgliYXNlLT5iYXNlID0gcGFyZW50OwoJYmFzZS0+b2JqID0gb2JqOwoJZmluZF9yZWZfZGVsdGFfY2hpbGRyZW4oJm9iai0+aWR4Lm9pZCwKCQkJCSZiYXNlLT5yZWZfZmlyc3QsICZiYXNlLT5yZWZfbGFzdCk7CglmaW5kX29mc19kZWx0YV9jaGlsZHJlbihvYmotPmlkeC5vZmZzZXQsCgkJCQkmYmFzZS0+b2ZzX2ZpcnN0LCAmYmFzZS0+b2ZzX2xhc3QpOwoJYmFzZS0+Y2hpbGRyZW5fcmVtYWluaW5nID0gYmFzZS0+cmVmX2xhc3QgLSBiYXNlLT5yZWZfZmlyc3QgKwoJCWJhc2UtPm9mc19sYXN0IC0gYmFzZS0+b2ZzX2ZpcnN0ICsgMjsKCXJldHVybiBiYXNlOwp9CgpzdGF0aWMgc3RydWN0IGJhc2VfZGF0YSAqcmVzb2x2ZV9kZWx0YShzdHJ1Y3Qgb2JqZWN0X2VudHJ5ICpkZWx0YV9vYmosCgkJCQkgICAgICAgc3RydWN0IGJhc2VfZGF0YSAqYmFzZSkKewoJdm9pZCAqZGVsdGFfZGF0YSwgKnJlc3VsdF9kYXRhOwoJc3RydWN0IGJhc2VfZGF0YSAqcmVzdWx0OwoJdW5zaWduZWQgbG9uZyByZXN1bHRfc2l6ZTsKCglpZiAoc2hvd19zdGF0KSB7CgkJaW50IGkgPSBkZWx0YV9vYmogLSBvYmplY3RzOwoJCWludCBqID0gYmFzZS0+b2JqIC0gb2JqZWN0czsKCQlvYmpfc3RhdFtpXS5kZWx0YV9kZXB0aCA9IG9ial9zdGF0W2pdLmRlbHRhX2RlcHRoICsgMTsKCQlkZWVwZXN0X2RlbHRhX2xvY2soKTsKCQlpZiAoZGVlcGVzdF9kZWx0YSA8IG9ial9zdGF0W2ldLmRlbHRhX2RlcHRoKQoJCQlkZWVwZXN0X2RlbHRhID0gb2JqX3N0YXRbaV0uZGVsdGFfZGVwdGg7CgkJZGVlcGVzdF9kZWx0YV91bmxvY2soKTsKCQlvYmpfc3RhdFtpXS5iYXNlX29iamVjdF9ubyA9IGo7Cgl9CglkZWx0YV9kYXRhID0gZ2V0X2RhdGFfZnJvbV9wYWNrKGRlbHRhX29iaik7Cglhc3NlcnQoYmFzZS0+ZGF0YSk7CglyZXN1bHRfZGF0YSA9IHBhdGNoX2RlbHRhKGJhc2UtPmRhdGEsIGJhc2UtPnNpemUsCgkJCQkgIGRlbHRhX2RhdGEsIGRlbHRhX29iai0+c2l6ZSwgJnJlc3VsdF9zaXplKTsKCWZyZWUoZGVsdGFfZGF0YSk7CglpZiAoIXJlc3VsdF9kYXRhKQoJCWJhZF9vYmplY3QoZGVsdGFfb2JqLT5pZHgub2Zmc2V0LCBfKCJmYWlsZWQgdG8gYXBwbHkgZGVsdGEiKSk7CgloYXNoX29iamVjdF9maWxlKHRoZV9oYXNoX2FsZ28sIHJlc3VsdF9kYXRhLCByZXN1bHRfc2l6ZSwKCQkJIGRlbHRhX29iai0+cmVhbF90eXBlLCAmZGVsdGFfb2JqLT5pZHgub2lkKTsKCXNoYTFfb2JqZWN0KHJlc3VsdF9kYXRhLCBOVUxMLCByZXN1bHRfc2l6ZSwgZGVsdGFfb2JqLT5yZWFsX3R5cGUsCgkJICAgICZkZWx0YV9vYmotPmlkeC5vaWQpOwoKCXJlc3VsdCA9IG1ha2VfYmFzZShkZWx0YV9vYmosIGJhc2UpOwoJcmVzdWx0LT5kYXRhID0gcmVzdWx0X2RhdGE7CglyZXN1bHQtPnNpemUgPSByZXN1bHRfc2l6ZTsKCgljb3VudGVyX2xvY2soKTsKCW5yX3Jlc29sdmVkX2RlbHRhcysrOwoJY291bnRlcl91bmxvY2soKTsKCglyZXR1cm4gcmVzdWx0Owp9CgpzdGF0aWMgaW50IGNvbXBhcmVfb2ZzX2RlbHRhX2VudHJ5KGNvbnN0IHZvaWQgKmEsIGNvbnN0IHZvaWQgKmIpCnsKCWNvbnN0IHN0cnVjdCBvZnNfZGVsdGFfZW50cnkgKmRlbHRhX2EgPSBhOwoJY29uc3Qgc3RydWN0IG9mc19kZWx0YV9lbnRyeSAqZGVsdGFfYiA9IGI7CgoJcmV0dXJuIGRlbHRhX2EtPm9mZnNldCA8IGRlbHRhX2ItPm9mZnNldCA/IC0xIDoKCSAgICAgICBkZWx0YV9hLT5vZmZzZXQgPiBkZWx0YV9iLT5vZmZzZXQgPyAgMSA6CgkgICAgICAgMDsKfQoKc3RhdGljIGludCBjb21wYXJlX3JlZl9kZWx0YV9lbnRyeShjb25zdCB2b2lkICphLCBjb25zdCB2b2lkICpiKQp7Cgljb25zdCBzdHJ1Y3QgcmVmX2RlbHRhX2VudHJ5ICpkZWx0YV9hID0gYTsKCWNvbnN0IHN0cnVjdCByZWZfZGVsdGFfZW50cnkgKmRlbHRhX2IgPSBiOwoKCXJldHVybiBvaWRjbXAoJmRlbHRhX2EtPm9pZCwgJmRlbHRhX2ItPm9pZCk7Cn0KCnN0YXRpYyB2b2lkICp0aHJlYWRlZF9zZWNvbmRfcGFzcyh2b2lkICpkYXRhKQp7CglpZiAoZGF0YSkKCQlzZXRfdGhyZWFkX2RhdGEoZGF0YSk7Cglmb3IgKDs7KSB7CgkJc3RydWN0IGJhc2VfZGF0YSAqcGFyZW50ID0gTlVMTDsKCQlzdHJ1Y3Qgb2JqZWN0X2VudHJ5ICpjaGlsZF9vYmo7CgkJc3RydWN0IGJhc2VfZGF0YSAqY2hpbGQ7CgoJCWNvdW50ZXJfbG9jaygpOwoJCWRpc3BsYXlfcHJvZ3Jlc3MocHJvZ3Jlc3MsIG5yX3Jlc29sdmVkX2RlbHRhcyk7CgkJY291bnRlcl91bmxvY2soKTsKCgkJd29ya19sb2NrKCk7CgkJaWYgKGxpc3RfZW1wdHkoJndvcmtfaGVhZCkpIHsKCQkJLyoKCQkJICogVGFrZSBhbiBvYmplY3QgZnJvbSB0aGUgb2JqZWN0IGFycmF5LgoJCQkgKi8KCQkJd2hpbGUgKG5yX2Rpc3BhdGNoZWQgPCBucl9vYmplY3RzICYmCgkJCSAgICAgICBpc19kZWx0YV90eXBlKG9iamVjdHNbbnJfZGlzcGF0Y2hlZF0udHlwZSkpCgkJCQlucl9kaXNwYXRjaGVkKys7CgkJCWlmIChucl9kaXNwYXRjaGVkID49IG5yX29iamVjdHMpIHsKCQkJCXdvcmtfdW5sb2NrKCk7CgkJCQlicmVhazsKCQkJfQoJCQljaGlsZF9vYmogPSAmb2JqZWN0c1tucl9kaXNwYXRjaGVkKytdOwoJCX0gZWxzZSB7CgkJCS8qCgkJCSAqIFBlZWsgYXQgdGhlIHRvcCBvZiB0aGUgc3RhY2ssIGFuZCB0YWtlIGEgY2hpbGQgZnJvbQoJCQkgKiBpdC4KCQkJICovCgkJCXBhcmVudCA9IGxpc3RfZmlyc3RfZW50cnkoJndvcmtfaGVhZCwgc3RydWN0IGJhc2VfZGF0YSwKCQkJCQkJICBsaXN0KTsKCgkJCWlmIChwYXJlbnQtPnJlZl9maXJzdCA8PSBwYXJlbnQtPnJlZl9sYXN0KSB7CgkJCQlpbnQgb2Zmc2V0ID0gcmVmX2RlbHRhc1twYXJlbnQtPnJlZl9maXJzdCsrXS5vYmpfbm87CgkJCQljaGlsZF9vYmogPSBvYmplY3RzICsgb2Zmc2V0OwoJCQkJaWYgKGNoaWxkX29iai0+cmVhbF90eXBlICE9IE9CSl9SRUZfREVMVEEpCgkJCQkJZGllKCJSRUZfREVMVEEgYXQgb2Zmc2V0ICUiUFJJdU1BWCIgYWxyZWFkeSByZXNvbHZlZCAoZHVwbGljYXRlIGJhc2UgJXM/KSIsCgkJCQkJICAgICh1aW50bWF4X3QpIGNoaWxkX29iai0+aWR4Lm9mZnNldCwKCQkJCQkgICAgb2lkX3RvX2hleCgmcGFyZW50LT5vYmotPmlkeC5vaWQpKTsKCQkJCWNoaWxkX29iai0+cmVhbF90eXBlID0gcGFyZW50LT5vYmotPnJlYWxfdHlwZTsKCQkJfSBlbHNlIHsKCQkJCWNoaWxkX29iaiA9IG9iamVjdHMgKwoJCQkJCW9mc19kZWx0YXNbcGFyZW50LT5vZnNfZmlyc3QrK10ub2JqX25vOwoJCQkJYXNzZXJ0KGNoaWxkX29iai0+cmVhbF90eXBlID09IE9CSl9PRlNfREVMVEEpOwoJCQkJY2hpbGRfb2JqLT5yZWFsX3R5cGUgPSBwYXJlbnQtPm9iai0+cmVhbF90eXBlOwoJCQl9CgoJCQlpZiAocGFyZW50LT5yZWZfZmlyc3QgPiBwYXJlbnQtPnJlZl9sYXN0ICYmCgkJCSAgICBwYXJlbnQtPm9mc19maXJzdCA+IHBhcmVudC0+b2ZzX2xhc3QpIHsKCQkJCS8qCgkJCQkgKiBUaGlzIHBhcmVudCBoYXMgcnVuIG91dCBvZiBjaGlsZHJlbiwgc28gbW92ZQoJCQkJICogaXQgdG8gZG9uZV9oZWFkLgoJCQkJICovCgkJCQlsaXN0X2RlbCgmcGFyZW50LT5saXN0KTsKCQkJCWxpc3RfYWRkKCZwYXJlbnQtPmxpc3QsICZkb25lX2hlYWQpOwoJCQl9CgoJCQkvKgoJCQkgKiBFbnN1cmUgdGhhdCB0aGUgcGFyZW50IGhhcyBkYXRhLCBzaW5jZSB3ZSB3aWxsIG5lZWQKCQkJICogaXQgbGF0ZXIuCgkJCSAqCgkJCSAqIE5FRURTV09SSzogSWYgcGFyZW50IGRhdGEgbmVlZHMgdG8gYmUgcmVsb2FkZWQsIHRoaXMKCQkJICogcHJvbG9uZ3MgdGhlIHRpbWUgdGhhdCB0aGUgY3VycmVudCB0aHJlYWQgc3BlbmRzIGluCgkJCSAqIHRoZSBtdXRleC4gQSBtaXRpZ2F0aW5nIGZhY3RvciBpcyB0aGF0IHBhcmVudCBkYXRhCgkJCSAqIG5lZWRzIHRvIGJlIHJlbG9hZGVkIG9ubHkgaWYgdGhlIGRlbHRhIGJhc2UgY2FjaGUKCQkJICogbGltaXQgaXMgZXhjZWVkZWQsIHNvIGluIHRoZSB0eXBpY2FsIGNhc2UsIHRoaXMgZG9lcwoJCQkgKiBub3QgaGFwcGVuLgoJCQkgKi8KCQkJZ2V0X2Jhc2VfZGF0YShwYXJlbnQpOwoJCQlwYXJlbnQtPnJldGFpbl9kYXRhKys7CgkJfQoJCXdvcmtfdW5sb2NrKCk7CgoJCWlmIChwYXJlbnQpIHsKCQkJY2hpbGQgPSByZXNvbHZlX2RlbHRhKGNoaWxkX29iaiwgcGFyZW50KTsKCQkJaWYgKCFjaGlsZC0+Y2hpbGRyZW5fcmVtYWluaW5nKQoJCQkJRlJFRV9BTkRfTlVMTChjaGlsZC0+ZGF0YSk7CgkJfSBlbHNlIHsKCQkJY2hpbGQgPSBtYWtlX2Jhc2UoY2hpbGRfb2JqLCBOVUxMKTsKCQkJaWYgKGNoaWxkLT5jaGlsZHJlbl9yZW1haW5pbmcpIHsKCQkJCS8qCgkJCQkgKiBTaW5jZSB0aGlzIGNoaWxkIGhhcyBpdHMgb3duIGRlbHRhIGNoaWxkcmVuLAoJCQkJICogd2Ugd2lsbCBuZWVkIHRoaXMgZGF0YSBpbiB0aGUgZnV0dXJlLgoJCQkJICogSW5mbGF0ZSBub3cgc28gdGhhdCBmdXR1cmUgaXRlcmF0aW9ucyB3aWxsCgkJCQkgKiBoYXZlIGFjY2VzcyB0byB0aGlzIG9iamVjdCdzIGRhdGEgd2hpbGUKCQkJCSAqIG91dHNpZGUgdGhlIHdvcmsgbXV0ZXguCgkJCQkgKi8KCQkJCWNoaWxkLT5kYXRhID0gZ2V0X2RhdGFfZnJvbV9wYWNrKGNoaWxkX29iaik7CgkJCQljaGlsZC0+c2l6ZSA9IGNoaWxkX29iai0+c2l6ZTsKCQkJfQoJCX0KCgkJd29ya19sb2NrKCk7CgkJaWYgKHBhcmVudCkKCQkJcGFyZW50LT5yZXRhaW5fZGF0YS0tOwoJCWlmIChjaGlsZC0+ZGF0YSkgewoJCQkvKgoJCQkgKiBUaGlzIGNoaWxkIGhhcyBpdHMgb3duIGNoaWxkcmVuLCBzbyBhZGQgaXQgdG8KCQkJICogd29ya19oZWFkLgoJCQkgKi8KCQkJbGlzdF9hZGQoJmNoaWxkLT5saXN0LCAmd29ya19oZWFkKTsKCQkJYmFzZV9jYWNoZV91c2VkICs9IGNoaWxkLT5zaXplOwoJCQlwcnVuZV9iYXNlX2RhdGEoTlVMTCk7CgkJCWZyZWVfYmFzZV9kYXRhKGNoaWxkKTsKCQl9IGVsc2UgewoJCQkvKgoJCQkgKiBUaGlzIGNoaWxkIGRvZXMgbm90IGhhdmUgaXRzIG93biBjaGlsZHJlbi4gSXQgbWF5IGJlCgkJCSAqIHRoZSBsYXN0IGRlc2NlbmRhbnQgb2YgaXRzIGFuY2VzdG9yczsgZnJlZSB0aG9zZQoJCQkgKiB0aGF0IHdlIGNhbi4KCQkJICovCgkJCXN0cnVjdCBiYXNlX2RhdGEgKnAgPSBwYXJlbnQ7CgoJCQl3aGlsZSAocCkgewoJCQkJc3RydWN0IGJhc2VfZGF0YSAqbmV4dF9wOwoKCQkJCXAtPmNoaWxkcmVuX3JlbWFpbmluZy0tOwoJCQkJaWYgKHAtPmNoaWxkcmVuX3JlbWFpbmluZykKCQkJCQlicmVhazsKCgkJCQluZXh0X3AgPSBwLT5iYXNlOwoJCQkJZnJlZV9iYXNlX2RhdGEocCk7CgkJCQlsaXN0X2RlbCgmcC0+bGlzdCk7CgkJCQlmcmVlKHApOwoKCQkJCXAgPSBuZXh0X3A7CgkJCX0KCQkJRlJFRV9BTkRfTlVMTChjaGlsZCk7CgkJfQoJCXdvcmtfdW5sb2NrKCk7Cgl9CglyZXR1cm4gTlVMTDsKfQoKLyoKICogRmlyc3QgcGFzczoKICogLSBmaW5kIGxvY2F0aW9ucyBvZiBhbGwgb2JqZWN0czsKICogLSBjYWxjdWxhdGUgU0hBMSBvZiBhbGwgbm9uLWRlbHRhIG9iamVjdHM7CiAqIC0gcmVtZW1iZXIgYmFzZSAoU0hBMSBvciBvZmZzZXQpIGZvciBhbGwgZGVsdGFzLgogKi8Kc3RhdGljIHZvaWQgcGFyc2VfcGFja19vYmplY3RzKHVuc2lnbmVkIGNoYXIgKmhhc2gpCnsKCWludCBpLCBucl9kZWxheXMgPSAwOwoJc3RydWN0IG9mc19kZWx0YV9lbnRyeSAqb2ZzX2RlbHRhID0gb2ZzX2RlbHRhczsKCXN0cnVjdCBvYmplY3RfaWQgcmVmX2RlbHRhX29pZDsKCXN0cnVjdCBzdGF0IHN0OwoKCWlmICh2ZXJib3NlKQoJCXByb2dyZXNzID0gc3RhcnRfcHJvZ3Jlc3MoCgkJCQlwcm9ncmVzc190aXRsZSA/IHByb2dyZXNzX3RpdGxlIDoKCQkJCWZyb21fc3RkaW4gPyBfKCJSZWNlaXZpbmcgb2JqZWN0cyIpIDogXygiSW5kZXhpbmcgb2JqZWN0cyIpLAoJCQkJbnJfb2JqZWN0cyk7Cglmb3IgKGkgPSAwOyBpIDwgbnJfb2JqZWN0czsgaSsrKSB7CgkJc3RydWN0IG9iamVjdF9lbnRyeSAqb2JqID0gJm9iamVjdHNbaV07CgkJdm9pZCAqZGF0YSA9IHVucGFja19yYXdfZW50cnkob2JqLCAmb2ZzX2RlbHRhLT5vZmZzZXQsCgkJCQkJICAgICAgJnJlZl9kZWx0YV9vaWQsCgkJCQkJICAgICAgJm9iai0+aWR4Lm9pZCk7CgkJb2JqLT5yZWFsX3R5cGUgPSBvYmotPnR5cGU7CgkJaWYgKG9iai0+dHlwZSA9PSBPQkpfT0ZTX0RFTFRBKSB7CgkJCW5yX29mc19kZWx0YXMrKzsKCQkJb2ZzX2RlbHRhLT5vYmpfbm8gPSBpOwoJCQlvZnNfZGVsdGErKzsKCQl9IGVsc2UgaWYgKG9iai0+dHlwZSA9PSBPQkpfUkVGX0RFTFRBKSB7CgkJCUFMTE9DX0dST1cocmVmX2RlbHRhcywgbnJfcmVmX2RlbHRhcyArIDEsIHJlZl9kZWx0YXNfYWxsb2MpOwoJCQlvaWRjcHkoJnJlZl9kZWx0YXNbbnJfcmVmX2RlbHRhc10ub2lkLCAmcmVmX2RlbHRhX29pZCk7CgkJCXJlZl9kZWx0YXNbbnJfcmVmX2RlbHRhc10ub2JqX25vID0gaTsKCQkJbnJfcmVmX2RlbHRhcysrOwoJCX0gZWxzZSBpZiAoIWRhdGEpIHsKCQkJLyogbGFyZ2UgYmxvYnMsIGNoZWNrIGxhdGVyICovCgkJCW9iai0+cmVhbF90eXBlID0gT0JKX0JBRDsKCQkJbnJfZGVsYXlzKys7CgkJfSBlbHNlCgkJCXNoYTFfb2JqZWN0KGRhdGEsIE5VTEwsIG9iai0+c2l6ZSwgb2JqLT50eXBlLAoJCQkJICAgICZvYmotPmlkeC5vaWQpOwoJCWZyZWUoZGF0YSk7CgkJZGlzcGxheV9wcm9ncmVzcyhwcm9ncmVzcywgaSsxKTsKCX0KCW9iamVjdHNbaV0uaWR4Lm9mZnNldCA9IGNvbnN1bWVkX2J5dGVzOwoJc3RvcF9wcm9ncmVzcygmcHJvZ3Jlc3MpOwoKCS8qIENoZWNrIHBhY2sgaW50ZWdyaXR5ICovCglmbHVzaCgpOwoJdGhlX2hhc2hfYWxnby0+ZmluYWxfZm4oaGFzaCwgJmlucHV0X2N0eCk7CglpZiAoIWhhc2hlcShmaWxsKHRoZV9oYXNoX2FsZ28tPnJhd3N6KSwgaGFzaCkpCgkJZGllKF8oInBhY2sgaXMgY29ycnVwdGVkIChTSEExIG1pc21hdGNoKSIpKTsKCXVzZSh0aGVfaGFzaF9hbGdvLT5yYXdzeik7CgoJLyogSWYgaW5wdXRfZmQgaXMgYSBmaWxlLCB3ZSBzaG91bGQgaGF2ZSByZWFjaGVkIGl0cyBlbmQgbm93LiAqLwoJaWYgKGZzdGF0KGlucHV0X2ZkLCAmc3QpKQoJCWRpZV9lcnJubyhfKCJjYW5ub3QgZnN0YXQgcGFja2ZpbGUiKSk7CglpZiAoU19JU1JFRyhzdC5zdF9tb2RlKSAmJgoJCQlsc2VlayhpbnB1dF9mZCwgMCwgU0VFS19DVVIpIC0gaW5wdXRfbGVuICE9IHN0LnN0X3NpemUpCgkJZGllKF8oInBhY2sgaGFzIGp1bmsgYXQgdGhlIGVuZCIpKTsKCglmb3IgKGkgPSAwOyBpIDwgbnJfb2JqZWN0czsgaSsrKSB7CgkJc3RydWN0IG9iamVjdF9lbnRyeSAqb2JqID0gJm9iamVjdHNbaV07CgkJaWYgKG9iai0+cmVhbF90eXBlICE9IE9CSl9CQUQpCgkJCWNvbnRpbnVlOwoJCW9iai0+cmVhbF90eXBlID0gb2JqLT50eXBlOwoJCXNoYTFfb2JqZWN0KE5VTEwsIG9iaiwgb2JqLT5zaXplLCBvYmotPnR5cGUsCgkJCSAgICAmb2JqLT5pZHgub2lkKTsKCQlucl9kZWxheXMtLTsKCX0KCWlmIChucl9kZWxheXMpCgkJZGllKF8oImNvbmZ1c2lvbiBiZXlvbmQgaW5zYW5pdHkgaW4gcGFyc2VfcGFja19vYmplY3RzKCkiKSk7Cn0KCi8qCiAqIFNlY29uZCBwYXNzOgogKiAtIGZvciBhbGwgbm9uLWRlbHRhIG9iamVjdHMsIGxvb2sgaWYgaXQgaXMgdXNlZCBhcyBhIGJhc2UgZm9yCiAqICAgZGVsdGFzOwogKiAtIGlmIHVzZWQgYXMgYSBiYXNlLCB1bmNvbXByZXNzIHRoZSBvYmplY3QgYW5kIGFwcGx5IGFsbCBkZWx0YXMsCiAqICAgcmVjdXJzaXZlbHkgY2hlY2tpbmcgaWYgdGhlIHJlc3VsdGluZyBvYmplY3QgaXMgdXNlZCBhcyBhIGJhc2UKICogICBmb3Igc29tZSBtb3JlIGRlbHRhcy4KICovCnN0YXRpYyB2b2lkIHJlc29sdmVfZGVsdGFzKHZvaWQpCnsKCWludCBpOwoKCWlmICghbnJfb2ZzX2RlbHRhcyAmJiAhbnJfcmVmX2RlbHRhcykKCQlyZXR1cm47CgoJLyogU29ydCBkZWx0YXMgYnkgYmFzZSBTSEExL29mZnNldCBmb3IgZmFzdCBzZWFyY2hpbmcgKi8KCVFTT1JUKG9mc19kZWx0YXMsIG5yX29mc19kZWx0YXMsIGNvbXBhcmVfb2ZzX2RlbHRhX2VudHJ5KTsKCVFTT1JUKHJlZl9kZWx0YXMsIG5yX3JlZl9kZWx0YXMsIGNvbXBhcmVfcmVmX2RlbHRhX2VudHJ5KTsKCglpZiAodmVyYm9zZSB8fCBzaG93X3Jlc29sdmluZ19wcm9ncmVzcykKCQlwcm9ncmVzcyA9IHN0YXJ0X3Byb2dyZXNzKF8oIlJlc29sdmluZyBkZWx0YXMiKSwKCQkJCQkgIG5yX3JlZl9kZWx0YXMgKyBucl9vZnNfZGVsdGFzKTsKCglucl9kaXNwYXRjaGVkID0gMDsKCWJhc2VfY2FjaGVfbGltaXQgPSBkZWx0YV9iYXNlX2NhY2hlX2xpbWl0ICogbnJfdGhyZWFkczsKCWlmIChucl90aHJlYWRzID4gMSB8fCBnZXRlbnYoIkdJVF9GT1JDRV9USFJFQURTIikpIHsKCQlpbml0X3RocmVhZCgpOwoJCWZvciAoaSA9IDA7IGkgPCBucl90aHJlYWRzOyBpKyspIHsKCQkJaW50IHJldCA9IHB0aHJlYWRfY3JlYXRlKCZ0aHJlYWRfZGF0YVtpXS50aHJlYWQsIE5VTEwsCgkJCQkJCSB0aHJlYWRlZF9zZWNvbmRfcGFzcywgdGhyZWFkX2RhdGEgKyBpKTsKCQkJaWYgKHJldCkKCQkJCWRpZShfKCJ1bmFibGUgdG8gY3JlYXRlIHRocmVhZDogJXMiKSwKCQkJCSAgICBzdHJlcnJvcihyZXQpKTsKCQl9CgkJZm9yIChpID0gMDsgaSA8IG5yX3RocmVhZHM7IGkrKykKCQkJcHRocmVhZF9qb2luKHRocmVhZF9kYXRhW2ldLnRocmVhZCwgTlVMTCk7CgkJY2xlYW51cF90aHJlYWQoKTsKCQlyZXR1cm47Cgl9Cgl0aHJlYWRlZF9zZWNvbmRfcGFzcygmbm90aHJlYWRfZGF0YSk7Cn0KCi8qCiAqIFRoaXJkIHBhc3M6CiAqIC0gYXBwZW5kIG9iamVjdHMgdG8gY29udmVydCB0aGluIHBhY2sgdG8gZnVsbCBwYWNrIGlmIHJlcXVpcmVkCiAqIC0gd3JpdGUgdGhlIGZpbmFsIHBhY2sgaGFzaAogKi8Kc3RhdGljIHZvaWQgZml4X3VucmVzb2x2ZWRfZGVsdGFzKHN0cnVjdCBoYXNoZmlsZSAqZik7CnN0YXRpYyB2b2lkIGNvbmNsdWRlX3BhY2soaW50IGZpeF90aGluX3BhY2ssIGNvbnN0IGNoYXIgKmN1cnJfcGFjaywgdW5zaWduZWQgY2hhciAqcGFja19oYXNoKQp7CglpZiAobnJfcmVmX2RlbHRhcyArIG5yX29mc19kZWx0YXMgPT0gbnJfcmVzb2x2ZWRfZGVsdGFzKSB7CgkJc3RvcF9wcm9ncmVzcygmcHJvZ3Jlc3MpOwoJCS8qIEZsdXNoIHJlbWFpbmluZyBwYWNrIGZpbmFsIGhhc2guICovCgkJZmx1c2goKTsKCQlyZXR1cm47Cgl9CgoJaWYgKGZpeF90aGluX3BhY2spIHsKCQlzdHJ1Y3QgaGFzaGZpbGUgKmY7CgkJdW5zaWduZWQgY2hhciByZWFkX2hhc2hbR0lUX01BWF9SQVdTWl0sIHRhaWxfaGFzaFtHSVRfTUFYX1JBV1NaXTsKCQlzdHJ1Y3Qgc3RyYnVmIG1zZyA9IFNUUkJVRl9JTklUOwoJCWludCBucl91bnJlc29sdmVkID0gbnJfb2ZzX2RlbHRhcyArIG5yX3JlZl9kZWx0YXMgLSBucl9yZXNvbHZlZF9kZWx0YXM7CgkJaW50IG5yX29iamVjdHNfaW5pdGlhbCA9IG5yX29iamVjdHM7CgkJaWYgKG5yX3VucmVzb2x2ZWQgPD0gMCkKCQkJZGllKF8oImNvbmZ1c2lvbiBiZXlvbmQgaW5zYW5pdHkiKSk7CgkJUkVBTExPQ19BUlJBWShvYmplY3RzLCBucl9vYmplY3RzICsgbnJfdW5yZXNvbHZlZCArIDEpOwoJCW1lbXNldChvYmplY3RzICsgbnJfb2JqZWN0cyArIDEsIDAsCgkJICAgICAgIG5yX3VucmVzb2x2ZWQgKiBzaXplb2YoKm9iamVjdHMpKTsKCQlmID0gaGFzaGZkKG91dHB1dF9mZCwgY3Vycl9wYWNrKTsKCQlmaXhfdW5yZXNvbHZlZF9kZWx0YXMoZik7CgkJc3RyYnVmX2FkZGYoJm1zZywgUV8oImNvbXBsZXRlZCB3aXRoICVkIGxvY2FsIG9iamVjdCIsCgkJCQkgICAgICJjb21wbGV0ZWQgd2l0aCAlZCBsb2NhbCBvYmplY3RzIiwKCQkJCSAgICAgbnJfb2JqZWN0cyAtIG5yX29iamVjdHNfaW5pdGlhbCksCgkJCSAgICBucl9vYmplY3RzIC0gbnJfb2JqZWN0c19pbml0aWFsKTsKCQlzdG9wX3Byb2dyZXNzX21zZygmcHJvZ3Jlc3MsIG1zZy5idWYpOwoJCXN0cmJ1Zl9yZWxlYXNlKCZtc2cpOwoJCWZpbmFsaXplX2hhc2hmaWxlKGYsIHRhaWxfaGFzaCwgRlNZTkNfQ09NUE9ORU5UX1BBQ0ssIDApOwoJCWhhc2hjcHkocmVhZF9oYXNoLCBwYWNrX2hhc2gpOwoJCWZpeHVwX3BhY2tfaGVhZGVyX2Zvb3RlcihvdXRwdXRfZmQsIHBhY2tfaGFzaCwKCQkJCQkgY3Vycl9wYWNrLCBucl9vYmplY3RzLAoJCQkJCSByZWFkX2hhc2gsIGNvbnN1bWVkX2J5dGVzLXRoZV9oYXNoX2FsZ28tPnJhd3N6KTsKCQlpZiAoIWhhc2hlcShyZWFkX2hhc2gsIHRhaWxfaGFzaCkpCgkJCWRpZShfKCJVbmV4cGVjdGVkIHRhaWwgY2hlY2tzdW0gZm9yICVzICIKCQkJICAgICAgIihkaXNrIGNvcnJ1cHRpb24/KSIpLCBjdXJyX3BhY2spOwoJfQoJaWYgKG5yX29mc19kZWx0YXMgKyBucl9yZWZfZGVsdGFzICE9IG5yX3Jlc29sdmVkX2RlbHRhcykKCQlkaWUoUV8oInBhY2sgaGFzICVkIHVucmVzb2x2ZWQgZGVsdGEiLAoJCSAgICAgICAicGFjayBoYXMgJWQgdW5yZXNvbHZlZCBkZWx0YXMiLAoJCSAgICAgICBucl9vZnNfZGVsdGFzICsgbnJfcmVmX2RlbHRhcyAtIG5yX3Jlc29sdmVkX2RlbHRhcyksCgkJICAgIG5yX29mc19kZWx0YXMgKyBucl9yZWZfZGVsdGFzIC0gbnJfcmVzb2x2ZWRfZGVsdGFzKTsKfQoKc3RhdGljIGludCB3cml0ZV9jb21wcmVzc2VkKHN0cnVjdCBoYXNoZmlsZSAqZiwgdm9pZCAqaW4sIHVuc2lnbmVkIGludCBzaXplKQp7CglnaXRfenN0cmVhbSBzdHJlYW07CglpbnQgc3RhdHVzOwoJdW5zaWduZWQgY2hhciBvdXRidWZbNDA5Nl07CgoJZ2l0X2RlZmxhdGVfaW5pdCgmc3RyZWFtLCB6bGliX2NvbXByZXNzaW9uX2xldmVsKTsKCXN0cmVhbS5uZXh0X2luID0gaW47CglzdHJlYW0uYXZhaWxfaW4gPSBzaXplOwoKCWRvIHsKCQlzdHJlYW0ubmV4dF9vdXQgPSBvdXRidWY7CgkJc3RyZWFtLmF2YWlsX291dCA9IHNpemVvZihvdXRidWYpOwoJCXN0YXR1cyA9IGdpdF9kZWZsYXRlKCZzdHJlYW0sIFpfRklOSVNIKTsKCQloYXNod3JpdGUoZiwgb3V0YnVmLCBzaXplb2Yob3V0YnVmKSAtIHN0cmVhbS5hdmFpbF9vdXQpOwoJfSB3aGlsZSAoc3RhdHVzID09IFpfT0spOwoKCWlmIChzdGF0dXMgIT0gWl9TVFJFQU1fRU5EKQoJCWRpZShfKCJ1bmFibGUgdG8gZGVmbGF0ZSBhcHBlbmRlZCBvYmplY3QgKCVkKSIpLCBzdGF0dXMpOwoJc2l6ZSA9IHN0cmVhbS50b3RhbF9vdXQ7CglnaXRfZGVmbGF0ZV9lbmQoJnN0cmVhbSk7CglyZXR1cm4gc2l6ZTsKfQoKc3RhdGljIHN0cnVjdCBvYmplY3RfZW50cnkgKmFwcGVuZF9vYmpfdG9fcGFjayhzdHJ1Y3QgaGFzaGZpbGUgKmYsCgkJCSAgICAgICBjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExLCB2b2lkICpidWYsCgkJCSAgICAgICB1bnNpZ25lZCBsb25nIHNpemUsIGVudW0gb2JqZWN0X3R5cGUgdHlwZSkKewoJc3RydWN0IG9iamVjdF9lbnRyeSAqb2JqID0gJm9iamVjdHNbbnJfb2JqZWN0cysrXTsKCXVuc2lnbmVkIGNoYXIgaGVhZGVyWzEwXTsKCXVuc2lnbmVkIGxvbmcgcyA9IHNpemU7CglpbnQgbiA9IDA7Cgl1bnNpZ25lZCBjaGFyIGMgPSAodHlwZSA8PCA0KSB8IChzICYgMTUpOwoJcyA+Pj0gNDsKCXdoaWxlIChzKSB7CgkJaGVhZGVyW24rK10gPSBjIHwgMHg4MDsKCQljID0gcyAmIDB4N2Y7CgkJcyA+Pj0gNzsKCX0KCWhlYWRlcltuKytdID0gYzsKCWNyYzMyX2JlZ2luKGYpOwoJaGFzaHdyaXRlKGYsIGhlYWRlciwgbik7CglvYmpbMF0uc2l6ZSA9IHNpemU7CglvYmpbMF0uaGRyX3NpemUgPSBuOwoJb2JqWzBdLnR5cGUgPSB0eXBlOwoJb2JqWzBdLnJlYWxfdHlwZSA9IHR5cGU7CglvYmpbMV0uaWR4Lm9mZnNldCA9IG9ialswXS5pZHgub2Zmc2V0ICsgbjsKCW9ialsxXS5pZHgub2Zmc2V0ICs9IHdyaXRlX2NvbXByZXNzZWQoZiwgYnVmLCBzaXplKTsKCW9ialswXS5pZHguY3JjMzIgPSBjcmMzMl9lbmQoZik7CgloYXNoZmx1c2goZik7CglvaWRyZWFkKCZvYmotPmlkeC5vaWQsIHNoYTEpOwoJcmV0dXJuIG9iajsKfQoKc3RhdGljIGludCBkZWx0YV9wb3NfY29tcGFyZShjb25zdCB2b2lkICpfYSwgY29uc3Qgdm9pZCAqX2IpCnsKCXN0cnVjdCByZWZfZGVsdGFfZW50cnkgKmEgPSAqKHN0cnVjdCByZWZfZGVsdGFfZW50cnkgKiopX2E7CglzdHJ1Y3QgcmVmX2RlbHRhX2VudHJ5ICpiID0gKihzdHJ1Y3QgcmVmX2RlbHRhX2VudHJ5ICoqKV9iOwoJcmV0dXJuIGEtPm9ial9ubyAtIGItPm9ial9ubzsKfQoKc3RhdGljIHZvaWQgZml4X3VucmVzb2x2ZWRfZGVsdGFzKHN0cnVjdCBoYXNoZmlsZSAqZikKewoJc3RydWN0IHJlZl9kZWx0YV9lbnRyeSAqKnNvcnRlZF9ieV9wb3M7CglpbnQgaTsKCgkvKgoJICogU2luY2UgbWFueSB1bnJlc29sdmVkIGRlbHRhcyBtYXkgd2VsbCBiZSB0aGVtc2VsdmVzIGJhc2Ugb2JqZWN0cwoJICogZm9yIG1vcmUgdW5yZXNvbHZlZCBkZWx0YXMsIHdlIHJlYWxseSB3YW50IHRvIGluY2x1ZGUgdGhlCgkgKiBzbWFsbGVzdCBudW1iZXIgb2YgYmFzZSBvYmplY3RzIHRoYXQgd291bGQgY292ZXIgYXMgbXVjaCBkZWx0YQoJICogYXMgcG9zc2libGUgYnkgcGlja2luZyB0aGUKCSAqIHRydW5jIGRlbHRhcyBmaXJzdCwgYWxsb3dpbmcgZm9yIG90aGVyIGRlbHRhcyB0byByZXNvbHZlIHdpdGhvdXQKCSAqIGFkZGl0aW9uYWwgYmFzZSBvYmplY3RzLiAgU2luY2UgbW9zdCBiYXNlIG9iamVjdHMgYXJlIHRvIGJlIGZvdW5kCgkgKiBiZWZvcmUgZGVsdGFzIGRlcGVuZGluZyBvbiB0aGVtLCBhIGdvb2QgaGV1cmlzdGljIGlzIHRvIHN0YXJ0CgkgKiByZXNvbHZpbmcgZGVsdGFzIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZWlyIHBvc2l0aW9uIGluIHRoZSBwYWNrLgoJICovCglBTExPQ19BUlJBWShzb3J0ZWRfYnlfcG9zLCBucl9yZWZfZGVsdGFzKTsKCWZvciAoaSA9IDA7IGkgPCBucl9yZWZfZGVsdGFzOyBpKyspCgkJc29ydGVkX2J5X3Bvc1tpXSA9ICZyZWZfZGVsdGFzW2ldOwoJUVNPUlQoc29ydGVkX2J5X3BvcywgbnJfcmVmX2RlbHRhcywgZGVsdGFfcG9zX2NvbXBhcmUpOwoKCWlmIChyZXBvX2hhc19wcm9taXNvcl9yZW1vdGUodGhlX3JlcG9zaXRvcnkpKSB7CgkJLyoKCQkgKiBQcmVmZXRjaCB0aGUgZGVsdGEgYmFzZXMuCgkJICovCgkJc3RydWN0IG9pZF9hcnJheSB0b19mZXRjaCA9IE9JRF9BUlJBWV9JTklUOwoJCWZvciAoaSA9IDA7IGkgPCBucl9yZWZfZGVsdGFzOyBpKyspIHsKCQkJc3RydWN0IHJlZl9kZWx0YV9lbnRyeSAqZCA9IHNvcnRlZF9ieV9wb3NbaV07CgkJCWlmICghb2lkX29iamVjdF9pbmZvX2V4dGVuZGVkKHRoZV9yZXBvc2l0b3J5LCAmZC0+b2lkLAoJCQkJCQkgICAgICBOVUxMLAoJCQkJCQkgICAgICBPQkpFQ1RfSU5GT19GT1JfUFJFRkVUQ0gpKQoJCQkJY29udGludWU7CgkJCW9pZF9hcnJheV9hcHBlbmQoJnRvX2ZldGNoLCAmZC0+b2lkKTsKCQl9CgkJcHJvbWlzb3JfcmVtb3RlX2dldF9kaXJlY3QodGhlX3JlcG9zaXRvcnksCgkJCQkJICAgdG9fZmV0Y2gub2lkLCB0b19mZXRjaC5ucik7CgkJb2lkX2FycmF5X2NsZWFyKCZ0b19mZXRjaCk7Cgl9CgoJZm9yIChpID0gMDsgaSA8IG5yX3JlZl9kZWx0YXM7IGkrKykgewoJCXN0cnVjdCByZWZfZGVsdGFfZW50cnkgKmQgPSBzb3J0ZWRfYnlfcG9zW2ldOwoJCWVudW0gb2JqZWN0X3R5cGUgdHlwZTsKCQl2b2lkICpkYXRhOwoJCXVuc2lnbmVkIGxvbmcgc2l6ZTsKCgkJaWYgKG9iamVjdHNbZC0+b2JqX25vXS5yZWFsX3R5cGUgIT0gT0JKX1JFRl9ERUxUQSkKCQkJY29udGludWU7CgkJZGF0YSA9IHJlcG9fcmVhZF9vYmplY3RfZmlsZSh0aGVfcmVwb3NpdG9yeSwgJmQtPm9pZCwgJnR5cGUsCgkJCQkJICAgICAmc2l6ZSk7CgkJaWYgKCFkYXRhKQoJCQljb250aW51ZTsKCgkJaWYgKGNoZWNrX29iamVjdF9zaWduYXR1cmUodGhlX3JlcG9zaXRvcnksICZkLT5vaWQsIGRhdGEsIHNpemUsCgkJCQkJICAgdHlwZSkgPCAwKQoJCQlkaWUoXygibG9jYWwgb2JqZWN0ICVzIGlzIGNvcnJ1cHQiKSwgb2lkX3RvX2hleCgmZC0+b2lkKSk7CgoJCS8qCgkJICogQWRkIHRoaXMgYXMgYW4gb2JqZWN0IHRvIHRoZSBvYmplY3RzIGFycmF5IGFuZCBjYWxsCgkJICogdGhyZWFkZWRfc2Vjb25kX3Bhc3MoKSAod2hpY2ggd2lsbCBwaWNrIHVwIHRoZSBhZGRlZAoJCSAqIG9iamVjdCkuCgkJICovCgkJYXBwZW5kX29ial90b19wYWNrKGYsIGQtPm9pZC5oYXNoLCBkYXRhLCBzaXplLCB0eXBlKTsKCQlmcmVlKGRhdGEpOwoJCXRocmVhZGVkX3NlY29uZF9wYXNzKE5VTEwpOwoKCQlkaXNwbGF5X3Byb2dyZXNzKHByb2dyZXNzLCBucl9yZXNvbHZlZF9kZWx0YXMpOwoJfQoJZnJlZShzb3J0ZWRfYnlfcG9zKTsKfQoKc3RhdGljIGNvbnN0IGNoYXIgKmRlcml2ZV9maWxlbmFtZShjb25zdCBjaGFyICpwYWNrX25hbWUsIGNvbnN0IGNoYXIgKnN0cmlwLAoJCQkJICAgY29uc3QgY2hhciAqc3VmZml4LCBzdHJ1Y3Qgc3RyYnVmICpidWYpCnsKCXNpemVfdCBsZW47CglpZiAoIXN0cmlwX3N1ZmZpeChwYWNrX25hbWUsIHN0cmlwLCAmbGVuKSB8fCAhbGVuIHx8CgkgICAgcGFja19uYW1lW2xlbiAtIDFdICE9ICcuJykKCQlkaWUoXygicGFja2ZpbGUgbmFtZSAnJXMnIGRvZXMgbm90IGVuZCB3aXRoICcuJXMnIiksCgkJICAgIHBhY2tfbmFtZSwgc3RyaXApOwoJc3RyYnVmX2FkZChidWYsIHBhY2tfbmFtZSwgbGVuKTsKCXN0cmJ1Zl9hZGRzdHIoYnVmLCBzdWZmaXgpOwoJcmV0dXJuIGJ1Zi0+YnVmOwp9CgpzdGF0aWMgdm9pZCB3cml0ZV9zcGVjaWFsX2ZpbGUoY29uc3QgY2hhciAqc3VmZml4LCBjb25zdCBjaGFyICptc2csCgkJCSAgICAgICBjb25zdCBjaGFyICpwYWNrX25hbWUsIGNvbnN0IHVuc2lnbmVkIGNoYXIgKmhhc2gsCgkJCSAgICAgICBjb25zdCBjaGFyICoqcmVwb3J0KQp7CglzdHJ1Y3Qgc3RyYnVmIG5hbWVfYnVmID0gU1RSQlVGX0lOSVQ7Cgljb25zdCBjaGFyICpmaWxlbmFtZTsKCWludCBmZDsKCWludCBtc2dfbGVuID0gc3RybGVuKG1zZyk7CgoJaWYgKHBhY2tfbmFtZSkKCQlmaWxlbmFtZSA9IGRlcml2ZV9maWxlbmFtZShwYWNrX25hbWUsICJwYWNrIiwgc3VmZml4LCAmbmFtZV9idWYpOwoJZWxzZQoJCWZpbGVuYW1lID0gb2RiX3BhY2tfbmFtZSgmbmFtZV9idWYsIGhhc2gsIHN1ZmZpeCk7CgoJZmQgPSBvZGJfcGFja19rZWVwKGZpbGVuYW1lKTsKCWlmIChmZCA8IDApIHsKCQlpZiAoZXJybm8gIT0gRUVYSVNUKQoJCQlkaWVfZXJybm8oXygiY2Fubm90IHdyaXRlICVzIGZpbGUgJyVzJyIpLAoJCQkJICBzdWZmaXgsIGZpbGVuYW1lKTsKCX0gZWxzZSB7CgkJaWYgKG1zZ19sZW4gPiAwKSB7CgkJCXdyaXRlX29yX2RpZShmZCwgbXNnLCBtc2dfbGVuKTsKCQkJd3JpdGVfb3JfZGllKGZkLCAiXG4iLCAxKTsKCQl9CgkJaWYgKGNsb3NlKGZkKSAhPSAwKQoJCQlkaWVfZXJybm8oXygiY2Fubm90IGNsb3NlIHdyaXR0ZW4gJXMgZmlsZSAnJXMnIiksCgkJCQkgIHN1ZmZpeCwgZmlsZW5hbWUpOwoJCWlmIChyZXBvcnQpCgkJCSpyZXBvcnQgPSBzdWZmaXg7Cgl9CglzdHJidWZfcmVsZWFzZSgmbmFtZV9idWYpOwp9CgpzdGF0aWMgdm9pZCByZW5hbWVfdG1wX3BhY2tmaWxlKGNvbnN0IGNoYXIgKipmaW5hbF9uYW1lLAoJCQkJY29uc3QgY2hhciAqY3Vycl9uYW1lLAoJCQkJc3RydWN0IHN0cmJ1ZiAqbmFtZSwgdW5zaWduZWQgY2hhciAqaGFzaCwKCQkJCWNvbnN0IGNoYXIgKmV4dCwgaW50IG1ha2VfcmVhZF9vbmx5X2lmX3NhbWUpCnsKCWlmICgqZmluYWxfbmFtZSAhPSBjdXJyX25hbWUpIHsKCQlpZiAoISpmaW5hbF9uYW1lKQoJCQkqZmluYWxfbmFtZSA9IG9kYl9wYWNrX25hbWUobmFtZSwgaGFzaCwgZXh0KTsKCQlpZiAoZmluYWxpemVfb2JqZWN0X2ZpbGUoY3Vycl9uYW1lLCAqZmluYWxfbmFtZSkpCgkJCWRpZShfKCJ1bmFibGUgdG8gcmVuYW1lIHRlbXBvcmFyeSAnKi4lcycgZmlsZSB0byAnJXMnIiksCgkJCSAgICBleHQsICpmaW5hbF9uYW1lKTsKCX0gZWxzZSBpZiAobWFrZV9yZWFkX29ubHlfaWZfc2FtZSkgewoJCWNobW9kKCpmaW5hbF9uYW1lLCAwNDQ0KTsKCX0KfQoKc3RhdGljIHZvaWQgZmluYWwoY29uc3QgY2hhciAqZmluYWxfcGFja19uYW1lLCBjb25zdCBjaGFyICpjdXJyX3BhY2tfbmFtZSwKCQkgIGNvbnN0IGNoYXIgKmZpbmFsX2luZGV4X25hbWUsIGNvbnN0IGNoYXIgKmN1cnJfaW5kZXhfbmFtZSwKCQkgIGNvbnN0IGNoYXIgKmZpbmFsX3Jldl9pbmRleF9uYW1lLCBjb25zdCBjaGFyICpjdXJyX3Jldl9pbmRleF9uYW1lLAoJCSAgY29uc3QgY2hhciAqa2VlcF9tc2csIGNvbnN0IGNoYXIgKnByb21pc29yX21zZywKCQkgIHVuc2lnbmVkIGNoYXIgKmhhc2gpCnsKCWNvbnN0IGNoYXIgKnJlcG9ydCA9ICJwYWNrIjsKCXN0cnVjdCBzdHJidWYgcGFja19uYW1lID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3Qgc3RyYnVmIGluZGV4X25hbWUgPSBTVFJCVUZfSU5JVDsKCXN0cnVjdCBzdHJidWYgcmV2X2luZGV4X25hbWUgPSBTVFJCVUZfSU5JVDsKCWludCBlcnI7CgoJaWYgKCFmcm9tX3N0ZGluKSB7CgkJY2xvc2UoaW5wdXRfZmQpOwoJfSBlbHNlIHsKCQlmc3luY19jb21wb25lbnRfb3JfZGllKEZTWU5DX0NPTVBPTkVOVF9QQUNLLCBvdXRwdXRfZmQsIGN1cnJfcGFja19uYW1lKTsKCQllcnIgPSBjbG9zZShvdXRwdXRfZmQpOwoJCWlmIChlcnIpCgkJCWRpZV9lcnJubyhfKCJlcnJvciB3aGlsZSBjbG9zaW5nIHBhY2sgZmlsZSIpKTsKCX0KCglpZiAoa2VlcF9tc2cpCgkJd3JpdGVfc3BlY2lhbF9maWxlKCJrZWVwIiwga2VlcF9tc2csIGZpbmFsX3BhY2tfbmFtZSwgaGFzaCwKCQkJCSAgICZyZXBvcnQpOwoJaWYgKHByb21pc29yX21zZykKCQl3cml0ZV9zcGVjaWFsX2ZpbGUoInByb21pc29yIiwgcHJvbWlzb3JfbXNnLCBmaW5hbF9wYWNrX25hbWUsCgkJCQkgICBoYXNoLCBOVUxMKTsKCglyZW5hbWVfdG1wX3BhY2tmaWxlKCZmaW5hbF9wYWNrX25hbWUsIGN1cnJfcGFja19uYW1lLCAmcGFja19uYW1lLAoJCQkgICAgaGFzaCwgInBhY2siLCBmcm9tX3N0ZGluKTsKCWlmIChjdXJyX3Jldl9pbmRleF9uYW1lKQoJCXJlbmFtZV90bXBfcGFja2ZpbGUoJmZpbmFsX3Jldl9pbmRleF9uYW1lLCBjdXJyX3Jldl9pbmRleF9uYW1lLAoJCQkJICAgICZyZXZfaW5kZXhfbmFtZSwgaGFzaCwgInJldiIsIDEpOwoJcmVuYW1lX3RtcF9wYWNrZmlsZSgmZmluYWxfaW5kZXhfbmFtZSwgY3Vycl9pbmRleF9uYW1lLCAmaW5kZXhfbmFtZSwKCQkJICAgIGhhc2gsICJpZHgiLCAxKTsKCglpZiAoZG9fZnNja19vYmplY3QpIHsKCQlzdHJ1Y3QgcGFja2VkX2dpdCAqcDsKCQlwID0gYWRkX3BhY2tlZF9naXQoZmluYWxfaW5kZXhfbmFtZSwgc3RybGVuKGZpbmFsX2luZGV4X25hbWUpLCAwKTsKCQlpZiAocCkKCQkJaW5zdGFsbF9wYWNrZWRfZ2l0KHRoZV9yZXBvc2l0b3J5LCBwKTsKCX0KCglpZiAoIWZyb21fc3RkaW4pIHsKCQlwcmludGYoIiVzXG4iLCBoYXNoX3RvX2hleChoYXNoKSk7Cgl9IGVsc2UgewoJCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7CgoJCXN0cmJ1Zl9hZGRmKCZidWYsICIlc1x0JXNcbiIsIHJlcG9ydCwgaGFzaF90b19oZXgoaGFzaCkpOwoJCXdyaXRlX29yX2RpZSgxLCBidWYuYnVmLCBidWYubGVuKTsKCQlzdHJidWZfcmVsZWFzZSgmYnVmKTsKCgkJLyoKCQkgKiBMZXQncyBqdXN0IG1pbWljIGdpdC11bnBhY2stb2JqZWN0cyBoZXJlIGFuZCB3cml0ZQoJCSAqIHRoZSBsYXN0IHBhcnQgb2YgdGhlIGlucHV0IGJ1ZmZlciB0byBzdGRvdXQuCgkJICovCgkJd2hpbGUgKGlucHV0X2xlbikgewoJCQllcnIgPSB4d3JpdGUoMSwgaW5wdXRfYnVmZmVyICsgaW5wdXRfb2Zmc2V0LCBpbnB1dF9sZW4pOwoJCQlpZiAoZXJyIDw9IDApCgkJCQlicmVhazsKCQkJaW5wdXRfbGVuIC09IGVycjsKCQkJaW5wdXRfb2Zmc2V0ICs9IGVycjsKCQl9Cgl9CgoJc3RyYnVmX3JlbGVhc2UoJnJldl9pbmRleF9uYW1lKTsKCXN0cmJ1Zl9yZWxlYXNlKCZpbmRleF9uYW1lKTsKCXN0cmJ1Zl9yZWxlYXNlKCZwYWNrX25hbWUpOwp9CgpzdGF0aWMgaW50IGdpdF9pbmRleF9wYWNrX2NvbmZpZyhjb25zdCBjaGFyICprLCBjb25zdCBjaGFyICp2LAoJCQkJIGNvbnN0IHN0cnVjdCBjb25maWdfY29udGV4dCAqY3R4LCB2b2lkICpjYikKewoJc3RydWN0IHBhY2tfaWR4X29wdGlvbiAqb3B0cyA9IGNiOwoKCWlmICghc3RyY21wKGssICJwYWNrLmluZGV4dmVyc2lvbiIpKSB7CgkJb3B0cy0+dmVyc2lvbiA9IGdpdF9jb25maWdfaW50KGssIHYsIGN0eC0+a3ZpKTsKCQlpZiAob3B0cy0+dmVyc2lvbiA+IDIpCgkJCWRpZShfKCJiYWQgcGFjay5pbmRleFZlcnNpb249JSJQUkl1MzIpLCBvcHRzLT52ZXJzaW9uKTsKCQlyZXR1cm4gMDsKCX0KCWlmICghc3RyY21wKGssICJwYWNrLnRocmVhZHMiKSkgewoJCW5yX3RocmVhZHMgPSBnaXRfY29uZmlnX2ludChrLCB2LCBjdHgtPmt2aSk7CgkJaWYgKG5yX3RocmVhZHMgPCAwKQoJCQlkaWUoXygiaW52YWxpZCBudW1iZXIgb2YgdGhyZWFkcyBzcGVjaWZpZWQgKCVkKSIpLAoJCQkgICAgbnJfdGhyZWFkcyk7CgkJaWYgKCFIQVZFX1RIUkVBRFMgJiYgbnJfdGhyZWFkcyAhPSAxKSB7CgkJCXdhcm5pbmcoXygibm8gdGhyZWFkcyBzdXBwb3J0LCBpZ25vcmluZyAlcyIpLCBrKTsKCQkJbnJfdGhyZWFkcyA9IDE7CgkJfQoJCXJldHVybiAwOwoJfQoJaWYgKCFzdHJjbXAoaywgInBhY2sud3JpdGVyZXZlcnNlaW5kZXgiKSkgewoJCWlmIChnaXRfY29uZmlnX2Jvb2woaywgdikpCgkJCW9wdHMtPmZsYWdzIHw9IFdSSVRFX1JFVjsKCQllbHNlCgkJCW9wdHMtPmZsYWdzICY9IH5XUklURV9SRVY7Cgl9CglyZXR1cm4gZ2l0X2RlZmF1bHRfY29uZmlnKGssIHYsIGN0eCwgY2IpOwp9CgpzdGF0aWMgaW50IGNtcF91aW50MzIoY29uc3Qgdm9pZCAqYV8sIGNvbnN0IHZvaWQgKmJfKQp7Cgl1aW50MzJfdCBhID0gKigodWludDMyX3QgKilhXyk7Cgl1aW50MzJfdCBiID0gKigodWludDMyX3QgKiliXyk7CgoJcmV0dXJuIChhIDwgYikgPyAtMSA6IChhICE9IGIpOwp9CgpzdGF0aWMgdm9pZCByZWFkX3YyX2Fub21hbG91c19vZmZzZXRzKHN0cnVjdCBwYWNrZWRfZ2l0ICpwLAoJCQkJICAgICAgc3RydWN0IHBhY2tfaWR4X29wdGlvbiAqb3B0cykKewoJY29uc3QgdWludDMyX3QgKmlkeDEsICppZHgyOwoJdWludDMyX3QgaTsKCgkvKiBUaGUgYWRkcmVzcyBvZiB0aGUgNC1ieXRlIG9mZnNldCB0YWJsZSAqLwoJaWR4MSA9ICgoKGNvbnN0IHVpbnQzMl90ICopKChjb25zdCB1aW50OF90ICopcC0+aW5kZXhfZGF0YSArIHAtPmNyY19vZmZzZXQpKQoJCSsgKHNpemVfdClwLT5udW1fb2JqZWN0cyAvKiBDUkMzMiB0YWJsZSAqLwoJCSk7CgoJLyogVGhlIGFkZHJlc3Mgb2YgdGhlIDgtYnl0ZSBvZmZzZXQgdGFibGUgKi8KCWlkeDIgPSBpZHgxICsgcC0+bnVtX29iamVjdHM7CgoJZm9yIChpID0gMDsgaSA8IHAtPm51bV9vYmplY3RzOyBpKyspIHsKCQl1aW50MzJfdCBvZmYgPSBudG9obChpZHgxW2ldKTsKCQlpZiAoIShvZmYgJiAweDgwMDAwMDAwKSkKCQkJY29udGludWU7CgkJb2ZmID0gb2ZmICYgMHg3ZmZmZmZmZjsKCQljaGVja19wYWNrX2luZGV4X3B0cihwLCAmaWR4MltvZmYgKiAyXSk7CgkJaWYgKGlkeDJbb2ZmICogMl0pCgkJCWNvbnRpbnVlOwoJCS8qCgkJICogVGhlIHJlYWwgb2Zmc2V0IGlzIG50b2hsKGlkeDJbb2ZmICogMl0pIGluIGhpZ2ggNAoJCSAqIG9jdGV0cywgYW5kIG50b2hsKGlkeDJbb2ZmICogMiArIDFdKSBpbiBsb3cgNAoJCSAqIG9jdGV0cy4gIEJ1dCBpZHgyW29mZiAqIDJdIGlzIFplcm8hISEKCQkgKi8KCQlBTExPQ19HUk9XKG9wdHMtPmFub21hbHksIG9wdHMtPmFub21hbHlfbnIgKyAxLCBvcHRzLT5hbm9tYWx5X2FsbG9jKTsKCQlvcHRzLT5hbm9tYWx5W29wdHMtPmFub21hbHlfbnIrK10gPSBudG9obChpZHgyW29mZiAqIDIgKyAxXSk7Cgl9CgoJUVNPUlQob3B0cy0+YW5vbWFseSwgb3B0cy0+YW5vbWFseV9uciwgY21wX3VpbnQzMik7Cn0KCnN0YXRpYyB2b2lkIHJlYWRfaWR4X29wdGlvbihzdHJ1Y3QgcGFja19pZHhfb3B0aW9uICpvcHRzLCBjb25zdCBjaGFyICpwYWNrX25hbWUpCnsKCXN0cnVjdCBwYWNrZWRfZ2l0ICpwID0gYWRkX3BhY2tlZF9naXQocGFja19uYW1lLCBzdHJsZW4ocGFja19uYW1lKSwgMSk7CgoJaWYgKCFwKQoJCWRpZShfKCJDYW5ub3Qgb3BlbiBleGlzdGluZyBwYWNrIGZpbGUgJyVzJyIpLCBwYWNrX25hbWUpOwoJaWYgKG9wZW5fcGFja19pbmRleChwKSkKCQlkaWUoXygiQ2Fubm90IG9wZW4gZXhpc3RpbmcgcGFjayBpZHggZmlsZSBmb3IgJyVzJyIpLCBwYWNrX25hbWUpOwoKCS8qIFJlYWQgdGhlIGF0dHJpYnV0ZXMgZnJvbSB0aGUgZXhpc3RpbmcgaWR4IGZpbGUgKi8KCW9wdHMtPnZlcnNpb24gPSBwLT5pbmRleF92ZXJzaW9uOwoKCWlmIChvcHRzLT52ZXJzaW9uID09IDIpCgkJcmVhZF92Ml9hbm9tYWxvdXNfb2Zmc2V0cyhwLCBvcHRzKTsKCgkvKgoJICogR2V0IHJpZCBvZiB0aGUgaWR4IGZpbGUgYXMgd2UgZG8gbm90IG5lZWQgaXQgYW55bW9yZS4KCSAqIE5FRURTV09SSzogZXh0cmFjdCB0aGlzIGJpdCBmcm9tIGZyZWVfcGFja19ieV9uYW1lKCkgaW4KCSAqIG9iamVjdC1maWxlLmMsIHBlcmhhcHM/ICBJdCBzaG91bGRuJ3QgbWF0dGVyIHZlcnkgbXVjaCBhcyB3ZQoJICoga25vdyB3ZSBoYXZlbid0IGluc3RhbGxlZCB0aGlzIHBhY2sgKGhlbmNlIHdlIG5ldmVyIGhhdmUKCSAqIHJlYWQgYW55dGhpbmcgZnJvbSBpdCkuCgkgKi8KCWNsb3NlX3BhY2tfaW5kZXgocCk7CglmcmVlKHApOwp9CgpzdGF0aWMgdm9pZCBzaG93X3BhY2tfaW5mbyhpbnQgc3RhdF9vbmx5KQp7CglpbnQgaSwgYmFzZW9iamVjdHMgPSBucl9vYmplY3RzIC0gbnJfcmVmX2RlbHRhcyAtIG5yX29mc19kZWx0YXM7Cgl1bnNpZ25lZCBsb25nICpjaGFpbl9oaXN0b2dyYW0gPSBOVUxMOwoKCWlmIChkZWVwZXN0X2RlbHRhKQoJCUNBTExPQ19BUlJBWShjaGFpbl9oaXN0b2dyYW0sIGRlZXBlc3RfZGVsdGEpOwoKCWZvciAoaSA9IDA7IGkgPCBucl9vYmplY3RzOyBpKyspIHsKCQlzdHJ1Y3Qgb2JqZWN0X2VudHJ5ICpvYmogPSAmb2JqZWN0c1tpXTsKCgkJaWYgKGlzX2RlbHRhX3R5cGUob2JqLT50eXBlKSkKCQkJY2hhaW5faGlzdG9ncmFtW29ial9zdGF0W2ldLmRlbHRhX2RlcHRoIC0gMV0rKzsKCQlpZiAoc3RhdF9vbmx5KQoJCQljb250aW51ZTsKCQlwcmludGYoIiVzICUtNnMgJSJQUkl1TUFYIiAlIlBSSXVNQVgiICUiUFJJdU1BWCwKCQkgICAgICAgb2lkX3RvX2hleCgmb2JqLT5pZHgub2lkKSwKCQkgICAgICAgdHlwZV9uYW1lKG9iai0+cmVhbF90eXBlKSwgKHVpbnRtYXhfdClvYmotPnNpemUsCgkJICAgICAgICh1aW50bWF4X3QpKG9ialsxXS5pZHgub2Zmc2V0IC0gb2JqLT5pZHgub2Zmc2V0KSwKCQkgICAgICAgKHVpbnRtYXhfdClvYmotPmlkeC5vZmZzZXQpOwoJCWlmIChpc19kZWx0YV90eXBlKG9iai0+dHlwZSkpIHsKCQkJc3RydWN0IG9iamVjdF9lbnRyeSAqYm9iaiA9ICZvYmplY3RzW29ial9zdGF0W2ldLmJhc2Vfb2JqZWN0X25vXTsKCQkJcHJpbnRmKCIgJXUgJXMiLCBvYmpfc3RhdFtpXS5kZWx0YV9kZXB0aCwKCQkJICAgICAgIG9pZF90b19oZXgoJmJvYmotPmlkeC5vaWQpKTsKCQl9CgkJcHV0Y2hhcignXG4nKTsKCX0KCglpZiAoYmFzZW9iamVjdHMpCgkJcHJpbnRmX2xuKFFfKCJub24gZGVsdGE6ICVkIG9iamVjdCIsCgkJCSAgICAgIm5vbiBkZWx0YTogJWQgb2JqZWN0cyIsCgkJCSAgICAgYmFzZW9iamVjdHMpLAoJCQkgIGJhc2VvYmplY3RzKTsKCWZvciAoaSA9IDA7IGkgPCBkZWVwZXN0X2RlbHRhOyBpKyspIHsKCQlpZiAoIWNoYWluX2hpc3RvZ3JhbVtpXSkKCQkJY29udGludWU7CgkJcHJpbnRmX2xuKFFfKCJjaGFpbiBsZW5ndGggPSAlZDogJWx1IG9iamVjdCIsCgkJCSAgICAgImNoYWluIGxlbmd0aCA9ICVkOiAlbHUgb2JqZWN0cyIsCgkJCSAgICAgY2hhaW5faGlzdG9ncmFtW2ldKSwKCQkJICBpICsgMSwKCQkJICBjaGFpbl9oaXN0b2dyYW1baV0pOwoJfQoJZnJlZShjaGFpbl9oaXN0b2dyYW0pOwp9CgppbnQgY21kX2luZGV4X3BhY2soaW50IGFyZ2MsIGNvbnN0IGNoYXIgKiphcmd2LCBjb25zdCBjaGFyICpwcmVmaXgpCnsKCWludCBpLCBmaXhfdGhpbl9wYWNrID0gMCwgdmVyaWZ5ID0gMCwgc3RhdF9vbmx5ID0gMCwgcmV2X2luZGV4OwoJY29uc3QgY2hhciAqY3Vycl9pbmRleDsKCWNvbnN0IGNoYXIgKmN1cnJfcmV2X2luZGV4ID0gTlVMTDsKCWNvbnN0IGNoYXIgKmluZGV4X25hbWUgPSBOVUxMLCAqcGFja19uYW1lID0gTlVMTCwgKnJldl9pbmRleF9uYW1lID0gTlVMTDsKCWNvbnN0IGNoYXIgKmtlZXBfbXNnID0gTlVMTDsKCWNvbnN0IGNoYXIgKnByb21pc29yX21zZyA9IE5VTEw7CglzdHJ1Y3Qgc3RyYnVmIGluZGV4X25hbWVfYnVmID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3Qgc3RyYnVmIHJldl9pbmRleF9uYW1lX2J1ZiA9IFNUUkJVRl9JTklUOwoJc3RydWN0IHBhY2tfaWR4X2VudHJ5ICoqaWR4X29iamVjdHM7CglzdHJ1Y3QgcGFja19pZHhfb3B0aW9uIG9wdHM7Cgl1bnNpZ25lZCBjaGFyIHBhY2tfaGFzaFtHSVRfTUFYX1JBV1NaXTsKCXVuc2lnbmVkIGZvcmVpZ25fbnIgPSAxOwkvKiB6ZXJvIGlzIGEgImdvb2QiIHZhbHVlLCBhc3N1bWUgYmFkICovCglpbnQgcmVwb3J0X2VuZF9vZl9pbnB1dCA9IDA7CglpbnQgaGFzaF9hbGdvID0gMDsKCgkvKgoJICogaW5kZXgtcGFjayBuZXZlciBuZWVkcyB0byBmZXRjaCBtaXNzaW5nIG9iamVjdHMgZXhjZXB0IHdoZW4KCSAqIFJFRl9ERUxUQSBiYXNlcyBhcmUgbWlzc2luZyAod2hpY2ggYXJlIGV4cGxpY2l0bHkgaGFuZGxlZCkuIEl0IG9ubHkKCSAqIGFjY2Vzc2VzIHRoZSByZXBvIHRvIGRvIGhhc2ggY29sbGlzaW9uIGNoZWNrcyBhbmQgdG8gY2hlY2sgd2hpY2gKCSAqIFJFRl9ERUxUQSBiYXNlcyBuZWVkIHRvIGJlIGZldGNoZWQuCgkgKi8KCWZldGNoX2lmX21pc3NpbmcgPSAwOwoKCWlmIChhcmdjID09IDIgJiYgIXN0cmNtcChhcmd2WzFdLCAiLWgiKSkKCQl1c2FnZShpbmRleF9wYWNrX3VzYWdlKTsKCglkaXNhYmxlX3JlcGxhY2VfcmVmcygpOwoJZnNja19vcHRpb25zLndhbGsgPSBtYXJrX2xpbms7CgoJcmVzZXRfcGFja19pZHhfb3B0aW9uKCZvcHRzKTsKCW9wdHMuZmxhZ3MgfD0gV1JJVEVfUkVWOwoJZ2l0X2NvbmZpZyhnaXRfaW5kZXhfcGFja19jb25maWcsICZvcHRzKTsKCWlmIChwcmVmaXggJiYgY2hkaXIocHJlZml4KSkKCQlkaWUoXygiQ2Fubm90IGNvbWUgYmFjayB0byBjd2QiKSk7CgoJaWYgKGdpdF9lbnZfYm9vbChHSVRfVEVTVF9OT19XUklURV9SRVZfSU5ERVgsIDApKQoJCXJldl9pbmRleCA9IDA7CgllbHNlCgkJcmV2X2luZGV4ID0gISEob3B0cy5mbGFncyAmIChXUklURV9SRVZfVkVSSUZZIHwgV1JJVEVfUkVWKSk7CgoJZm9yIChpID0gMTsgaSA8IGFyZ2M7IGkrKykgewoJCWNvbnN0IGNoYXIgKmFyZyA9IGFyZ3ZbaV07CgoJCWlmICgqYXJnID09ICctJykgewoJCQlpZiAoIXN0cmNtcChhcmcsICItLXN0ZGluIikpIHsKCQkJCWZyb21fc3RkaW4gPSAxOwoJCQl9IGVsc2UgaWYgKCFzdHJjbXAoYXJnLCAiLS1maXgtdGhpbiIpKSB7CgkJCQlmaXhfdGhpbl9wYWNrID0gMTsKCQkJfSBlbHNlIGlmIChza2lwX3RvX29wdGlvbmFsX2FyZyhhcmcsICItLXN0cmljdCIsICZhcmcpKSB7CgkJCQlzdHJpY3QgPSAxOwoJCQkJZG9fZnNja19vYmplY3QgPSAxOwoJCQkJZnNja19zZXRfbXNnX3R5cGVzKCZmc2NrX29wdGlvbnMsIGFyZyk7CgkJCX0gZWxzZSBpZiAoIXN0cmNtcChhcmcsICItLWNoZWNrLXNlbGYtY29udGFpbmVkLWFuZC1jb25uZWN0ZWQiKSkgewoJCQkJc3RyaWN0ID0gMTsKCQkJCWNoZWNrX3NlbGZfY29udGFpbmVkX2FuZF9jb25uZWN0ZWQgPSAxOwoJCQl9IGVsc2UgaWYgKCFzdHJjbXAoYXJnLCAiLS1mc2NrLW9iamVjdHMiKSkgewoJCQkJZG9fZnNja19vYmplY3QgPSAxOwoJCQl9IGVsc2UgaWYgKCFzdHJjbXAoYXJnLCAiLS12ZXJpZnkiKSkgewoJCQkJdmVyaWZ5ID0gMTsKCQkJfSBlbHNlIGlmICghc3RyY21wKGFyZywgIi0tdmVyaWZ5LXN0YXQiKSkgewoJCQkJdmVyaWZ5ID0gMTsKCQkJCXNob3dfc3RhdCA9IDE7CgkJCX0gZWxzZSBpZiAoIXN0cmNtcChhcmcsICItLXZlcmlmeS1zdGF0LW9ubHkiKSkgewoJCQkJdmVyaWZ5ID0gMTsKCQkJCXNob3dfc3RhdCA9IDE7CgkJCQlzdGF0X29ubHkgPSAxOwoJCQl9IGVsc2UgaWYgKHNraXBfdG9fb3B0aW9uYWxfYXJnKGFyZywgIi0ta2VlcCIsICZrZWVwX21zZykpIHsKCQkJCTsgLyogbm90aGluZyB0byBkbyAqLwoJCQl9IGVsc2UgaWYgKHNraXBfdG9fb3B0aW9uYWxfYXJnKGFyZywgIi0tcHJvbWlzb3IiLCAmcHJvbWlzb3JfbXNnKSkgewoJCQkJOyAvKiBhbHJlYWR5IHBhcnNlZCAqLwoJCQl9IGVsc2UgaWYgKHN0YXJ0c193aXRoKGFyZywgIi0tdGhyZWFkcz0iKSkgewoJCQkJY2hhciAqZW5kOwoJCQkJbnJfdGhyZWFkcyA9IHN0cnRvdWwoYXJnKzEwLCAmZW5kLCAwKTsKCQkJCWlmICghYXJnWzEwXSB8fCAqZW5kIHx8IG5yX3RocmVhZHMgPCAwKQoJCQkJCXVzYWdlKGluZGV4X3BhY2tfdXNhZ2UpOwoJCQkJaWYgKCFIQVZFX1RIUkVBRFMgJiYgbnJfdGhyZWFkcyAhPSAxKSB7CgkJCQkJd2FybmluZyhfKCJubyB0aHJlYWRzIHN1cHBvcnQsIGlnbm9yaW5nICVzIiksIGFyZyk7CgkJCQkJbnJfdGhyZWFkcyA9IDE7CgkJCQl9CgkJCX0gZWxzZSBpZiAoc3RhcnRzX3dpdGgoYXJnLCAiLS1wYWNrX2hlYWRlcj0iKSkgewoJCQkJc3RydWN0IHBhY2tfaGVhZGVyICpoZHI7CgkJCQljaGFyICpjOwoKCQkJCWhkciA9IChzdHJ1Y3QgcGFja19oZWFkZXIgKilpbnB1dF9idWZmZXI7CgkJCQloZHItPmhkcl9zaWduYXR1cmUgPSBodG9ubChQQUNLX1NJR05BVFVSRSk7CgkJCQloZHItPmhkcl92ZXJzaW9uID0gaHRvbmwoc3RydG91bChhcmcgKyAxNCwgJmMsIDEwKSk7CgkJCQlpZiAoKmMgIT0gJywnKQoJCQkJCWRpZShfKCJiYWQgJXMiKSwgYXJnKTsKCQkJCWhkci0+aGRyX2VudHJpZXMgPSBodG9ubChzdHJ0b3VsKGMgKyAxLCAmYywgMTApKTsKCQkJCWlmICgqYykKCQkJCQlkaWUoXygiYmFkICVzIiksIGFyZyk7CgkJCQlpbnB1dF9sZW4gPSBzaXplb2YoKmhkcik7CgkJCX0gZWxzZSBpZiAoIXN0cmNtcChhcmcsICItdiIpKSB7CgkJCQl2ZXJib3NlID0gMTsKCQkJfSBlbHNlIGlmICghc3RyY21wKGFyZywgIi0tcHJvZ3Jlc3MtdGl0bGUiKSkgewoJCQkJaWYgKHByb2dyZXNzX3RpdGxlIHx8IChpKzEpID49IGFyZ2MpCgkJCQkJdXNhZ2UoaW5kZXhfcGFja191c2FnZSk7CgkJCQlwcm9ncmVzc190aXRsZSA9IGFyZ3ZbKytpXTsKCQkJfSBlbHNlIGlmICghc3RyY21wKGFyZywgIi0tc2hvdy1yZXNvbHZpbmctcHJvZ3Jlc3MiKSkgewoJCQkJc2hvd19yZXNvbHZpbmdfcHJvZ3Jlc3MgPSAxOwoJCQl9IGVsc2UgaWYgKCFzdHJjbXAoYXJnLCAiLS1yZXBvcnQtZW5kLW9mLWlucHV0IikpIHsKCQkJCXJlcG9ydF9lbmRfb2ZfaW5wdXQgPSAxOwoJCQl9IGVsc2UgaWYgKCFzdHJjbXAoYXJnLCAiLW8iKSkgewoJCQkJaWYgKGluZGV4X25hbWUgfHwgKGkrMSkgPj0gYXJnYykKCQkJCQl1c2FnZShpbmRleF9wYWNrX3VzYWdlKTsKCQkJCWluZGV4X25hbWUgPSBhcmd2WysraV07CgkJCX0gZWxzZSBpZiAoc3RhcnRzX3dpdGgoYXJnLCAiLS1pbmRleC12ZXJzaW9uPSIpKSB7CgkJCQljaGFyICpjOwoJCQkJb3B0cy52ZXJzaW9uID0gc3RydG91bChhcmcgKyAxNiwgJmMsIDEwKTsKCQkJCWlmIChvcHRzLnZlcnNpb24gPiAyKQoJCQkJCWRpZShfKCJiYWQgJXMiKSwgYXJnKTsKCQkJCWlmICgqYyA9PSAnLCcpCgkJCQkJb3B0cy5vZmYzMl9saW1pdCA9IHN0cnRvdWwoYysxLCAmYywgMCk7CgkJCQlpZiAoKmMgfHwgb3B0cy5vZmYzMl9saW1pdCAmIDB4ODAwMDAwMDApCgkJCQkJZGllKF8oImJhZCAlcyIpLCBhcmcpOwoJCQl9IGVsc2UgaWYgKHNraXBfcHJlZml4KGFyZywgIi0tbWF4LWlucHV0LXNpemU9IiwgJmFyZykpIHsKCQkJCW1heF9pbnB1dF9zaXplID0gc3RydG91bWF4KGFyZywgTlVMTCwgMTApOwoJCQl9IGVsc2UgaWYgKHNraXBfcHJlZml4KGFyZywgIi0tb2JqZWN0LWZvcm1hdD0iLCAmYXJnKSkgewoJCQkJaGFzaF9hbGdvID0gaGFzaF9hbGdvX2J5X25hbWUoYXJnKTsKCQkJCWlmIChoYXNoX2FsZ28gPT0gR0lUX0hBU0hfVU5LTk9XTikKCQkJCQlkaWUoXygidW5rbm93biBoYXNoIGFsZ29yaXRobSAnJXMnIiksIGFyZyk7CgkJCQlyZXBvX3NldF9oYXNoX2FsZ28odGhlX3JlcG9zaXRvcnksIGhhc2hfYWxnbyk7CgkJCX0gZWxzZSBpZiAoIXN0cmNtcChhcmcsICItLXJldi1pbmRleCIpKSB7CgkJCQlyZXZfaW5kZXggPSAxOwoJCQl9IGVsc2UgaWYgKCFzdHJjbXAoYXJnLCAiLS1uby1yZXYtaW5kZXgiKSkgewoJCQkJcmV2X2luZGV4ID0gMDsKCQkJfSBlbHNlCgkJCQl1c2FnZShpbmRleF9wYWNrX3VzYWdlKTsKCQkJY29udGludWU7CgkJfQoKCQlpZiAocGFja19uYW1lKQoJCQl1c2FnZShpbmRleF9wYWNrX3VzYWdlKTsKCQlwYWNrX25hbWUgPSBhcmc7Cgl9CgoJaWYgKCFwYWNrX25hbWUgJiYgIWZyb21fc3RkaW4pCgkJdXNhZ2UoaW5kZXhfcGFja191c2FnZSk7CglpZiAoZml4X3RoaW5fcGFjayAmJiAhZnJvbV9zdGRpbikKCQlkaWUoXygidGhlIG9wdGlvbiAnJXMnIHJlcXVpcmVzICclcyciKSwgIi0tZml4LXRoaW4iLCAiLS1zdGRpbiIpOwoJaWYgKGZyb21fc3RkaW4gJiYgIXN0YXJ0dXBfaW5mby0+aGF2ZV9yZXBvc2l0b3J5KQoJCWRpZShfKCItLXN0ZGluIHJlcXVpcmVzIGEgZ2l0IHJlcG9zaXRvcnkiKSk7CglpZiAoZnJvbV9zdGRpbiAmJiBoYXNoX2FsZ28pCgkJZGllKF8oIm9wdGlvbnMgJyVzJyBhbmQgJyVzJyBjYW5ub3QgYmUgdXNlZCB0b2dldGhlciIpLCAiLS1vYmplY3QtZm9ybWF0IiwgIi0tc3RkaW4iKTsKCWlmICghaW5kZXhfbmFtZSAmJiBwYWNrX25hbWUpCgkJaW5kZXhfbmFtZSA9IGRlcml2ZV9maWxlbmFtZShwYWNrX25hbWUsICJwYWNrIiwgImlkeCIsICZpbmRleF9uYW1lX2J1Zik7CgoJb3B0cy5mbGFncyAmPSB+KFdSSVRFX1JFViB8IFdSSVRFX1JFVl9WRVJJRlkpOwoJaWYgKHJldl9pbmRleCkgewoJCW9wdHMuZmxhZ3MgfD0gdmVyaWZ5ID8gV1JJVEVfUkVWX1ZFUklGWSA6IFdSSVRFX1JFVjsKCQlpZiAoaW5kZXhfbmFtZSkKCQkJcmV2X2luZGV4X25hbWUgPSBkZXJpdmVfZmlsZW5hbWUoaW5kZXhfbmFtZSwKCQkJCQkJCSAiaWR4IiwgInJldiIsCgkJCQkJCQkgJnJldl9pbmRleF9uYW1lX2J1Zik7Cgl9CgoJaWYgKHZlcmlmeSkgewoJCWlmICghaW5kZXhfbmFtZSkKCQkJZGllKF8oIi0tdmVyaWZ5IHdpdGggbm8gcGFja2ZpbGUgbmFtZSBnaXZlbiIpKTsKCQlyZWFkX2lkeF9vcHRpb24oJm9wdHMsIGluZGV4X25hbWUpOwoJCW9wdHMuZmxhZ3MgfD0gV1JJVEVfSURYX1ZFUklGWSB8IFdSSVRFX0lEWF9TVFJJQ1Q7Cgl9CglpZiAoc3RyaWN0KQoJCW9wdHMuZmxhZ3MgfD0gV1JJVEVfSURYX1NUUklDVDsKCglpZiAoSEFWRV9USFJFQURTICYmICFucl90aHJlYWRzKSB7CgkJbnJfdGhyZWFkcyA9IG9ubGluZV9jcHVzKCk7CgkJLyoKCQkgKiBFeHBlcmltZW50cyBzaG93IHRoYXQgZ29pbmcgYWJvdmUgMjAgdGhyZWFkcyBkb2Vzbid0IGhlbHAsCgkJICogbm8gbWF0dGVyIGhvdyBtYW55IGNvcmVzIHlvdSBoYXZlLiBCZWxvdyB0aGF0LCB3ZSB0ZW5kIHRvCgkJICogbWF4IGF0IGhhbGYgdGhlIG51bWJlciBvZiBvbmxpbmVfY3B1cygpLCBwcmVzdW1hYmx5IGJlY2F1c2UKCQkgKiBoYWxmIG9mIHRob3NlIGFyZSBoeXBlcnRocmVhZHMgcmF0aGVyIHRoYW4gZnVsbCBjb3Jlcy4gV2UnbGwKCQkgKiBuZXZlciByZWR1Y2UgdGhlIGxldmVsIGJlbG93ICIzIiwgdGhvdWdoLCB0byBtYXRjaCBhCgkJICogaGlzdG9yaWNhbCB2YWx1ZSB0aGF0IG5vYm9keSBjb21wbGFpbmVkIGFib3V0LgoJCSAqLwoJCWlmIChucl90aHJlYWRzIDwgNCkKCQkJOyAvKiB0b28gZmV3IGNvcmVzIHRvIGNvbnNpZGVyIGNhcHBpbmcgKi8KCQllbHNlIGlmIChucl90aHJlYWRzIDwgNikKCQkJbnJfdGhyZWFkcyA9IDM7IC8qIGhpc3RvcmljIGNhcCAqLwoJCWVsc2UgaWYgKG5yX3RocmVhZHMgPCA0MCkKCQkJbnJfdGhyZWFkcyAvPSAyOwoJCWVsc2UKCQkJbnJfdGhyZWFkcyA9IDIwOyAvKiBoYXJkIGNhcCAqLwoJfQoKCWN1cnJfcGFjayA9IG9wZW5fcGFja19maWxlKHBhY2tfbmFtZSk7CglwYXJzZV9wYWNrX2hlYWRlcigpOwoJQ0FMTE9DX0FSUkFZKG9iamVjdHMsIHN0X2FkZChucl9vYmplY3RzLCAxKSk7CglpZiAoc2hvd19zdGF0KQoJCUNBTExPQ19BUlJBWShvYmpfc3RhdCwgc3RfYWRkKG5yX29iamVjdHMsIDEpKTsKCUNBTExPQ19BUlJBWShvZnNfZGVsdGFzLCBucl9vYmplY3RzKTsKCXBhcnNlX3BhY2tfb2JqZWN0cyhwYWNrX2hhc2gpOwoJaWYgKHJlcG9ydF9lbmRfb2ZfaW5wdXQpCgkJd3JpdGVfaW5fZnVsbCgyLCAiXDAiLCAxKTsKCXJlc29sdmVfZGVsdGFzKCk7Cgljb25jbHVkZV9wYWNrKGZpeF90aGluX3BhY2ssIGN1cnJfcGFjaywgcGFja19oYXNoKTsKCWZyZWUob2ZzX2RlbHRhcyk7CglmcmVlKHJlZl9kZWx0YXMpOwoJaWYgKHN0cmljdCkKCQlmb3JlaWduX25yID0gY2hlY2tfb2JqZWN0cygpOwoKCWlmIChzaG93X3N0YXQpCgkJc2hvd19wYWNrX2luZm8oc3RhdF9vbmx5KTsKCglBTExPQ19BUlJBWShpZHhfb2JqZWN0cywgbnJfb2JqZWN0cyk7Cglmb3IgKGkgPSAwOyBpIDwgbnJfb2JqZWN0czsgaSsrKQoJCWlkeF9vYmplY3RzW2ldID0gJm9iamVjdHNbaV0uaWR4OwoJY3Vycl9pbmRleCA9IHdyaXRlX2lkeF9maWxlKGluZGV4X25hbWUsIGlkeF9vYmplY3RzLCBucl9vYmplY3RzLCAmb3B0cywgcGFja19oYXNoKTsKCWlmIChyZXZfaW5kZXgpCgkJY3Vycl9yZXZfaW5kZXggPSB3cml0ZV9yZXZfZmlsZShyZXZfaW5kZXhfbmFtZSwgaWR4X29iamVjdHMsCgkJCQkJCW5yX29iamVjdHMsIHBhY2tfaGFzaCwKCQkJCQkJb3B0cy5mbGFncyk7CglmcmVlKGlkeF9vYmplY3RzKTsKCglpZiAoIXZlcmlmeSkKCQlmaW5hbChwYWNrX25hbWUsIGN1cnJfcGFjaywKCQkgICAgICBpbmRleF9uYW1lLCBjdXJyX2luZGV4LAoJCSAgICAgIHJldl9pbmRleF9uYW1lLCBjdXJyX3Jldl9pbmRleCwKCQkgICAgICBrZWVwX21zZywgcHJvbWlzb3JfbXNnLAoJCSAgICAgIHBhY2tfaGFzaCk7CgllbHNlCgkJY2xvc2UoaW5wdXRfZmQpOwoKCWlmIChkb19mc2NrX29iamVjdCAmJiBmc2NrX2ZpbmlzaCgmZnNja19vcHRpb25zKSkKCQlkaWUoXygiZnNjayBlcnJvciBpbiBwYWNrIG9iamVjdHMiKSk7CgoJZnJlZShvcHRzLmFub21hbHkpOwoJZnJlZShvYmplY3RzKTsKCXN0cmJ1Zl9yZWxlYXNlKCZpbmRleF9uYW1lX2J1Zik7CglzdHJidWZfcmVsZWFzZSgmcmV2X2luZGV4X25hbWVfYnVmKTsKCWlmICghcGFja19uYW1lKQoJCWZyZWUoKHZvaWQgKikgY3Vycl9wYWNrKTsKCWlmICghaW5kZXhfbmFtZSkKCQlmcmVlKCh2b2lkICopIGN1cnJfaW5kZXgpOwoJaWYgKCFyZXZfaW5kZXhfbmFtZSkKCQlmcmVlKCh2b2lkICopIGN1cnJfcmV2X2luZGV4KTsKCgkvKgoJICogTGV0IHRoZSBjYWxsZXIga25vdyB0aGlzIHBhY2sgaXMgbm90IHNlbGYgY29udGFpbmVkCgkgKi8KCWlmIChjaGVja19zZWxmX2NvbnRhaW5lZF9hbmRfY29ubmVjdGVkICYmIGZvcmVpZ25fbnIpCgkJcmV0dXJuIDE7CgoJcmV0dXJuIDA7Cn0K",
    "text": "#include \"builtin.h\"\n#include \"config.h\"\n#include \"delta.h\"\n#include \"environment.h\"\n#include \"gettext.h\"\n#include \"hex.h\"\n#include \"pack.h\"\n#include \"csum-file.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"tag.h\"\n#include \"tree.h\"\n#include \"progress.h\"\n#include \"fsck.h\"\n#include \"exec-cmd.h\"\n#include \"strbuf.h\"\n#include \"streaming.h\"\n#include \"thread-utils.h\"\n#include \"packfile.h\"\n#include \"pack-revindex.h\"\n#include \"object-file.h\"\n#include \"object-store-ll.h\"\n#include \"oid-array.h\"\n#include \"replace-object.h\"\n#include \"promisor-remote.h\"\n#include \"setup.h\"\n\nstatic const char index_pack_usage[] =\n\"git index-pack [-v] [-o <index-file>] [--keep | --keep=<msg>] [--[no-]rev-index] [--verify] [--strict] (<pack-file> | --stdin [--fix-thin] [<pack-file>])\";\n\nstruct object_entry {\n\tstruct pack_idx_entry idx;\n\tunsigned long size;\n\tunsigned char hdr_size;\n\tsigned char type;\n\tsigned char real_type;\n};\n\nstruct object_stat {\n\tunsigned delta_depth;\n\tint base_object_no;\n};\n\nstruct base_data {\n\t/* Initialized by make_base(). */\n\tstruct base_data *base;\n\tstruct object_entry *obj;\n\tint ref_first, ref_last;\n\tint ofs_first, ofs_last;\n\t/*\n\t * Threads should increment retain_data if they are about to call\n\t * patch_delta() using this struct's data as a base, and decrement this\n\t * when they are done. While retain_data is nonzero, this struct's data\n\t * will not be freed even if the delta base cache limit is exceeded.\n\t */\n\tint retain_data;\n\t/*\n\t * The number of direct children that have not been fully processed\n\t * (entered work_head, entered done_head, left done_head). When this\n\t * number reaches zero, this struct base_data can be freed.\n\t */\n\tint children_remaining;\n\n\t/* Not initialized by make_base(). */\n\tstruct list_head list;\n\tvoid *data;\n\tunsigned long size;\n};\n\n/*\n * Stack of struct base_data that have unprocessed children.\n * threaded_second_pass() uses this as a source of work (the other being the\n * objects array).\n *\n * Guarded by work_mutex.\n */\nstatic LIST_HEAD(work_head);\n\n/*\n * Stack of struct base_data that have children, all of whom have been\n * processed or are being processed, and at least one child is being processed.\n * These struct base_data must be kept around until the last child is\n * processed.\n *\n * Guarded by work_mutex.\n */\nstatic LIST_HEAD(done_head);\n\n/*\n * All threads share one delta base cache.\n *\n * base_cache_used is guarded by work_mutex, and base_cache_limit is read-only\n * in a thread.\n */\nstatic size_t base_cache_used;\nstatic size_t base_cache_limit;\n\nstruct thread_local {\n\tpthread_t thread;\n\tint pack_fd;\n};\n\n/* Remember to update object flag allocation in object.h */\n#define FLAG_LINK (1u<<20)\n#define FLAG_CHECKED (1u<<21)\n\nstruct ofs_delta_entry {\n\toff_t offset;\n\tint obj_no;\n};\n\nstruct ref_delta_entry {\n\tstruct object_id oid;\n\tint obj_no;\n};\n\nstatic struct object_entry *objects;\nstatic struct object_stat *obj_stat;\nstatic struct ofs_delta_entry *ofs_deltas;\nstatic struct ref_delta_entry *ref_deltas;\nstatic struct thread_local nothread_data;\nstatic int nr_objects;\nstatic int nr_ofs_deltas;\nstatic int nr_ref_deltas;\nstatic int ref_deltas_alloc;\nstatic int nr_resolved_deltas;\nstatic int nr_threads;\n\nstatic int from_stdin;\nstatic int strict;\nstatic int do_fsck_object;\nstatic struct fsck_options fsck_options = FSCK_OPTIONS_MISSING_GITMODULES;\nstatic int verbose;\nstatic const char *progress_title;\nstatic int show_resolving_progress;\nstatic int show_stat;\nstatic int check_self_contained_and_connected;\n\nstatic struct progress *progress;\n\n/* We always read in 4kB chunks. */\nstatic unsigned char input_buffer[4096];\nstatic unsigned int input_offset, input_len;\nstatic off_t consumed_bytes;\nstatic off_t max_input_size;\nstatic unsigned deepest_delta;\nstatic git_hash_ctx input_ctx;\nstatic uint32_t input_crc32;\nstatic int input_fd, output_fd;\nstatic const char *curr_pack;\n\nstatic struct thread_local *thread_data;\nstatic int nr_dispatched;\nstatic int threads_active;\n\nstatic pthread_mutex_t read_mutex;\n#define read_lock()\t\tlock_mutex(&read_mutex)\n#define read_unlock()\t\tunlock_mutex(&read_mutex)\n\nstatic pthread_mutex_t counter_mutex;\n#define counter_lock()\t\tlock_mutex(&counter_mutex)\n#define counter_unlock()\tunlock_mutex(&counter_mutex)\n\nstatic pthread_mutex_t work_mutex;\n#define work_lock()\t\tlock_mutex(&work_mutex)\n#define work_unlock()\t\tunlock_mutex(&work_mutex)\n\nstatic pthread_mutex_t deepest_delta_mutex;\n#define deepest_delta_lock()\tlock_mutex(&deepest_delta_mutex)\n#define deepest_delta_unlock()\tunlock_mutex(&deepest_delta_mutex)\n\nstatic pthread_key_t key;\n\nstatic inline void lock_mutex(pthread_mutex_t *mutex)\n{\n\tif (threads_active)\n\t\tpthread_mutex_lock(mutex);\n}\n\nstatic inline void unlock_mutex(pthread_mutex_t *mutex)\n{\n\tif (threads_active)\n\t\tpthread_mutex_unlock(mutex);\n}\n\n/*\n * Mutex and conditional variable can't be statically-initialized on Windows.\n */\nstatic void init_thread(void)\n{\n\tint i;\n\tinit_recursive_mutex(&read_mutex);\n\tpthread_mutex_init(&counter_mutex, NULL);\n\tpthread_mutex_init(&work_mutex, NULL);\n\tif (show_stat)\n\t\tpthread_mutex_init(&deepest_delta_mutex, NULL);\n\tpthread_key_create(&key, NULL);\n\tCALLOC_ARRAY(thread_data, nr_threads);\n\tfor (i = 0; i < nr_threads; i++) {\n\t\tthread_data[i].pack_fd = xopen(curr_pack, O_RDONLY);\n\t}\n\n\tthreads_active = 1;\n}\n\nstatic void cleanup_thread(void)\n{\n\tint i;\n\tif (!threads_active)\n\t\treturn;\n\tthreads_active = 0;\n\tpthread_mutex_destroy(&read_mutex);\n\tpthread_mutex_destroy(&counter_mutex);\n\tpthread_mutex_destroy(&work_mutex);\n\tif (show_stat)\n\t\tpthread_mutex_destroy(&deepest_delta_mutex);\n\tfor (i = 0; i < nr_threads; i++)\n\t\tclose(thread_data[i].pack_fd);\n\tpthread_key_delete(key);\n\tfree(thread_data);\n}\n\nstatic int mark_link(struct object *obj, enum object_type type,\n\t\t     void *data UNUSED,\n\t\t     struct fsck_options *options UNUSED)\n{\n\tif (!obj)\n\t\treturn -1;\n\n\tif (type != OBJ_ANY && obj->type != type)\n\t\tdie(_(\"object type mismatch at %s\"), oid_to_hex(&obj->oid));\n\n\tobj->flags |= FLAG_LINK;\n\treturn 0;\n}\n\n/* The content of each linked object must have been checked\n   or it must be already present in the object database */\nstatic unsigned check_object(struct object *obj)\n{\n\tif (!obj)\n\t\treturn 0;\n\n\tif (!(obj->flags & FLAG_LINK))\n\t\treturn 0;\n\n\tif (!(obj->flags & FLAG_CHECKED)) {\n\t\tunsigned long size;\n\t\tint type = oid_object_info(the_repository, &obj->oid, &size);\n\t\tif (type <= 0)\n\t\t\tdie(_(\"did not receive expected object %s\"),\n\t\t\t      oid_to_hex(&obj->oid));\n\t\tif (type != obj->type)\n\t\t\tdie(_(\"object %s: expected type %s, found %s\"),\n\t\t\t    oid_to_hex(&obj->oid),\n\t\t\t    type_name(obj->type), type_name(type));\n\t\tobj->flags |= FLAG_CHECKED;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned check_objects(void)\n{\n\tunsigned i, max, foreign_nr = 0;\n\n\tmax = get_max_object_index();\n\n\tif (verbose)\n\t\tprogress = start_delayed_progress(_(\"Checking objects\"), max);\n\n\tfor (i = 0; i < max; i++) {\n\t\tforeign_nr += check_object(get_indexed_object(i));\n\t\tdisplay_progress(progress, i + 1);\n\t}\n\n\tstop_progress(&progress);\n\treturn foreign_nr;\n}\n\n\n/* Discard current buffer used content. */\nstatic void flush(void)\n{\n\tif (input_offset) {\n\t\tif (output_fd >= 0)\n\t\t\twrite_or_die(output_fd, input_buffer, input_offset);\n\t\tthe_hash_algo->update_fn(&input_ctx, input_buffer, input_offset);\n\t\tmemmove(input_buffer, input_buffer + input_offset, input_len);\n\t\tinput_offset = 0;\n\t}\n}\n\n/*\n * Make sure at least \"min\" bytes are available in the buffer, and\n * return the pointer to the buffer.\n */\nstatic void *fill(int min)\n{\n\tif (min <= input_len)\n\t\treturn input_buffer + input_offset;\n\tif (min > sizeof(input_buffer))\n\t\tdie(Q_(\"cannot fill %d byte\",\n\t\t       \"cannot fill %d bytes\",\n\t\t       min),\n\t\t    min);\n\tflush();\n\tdo {\n\t\tssize_t ret = xread(input_fd, input_buffer + input_len,\n\t\t\t\tsizeof(input_buffer) - input_len);\n\t\tif (ret <= 0) {\n\t\t\tif (!ret)\n\t\t\t\tdie(_(\"early EOF\"));\n\t\t\tdie_errno(_(\"read error on input\"));\n\t\t}\n\t\tinput_len += ret;\n\t\tif (from_stdin)\n\t\t\tdisplay_throughput(progress, consumed_bytes + input_len);\n\t} while (input_len < min);\n\treturn input_buffer;\n}\n\nstatic void use(int bytes)\n{\n\tif (bytes > input_len)\n\t\tdie(_(\"used more bytes than were available\"));\n\tinput_crc32 = crc32(input_crc32, input_buffer + input_offset, bytes);\n\tinput_len -= bytes;\n\tinput_offset += bytes;\n\n\t/* make sure off_t is sufficiently large not to wrap */\n\tif (signed_add_overflows(consumed_bytes, bytes))\n\t\tdie(_(\"pack too large for current definition of off_t\"));\n\tconsumed_bytes += bytes;\n\tif (max_input_size && consumed_bytes > max_input_size) {\n\t\tstruct strbuf size_limit = STRBUF_INIT;\n\t\tstrbuf_humanise_bytes(&size_limit, max_input_size);\n\t\tdie(_(\"pack exceeds maximum allowed size (%s)\"),\n\t\t    size_limit.buf);\n\t}\n}\n\nstatic const char *open_pack_file(const char *pack_name)\n{\n\tif (from_stdin) {\n\t\tinput_fd = 0;\n\t\tif (!pack_name) {\n\t\t\tstruct strbuf tmp_file = STRBUF_INIT;\n\t\t\toutput_fd = odb_mkstemp(&tmp_file,\n\t\t\t\t\t\t\"pack/tmp_pack_XXXXXX\");\n\t\t\tpack_name = strbuf_detach(&tmp_file, NULL);\n\t\t} else {\n\t\t\toutput_fd = xopen(pack_name, O_CREAT|O_EXCL|O_RDWR, 0600);\n\t\t}\n\t\tnothread_data.pack_fd = output_fd;\n\t} else {\n\t\tinput_fd = xopen(pack_name, O_RDONLY);\n\t\toutput_fd = -1;\n\t\tnothread_data.pack_fd = input_fd;\n\t}\n\tthe_hash_algo->init_fn(&input_ctx);\n\treturn pack_name;\n}\n\nstatic void parse_pack_header(void)\n{\n\tstruct pack_header *hdr = fill(sizeof(struct pack_header));\n\n\t/* Header consistency check */\n\tif (hdr->hdr_signature != htonl(PACK_SIGNATURE))\n\t\tdie(_(\"pack signature mismatch\"));\n\tif (!pack_version_ok(hdr->hdr_version))\n\t\tdie(_(\"pack version %\"PRIu32\" unsupported\"),\n\t\t\tntohl(hdr->hdr_version));\n\n\tnr_objects = ntohl(hdr->hdr_entries);\n\tuse(sizeof(struct pack_header));\n}\n\n__attribute__((format (printf, 2, 3)))\nstatic NORETURN void bad_object(off_t offset, const char *format, ...)\n{\n\tva_list params;\n\tchar buf[1024];\n\n\tva_start(params, format);\n\tvsnprintf(buf, sizeof(buf), format, params);\n\tva_end(params);\n\tdie(_(\"pack has bad object at offset %\"PRIuMAX\": %s\"),\n\t    (uintmax_t)offset, buf);\n}\n\nstatic inline struct thread_local *get_thread_data(void)\n{\n\tif (HAVE_THREADS) {\n\t\tif (threads_active)\n\t\t\treturn pthread_getspecific(key);\n\t\tassert(!threads_active &&\n\t\t       \"This should only be reached when all threads are gone\");\n\t}\n\treturn &nothread_data;\n}\n\nstatic void set_thread_data(struct thread_local *data)\n{\n\tif (threads_active)\n\t\tpthread_setspecific(key, data);\n}\n\nstatic void free_base_data(struct base_data *c)\n{\n\tif (c->data) {\n\t\tFREE_AND_NULL(c->data);\n\t\tbase_cache_used -= c->size;\n\t}\n}\n\nstatic void prune_base_data(struct base_data *retain)\n{\n\tstruct list_head *pos;\n\n\tif (base_cache_used <= base_cache_limit)\n\t\treturn;\n\n\tlist_for_each_prev(pos, &done_head) {\n\t\tstruct base_data *b = list_entry(pos, struct base_data, list);\n\t\tif (b->retain_data || b == retain)\n\t\t\tcontinue;\n\t\tif (b->data) {\n\t\t\tfree_base_data(b);\n\t\t\tif (base_cache_used <= base_cache_limit)\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\tlist_for_each_prev(pos, &work_head) {\n\t\tstruct base_data *b = list_entry(pos, struct base_data, list);\n\t\tif (b->retain_data || b == retain)\n\t\t\tcontinue;\n\t\tif (b->data) {\n\t\t\tfree_base_data(b);\n\t\t\tif (base_cache_used <= base_cache_limit)\n\t\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic int is_delta_type(enum object_type type)\n{\n\treturn (type == OBJ_REF_DELTA || type == OBJ_OFS_DELTA);\n}\n\nstatic void *unpack_entry_data(off_t offset, unsigned long size,\n\t\t\t       enum object_type type, struct object_id *oid)\n{\n\tstatic char fixed_buf[8192];\n\tint status;\n\tgit_zstream stream;\n\tvoid *buf;\n\tgit_hash_ctx c;\n\tchar hdr[32];\n\tint hdrlen;\n\n\tif (!is_delta_type(type)) {\n\t\thdrlen = format_object_header(hdr, sizeof(hdr), type, size);\n\t\tthe_hash_algo->init_fn(&c);\n\t\tthe_hash_algo->update_fn(&c, hdr, hdrlen);\n\t} else\n\t\toid = NULL;\n\tif (type == OBJ_BLOB && size > big_file_threshold)\n\t\tbuf = fixed_buf;\n\telse\n\t\tbuf = xmallocz(size);\n\n\tmemset(&stream, 0, sizeof(stream));\n\tgit_inflate_init(&stream);\n\tstream.next_out = buf;\n\tstream.avail_out = buf == fixed_buf ? sizeof(fixed_buf) : size;\n\n\tdo {\n\t\tunsigned char *last_out = stream.next_out;\n\t\tstream.next_in = fill(1);\n\t\tstream.avail_in = input_len;\n\t\tstatus = git_inflate(&stream, 0);\n\t\tuse(input_len - stream.avail_in);\n\t\tif (oid)\n\t\t\tthe_hash_algo->update_fn(&c, last_out, stream.next_out - last_out);\n\t\tif (buf == fixed_buf) {\n\t\t\tstream.next_out = buf;\n\t\t\tstream.avail_out = sizeof(fixed_buf);\n\t\t}\n\t} while (status == Z_OK);\n\tif (stream.total_out != size || status != Z_STREAM_END)\n\t\tbad_object(offset, _(\"inflate returned %d\"), status);\n\tgit_inflate_end(&stream);\n\tif (oid)\n\t\tthe_hash_algo->final_oid_fn(oid, &c);\n\treturn buf == fixed_buf ? NULL : buf;\n}\n\nstatic void *unpack_raw_entry(struct object_entry *obj,\n\t\t\t      off_t *ofs_offset,\n\t\t\t      struct object_id *ref_oid,\n\t\t\t      struct object_id *oid)\n{\n\tunsigned char *p;\n\tunsigned long size, c;\n\toff_t base_offset;\n\tunsigned shift;\n\tvoid *data;\n\n\tobj->idx.offset = consumed_bytes;\n\tinput_crc32 = crc32(0, NULL, 0);\n\n\tp = fill(1);\n\tc = *p;\n\tuse(1);\n\tobj->type = (c >> 4) & 7;\n\tsize = (c & 15);\n\tshift = 4;\n\twhile (c & 0x80) {\n\t\tp = fill(1);\n\t\tc = *p;\n\t\tuse(1);\n\t\tsize += (c & 0x7f) << shift;\n\t\tshift += 7;\n\t}\n\tobj->size = size;\n\n\tswitch (obj->type) {\n\tcase OBJ_REF_DELTA:\n\t\toidread(ref_oid, fill(the_hash_algo->rawsz));\n\t\tuse(the_hash_algo->rawsz);\n\t\tbreak;\n\tcase OBJ_OFS_DELTA:\n\t\tp = fill(1);\n\t\tc = *p;\n\t\tuse(1);\n\t\tbase_offset = c & 127;\n\t\twhile (c & 128) {\n\t\t\tbase_offset += 1;\n\t\t\tif (!base_offset || MSB(base_offset, 7))\n\t\t\t\tbad_object(obj->idx.offset, _(\"offset value overflow for delta base object\"));\n\t\t\tp = fill(1);\n\t\t\tc = *p;\n\t\t\tuse(1);\n\t\t\tbase_offset = (base_offset << 7) + (c & 127);\n\t\t}\n\t\t*ofs_offset = obj->idx.offset - base_offset;\n\t\tif (*ofs_offset <= 0 || *ofs_offset >= obj->idx.offset)\n\t\t\tbad_object(obj->idx.offset, _(\"delta base offset is out of bound\"));\n\t\tbreak;\n\tcase OBJ_COMMIT:\n\tcase OBJ_TREE:\n\tcase OBJ_BLOB:\n\tcase OBJ_TAG:\n\t\tbreak;\n\tdefault:\n\t\tbad_object(obj->idx.offset, _(\"unknown object type %d\"), obj->type);\n\t}\n\tobj->hdr_size = consumed_bytes - obj->idx.offset;\n\n\tdata = unpack_entry_data(obj->idx.offset, obj->size, obj->type, oid);\n\tobj->idx.crc32 = input_crc32;\n\treturn data;\n}\n\nstatic void *unpack_data(struct object_entry *obj,\n\t\t\t int (*consume)(const unsigned char *, unsigned long, void *),\n\t\t\t void *cb_data)\n{\n\toff_t from = obj[0].idx.offset + obj[0].hdr_size;\n\toff_t len = obj[1].idx.offset - from;\n\tunsigned char *data, *inbuf;\n\tgit_zstream stream;\n\tint status;\n\n\tdata = xmallocz(consume ? 64*1024 : obj->size);\n\tinbuf = xmalloc((len < 64*1024) ? (int)len : 64*1024);\n\n\tmemset(&stream, 0, sizeof(stream));\n\tgit_inflate_init(&stream);\n\tstream.next_out = data;\n\tstream.avail_out = consume ? 64*1024 : obj->size;\n\n\tdo {\n\t\tssize_t n = (len < 64*1024) ? (ssize_t)len : 64*1024;\n\t\tn = xpread(get_thread_data()->pack_fd, inbuf, n, from);\n\t\tif (n < 0)\n\t\t\tdie_errno(_(\"cannot pread pack file\"));\n\t\tif (!n)\n\t\t\tdie(Q_(\"premature end of pack file, %\"PRIuMAX\" byte missing\",\n\t\t\t       \"premature end of pack file, %\"PRIuMAX\" bytes missing\",\n\t\t\t       len),\n\t\t\t    (uintmax_t)len);\n\t\tfrom += n;\n\t\tlen -= n;\n\t\tstream.next_in = inbuf;\n\t\tstream.avail_in = n;\n\t\tif (!consume)\n\t\t\tstatus = git_inflate(&stream, 0);\n\t\telse {\n\t\t\tdo {\n\t\t\t\tstatus = git_inflate(&stream, 0);\n\t\t\t\tif (consume(data, stream.next_out - data, cb_data)) {\n\t\t\t\t\tfree(inbuf);\n\t\t\t\t\tfree(data);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tstream.next_out = data;\n\t\t\t\tstream.avail_out = 64*1024;\n\t\t\t} while (status == Z_OK && stream.avail_in);\n\t\t}\n\t} while (len && status == Z_OK && !stream.avail_in);\n\n\t/* This has been inflated OK when first encountered, so... */\n\tif (status != Z_STREAM_END || stream.total_out != obj->size)\n\t\tdie(_(\"serious inflate inconsistency\"));\n\n\tgit_inflate_end(&stream);\n\tfree(inbuf);\n\tif (consume) {\n\t\tFREE_AND_NULL(data);\n\t}\n\treturn data;\n}\n\nstatic void *get_data_from_pack(struct object_entry *obj)\n{\n\treturn unpack_data(obj, NULL, NULL);\n}\n\nstatic int compare_ofs_delta_bases(off_t offset1, off_t offset2,\n\t\t\t\t   enum object_type type1,\n\t\t\t\t   enum object_type type2)\n{\n\tint cmp = type1 - type2;\n\tif (cmp)\n\t\treturn cmp;\n\treturn offset1 < offset2 ? -1 :\n\t       offset1 > offset2 ?  1 :\n\t       0;\n}\n\nstatic int find_ofs_delta(const off_t offset)\n{\n\tint first = 0, last = nr_ofs_deltas;\n\n\twhile (first < last) {\n\t\tint next = first + (last - first) / 2;\n\t\tstruct ofs_delta_entry *delta = &ofs_deltas[next];\n\t\tint cmp;\n\n\t\tcmp = compare_ofs_delta_bases(offset, delta->offset,\n\t\t\t\t\t      OBJ_OFS_DELTA,\n\t\t\t\t\t      objects[delta->obj_no].type);\n\t\tif (!cmp)\n\t\t\treturn next;\n\t\tif (cmp < 0) {\n\t\t\tlast = next;\n\t\t\tcontinue;\n\t\t}\n\t\tfirst = next+1;\n\t}\n\treturn -first-1;\n}\n\nstatic void find_ofs_delta_children(off_t offset,\n\t\t\t\t    int *first_index, int *last_index)\n{\n\tint first = find_ofs_delta(offset);\n\tint last = first;\n\tint end = nr_ofs_deltas - 1;\n\n\tif (first < 0) {\n\t\t*first_index = 0;\n\t\t*last_index = -1;\n\t\treturn;\n\t}\n\twhile (first > 0 && ofs_deltas[first - 1].offset == offset)\n\t\t--first;\n\twhile (last < end && ofs_deltas[last + 1].offset == offset)\n\t\t++last;\n\t*first_index = first;\n\t*last_index = last;\n}\n\nstatic int compare_ref_delta_bases(const struct object_id *oid1,\n\t\t\t\t   const struct object_id *oid2,\n\t\t\t\t   enum object_type type1,\n\t\t\t\t   enum object_type type2)\n{\n\tint cmp = type1 - type2;\n\tif (cmp)\n\t\treturn cmp;\n\treturn oidcmp(oid1, oid2);\n}\n\nstatic int find_ref_delta(const struct object_id *oid)\n{\n\tint first = 0, last = nr_ref_deltas;\n\n\twhile (first < last) {\n\t\tint next = first + (last - first) / 2;\n\t\tstruct ref_delta_entry *delta = &ref_deltas[next];\n\t\tint cmp;\n\n\t\tcmp = compare_ref_delta_bases(oid, &delta->oid,\n\t\t\t\t\t      OBJ_REF_DELTA,\n\t\t\t\t\t      objects[delta->obj_no].type);\n\t\tif (!cmp)\n\t\t\treturn next;\n\t\tif (cmp < 0) {\n\t\t\tlast = next;\n\t\t\tcontinue;\n\t\t}\n\t\tfirst = next+1;\n\t}\n\treturn -first-1;\n}\n\nstatic void find_ref_delta_children(const struct object_id *oid,\n\t\t\t\t    int *first_index, int *last_index)\n{\n\tint first = find_ref_delta(oid);\n\tint last = first;\n\tint end = nr_ref_deltas - 1;\n\n\tif (first < 0) {\n\t\t*first_index = 0;\n\t\t*last_index = -1;\n\t\treturn;\n\t}\n\twhile (first > 0 && oideq(&ref_deltas[first - 1].oid, oid))\n\t\t--first;\n\twhile (last < end && oideq(&ref_deltas[last + 1].oid, oid))\n\t\t++last;\n\t*first_index = first;\n\t*last_index = last;\n}\n\nstruct compare_data {\n\tstruct object_entry *entry;\n\tstruct git_istream *st;\n\tunsigned char *buf;\n\tunsigned long buf_size;\n};\n\nstatic int compare_objects(const unsigned char *buf, unsigned long size,\n\t\t\t   void *cb_data)\n{\n\tstruct compare_data *data = cb_data;\n\n\tif (data->buf_size < size) {\n\t\tfree(data->buf);\n\t\tdata->buf = xmalloc(size);\n\t\tdata->buf_size = size;\n\t}\n\n\twhile (size) {\n\t\tssize_t len = read_istream(data->st, data->buf, size);\n\t\tif (len == 0)\n\t\t\tdie(_(\"SHA1 COLLISION FOUND WITH %s !\"),\n\t\t\t    oid_to_hex(&data->entry->idx.oid));\n\t\tif (len < 0)\n\t\t\tdie(_(\"unable to read %s\"),\n\t\t\t    oid_to_hex(&data->entry->idx.oid));\n\t\tif (memcmp(buf, data->buf, len))\n\t\t\tdie(_(\"SHA1 COLLISION FOUND WITH %s !\"),\n\t\t\t    oid_to_hex(&data->entry->idx.oid));\n\t\tsize -= len;\n\t\tbuf += len;\n\t}\n\treturn 0;\n}\n\nstatic int check_collison(struct object_entry *entry)\n{\n\tstruct compare_data data;\n\tenum object_type type;\n\tunsigned long size;\n\n\tif (entry->size <= big_file_threshold || entry->type != OBJ_BLOB)\n\t\treturn -1;\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.entry = entry;\n\tdata.st = open_istream(the_repository, &entry->idx.oid, &type, &size,\n\t\t\t       NULL);\n\tif (!data.st)\n\t\treturn -1;\n\tif (size != entry->size || type != entry->type)\n\t\tdie(_(\"SHA1 COLLISION FOUND WITH %s !\"),\n\t\t    oid_to_hex(&entry->idx.oid));\n\tunpack_data(entry, compare_objects, &data);\n\tclose_istream(data.st);\n\tfree(data.buf);\n\treturn 0;\n}\n\nstatic void sha1_object(const void *data, struct object_entry *obj_entry,\n\t\t\tunsigned long size, enum object_type type,\n\t\t\tconst struct object_id *oid)\n{\n\tvoid *new_data = NULL;\n\tint collision_test_needed = 0;\n\n\tassert(data || obj_entry);\n\n\tif (startup_info->have_repository) {\n\t\tread_lock();\n\t\tcollision_test_needed =\n\t\t\trepo_has_object_file_with_flags(the_repository, oid,\n\t\t\t\t\t\t\tOBJECT_INFO_QUICK);\n\t\tread_unlock();\n\t}\n\n\tif (collision_test_needed && !data) {\n\t\tread_lock();\n\t\tif (!check_collison(obj_entry))\n\t\t\tcollision_test_needed = 0;\n\t\tread_unlock();\n\t}\n\tif (collision_test_needed) {\n\t\tvoid *has_data;\n\t\tenum object_type has_type;\n\t\tunsigned long has_size;\n\t\tread_lock();\n\t\thas_type = oid_object_info(the_repository, oid, &has_size);\n\t\tif (has_type < 0)\n\t\t\tdie(_(\"cannot read existing object info %s\"), oid_to_hex(oid));\n\t\tif (has_type != type || has_size != size)\n\t\t\tdie(_(\"SHA1 COLLISION FOUND WITH %s !\"), oid_to_hex(oid));\n\t\thas_data = repo_read_object_file(the_repository, oid,\n\t\t\t\t\t\t &has_type, &has_size);\n\t\tread_unlock();\n\t\tif (!data)\n\t\t\tdata = new_data = get_data_from_pack(obj_entry);\n\t\tif (!has_data)\n\t\t\tdie(_(\"cannot read existing object %s\"), oid_to_hex(oid));\n\t\tif (size != has_size || type != has_type ||\n\t\t    memcmp(data, has_data, size) != 0)\n\t\t\tdie(_(\"SHA1 COLLISION FOUND WITH %s !\"), oid_to_hex(oid));\n\t\tfree(has_data);\n\t}\n\n\tif (strict || do_fsck_object) {\n\t\tread_lock();\n\t\tif (type == OBJ_BLOB) {\n\t\t\tstruct blob *blob = lookup_blob(the_repository, oid);\n\t\t\tif (blob)\n\t\t\t\tblob->object.flags |= FLAG_CHECKED;\n\t\t\telse\n\t\t\t\tdie(_(\"invalid blob object %s\"), oid_to_hex(oid));\n\t\t\tif (do_fsck_object &&\n\t\t\t    fsck_object(&blob->object, (void *)data, size, &fsck_options))\n\t\t\t\tdie(_(\"fsck error in packed object\"));\n\t\t} else {\n\t\t\tstruct object *obj;\n\t\t\tint eaten;\n\t\t\tvoid *buf = (void *) data;\n\n\t\t\tassert(data && \"data can only be NULL for large _blobs_\");\n\n\t\t\t/*\n\t\t\t * we do not need to free the memory here, as the\n\t\t\t * buf is deleted by the caller.\n\t\t\t */\n\t\t\tobj = parse_object_buffer(the_repository, oid, type,\n\t\t\t\t\t\t  size, buf,\n\t\t\t\t\t\t  &eaten);\n\t\t\tif (!obj)\n\t\t\t\tdie(_(\"invalid %s\"), type_name(type));\n\t\t\tif (do_fsck_object &&\n\t\t\t    fsck_object(obj, buf, size, &fsck_options))\n\t\t\t\tdie(_(\"fsck error in packed object\"));\n\t\t\tif (strict && fsck_walk(obj, NULL, &fsck_options))\n\t\t\t\tdie(_(\"Not all child objects of %s are reachable\"), oid_to_hex(&obj->oid));\n\n\t\t\tif (obj->type == OBJ_TREE) {\n\t\t\t\tstruct tree *item = (struct tree *) obj;\n\t\t\t\titem->buffer = NULL;\n\t\t\t\tobj->parsed = 0;\n\t\t\t}\n\t\t\tif (obj->type == OBJ_COMMIT) {\n\t\t\t\tstruct commit *commit = (struct commit *) obj;\n\t\t\t\tif (detach_commit_buffer(commit, NULL) != data)\n\t\t\t\t\tBUG(\"parse_object_buffer transmogrified our buffer\");\n\t\t\t}\n\t\t\tobj->flags |= FLAG_CHECKED;\n\t\t}\n\t\tread_unlock();\n\t}\n\n\tfree(new_data);\n}\n\n/*\n * Ensure that this node has been reconstructed and return its contents.\n *\n * In the typical and best case, this node would already be reconstructed\n * (through the invocation to resolve_delta() in threaded_second_pass()) and it\n * would not be pruned. However, if pruning of this node was necessary due to\n * reaching delta_base_cache_limit, this function will find the closest\n * ancestor with reconstructed data that has not been pruned (or if there is\n * none, the ultimate base object), and reconstruct each node in the delta\n * chain in order to generate the reconstructed data for this node.\n */\nstatic void *get_base_data(struct base_data *c)\n{\n\tif (!c->data) {\n\t\tstruct object_entry *obj = c->obj;\n\t\tstruct base_data **delta = NULL;\n\t\tint delta_nr = 0, delta_alloc = 0;\n\n\t\twhile (is_delta_type(c->obj->type) && !c->data) {\n\t\t\tALLOC_GROW(delta, delta_nr + 1, delta_alloc);\n\t\t\tdelta[delta_nr++] = c;\n\t\t\tc = c->base;\n\t\t}\n\t\tif (!delta_nr) {\n\t\t\tc->data = get_data_from_pack(obj);\n\t\t\tc->size = obj->size;\n\t\t\tbase_cache_used += c->size;\n\t\t\tprune_base_data(c);\n\t\t}\n\t\tfor (; delta_nr > 0; delta_nr--) {\n\t\t\tvoid *base, *raw;\n\t\t\tc = delta[delta_nr - 1];\n\t\t\tobj = c->obj;\n\t\t\tbase = get_base_data(c->base);\n\t\t\traw = get_data_from_pack(obj);\n\t\t\tc->data = patch_delta(\n\t\t\t\tbase, c->base->size,\n\t\t\t\traw, obj->size,\n\t\t\t\t&c->size);\n\t\t\tfree(raw);\n\t\t\tif (!c->data)\n\t\t\t\tbad_object(obj->idx.offset, _(\"failed to apply delta\"));\n\t\t\tbase_cache_used += c->size;\n\t\t\tprune_base_data(c);\n\t\t}\n\t\tfree(delta);\n\t}\n\treturn c->data;\n}\n\nstatic struct base_data *make_base(struct object_entry *obj,\n\t\t\t\t   struct base_data *parent)\n{\n\tstruct base_data *base = xcalloc(1, sizeof(struct base_data));\n\tbase->base = parent;\n\tbase->obj = obj;\n\tfind_ref_delta_children(&obj->idx.oid,\n\t\t\t\t&base->ref_first, &base->ref_last);\n\tfind_ofs_delta_children(obj->idx.offset,\n\t\t\t\t&base->ofs_first, &base->ofs_last);\n\tbase->children_remaining = base->ref_last - base->ref_first +\n\t\tbase->ofs_last - base->ofs_first + 2;\n\treturn base;\n}\n\nstatic struct base_data *resolve_delta(struct object_entry *delta_obj,\n\t\t\t\t       struct base_data *base)\n{\n\tvoid *delta_data, *result_data;\n\tstruct base_data *result;\n\tunsigned long result_size;\n\n\tif (show_stat) {\n\t\tint i = delta_obj - objects;\n\t\tint j = base->obj - objects;\n\t\tobj_stat[i].delta_depth = obj_stat[j].delta_depth + 1;\n\t\tdeepest_delta_lock();\n\t\tif (deepest_delta < obj_stat[i].delta_depth)\n\t\t\tdeepest_delta = obj_stat[i].delta_depth;\n\t\tdeepest_delta_unlock();\n\t\tobj_stat[i].base_object_no = j;\n\t}\n\tdelta_data = get_data_from_pack(delta_obj);\n\tassert(base->data);\n\tresult_data = patch_delta(base->data, base->size,\n\t\t\t\t  delta_data, delta_obj->size, &result_size);\n\tfree(delta_data);\n\tif (!result_data)\n\t\tbad_object(delta_obj->idx.offset, _(\"failed to apply delta\"));\n\thash_object_file(the_hash_algo, result_data, result_size,\n\t\t\t delta_obj->real_type, &delta_obj->idx.oid);\n\tsha1_object(result_data, NULL, result_size, delta_obj->real_type,\n\t\t    &delta_obj->idx.oid);\n\n\tresult = make_base(delta_obj, base);\n\tresult->data = result_data;\n\tresult->size = result_size;\n\n\tcounter_lock();\n\tnr_resolved_deltas++;\n\tcounter_unlock();\n\n\treturn result;\n}\n\nstatic int compare_ofs_delta_entry(const void *a, const void *b)\n{\n\tconst struct ofs_delta_entry *delta_a = a;\n\tconst struct ofs_delta_entry *delta_b = b;\n\n\treturn delta_a->offset < delta_b->offset ? -1 :\n\t       delta_a->offset > delta_b->offset ?  1 :\n\t       0;\n}\n\nstatic int compare_ref_delta_entry(const void *a, const void *b)\n{\n\tconst struct ref_delta_entry *delta_a = a;\n\tconst struct ref_delta_entry *delta_b = b;\n\n\treturn oidcmp(&delta_a->oid, &delta_b->oid);\n}\n\nstatic void *threaded_second_pass(void *data)\n{\n\tif (data)\n\t\tset_thread_data(data);\n\tfor (;;) {\n\t\tstruct base_data *parent = NULL;\n\t\tstruct object_entry *child_obj;\n\t\tstruct base_data *child;\n\n\t\tcounter_lock();\n\t\tdisplay_progress(progress, nr_resolved_deltas);\n\t\tcounter_unlock();\n\n\t\twork_lock();\n\t\tif (list_empty(&work_head)) {\n\t\t\t/*\n\t\t\t * Take an object from the object array.\n\t\t\t */\n\t\t\twhile (nr_dispatched < nr_objects &&\n\t\t\t       is_delta_type(objects[nr_dispatched].type))\n\t\t\t\tnr_dispatched++;\n\t\t\tif (nr_dispatched >= nr_objects) {\n\t\t\t\twork_unlock();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tchild_obj = &objects[nr_dispatched++];\n\t\t} else {\n\t\t\t/*\n\t\t\t * Peek at the top of the stack, and take a child from\n\t\t\t * it.\n\t\t\t */\n\t\t\tparent = list_first_entry(&work_head, struct base_data,\n\t\t\t\t\t\t  list);\n\n\t\t\tif (parent->ref_first <= parent->ref_last) {\n\t\t\t\tint offset = ref_deltas[parent->ref_first++].obj_no;\n\t\t\t\tchild_obj = objects + offset;\n\t\t\t\tif (child_obj->real_type != OBJ_REF_DELTA)\n\t\t\t\t\tdie(\"REF_DELTA at offset %\"PRIuMAX\" already resolved (duplicate base %s?)\",\n\t\t\t\t\t    (uintmax_t) child_obj->idx.offset,\n\t\t\t\t\t    oid_to_hex(&parent->obj->idx.oid));\n\t\t\t\tchild_obj->real_type = parent->obj->real_type;\n\t\t\t} else {\n\t\t\t\tchild_obj = objects +\n\t\t\t\t\tofs_deltas[parent->ofs_first++].obj_no;\n\t\t\t\tassert(child_obj->real_type == OBJ_OFS_DELTA);\n\t\t\t\tchild_obj->real_type = parent->obj->real_type;\n\t\t\t}\n\n\t\t\tif (parent->ref_first > parent->ref_last &&\n\t\t\t    parent->ofs_first > parent->ofs_last) {\n\t\t\t\t/*\n\t\t\t\t * This parent has run out of children, so move\n\t\t\t\t * it to done_head.\n\t\t\t\t */\n\t\t\t\tlist_del(&parent->list);\n\t\t\t\tlist_add(&parent->list, &done_head);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Ensure that the parent has data, since we will need\n\t\t\t * it later.\n\t\t\t *\n\t\t\t * NEEDSWORK: If parent data needs to be reloaded, this\n\t\t\t * prolongs the time that the current thread spends in\n\t\t\t * the mutex. A mitigating factor is that parent data\n\t\t\t * needs to be reloaded only if the delta base cache\n\t\t\t * limit is exceeded, so in the typical case, this does\n\t\t\t * not happen.\n\t\t\t */\n\t\t\tget_base_data(parent);\n\t\t\tparent->retain_data++;\n\t\t}\n\t\twork_unlock();\n\n\t\tif (parent) {\n\t\t\tchild = resolve_delta(child_obj, parent);\n\t\t\tif (!child->children_remaining)\n\t\t\t\tFREE_AND_NULL(child->data);\n\t\t} else {\n\t\t\tchild = make_base(child_obj, NULL);\n\t\t\tif (child->children_remaining) {\n\t\t\t\t/*\n\t\t\t\t * Since this child has its own delta children,\n\t\t\t\t * we will need this data in the future.\n\t\t\t\t * Inflate now so that future iterations will\n\t\t\t\t * have access to this object's data while\n\t\t\t\t * outside the work mutex.\n\t\t\t\t */\n\t\t\t\tchild->data = get_data_from_pack(child_obj);\n\t\t\t\tchild->size = child_obj->size;\n\t\t\t}\n\t\t}\n\n\t\twork_lock();\n\t\tif (parent)\n\t\t\tparent->retain_data--;\n\t\tif (child->data) {\n\t\t\t/*\n\t\t\t * This child has its own children, so add it to\n\t\t\t * work_head.\n\t\t\t */\n\t\t\tlist_add(&child->list, &work_head);\n\t\t\tbase_cache_used += child->size;\n\t\t\tprune_base_data(NULL);\n\t\t\tfree_base_data(child);\n\t\t} else {\n\t\t\t/*\n\t\t\t * This child does not have its own children. It may be\n\t\t\t * the last descendant of its ancestors; free those\n\t\t\t * that we can.\n\t\t\t */\n\t\t\tstruct base_data *p = parent;\n\n\t\t\twhile (p) {\n\t\t\t\tstruct base_data *next_p;\n\n\t\t\t\tp->children_remaining--;\n\t\t\t\tif (p->children_remaining)\n\t\t\t\t\tbreak;\n\n\t\t\t\tnext_p = p->base;\n\t\t\t\tfree_base_data(p);\n\t\t\t\tlist_del(&p->list);\n\t\t\t\tfree(p);\n\n\t\t\t\tp = next_p;\n\t\t\t}\n\t\t\tFREE_AND_NULL(child);\n\t\t}\n\t\twork_unlock();\n\t}\n\treturn NULL;\n}\n\n/*\n * First pass:\n * - find locations of all objects;\n * - calculate SHA1 of all non-delta objects;\n * - remember base (SHA1 or offset) for all deltas.\n */\nstatic void parse_pack_objects(unsigned char *hash)\n{\n\tint i, nr_delays = 0;\n\tstruct ofs_delta_entry *ofs_delta = ofs_deltas;\n\tstruct object_id ref_delta_oid;\n\tstruct stat st;\n\n\tif (verbose)\n\t\tprogress = start_progress(\n\t\t\t\tprogress_title ? progress_title :\n\t\t\t\tfrom_stdin ? _(\"Receiving objects\") : _(\"Indexing objects\"),\n\t\t\t\tnr_objects);\n\tfor (i = 0; i < nr_objects; i++) {\n\t\tstruct object_entry *obj = &objects[i];\n\t\tvoid *data = unpack_raw_entry(obj, &ofs_delta->offset,\n\t\t\t\t\t      &ref_delta_oid,\n\t\t\t\t\t      &obj->idx.oid);\n\t\tobj->real_type = obj->type;\n\t\tif (obj->type == OBJ_OFS_DELTA) {\n\t\t\tnr_ofs_deltas++;\n\t\t\tofs_delta->obj_no = i;\n\t\t\tofs_delta++;\n\t\t} else if (obj->type == OBJ_REF_DELTA) {\n\t\t\tALLOC_GROW(ref_deltas, nr_ref_deltas + 1, ref_deltas_alloc);\n\t\t\toidcpy(&ref_deltas[nr_ref_deltas].oid, &ref_delta_oid);\n\t\t\tref_deltas[nr_ref_deltas].obj_no = i;\n\t\t\tnr_ref_deltas++;\n\t\t} else if (!data) {\n\t\t\t/* large blobs, check later */\n\t\t\tobj->real_type = OBJ_BAD;\n\t\t\tnr_delays++;\n\t\t} else\n\t\t\tsha1_object(data, NULL, obj->size, obj->type,\n\t\t\t\t    &obj->idx.oid);\n\t\tfree(data);\n\t\tdisplay_progress(progress, i+1);\n\t}\n\tobjects[i].idx.offset = consumed_bytes;\n\tstop_progress(&progress);\n\n\t/* Check pack integrity */\n\tflush();\n\tthe_hash_algo->final_fn(hash, &input_ctx);\n\tif (!hasheq(fill(the_hash_algo->rawsz), hash))\n\t\tdie(_(\"pack is corrupted (SHA1 mismatch)\"));\n\tuse(the_hash_algo->rawsz);\n\n\t/* If input_fd is a file, we should have reached its end now. */\n\tif (fstat(input_fd, &st))\n\t\tdie_errno(_(\"cannot fstat packfile\"));\n\tif (S_ISREG(st.st_mode) &&\n\t\t\tlseek(input_fd, 0, SEEK_CUR) - input_len != st.st_size)\n\t\tdie(_(\"pack has junk at the end\"));\n\n\tfor (i = 0; i < nr_objects; i++) {\n\t\tstruct object_entry *obj = &objects[i];\n\t\tif (obj->real_type != OBJ_BAD)\n\t\t\tcontinue;\n\t\tobj->real_type = obj->type;\n\t\tsha1_object(NULL, obj, obj->size, obj->type,\n\t\t\t    &obj->idx.oid);\n\t\tnr_delays--;\n\t}\n\tif (nr_delays)\n\t\tdie(_(\"confusion beyond insanity in parse_pack_objects()\"));\n}\n\n/*\n * Second pass:\n * - for all non-delta objects, look if it is used as a base for\n *   deltas;\n * - if used as a base, uncompress the object and apply all deltas,\n *   recursively checking if the resulting object is used as a base\n *   for some more deltas.\n */\nstatic void resolve_deltas(void)\n{\n\tint i;\n\n\tif (!nr_ofs_deltas && !nr_ref_deltas)\n\t\treturn;\n\n\t/* Sort deltas by base SHA1/offset for fast searching */\n\tQSORT(ofs_deltas, nr_ofs_deltas, compare_ofs_delta_entry);\n\tQSORT(ref_deltas, nr_ref_deltas, compare_ref_delta_entry);\n\n\tif (verbose || show_resolving_progress)\n\t\tprogress = start_progress(_(\"Resolving deltas\"),\n\t\t\t\t\t  nr_ref_deltas + nr_ofs_deltas);\n\n\tnr_dispatched = 0;\n\tbase_cache_limit = delta_base_cache_limit * nr_threads;\n\tif (nr_threads > 1 || getenv(\"GIT_FORCE_THREADS\")) {\n\t\tinit_thread();\n\t\tfor (i = 0; i < nr_threads; i++) {\n\t\t\tint ret = pthread_create(&thread_data[i].thread, NULL,\n\t\t\t\t\t\t threaded_second_pass, thread_data + i);\n\t\t\tif (ret)\n\t\t\t\tdie(_(\"unable to create thread: %s\"),\n\t\t\t\t    strerror(ret));\n\t\t}\n\t\tfor (i = 0; i < nr_threads; i++)\n\t\t\tpthread_join(thread_data[i].thread, NULL);\n\t\tcleanup_thread();\n\t\treturn;\n\t}\n\tthreaded_second_pass(&nothread_data);\n}\n\n/*\n * Third pass:\n * - append objects to convert thin pack to full pack if required\n * - write the final pack hash\n */\nstatic void fix_unresolved_deltas(struct hashfile *f);\nstatic void conclude_pack(int fix_thin_pack, const char *curr_pack, unsigned char *pack_hash)\n{\n\tif (nr_ref_deltas + nr_ofs_deltas == nr_resolved_deltas) {\n\t\tstop_progress(&progress);\n\t\t/* Flush remaining pack final hash. */\n\t\tflush();\n\t\treturn;\n\t}\n\n\tif (fix_thin_pack) {\n\t\tstruct hashfile *f;\n\t\tunsigned char read_hash[GIT_MAX_RAWSZ], tail_hash[GIT_MAX_RAWSZ];\n\t\tstruct strbuf msg = STRBUF_INIT;\n\t\tint nr_unresolved = nr_ofs_deltas + nr_ref_deltas - nr_resolved_deltas;\n\t\tint nr_objects_initial = nr_objects;\n\t\tif (nr_unresolved <= 0)\n\t\t\tdie(_(\"confusion beyond insanity\"));\n\t\tREALLOC_ARRAY(objects, nr_objects + nr_unresolved + 1);\n\t\tmemset(objects + nr_objects + 1, 0,\n\t\t       nr_unresolved * sizeof(*objects));\n\t\tf = hashfd(output_fd, curr_pack);\n\t\tfix_unresolved_deltas(f);\n\t\tstrbuf_addf(&msg, Q_(\"completed with %d local object\",\n\t\t\t\t     \"completed with %d local objects\",\n\t\t\t\t     nr_objects - nr_objects_initial),\n\t\t\t    nr_objects - nr_objects_initial);\n\t\tstop_progress_msg(&progress, msg.buf);\n\t\tstrbuf_release(&msg);\n\t\tfinalize_hashfile(f, tail_hash, FSYNC_COMPONENT_PACK, 0);\n\t\thashcpy(read_hash, pack_hash);\n\t\tfixup_pack_header_footer(output_fd, pack_hash,\n\t\t\t\t\t curr_pack, nr_objects,\n\t\t\t\t\t read_hash, consumed_bytes-the_hash_algo->rawsz);\n\t\tif (!hasheq(read_hash, tail_hash))\n\t\t\tdie(_(\"Unexpected tail checksum for %s \"\n\t\t\t      \"(disk corruption?)\"), curr_pack);\n\t}\n\tif (nr_ofs_deltas + nr_ref_deltas != nr_resolved_deltas)\n\t\tdie(Q_(\"pack has %d unresolved delta\",\n\t\t       \"pack has %d unresolved deltas\",\n\t\t       nr_ofs_deltas + nr_ref_deltas - nr_resolved_deltas),\n\t\t    nr_ofs_deltas + nr_ref_deltas - nr_resolved_deltas);\n}\n\nstatic int write_compressed(struct hashfile *f, void *in, unsigned int size)\n{\n\tgit_zstream stream;\n\tint status;\n\tunsigned char outbuf[4096];\n\n\tgit_deflate_init(&stream, zlib_compression_level);\n\tstream.next_in = in;\n\tstream.avail_in = size;\n\n\tdo {\n\t\tstream.next_out = outbuf;\n\t\tstream.avail_out = sizeof(outbuf);\n\t\tstatus = git_deflate(&stream, Z_FINISH);\n\t\thashwrite(f, outbuf, sizeof(outbuf) - stream.avail_out);\n\t} while (status == Z_OK);\n\n\tif (status != Z_STREAM_END)\n\t\tdie(_(\"unable to deflate appended object (%d)\"), status);\n\tsize = stream.total_out;\n\tgit_deflate_end(&stream);\n\treturn size;\n}\n\nstatic struct object_entry *append_obj_to_pack(struct hashfile *f,\n\t\t\t       const unsigned char *sha1, void *buf,\n\t\t\t       unsigned long size, enum object_type type)\n{\n\tstruct object_entry *obj = &objects[nr_objects++];\n\tunsigned char header[10];\n\tunsigned long s = size;\n\tint n = 0;\n\tunsigned char c = (type << 4) | (s & 15);\n\ts >>= 4;\n\twhile (s) {\n\t\theader[n++] = c | 0x80;\n\t\tc = s & 0x7f;\n\t\ts >>= 7;\n\t}\n\theader[n++] = c;\n\tcrc32_begin(f);\n\thashwrite(f, header, n);\n\tobj[0].size = size;\n\tobj[0].hdr_size = n;\n\tobj[0].type = type;\n\tobj[0].real_type = type;\n\tobj[1].idx.offset = obj[0].idx.offset + n;\n\tobj[1].idx.offset += write_compressed(f, buf, size);\n\tobj[0].idx.crc32 = crc32_end(f);\n\thashflush(f);\n\toidread(&obj->idx.oid, sha1);\n\treturn obj;\n}\n\nstatic int delta_pos_compare(const void *_a, const void *_b)\n{\n\tstruct ref_delta_entry *a = *(struct ref_delta_entry **)_a;\n\tstruct ref_delta_entry *b = *(struct ref_delta_entry **)_b;\n\treturn a->obj_no - b->obj_no;\n}\n\nstatic void fix_unresolved_deltas(struct hashfile *f)\n{\n\tstruct ref_delta_entry **sorted_by_pos;\n\tint i;\n\n\t/*\n\t * Since many unresolved deltas may well be themselves base objects\n\t * for more unresolved deltas, we really want to include the\n\t * smallest number of base objects that would cover as much delta\n\t * as possible by picking the\n\t * trunc deltas first, allowing for other deltas to resolve without\n\t * additional base objects.  Since most base objects are to be found\n\t * before deltas depending on them, a good heuristic is to start\n\t * resolving deltas in the same order as their position in the pack.\n\t */\n\tALLOC_ARRAY(sorted_by_pos, nr_ref_deltas);\n\tfor (i = 0; i < nr_ref_deltas; i++)\n\t\tsorted_by_pos[i] = &ref_deltas[i];\n\tQSORT(sorted_by_pos, nr_ref_deltas, delta_pos_compare);\n\n\tif (repo_has_promisor_remote(the_repository)) {\n\t\t/*\n\t\t * Prefetch the delta bases.\n\t\t */\n\t\tstruct oid_array to_fetch = OID_ARRAY_INIT;\n\t\tfor (i = 0; i < nr_ref_deltas; i++) {\n\t\t\tstruct ref_delta_entry *d = sorted_by_pos[i];\n\t\t\tif (!oid_object_info_extended(the_repository, &d->oid,\n\t\t\t\t\t\t      NULL,\n\t\t\t\t\t\t      OBJECT_INFO_FOR_PREFETCH))\n\t\t\t\tcontinue;\n\t\t\toid_array_append(&to_fetch, &d->oid);\n\t\t}\n\t\tpromisor_remote_get_direct(the_repository,\n\t\t\t\t\t   to_fetch.oid, to_fetch.nr);\n\t\toid_array_clear(&to_fetch);\n\t}\n\n\tfor (i = 0; i < nr_ref_deltas; i++) {\n\t\tstruct ref_delta_entry *d = sorted_by_pos[i];\n\t\tenum object_type type;\n\t\tvoid *data;\n\t\tunsigned long size;\n\n\t\tif (objects[d->obj_no].real_type != OBJ_REF_DELTA)\n\t\t\tcontinue;\n\t\tdata = repo_read_object_file(the_repository, &d->oid, &type,\n\t\t\t\t\t     &size);\n\t\tif (!data)\n\t\t\tcontinue;\n\n\t\tif (check_object_signature(the_repository, &d->oid, data, size,\n\t\t\t\t\t   type) < 0)\n\t\t\tdie(_(\"local object %s is corrupt\"), oid_to_hex(&d->oid));\n\n\t\t/*\n\t\t * Add this as an object to the objects array and call\n\t\t * threaded_second_pass() (which will pick up the added\n\t\t * object).\n\t\t */\n\t\tappend_obj_to_pack(f, d->oid.hash, data, size, type);\n\t\tfree(data);\n\t\tthreaded_second_pass(NULL);\n\n\t\tdisplay_progress(progress, nr_resolved_deltas);\n\t}\n\tfree(sorted_by_pos);\n}\n\nstatic const char *derive_filename(const char *pack_name, const char *strip,\n\t\t\t\t   const char *suffix, struct strbuf *buf)\n{\n\tsize_t len;\n\tif (!strip_suffix(pack_name, strip, &len) || !len ||\n\t    pack_name[len - 1] != '.')\n\t\tdie(_(\"packfile name '%s' does not end with '.%s'\"),\n\t\t    pack_name, strip);\n\tstrbuf_add(buf, pack_name, len);\n\tstrbuf_addstr(buf, suffix);\n\treturn buf->buf;\n}\n\nstatic void write_special_file(const char *suffix, const char *msg,\n\t\t\t       const char *pack_name, const unsigned char *hash,\n\t\t\t       const char **report)\n{\n\tstruct strbuf name_buf = STRBUF_INIT;\n\tconst char *filename;\n\tint fd;\n\tint msg_len = strlen(msg);\n\n\tif (pack_name)\n\t\tfilename = derive_filename(pack_name, \"pack\", suffix, &name_buf);\n\telse\n\t\tfilename = odb_pack_name(&name_buf, hash, suffix);\n\n\tfd = odb_pack_keep(filename);\n\tif (fd < 0) {\n\t\tif (errno != EEXIST)\n\t\t\tdie_errno(_(\"cannot write %s file '%s'\"),\n\t\t\t\t  suffix, filename);\n\t} else {\n\t\tif (msg_len > 0) {\n\t\t\twrite_or_die(fd, msg, msg_len);\n\t\t\twrite_or_die(fd, \"\\n\", 1);\n\t\t}\n\t\tif (close(fd) != 0)\n\t\t\tdie_errno(_(\"cannot close written %s file '%s'\"),\n\t\t\t\t  suffix, filename);\n\t\tif (report)\n\t\t\t*report = suffix;\n\t}\n\tstrbuf_release(&name_buf);\n}\n\nstatic void rename_tmp_packfile(const char **final_name,\n\t\t\t\tconst char *curr_name,\n\t\t\t\tstruct strbuf *name, unsigned char *hash,\n\t\t\t\tconst char *ext, int make_read_only_if_same)\n{\n\tif (*final_name != curr_name) {\n\t\tif (!*final_name)\n\t\t\t*final_name = odb_pack_name(name, hash, ext);\n\t\tif (finalize_object_file(curr_name, *final_name))\n\t\t\tdie(_(\"unable to rename temporary '*.%s' file to '%s'\"),\n\t\t\t    ext, *final_name);\n\t} else if (make_read_only_if_same) {\n\t\tchmod(*final_name, 0444);\n\t}\n}\n\nstatic void final(const char *final_pack_name, const char *curr_pack_name,\n\t\t  const char *final_index_name, const char *curr_index_name,\n\t\t  const char *final_rev_index_name, const char *curr_rev_index_name,\n\t\t  const char *keep_msg, const char *promisor_msg,\n\t\t  unsigned char *hash)\n{\n\tconst char *report = \"pack\";\n\tstruct strbuf pack_name = STRBUF_INIT;\n\tstruct strbuf index_name = STRBUF_INIT;\n\tstruct strbuf rev_index_name = STRBUF_INIT;\n\tint err;\n\n\tif (!from_stdin) {\n\t\tclose(input_fd);\n\t} else {\n\t\tfsync_component_or_die(FSYNC_COMPONENT_PACK, output_fd, curr_pack_name);\n\t\terr = close(output_fd);\n\t\tif (err)\n\t\t\tdie_errno(_(\"error while closing pack file\"));\n\t}\n\n\tif (keep_msg)\n\t\twrite_special_file(\"keep\", keep_msg, final_pack_name, hash,\n\t\t\t\t   &report);\n\tif (promisor_msg)\n\t\twrite_special_file(\"promisor\", promisor_msg, final_pack_name,\n\t\t\t\t   hash, NULL);\n\n\trename_tmp_packfile(&final_pack_name, curr_pack_name, &pack_name,\n\t\t\t    hash, \"pack\", from_stdin);\n\tif (curr_rev_index_name)\n\t\trename_tmp_packfile(&final_rev_index_name, curr_rev_index_name,\n\t\t\t\t    &rev_index_name, hash, \"rev\", 1);\n\trename_tmp_packfile(&final_index_name, curr_index_name, &index_name,\n\t\t\t    hash, \"idx\", 1);\n\n\tif (do_fsck_object) {\n\t\tstruct packed_git *p;\n\t\tp = add_packed_git(final_index_name, strlen(final_index_name), 0);\n\t\tif (p)\n\t\t\tinstall_packed_git(the_repository, p);\n\t}\n\n\tif (!from_stdin) {\n\t\tprintf(\"%s\\n\", hash_to_hex(hash));\n\t} else {\n\t\tstruct strbuf buf = STRBUF_INIT;\n\n\t\tstrbuf_addf(&buf, \"%s\\t%s\\n\", report, hash_to_hex(hash));\n\t\twrite_or_die(1, buf.buf, buf.len);\n\t\tstrbuf_release(&buf);\n\n\t\t/*\n\t\t * Let's just mimic git-unpack-objects here and write\n\t\t * the last part of the input buffer to stdout.\n\t\t */\n\t\twhile (input_len) {\n\t\t\terr = xwrite(1, input_buffer + input_offset, input_len);\n\t\t\tif (err <= 0)\n\t\t\t\tbreak;\n\t\t\tinput_len -= err;\n\t\t\tinput_offset += err;\n\t\t}\n\t}\n\n\tstrbuf_release(&rev_index_name);\n\tstrbuf_release(&index_name);\n\tstrbuf_release(&pack_name);\n}\n\nstatic int git_index_pack_config(const char *k, const char *v,\n\t\t\t\t const struct config_context *ctx, void *cb)\n{\n\tstruct pack_idx_option *opts = cb;\n\n\tif (!strcmp(k, \"pack.indexversion\")) {\n\t\topts->version = git_config_int(k, v, ctx->kvi);\n\t\tif (opts->version > 2)\n\t\t\tdie(_(\"bad pack.indexVersion=%\"PRIu32), opts->version);\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"pack.threads\")) {\n\t\tnr_threads = git_config_int(k, v, ctx->kvi);\n\t\tif (nr_threads < 0)\n\t\t\tdie(_(\"invalid number of threads specified (%d)\"),\n\t\t\t    nr_threads);\n\t\tif (!HAVE_THREADS && nr_threads != 1) {\n\t\t\twarning(_(\"no threads support, ignoring %s\"), k);\n\t\t\tnr_threads = 1;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"pack.writereverseindex\")) {\n\t\tif (git_config_bool(k, v))\n\t\t\topts->flags |= WRITE_REV;\n\t\telse\n\t\t\topts->flags &= ~WRITE_REV;\n\t}\n\treturn git_default_config(k, v, ctx, cb);\n}\n\nstatic int cmp_uint32(const void *a_, const void *b_)\n{\n\tuint32_t a = *((uint32_t *)a_);\n\tuint32_t b = *((uint32_t *)b_);\n\n\treturn (a < b) ? -1 : (a != b);\n}\n\nstatic void read_v2_anomalous_offsets(struct packed_git *p,\n\t\t\t\t      struct pack_idx_option *opts)\n{\n\tconst uint32_t *idx1, *idx2;\n\tuint32_t i;\n\n\t/* The address of the 4-byte offset table */\n\tidx1 = (((const uint32_t *)((const uint8_t *)p->index_data + p->crc_offset))\n\t\t+ (size_t)p->num_objects /* CRC32 table */\n\t\t);\n\n\t/* The address of the 8-byte offset table */\n\tidx2 = idx1 + p->num_objects;\n\n\tfor (i = 0; i < p->num_objects; i++) {\n\t\tuint32_t off = ntohl(idx1[i]);\n\t\tif (!(off & 0x80000000))\n\t\t\tcontinue;\n\t\toff = off & 0x7fffffff;\n\t\tcheck_pack_index_ptr(p, &idx2[off * 2]);\n\t\tif (idx2[off * 2])\n\t\t\tcontinue;\n\t\t/*\n\t\t * The real offset is ntohl(idx2[off * 2]) in high 4\n\t\t * octets, and ntohl(idx2[off * 2 + 1]) in low 4\n\t\t * octets.  But idx2[off * 2] is Zero!!!\n\t\t */\n\t\tALLOC_GROW(opts->anomaly, opts->anomaly_nr + 1, opts->anomaly_alloc);\n\t\topts->anomaly[opts->anomaly_nr++] = ntohl(idx2[off * 2 + 1]);\n\t}\n\n\tQSORT(opts->anomaly, opts->anomaly_nr, cmp_uint32);\n}\n\nstatic void read_idx_option(struct pack_idx_option *opts, const char *pack_name)\n{\n\tstruct packed_git *p = add_packed_git(pack_name, strlen(pack_name), 1);\n\n\tif (!p)\n\t\tdie(_(\"Cannot open existing pack file '%s'\"), pack_name);\n\tif (open_pack_index(p))\n\t\tdie(_(\"Cannot open existing pack idx file for '%s'\"), pack_name);\n\n\t/* Read the attributes from the existing idx file */\n\topts->version = p->index_version;\n\n\tif (opts->version == 2)\n\t\tread_v2_anomalous_offsets(p, opts);\n\n\t/*\n\t * Get rid of the idx file as we do not need it anymore.\n\t * NEEDSWORK: extract this bit from free_pack_by_name() in\n\t * object-file.c, perhaps?  It shouldn't matter very much as we\n\t * know we haven't installed this pack (hence we never have\n\t * read anything from it).\n\t */\n\tclose_pack_index(p);\n\tfree(p);\n}\n\nstatic void show_pack_info(int stat_only)\n{\n\tint i, baseobjects = nr_objects - nr_ref_deltas - nr_ofs_deltas;\n\tunsigned long *chain_histogram = NULL;\n\n\tif (deepest_delta)\n\t\tCALLOC_ARRAY(chain_histogram, deepest_delta);\n\n\tfor (i = 0; i < nr_objects; i++) {\n\t\tstruct object_entry *obj = &objects[i];\n\n\t\tif (is_delta_type(obj->type))\n\t\t\tchain_histogram[obj_stat[i].delta_depth - 1]++;\n\t\tif (stat_only)\n\t\t\tcontinue;\n\t\tprintf(\"%s %-6s %\"PRIuMAX\" %\"PRIuMAX\" %\"PRIuMAX,\n\t\t       oid_to_hex(&obj->idx.oid),\n\t\t       type_name(obj->real_type), (uintmax_t)obj->size,\n\t\t       (uintmax_t)(obj[1].idx.offset - obj->idx.offset),\n\t\t       (uintmax_t)obj->idx.offset);\n\t\tif (is_delta_type(obj->type)) {\n\t\t\tstruct object_entry *bobj = &objects[obj_stat[i].base_object_no];\n\t\t\tprintf(\" %u %s\", obj_stat[i].delta_depth,\n\t\t\t       oid_to_hex(&bobj->idx.oid));\n\t\t}\n\t\tputchar('\\n');\n\t}\n\n\tif (baseobjects)\n\t\tprintf_ln(Q_(\"non delta: %d object\",\n\t\t\t     \"non delta: %d objects\",\n\t\t\t     baseobjects),\n\t\t\t  baseobjects);\n\tfor (i = 0; i < deepest_delta; i++) {\n\t\tif (!chain_histogram[i])\n\t\t\tcontinue;\n\t\tprintf_ln(Q_(\"chain length = %d: %lu object\",\n\t\t\t     \"chain length = %d: %lu objects\",\n\t\t\t     chain_histogram[i]),\n\t\t\t  i + 1,\n\t\t\t  chain_histogram[i]);\n\t}\n\tfree(chain_histogram);\n}\n\nint cmd_index_pack(int argc, const char **argv, const char *prefix)\n{\n\tint i, fix_thin_pack = 0, verify = 0, stat_only = 0, rev_index;\n\tconst char *curr_index;\n\tconst char *curr_rev_index = NULL;\n\tconst char *index_name = NULL, *pack_name = NULL, *rev_index_name = NULL;\n\tconst char *keep_msg = NULL;\n\tconst char *promisor_msg = NULL;\n\tstruct strbuf index_name_buf = STRBUF_INIT;\n\tstruct strbuf rev_index_name_buf = STRBUF_INIT;\n\tstruct pack_idx_entry **idx_objects;\n\tstruct pack_idx_option opts;\n\tunsigned char pack_hash[GIT_MAX_RAWSZ];\n\tunsigned foreign_nr = 1;\t/* zero is a \"good\" value, assume bad */\n\tint report_end_of_input = 0;\n\tint hash_algo = 0;\n\n\t/*\n\t * index-pack never needs to fetch missing objects except when\n\t * REF_DELTA bases are missing (which are explicitly handled). It only\n\t * accesses the repo to do hash collision checks and to check which\n\t * REF_DELTA bases need to be fetched.\n\t */\n\tfetch_if_missing = 0;\n\n\tif (argc == 2 && !strcmp(argv[1], \"-h\"))\n\t\tusage(index_pack_usage);\n\n\tdisable_replace_refs();\n\tfsck_options.walk = mark_link;\n\n\treset_pack_idx_option(&opts);\n\topts.flags |= WRITE_REV;\n\tgit_config(git_index_pack_config, &opts);\n\tif (prefix && chdir(prefix))\n\t\tdie(_(\"Cannot come back to cwd\"));\n\n\tif (git_env_bool(GIT_TEST_NO_WRITE_REV_INDEX, 0))\n\t\trev_index = 0;\n\telse\n\t\trev_index = !!(opts.flags & (WRITE_REV_VERIFY | WRITE_REV));\n\n\tfor (i = 1; i < argc; i++) {\n\t\tconst char *arg = argv[i];\n\n\t\tif (*arg == '-') {\n\t\t\tif (!strcmp(arg, \"--stdin\")) {\n\t\t\t\tfrom_stdin = 1;\n\t\t\t} else if (!strcmp(arg, \"--fix-thin\")) {\n\t\t\t\tfix_thin_pack = 1;\n\t\t\t} else if (skip_to_optional_arg(arg, \"--strict\", &arg)) {\n\t\t\t\tstrict = 1;\n\t\t\t\tdo_fsck_object = 1;\n\t\t\t\tfsck_set_msg_types(&fsck_options, arg);\n\t\t\t} else if (!strcmp(arg, \"--check-self-contained-and-connected\")) {\n\t\t\t\tstrict = 1;\n\t\t\t\tcheck_self_contained_and_connected = 1;\n\t\t\t} else if (!strcmp(arg, \"--fsck-objects\")) {\n\t\t\t\tdo_fsck_object = 1;\n\t\t\t} else if (!strcmp(arg, \"--verify\")) {\n\t\t\t\tverify = 1;\n\t\t\t} else if (!strcmp(arg, \"--verify-stat\")) {\n\t\t\t\tverify = 1;\n\t\t\t\tshow_stat = 1;\n\t\t\t} else if (!strcmp(arg, \"--verify-stat-only\")) {\n\t\t\t\tverify = 1;\n\t\t\t\tshow_stat = 1;\n\t\t\t\tstat_only = 1;\n\t\t\t} else if (skip_to_optional_arg(arg, \"--keep\", &keep_msg)) {\n\t\t\t\t; /* nothing to do */\n\t\t\t} else if (skip_to_optional_arg(arg, \"--promisor\", &promisor_msg)) {\n\t\t\t\t; /* already parsed */\n\t\t\t} else if (starts_with(arg, \"--threads=\")) {\n\t\t\t\tchar *end;\n\t\t\t\tnr_threads = strtoul(arg+10, &end, 0);\n\t\t\t\tif (!arg[10] || *end || nr_threads < 0)\n\t\t\t\t\tusage(index_pack_usage);\n\t\t\t\tif (!HAVE_THREADS && nr_threads != 1) {\n\t\t\t\t\twarning(_(\"no threads support, ignoring %s\"), arg);\n\t\t\t\t\tnr_threads = 1;\n\t\t\t\t}\n\t\t\t} else if (starts_with(arg, \"--pack_header=\")) {\n\t\t\t\tstruct pack_header *hdr;\n\t\t\t\tchar *c;\n\n\t\t\t\thdr = (struct pack_header *)input_buffer;\n\t\t\t\thdr->hdr_signature = htonl(PACK_SIGNATURE);\n\t\t\t\thdr->hdr_version = htonl(strtoul(arg + 14, &c, 10));\n\t\t\t\tif (*c != ',')\n\t\t\t\t\tdie(_(\"bad %s\"), arg);\n\t\t\t\thdr->hdr_entries = htonl(strtoul(c + 1, &c, 10));\n\t\t\t\tif (*c)\n\t\t\t\t\tdie(_(\"bad %s\"), arg);\n\t\t\t\tinput_len = sizeof(*hdr);\n\t\t\t} else if (!strcmp(arg, \"-v\")) {\n\t\t\t\tverbose = 1;\n\t\t\t} else if (!strcmp(arg, \"--progress-title\")) {\n\t\t\t\tif (progress_title || (i+1) >= argc)\n\t\t\t\t\tusage(index_pack_usage);\n\t\t\t\tprogress_title = argv[++i];\n\t\t\t} else if (!strcmp(arg, \"--show-resolving-progress\")) {\n\t\t\t\tshow_resolving_progress = 1;\n\t\t\t} else if (!strcmp(arg, \"--report-end-of-input\")) {\n\t\t\t\treport_end_of_input = 1;\n\t\t\t} else if (!strcmp(arg, \"-o\")) {\n\t\t\t\tif (index_name || (i+1) >= argc)\n\t\t\t\t\tusage(index_pack_usage);\n\t\t\t\tindex_name = argv[++i];\n\t\t\t} else if (starts_with(arg, \"--index-version=\")) {\n\t\t\t\tchar *c;\n\t\t\t\topts.version = strtoul(arg + 16, &c, 10);\n\t\t\t\tif (opts.version > 2)\n\t\t\t\t\tdie(_(\"bad %s\"), arg);\n\t\t\t\tif (*c == ',')\n\t\t\t\t\topts.off32_limit = strtoul(c+1, &c, 0);\n\t\t\t\tif (*c || opts.off32_limit & 0x80000000)\n\t\t\t\t\tdie(_(\"bad %s\"), arg);\n\t\t\t} else if (skip_prefix(arg, \"--max-input-size=\", &arg)) {\n\t\t\t\tmax_input_size = strtoumax(arg, NULL, 10);\n\t\t\t} else if (skip_prefix(arg, \"--object-format=\", &arg)) {\n\t\t\t\thash_algo = hash_algo_by_name(arg);\n\t\t\t\tif (hash_algo == GIT_HASH_UNKNOWN)\n\t\t\t\t\tdie(_(\"unknown hash algorithm '%s'\"), arg);\n\t\t\t\trepo_set_hash_algo(the_repository, hash_algo);\n\t\t\t} else if (!strcmp(arg, \"--rev-index\")) {\n\t\t\t\trev_index = 1;\n\t\t\t} else if (!strcmp(arg, \"--no-rev-index\")) {\n\t\t\t\trev_index = 0;\n\t\t\t} else\n\t\t\t\tusage(index_pack_usage);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pack_name)\n\t\t\tusage(index_pack_usage);\n\t\tpack_name = arg;\n\t}\n\n\tif (!pack_name && !from_stdin)\n\t\tusage(index_pack_usage);\n\tif (fix_thin_pack && !from_stdin)\n\t\tdie(_(\"the option '%s' requires '%s'\"), \"--fix-thin\", \"--stdin\");\n\tif (from_stdin && !startup_info->have_repository)\n\t\tdie(_(\"--stdin requires a git repository\"));\n\tif (from_stdin && hash_algo)\n\t\tdie(_(\"options '%s' and '%s' cannot be used together\"), \"--object-format\", \"--stdin\");\n\tif (!index_name && pack_name)\n\t\tindex_name = derive_filename(pack_name, \"pack\", \"idx\", &index_name_buf);\n\n\topts.flags &= ~(WRITE_REV | WRITE_REV_VERIFY);\n\tif (rev_index) {\n\t\topts.flags |= verify ? WRITE_REV_VERIFY : WRITE_REV;\n\t\tif (index_name)\n\t\t\trev_index_name = derive_filename(index_name,\n\t\t\t\t\t\t\t \"idx\", \"rev\",\n\t\t\t\t\t\t\t &rev_index_name_buf);\n\t}\n\n\tif (verify) {\n\t\tif (!index_name)\n\t\t\tdie(_(\"--verify with no packfile name given\"));\n\t\tread_idx_option(&opts, index_name);\n\t\topts.flags |= WRITE_IDX_VERIFY | WRITE_IDX_STRICT;\n\t}\n\tif (strict)\n\t\topts.flags |= WRITE_IDX_STRICT;\n\n\tif (HAVE_THREADS && !nr_threads) {\n\t\tnr_threads = online_cpus();\n\t\t/*\n\t\t * Experiments show that going above 20 threads doesn't help,\n\t\t * no matter how many cores you have. Below that, we tend to\n\t\t * max at half the number of online_cpus(), presumably because\n\t\t * half of those are hyperthreads rather than full cores. We'll\n\t\t * never reduce the level below \"3\", though, to match a\n\t\t * historical value that nobody complained about.\n\t\t */\n\t\tif (nr_threads < 4)\n\t\t\t; /* too few cores to consider capping */\n\t\telse if (nr_threads < 6)\n\t\t\tnr_threads = 3; /* historic cap */\n\t\telse if (nr_threads < 40)\n\t\t\tnr_threads /= 2;\n\t\telse\n\t\t\tnr_threads = 20; /* hard cap */\n\t}\n\n\tcurr_pack = open_pack_file(pack_name);\n\tparse_pack_header();\n\tCALLOC_ARRAY(objects, st_add(nr_objects, 1));\n\tif (show_stat)\n\t\tCALLOC_ARRAY(obj_stat, st_add(nr_objects, 1));\n\tCALLOC_ARRAY(ofs_deltas, nr_objects);\n\tparse_pack_objects(pack_hash);\n\tif (report_end_of_input)\n\t\twrite_in_full(2, \"\\0\", 1);\n\tresolve_deltas();\n\tconclude_pack(fix_thin_pack, curr_pack, pack_hash);\n\tfree(ofs_deltas);\n\tfree(ref_deltas);\n\tif (strict)\n\t\tforeign_nr = check_objects();\n\n\tif (show_stat)\n\t\tshow_pack_info(stat_only);\n\n\tALLOC_ARRAY(idx_objects, nr_objects);\n\tfor (i = 0; i < nr_objects; i++)\n\t\tidx_objects[i] = &objects[i].idx;\n\tcurr_index = write_idx_file(index_name, idx_objects, nr_objects, &opts, pack_hash);\n\tif (rev_index)\n\t\tcurr_rev_index = write_rev_file(rev_index_name, idx_objects,\n\t\t\t\t\t\tnr_objects, pack_hash,\n\t\t\t\t\t\topts.flags);\n\tfree(idx_objects);\n\n\tif (!verify)\n\t\tfinal(pack_name, curr_pack,\n\t\t      index_name, curr_index,\n\t\t      rev_index_name, curr_rev_index,\n\t\t      keep_msg, promisor_msg,\n\t\t      pack_hash);\n\telse\n\t\tclose(input_fd);\n\n\tif (do_fsck_object && fsck_finish(&fsck_options))\n\t\tdie(_(\"fsck error in pack objects\"));\n\n\tfree(opts.anomaly);\n\tfree(objects);\n\tstrbuf_release(&index_name_buf);\n\tstrbuf_release(&rev_index_name_buf);\n\tif (!pack_name)\n\t\tfree((void *) curr_pack);\n\tif (!index_name)\n\t\tfree((void *) curr_index);\n\tif (!rev_index_name)\n\t\tfree((void *) curr_rev_index);\n\n\t/*\n\t * Let the caller know this pack is not self contained\n\t */\n\tif (check_self_contained_and_connected && foreign_nr)\n\t\treturn 1;\n\n\treturn 0;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "006ffdc9c550d75a034960635f13d87b33dc57cc",
  "sha1_ok": true,
  "size": 53544
}
