{
  "content": {
    "base64": "LyoKICogImdpdCBmZXRjaCIKICovCiNpbmNsdWRlICJjYWNoZS5oIgojaW5jbHVkZSAicmVmcy5oIgojaW5jbHVkZSAiY29tbWl0LmgiCiNpbmNsdWRlICJidWlsdGluLmgiCiNpbmNsdWRlICJzdHJpbmctbGlzdC5oIgojaW5jbHVkZSAicmVtb3RlLmgiCiNpbmNsdWRlICJ0cmFuc3BvcnQuaCIKI2luY2x1ZGUgInJ1bi1jb21tYW5kLmgiCiNpbmNsdWRlICJwYXJzZS1vcHRpb25zLmgiCiNpbmNsdWRlICJzaWdjaGFpbi5oIgoKc3RhdGljIGNvbnN0IGNoYXIgKiBjb25zdCBidWlsdGluX2ZldGNoX3VzYWdlW10gPSB7CgkiZ2l0IGZldGNoIFs8b3B0aW9ucz5dIFs8cmVwb3NpdG9yeT4gWzxyZWZzcGVjPi4uLl1dIiwKCSJnaXQgZmV0Y2ggWzxvcHRpb25zPl0gPGdyb3VwPiIsCgkiZ2l0IGZldGNoIC0tbXVsdGlwbGUgWzxvcHRpb25zPl0gWzxyZXBvc2l0b3J5PiB8IDxncm91cD5dLi4uIiwKCSJnaXQgZmV0Y2ggLS1hbGwgWzxvcHRpb25zPl0iLAoJTlVMTAp9OwoKZW51bSB7CglUQUdTX1VOU0VUID0gMCwKCVRBR1NfREVGQVVMVCA9IDEsCglUQUdTX1NFVCA9IDIKfTsKCnN0YXRpYyBpbnQgYWxsLCBhcHBlbmQsIGRyeV9ydW4sIGZvcmNlLCBrZWVwLCBtdWx0aXBsZSwgcHJ1bmUsIHVwZGF0ZV9oZWFkX29rLCB2ZXJib3NpdHk7CnN0YXRpYyBpbnQgdGFncyA9IFRBR1NfREVGQVVMVDsKc3RhdGljIGNvbnN0IGNoYXIgKmRlcHRoOwpzdGF0aWMgY29uc3QgY2hhciAqdXBsb2FkX3BhY2s7CnN0YXRpYyBzdHJ1Y3Qgc3RyYnVmIGRlZmF1bHRfcmxhID0gU1RSQlVGX0lOSVQ7CnN0YXRpYyBzdHJ1Y3QgdHJhbnNwb3J0ICp0cmFuc3BvcnQ7CgpzdGF0aWMgc3RydWN0IG9wdGlvbiBidWlsdGluX2ZldGNoX29wdGlvbnNbXSA9IHsKCU9QVF9fVkVSQk9TSVRZKCZ2ZXJib3NpdHkpLAoJT1BUX0JPT0xFQU4oMCwgImFsbCIsICZhbGwsCgkJICAgICJmZXRjaCBmcm9tIGFsbCByZW1vdGVzIiksCglPUFRfQk9PTEVBTignYScsICJhcHBlbmQiLCAmYXBwZW5kLAoJCSAgICAiYXBwZW5kIHRvIC5naXQvRkVUQ0hfSEVBRCBpbnN0ZWFkIG9mIG92ZXJ3cml0aW5nIiksCglPUFRfU1RSSU5HKDAsICJ1cGxvYWQtcGFjayIsICZ1cGxvYWRfcGFjaywgIlBBVEgiLAoJCSAgICJwYXRoIHRvIHVwbG9hZCBwYWNrIG9uIHJlbW90ZSBlbmQiKSwKCU9QVF9CT09MRUFOKCdmJywgImZvcmNlIiwgJmZvcmNlLAoJCSAgICAiZm9yY2Ugb3ZlcndyaXRlIG9mIGxvY2FsIGJyYW5jaCIpLAoJT1BUX0JPT0xFQU4oJ20nLCAibXVsdGlwbGUiLCAmbXVsdGlwbGUsCgkJICAgICJmZXRjaCBmcm9tIG11bHRpcGxlIHJlbW90ZXMiKSwKCU9QVF9TRVRfSU5UKCd0JywgInRhZ3MiLCAmdGFncywKCQkgICAgImZldGNoIGFsbCB0YWdzIGFuZCBhc3NvY2lhdGVkIG9iamVjdHMiLCBUQUdTX1NFVCksCglPUFRfU0VUX0lOVCgnbicsIE5VTEwsICZ0YWdzLAoJCSAgICAiZG8gbm90IGZldGNoIGFsbCB0YWdzICgtLW5vLXRhZ3MpIiwgVEFHU19VTlNFVCksCglPUFRfQk9PTEVBTigncCcsICJwcnVuZSIsICZwcnVuZSwKCQkgICAgInBydW5lIHRyYWNraW5nIGJyYW5jaGVzIG5vIGxvbmdlciBvbiByZW1vdGUiKSwKCU9QVF9CT09MRUFOKDAsICJkcnktcnVuIiwgJmRyeV9ydW4sCgkJICAgICJkcnkgcnVuIiksCglPUFRfQk9PTEVBTignaycsICJrZWVwIiwgJmtlZXAsICJrZWVwIGRvd25sb2FkZWQgcGFjayIpLAoJT1BUX0JPT0xFQU4oJ3UnLCAidXBkYXRlLWhlYWQtb2siLCAmdXBkYXRlX2hlYWRfb2ssCgkJICAgICJhbGxvdyB1cGRhdGluZyBvZiBIRUFEIHJlZiIpLAoJT1BUX1NUUklORygwLCAiZGVwdGgiLCAmZGVwdGgsICJERVBUSCIsCgkJICAgImRlZXBlbiBoaXN0b3J5IG9mIHNoYWxsb3cgY2xvbmUiKSwKCU9QVF9FTkQoKQp9OwoKc3RhdGljIHZvaWQgdW5sb2NrX3BhY2sodm9pZCkKewoJaWYgKHRyYW5zcG9ydCkKCQl0cmFuc3BvcnRfdW5sb2NrX3BhY2sodHJhbnNwb3J0KTsKfQoKc3RhdGljIHZvaWQgdW5sb2NrX3BhY2tfb25fc2lnbmFsKGludCBzaWdubykKewoJdW5sb2NrX3BhY2soKTsKCXNpZ2NoYWluX3BvcChzaWdubyk7CglyYWlzZShzaWdubyk7Cn0KCnN0YXRpYyB2b2lkIGFkZF9tZXJnZV9jb25maWcoc3RydWN0IHJlZiAqKmhlYWQsCgkJCSAgIGNvbnN0IHN0cnVjdCByZWYgKnJlbW90ZV9yZWZzLAoJCSAgICAgICAgICAgc3RydWN0IGJyYW5jaCAqYnJhbmNoLAoJCSAgICAgICAgICAgc3RydWN0IHJlZiAqKip0YWlsKQp7CglpbnQgaTsKCglmb3IgKGkgPSAwOyBpIDwgYnJhbmNoLT5tZXJnZV9ucjsgaSsrKSB7CgkJc3RydWN0IHJlZiAqcm0sICoqb2xkX3RhaWwgPSAqdGFpbDsKCQlzdHJ1Y3QgcmVmc3BlYyByZWZzcGVjOwoKCQlmb3IgKHJtID0gKmhlYWQ7IHJtOyBybSA9IHJtLT5uZXh0KSB7CgkJCWlmIChicmFuY2hfbWVyZ2VfbWF0Y2hlcyhicmFuY2gsIGksIHJtLT5uYW1lKSkgewoJCQkJcm0tPm1lcmdlID0gMTsKCQkJCWJyZWFrOwoJCQl9CgkJfQoJCWlmIChybSkKCQkJY29udGludWU7CgoJCS8qCgkJICogTm90IGZldGNoZWQgdG8gYSB0cmFja2luZyBicmFuY2g/ICBXZSBuZWVkIHRvIGZldGNoCgkJICogaXQgYW55d2F5IHRvIGFsbG93IHRoaXMgYnJhbmNoJ3MgImJyYW5jaC4kbmFtZS5tZXJnZSIKCQkgKiB0byBiZSBob25vcmVkIGJ5ICdnaXQgcHVsbCcsIGJ1dCB3ZSBkbyBub3QgaGF2ZSB0bwoJCSAqIGZhaWwgaWYgYnJhbmNoLiRuYW1lLm1lcmdlIGlzIG1pc2NvbmZpZ3VyZWQgdG8gcG9pbnQKCQkgKiBhdCBhIG5vbmV4aXN0aW5nIGJyYW5jaC4gIElmIHdlIHdlcmUgaW5kZWVkIGNhbGxlZCBieQoJCSAqICdnaXQgcHVsbCcsIGl0IHdpbGwgbm90aWNlIHRoZSBtaXNjb25maWd1cmF0aW9uIGJlY2F1c2UKCQkgKiB0aGVyZSBpcyBubyBlbnRyeSBpbiB0aGUgcmVzdWx0aW5nIEZFVENIX0hFQUQgbWFya2VkCgkJICogZm9yIG1lcmdpbmcuCgkJICovCgkJbWVtc2V0KCZyZWZzcGVjLCAwLCBzaXplb2YocmVmc3BlYykpOwoJCXJlZnNwZWMuc3JjID0gYnJhbmNoLT5tZXJnZVtpXS0+c3JjOwoJCWdldF9mZXRjaF9tYXAocmVtb3RlX3JlZnMsICZyZWZzcGVjLCB0YWlsLCAxKTsKCQlmb3IgKHJtID0gKm9sZF90YWlsOyBybTsgcm0gPSBybS0+bmV4dCkKCQkJcm0tPm1lcmdlID0gMTsKCX0KfQoKc3RhdGljIHZvaWQgZmluZF9ub25fbG9jYWxfdGFncyhzdHJ1Y3QgdHJhbnNwb3J0ICp0cmFuc3BvcnQsCgkJCXN0cnVjdCByZWYgKipoZWFkLAoJCQlzdHJ1Y3QgcmVmICoqKnRhaWwpOwoKc3RhdGljIHN0cnVjdCByZWYgKmdldF9yZWZfbWFwKHN0cnVjdCB0cmFuc3BvcnQgKnRyYW5zcG9ydCwKCQkJICAgICAgIHN0cnVjdCByZWZzcGVjICpyZWZzLCBpbnQgcmVmX2NvdW50LCBpbnQgdGFncywKCQkJICAgICAgIGludCAqYXV0b3RhZ3MpCnsKCWludCBpOwoJc3RydWN0IHJlZiAqcm07CglzdHJ1Y3QgcmVmICpyZWZfbWFwID0gTlVMTDsKCXN0cnVjdCByZWYgKip0YWlsID0gJnJlZl9tYXA7CgoJY29uc3Qgc3RydWN0IHJlZiAqcmVtb3RlX3JlZnMgPSB0cmFuc3BvcnRfZ2V0X3JlbW90ZV9yZWZzKHRyYW5zcG9ydCk7CgoJaWYgKHJlZl9jb3VudCB8fCB0YWdzID09IFRBR1NfU0VUKSB7CgkJZm9yIChpID0gMDsgaSA8IHJlZl9jb3VudDsgaSsrKSB7CgkJCWdldF9mZXRjaF9tYXAocmVtb3RlX3JlZnMsICZyZWZzW2ldLCAmdGFpbCwgMCk7CgkJCWlmIChyZWZzW2ldLmRzdCAmJiByZWZzW2ldLmRzdFswXSkKCQkJCSphdXRvdGFncyA9IDE7CgkJfQoJCS8qIE1lcmdlIGV2ZXJ5dGhpbmcgb24gdGhlIGNvbW1hbmQgbGluZSwgYnV0IG5vdCAtLXRhZ3MgKi8KCQlmb3IgKHJtID0gcmVmX21hcDsgcm07IHJtID0gcm0tPm5leHQpCgkJCXJtLT5tZXJnZSA9IDE7CgkJaWYgKHRhZ3MgPT0gVEFHU19TRVQpCgkJCWdldF9mZXRjaF9tYXAocmVtb3RlX3JlZnMsIHRhZ19yZWZzcGVjLCAmdGFpbCwgMCk7Cgl9IGVsc2UgewoJCS8qIFVzZSB0aGUgZGVmYXVsdHMgKi8KCQlzdHJ1Y3QgcmVtb3RlICpyZW1vdGUgPSB0cmFuc3BvcnQtPnJlbW90ZTsKCQlzdHJ1Y3QgYnJhbmNoICpicmFuY2ggPSBicmFuY2hfZ2V0KE5VTEwpOwoJCWludCBoYXNfbWVyZ2UgPSBicmFuY2hfaGFzX21lcmdlX2NvbmZpZyhicmFuY2gpOwoJCWlmIChyZW1vdGUgJiYgKHJlbW90ZS0+ZmV0Y2hfcmVmc3BlY19uciB8fCBoYXNfbWVyZ2UpKSB7CgkJCWZvciAoaSA9IDA7IGkgPCByZW1vdGUtPmZldGNoX3JlZnNwZWNfbnI7IGkrKykgewoJCQkJZ2V0X2ZldGNoX21hcChyZW1vdGVfcmVmcywgJnJlbW90ZS0+ZmV0Y2hbaV0sICZ0YWlsLCAwKTsKCQkJCWlmIChyZW1vdGUtPmZldGNoW2ldLmRzdCAmJgoJCQkJICAgIHJlbW90ZS0+ZmV0Y2hbaV0uZHN0WzBdKQoJCQkJCSphdXRvdGFncyA9IDE7CgkJCQlpZiAoIWkgJiYgIWhhc19tZXJnZSAmJiByZWZfbWFwICYmCgkJCQkgICAgIXJlbW90ZS0+ZmV0Y2hbMF0ucGF0dGVybikKCQkJCQlyZWZfbWFwLT5tZXJnZSA9IDE7CgkJCX0KCQkJLyoKCQkJICogaWYgdGhlIHJlbW90ZSB3ZSdyZSBmZXRjaGluZyBmcm9tIGlzIHRoZSBzYW1lCgkJCSAqIGFzIGdpdmVuIGluIGJyYW5jaC48bmFtZT4ucmVtb3RlLCB3ZSBhZGQgdGhlCgkJCSAqIHJlZiBnaXZlbiBpbiBicmFuY2guPG5hbWU+Lm1lcmdlLCB0b28uCgkJCSAqLwoJCQlpZiAoaGFzX21lcmdlICYmCgkJCSAgICAhc3RyY21wKGJyYW5jaC0+cmVtb3RlX25hbWUsIHJlbW90ZS0+bmFtZSkpCgkJCQlhZGRfbWVyZ2VfY29uZmlnKCZyZWZfbWFwLCByZW1vdGVfcmVmcywgYnJhbmNoLCAmdGFpbCk7CgkJfSBlbHNlIHsKCQkJcmVmX21hcCA9IGdldF9yZW1vdGVfcmVmKHJlbW90ZV9yZWZzLCAiSEVBRCIpOwoJCQlpZiAoIXJlZl9tYXApCgkJCQlkaWUoIkNvdWxkbid0IGZpbmQgcmVtb3RlIHJlZiBIRUFEIik7CgkJCXJlZl9tYXAtPm1lcmdlID0gMTsKCQkJdGFpbCA9ICZyZWZfbWFwLT5uZXh0OwoJCX0KCX0KCWlmICh0YWdzID09IFRBR1NfREVGQVVMVCAmJiAqYXV0b3RhZ3MpCgkJZmluZF9ub25fbG9jYWxfdGFncyh0cmFuc3BvcnQsICZyZWZfbWFwLCAmdGFpbCk7CglyZWZfcmVtb3ZlX2R1cGxpY2F0ZXMocmVmX21hcCk7CgoJcmV0dXJuIHJlZl9tYXA7Cn0KCiNkZWZpbmUgU1RPUkVfUkVGX0VSUk9SX09USEVSIDEKI2RlZmluZSBTVE9SRV9SRUZfRVJST1JfREZfQ09ORkxJQ1QgMgoKc3RhdGljIGludCBzX3VwZGF0ZV9yZWYoY29uc3QgY2hhciAqYWN0aW9uLAoJCQlzdHJ1Y3QgcmVmICpyZWYsCgkJCWludCBjaGVja19vbGQpCnsKCWNoYXIgbXNnWzEwMjRdOwoJY2hhciAqcmxhID0gZ2V0ZW52KCJHSVRfUkVGTE9HX0FDVElPTiIpOwoJc3RhdGljIHN0cnVjdCByZWZfbG9jayAqbG9jazsKCglpZiAoZHJ5X3J1bikKCQlyZXR1cm4gMDsKCWlmICghcmxhKQoJCXJsYSA9IGRlZmF1bHRfcmxhLmJ1ZjsKCXNucHJpbnRmKG1zZywgc2l6ZW9mKG1zZyksICIlczogJXMiLCBybGEsIGFjdGlvbik7Cglsb2NrID0gbG9ja19hbnlfcmVmX2Zvcl91cGRhdGUocmVmLT5uYW1lLAoJCQkJICAgICAgIGNoZWNrX29sZCA/IHJlZi0+b2xkX3NoYTEgOiBOVUxMLCAwKTsKCWlmICghbG9jaykKCQlyZXR1cm4gZXJybm8gPT0gRU5PVERJUiA/IFNUT1JFX1JFRl9FUlJPUl9ERl9DT05GTElDVCA6CgkJCQkJICBTVE9SRV9SRUZfRVJST1JfT1RIRVI7CglpZiAod3JpdGVfcmVmX3NoYTEobG9jaywgcmVmLT5uZXdfc2hhMSwgbXNnKSA8IDApCgkJcmV0dXJuIGVycm5vID09IEVOT1RESVIgPyBTVE9SRV9SRUZfRVJST1JfREZfQ09ORkxJQ1QgOgoJCQkJCSAgU1RPUkVfUkVGX0VSUk9SX09USEVSOwoJcmV0dXJuIDA7Cn0KCiNkZWZpbmUgU1VNTUFSWV9XSURUSCAoMiAqIERFRkFVTFRfQUJCUkVWICsgMykKI2RlZmluZSBSRUZDT0xfV0lEVEggIDEwCgpzdGF0aWMgaW50IHVwZGF0ZV9sb2NhbF9yZWYoc3RydWN0IHJlZiAqcmVmLAoJCQkgICAgY29uc3QgY2hhciAqcmVtb3RlLAoJCQkgICAgY2hhciAqZGlzcGxheSkKewoJc3RydWN0IGNvbW1pdCAqY3VycmVudCA9IE5VTEwsICp1cGRhdGVkOwoJZW51bSBvYmplY3RfdHlwZSB0eXBlOwoJc3RydWN0IGJyYW5jaCAqY3VycmVudF9icmFuY2ggPSBicmFuY2hfZ2V0KE5VTEwpOwoJY29uc3QgY2hhciAqcHJldHR5X3JlZiA9IHByZXR0aWZ5X3JlZm5hbWUocmVmLT5uYW1lKTsKCgkqZGlzcGxheSA9IDA7Cgl0eXBlID0gc2hhMV9vYmplY3RfaW5mbyhyZWYtPm5ld19zaGExLCBOVUxMKTsKCWlmICh0eXBlIDwgMCkKCQlkaWUoIm9iamVjdCAlcyBub3QgZm91bmQiLCBzaGExX3RvX2hleChyZWYtPm5ld19zaGExKSk7CgoJaWYgKCFoYXNoY21wKHJlZi0+b2xkX3NoYTEsIHJlZi0+bmV3X3NoYTEpKSB7CgkJaWYgKHZlcmJvc2l0eSA+IDApCgkJCXNwcmludGYoZGlzcGxheSwgIj0gJS0qcyAlLSpzIC0+ICVzIiwgU1VNTUFSWV9XSURUSCwKCQkJCSJbdXAgdG8gZGF0ZV0iLCBSRUZDT0xfV0lEVEgsIHJlbW90ZSwKCQkJCXByZXR0eV9yZWYpOwoJCXJldHVybiAwOwoJfQoKCWlmIChjdXJyZW50X2JyYW5jaCAmJgoJICAgICFzdHJjbXAocmVmLT5uYW1lLCBjdXJyZW50X2JyYW5jaC0+bmFtZSkgJiYKCSAgICAhKHVwZGF0ZV9oZWFkX29rIHx8IGlzX2JhcmVfcmVwb3NpdG9yeSgpKSAmJgoJICAgICFpc19udWxsX3NoYTEocmVmLT5vbGRfc2hhMSkpIHsKCQkvKgoJCSAqIElmIHRoaXMgaXMgdGhlIGhlYWQsIGFuZCBpdCdzIG5vdCBva2F5IHRvIHVwZGF0ZQoJCSAqIHRoZSBoZWFkLCBhbmQgdGhlIG9sZCB2YWx1ZSBvZiB0aGUgaGVhZCBpc24ndCBlbXB0eS4uLgoJCSAqLwoJCXNwcmludGYoZGlzcGxheSwgIiEgJS0qcyAlLSpzIC0+ICVzICAoY2FuJ3QgZmV0Y2ggaW4gY3VycmVudCBicmFuY2gpIiwKCQkJU1VNTUFSWV9XSURUSCwgIltyZWplY3RlZF0iLCBSRUZDT0xfV0lEVEgsIHJlbW90ZSwKCQkJcHJldHR5X3JlZik7CgkJcmV0dXJuIDE7Cgl9CgoJaWYgKCFpc19udWxsX3NoYTEocmVmLT5vbGRfc2hhMSkgJiYKCSAgICAhcHJlZml4Y21wKHJlZi0+bmFtZSwgInJlZnMvdGFncy8iKSkgewoJCWludCByOwoJCXIgPSBzX3VwZGF0ZV9yZWYoInVwZGF0aW5nIHRhZyIsIHJlZiwgMCk7CgkJc3ByaW50ZihkaXNwbGF5LCAiJWMgJS0qcyAlLSpzIC0+ICVzJXMiLCByID8gJyEnIDogJy0nLAoJCQlTVU1NQVJZX1dJRFRILCAiW3RhZyB1cGRhdGVdIiwgUkVGQ09MX1dJRFRILCByZW1vdGUsCgkJCXByZXR0eV9yZWYsIHIgPyAiICAodW5hYmxlIHRvIHVwZGF0ZSBsb2NhbCByZWYpIiA6ICIiKTsKCQlyZXR1cm4gcjsKCX0KCgljdXJyZW50ID0gbG9va3VwX2NvbW1pdF9yZWZlcmVuY2VfZ2VudGx5KHJlZi0+b2xkX3NoYTEsIDEpOwoJdXBkYXRlZCA9IGxvb2t1cF9jb21taXRfcmVmZXJlbmNlX2dlbnRseShyZWYtPm5ld19zaGExLCAxKTsKCWlmICghY3VycmVudCB8fCAhdXBkYXRlZCkgewoJCWNvbnN0IGNoYXIgKm1zZzsKCQljb25zdCBjaGFyICp3aGF0OwoJCWludCByOwoJCWlmICghc3RybmNtcChyZWYtPm5hbWUsICJyZWZzL3RhZ3MvIiwgMTApKSB7CgkJCW1zZyA9ICJzdG9yaW5nIHRhZyI7CgkJCXdoYXQgPSAiW25ldyB0YWddIjsKCQl9CgkJZWxzZSB7CgkJCW1zZyA9ICJzdG9yaW5nIGhlYWQiOwoJCQl3aGF0ID0gIltuZXcgYnJhbmNoXSI7CgkJfQoKCQlyID0gc191cGRhdGVfcmVmKG1zZywgcmVmLCAwKTsKCQlzcHJpbnRmKGRpc3BsYXksICIlYyAlLSpzICUtKnMgLT4gJXMlcyIsIHIgPyAnIScgOiAnKicsCgkJCVNVTU1BUllfV0lEVEgsIHdoYXQsIFJFRkNPTF9XSURUSCwgcmVtb3RlLCBwcmV0dHlfcmVmLAoJCQlyID8gIiAgKHVuYWJsZSB0byB1cGRhdGUgbG9jYWwgcmVmKSIgOiAiIik7CgkJcmV0dXJuIHI7Cgl9CgoJaWYgKGluX21lcmdlX2Jhc2VzKGN1cnJlbnQsICZ1cGRhdGVkLCAxKSkgewoJCWNoYXIgcXVpY2tyZWZbODNdOwoJCWludCByOwoJCXN0cmNweShxdWlja3JlZiwgZmluZF91bmlxdWVfYWJicmV2KGN1cnJlbnQtPm9iamVjdC5zaGExLCBERUZBVUxUX0FCQlJFVikpOwoJCXN0cmNhdChxdWlja3JlZiwgIi4uIik7CgkJc3RyY2F0KHF1aWNrcmVmLCBmaW5kX3VuaXF1ZV9hYmJyZXYocmVmLT5uZXdfc2hhMSwgREVGQVVMVF9BQkJSRVYpKTsKCQlyID0gc191cGRhdGVfcmVmKCJmYXN0LWZvcndhcmQiLCByZWYsIDEpOwoJCXNwcmludGYoZGlzcGxheSwgIiVjICUtKnMgJS0qcyAtPiAlcyVzIiwgciA/ICchJyA6ICcgJywKCQkJU1VNTUFSWV9XSURUSCwgcXVpY2tyZWYsIFJFRkNPTF9XSURUSCwgcmVtb3RlLAoJCQlwcmV0dHlfcmVmLCByID8gIiAgKHVuYWJsZSB0byB1cGRhdGUgbG9jYWwgcmVmKSIgOiAiIik7CgkJcmV0dXJuIHI7Cgl9IGVsc2UgaWYgKGZvcmNlIHx8IHJlZi0+Zm9yY2UpIHsKCQljaGFyIHF1aWNrcmVmWzg0XTsKCQlpbnQgcjsKCQlzdHJjcHkocXVpY2tyZWYsIGZpbmRfdW5pcXVlX2FiYnJldihjdXJyZW50LT5vYmplY3Quc2hhMSwgREVGQVVMVF9BQkJSRVYpKTsKCQlzdHJjYXQocXVpY2tyZWYsICIuLi4iKTsKCQlzdHJjYXQocXVpY2tyZWYsIGZpbmRfdW5pcXVlX2FiYnJldihyZWYtPm5ld19zaGExLCBERUZBVUxUX0FCQlJFVikpOwoJCXIgPSBzX3VwZGF0ZV9yZWYoImZvcmNlZC11cGRhdGUiLCByZWYsIDEpOwoJCXNwcmludGYoZGlzcGxheSwgIiVjICUtKnMgJS0qcyAtPiAlcyAgKCVzKSIsIHIgPyAnIScgOiAnKycsCgkJCVNVTU1BUllfV0lEVEgsIHF1aWNrcmVmLCBSRUZDT0xfV0lEVEgsIHJlbW90ZSwKCQkJcHJldHR5X3JlZiwKCQkJciA/ICJ1bmFibGUgdG8gdXBkYXRlIGxvY2FsIHJlZiIgOiAiZm9yY2VkIHVwZGF0ZSIpOwoJCXJldHVybiByOwoJfSBlbHNlIHsKCQlzcHJpbnRmKGRpc3BsYXksICIhICUtKnMgJS0qcyAtPiAlcyAgKG5vbi1mYXN0LWZvcndhcmQpIiwKCQkJU1VNTUFSWV9XSURUSCwgIltyZWplY3RlZF0iLCBSRUZDT0xfV0lEVEgsIHJlbW90ZSwKCQkJcHJldHR5X3JlZik7CgkJcmV0dXJuIDE7Cgl9Cn0KCnN0YXRpYyBpbnQgc3RvcmVfdXBkYXRlZF9yZWZzKGNvbnN0IGNoYXIgKnJhd191cmwsIGNvbnN0IGNoYXIgKnJlbW90ZV9uYW1lLAoJCXN0cnVjdCByZWYgKnJlZl9tYXApCnsKCUZJTEUgKmZwOwoJc3RydWN0IGNvbW1pdCAqY29tbWl0OwoJaW50IHVybF9sZW4sIGksIG5vdGVfbGVuLCBzaG93bl91cmwgPSAwLCByYyA9IDA7CgljaGFyIG5vdGVbMTAyNF07Cgljb25zdCBjaGFyICp3aGF0LCAqa2luZDsKCXN0cnVjdCByZWYgKnJtOwoJY2hhciAqdXJsLCAqZmlsZW5hbWUgPSBkcnlfcnVuID8gIi9kZXYvbnVsbCIgOiBnaXRfcGF0aCgiRkVUQ0hfSEVBRCIpOwoKCWZwID0gZm9wZW4oZmlsZW5hbWUsICJhIik7CglpZiAoIWZwKQoJCXJldHVybiBlcnJvcigiY2Fubm90IG9wZW4gJXM6ICVzXG4iLCBmaWxlbmFtZSwgc3RyZXJyb3IoZXJybm8pKTsKCglpZiAocmF3X3VybCkKCQl1cmwgPSB0cmFuc3BvcnRfYW5vbnltaXplX3VybChyYXdfdXJsKTsKCWVsc2UKCQl1cmwgPSB4c3RyZHVwKCJmb3JlaWduIik7Cglmb3IgKHJtID0gcmVmX21hcDsgcm07IHJtID0gcm0tPm5leHQpIHsKCQlzdHJ1Y3QgcmVmICpyZWYgPSBOVUxMOwoKCQlpZiAocm0tPnBlZXJfcmVmKSB7CgkJCXJlZiA9IHhjYWxsb2MoMSwgc2l6ZW9mKCpyZWYpICsgc3RybGVuKHJtLT5wZWVyX3JlZi0+bmFtZSkgKyAxKTsKCQkJc3RyY3B5KHJlZi0+bmFtZSwgcm0tPnBlZXJfcmVmLT5uYW1lKTsKCQkJaGFzaGNweShyZWYtPm9sZF9zaGExLCBybS0+cGVlcl9yZWYtPm9sZF9zaGExKTsKCQkJaGFzaGNweShyZWYtPm5ld19zaGExLCBybS0+b2xkX3NoYTEpOwoJCQlyZWYtPmZvcmNlID0gcm0tPnBlZXJfcmVmLT5mb3JjZTsKCQl9CgoJCWNvbW1pdCA9IGxvb2t1cF9jb21taXRfcmVmZXJlbmNlX2dlbnRseShybS0+b2xkX3NoYTEsIDEpOwoJCWlmICghY29tbWl0KQoJCQlybS0+bWVyZ2UgPSAwOwoKCQlpZiAoIXN0cmNtcChybS0+bmFtZSwgIkhFQUQiKSkgewoJCQlraW5kID0gIiI7CgkJCXdoYXQgPSAiIjsKCQl9CgkJZWxzZSBpZiAoIXByZWZpeGNtcChybS0+bmFtZSwgInJlZnMvaGVhZHMvIikpIHsKCQkJa2luZCA9ICJicmFuY2giOwoJCQl3aGF0ID0gcm0tPm5hbWUgKyAxMTsKCQl9CgkJZWxzZSBpZiAoIXByZWZpeGNtcChybS0+bmFtZSwgInJlZnMvdGFncy8iKSkgewoJCQlraW5kID0gInRhZyI7CgkJCXdoYXQgPSBybS0+bmFtZSArIDEwOwoJCX0KCQllbHNlIGlmICghcHJlZml4Y21wKHJtLT5uYW1lLCAicmVmcy9yZW1vdGVzLyIpKSB7CgkJCWtpbmQgPSAicmVtb3RlIGJyYW5jaCI7CgkJCXdoYXQgPSBybS0+bmFtZSArIDEzOwoJCX0KCQllbHNlIHsKCQkJa2luZCA9ICIiOwoJCQl3aGF0ID0gcm0tPm5hbWU7CgkJfQoKCQl1cmxfbGVuID0gc3RybGVuKHVybCk7CgkJZm9yIChpID0gdXJsX2xlbiAtIDE7IHVybFtpXSA9PSAnLycgJiYgMCA8PSBpOyBpLS0pCgkJCTsKCQl1cmxfbGVuID0gaSArIDE7CgkJaWYgKDQgPCBpICYmICFzdHJuY21wKCIuZ2l0IiwgdXJsICsgaSAtIDMsIDQpKQoJCQl1cmxfbGVuID0gaSAtIDM7CgoJCW5vdGVfbGVuID0gMDsKCQlpZiAoKndoYXQpIHsKCQkJaWYgKCpraW5kKQoJCQkJbm90ZV9sZW4gKz0gc3ByaW50Zihub3RlICsgbm90ZV9sZW4sICIlcyAiLAoJCQkJCQkgICAga2luZCk7CgkJCW5vdGVfbGVuICs9IHNwcmludGYobm90ZSArIG5vdGVfbGVuLCAiJyVzJyBvZiAiLCB3aGF0KTsKCQl9CgkJbm90ZVtub3RlX2xlbl0gPSAnXDAnOwoJCWZwcmludGYoZnAsICIlc1x0JXNcdCVzIiwKCQkJc2hhMV90b19oZXgoY29tbWl0ID8gY29tbWl0LT5vYmplY3Quc2hhMSA6CgkJCQkgICAgcm0tPm9sZF9zaGExKSwKCQkJcm0tPm1lcmdlID8gIiIgOiAibm90LWZvci1tZXJnZSIsCgkJCW5vdGUpOwoJCWZvciAoaSA9IDA7IGkgPCB1cmxfbGVuOyArK2kpCgkJCWlmICgnXG4nID09IHVybFtpXSkKCQkJCWZwdXRzKCJcXG4iLCBmcCk7CgkJCWVsc2UKCQkJCWZwdXRjKHVybFtpXSwgZnApOwoJCWZwdXRjKCdcbicsIGZwKTsKCgkJaWYgKHJlZikgewoJCQlyYyB8PSB1cGRhdGVfbG9jYWxfcmVmKHJlZiwgd2hhdCwgbm90ZSk7CgkJCWZyZWUocmVmKTsKCQl9IGVsc2UKCQkJc3ByaW50Zihub3RlLCAiKiAlLSpzICUtKnMgLT4gRkVUQ0hfSEVBRCIsCgkJCQlTVU1NQVJZX1dJRFRILCAqa2luZCA/IGtpbmQgOiAiYnJhbmNoIiwKCQkJCSBSRUZDT0xfV0lEVEgsICp3aGF0ID8gd2hhdCA6ICJIRUFEIik7CgkJaWYgKCpub3RlKSB7CgkJCWlmICh2ZXJib3NpdHkgPj0gMCAmJiAhc2hvd25fdXJsKSB7CgkJCQlmcHJpbnRmKHN0ZGVyciwgIkZyb20gJS4qc1xuIiwKCQkJCQkJdXJsX2xlbiwgdXJsKTsKCQkJCXNob3duX3VybCA9IDE7CgkJCX0KCQkJaWYgKHZlcmJvc2l0eSA+PSAwKQoJCQkJZnByaW50ZihzdGRlcnIsICIgJXNcbiIsIG5vdGUpOwoJCX0KCX0KCWZyZWUodXJsKTsKCWZjbG9zZShmcCk7CglpZiAocmMgJiBTVE9SRV9SRUZfRVJST1JfREZfQ09ORkxJQ1QpCgkJZXJyb3IoInNvbWUgbG9jYWwgcmVmcyBjb3VsZCBub3QgYmUgdXBkYXRlZDsgdHJ5IHJ1bm5pbmdcbiIKCQkgICAgICAiICdnaXQgcmVtb3RlIHBydW5lICVzJyB0byByZW1vdmUgYW55IG9sZCwgY29uZmxpY3RpbmcgIgoJCSAgICAgICJicmFuY2hlcyIsIHJlbW90ZV9uYW1lKTsKCXJldHVybiByYzsKfQoKLyoKICogV2Ugd291bGQgd2FudCB0byBieXBhc3MgdGhlIG9iamVjdCB0cmFuc2ZlciBhbHRvZ2V0aGVyIGlmCiAqIGV2ZXJ5dGhpbmcgd2UgYXJlIGdvaW5nIHRvIGZldGNoIGFscmVhZHkgZXhpc3RzIGFuZCBpcyBjb25uZWN0ZWQKICogbG9jYWxseS4KICoKICogVGhlIHJlZnMgd2UgYXJlIGdvaW5nIHRvIGZldGNoIGFyZSBpbiByZWZfbWFwLiAgSWYgcnVubmluZwogKgogKiAgJCBnaXQgcmV2LWxpc3QgLS1vYmplY3RzIC0tc3RkaW4gLS1ub3QgLS1hbGwKICoKICogKGZlZWRpbmcgYWxsIHRoZSByZWZzIGluIHJlZl9tYXAgb24gaXRzIHN0YW5kYXJkIGlucHV0KQogKiBkb2VzIG5vdCBlcnJvciBvdXQsIHRoYXQgbWVhbnMgZXZlcnl0aGluZyByZWFjaGFibGUgZnJvbSB0aGUKICogcmVmcyB3ZSBhcmUgZ29pbmcgdG8gZmV0Y2ggZXhpc3RzIGFuZCBpcyBjb25uZWN0ZWQgdG8gc29tZSBvZgogKiBvdXIgZXhpc3RpbmcgcmVmcy4KICovCnN0YXRpYyBpbnQgcXVpY2tmZXRjaChzdHJ1Y3QgcmVmICpyZWZfbWFwKQp7CglzdHJ1Y3QgY2hpbGRfcHJvY2VzcyByZXZsaXN0OwoJc3RydWN0IHJlZiAqcmVmOwoJaW50IGVycjsKCWNvbnN0IGNoYXIgKmFyZ3ZbXSA9IHsicmV2LWxpc3QiLAoJCSItLXF1aWV0IiwgIi0tb2JqZWN0cyIsICItLXN0ZGluIiwgIi0tbm90IiwgIi0tYWxsIiwgTlVMTH07CgoJLyoKCSAqIElmIHdlIGFyZSBkZWVwZW5pbmcgYSBzaGFsbG93IGNsb25lIHdlIGFscmVhZHkgaGF2ZSB0aGVzZQoJICogb2JqZWN0cyByZWFjaGFibGUuICBSdW5uaW5nIHJldi1saXN0IGhlcmUgd2lsbCByZXR1cm4gd2l0aAoJICogYSBnb29kICgwKSBleGl0IHN0YXR1cyBhbmQgd2UnbGwgYnlwYXNzIHRoZSBmZXRjaCB0aGF0IHdlCgkgKiByZWFsbHkgbmVlZCB0byBwZXJmb3JtLiAgQ2xhaW1pbmcgZmFpbHVyZSBub3cgd2lsbCBlbnN1cmUKCSAqIHdlIHBlcmZvcm0gdGhlIG5ldHdvcmsgZXhjaGFuZ2UgdG8gZGVlcGVuIG91ciBoaXN0b3J5LgoJICovCglpZiAoZGVwdGgpCgkJcmV0dXJuIC0xOwoKCWlmICghcmVmX21hcCkKCQlyZXR1cm4gMDsKCgltZW1zZXQoJnJldmxpc3QsIDAsIHNpemVvZihyZXZsaXN0KSk7CglyZXZsaXN0LmFyZ3YgPSBhcmd2OwoJcmV2bGlzdC5naXRfY21kID0gMTsKCXJldmxpc3Qubm9fc3Rkb3V0ID0gMTsKCXJldmxpc3Qubm9fc3RkZXJyID0gMTsKCXJldmxpc3QuaW4gPSAtMTsKCgllcnIgPSBzdGFydF9jb21tYW5kKCZyZXZsaXN0KTsKCWlmIChlcnIpIHsKCQllcnJvcigiY291bGQgbm90IHJ1biByZXYtbGlzdCIpOwoJCXJldHVybiBlcnI7Cgl9CgoJLyoKCSAqIElmIHJldi1saXN0IC0tc3RkaW4gZW5jb3VudGVycyBhbiB1bmtub3duIGNvbW1pdCwgaXQgdGVybWluYXRlcywKCSAqIHdoaWNoIHdpbGwgY2F1c2UgU0lHUElQRSBpbiB0aGUgd3JpdGUgbG9vcCBiZWxvdy4KCSAqLwoJc2lnY2hhaW5fcHVzaChTSUdQSVBFLCBTSUdfSUdOKTsKCglmb3IgKHJlZiA9IHJlZl9tYXA7IHJlZjsgcmVmID0gcmVmLT5uZXh0KSB7CgkJaWYgKHdyaXRlX2luX2Z1bGwocmV2bGlzdC5pbiwgc2hhMV90b19oZXgocmVmLT5vbGRfc2hhMSksIDQwKSA8IDAgfHwKCQkgICAgd3JpdGVfc3RyX2luX2Z1bGwocmV2bGlzdC5pbiwgIlxuIikgPCAwKSB7CgkJCWlmIChlcnJubyAhPSBFUElQRSAmJiBlcnJubyAhPSBFSU5WQUwpCgkJCQllcnJvcigiZmFpbGVkIHdyaXRlIHRvIHJldi1saXN0OiAlcyIsIHN0cmVycm9yKGVycm5vKSk7CgkJCWVyciA9IC0xOwoJCQlicmVhazsKCQl9Cgl9CgoJaWYgKGNsb3NlKHJldmxpc3QuaW4pKSB7CgkJZXJyb3IoImZhaWxlZCB0byBjbG9zZSByZXYtbGlzdCdzIHN0ZGluOiAlcyIsIHN0cmVycm9yKGVycm5vKSk7CgkJZXJyID0gLTE7Cgl9CgoJc2lnY2hhaW5fcG9wKFNJR1BJUEUpOwoKCXJldHVybiBmaW5pc2hfY29tbWFuZCgmcmV2bGlzdCkgfHwgZXJyOwp9CgpzdGF0aWMgaW50IGZldGNoX3JlZnMoc3RydWN0IHRyYW5zcG9ydCAqdHJhbnNwb3J0LCBzdHJ1Y3QgcmVmICpyZWZfbWFwKQp7CglpbnQgcmV0ID0gcXVpY2tmZXRjaChyZWZfbWFwKTsKCWlmIChyZXQpCgkJcmV0ID0gdHJhbnNwb3J0X2ZldGNoX3JlZnModHJhbnNwb3J0LCByZWZfbWFwKTsKCWlmICghcmV0KQoJCXJldCB8PSBzdG9yZV91cGRhdGVkX3JlZnModHJhbnNwb3J0LT51cmwsCgkJCQl0cmFuc3BvcnQtPnJlbW90ZS0+bmFtZSwKCQkJCXJlZl9tYXApOwoJdHJhbnNwb3J0X3VubG9ja19wYWNrKHRyYW5zcG9ydCk7CglyZXR1cm4gcmV0Owp9CgpzdGF0aWMgaW50IHBydW5lX3JlZnMoc3RydWN0IHRyYW5zcG9ydCAqdHJhbnNwb3J0LCBzdHJ1Y3QgcmVmICpyZWZfbWFwKQp7CglpbnQgcmVzdWx0ID0gMDsKCXN0cnVjdCByZWYgKnJlZiwgKnN0YWxlX3JlZnMgPSBnZXRfc3RhbGVfaGVhZHModHJhbnNwb3J0LT5yZW1vdGUsIHJlZl9tYXApOwoJY29uc3QgY2hhciAqZGFuZ2xpbmdfbXNnID0gZHJ5X3J1bgoJCT8gIiAgICglcyB3aWxsIGJlY29tZSBkYW5nbGluZylcbiIKCQk6ICIgICAoJXMgaGFzIGJlY29tZSBkYW5nbGluZylcbiI7CgoJZm9yIChyZWYgPSBzdGFsZV9yZWZzOyByZWY7IHJlZiA9IHJlZi0+bmV4dCkgewoJCWlmICghZHJ5X3J1bikKCQkJcmVzdWx0IHw9IGRlbGV0ZV9yZWYocmVmLT5uYW1lLCBOVUxMLCAwKTsKCQlpZiAodmVyYm9zaXR5ID49IDApIHsKCQkJZnByaW50ZihzdGRlcnIsICIgeCAlLSpzICUtKnMgLT4gJXNcbiIsCgkJCQlTVU1NQVJZX1dJRFRILCAiW2RlbGV0ZWRdIiwKCQkJCVJFRkNPTF9XSURUSCwgIihub25lKSIsIHByZXR0aWZ5X3JlZm5hbWUocmVmLT5uYW1lKSk7CgkJCXdhcm5fZGFuZ2xpbmdfc3ltcmVmKHN0ZGVyciwgZGFuZ2xpbmdfbXNnLCByZWYtPm5hbWUpOwoJCX0KCX0KCWZyZWVfcmVmcyhzdGFsZV9yZWZzKTsKCXJldHVybiByZXN1bHQ7Cn0KCnN0YXRpYyBpbnQgYWRkX2V4aXN0aW5nKGNvbnN0IGNoYXIgKnJlZm5hbWUsIGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEsCgkJCWludCBmbGFnLCB2b2lkICpjYmRhdGEpCnsKCXN0cnVjdCBzdHJpbmdfbGlzdCAqbGlzdCA9IChzdHJ1Y3Qgc3RyaW5nX2xpc3QgKiljYmRhdGE7CglzdHJ1Y3Qgc3RyaW5nX2xpc3RfaXRlbSAqaXRlbSA9IHN0cmluZ19saXN0X2luc2VydChyZWZuYW1lLCBsaXN0KTsKCWl0ZW0tPnV0aWwgPSAodm9pZCAqKXNoYTE7CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCB3aWxsX2ZldGNoKHN0cnVjdCByZWYgKipoZWFkLCBjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExKQp7CglzdHJ1Y3QgcmVmICpybSA9ICpoZWFkOwoJd2hpbGUgKHJtKSB7CgkJaWYgKCFoYXNoY21wKHJtLT5vbGRfc2hhMSwgc2hhMSkpCgkJCXJldHVybiAxOwoJCXJtID0gcm0tPm5leHQ7Cgl9CglyZXR1cm4gMDsKfQoKc3RydWN0IHRhZ19kYXRhIHsKCXN0cnVjdCByZWYgKipoZWFkOwoJc3RydWN0IHJlZiAqKip0YWlsOwp9OwoKc3RhdGljIGludCBhZGRfdG9fdGFpbChzdHJ1Y3Qgc3RyaW5nX2xpc3RfaXRlbSAqaXRlbSwgdm9pZCAqY2JfZGF0YSkKewoJc3RydWN0IHRhZ19kYXRhICpkYXRhID0gKHN0cnVjdCB0YWdfZGF0YSAqKWNiX2RhdGE7CglzdHJ1Y3QgcmVmICpybSA9IE5VTEw7CgoJLyogV2UgaGF2ZSBhbHJlYWR5IGRlY2lkZWQgdG8gaWdub3JlIHRoaXMgaXRlbSAqLwoJaWYgKCFpdGVtLT51dGlsKQoJCXJldHVybiAwOwoKCXJtID0gYWxsb2NfcmVmKGl0ZW0tPnN0cmluZyk7CglybS0+cGVlcl9yZWYgPSBhbGxvY19yZWYoaXRlbS0+c3RyaW5nKTsKCWhhc2hjcHkocm0tPm9sZF9zaGExLCBpdGVtLT51dGlsKTsKCgkqKmRhdGEtPnRhaWwgPSBybTsKCSpkYXRhLT50YWlsID0gJnJtLT5uZXh0OwoKCXJldHVybiAwOwp9CgpzdGF0aWMgdm9pZCBmaW5kX25vbl9sb2NhbF90YWdzKHN0cnVjdCB0cmFuc3BvcnQgKnRyYW5zcG9ydCwKCQkJc3RydWN0IHJlZiAqKmhlYWQsCgkJCXN0cnVjdCByZWYgKioqdGFpbCkKewoJc3RydWN0IHN0cmluZ19saXN0IGV4aXN0aW5nX3JlZnMgPSB7IE5VTEwsIDAsIDAsIDAgfTsKCXN0cnVjdCBzdHJpbmdfbGlzdCByZW1vdGVfcmVmcyA9IHsgTlVMTCwgMCwgMCwgMCB9OwoJc3RydWN0IHRhZ19kYXRhIGRhdGEgPSB7aGVhZCwgdGFpbH07Cgljb25zdCBzdHJ1Y3QgcmVmICpyZWY7CglzdHJ1Y3Qgc3RyaW5nX2xpc3RfaXRlbSAqaXRlbSA9IE5VTEw7CgoJZm9yX2VhY2hfcmVmKGFkZF9leGlzdGluZywgJmV4aXN0aW5nX3JlZnMpOwoJZm9yIChyZWYgPSB0cmFuc3BvcnRfZ2V0X3JlbW90ZV9yZWZzKHRyYW5zcG9ydCk7IHJlZjsgcmVmID0gcmVmLT5uZXh0KSB7CgkJaWYgKHByZWZpeGNtcChyZWYtPm5hbWUsICJyZWZzL3RhZ3MiKSkKCQkJY29udGludWU7CgoJCS8qCgkJICogVGhlIHBlZWxlZCByZWYgYWx3YXlzIGZvbGxvd3MgdGhlIG1hdGNoaW5nIGJhc2UKCQkgKiByZWYsIHNvIGlmIHdlIHNlZSBhIHBlZWxlZCByZWYgdGhhdCB3ZSBkb24ndCB3YW50CgkJICogdG8gZmV0Y2ggdGhlbiB3ZSBjYW4gbWFyayB0aGUgcmVmIGVudHJ5IGluIHRoZSBsaXN0CgkJICogYXMgb25lIHRvIGlnbm9yZSBieSBzZXR0aW5nIHV0aWwgdG8gTlVMTC4KCQkgKi8KCQlpZiAoIXN1ZmZpeGNtcChyZWYtPm5hbWUsICJee30iKSkgewoJCQlpZiAoaXRlbSAmJiAhaGFzX3NoYTFfZmlsZShyZWYtPm9sZF9zaGExKSAmJgoJCQkgICAgIXdpbGxfZmV0Y2goaGVhZCwgcmVmLT5vbGRfc2hhMSkgJiYKCQkJICAgICFoYXNfc2hhMV9maWxlKGl0ZW0tPnV0aWwpICYmCgkJCSAgICAhd2lsbF9mZXRjaChoZWFkLCBpdGVtLT51dGlsKSkKCQkJCWl0ZW0tPnV0aWwgPSBOVUxMOwoJCQlpdGVtID0gTlVMTDsKCQkJY29udGludWU7CgkJfQoKCQkvKgoJCSAqIElmIGl0ZW0gaXMgbm9uLU5VTEwgaGVyZSwgdGhlbiB3ZSBwcmV2aW91c2x5IHNhdyBhCgkJICogcmVmIG5vdCBmb2xsb3dlZCBieSBhIHBlZWxlZCByZWZlcmVuY2UsIHNvIHdlIG5lZWQKCQkgKiB0byBjaGVjayBpZiBpdCBpcyBhIGxpZ2h0d2VpZ2h0IHRhZyB0aGF0IHdlIHdhbnQgdG8KCQkgKiBmZXRjaC4KCQkgKi8KCQlpZiAoaXRlbSAmJiAhaGFzX3NoYTFfZmlsZShpdGVtLT51dGlsKSAmJgoJCSAgICAhd2lsbF9mZXRjaChoZWFkLCBpdGVtLT51dGlsKSkKCQkJaXRlbS0+dXRpbCA9IE5VTEw7CgoJCWl0ZW0gPSBOVUxMOwoKCQkvKiBza2lwIGR1cGxpY2F0ZXMgYW5kIHJlZnMgdGhhdCB3ZSBhbHJlYWR5IGhhdmUgKi8KCQlpZiAoc3RyaW5nX2xpc3RfaGFzX3N0cmluZygmcmVtb3RlX3JlZnMsIHJlZi0+bmFtZSkgfHwKCQkgICAgc3RyaW5nX2xpc3RfaGFzX3N0cmluZygmZXhpc3RpbmdfcmVmcywgcmVmLT5uYW1lKSkKCQkJY29udGludWU7CgoJCWl0ZW0gPSBzdHJpbmdfbGlzdF9pbnNlcnQocmVmLT5uYW1lLCAmcmVtb3RlX3JlZnMpOwoJCWl0ZW0tPnV0aWwgPSAodm9pZCAqKXJlZi0+b2xkX3NoYTE7Cgl9CglzdHJpbmdfbGlzdF9jbGVhcigmZXhpc3RpbmdfcmVmcywgMCk7CgoJLyoKCSAqIFdlIG1heSBoYXZlIGEgZmluYWwgbGlnaHR3ZWlnaHQgdGFnIHRoYXQgbmVlZHMgdG8gYmUKCSAqIGNoZWNrZWQgdG8gc2VlIGlmIGl0IG5lZWRzIGZldGNoaW5nLgoJICovCglpZiAoaXRlbSAmJiAhaGFzX3NoYTFfZmlsZShpdGVtLT51dGlsKSAmJgoJICAgICF3aWxsX2ZldGNoKGhlYWQsIGl0ZW0tPnV0aWwpKQoJCWl0ZW0tPnV0aWwgPSBOVUxMOwoKCS8qCgkgKiBGb3IgYWxsIHRoZSB0YWdzIGluIHRoZSByZW1vdGVfcmVmcyBzdHJpbmcgbGlzdCwgY2FsbAoJICogYWRkX3RvX3RhaWwgdG8gYWRkIHRoZW0gdG8gdGhlIGxpc3Qgb2YgcmVmcyB0byBiZSBmZXRjaGVkCgkgKi8KCWZvcl9lYWNoX3N0cmluZ19saXN0KGFkZF90b190YWlsLCAmcmVtb3RlX3JlZnMsICZkYXRhKTsKCglzdHJpbmdfbGlzdF9jbGVhcigmcmVtb3RlX3JlZnMsIDApOwp9CgpzdGF0aWMgdm9pZCBjaGVja19ub3RfY3VycmVudF9icmFuY2goc3RydWN0IHJlZiAqcmVmX21hcCkKewoJc3RydWN0IGJyYW5jaCAqY3VycmVudF9icmFuY2ggPSBicmFuY2hfZ2V0KE5VTEwpOwoKCWlmIChpc19iYXJlX3JlcG9zaXRvcnkoKSB8fCAhY3VycmVudF9icmFuY2gpCgkJcmV0dXJuOwoKCWZvciAoOyByZWZfbWFwOyByZWZfbWFwID0gcmVmX21hcC0+bmV4dCkKCQlpZiAocmVmX21hcC0+cGVlcl9yZWYgJiYgIXN0cmNtcChjdXJyZW50X2JyYW5jaC0+cmVmbmFtZSwKCQkJCQlyZWZfbWFwLT5wZWVyX3JlZi0+bmFtZSkpCgkJCWRpZSgiUmVmdXNpbmcgdG8gZmV0Y2ggaW50byBjdXJyZW50IGJyYW5jaCAlcyAiCgkJCSAgICAib2Ygbm9uLWJhcmUgcmVwb3NpdG9yeSIsIGN1cnJlbnRfYnJhbmNoLT5yZWZuYW1lKTsKfQoKc3RhdGljIGludCB0cnVuY2F0ZV9mZXRjaF9oZWFkKHZvaWQpCnsKCWNoYXIgKmZpbGVuYW1lID0gZ2l0X3BhdGgoIkZFVENIX0hFQUQiKTsKCUZJTEUgKmZwID0gZm9wZW4oZmlsZW5hbWUsICJ3Iik7CgoJaWYgKCFmcCkKCQlyZXR1cm4gZXJyb3IoImNhbm5vdCBvcGVuICVzOiAlc1xuIiwgZmlsZW5hbWUsIHN0cmVycm9yKGVycm5vKSk7CglmY2xvc2UoZnApOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgZG9fZmV0Y2goc3RydWN0IHRyYW5zcG9ydCAqdHJhbnNwb3J0LAoJCSAgICBzdHJ1Y3QgcmVmc3BlYyAqcmVmcywgaW50IHJlZl9jb3VudCkKewoJc3RydWN0IHN0cmluZ19saXN0IGV4aXN0aW5nX3JlZnMgPSB7IE5VTEwsIDAsIDAsIDAgfTsKCXN0cnVjdCBzdHJpbmdfbGlzdF9pdGVtICpwZWVyX2l0ZW0gPSBOVUxMOwoJc3RydWN0IHJlZiAqcmVmX21hcDsKCXN0cnVjdCByZWYgKnJtOwoJaW50IGF1dG90YWdzID0gKHRyYW5zcG9ydC0+cmVtb3RlLT5mZXRjaF90YWdzID09IDEpOwoKCWZvcl9lYWNoX3JlZihhZGRfZXhpc3RpbmcsICZleGlzdGluZ19yZWZzKTsKCglpZiAodHJhbnNwb3J0LT5yZW1vdGUtPmZldGNoX3RhZ3MgPT0gMiAmJiB0YWdzICE9IFRBR1NfVU5TRVQpCgkJdGFncyA9IFRBR1NfU0VUOwoJaWYgKHRyYW5zcG9ydC0+cmVtb3RlLT5mZXRjaF90YWdzID09IC0xKQoJCXRhZ3MgPSBUQUdTX1VOU0VUOwoKCWlmICghdHJhbnNwb3J0LT5nZXRfcmVmc19saXN0IHx8ICF0cmFuc3BvcnQtPmZldGNoKQoJCWRpZSgiRG9uJ3Qga25vdyBob3cgdG8gZmV0Y2ggZnJvbSAlcyIsIHRyYW5zcG9ydC0+dXJsKTsKCgkvKiBpZiBub3QgYXBwZW5kaW5nLCB0cnVuY2F0ZSBGRVRDSF9IRUFEICovCglpZiAoIWFwcGVuZCAmJiAhZHJ5X3J1bikgewoJCWludCBlcnJjb2RlID0gdHJ1bmNhdGVfZmV0Y2hfaGVhZCgpOwoJCWlmIChlcnJjb2RlKQoJCQlyZXR1cm4gZXJyY29kZTsKCX0KCglyZWZfbWFwID0gZ2V0X3JlZl9tYXAodHJhbnNwb3J0LCByZWZzLCByZWZfY291bnQsIHRhZ3MsICZhdXRvdGFncyk7CglpZiAoIXVwZGF0ZV9oZWFkX29rKQoJCWNoZWNrX25vdF9jdXJyZW50X2JyYW5jaChyZWZfbWFwKTsKCglmb3IgKHJtID0gcmVmX21hcDsgcm07IHJtID0gcm0tPm5leHQpIHsKCQlpZiAocm0tPnBlZXJfcmVmKSB7CgkJCXBlZXJfaXRlbSA9IHN0cmluZ19saXN0X2xvb2t1cChybS0+cGVlcl9yZWYtPm5hbWUsCgkJCQkJCSAgICAgICAmZXhpc3RpbmdfcmVmcyk7CgkJCWlmIChwZWVyX2l0ZW0pCgkJCQloYXNoY3B5KHJtLT5wZWVyX3JlZi0+b2xkX3NoYTEsCgkJCQkJcGVlcl9pdGVtLT51dGlsKTsKCQl9Cgl9CgoJaWYgKHRhZ3MgPT0gVEFHU19ERUZBVUxUICYmIGF1dG90YWdzKQoJCXRyYW5zcG9ydF9zZXRfb3B0aW9uKHRyYW5zcG9ydCwgVFJBTlNfT1BUX0ZPTExPV1RBR1MsICIxIik7CglpZiAoZmV0Y2hfcmVmcyh0cmFuc3BvcnQsIHJlZl9tYXApKSB7CgkJZnJlZV9yZWZzKHJlZl9tYXApOwoJCXJldHVybiAxOwoJfQoJaWYgKHBydW5lKQoJCXBydW5lX3JlZnModHJhbnNwb3J0LCByZWZfbWFwKTsKCWZyZWVfcmVmcyhyZWZfbWFwKTsKCgkvKiBpZiBuZWl0aGVyIC0tbm8tdGFncyBub3IgLS10YWdzIHdhcyBzcGVjaWZpZWQsIGRvIGF1dG9tYXRlZCB0YWcKCSAqIGZvbGxvd2luZyAuLi4gKi8KCWlmICh0YWdzID09IFRBR1NfREVGQVVMVCAmJiBhdXRvdGFncykgewoJCXN0cnVjdCByZWYgKip0YWlsID0gJnJlZl9tYXA7CgkJcmVmX21hcCA9IE5VTEw7CgkJZmluZF9ub25fbG9jYWxfdGFncyh0cmFuc3BvcnQsICZyZWZfbWFwLCAmdGFpbCk7CgkJaWYgKHJlZl9tYXApIHsKCQkJdHJhbnNwb3J0X3NldF9vcHRpb24odHJhbnNwb3J0LCBUUkFOU19PUFRfRk9MTE9XVEFHUywgTlVMTCk7CgkJCXRyYW5zcG9ydF9zZXRfb3B0aW9uKHRyYW5zcG9ydCwgVFJBTlNfT1BUX0RFUFRILCAiMCIpOwoJCQlmZXRjaF9yZWZzKHRyYW5zcG9ydCwgcmVmX21hcCk7CgkJfQoJCWZyZWVfcmVmcyhyZWZfbWFwKTsKCX0KCglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgc2V0X29wdGlvbihjb25zdCBjaGFyICpuYW1lLCBjb25zdCBjaGFyICp2YWx1ZSkKewoJaW50IHIgPSB0cmFuc3BvcnRfc2V0X29wdGlvbih0cmFuc3BvcnQsIG5hbWUsIHZhbHVlKTsKCWlmIChyIDwgMCkKCQlkaWUoIk9wdGlvbiBcIiVzXCIgdmFsdWUgXCIlc1wiIGlzIG5vdCB2YWxpZCBmb3IgJXMiLAoJCQluYW1lLCB2YWx1ZSwgdHJhbnNwb3J0LT51cmwpOwoJaWYgKHIgPiAwKQoJCXdhcm5pbmcoIk9wdGlvbiBcIiVzXCIgaXMgaWdub3JlZCBmb3IgJXNcbiIsCgkJCW5hbWUsIHRyYW5zcG9ydC0+dXJsKTsKfQoKc3RhdGljIGludCBnZXRfb25lX3JlbW90ZV9mb3JfZmV0Y2goc3RydWN0IHJlbW90ZSAqcmVtb3RlLCB2b2lkICpwcml2KQp7CglzdHJ1Y3Qgc3RyaW5nX2xpc3QgKmxpc3QgPSBwcml2OwoJaWYgKCFyZW1vdGUtPnNraXBfZGVmYXVsdF91cGRhdGUpCgkJc3RyaW5nX2xpc3RfYXBwZW5kKHJlbW90ZS0+bmFtZSwgbGlzdCk7CglyZXR1cm4gMDsKfQoKc3RydWN0IHJlbW90ZV9ncm91cF9kYXRhIHsKCWNvbnN0IGNoYXIgKm5hbWU7CglzdHJ1Y3Qgc3RyaW5nX2xpc3QgKmxpc3Q7Cn07CgpzdGF0aWMgaW50IGdldF9yZW1vdGVfZ3JvdXAoY29uc3QgY2hhciAqa2V5LCBjb25zdCBjaGFyICp2YWx1ZSwgdm9pZCAqcHJpdikKewoJc3RydWN0IHJlbW90ZV9ncm91cF9kYXRhICpnID0gcHJpdjsKCglpZiAoIXByZWZpeGNtcChrZXksICJyZW1vdGVzLiIpICYmCgkJCSFzdHJjbXAoa2V5ICsgOCwgZy0+bmFtZSkpIHsKCQkvKiBzcGxpdCBsaXN0IGJ5IHdoaXRlIHNwYWNlICovCgkJaW50IHNwYWNlID0gc3RyY3Nwbih2YWx1ZSwgIiBcdFxuIik7CgkJd2hpbGUgKCp2YWx1ZSkgewoJCQlpZiAoc3BhY2UgPiAxKSB7CgkJCQlzdHJpbmdfbGlzdF9hcHBlbmQoeHN0cm5kdXAodmFsdWUsIHNwYWNlKSwKCQkJCQkJICAgZy0+bGlzdCk7CgkJCX0KCQkJdmFsdWUgKz0gc3BhY2UgKyAodmFsdWVbc3BhY2VdICE9ICdcMCcpOwoJCQlzcGFjZSA9IHN0cmNzcG4odmFsdWUsICIgXHRcbiIpOwoJCX0KCX0KCglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBhZGRfcmVtb3RlX29yX2dyb3VwKGNvbnN0IGNoYXIgKm5hbWUsIHN0cnVjdCBzdHJpbmdfbGlzdCAqbGlzdCkKewoJaW50IHByZXZfbnIgPSBsaXN0LT5ucjsKCXN0cnVjdCByZW1vdGVfZ3JvdXBfZGF0YSBnID0geyBuYW1lLCBsaXN0IH07CgoJZ2l0X2NvbmZpZyhnZXRfcmVtb3RlX2dyb3VwLCAmZyk7CglpZiAobGlzdC0+bnIgPT0gcHJldl9ucikgewoJCXN0cnVjdCByZW1vdGUgKnJlbW90ZTsKCQlpZiAoIXJlbW90ZV9pc19jb25maWd1cmVkKG5hbWUpKQoJCQlyZXR1cm4gMDsKCQlyZW1vdGUgPSByZW1vdGVfZ2V0KG5hbWUpOwoJCXN0cmluZ19saXN0X2FwcGVuZChyZW1vdGUtPm5hbWUsIGxpc3QpOwoJfQoJcmV0dXJuIDE7Cn0KCnN0YXRpYyBpbnQgZmV0Y2hfbXVsdGlwbGUoc3RydWN0IHN0cmluZ19saXN0ICpsaXN0KQp7CglpbnQgaSwgcmVzdWx0ID0gMDsKCWNvbnN0IGNoYXIgKmFyZ3ZbMTFdID0geyAiZmV0Y2giLCAiLS1hcHBlbmQiIH07CglpbnQgYXJnYyA9IDI7CgoJaWYgKGRyeV9ydW4pCgkJYXJndlthcmdjKytdID0gIi0tZHJ5LXJ1biI7CglpZiAocHJ1bmUpCgkJYXJndlthcmdjKytdID0gIi0tcHJ1bmUiOwoJaWYgKHVwZGF0ZV9oZWFkX29rKQoJCWFyZ3ZbYXJnYysrXSA9ICItLXVwZGF0ZS1oZWFkLW9rIjsKCWlmIChmb3JjZSkKCQlhcmd2W2FyZ2MrK10gPSAiLS1mb3JjZSI7CglpZiAoa2VlcCkKCQlhcmd2W2FyZ2MrK10gPSAiLS1rZWVwIjsKCWlmICh2ZXJib3NpdHkgPj0gMikKCQlhcmd2W2FyZ2MrK10gPSAiLXYiOwoJaWYgKHZlcmJvc2l0eSA+PSAxKQoJCWFyZ3ZbYXJnYysrXSA9ICItdiI7CgllbHNlIGlmICh2ZXJib3NpdHkgPCAwKQoJCWFyZ3ZbYXJnYysrXSA9ICItcSI7CgoJaWYgKCFhcHBlbmQgJiYgIWRyeV9ydW4pIHsKCQlpbnQgZXJyY29kZSA9IHRydW5jYXRlX2ZldGNoX2hlYWQoKTsKCQlpZiAoZXJyY29kZSkKCQkJcmV0dXJuIGVycmNvZGU7Cgl9CgoJZm9yIChpID0gMDsgaSA8IGxpc3QtPm5yOyBpKyspIHsKCQljb25zdCBjaGFyICpuYW1lID0gbGlzdC0+aXRlbXNbaV0uc3RyaW5nOwoJCWFyZ3ZbYXJnY10gPSBuYW1lOwoJCWFyZ3ZbYXJnYyArIDFdID0gTlVMTDsKCQlpZiAodmVyYm9zaXR5ID49IDApCgkJCXByaW50ZigiRmV0Y2hpbmcgJXNcbiIsIG5hbWUpOwoJCWlmIChydW5fY29tbWFuZF92X29wdChhcmd2LCBSVU5fR0lUX0NNRCkpIHsKCQkJZXJyb3IoIkNvdWxkIG5vdCBmZXRjaCAlcyIsIG5hbWUpOwoJCQlyZXN1bHQgPSAxOwoJCX0KCX0KCglyZXR1cm4gcmVzdWx0Owp9CgpzdGF0aWMgaW50IGZldGNoX29uZShzdHJ1Y3QgcmVtb3RlICpyZW1vdGUsIGludCBhcmdjLCBjb25zdCBjaGFyICoqYXJndikKewoJaW50IGk7CglzdGF0aWMgY29uc3QgY2hhciAqKnJlZnMgPSBOVUxMOwoJaW50IHJlZl9uciA9IDA7CglpbnQgZXhpdF9jb2RlOwoKCWlmICghcmVtb3RlKQoJCWRpZSgiV2hlcmUgZG8geW91IHdhbnQgdG8gZmV0Y2ggZnJvbSB0b2RheT8iKTsKCgl0cmFuc3BvcnQgPSB0cmFuc3BvcnRfZ2V0KHJlbW90ZSwgTlVMTCk7CglpZiAodmVyYm9zaXR5ID49IDIpCgkJdHJhbnNwb3J0LT52ZXJib3NlID0gdmVyYm9zaXR5IDw9IDMgPyB2ZXJib3NpdHkgOiAzOwoJaWYgKHZlcmJvc2l0eSA8IDApCgkJdHJhbnNwb3J0LT52ZXJib3NlID0gLTE7CglpZiAodXBsb2FkX3BhY2spCgkJc2V0X29wdGlvbihUUkFOU19PUFRfVVBMT0FEUEFDSywgdXBsb2FkX3BhY2spOwoJaWYgKGtlZXApCgkJc2V0X29wdGlvbihUUkFOU19PUFRfS0VFUCwgInllcyIpOwoJaWYgKGRlcHRoKQoJCXNldF9vcHRpb24oVFJBTlNfT1BUX0RFUFRILCBkZXB0aCk7CgoJaWYgKGFyZ2MgPiAwKSB7CgkJaW50IGogPSAwOwoJCXJlZnMgPSB4Y2FsbG9jKGFyZ2MgKyAxLCBzaXplb2YoY29uc3QgY2hhciAqKSk7CgkJZm9yIChpID0gMDsgaSA8IGFyZ2M7IGkrKykgewoJCQlpZiAoIXN0cmNtcChhcmd2W2ldLCAidGFnIikpIHsKCQkJCWNoYXIgKnJlZjsKCQkJCWkrKzsKCQkJCWlmIChpID49IGFyZ2MpCgkJCQkJZGllKCJZb3UgbmVlZCB0byBzcGVjaWZ5IGEgdGFnIG5hbWUuIik7CgkJCQlyZWYgPSB4bWFsbG9jKHN0cmxlbihhcmd2W2ldKSAqIDIgKyAyMik7CgkJCQlzdHJjcHkocmVmLCAicmVmcy90YWdzLyIpOwoJCQkJc3RyY2F0KHJlZiwgYXJndltpXSk7CgkJCQlzdHJjYXQocmVmLCAiOnJlZnMvdGFncy8iKTsKCQkJCXN0cmNhdChyZWYsIGFyZ3ZbaV0pOwoJCQkJcmVmc1tqKytdID0gcmVmOwoJCQl9IGVsc2UKCQkJCXJlZnNbaisrXSA9IGFyZ3ZbaV07CgkJfQoJCXJlZnNbal0gPSBOVUxMOwoJCXJlZl9uciA9IGo7Cgl9CgoJc2lnY2hhaW5fcHVzaF9jb21tb24odW5sb2NrX3BhY2tfb25fc2lnbmFsKTsKCWF0ZXhpdCh1bmxvY2tfcGFjayk7CglleGl0X2NvZGUgPSBkb19mZXRjaCh0cmFuc3BvcnQsCgkJCXBhcnNlX2ZldGNoX3JlZnNwZWMocmVmX25yLCByZWZzKSwgcmVmX25yKTsKCXRyYW5zcG9ydF9kaXNjb25uZWN0KHRyYW5zcG9ydCk7Cgl0cmFuc3BvcnQgPSBOVUxMOwoJcmV0dXJuIGV4aXRfY29kZTsKfQoKaW50IGNtZF9mZXRjaChpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsIGNvbnN0IGNoYXIgKnByZWZpeCkKewoJaW50IGk7CglzdHJ1Y3Qgc3RyaW5nX2xpc3QgbGlzdCA9IHsgTlVMTCwgMCwgMCwgMCB9OwoJc3RydWN0IHJlbW90ZSAqcmVtb3RlOwoJaW50IHJlc3VsdCA9IDA7CgoJLyogUmVjb3JkIHRoZSBjb21tYW5kIGxpbmUgZm9yIHRoZSByZWZsb2cgKi8KCXN0cmJ1Zl9hZGRzdHIoJmRlZmF1bHRfcmxhLCAiZmV0Y2giKTsKCWZvciAoaSA9IDE7IGkgPCBhcmdjOyBpKyspCgkJc3RyYnVmX2FkZGYoJmRlZmF1bHRfcmxhLCAiICVzIiwgYXJndltpXSk7CgoJYXJnYyA9IHBhcnNlX29wdGlvbnMoYXJnYywgYXJndiwgcHJlZml4LAoJCQkgICAgIGJ1aWx0aW5fZmV0Y2hfb3B0aW9ucywgYnVpbHRpbl9mZXRjaF91c2FnZSwgMCk7CgoJaWYgKGFsbCkgewoJCWlmIChhcmdjID09IDEpCgkJCWRpZSgiZmV0Y2ggLS1hbGwgZG9lcyBub3QgdGFrZSBhIHJlcG9zaXRvcnkgYXJndW1lbnQiKTsKCQllbHNlIGlmIChhcmdjID4gMSkKCQkJZGllKCJmZXRjaCAtLWFsbCBkb2VzIG5vdCBtYWtlIHNlbnNlIHdpdGggcmVmc3BlY3MiKTsKCQkodm9pZCkgZm9yX2VhY2hfcmVtb3RlKGdldF9vbmVfcmVtb3RlX2Zvcl9mZXRjaCwgJmxpc3QpOwoJCXJlc3VsdCA9IGZldGNoX211bHRpcGxlKCZsaXN0KTsKCX0gZWxzZSBpZiAoYXJnYyA9PSAwKSB7CgkJLyogTm8gYXJndW1lbnRzIC0tIHVzZSBkZWZhdWx0IHJlbW90ZSAqLwoJCXJlbW90ZSA9IHJlbW90ZV9nZXQoTlVMTCk7CgkJcmVzdWx0ID0gZmV0Y2hfb25lKHJlbW90ZSwgYXJnYywgYXJndik7Cgl9IGVsc2UgaWYgKG11bHRpcGxlKSB7CgkJLyogQWxsIGFyZ3VtZW50cyBhcmUgYXNzdW1lZCB0byBiZSByZW1vdGVzIG9yIGdyb3VwcyAqLwoJCWZvciAoaSA9IDA7IGkgPCBhcmdjOyBpKyspCgkJCWlmICghYWRkX3JlbW90ZV9vcl9ncm91cChhcmd2W2ldLCAmbGlzdCkpCgkJCQlkaWUoIk5vIHN1Y2ggcmVtb3RlIG9yIHJlbW90ZSBncm91cDogJXMiLCBhcmd2W2ldKTsKCQlyZXN1bHQgPSBmZXRjaF9tdWx0aXBsZSgmbGlzdCk7Cgl9IGVsc2UgewoJCS8qIFNpbmdsZSByZW1vdGUgb3IgZ3JvdXAgKi8KCQkodm9pZCkgYWRkX3JlbW90ZV9vcl9ncm91cChhcmd2WzBdLCAmbGlzdCk7CgkJaWYgKGxpc3QubnIgPiAxKSB7CgkJCS8qIE1vcmUgdGhhbiBvbmUgcmVtb3RlICovCgkJCWlmIChhcmdjID4gMSkKCQkJCWRpZSgiRmV0Y2hpbmcgYSBncm91cCBhbmQgc3BlY2lmeWluZyByZWZzcGVjcyBkb2VzIG5vdCBtYWtlIHNlbnNlIik7CgkJCXJlc3VsdCA9IGZldGNoX211bHRpcGxlKCZsaXN0KTsKCQl9IGVsc2UgewoJCQkvKiBaZXJvIG9yIG9uZSByZW1vdGVzICovCgkJCXJlbW90ZSA9IHJlbW90ZV9nZXQoYXJndlswXSk7CgkJCXJlc3VsdCA9IGZldGNoX29uZShyZW1vdGUsIGFyZ2MtMSwgYXJndisxKTsKCQl9Cgl9CgoJLyogQWxsIG5hbWVzIHdlcmUgc3RyZHVwKCllZCBvciBzdHJuZHVwKCllZCAqLwoJbGlzdC5zdHJkdXBfc3RyaW5ncyA9IDE7CglzdHJpbmdfbGlzdF9jbGVhcigmbGlzdCwgMCk7CgoJcmV0dXJuIHJlc3VsdDsKfQo=",
    "text": "/*\n * \"git fetch\"\n */\n#include \"cache.h\"\n#include \"refs.h\"\n#include \"commit.h\"\n#include \"builtin.h\"\n#include \"string-list.h\"\n#include \"remote.h\"\n#include \"transport.h\"\n#include \"run-command.h\"\n#include \"parse-options.h\"\n#include \"sigchain.h\"\n\nstatic const char * const builtin_fetch_usage[] = {\n\t\"git fetch [<options>] [<repository> [<refspec>...]]\",\n\t\"git fetch [<options>] <group>\",\n\t\"git fetch --multiple [<options>] [<repository> | <group>]...\",\n\t\"git fetch --all [<options>]\",\n\tNULL\n};\n\nenum {\n\tTAGS_UNSET = 0,\n\tTAGS_DEFAULT = 1,\n\tTAGS_SET = 2\n};\n\nstatic int all, append, dry_run, force, keep, multiple, prune, update_head_ok, verbosity;\nstatic int tags = TAGS_DEFAULT;\nstatic const char *depth;\nstatic const char *upload_pack;\nstatic struct strbuf default_rla = STRBUF_INIT;\nstatic struct transport *transport;\n\nstatic struct option builtin_fetch_options[] = {\n\tOPT__VERBOSITY(&verbosity),\n\tOPT_BOOLEAN(0, \"all\", &all,\n\t\t    \"fetch from all remotes\"),\n\tOPT_BOOLEAN('a', \"append\", &append,\n\t\t    \"append to .git/FETCH_HEAD instead of overwriting\"),\n\tOPT_STRING(0, \"upload-pack\", &upload_pack, \"PATH\",\n\t\t   \"path to upload pack on remote end\"),\n\tOPT_BOOLEAN('f', \"force\", &force,\n\t\t    \"force overwrite of local branch\"),\n\tOPT_BOOLEAN('m', \"multiple\", &multiple,\n\t\t    \"fetch from multiple remotes\"),\n\tOPT_SET_INT('t', \"tags\", &tags,\n\t\t    \"fetch all tags and associated objects\", TAGS_SET),\n\tOPT_SET_INT('n', NULL, &tags,\n\t\t    \"do not fetch all tags (--no-tags)\", TAGS_UNSET),\n\tOPT_BOOLEAN('p', \"prune\", &prune,\n\t\t    \"prune tracking branches no longer on remote\"),\n\tOPT_BOOLEAN(0, \"dry-run\", &dry_run,\n\t\t    \"dry run\"),\n\tOPT_BOOLEAN('k', \"keep\", &keep, \"keep downloaded pack\"),\n\tOPT_BOOLEAN('u', \"update-head-ok\", &update_head_ok,\n\t\t    \"allow updating of HEAD ref\"),\n\tOPT_STRING(0, \"depth\", &depth, \"DEPTH\",\n\t\t   \"deepen history of shallow clone\"),\n\tOPT_END()\n};\n\nstatic void unlock_pack(void)\n{\n\tif (transport)\n\t\ttransport_unlock_pack(transport);\n}\n\nstatic void unlock_pack_on_signal(int signo)\n{\n\tunlock_pack();\n\tsigchain_pop(signo);\n\traise(signo);\n}\n\nstatic void add_merge_config(struct ref **head,\n\t\t\t   const struct ref *remote_refs,\n\t\t           struct branch *branch,\n\t\t           struct ref ***tail)\n{\n\tint i;\n\n\tfor (i = 0; i < branch->merge_nr; i++) {\n\t\tstruct ref *rm, **old_tail = *tail;\n\t\tstruct refspec refspec;\n\n\t\tfor (rm = *head; rm; rm = rm->next) {\n\t\t\tif (branch_merge_matches(branch, i, rm->name)) {\n\t\t\t\trm->merge = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (rm)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Not fetched to a tracking branch?  We need to fetch\n\t\t * it anyway to allow this branch's \"branch.$name.merge\"\n\t\t * to be honored by 'git pull', but we do not have to\n\t\t * fail if branch.$name.merge is misconfigured to point\n\t\t * at a nonexisting branch.  If we were indeed called by\n\t\t * 'git pull', it will notice the misconfiguration because\n\t\t * there is no entry in the resulting FETCH_HEAD marked\n\t\t * for merging.\n\t\t */\n\t\tmemset(&refspec, 0, sizeof(refspec));\n\t\trefspec.src = branch->merge[i]->src;\n\t\tget_fetch_map(remote_refs, &refspec, tail, 1);\n\t\tfor (rm = *old_tail; rm; rm = rm->next)\n\t\t\trm->merge = 1;\n\t}\n}\n\nstatic void find_non_local_tags(struct transport *transport,\n\t\t\tstruct ref **head,\n\t\t\tstruct ref ***tail);\n\nstatic struct ref *get_ref_map(struct transport *transport,\n\t\t\t       struct refspec *refs, int ref_count, int tags,\n\t\t\t       int *autotags)\n{\n\tint i;\n\tstruct ref *rm;\n\tstruct ref *ref_map = NULL;\n\tstruct ref **tail = &ref_map;\n\n\tconst struct ref *remote_refs = transport_get_remote_refs(transport);\n\n\tif (ref_count || tags == TAGS_SET) {\n\t\tfor (i = 0; i < ref_count; i++) {\n\t\t\tget_fetch_map(remote_refs, &refs[i], &tail, 0);\n\t\t\tif (refs[i].dst && refs[i].dst[0])\n\t\t\t\t*autotags = 1;\n\t\t}\n\t\t/* Merge everything on the command line, but not --tags */\n\t\tfor (rm = ref_map; rm; rm = rm->next)\n\t\t\trm->merge = 1;\n\t\tif (tags == TAGS_SET)\n\t\t\tget_fetch_map(remote_refs, tag_refspec, &tail, 0);\n\t} else {\n\t\t/* Use the defaults */\n\t\tstruct remote *remote = transport->remote;\n\t\tstruct branch *branch = branch_get(NULL);\n\t\tint has_merge = branch_has_merge_config(branch);\n\t\tif (remote && (remote->fetch_refspec_nr || has_merge)) {\n\t\t\tfor (i = 0; i < remote->fetch_refspec_nr; i++) {\n\t\t\t\tget_fetch_map(remote_refs, &remote->fetch[i], &tail, 0);\n\t\t\t\tif (remote->fetch[i].dst &&\n\t\t\t\t    remote->fetch[i].dst[0])\n\t\t\t\t\t*autotags = 1;\n\t\t\t\tif (!i && !has_merge && ref_map &&\n\t\t\t\t    !remote->fetch[0].pattern)\n\t\t\t\t\tref_map->merge = 1;\n\t\t\t}\n\t\t\t/*\n\t\t\t * if the remote we're fetching from is the same\n\t\t\t * as given in branch.<name>.remote, we add the\n\t\t\t * ref given in branch.<name>.merge, too.\n\t\t\t */\n\t\t\tif (has_merge &&\n\t\t\t    !strcmp(branch->remote_name, remote->name))\n\t\t\t\tadd_merge_config(&ref_map, remote_refs, branch, &tail);\n\t\t} else {\n\t\t\tref_map = get_remote_ref(remote_refs, \"HEAD\");\n\t\t\tif (!ref_map)\n\t\t\t\tdie(\"Couldn't find remote ref HEAD\");\n\t\t\tref_map->merge = 1;\n\t\t\ttail = &ref_map->next;\n\t\t}\n\t}\n\tif (tags == TAGS_DEFAULT && *autotags)\n\t\tfind_non_local_tags(transport, &ref_map, &tail);\n\tref_remove_duplicates(ref_map);\n\n\treturn ref_map;\n}\n\n#define STORE_REF_ERROR_OTHER 1\n#define STORE_REF_ERROR_DF_CONFLICT 2\n\nstatic int s_update_ref(const char *action,\n\t\t\tstruct ref *ref,\n\t\t\tint check_old)\n{\n\tchar msg[1024];\n\tchar *rla = getenv(\"GIT_REFLOG_ACTION\");\n\tstatic struct ref_lock *lock;\n\n\tif (dry_run)\n\t\treturn 0;\n\tif (!rla)\n\t\trla = default_rla.buf;\n\tsnprintf(msg, sizeof(msg), \"%s: %s\", rla, action);\n\tlock = lock_any_ref_for_update(ref->name,\n\t\t\t\t       check_old ? ref->old_sha1 : NULL, 0);\n\tif (!lock)\n\t\treturn errno == ENOTDIR ? STORE_REF_ERROR_DF_CONFLICT :\n\t\t\t\t\t  STORE_REF_ERROR_OTHER;\n\tif (write_ref_sha1(lock, ref->new_sha1, msg) < 0)\n\t\treturn errno == ENOTDIR ? STORE_REF_ERROR_DF_CONFLICT :\n\t\t\t\t\t  STORE_REF_ERROR_OTHER;\n\treturn 0;\n}\n\n#define SUMMARY_WIDTH (2 * DEFAULT_ABBREV + 3)\n#define REFCOL_WIDTH  10\n\nstatic int update_local_ref(struct ref *ref,\n\t\t\t    const char *remote,\n\t\t\t    char *display)\n{\n\tstruct commit *current = NULL, *updated;\n\tenum object_type type;\n\tstruct branch *current_branch = branch_get(NULL);\n\tconst char *pretty_ref = prettify_refname(ref->name);\n\n\t*display = 0;\n\ttype = sha1_object_info(ref->new_sha1, NULL);\n\tif (type < 0)\n\t\tdie(\"object %s not found\", sha1_to_hex(ref->new_sha1));\n\n\tif (!hashcmp(ref->old_sha1, ref->new_sha1)) {\n\t\tif (verbosity > 0)\n\t\t\tsprintf(display, \"= %-*s %-*s -> %s\", SUMMARY_WIDTH,\n\t\t\t\t\"[up to date]\", REFCOL_WIDTH, remote,\n\t\t\t\tpretty_ref);\n\t\treturn 0;\n\t}\n\n\tif (current_branch &&\n\t    !strcmp(ref->name, current_branch->name) &&\n\t    !(update_head_ok || is_bare_repository()) &&\n\t    !is_null_sha1(ref->old_sha1)) {\n\t\t/*\n\t\t * If this is the head, and it's not okay to update\n\t\t * the head, and the old value of the head isn't empty...\n\t\t */\n\t\tsprintf(display, \"! %-*s %-*s -> %s  (can't fetch in current branch)\",\n\t\t\tSUMMARY_WIDTH, \"[rejected]\", REFCOL_WIDTH, remote,\n\t\t\tpretty_ref);\n\t\treturn 1;\n\t}\n\n\tif (!is_null_sha1(ref->old_sha1) &&\n\t    !prefixcmp(ref->name, \"refs/tags/\")) {\n\t\tint r;\n\t\tr = s_update_ref(\"updating tag\", ref, 0);\n\t\tsprintf(display, \"%c %-*s %-*s -> %s%s\", r ? '!' : '-',\n\t\t\tSUMMARY_WIDTH, \"[tag update]\", REFCOL_WIDTH, remote,\n\t\t\tpretty_ref, r ? \"  (unable to update local ref)\" : \"\");\n\t\treturn r;\n\t}\n\n\tcurrent = lookup_commit_reference_gently(ref->old_sha1, 1);\n\tupdated = lookup_commit_reference_gently(ref->new_sha1, 1);\n\tif (!current || !updated) {\n\t\tconst char *msg;\n\t\tconst char *what;\n\t\tint r;\n\t\tif (!strncmp(ref->name, \"refs/tags/\", 10)) {\n\t\t\tmsg = \"storing tag\";\n\t\t\twhat = \"[new tag]\";\n\t\t}\n\t\telse {\n\t\t\tmsg = \"storing head\";\n\t\t\twhat = \"[new branch]\";\n\t\t}\n\n\t\tr = s_update_ref(msg, ref, 0);\n\t\tsprintf(display, \"%c %-*s %-*s -> %s%s\", r ? '!' : '*',\n\t\t\tSUMMARY_WIDTH, what, REFCOL_WIDTH, remote, pretty_ref,\n\t\t\tr ? \"  (unable to update local ref)\" : \"\");\n\t\treturn r;\n\t}\n\n\tif (in_merge_bases(current, &updated, 1)) {\n\t\tchar quickref[83];\n\t\tint r;\n\t\tstrcpy(quickref, find_unique_abbrev(current->object.sha1, DEFAULT_ABBREV));\n\t\tstrcat(quickref, \"..\");\n\t\tstrcat(quickref, find_unique_abbrev(ref->new_sha1, DEFAULT_ABBREV));\n\t\tr = s_update_ref(\"fast-forward\", ref, 1);\n\t\tsprintf(display, \"%c %-*s %-*s -> %s%s\", r ? '!' : ' ',\n\t\t\tSUMMARY_WIDTH, quickref, REFCOL_WIDTH, remote,\n\t\t\tpretty_ref, r ? \"  (unable to update local ref)\" : \"\");\n\t\treturn r;\n\t} else if (force || ref->force) {\n\t\tchar quickref[84];\n\t\tint r;\n\t\tstrcpy(quickref, find_unique_abbrev(current->object.sha1, DEFAULT_ABBREV));\n\t\tstrcat(quickref, \"...\");\n\t\tstrcat(quickref, find_unique_abbrev(ref->new_sha1, DEFAULT_ABBREV));\n\t\tr = s_update_ref(\"forced-update\", ref, 1);\n\t\tsprintf(display, \"%c %-*s %-*s -> %s  (%s)\", r ? '!' : '+',\n\t\t\tSUMMARY_WIDTH, quickref, REFCOL_WIDTH, remote,\n\t\t\tpretty_ref,\n\t\t\tr ? \"unable to update local ref\" : \"forced update\");\n\t\treturn r;\n\t} else {\n\t\tsprintf(display, \"! %-*s %-*s -> %s  (non-fast-forward)\",\n\t\t\tSUMMARY_WIDTH, \"[rejected]\", REFCOL_WIDTH, remote,\n\t\t\tpretty_ref);\n\t\treturn 1;\n\t}\n}\n\nstatic int store_updated_refs(const char *raw_url, const char *remote_name,\n\t\tstruct ref *ref_map)\n{\n\tFILE *fp;\n\tstruct commit *commit;\n\tint url_len, i, note_len, shown_url = 0, rc = 0;\n\tchar note[1024];\n\tconst char *what, *kind;\n\tstruct ref *rm;\n\tchar *url, *filename = dry_run ? \"/dev/null\" : git_path(\"FETCH_HEAD\");\n\n\tfp = fopen(filename, \"a\");\n\tif (!fp)\n\t\treturn error(\"cannot open %s: %s\\n\", filename, strerror(errno));\n\n\tif (raw_url)\n\t\turl = transport_anonymize_url(raw_url);\n\telse\n\t\turl = xstrdup(\"foreign\");\n\tfor (rm = ref_map; rm; rm = rm->next) {\n\t\tstruct ref *ref = NULL;\n\n\t\tif (rm->peer_ref) {\n\t\t\tref = xcalloc(1, sizeof(*ref) + strlen(rm->peer_ref->name) + 1);\n\t\t\tstrcpy(ref->name, rm->peer_ref->name);\n\t\t\thashcpy(ref->old_sha1, rm->peer_ref->old_sha1);\n\t\t\thashcpy(ref->new_sha1, rm->old_sha1);\n\t\t\tref->force = rm->peer_ref->force;\n\t\t}\n\n\t\tcommit = lookup_commit_reference_gently(rm->old_sha1, 1);\n\t\tif (!commit)\n\t\t\trm->merge = 0;\n\n\t\tif (!strcmp(rm->name, \"HEAD\")) {\n\t\t\tkind = \"\";\n\t\t\twhat = \"\";\n\t\t}\n\t\telse if (!prefixcmp(rm->name, \"refs/heads/\")) {\n\t\t\tkind = \"branch\";\n\t\t\twhat = rm->name + 11;\n\t\t}\n\t\telse if (!prefixcmp(rm->name, \"refs/tags/\")) {\n\t\t\tkind = \"tag\";\n\t\t\twhat = rm->name + 10;\n\t\t}\n\t\telse if (!prefixcmp(rm->name, \"refs/remotes/\")) {\n\t\t\tkind = \"remote branch\";\n\t\t\twhat = rm->name + 13;\n\t\t}\n\t\telse {\n\t\t\tkind = \"\";\n\t\t\twhat = rm->name;\n\t\t}\n\n\t\turl_len = strlen(url);\n\t\tfor (i = url_len - 1; url[i] == '/' && 0 <= i; i--)\n\t\t\t;\n\t\turl_len = i + 1;\n\t\tif (4 < i && !strncmp(\".git\", url + i - 3, 4))\n\t\t\turl_len = i - 3;\n\n\t\tnote_len = 0;\n\t\tif (*what) {\n\t\t\tif (*kind)\n\t\t\t\tnote_len += sprintf(note + note_len, \"%s \",\n\t\t\t\t\t\t    kind);\n\t\t\tnote_len += sprintf(note + note_len, \"'%s' of \", what);\n\t\t}\n\t\tnote[note_len] = '\\0';\n\t\tfprintf(fp, \"%s\\t%s\\t%s\",\n\t\t\tsha1_to_hex(commit ? commit->object.sha1 :\n\t\t\t\t    rm->old_sha1),\n\t\t\trm->merge ? \"\" : \"not-for-merge\",\n\t\t\tnote);\n\t\tfor (i = 0; i < url_len; ++i)\n\t\t\tif ('\\n' == url[i])\n\t\t\t\tfputs(\"\\\\n\", fp);\n\t\t\telse\n\t\t\t\tfputc(url[i], fp);\n\t\tfputc('\\n', fp);\n\n\t\tif (ref) {\n\t\t\trc |= update_local_ref(ref, what, note);\n\t\t\tfree(ref);\n\t\t} else\n\t\t\tsprintf(note, \"* %-*s %-*s -> FETCH_HEAD\",\n\t\t\t\tSUMMARY_WIDTH, *kind ? kind : \"branch\",\n\t\t\t\t REFCOL_WIDTH, *what ? what : \"HEAD\");\n\t\tif (*note) {\n\t\t\tif (verbosity >= 0 && !shown_url) {\n\t\t\t\tfprintf(stderr, \"From %.*s\\n\",\n\t\t\t\t\t\turl_len, url);\n\t\t\t\tshown_url = 1;\n\t\t\t}\n\t\t\tif (verbosity >= 0)\n\t\t\t\tfprintf(stderr, \" %s\\n\", note);\n\t\t}\n\t}\n\tfree(url);\n\tfclose(fp);\n\tif (rc & STORE_REF_ERROR_DF_CONFLICT)\n\t\terror(\"some local refs could not be updated; try running\\n\"\n\t\t      \" 'git remote prune %s' to remove any old, conflicting \"\n\t\t      \"branches\", remote_name);\n\treturn rc;\n}\n\n/*\n * We would want to bypass the object transfer altogether if\n * everything we are going to fetch already exists and is connected\n * locally.\n *\n * The refs we are going to fetch are in ref_map.  If running\n *\n *  $ git rev-list --objects --stdin --not --all\n *\n * (feeding all the refs in ref_map on its standard input)\n * does not error out, that means everything reachable from the\n * refs we are going to fetch exists and is connected to some of\n * our existing refs.\n */\nstatic int quickfetch(struct ref *ref_map)\n{\n\tstruct child_process revlist;\n\tstruct ref *ref;\n\tint err;\n\tconst char *argv[] = {\"rev-list\",\n\t\t\"--quiet\", \"--objects\", \"--stdin\", \"--not\", \"--all\", NULL};\n\n\t/*\n\t * If we are deepening a shallow clone we already have these\n\t * objects reachable.  Running rev-list here will return with\n\t * a good (0) exit status and we'll bypass the fetch that we\n\t * really need to perform.  Claiming failure now will ensure\n\t * we perform the network exchange to deepen our history.\n\t */\n\tif (depth)\n\t\treturn -1;\n\n\tif (!ref_map)\n\t\treturn 0;\n\n\tmemset(&revlist, 0, sizeof(revlist));\n\trevlist.argv = argv;\n\trevlist.git_cmd = 1;\n\trevlist.no_stdout = 1;\n\trevlist.no_stderr = 1;\n\trevlist.in = -1;\n\n\terr = start_command(&revlist);\n\tif (err) {\n\t\terror(\"could not run rev-list\");\n\t\treturn err;\n\t}\n\n\t/*\n\t * If rev-list --stdin encounters an unknown commit, it terminates,\n\t * which will cause SIGPIPE in the write loop below.\n\t */\n\tsigchain_push(SIGPIPE, SIG_IGN);\n\n\tfor (ref = ref_map; ref; ref = ref->next) {\n\t\tif (write_in_full(revlist.in, sha1_to_hex(ref->old_sha1), 40) < 0 ||\n\t\t    write_str_in_full(revlist.in, \"\\n\") < 0) {\n\t\t\tif (errno != EPIPE && errno != EINVAL)\n\t\t\t\terror(\"failed write to rev-list: %s\", strerror(errno));\n\t\t\terr = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (close(revlist.in)) {\n\t\terror(\"failed to close rev-list's stdin: %s\", strerror(errno));\n\t\terr = -1;\n\t}\n\n\tsigchain_pop(SIGPIPE);\n\n\treturn finish_command(&revlist) || err;\n}\n\nstatic int fetch_refs(struct transport *transport, struct ref *ref_map)\n{\n\tint ret = quickfetch(ref_map);\n\tif (ret)\n\t\tret = transport_fetch_refs(transport, ref_map);\n\tif (!ret)\n\t\tret |= store_updated_refs(transport->url,\n\t\t\t\ttransport->remote->name,\n\t\t\t\tref_map);\n\ttransport_unlock_pack(transport);\n\treturn ret;\n}\n\nstatic int prune_refs(struct transport *transport, struct ref *ref_map)\n{\n\tint result = 0;\n\tstruct ref *ref, *stale_refs = get_stale_heads(transport->remote, ref_map);\n\tconst char *dangling_msg = dry_run\n\t\t? \"   (%s will become dangling)\\n\"\n\t\t: \"   (%s has become dangling)\\n\";\n\n\tfor (ref = stale_refs; ref; ref = ref->next) {\n\t\tif (!dry_run)\n\t\t\tresult |= delete_ref(ref->name, NULL, 0);\n\t\tif (verbosity >= 0) {\n\t\t\tfprintf(stderr, \" x %-*s %-*s -> %s\\n\",\n\t\t\t\tSUMMARY_WIDTH, \"[deleted]\",\n\t\t\t\tREFCOL_WIDTH, \"(none)\", prettify_refname(ref->name));\n\t\t\twarn_dangling_symref(stderr, dangling_msg, ref->name);\n\t\t}\n\t}\n\tfree_refs(stale_refs);\n\treturn result;\n}\n\nstatic int add_existing(const char *refname, const unsigned char *sha1,\n\t\t\tint flag, void *cbdata)\n{\n\tstruct string_list *list = (struct string_list *)cbdata;\n\tstruct string_list_item *item = string_list_insert(refname, list);\n\titem->util = (void *)sha1;\n\treturn 0;\n}\n\nstatic int will_fetch(struct ref **head, const unsigned char *sha1)\n{\n\tstruct ref *rm = *head;\n\twhile (rm) {\n\t\tif (!hashcmp(rm->old_sha1, sha1))\n\t\t\treturn 1;\n\t\trm = rm->next;\n\t}\n\treturn 0;\n}\n\nstruct tag_data {\n\tstruct ref **head;\n\tstruct ref ***tail;\n};\n\nstatic int add_to_tail(struct string_list_item *item, void *cb_data)\n{\n\tstruct tag_data *data = (struct tag_data *)cb_data;\n\tstruct ref *rm = NULL;\n\n\t/* We have already decided to ignore this item */\n\tif (!item->util)\n\t\treturn 0;\n\n\trm = alloc_ref(item->string);\n\trm->peer_ref = alloc_ref(item->string);\n\thashcpy(rm->old_sha1, item->util);\n\n\t**data->tail = rm;\n\t*data->tail = &rm->next;\n\n\treturn 0;\n}\n\nstatic void find_non_local_tags(struct transport *transport,\n\t\t\tstruct ref **head,\n\t\t\tstruct ref ***tail)\n{\n\tstruct string_list existing_refs = { NULL, 0, 0, 0 };\n\tstruct string_list remote_refs = { NULL, 0, 0, 0 };\n\tstruct tag_data data = {head, tail};\n\tconst struct ref *ref;\n\tstruct string_list_item *item = NULL;\n\n\tfor_each_ref(add_existing, &existing_refs);\n\tfor (ref = transport_get_remote_refs(transport); ref; ref = ref->next) {\n\t\tif (prefixcmp(ref->name, \"refs/tags\"))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * The peeled ref always follows the matching base\n\t\t * ref, so if we see a peeled ref that we don't want\n\t\t * to fetch then we can mark the ref entry in the list\n\t\t * as one to ignore by setting util to NULL.\n\t\t */\n\t\tif (!suffixcmp(ref->name, \"^{}\")) {\n\t\t\tif (item && !has_sha1_file(ref->old_sha1) &&\n\t\t\t    !will_fetch(head, ref->old_sha1) &&\n\t\t\t    !has_sha1_file(item->util) &&\n\t\t\t    !will_fetch(head, item->util))\n\t\t\t\titem->util = NULL;\n\t\t\titem = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If item is non-NULL here, then we previously saw a\n\t\t * ref not followed by a peeled reference, so we need\n\t\t * to check if it is a lightweight tag that we want to\n\t\t * fetch.\n\t\t */\n\t\tif (item && !has_sha1_file(item->util) &&\n\t\t    !will_fetch(head, item->util))\n\t\t\titem->util = NULL;\n\n\t\titem = NULL;\n\n\t\t/* skip duplicates and refs that we already have */\n\t\tif (string_list_has_string(&remote_refs, ref->name) ||\n\t\t    string_list_has_string(&existing_refs, ref->name))\n\t\t\tcontinue;\n\n\t\titem = string_list_insert(ref->name, &remote_refs);\n\t\titem->util = (void *)ref->old_sha1;\n\t}\n\tstring_list_clear(&existing_refs, 0);\n\n\t/*\n\t * We may have a final lightweight tag that needs to be\n\t * checked to see if it needs fetching.\n\t */\n\tif (item && !has_sha1_file(item->util) &&\n\t    !will_fetch(head, item->util))\n\t\titem->util = NULL;\n\n\t/*\n\t * For all the tags in the remote_refs string list, call\n\t * add_to_tail to add them to the list of refs to be fetched\n\t */\n\tfor_each_string_list(add_to_tail, &remote_refs, &data);\n\n\tstring_list_clear(&remote_refs, 0);\n}\n\nstatic void check_not_current_branch(struct ref *ref_map)\n{\n\tstruct branch *current_branch = branch_get(NULL);\n\n\tif (is_bare_repository() || !current_branch)\n\t\treturn;\n\n\tfor (; ref_map; ref_map = ref_map->next)\n\t\tif (ref_map->peer_ref && !strcmp(current_branch->refname,\n\t\t\t\t\tref_map->peer_ref->name))\n\t\t\tdie(\"Refusing to fetch into current branch %s \"\n\t\t\t    \"of non-bare repository\", current_branch->refname);\n}\n\nstatic int truncate_fetch_head(void)\n{\n\tchar *filename = git_path(\"FETCH_HEAD\");\n\tFILE *fp = fopen(filename, \"w\");\n\n\tif (!fp)\n\t\treturn error(\"cannot open %s: %s\\n\", filename, strerror(errno));\n\tfclose(fp);\n\treturn 0;\n}\n\nstatic int do_fetch(struct transport *transport,\n\t\t    struct refspec *refs, int ref_count)\n{\n\tstruct string_list existing_refs = { NULL, 0, 0, 0 };\n\tstruct string_list_item *peer_item = NULL;\n\tstruct ref *ref_map;\n\tstruct ref *rm;\n\tint autotags = (transport->remote->fetch_tags == 1);\n\n\tfor_each_ref(add_existing, &existing_refs);\n\n\tif (transport->remote->fetch_tags == 2 && tags != TAGS_UNSET)\n\t\ttags = TAGS_SET;\n\tif (transport->remote->fetch_tags == -1)\n\t\ttags = TAGS_UNSET;\n\n\tif (!transport->get_refs_list || !transport->fetch)\n\t\tdie(\"Don't know how to fetch from %s\", transport->url);\n\n\t/* if not appending, truncate FETCH_HEAD */\n\tif (!append && !dry_run) {\n\t\tint errcode = truncate_fetch_head();\n\t\tif (errcode)\n\t\t\treturn errcode;\n\t}\n\n\tref_map = get_ref_map(transport, refs, ref_count, tags, &autotags);\n\tif (!update_head_ok)\n\t\tcheck_not_current_branch(ref_map);\n\n\tfor (rm = ref_map; rm; rm = rm->next) {\n\t\tif (rm->peer_ref) {\n\t\t\tpeer_item = string_list_lookup(rm->peer_ref->name,\n\t\t\t\t\t\t       &existing_refs);\n\t\t\tif (peer_item)\n\t\t\t\thashcpy(rm->peer_ref->old_sha1,\n\t\t\t\t\tpeer_item->util);\n\t\t}\n\t}\n\n\tif (tags == TAGS_DEFAULT && autotags)\n\t\ttransport_set_option(transport, TRANS_OPT_FOLLOWTAGS, \"1\");\n\tif (fetch_refs(transport, ref_map)) {\n\t\tfree_refs(ref_map);\n\t\treturn 1;\n\t}\n\tif (prune)\n\t\tprune_refs(transport, ref_map);\n\tfree_refs(ref_map);\n\n\t/* if neither --no-tags nor --tags was specified, do automated tag\n\t * following ... */\n\tif (tags == TAGS_DEFAULT && autotags) {\n\t\tstruct ref **tail = &ref_map;\n\t\tref_map = NULL;\n\t\tfind_non_local_tags(transport, &ref_map, &tail);\n\t\tif (ref_map) {\n\t\t\ttransport_set_option(transport, TRANS_OPT_FOLLOWTAGS, NULL);\n\t\t\ttransport_set_option(transport, TRANS_OPT_DEPTH, \"0\");\n\t\t\tfetch_refs(transport, ref_map);\n\t\t}\n\t\tfree_refs(ref_map);\n\t}\n\n\treturn 0;\n}\n\nstatic void set_option(const char *name, const char *value)\n{\n\tint r = transport_set_option(transport, name, value);\n\tif (r < 0)\n\t\tdie(\"Option \\\"%s\\\" value \\\"%s\\\" is not valid for %s\",\n\t\t\tname, value, transport->url);\n\tif (r > 0)\n\t\twarning(\"Option \\\"%s\\\" is ignored for %s\\n\",\n\t\t\tname, transport->url);\n}\n\nstatic int get_one_remote_for_fetch(struct remote *remote, void *priv)\n{\n\tstruct string_list *list = priv;\n\tif (!remote->skip_default_update)\n\t\tstring_list_append(remote->name, list);\n\treturn 0;\n}\n\nstruct remote_group_data {\n\tconst char *name;\n\tstruct string_list *list;\n};\n\nstatic int get_remote_group(const char *key, const char *value, void *priv)\n{\n\tstruct remote_group_data *g = priv;\n\n\tif (!prefixcmp(key, \"remotes.\") &&\n\t\t\t!strcmp(key + 8, g->name)) {\n\t\t/* split list by white space */\n\t\tint space = strcspn(value, \" \\t\\n\");\n\t\twhile (*value) {\n\t\t\tif (space > 1) {\n\t\t\t\tstring_list_append(xstrndup(value, space),\n\t\t\t\t\t\t   g->list);\n\t\t\t}\n\t\t\tvalue += space + (value[space] != '\\0');\n\t\t\tspace = strcspn(value, \" \\t\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int add_remote_or_group(const char *name, struct string_list *list)\n{\n\tint prev_nr = list->nr;\n\tstruct remote_group_data g = { name, list };\n\n\tgit_config(get_remote_group, &g);\n\tif (list->nr == prev_nr) {\n\t\tstruct remote *remote;\n\t\tif (!remote_is_configured(name))\n\t\t\treturn 0;\n\t\tremote = remote_get(name);\n\t\tstring_list_append(remote->name, list);\n\t}\n\treturn 1;\n}\n\nstatic int fetch_multiple(struct string_list *list)\n{\n\tint i, result = 0;\n\tconst char *argv[11] = { \"fetch\", \"--append\" };\n\tint argc = 2;\n\n\tif (dry_run)\n\t\targv[argc++] = \"--dry-run\";\n\tif (prune)\n\t\targv[argc++] = \"--prune\";\n\tif (update_head_ok)\n\t\targv[argc++] = \"--update-head-ok\";\n\tif (force)\n\t\targv[argc++] = \"--force\";\n\tif (keep)\n\t\targv[argc++] = \"--keep\";\n\tif (verbosity >= 2)\n\t\targv[argc++] = \"-v\";\n\tif (verbosity >= 1)\n\t\targv[argc++] = \"-v\";\n\telse if (verbosity < 0)\n\t\targv[argc++] = \"-q\";\n\n\tif (!append && !dry_run) {\n\t\tint errcode = truncate_fetch_head();\n\t\tif (errcode)\n\t\t\treturn errcode;\n\t}\n\n\tfor (i = 0; i < list->nr; i++) {\n\t\tconst char *name = list->items[i].string;\n\t\targv[argc] = name;\n\t\targv[argc + 1] = NULL;\n\t\tif (verbosity >= 0)\n\t\t\tprintf(\"Fetching %s\\n\", name);\n\t\tif (run_command_v_opt(argv, RUN_GIT_CMD)) {\n\t\t\terror(\"Could not fetch %s\", name);\n\t\t\tresult = 1;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nstatic int fetch_one(struct remote *remote, int argc, const char **argv)\n{\n\tint i;\n\tstatic const char **refs = NULL;\n\tint ref_nr = 0;\n\tint exit_code;\n\n\tif (!remote)\n\t\tdie(\"Where do you want to fetch from today?\");\n\n\ttransport = transport_get(remote, NULL);\n\tif (verbosity >= 2)\n\t\ttransport->verbose = verbosity <= 3 ? verbosity : 3;\n\tif (verbosity < 0)\n\t\ttransport->verbose = -1;\n\tif (upload_pack)\n\t\tset_option(TRANS_OPT_UPLOADPACK, upload_pack);\n\tif (keep)\n\t\tset_option(TRANS_OPT_KEEP, \"yes\");\n\tif (depth)\n\t\tset_option(TRANS_OPT_DEPTH, depth);\n\n\tif (argc > 0) {\n\t\tint j = 0;\n\t\trefs = xcalloc(argc + 1, sizeof(const char *));\n\t\tfor (i = 0; i < argc; i++) {\n\t\t\tif (!strcmp(argv[i], \"tag\")) {\n\t\t\t\tchar *ref;\n\t\t\t\ti++;\n\t\t\t\tif (i >= argc)\n\t\t\t\t\tdie(\"You need to specify a tag name.\");\n\t\t\t\tref = xmalloc(strlen(argv[i]) * 2 + 22);\n\t\t\t\tstrcpy(ref, \"refs/tags/\");\n\t\t\t\tstrcat(ref, argv[i]);\n\t\t\t\tstrcat(ref, \":refs/tags/\");\n\t\t\t\tstrcat(ref, argv[i]);\n\t\t\t\trefs[j++] = ref;\n\t\t\t} else\n\t\t\t\trefs[j++] = argv[i];\n\t\t}\n\t\trefs[j] = NULL;\n\t\tref_nr = j;\n\t}\n\n\tsigchain_push_common(unlock_pack_on_signal);\n\tatexit(unlock_pack);\n\texit_code = do_fetch(transport,\n\t\t\tparse_fetch_refspec(ref_nr, refs), ref_nr);\n\ttransport_disconnect(transport);\n\ttransport = NULL;\n\treturn exit_code;\n}\n\nint cmd_fetch(int argc, const char **argv, const char *prefix)\n{\n\tint i;\n\tstruct string_list list = { NULL, 0, 0, 0 };\n\tstruct remote *remote;\n\tint result = 0;\n\n\t/* Record the command line for the reflog */\n\tstrbuf_addstr(&default_rla, \"fetch\");\n\tfor (i = 1; i < argc; i++)\n\t\tstrbuf_addf(&default_rla, \" %s\", argv[i]);\n\n\targc = parse_options(argc, argv, prefix,\n\t\t\t     builtin_fetch_options, builtin_fetch_usage, 0);\n\n\tif (all) {\n\t\tif (argc == 1)\n\t\t\tdie(\"fetch --all does not take a repository argument\");\n\t\telse if (argc > 1)\n\t\t\tdie(\"fetch --all does not make sense with refspecs\");\n\t\t(void) for_each_remote(get_one_remote_for_fetch, &list);\n\t\tresult = fetch_multiple(&list);\n\t} else if (argc == 0) {\n\t\t/* No arguments -- use default remote */\n\t\tremote = remote_get(NULL);\n\t\tresult = fetch_one(remote, argc, argv);\n\t} else if (multiple) {\n\t\t/* All arguments are assumed to be remotes or groups */\n\t\tfor (i = 0; i < argc; i++)\n\t\t\tif (!add_remote_or_group(argv[i], &list))\n\t\t\t\tdie(\"No such remote or remote group: %s\", argv[i]);\n\t\tresult = fetch_multiple(&list);\n\t} else {\n\t\t/* Single remote or group */\n\t\t(void) add_remote_or_group(argv[0], &list);\n\t\tif (list.nr > 1) {\n\t\t\t/* More than one remote */\n\t\t\tif (argc > 1)\n\t\t\t\tdie(\"Fetching a group and specifying refspecs does not make sense\");\n\t\t\tresult = fetch_multiple(&list);\n\t\t} else {\n\t\t\t/* Zero or one remotes */\n\t\t\tremote = remote_get(argv[0]);\n\t\t\tresult = fetch_one(remote, argc-1, argv+1);\n\t\t}\n\t}\n\n\t/* All names were strdup()ed or strndup()ed */\n\tlist.strdup_strings = 1;\n\tstring_list_clear(&list, 0);\n\n\treturn result;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "007dabf62f2574fc9214d6fb2a961619ad305a6b",
  "sha1_ok": true,
  "size": 25022
}
