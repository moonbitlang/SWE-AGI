{
  "content": {
    "base64": "I2luY2x1ZGUgImJ1aWx0aW4uaCIKI2luY2x1ZGUgImNvbmZpZy5oIgojaW5jbHVkZSAiZGVsdGEuaCIKI2luY2x1ZGUgInBhY2suaCIKI2luY2x1ZGUgImNzdW0tZmlsZS5oIgojaW5jbHVkZSAiYmxvYi5oIgojaW5jbHVkZSAiY29tbWl0LmgiCiNpbmNsdWRlICJ0YWcuaCIKI2luY2x1ZGUgInRyZWUuaCIKI2luY2x1ZGUgInByb2dyZXNzLmgiCiNpbmNsdWRlICJmc2NrLmgiCiNpbmNsdWRlICJleGVjLWNtZC5oIgojaW5jbHVkZSAic3RyZWFtaW5nLmgiCiNpbmNsdWRlICJ0aHJlYWQtdXRpbHMuaCIKI2luY2x1ZGUgInBhY2tmaWxlLmgiCiNpbmNsdWRlICJvYmplY3Qtc3RvcmUuaCIKI2luY2x1ZGUgInByb21pc29yLXJlbW90ZS5oIgoKc3RhdGljIGNvbnN0IGNoYXIgaW5kZXhfcGFja191c2FnZVtdID0KImdpdCBpbmRleC1wYWNrIFstdl0gWy1vIDxpbmRleC1maWxlPl0gWy0ta2VlcCB8IC0ta2VlcD08bXNnPl0gWy0tW25vLV1yZXYtaW5kZXhdIFstLXZlcmlmeV0gWy0tc3RyaWN0XSAoPHBhY2stZmlsZT4gfCAtLXN0ZGluIFstLWZpeC10aGluXSBbPHBhY2stZmlsZT5dKSI7CgpzdHJ1Y3Qgb2JqZWN0X2VudHJ5IHsKCXN0cnVjdCBwYWNrX2lkeF9lbnRyeSBpZHg7Cgl1bnNpZ25lZCBsb25nIHNpemU7Cgl1bnNpZ25lZCBjaGFyIGhkcl9zaXplOwoJc2lnbmVkIGNoYXIgdHlwZTsKCXNpZ25lZCBjaGFyIHJlYWxfdHlwZTsKfTsKCnN0cnVjdCBvYmplY3Rfc3RhdCB7Cgl1bnNpZ25lZCBkZWx0YV9kZXB0aDsKCWludCBiYXNlX29iamVjdF9ubzsKfTsKCnN0cnVjdCBiYXNlX2RhdGEgewoJLyogSW5pdGlhbGl6ZWQgYnkgbWFrZV9iYXNlKCkuICovCglzdHJ1Y3QgYmFzZV9kYXRhICpiYXNlOwoJc3RydWN0IG9iamVjdF9lbnRyeSAqb2JqOwoJaW50IHJlZl9maXJzdCwgcmVmX2xhc3Q7CglpbnQgb2ZzX2ZpcnN0LCBvZnNfbGFzdDsKCS8qCgkgKiBUaHJlYWRzIHNob3VsZCBpbmNyZW1lbnQgcmV0YWluX2RhdGEgaWYgdGhleSBhcmUgYWJvdXQgdG8gY2FsbAoJICogcGF0Y2hfZGVsdGEoKSB1c2luZyB0aGlzIHN0cnVjdCdzIGRhdGEgYXMgYSBiYXNlLCBhbmQgZGVjcmVtZW50IHRoaXMKCSAqIHdoZW4gdGhleSBhcmUgZG9uZS4gV2hpbGUgcmV0YWluX2RhdGEgaXMgbm9uemVybywgdGhpcyBzdHJ1Y3QncyBkYXRhCgkgKiB3aWxsIG5vdCBiZSBmcmVlZCBldmVuIGlmIHRoZSBkZWx0YSBiYXNlIGNhY2hlIGxpbWl0IGlzIGV4Y2VlZGVkLgoJICovCglpbnQgcmV0YWluX2RhdGE7CgkvKgoJICogVGhlIG51bWJlciBvZiBkaXJlY3QgY2hpbGRyZW4gdGhhdCBoYXZlIG5vdCBiZWVuIGZ1bGx5IHByb2Nlc3NlZAoJICogKGVudGVyZWQgd29ya19oZWFkLCBlbnRlcmVkIGRvbmVfaGVhZCwgbGVmdCBkb25lX2hlYWQpLiBXaGVuIHRoaXMKCSAqIG51bWJlciByZWFjaGVzIHplcm8sIHRoaXMgc3RydWN0IGJhc2VfZGF0YSBjYW4gYmUgZnJlZWQuCgkgKi8KCWludCBjaGlsZHJlbl9yZW1haW5pbmc7CgoJLyogTm90IGluaXRpYWxpemVkIGJ5IG1ha2VfYmFzZSgpLiAqLwoJc3RydWN0IGxpc3RfaGVhZCBsaXN0OwoJdm9pZCAqZGF0YTsKCXVuc2lnbmVkIGxvbmcgc2l6ZTsKfTsKCi8qCiAqIFN0YWNrIG9mIHN0cnVjdCBiYXNlX2RhdGEgdGhhdCBoYXZlIHVucHJvY2Vzc2VkIGNoaWxkcmVuLgogKiB0aHJlYWRlZF9zZWNvbmRfcGFzcygpIHVzZXMgdGhpcyBhcyBhIHNvdXJjZSBvZiB3b3JrICh0aGUgb3RoZXIgYmVpbmcgdGhlCiAqIG9iamVjdHMgYXJyYXkpLgogKgogKiBHdWFyZGVkIGJ5IHdvcmtfbXV0ZXguCiAqLwpzdGF0aWMgTElTVF9IRUFEKHdvcmtfaGVhZCk7CgovKgogKiBTdGFjayBvZiBzdHJ1Y3QgYmFzZV9kYXRhIHRoYXQgaGF2ZSBjaGlsZHJlbiwgYWxsIG9mIHdob20gaGF2ZSBiZWVuCiAqIHByb2Nlc3NlZCBvciBhcmUgYmVpbmcgcHJvY2Vzc2VkLCBhbmQgYXQgbGVhc3Qgb25lIGNoaWxkIGlzIGJlaW5nIHByb2Nlc3NlZC4KICogVGhlc2Ugc3RydWN0IGJhc2VfZGF0YSBtdXN0IGJlIGtlcHQgYXJvdW5kIHVudGlsIHRoZSBsYXN0IGNoaWxkIGlzCiAqIHByb2Nlc3NlZC4KICoKICogR3VhcmRlZCBieSB3b3JrX211dGV4LgogKi8Kc3RhdGljIExJU1RfSEVBRChkb25lX2hlYWQpOwoKLyoKICogQWxsIHRocmVhZHMgc2hhcmUgb25lIGRlbHRhIGJhc2UgY2FjaGUuCiAqCiAqIGJhc2VfY2FjaGVfdXNlZCBpcyBndWFyZGVkIGJ5IHdvcmtfbXV0ZXgsIGFuZCBiYXNlX2NhY2hlX2xpbWl0IGlzIHJlYWQtb25seQogKiBpbiBhIHRocmVhZC4KICovCnN0YXRpYyBzaXplX3QgYmFzZV9jYWNoZV91c2VkOwpzdGF0aWMgc2l6ZV90IGJhc2VfY2FjaGVfbGltaXQ7CgpzdHJ1Y3QgdGhyZWFkX2xvY2FsIHsKCXB0aHJlYWRfdCB0aHJlYWQ7CglpbnQgcGFja19mZDsKfTsKCi8qIFJlbWVtYmVyIHRvIHVwZGF0ZSBvYmplY3QgZmxhZyBhbGxvY2F0aW9uIGluIG9iamVjdC5oICovCiNkZWZpbmUgRkxBR19MSU5LICgxdTw8MjApCiNkZWZpbmUgRkxBR19DSEVDS0VEICgxdTw8MjEpCgpzdHJ1Y3Qgb2ZzX2RlbHRhX2VudHJ5IHsKCW9mZl90IG9mZnNldDsKCWludCBvYmpfbm87Cn07CgpzdHJ1Y3QgcmVmX2RlbHRhX2VudHJ5IHsKCXN0cnVjdCBvYmplY3RfaWQgb2lkOwoJaW50IG9ial9ubzsKfTsKCnN0YXRpYyBzdHJ1Y3Qgb2JqZWN0X2VudHJ5ICpvYmplY3RzOwpzdGF0aWMgc3RydWN0IG9iamVjdF9zdGF0ICpvYmpfc3RhdDsKc3RhdGljIHN0cnVjdCBvZnNfZGVsdGFfZW50cnkgKm9mc19kZWx0YXM7CnN0YXRpYyBzdHJ1Y3QgcmVmX2RlbHRhX2VudHJ5ICpyZWZfZGVsdGFzOwpzdGF0aWMgc3RydWN0IHRocmVhZF9sb2NhbCBub3RocmVhZF9kYXRhOwpzdGF0aWMgaW50IG5yX29iamVjdHM7CnN0YXRpYyBpbnQgbnJfb2ZzX2RlbHRhczsKc3RhdGljIGludCBucl9yZWZfZGVsdGFzOwpzdGF0aWMgaW50IHJlZl9kZWx0YXNfYWxsb2M7CnN0YXRpYyBpbnQgbnJfcmVzb2x2ZWRfZGVsdGFzOwpzdGF0aWMgaW50IG5yX3RocmVhZHM7CgpzdGF0aWMgaW50IGZyb21fc3RkaW47CnN0YXRpYyBpbnQgc3RyaWN0OwpzdGF0aWMgaW50IGRvX2ZzY2tfb2JqZWN0OwpzdGF0aWMgc3RydWN0IGZzY2tfb3B0aW9ucyBmc2NrX29wdGlvbnMgPSBGU0NLX09QVElPTlNfTUlTU0lOR19HSVRNT0RVTEVTOwpzdGF0aWMgaW50IHZlcmJvc2U7CnN0YXRpYyBjb25zdCBjaGFyICpwcm9ncmVzc190aXRsZTsKc3RhdGljIGludCBzaG93X3Jlc29sdmluZ19wcm9ncmVzczsKc3RhdGljIGludCBzaG93X3N0YXQ7CnN0YXRpYyBpbnQgY2hlY2tfc2VsZl9jb250YWluZWRfYW5kX2Nvbm5lY3RlZDsKCnN0YXRpYyBzdHJ1Y3QgcHJvZ3Jlc3MgKnByb2dyZXNzOwoKLyogV2UgYWx3YXlzIHJlYWQgaW4gNGtCIGNodW5rcy4gKi8Kc3RhdGljIHVuc2lnbmVkIGNoYXIgaW5wdXRfYnVmZmVyWzQwOTZdOwpzdGF0aWMgdW5zaWduZWQgaW50IGlucHV0X29mZnNldCwgaW5wdXRfbGVuOwpzdGF0aWMgb2ZmX3QgY29uc3VtZWRfYnl0ZXM7CnN0YXRpYyBvZmZfdCBtYXhfaW5wdXRfc2l6ZTsKc3RhdGljIHVuc2lnbmVkIGRlZXBlc3RfZGVsdGE7CnN0YXRpYyBnaXRfaGFzaF9jdHggaW5wdXRfY3R4OwpzdGF0aWMgdWludDMyX3QgaW5wdXRfY3JjMzI7CnN0YXRpYyBpbnQgaW5wdXRfZmQsIG91dHB1dF9mZDsKc3RhdGljIGNvbnN0IGNoYXIgKmN1cnJfcGFjazsKCnN0YXRpYyBzdHJ1Y3QgdGhyZWFkX2xvY2FsICp0aHJlYWRfZGF0YTsKc3RhdGljIGludCBucl9kaXNwYXRjaGVkOwpzdGF0aWMgaW50IHRocmVhZHNfYWN0aXZlOwoKc3RhdGljIHB0aHJlYWRfbXV0ZXhfdCByZWFkX211dGV4OwojZGVmaW5lIHJlYWRfbG9jaygpCQlsb2NrX211dGV4KCZyZWFkX211dGV4KQojZGVmaW5lIHJlYWRfdW5sb2NrKCkJCXVubG9ja19tdXRleCgmcmVhZF9tdXRleCkKCnN0YXRpYyBwdGhyZWFkX211dGV4X3QgY291bnRlcl9tdXRleDsKI2RlZmluZSBjb3VudGVyX2xvY2soKQkJbG9ja19tdXRleCgmY291bnRlcl9tdXRleCkKI2RlZmluZSBjb3VudGVyX3VubG9jaygpCXVubG9ja19tdXRleCgmY291bnRlcl9tdXRleCkKCnN0YXRpYyBwdGhyZWFkX211dGV4X3Qgd29ya19tdXRleDsKI2RlZmluZSB3b3JrX2xvY2soKQkJbG9ja19tdXRleCgmd29ya19tdXRleCkKI2RlZmluZSB3b3JrX3VubG9jaygpCQl1bmxvY2tfbXV0ZXgoJndvcmtfbXV0ZXgpCgpzdGF0aWMgcHRocmVhZF9tdXRleF90IGRlZXBlc3RfZGVsdGFfbXV0ZXg7CiNkZWZpbmUgZGVlcGVzdF9kZWx0YV9sb2NrKCkJbG9ja19tdXRleCgmZGVlcGVzdF9kZWx0YV9tdXRleCkKI2RlZmluZSBkZWVwZXN0X2RlbHRhX3VubG9jaygpCXVubG9ja19tdXRleCgmZGVlcGVzdF9kZWx0YV9tdXRleCkKCnN0YXRpYyBwdGhyZWFkX2tleV90IGtleTsKCnN0YXRpYyBpbmxpbmUgdm9pZCBsb2NrX211dGV4KHB0aHJlYWRfbXV0ZXhfdCAqbXV0ZXgpCnsKCWlmICh0aHJlYWRzX2FjdGl2ZSkKCQlwdGhyZWFkX211dGV4X2xvY2sobXV0ZXgpOwp9CgpzdGF0aWMgaW5saW5lIHZvaWQgdW5sb2NrX211dGV4KHB0aHJlYWRfbXV0ZXhfdCAqbXV0ZXgpCnsKCWlmICh0aHJlYWRzX2FjdGl2ZSkKCQlwdGhyZWFkX211dGV4X3VubG9jayhtdXRleCk7Cn0KCi8qCiAqIE11dGV4IGFuZCBjb25kaXRpb25hbCB2YXJpYWJsZSBjYW4ndCBiZSBzdGF0aWNhbGx5LWluaXRpYWxpemVkIG9uIFdpbmRvd3MuCiAqLwpzdGF0aWMgdm9pZCBpbml0X3RocmVhZCh2b2lkKQp7CglpbnQgaTsKCWluaXRfcmVjdXJzaXZlX211dGV4KCZyZWFkX211dGV4KTsKCXB0aHJlYWRfbXV0ZXhfaW5pdCgmY291bnRlcl9tdXRleCwgTlVMTCk7CglwdGhyZWFkX211dGV4X2luaXQoJndvcmtfbXV0ZXgsIE5VTEwpOwoJaWYgKHNob3dfc3RhdCkKCQlwdGhyZWFkX211dGV4X2luaXQoJmRlZXBlc3RfZGVsdGFfbXV0ZXgsIE5VTEwpOwoJcHRocmVhZF9rZXlfY3JlYXRlKCZrZXksIE5VTEwpOwoJQ0FMTE9DX0FSUkFZKHRocmVhZF9kYXRhLCBucl90aHJlYWRzKTsKCWZvciAoaSA9IDA7IGkgPCBucl90aHJlYWRzOyBpKyspIHsKCQl0aHJlYWRfZGF0YVtpXS5wYWNrX2ZkID0geG9wZW4oY3Vycl9wYWNrLCBPX1JET05MWSk7Cgl9CgoJdGhyZWFkc19hY3RpdmUgPSAxOwp9CgpzdGF0aWMgdm9pZCBjbGVhbnVwX3RocmVhZCh2b2lkKQp7CglpbnQgaTsKCWlmICghdGhyZWFkc19hY3RpdmUpCgkJcmV0dXJuOwoJdGhyZWFkc19hY3RpdmUgPSAwOwoJcHRocmVhZF9tdXRleF9kZXN0cm95KCZyZWFkX211dGV4KTsKCXB0aHJlYWRfbXV0ZXhfZGVzdHJveSgmY291bnRlcl9tdXRleCk7CglwdGhyZWFkX211dGV4X2Rlc3Ryb3koJndvcmtfbXV0ZXgpOwoJaWYgKHNob3dfc3RhdCkKCQlwdGhyZWFkX211dGV4X2Rlc3Ryb3koJmRlZXBlc3RfZGVsdGFfbXV0ZXgpOwoJZm9yIChpID0gMDsgaSA8IG5yX3RocmVhZHM7IGkrKykKCQljbG9zZSh0aHJlYWRfZGF0YVtpXS5wYWNrX2ZkKTsKCXB0aHJlYWRfa2V5X2RlbGV0ZShrZXkpOwoJZnJlZSh0aHJlYWRfZGF0YSk7Cn0KCnN0YXRpYyBpbnQgbWFya19saW5rKHN0cnVjdCBvYmplY3QgKm9iaiwgZW51bSBvYmplY3RfdHlwZSB0eXBlLAoJCSAgICAgdm9pZCAqZGF0YSwgc3RydWN0IGZzY2tfb3B0aW9ucyAqb3B0aW9ucykKewoJaWYgKCFvYmopCgkJcmV0dXJuIC0xOwoKCWlmICh0eXBlICE9IE9CSl9BTlkgJiYgb2JqLT50eXBlICE9IHR5cGUpCgkJZGllKF8oIm9iamVjdCB0eXBlIG1pc21hdGNoIGF0ICVzIiksIG9pZF90b19oZXgoJm9iai0+b2lkKSk7CgoJb2JqLT5mbGFncyB8PSBGTEFHX0xJTks7CglyZXR1cm4gMDsKfQoKLyogVGhlIGNvbnRlbnQgb2YgZWFjaCBsaW5rZWQgb2JqZWN0IG11c3QgaGF2ZSBiZWVuIGNoZWNrZWQKICAgb3IgaXQgbXVzdCBiZSBhbHJlYWR5IHByZXNlbnQgaW4gdGhlIG9iamVjdCBkYXRhYmFzZSAqLwpzdGF0aWMgdW5zaWduZWQgY2hlY2tfb2JqZWN0KHN0cnVjdCBvYmplY3QgKm9iaikKewoJaWYgKCFvYmopCgkJcmV0dXJuIDA7CgoJaWYgKCEob2JqLT5mbGFncyAmIEZMQUdfTElOSykpCgkJcmV0dXJuIDA7CgoJaWYgKCEob2JqLT5mbGFncyAmIEZMQUdfQ0hFQ0tFRCkpIHsKCQl1bnNpZ25lZCBsb25nIHNpemU7CgkJaW50IHR5cGUgPSBvaWRfb2JqZWN0X2luZm8odGhlX3JlcG9zaXRvcnksICZvYmotPm9pZCwgJnNpemUpOwoJCWlmICh0eXBlIDw9IDApCgkJCWRpZShfKCJkaWQgbm90IHJlY2VpdmUgZXhwZWN0ZWQgb2JqZWN0ICVzIiksCgkJCSAgICAgIG9pZF90b19oZXgoJm9iai0+b2lkKSk7CgkJaWYgKHR5cGUgIT0gb2JqLT50eXBlKQoJCQlkaWUoXygib2JqZWN0ICVzOiBleHBlY3RlZCB0eXBlICVzLCBmb3VuZCAlcyIpLAoJCQkgICAgb2lkX3RvX2hleCgmb2JqLT5vaWQpLAoJCQkgICAgdHlwZV9uYW1lKG9iai0+dHlwZSksIHR5cGVfbmFtZSh0eXBlKSk7CgkJb2JqLT5mbGFncyB8PSBGTEFHX0NIRUNLRUQ7CgkJcmV0dXJuIDE7Cgl9CgoJcmV0dXJuIDA7Cn0KCnN0YXRpYyB1bnNpZ25lZCBjaGVja19vYmplY3RzKHZvaWQpCnsKCXVuc2lnbmVkIGksIG1heCwgZm9yZWlnbl9uciA9IDA7CgoJbWF4ID0gZ2V0X21heF9vYmplY3RfaW5kZXgoKTsKCglpZiAodmVyYm9zZSkKCQlwcm9ncmVzcyA9IHN0YXJ0X2RlbGF5ZWRfcHJvZ3Jlc3MoXygiQ2hlY2tpbmcgb2JqZWN0cyIpLCBtYXgpOwoKCWZvciAoaSA9IDA7IGkgPCBtYXg7IGkrKykgewoJCWZvcmVpZ25fbnIgKz0gY2hlY2tfb2JqZWN0KGdldF9pbmRleGVkX29iamVjdChpKSk7CgkJZGlzcGxheV9wcm9ncmVzcyhwcm9ncmVzcywgaSArIDEpOwoJfQoKCXN0b3BfcHJvZ3Jlc3MoJnByb2dyZXNzKTsKCXJldHVybiBmb3JlaWduX25yOwp9CgoKLyogRGlzY2FyZCBjdXJyZW50IGJ1ZmZlciB1c2VkIGNvbnRlbnQuICovCnN0YXRpYyB2b2lkIGZsdXNoKHZvaWQpCnsKCWlmIChpbnB1dF9vZmZzZXQpIHsKCQlpZiAob3V0cHV0X2ZkID49IDApCgkJCXdyaXRlX29yX2RpZShvdXRwdXRfZmQsIGlucHV0X2J1ZmZlciwgaW5wdXRfb2Zmc2V0KTsKCQl0aGVfaGFzaF9hbGdvLT51cGRhdGVfZm4oJmlucHV0X2N0eCwgaW5wdXRfYnVmZmVyLCBpbnB1dF9vZmZzZXQpOwoJCW1lbW1vdmUoaW5wdXRfYnVmZmVyLCBpbnB1dF9idWZmZXIgKyBpbnB1dF9vZmZzZXQsIGlucHV0X2xlbik7CgkJaW5wdXRfb2Zmc2V0ID0gMDsKCX0KfQoKLyoKICogTWFrZSBzdXJlIGF0IGxlYXN0ICJtaW4iIGJ5dGVzIGFyZSBhdmFpbGFibGUgaW4gdGhlIGJ1ZmZlciwgYW5kCiAqIHJldHVybiB0aGUgcG9pbnRlciB0byB0aGUgYnVmZmVyLgogKi8Kc3RhdGljIHZvaWQgKmZpbGwoaW50IG1pbikKewoJaWYgKG1pbiA8PSBpbnB1dF9sZW4pCgkJcmV0dXJuIGlucHV0X2J1ZmZlciArIGlucHV0X29mZnNldDsKCWlmIChtaW4gPiBzaXplb2YoaW5wdXRfYnVmZmVyKSkKCQlkaWUoUV8oImNhbm5vdCBmaWxsICVkIGJ5dGUiLAoJCSAgICAgICAiY2Fubm90IGZpbGwgJWQgYnl0ZXMiLAoJCSAgICAgICBtaW4pLAoJCSAgICBtaW4pOwoJZmx1c2goKTsKCWRvIHsKCQlzc2l6ZV90IHJldCA9IHhyZWFkKGlucHV0X2ZkLCBpbnB1dF9idWZmZXIgKyBpbnB1dF9sZW4sCgkJCQlzaXplb2YoaW5wdXRfYnVmZmVyKSAtIGlucHV0X2xlbik7CgkJaWYgKHJldCA8PSAwKSB7CgkJCWlmICghcmV0KQoJCQkJZGllKF8oImVhcmx5IEVPRiIpKTsKCQkJZGllX2Vycm5vKF8oInJlYWQgZXJyb3Igb24gaW5wdXQiKSk7CgkJfQoJCWlucHV0X2xlbiArPSByZXQ7CgkJaWYgKGZyb21fc3RkaW4pCgkJCWRpc3BsYXlfdGhyb3VnaHB1dChwcm9ncmVzcywgY29uc3VtZWRfYnl0ZXMgKyBpbnB1dF9sZW4pOwoJfSB3aGlsZSAoaW5wdXRfbGVuIDwgbWluKTsKCXJldHVybiBpbnB1dF9idWZmZXI7Cn0KCnN0YXRpYyB2b2lkIHVzZShpbnQgYnl0ZXMpCnsKCWlmIChieXRlcyA+IGlucHV0X2xlbikKCQlkaWUoXygidXNlZCBtb3JlIGJ5dGVzIHRoYW4gd2VyZSBhdmFpbGFibGUiKSk7CglpbnB1dF9jcmMzMiA9IGNyYzMyKGlucHV0X2NyYzMyLCBpbnB1dF9idWZmZXIgKyBpbnB1dF9vZmZzZXQsIGJ5dGVzKTsKCWlucHV0X2xlbiAtPSBieXRlczsKCWlucHV0X29mZnNldCArPSBieXRlczsKCgkvKiBtYWtlIHN1cmUgb2ZmX3QgaXMgc3VmZmljaWVudGx5IGxhcmdlIG5vdCB0byB3cmFwICovCglpZiAoc2lnbmVkX2FkZF9vdmVyZmxvd3MoY29uc3VtZWRfYnl0ZXMsIGJ5dGVzKSkKCQlkaWUoXygicGFjayB0b28gbGFyZ2UgZm9yIGN1cnJlbnQgZGVmaW5pdGlvbiBvZiBvZmZfdCIpKTsKCWNvbnN1bWVkX2J5dGVzICs9IGJ5dGVzOwoJaWYgKG1heF9pbnB1dF9zaXplICYmIGNvbnN1bWVkX2J5dGVzID4gbWF4X2lucHV0X3NpemUpIHsKCQlzdHJ1Y3Qgc3RyYnVmIHNpemVfbGltaXQgPSBTVFJCVUZfSU5JVDsKCQlzdHJidWZfaHVtYW5pc2VfYnl0ZXMoJnNpemVfbGltaXQsIG1heF9pbnB1dF9zaXplKTsKCQlkaWUoXygicGFjayBleGNlZWRzIG1heGltdW0gYWxsb3dlZCBzaXplICglcykiKSwKCQkgICAgc2l6ZV9saW1pdC5idWYpOwoJfQp9CgpzdGF0aWMgY29uc3QgY2hhciAqb3Blbl9wYWNrX2ZpbGUoY29uc3QgY2hhciAqcGFja19uYW1lKQp7CglpZiAoZnJvbV9zdGRpbikgewoJCWlucHV0X2ZkID0gMDsKCQlpZiAoIXBhY2tfbmFtZSkgewoJCQlzdHJ1Y3Qgc3RyYnVmIHRtcF9maWxlID0gU1RSQlVGX0lOSVQ7CgkJCW91dHB1dF9mZCA9IG9kYl9ta3N0ZW1wKCZ0bXBfZmlsZSwKCQkJCQkJInBhY2svdG1wX3BhY2tfWFhYWFhYIik7CgkJCXBhY2tfbmFtZSA9IHN0cmJ1Zl9kZXRhY2goJnRtcF9maWxlLCBOVUxMKTsKCQl9IGVsc2UgewoJCQlvdXRwdXRfZmQgPSB4b3BlbihwYWNrX25hbWUsIE9fQ1JFQVR8T19FWENMfE9fUkRXUiwgMDYwMCk7CgkJfQoJCW5vdGhyZWFkX2RhdGEucGFja19mZCA9IG91dHB1dF9mZDsKCX0gZWxzZSB7CgkJaW5wdXRfZmQgPSB4b3BlbihwYWNrX25hbWUsIE9fUkRPTkxZKTsKCQlvdXRwdXRfZmQgPSAtMTsKCQlub3RocmVhZF9kYXRhLnBhY2tfZmQgPSBpbnB1dF9mZDsKCX0KCXRoZV9oYXNoX2FsZ28tPmluaXRfZm4oJmlucHV0X2N0eCk7CglyZXR1cm4gcGFja19uYW1lOwp9CgpzdGF0aWMgdm9pZCBwYXJzZV9wYWNrX2hlYWRlcih2b2lkKQp7CglzdHJ1Y3QgcGFja19oZWFkZXIgKmhkciA9IGZpbGwoc2l6ZW9mKHN0cnVjdCBwYWNrX2hlYWRlcikpOwoKCS8qIEhlYWRlciBjb25zaXN0ZW5jeSBjaGVjayAqLwoJaWYgKGhkci0+aGRyX3NpZ25hdHVyZSAhPSBodG9ubChQQUNLX1NJR05BVFVSRSkpCgkJZGllKF8oInBhY2sgc2lnbmF0dXJlIG1pc21hdGNoIikpOwoJaWYgKCFwYWNrX3ZlcnNpb25fb2soaGRyLT5oZHJfdmVyc2lvbikpCgkJZGllKF8oInBhY2sgdmVyc2lvbiAlIlBSSXUzMiIgdW5zdXBwb3J0ZWQiKSwKCQkJbnRvaGwoaGRyLT5oZHJfdmVyc2lvbikpOwoKCW5yX29iamVjdHMgPSBudG9obChoZHItPmhkcl9lbnRyaWVzKTsKCXVzZShzaXplb2Yoc3RydWN0IHBhY2tfaGVhZGVyKSk7Cn0KCl9fYXR0cmlidXRlX18oKGZvcm1hdCAocHJpbnRmLCAyLCAzKSkpCnN0YXRpYyBOT1JFVFVSTiB2b2lkIGJhZF9vYmplY3Qob2ZmX3Qgb2Zmc2V0LCBjb25zdCBjaGFyICpmb3JtYXQsIC4uLikKewoJdmFfbGlzdCBwYXJhbXM7CgljaGFyIGJ1ZlsxMDI0XTsKCgl2YV9zdGFydChwYXJhbXMsIGZvcm1hdCk7Cgl2c25wcmludGYoYnVmLCBzaXplb2YoYnVmKSwgZm9ybWF0LCBwYXJhbXMpOwoJdmFfZW5kKHBhcmFtcyk7CglkaWUoXygicGFjayBoYXMgYmFkIG9iamVjdCBhdCBvZmZzZXQgJSJQUkl1TUFYIjogJXMiKSwKCSAgICAodWludG1heF90KW9mZnNldCwgYnVmKTsKfQoKc3RhdGljIGlubGluZSBzdHJ1Y3QgdGhyZWFkX2xvY2FsICpnZXRfdGhyZWFkX2RhdGEodm9pZCkKewoJaWYgKEhBVkVfVEhSRUFEUykgewoJCWlmICh0aHJlYWRzX2FjdGl2ZSkKCQkJcmV0dXJuIHB0aHJlYWRfZ2V0c3BlY2lmaWMoa2V5KTsKCQlhc3NlcnQoIXRocmVhZHNfYWN0aXZlICYmCgkJICAgICAgICJUaGlzIHNob3VsZCBvbmx5IGJlIHJlYWNoZWQgd2hlbiBhbGwgdGhyZWFkcyBhcmUgZ29uZSIpOwoJfQoJcmV0dXJuICZub3RocmVhZF9kYXRhOwp9CgpzdGF0aWMgdm9pZCBzZXRfdGhyZWFkX2RhdGEoc3RydWN0IHRocmVhZF9sb2NhbCAqZGF0YSkKewoJaWYgKHRocmVhZHNfYWN0aXZlKQoJCXB0aHJlYWRfc2V0c3BlY2lmaWMoa2V5LCBkYXRhKTsKfQoKc3RhdGljIHZvaWQgZnJlZV9iYXNlX2RhdGEoc3RydWN0IGJhc2VfZGF0YSAqYykKewoJaWYgKGMtPmRhdGEpIHsKCQlGUkVFX0FORF9OVUxMKGMtPmRhdGEpOwoJCWJhc2VfY2FjaGVfdXNlZCAtPSBjLT5zaXplOwoJfQp9CgpzdGF0aWMgdm9pZCBwcnVuZV9iYXNlX2RhdGEoc3RydWN0IGJhc2VfZGF0YSAqcmV0YWluKQp7CglzdHJ1Y3QgbGlzdF9oZWFkICpwb3M7CgoJaWYgKGJhc2VfY2FjaGVfdXNlZCA8PSBiYXNlX2NhY2hlX2xpbWl0KQoJCXJldHVybjsKCglsaXN0X2Zvcl9lYWNoX3ByZXYocG9zLCAmZG9uZV9oZWFkKSB7CgkJc3RydWN0IGJhc2VfZGF0YSAqYiA9IGxpc3RfZW50cnkocG9zLCBzdHJ1Y3QgYmFzZV9kYXRhLCBsaXN0KTsKCQlpZiAoYi0+cmV0YWluX2RhdGEgfHwgYiA9PSByZXRhaW4pCgkJCWNvbnRpbnVlOwoJCWlmIChiLT5kYXRhKSB7CgkJCWZyZWVfYmFzZV9kYXRhKGIpOwoJCQlpZiAoYmFzZV9jYWNoZV91c2VkIDw9IGJhc2VfY2FjaGVfbGltaXQpCgkJCQlyZXR1cm47CgkJfQoJfQoKCWxpc3RfZm9yX2VhY2hfcHJldihwb3MsICZ3b3JrX2hlYWQpIHsKCQlzdHJ1Y3QgYmFzZV9kYXRhICpiID0gbGlzdF9lbnRyeShwb3MsIHN0cnVjdCBiYXNlX2RhdGEsIGxpc3QpOwoJCWlmIChiLT5yZXRhaW5fZGF0YSB8fCBiID09IHJldGFpbikKCQkJY29udGludWU7CgkJaWYgKGItPmRhdGEpIHsKCQkJZnJlZV9iYXNlX2RhdGEoYik7CgkJCWlmIChiYXNlX2NhY2hlX3VzZWQgPD0gYmFzZV9jYWNoZV9saW1pdCkKCQkJCXJldHVybjsKCQl9Cgl9Cn0KCnN0YXRpYyBpbnQgaXNfZGVsdGFfdHlwZShlbnVtIG9iamVjdF90eXBlIHR5cGUpCnsKCXJldHVybiAodHlwZSA9PSBPQkpfUkVGX0RFTFRBIHx8IHR5cGUgPT0gT0JKX09GU19ERUxUQSk7Cn0KCnN0YXRpYyB2b2lkICp1bnBhY2tfZW50cnlfZGF0YShvZmZfdCBvZmZzZXQsIHVuc2lnbmVkIGxvbmcgc2l6ZSwKCQkJICAgICAgIGVudW0gb2JqZWN0X3R5cGUgdHlwZSwgc3RydWN0IG9iamVjdF9pZCAqb2lkKQp7CglzdGF0aWMgY2hhciBmaXhlZF9idWZbODE5Ml07CglpbnQgc3RhdHVzOwoJZ2l0X3pzdHJlYW0gc3RyZWFtOwoJdm9pZCAqYnVmOwoJZ2l0X2hhc2hfY3R4IGM7CgljaGFyIGhkclszMl07CglpbnQgaGRybGVuOwoKCWlmICghaXNfZGVsdGFfdHlwZSh0eXBlKSkgewoJCWhkcmxlbiA9IGZvcm1hdF9vYmplY3RfaGVhZGVyKGhkciwgc2l6ZW9mKGhkciksIHR5cGUsIHNpemUpOwoJCXRoZV9oYXNoX2FsZ28tPmluaXRfZm4oJmMpOwoJCXRoZV9oYXNoX2FsZ28tPnVwZGF0ZV9mbigmYywgaGRyLCBoZHJsZW4pOwoJfSBlbHNlCgkJb2lkID0gTlVMTDsKCWlmICh0eXBlID09IE9CSl9CTE9CICYmIHNpemUgPiBiaWdfZmlsZV90aHJlc2hvbGQpCgkJYnVmID0gZml4ZWRfYnVmOwoJZWxzZQoJCWJ1ZiA9IHhtYWxsb2N6KHNpemUpOwoKCW1lbXNldCgmc3RyZWFtLCAwLCBzaXplb2Yoc3RyZWFtKSk7CglnaXRfaW5mbGF0ZV9pbml0KCZzdHJlYW0pOwoJc3RyZWFtLm5leHRfb3V0ID0gYnVmOwoJc3RyZWFtLmF2YWlsX291dCA9IGJ1ZiA9PSBmaXhlZF9idWYgPyBzaXplb2YoZml4ZWRfYnVmKSA6IHNpemU7CgoJZG8gewoJCXVuc2lnbmVkIGNoYXIgKmxhc3Rfb3V0ID0gc3RyZWFtLm5leHRfb3V0OwoJCXN0cmVhbS5uZXh0X2luID0gZmlsbCgxKTsKCQlzdHJlYW0uYXZhaWxfaW4gPSBpbnB1dF9sZW47CgkJc3RhdHVzID0gZ2l0X2luZmxhdGUoJnN0cmVhbSwgMCk7CgkJdXNlKGlucHV0X2xlbiAtIHN0cmVhbS5hdmFpbF9pbik7CgkJaWYgKG9pZCkKCQkJdGhlX2hhc2hfYWxnby0+dXBkYXRlX2ZuKCZjLCBsYXN0X291dCwgc3RyZWFtLm5leHRfb3V0IC0gbGFzdF9vdXQpOwoJCWlmIChidWYgPT0gZml4ZWRfYnVmKSB7CgkJCXN0cmVhbS5uZXh0X291dCA9IGJ1ZjsKCQkJc3RyZWFtLmF2YWlsX291dCA9IHNpemVvZihmaXhlZF9idWYpOwoJCX0KCX0gd2hpbGUgKHN0YXR1cyA9PSBaX09LKTsKCWlmIChzdHJlYW0udG90YWxfb3V0ICE9IHNpemUgfHwgc3RhdHVzICE9IFpfU1RSRUFNX0VORCkKCQliYWRfb2JqZWN0KG9mZnNldCwgXygiaW5mbGF0ZSByZXR1cm5lZCAlZCIpLCBzdGF0dXMpOwoJZ2l0X2luZmxhdGVfZW5kKCZzdHJlYW0pOwoJaWYgKG9pZCkKCQl0aGVfaGFzaF9hbGdvLT5maW5hbF9vaWRfZm4ob2lkLCAmYyk7CglyZXR1cm4gYnVmID09IGZpeGVkX2J1ZiA/IE5VTEwgOiBidWY7Cn0KCnN0YXRpYyB2b2lkICp1bnBhY2tfcmF3X2VudHJ5KHN0cnVjdCBvYmplY3RfZW50cnkgKm9iaiwKCQkJICAgICAgb2ZmX3QgKm9mc19vZmZzZXQsCgkJCSAgICAgIHN0cnVjdCBvYmplY3RfaWQgKnJlZl9vaWQsCgkJCSAgICAgIHN0cnVjdCBvYmplY3RfaWQgKm9pZCkKewoJdW5zaWduZWQgY2hhciAqcDsKCXVuc2lnbmVkIGxvbmcgc2l6ZSwgYzsKCW9mZl90IGJhc2Vfb2Zmc2V0OwoJdW5zaWduZWQgc2hpZnQ7Cgl2b2lkICpkYXRhOwoKCW9iai0+aWR4Lm9mZnNldCA9IGNvbnN1bWVkX2J5dGVzOwoJaW5wdXRfY3JjMzIgPSBjcmMzMigwLCBOVUxMLCAwKTsKCglwID0gZmlsbCgxKTsKCWMgPSAqcDsKCXVzZSgxKTsKCW9iai0+dHlwZSA9IChjID4+IDQpICYgNzsKCXNpemUgPSAoYyAmIDE1KTsKCXNoaWZ0ID0gNDsKCXdoaWxlIChjICYgMHg4MCkgewoJCXAgPSBmaWxsKDEpOwoJCWMgPSAqcDsKCQl1c2UoMSk7CgkJc2l6ZSArPSAoYyAmIDB4N2YpIDw8IHNoaWZ0OwoJCXNoaWZ0ICs9IDc7Cgl9CglvYmotPnNpemUgPSBzaXplOwoKCXN3aXRjaCAob2JqLT50eXBlKSB7CgljYXNlIE9CSl9SRUZfREVMVEE6CgkJb2lkcmVhZChyZWZfb2lkLCBmaWxsKHRoZV9oYXNoX2FsZ28tPnJhd3N6KSk7CgkJdXNlKHRoZV9oYXNoX2FsZ28tPnJhd3N6KTsKCQlicmVhazsKCWNhc2UgT0JKX09GU19ERUxUQToKCQlwID0gZmlsbCgxKTsKCQljID0gKnA7CgkJdXNlKDEpOwoJCWJhc2Vfb2Zmc2V0ID0gYyAmIDEyNzsKCQl3aGlsZSAoYyAmIDEyOCkgewoJCQliYXNlX29mZnNldCArPSAxOwoJCQlpZiAoIWJhc2Vfb2Zmc2V0IHx8IE1TQihiYXNlX29mZnNldCwgNykpCgkJCQliYWRfb2JqZWN0KG9iai0+aWR4Lm9mZnNldCwgXygib2Zmc2V0IHZhbHVlIG92ZXJmbG93IGZvciBkZWx0YSBiYXNlIG9iamVjdCIpKTsKCQkJcCA9IGZpbGwoMSk7CgkJCWMgPSAqcDsKCQkJdXNlKDEpOwoJCQliYXNlX29mZnNldCA9IChiYXNlX29mZnNldCA8PCA3KSArIChjICYgMTI3KTsKCQl9CgkJKm9mc19vZmZzZXQgPSBvYmotPmlkeC5vZmZzZXQgLSBiYXNlX29mZnNldDsKCQlpZiAoKm9mc19vZmZzZXQgPD0gMCB8fCAqb2ZzX29mZnNldCA+PSBvYmotPmlkeC5vZmZzZXQpCgkJCWJhZF9vYmplY3Qob2JqLT5pZHgub2Zmc2V0LCBfKCJkZWx0YSBiYXNlIG9mZnNldCBpcyBvdXQgb2YgYm91bmQiKSk7CgkJYnJlYWs7CgljYXNlIE9CSl9DT01NSVQ6CgljYXNlIE9CSl9UUkVFOgoJY2FzZSBPQkpfQkxPQjoKCWNhc2UgT0JKX1RBRzoKCQlicmVhazsKCWRlZmF1bHQ6CgkJYmFkX29iamVjdChvYmotPmlkeC5vZmZzZXQsIF8oInVua25vd24gb2JqZWN0IHR5cGUgJWQiKSwgb2JqLT50eXBlKTsKCX0KCW9iai0+aGRyX3NpemUgPSBjb25zdW1lZF9ieXRlcyAtIG9iai0+aWR4Lm9mZnNldDsKCglkYXRhID0gdW5wYWNrX2VudHJ5X2RhdGEob2JqLT5pZHgub2Zmc2V0LCBvYmotPnNpemUsIG9iai0+dHlwZSwgb2lkKTsKCW9iai0+aWR4LmNyYzMyID0gaW5wdXRfY3JjMzI7CglyZXR1cm4gZGF0YTsKfQoKc3RhdGljIHZvaWQgKnVucGFja19kYXRhKHN0cnVjdCBvYmplY3RfZW50cnkgKm9iaiwKCQkJIGludCAoKmNvbnN1bWUpKGNvbnN0IHVuc2lnbmVkIGNoYXIgKiwgdW5zaWduZWQgbG9uZywgdm9pZCAqKSwKCQkJIHZvaWQgKmNiX2RhdGEpCnsKCW9mZl90IGZyb20gPSBvYmpbMF0uaWR4Lm9mZnNldCArIG9ialswXS5oZHJfc2l6ZTsKCW9mZl90IGxlbiA9IG9ialsxXS5pZHgub2Zmc2V0IC0gZnJvbTsKCXVuc2lnbmVkIGNoYXIgKmRhdGEsICppbmJ1ZjsKCWdpdF96c3RyZWFtIHN0cmVhbTsKCWludCBzdGF0dXM7CgoJZGF0YSA9IHhtYWxsb2N6KGNvbnN1bWUgPyA2NCoxMDI0IDogb2JqLT5zaXplKTsKCWluYnVmID0geG1hbGxvYygobGVuIDwgNjQqMTAyNCkgPyAoaW50KWxlbiA6IDY0KjEwMjQpOwoKCW1lbXNldCgmc3RyZWFtLCAwLCBzaXplb2Yoc3RyZWFtKSk7CglnaXRfaW5mbGF0ZV9pbml0KCZzdHJlYW0pOwoJc3RyZWFtLm5leHRfb3V0ID0gZGF0YTsKCXN0cmVhbS5hdmFpbF9vdXQgPSBjb25zdW1lID8gNjQqMTAyNCA6IG9iai0+c2l6ZTsKCglkbyB7CgkJc3NpemVfdCBuID0gKGxlbiA8IDY0KjEwMjQpID8gKHNzaXplX3QpbGVuIDogNjQqMTAyNDsKCQluID0geHByZWFkKGdldF90aHJlYWRfZGF0YSgpLT5wYWNrX2ZkLCBpbmJ1ZiwgbiwgZnJvbSk7CgkJaWYgKG4gPCAwKQoJCQlkaWVfZXJybm8oXygiY2Fubm90IHByZWFkIHBhY2sgZmlsZSIpKTsKCQlpZiAoIW4pCgkJCWRpZShRXygicHJlbWF0dXJlIGVuZCBvZiBwYWNrIGZpbGUsICUiUFJJdU1BWCIgYnl0ZSBtaXNzaW5nIiwKCQkJICAgICAgICJwcmVtYXR1cmUgZW5kIG9mIHBhY2sgZmlsZSwgJSJQUkl1TUFYIiBieXRlcyBtaXNzaW5nIiwKCQkJICAgICAgIGxlbiksCgkJCSAgICAodWludG1heF90KWxlbik7CgkJZnJvbSArPSBuOwoJCWxlbiAtPSBuOwoJCXN0cmVhbS5uZXh0X2luID0gaW5idWY7CgkJc3RyZWFtLmF2YWlsX2luID0gbjsKCQlpZiAoIWNvbnN1bWUpCgkJCXN0YXR1cyA9IGdpdF9pbmZsYXRlKCZzdHJlYW0sIDApOwoJCWVsc2UgewoJCQlkbyB7CgkJCQlzdGF0dXMgPSBnaXRfaW5mbGF0ZSgmc3RyZWFtLCAwKTsKCQkJCWlmIChjb25zdW1lKGRhdGEsIHN0cmVhbS5uZXh0X291dCAtIGRhdGEsIGNiX2RhdGEpKSB7CgkJCQkJZnJlZShpbmJ1Zik7CgkJCQkJZnJlZShkYXRhKTsKCQkJCQlyZXR1cm4gTlVMTDsKCQkJCX0KCQkJCXN0cmVhbS5uZXh0X291dCA9IGRhdGE7CgkJCQlzdHJlYW0uYXZhaWxfb3V0ID0gNjQqMTAyNDsKCQkJfSB3aGlsZSAoc3RhdHVzID09IFpfT0sgJiYgc3RyZWFtLmF2YWlsX2luKTsKCQl9Cgl9IHdoaWxlIChsZW4gJiYgc3RhdHVzID09IFpfT0sgJiYgIXN0cmVhbS5hdmFpbF9pbik7CgoJLyogVGhpcyBoYXMgYmVlbiBpbmZsYXRlZCBPSyB3aGVuIGZpcnN0IGVuY291bnRlcmVkLCBzby4uLiAqLwoJaWYgKHN0YXR1cyAhPSBaX1NUUkVBTV9FTkQgfHwgc3RyZWFtLnRvdGFsX291dCAhPSBvYmotPnNpemUpCgkJZGllKF8oInNlcmlvdXMgaW5mbGF0ZSBpbmNvbnNpc3RlbmN5IikpOwoKCWdpdF9pbmZsYXRlX2VuZCgmc3RyZWFtKTsKCWZyZWUoaW5idWYpOwoJaWYgKGNvbnN1bWUpIHsKCQlGUkVFX0FORF9OVUxMKGRhdGEpOwoJfQoJcmV0dXJuIGRhdGE7Cn0KCnN0YXRpYyB2b2lkICpnZXRfZGF0YV9mcm9tX3BhY2soc3RydWN0IG9iamVjdF9lbnRyeSAqb2JqKQp7CglyZXR1cm4gdW5wYWNrX2RhdGEob2JqLCBOVUxMLCBOVUxMKTsKfQoKc3RhdGljIGludCBjb21wYXJlX29mc19kZWx0YV9iYXNlcyhvZmZfdCBvZmZzZXQxLCBvZmZfdCBvZmZzZXQyLAoJCQkJICAgZW51bSBvYmplY3RfdHlwZSB0eXBlMSwKCQkJCSAgIGVudW0gb2JqZWN0X3R5cGUgdHlwZTIpCnsKCWludCBjbXAgPSB0eXBlMSAtIHR5cGUyOwoJaWYgKGNtcCkKCQlyZXR1cm4gY21wOwoJcmV0dXJuIG9mZnNldDEgPCBvZmZzZXQyID8gLTEgOgoJICAgICAgIG9mZnNldDEgPiBvZmZzZXQyID8gIDEgOgoJICAgICAgIDA7Cn0KCnN0YXRpYyBpbnQgZmluZF9vZnNfZGVsdGEoY29uc3Qgb2ZmX3Qgb2Zmc2V0KQp7CglpbnQgZmlyc3QgPSAwLCBsYXN0ID0gbnJfb2ZzX2RlbHRhczsKCgl3aGlsZSAoZmlyc3QgPCBsYXN0KSB7CgkJaW50IG5leHQgPSBmaXJzdCArIChsYXN0IC0gZmlyc3QpIC8gMjsKCQlzdHJ1Y3Qgb2ZzX2RlbHRhX2VudHJ5ICpkZWx0YSA9ICZvZnNfZGVsdGFzW25leHRdOwoJCWludCBjbXA7CgoJCWNtcCA9IGNvbXBhcmVfb2ZzX2RlbHRhX2Jhc2VzKG9mZnNldCwgZGVsdGEtPm9mZnNldCwKCQkJCQkgICAgICBPQkpfT0ZTX0RFTFRBLAoJCQkJCSAgICAgIG9iamVjdHNbZGVsdGEtPm9ial9ub10udHlwZSk7CgkJaWYgKCFjbXApCgkJCXJldHVybiBuZXh0OwoJCWlmIChjbXAgPCAwKSB7CgkJCWxhc3QgPSBuZXh0OwoJCQljb250aW51ZTsKCQl9CgkJZmlyc3QgPSBuZXh0KzE7Cgl9CglyZXR1cm4gLWZpcnN0LTE7Cn0KCnN0YXRpYyB2b2lkIGZpbmRfb2ZzX2RlbHRhX2NoaWxkcmVuKG9mZl90IG9mZnNldCwKCQkJCSAgICBpbnQgKmZpcnN0X2luZGV4LCBpbnQgKmxhc3RfaW5kZXgpCnsKCWludCBmaXJzdCA9IGZpbmRfb2ZzX2RlbHRhKG9mZnNldCk7CglpbnQgbGFzdCA9IGZpcnN0OwoJaW50IGVuZCA9IG5yX29mc19kZWx0YXMgLSAxOwoKCWlmIChmaXJzdCA8IDApIHsKCQkqZmlyc3RfaW5kZXggPSAwOwoJCSpsYXN0X2luZGV4ID0gLTE7CgkJcmV0dXJuOwoJfQoJd2hpbGUgKGZpcnN0ID4gMCAmJiBvZnNfZGVsdGFzW2ZpcnN0IC0gMV0ub2Zmc2V0ID09IG9mZnNldCkKCQktLWZpcnN0OwoJd2hpbGUgKGxhc3QgPCBlbmQgJiYgb2ZzX2RlbHRhc1tsYXN0ICsgMV0ub2Zmc2V0ID09IG9mZnNldCkKCQkrK2xhc3Q7CgkqZmlyc3RfaW5kZXggPSBmaXJzdDsKCSpsYXN0X2luZGV4ID0gbGFzdDsKfQoKc3RhdGljIGludCBjb21wYXJlX3JlZl9kZWx0YV9iYXNlcyhjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQxLAoJCQkJICAgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkMiwKCQkJCSAgIGVudW0gb2JqZWN0X3R5cGUgdHlwZTEsCgkJCQkgICBlbnVtIG9iamVjdF90eXBlIHR5cGUyKQp7CglpbnQgY21wID0gdHlwZTEgLSB0eXBlMjsKCWlmIChjbXApCgkJcmV0dXJuIGNtcDsKCXJldHVybiBvaWRjbXAob2lkMSwgb2lkMik7Cn0KCnN0YXRpYyBpbnQgZmluZF9yZWZfZGVsdGEoY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkKQp7CglpbnQgZmlyc3QgPSAwLCBsYXN0ID0gbnJfcmVmX2RlbHRhczsKCgl3aGlsZSAoZmlyc3QgPCBsYXN0KSB7CgkJaW50IG5leHQgPSBmaXJzdCArIChsYXN0IC0gZmlyc3QpIC8gMjsKCQlzdHJ1Y3QgcmVmX2RlbHRhX2VudHJ5ICpkZWx0YSA9ICZyZWZfZGVsdGFzW25leHRdOwoJCWludCBjbXA7CgoJCWNtcCA9IGNvbXBhcmVfcmVmX2RlbHRhX2Jhc2VzKG9pZCwgJmRlbHRhLT5vaWQsCgkJCQkJICAgICAgT0JKX1JFRl9ERUxUQSwKCQkJCQkgICAgICBvYmplY3RzW2RlbHRhLT5vYmpfbm9dLnR5cGUpOwoJCWlmICghY21wKQoJCQlyZXR1cm4gbmV4dDsKCQlpZiAoY21wIDwgMCkgewoJCQlsYXN0ID0gbmV4dDsKCQkJY29udGludWU7CgkJfQoJCWZpcnN0ID0gbmV4dCsxOwoJfQoJcmV0dXJuIC1maXJzdC0xOwp9CgpzdGF0aWMgdm9pZCBmaW5kX3JlZl9kZWx0YV9jaGlsZHJlbihjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsCgkJCQkgICAgaW50ICpmaXJzdF9pbmRleCwgaW50ICpsYXN0X2luZGV4KQp7CglpbnQgZmlyc3QgPSBmaW5kX3JlZl9kZWx0YShvaWQpOwoJaW50IGxhc3QgPSBmaXJzdDsKCWludCBlbmQgPSBucl9yZWZfZGVsdGFzIC0gMTsKCglpZiAoZmlyc3QgPCAwKSB7CgkJKmZpcnN0X2luZGV4ID0gMDsKCQkqbGFzdF9pbmRleCA9IC0xOwoJCXJldHVybjsKCX0KCXdoaWxlIChmaXJzdCA+IDAgJiYgb2lkZXEoJnJlZl9kZWx0YXNbZmlyc3QgLSAxXS5vaWQsIG9pZCkpCgkJLS1maXJzdDsKCXdoaWxlIChsYXN0IDwgZW5kICYmIG9pZGVxKCZyZWZfZGVsdGFzW2xhc3QgKyAxXS5vaWQsIG9pZCkpCgkJKytsYXN0OwoJKmZpcnN0X2luZGV4ID0gZmlyc3Q7CgkqbGFzdF9pbmRleCA9IGxhc3Q7Cn0KCnN0cnVjdCBjb21wYXJlX2RhdGEgewoJc3RydWN0IG9iamVjdF9lbnRyeSAqZW50cnk7CglzdHJ1Y3QgZ2l0X2lzdHJlYW0gKnN0OwoJdW5zaWduZWQgY2hhciAqYnVmOwoJdW5zaWduZWQgbG9uZyBidWZfc2l6ZTsKfTsKCnN0YXRpYyBpbnQgY29tcGFyZV9vYmplY3RzKGNvbnN0IHVuc2lnbmVkIGNoYXIgKmJ1ZiwgdW5zaWduZWQgbG9uZyBzaXplLAoJCQkgICB2b2lkICpjYl9kYXRhKQp7CglzdHJ1Y3QgY29tcGFyZV9kYXRhICpkYXRhID0gY2JfZGF0YTsKCglpZiAoZGF0YS0+YnVmX3NpemUgPCBzaXplKSB7CgkJZnJlZShkYXRhLT5idWYpOwoJCWRhdGEtPmJ1ZiA9IHhtYWxsb2Moc2l6ZSk7CgkJZGF0YS0+YnVmX3NpemUgPSBzaXplOwoJfQoKCXdoaWxlIChzaXplKSB7CgkJc3NpemVfdCBsZW4gPSByZWFkX2lzdHJlYW0oZGF0YS0+c3QsIGRhdGEtPmJ1Ziwgc2l6ZSk7CgkJaWYgKGxlbiA9PSAwKQoJCQlkaWUoXygiU0hBMSBDT0xMSVNJT04gRk9VTkQgV0lUSCAlcyAhIiksCgkJCSAgICBvaWRfdG9faGV4KCZkYXRhLT5lbnRyeS0+aWR4Lm9pZCkpOwoJCWlmIChsZW4gPCAwKQoJCQlkaWUoXygidW5hYmxlIHRvIHJlYWQgJXMiKSwKCQkJICAgIG9pZF90b19oZXgoJmRhdGEtPmVudHJ5LT5pZHgub2lkKSk7CgkJaWYgKG1lbWNtcChidWYsIGRhdGEtPmJ1ZiwgbGVuKSkKCQkJZGllKF8oIlNIQTEgQ09MTElTSU9OIEZPVU5EIFdJVEggJXMgISIpLAoJCQkgICAgb2lkX3RvX2hleCgmZGF0YS0+ZW50cnktPmlkeC5vaWQpKTsKCQlzaXplIC09IGxlbjsKCQlidWYgKz0gbGVuOwoJfQoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgY2hlY2tfY29sbGlzb24oc3RydWN0IG9iamVjdF9lbnRyeSAqZW50cnkpCnsKCXN0cnVjdCBjb21wYXJlX2RhdGEgZGF0YTsKCWVudW0gb2JqZWN0X3R5cGUgdHlwZTsKCXVuc2lnbmVkIGxvbmcgc2l6ZTsKCglpZiAoZW50cnktPnNpemUgPD0gYmlnX2ZpbGVfdGhyZXNob2xkIHx8IGVudHJ5LT50eXBlICE9IE9CSl9CTE9CKQoJCXJldHVybiAtMTsKCgltZW1zZXQoJmRhdGEsIDAsIHNpemVvZihkYXRhKSk7CglkYXRhLmVudHJ5ID0gZW50cnk7CglkYXRhLnN0ID0gb3Blbl9pc3RyZWFtKHRoZV9yZXBvc2l0b3J5LCAmZW50cnktPmlkeC5vaWQsICZ0eXBlLCAmc2l6ZSwKCQkJICAgICAgIE5VTEwpOwoJaWYgKCFkYXRhLnN0KQoJCXJldHVybiAtMTsKCWlmIChzaXplICE9IGVudHJ5LT5zaXplIHx8IHR5cGUgIT0gZW50cnktPnR5cGUpCgkJZGllKF8oIlNIQTEgQ09MTElTSU9OIEZPVU5EIFdJVEggJXMgISIpLAoJCSAgICBvaWRfdG9faGV4KCZlbnRyeS0+aWR4Lm9pZCkpOwoJdW5wYWNrX2RhdGEoZW50cnksIGNvbXBhcmVfb2JqZWN0cywgJmRhdGEpOwoJY2xvc2VfaXN0cmVhbShkYXRhLnN0KTsKCWZyZWUoZGF0YS5idWYpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyB2b2lkIHNoYTFfb2JqZWN0KGNvbnN0IHZvaWQgKmRhdGEsIHN0cnVjdCBvYmplY3RfZW50cnkgKm9ial9lbnRyeSwKCQkJdW5zaWduZWQgbG9uZyBzaXplLCBlbnVtIG9iamVjdF90eXBlIHR5cGUsCgkJCWNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCkKewoJdm9pZCAqbmV3X2RhdGEgPSBOVUxMOwoJaW50IGNvbGxpc2lvbl90ZXN0X25lZWRlZCA9IDA7CgoJYXNzZXJ0KGRhdGEgfHwgb2JqX2VudHJ5KTsKCglpZiAoc3RhcnR1cF9pbmZvLT5oYXZlX3JlcG9zaXRvcnkpIHsKCQlyZWFkX2xvY2soKTsKCQljb2xsaXNpb25fdGVzdF9uZWVkZWQgPQoJCQloYXNfb2JqZWN0X2ZpbGVfd2l0aF9mbGFncyhvaWQsIE9CSkVDVF9JTkZPX1FVSUNLKTsKCQlyZWFkX3VubG9jaygpOwoJfQoKCWlmIChjb2xsaXNpb25fdGVzdF9uZWVkZWQgJiYgIWRhdGEpIHsKCQlyZWFkX2xvY2soKTsKCQlpZiAoIWNoZWNrX2NvbGxpc29uKG9ial9lbnRyeSkpCgkJCWNvbGxpc2lvbl90ZXN0X25lZWRlZCA9IDA7CgkJcmVhZF91bmxvY2soKTsKCX0KCWlmIChjb2xsaXNpb25fdGVzdF9uZWVkZWQpIHsKCQl2b2lkICpoYXNfZGF0YTsKCQllbnVtIG9iamVjdF90eXBlIGhhc190eXBlOwoJCXVuc2lnbmVkIGxvbmcgaGFzX3NpemU7CgkJcmVhZF9sb2NrKCk7CgkJaGFzX3R5cGUgPSBvaWRfb2JqZWN0X2luZm8odGhlX3JlcG9zaXRvcnksIG9pZCwgJmhhc19zaXplKTsKCQlpZiAoaGFzX3R5cGUgPCAwKQoJCQlkaWUoXygiY2Fubm90IHJlYWQgZXhpc3Rpbmcgb2JqZWN0IGluZm8gJXMiKSwgb2lkX3RvX2hleChvaWQpKTsKCQlpZiAoaGFzX3R5cGUgIT0gdHlwZSB8fCBoYXNfc2l6ZSAhPSBzaXplKQoJCQlkaWUoXygiU0hBMSBDT0xMSVNJT04gRk9VTkQgV0lUSCAlcyAhIiksIG9pZF90b19oZXgob2lkKSk7CgkJaGFzX2RhdGEgPSByZWFkX29iamVjdF9maWxlKG9pZCwgJmhhc190eXBlLCAmaGFzX3NpemUpOwoJCXJlYWRfdW5sb2NrKCk7CgkJaWYgKCFkYXRhKQoJCQlkYXRhID0gbmV3X2RhdGEgPSBnZXRfZGF0YV9mcm9tX3BhY2sob2JqX2VudHJ5KTsKCQlpZiAoIWhhc19kYXRhKQoJCQlkaWUoXygiY2Fubm90IHJlYWQgZXhpc3Rpbmcgb2JqZWN0ICVzIiksIG9pZF90b19oZXgob2lkKSk7CgkJaWYgKHNpemUgIT0gaGFzX3NpemUgfHwgdHlwZSAhPSBoYXNfdHlwZSB8fAoJCSAgICBtZW1jbXAoZGF0YSwgaGFzX2RhdGEsIHNpemUpICE9IDApCgkJCWRpZShfKCJTSEExIENPTExJU0lPTiBGT1VORCBXSVRIICVzICEiKSwgb2lkX3RvX2hleChvaWQpKTsKCQlmcmVlKGhhc19kYXRhKTsKCX0KCglpZiAoc3RyaWN0IHx8IGRvX2ZzY2tfb2JqZWN0KSB7CgkJcmVhZF9sb2NrKCk7CgkJaWYgKHR5cGUgPT0gT0JKX0JMT0IpIHsKCQkJc3RydWN0IGJsb2IgKmJsb2IgPSBsb29rdXBfYmxvYih0aGVfcmVwb3NpdG9yeSwgb2lkKTsKCQkJaWYgKGJsb2IpCgkJCQlibG9iLT5vYmplY3QuZmxhZ3MgfD0gRkxBR19DSEVDS0VEOwoJCQllbHNlCgkJCQlkaWUoXygiaW52YWxpZCBibG9iIG9iamVjdCAlcyIpLCBvaWRfdG9faGV4KG9pZCkpOwoJCQlpZiAoZG9fZnNja19vYmplY3QgJiYKCQkJICAgIGZzY2tfb2JqZWN0KCZibG9iLT5vYmplY3QsICh2b2lkICopZGF0YSwgc2l6ZSwgJmZzY2tfb3B0aW9ucykpCgkJCQlkaWUoXygiZnNjayBlcnJvciBpbiBwYWNrZWQgb2JqZWN0IikpOwoJCX0gZWxzZSB7CgkJCXN0cnVjdCBvYmplY3QgKm9iajsKCQkJaW50IGVhdGVuOwoJCQl2b2lkICpidWYgPSAodm9pZCAqKSBkYXRhOwoKCQkJYXNzZXJ0KGRhdGEgJiYgImRhdGEgY2FuIG9ubHkgYmUgTlVMTCBmb3IgbGFyZ2UgX2Jsb2JzXyIpOwoKCQkJLyoKCQkJICogd2UgZG8gbm90IG5lZWQgdG8gZnJlZSB0aGUgbWVtb3J5IGhlcmUsIGFzIHRoZQoJCQkgKiBidWYgaXMgZGVsZXRlZCBieSB0aGUgY2FsbGVyLgoJCQkgKi8KCQkJb2JqID0gcGFyc2Vfb2JqZWN0X2J1ZmZlcih0aGVfcmVwb3NpdG9yeSwgb2lkLCB0eXBlLAoJCQkJCQkgIHNpemUsIGJ1ZiwKCQkJCQkJICAmZWF0ZW4pOwoJCQlpZiAoIW9iaikKCQkJCWRpZShfKCJpbnZhbGlkICVzIiksIHR5cGVfbmFtZSh0eXBlKSk7CgkJCWlmIChkb19mc2NrX29iamVjdCAmJgoJCQkgICAgZnNja19vYmplY3Qob2JqLCBidWYsIHNpemUsICZmc2NrX29wdGlvbnMpKQoJCQkJZGllKF8oImZzY2sgZXJyb3IgaW4gcGFja2VkIG9iamVjdCIpKTsKCQkJaWYgKHN0cmljdCAmJiBmc2NrX3dhbGsob2JqLCBOVUxMLCAmZnNja19vcHRpb25zKSkKCQkJCWRpZShfKCJOb3QgYWxsIGNoaWxkIG9iamVjdHMgb2YgJXMgYXJlIHJlYWNoYWJsZSIpLCBvaWRfdG9faGV4KCZvYmotPm9pZCkpOwoKCQkJaWYgKG9iai0+dHlwZSA9PSBPQkpfVFJFRSkgewoJCQkJc3RydWN0IHRyZWUgKml0ZW0gPSAoc3RydWN0IHRyZWUgKikgb2JqOwoJCQkJaXRlbS0+YnVmZmVyID0gTlVMTDsKCQkJCW9iai0+cGFyc2VkID0gMDsKCQkJfQoJCQlpZiAob2JqLT50eXBlID09IE9CSl9DT01NSVQpIHsKCQkJCXN0cnVjdCBjb21taXQgKmNvbW1pdCA9IChzdHJ1Y3QgY29tbWl0ICopIG9iajsKCQkJCWlmIChkZXRhY2hfY29tbWl0X2J1ZmZlcihjb21taXQsIE5VTEwpICE9IGRhdGEpCgkJCQkJQlVHKCJwYXJzZV9vYmplY3RfYnVmZmVyIHRyYW5zbW9ncmlmaWVkIG91ciBidWZmZXIiKTsKCQkJfQoJCQlvYmotPmZsYWdzIHw9IEZMQUdfQ0hFQ0tFRDsKCQl9CgkJcmVhZF91bmxvY2soKTsKCX0KCglmcmVlKG5ld19kYXRhKTsKfQoKLyoKICogRW5zdXJlIHRoYXQgdGhpcyBub2RlIGhhcyBiZWVuIHJlY29uc3RydWN0ZWQgYW5kIHJldHVybiBpdHMgY29udGVudHMuCiAqCiAqIEluIHRoZSB0eXBpY2FsIGFuZCBiZXN0IGNhc2UsIHRoaXMgbm9kZSB3b3VsZCBhbHJlYWR5IGJlIHJlY29uc3RydWN0ZWQKICogKHRocm91Z2ggdGhlIGludm9jYXRpb24gdG8gcmVzb2x2ZV9kZWx0YSgpIGluIHRocmVhZGVkX3NlY29uZF9wYXNzKCkpIGFuZCBpdAogKiB3b3VsZCBub3QgYmUgcHJ1bmVkLiBIb3dldmVyLCBpZiBwcnVuaW5nIG9mIHRoaXMgbm9kZSB3YXMgbmVjZXNzYXJ5IGR1ZSB0bwogKiByZWFjaGluZyBkZWx0YV9iYXNlX2NhY2hlX2xpbWl0LCB0aGlzIGZ1bmN0aW9uIHdpbGwgZmluZCB0aGUgY2xvc2VzdAogKiBhbmNlc3RvciB3aXRoIHJlY29uc3RydWN0ZWQgZGF0YSB0aGF0IGhhcyBub3QgYmVlbiBwcnVuZWQgKG9yIGlmIHRoZXJlIGlzCiAqIG5vbmUsIHRoZSB1bHRpbWF0ZSBiYXNlIG9iamVjdCksIGFuZCByZWNvbnN0cnVjdCBlYWNoIG5vZGUgaW4gdGhlIGRlbHRhCiAqIGNoYWluIGluIG9yZGVyIHRvIGdlbmVyYXRlIHRoZSByZWNvbnN0cnVjdGVkIGRhdGEgZm9yIHRoaXMgbm9kZS4KICovCnN0YXRpYyB2b2lkICpnZXRfYmFzZV9kYXRhKHN0cnVjdCBiYXNlX2RhdGEgKmMpCnsKCWlmICghYy0+ZGF0YSkgewoJCXN0cnVjdCBvYmplY3RfZW50cnkgKm9iaiA9IGMtPm9iajsKCQlzdHJ1Y3QgYmFzZV9kYXRhICoqZGVsdGEgPSBOVUxMOwoJCWludCBkZWx0YV9uciA9IDAsIGRlbHRhX2FsbG9jID0gMDsKCgkJd2hpbGUgKGlzX2RlbHRhX3R5cGUoYy0+b2JqLT50eXBlKSAmJiAhYy0+ZGF0YSkgewoJCQlBTExPQ19HUk9XKGRlbHRhLCBkZWx0YV9uciArIDEsIGRlbHRhX2FsbG9jKTsKCQkJZGVsdGFbZGVsdGFfbnIrK10gPSBjOwoJCQljID0gYy0+YmFzZTsKCQl9CgkJaWYgKCFkZWx0YV9ucikgewoJCQljLT5kYXRhID0gZ2V0X2RhdGFfZnJvbV9wYWNrKG9iaik7CgkJCWMtPnNpemUgPSBvYmotPnNpemU7CgkJCWJhc2VfY2FjaGVfdXNlZCArPSBjLT5zaXplOwoJCQlwcnVuZV9iYXNlX2RhdGEoYyk7CgkJfQoJCWZvciAoOyBkZWx0YV9uciA+IDA7IGRlbHRhX25yLS0pIHsKCQkJdm9pZCAqYmFzZSwgKnJhdzsKCQkJYyA9IGRlbHRhW2RlbHRhX25yIC0gMV07CgkJCW9iaiA9IGMtPm9iajsKCQkJYmFzZSA9IGdldF9iYXNlX2RhdGEoYy0+YmFzZSk7CgkJCXJhdyA9IGdldF9kYXRhX2Zyb21fcGFjayhvYmopOwoJCQljLT5kYXRhID0gcGF0Y2hfZGVsdGEoCgkJCQliYXNlLCBjLT5iYXNlLT5zaXplLAoJCQkJcmF3LCBvYmotPnNpemUsCgkJCQkmYy0+c2l6ZSk7CgkJCWZyZWUocmF3KTsKCQkJaWYgKCFjLT5kYXRhKQoJCQkJYmFkX29iamVjdChvYmotPmlkeC5vZmZzZXQsIF8oImZhaWxlZCB0byBhcHBseSBkZWx0YSIpKTsKCQkJYmFzZV9jYWNoZV91c2VkICs9IGMtPnNpemU7CgkJCXBydW5lX2Jhc2VfZGF0YShjKTsKCQl9CgkJZnJlZShkZWx0YSk7Cgl9CglyZXR1cm4gYy0+ZGF0YTsKfQoKc3RhdGljIHN0cnVjdCBiYXNlX2RhdGEgKm1ha2VfYmFzZShzdHJ1Y3Qgb2JqZWN0X2VudHJ5ICpvYmosCgkJCQkgICBzdHJ1Y3QgYmFzZV9kYXRhICpwYXJlbnQpCnsKCXN0cnVjdCBiYXNlX2RhdGEgKmJhc2UgPSB4Y2FsbG9jKDEsIHNpemVvZihzdHJ1Y3QgYmFzZV9kYXRhKSk7CgliYXNlLT5iYXNlID0gcGFyZW50OwoJYmFzZS0+b2JqID0gb2JqOwoJZmluZF9yZWZfZGVsdGFfY2hpbGRyZW4oJm9iai0+aWR4Lm9pZCwKCQkJCSZiYXNlLT5yZWZfZmlyc3QsICZiYXNlLT5yZWZfbGFzdCk7CglmaW5kX29mc19kZWx0YV9jaGlsZHJlbihvYmotPmlkeC5vZmZzZXQsCgkJCQkmYmFzZS0+b2ZzX2ZpcnN0LCAmYmFzZS0+b2ZzX2xhc3QpOwoJYmFzZS0+Y2hpbGRyZW5fcmVtYWluaW5nID0gYmFzZS0+cmVmX2xhc3QgLSBiYXNlLT5yZWZfZmlyc3QgKwoJCWJhc2UtPm9mc19sYXN0IC0gYmFzZS0+b2ZzX2ZpcnN0ICsgMjsKCXJldHVybiBiYXNlOwp9CgpzdGF0aWMgc3RydWN0IGJhc2VfZGF0YSAqcmVzb2x2ZV9kZWx0YShzdHJ1Y3Qgb2JqZWN0X2VudHJ5ICpkZWx0YV9vYmosCgkJCQkgICAgICAgc3RydWN0IGJhc2VfZGF0YSAqYmFzZSkKewoJdm9pZCAqZGVsdGFfZGF0YSwgKnJlc3VsdF9kYXRhOwoJc3RydWN0IGJhc2VfZGF0YSAqcmVzdWx0OwoJdW5zaWduZWQgbG9uZyByZXN1bHRfc2l6ZTsKCglpZiAoc2hvd19zdGF0KSB7CgkJaW50IGkgPSBkZWx0YV9vYmogLSBvYmplY3RzOwoJCWludCBqID0gYmFzZS0+b2JqIC0gb2JqZWN0czsKCQlvYmpfc3RhdFtpXS5kZWx0YV9kZXB0aCA9IG9ial9zdGF0W2pdLmRlbHRhX2RlcHRoICsgMTsKCQlkZWVwZXN0X2RlbHRhX2xvY2soKTsKCQlpZiAoZGVlcGVzdF9kZWx0YSA8IG9ial9zdGF0W2ldLmRlbHRhX2RlcHRoKQoJCQlkZWVwZXN0X2RlbHRhID0gb2JqX3N0YXRbaV0uZGVsdGFfZGVwdGg7CgkJZGVlcGVzdF9kZWx0YV91bmxvY2soKTsKCQlvYmpfc3RhdFtpXS5iYXNlX29iamVjdF9ubyA9IGo7Cgl9CglkZWx0YV9kYXRhID0gZ2V0X2RhdGFfZnJvbV9wYWNrKGRlbHRhX29iaik7Cglhc3NlcnQoYmFzZS0+ZGF0YSk7CglyZXN1bHRfZGF0YSA9IHBhdGNoX2RlbHRhKGJhc2UtPmRhdGEsIGJhc2UtPnNpemUsCgkJCQkgIGRlbHRhX2RhdGEsIGRlbHRhX29iai0+c2l6ZSwgJnJlc3VsdF9zaXplKTsKCWZyZWUoZGVsdGFfZGF0YSk7CglpZiAoIXJlc3VsdF9kYXRhKQoJCWJhZF9vYmplY3QoZGVsdGFfb2JqLT5pZHgub2Zmc2V0LCBfKCJmYWlsZWQgdG8gYXBwbHkgZGVsdGEiKSk7CgloYXNoX29iamVjdF9maWxlKHRoZV9oYXNoX2FsZ28sIHJlc3VsdF9kYXRhLCByZXN1bHRfc2l6ZSwKCQkJIGRlbHRhX29iai0+cmVhbF90eXBlLCAmZGVsdGFfb2JqLT5pZHgub2lkKTsKCXNoYTFfb2JqZWN0KHJlc3VsdF9kYXRhLCBOVUxMLCByZXN1bHRfc2l6ZSwgZGVsdGFfb2JqLT5yZWFsX3R5cGUsCgkJICAgICZkZWx0YV9vYmotPmlkeC5vaWQpOwoKCXJlc3VsdCA9IG1ha2VfYmFzZShkZWx0YV9vYmosIGJhc2UpOwoJcmVzdWx0LT5kYXRhID0gcmVzdWx0X2RhdGE7CglyZXN1bHQtPnNpemUgPSByZXN1bHRfc2l6ZTsKCgljb3VudGVyX2xvY2soKTsKCW5yX3Jlc29sdmVkX2RlbHRhcysrOwoJY291bnRlcl91bmxvY2soKTsKCglyZXR1cm4gcmVzdWx0Owp9CgpzdGF0aWMgaW50IGNvbXBhcmVfb2ZzX2RlbHRhX2VudHJ5KGNvbnN0IHZvaWQgKmEsIGNvbnN0IHZvaWQgKmIpCnsKCWNvbnN0IHN0cnVjdCBvZnNfZGVsdGFfZW50cnkgKmRlbHRhX2EgPSBhOwoJY29uc3Qgc3RydWN0IG9mc19kZWx0YV9lbnRyeSAqZGVsdGFfYiA9IGI7CgoJcmV0dXJuIGRlbHRhX2EtPm9mZnNldCA8IGRlbHRhX2ItPm9mZnNldCA/IC0xIDoKCSAgICAgICBkZWx0YV9hLT5vZmZzZXQgPiBkZWx0YV9iLT5vZmZzZXQgPyAgMSA6CgkgICAgICAgMDsKfQoKc3RhdGljIGludCBjb21wYXJlX3JlZl9kZWx0YV9lbnRyeShjb25zdCB2b2lkICphLCBjb25zdCB2b2lkICpiKQp7Cgljb25zdCBzdHJ1Y3QgcmVmX2RlbHRhX2VudHJ5ICpkZWx0YV9hID0gYTsKCWNvbnN0IHN0cnVjdCByZWZfZGVsdGFfZW50cnkgKmRlbHRhX2IgPSBiOwoKCXJldHVybiBvaWRjbXAoJmRlbHRhX2EtPm9pZCwgJmRlbHRhX2ItPm9pZCk7Cn0KCnN0YXRpYyB2b2lkICp0aHJlYWRlZF9zZWNvbmRfcGFzcyh2b2lkICpkYXRhKQp7CglpZiAoZGF0YSkKCQlzZXRfdGhyZWFkX2RhdGEoZGF0YSk7Cglmb3IgKDs7KSB7CgkJc3RydWN0IGJhc2VfZGF0YSAqcGFyZW50ID0gTlVMTDsKCQlzdHJ1Y3Qgb2JqZWN0X2VudHJ5ICpjaGlsZF9vYmo7CgkJc3RydWN0IGJhc2VfZGF0YSAqY2hpbGQ7CgoJCWNvdW50ZXJfbG9jaygpOwoJCWRpc3BsYXlfcHJvZ3Jlc3MocHJvZ3Jlc3MsIG5yX3Jlc29sdmVkX2RlbHRhcyk7CgkJY291bnRlcl91bmxvY2soKTsKCgkJd29ya19sb2NrKCk7CgkJaWYgKGxpc3RfZW1wdHkoJndvcmtfaGVhZCkpIHsKCQkJLyoKCQkJICogVGFrZSBhbiBvYmplY3QgZnJvbSB0aGUgb2JqZWN0IGFycmF5LgoJCQkgKi8KCQkJd2hpbGUgKG5yX2Rpc3BhdGNoZWQgPCBucl9vYmplY3RzICYmCgkJCSAgICAgICBpc19kZWx0YV90eXBlKG9iamVjdHNbbnJfZGlzcGF0Y2hlZF0udHlwZSkpCgkJCQlucl9kaXNwYXRjaGVkKys7CgkJCWlmIChucl9kaXNwYXRjaGVkID49IG5yX29iamVjdHMpIHsKCQkJCXdvcmtfdW5sb2NrKCk7CgkJCQlicmVhazsKCQkJfQoJCQljaGlsZF9vYmogPSAmb2JqZWN0c1tucl9kaXNwYXRjaGVkKytdOwoJCX0gZWxzZSB7CgkJCS8qCgkJCSAqIFBlZWsgYXQgdGhlIHRvcCBvZiB0aGUgc3RhY2ssIGFuZCB0YWtlIGEgY2hpbGQgZnJvbQoJCQkgKiBpdC4KCQkJICovCgkJCXBhcmVudCA9IGxpc3RfZmlyc3RfZW50cnkoJndvcmtfaGVhZCwgc3RydWN0IGJhc2VfZGF0YSwKCQkJCQkJICBsaXN0KTsKCgkJCWlmIChwYXJlbnQtPnJlZl9maXJzdCA8PSBwYXJlbnQtPnJlZl9sYXN0KSB7CgkJCQlpbnQgb2Zmc2V0ID0gcmVmX2RlbHRhc1twYXJlbnQtPnJlZl9maXJzdCsrXS5vYmpfbm87CgkJCQljaGlsZF9vYmogPSBvYmplY3RzICsgb2Zmc2V0OwoJCQkJaWYgKGNoaWxkX29iai0+cmVhbF90eXBlICE9IE9CSl9SRUZfREVMVEEpCgkJCQkJZGllKCJSRUZfREVMVEEgYXQgb2Zmc2V0ICUiUFJJdU1BWCIgYWxyZWFkeSByZXNvbHZlZCAoZHVwbGljYXRlIGJhc2UgJXM/KSIsCgkJCQkJICAgICh1aW50bWF4X3QpIGNoaWxkX29iai0+aWR4Lm9mZnNldCwKCQkJCQkgICAgb2lkX3RvX2hleCgmcGFyZW50LT5vYmotPmlkeC5vaWQpKTsKCQkJCWNoaWxkX29iai0+cmVhbF90eXBlID0gcGFyZW50LT5vYmotPnJlYWxfdHlwZTsKCQkJfSBlbHNlIHsKCQkJCWNoaWxkX29iaiA9IG9iamVjdHMgKwoJCQkJCW9mc19kZWx0YXNbcGFyZW50LT5vZnNfZmlyc3QrK10ub2JqX25vOwoJCQkJYXNzZXJ0KGNoaWxkX29iai0+cmVhbF90eXBlID09IE9CSl9PRlNfREVMVEEpOwoJCQkJY2hpbGRfb2JqLT5yZWFsX3R5cGUgPSBwYXJlbnQtPm9iai0+cmVhbF90eXBlOwoJCQl9CgoJCQlpZiAocGFyZW50LT5yZWZfZmlyc3QgPiBwYXJlbnQtPnJlZl9sYXN0ICYmCgkJCSAgICBwYXJlbnQtPm9mc19maXJzdCA+IHBhcmVudC0+b2ZzX2xhc3QpIHsKCQkJCS8qCgkJCQkgKiBUaGlzIHBhcmVudCBoYXMgcnVuIG91dCBvZiBjaGlsZHJlbiwgc28gbW92ZQoJCQkJICogaXQgdG8gZG9uZV9oZWFkLgoJCQkJICovCgkJCQlsaXN0X2RlbCgmcGFyZW50LT5saXN0KTsKCQkJCWxpc3RfYWRkKCZwYXJlbnQtPmxpc3QsICZkb25lX2hlYWQpOwoJCQl9CgoJCQkvKgoJCQkgKiBFbnN1cmUgdGhhdCB0aGUgcGFyZW50IGhhcyBkYXRhLCBzaW5jZSB3ZSB3aWxsIG5lZWQKCQkJICogaXQgbGF0ZXIuCgkJCSAqCgkJCSAqIE5FRURTV09SSzogSWYgcGFyZW50IGRhdGEgbmVlZHMgdG8gYmUgcmVsb2FkZWQsIHRoaXMKCQkJICogcHJvbG9uZ3MgdGhlIHRpbWUgdGhhdCB0aGUgY3VycmVudCB0aHJlYWQgc3BlbmRzIGluCgkJCSAqIHRoZSBtdXRleC4gQSBtaXRpZ2F0aW5nIGZhY3RvciBpcyB0aGF0IHBhcmVudCBkYXRhCgkJCSAqIG5lZWRzIHRvIGJlIHJlbG9hZGVkIG9ubHkgaWYgdGhlIGRlbHRhIGJhc2UgY2FjaGUKCQkJICogbGltaXQgaXMgZXhjZWVkZWQsIHNvIGluIHRoZSB0eXBpY2FsIGNhc2UsIHRoaXMgZG9lcwoJCQkgKiBub3QgaGFwcGVuLgoJCQkgKi8KCQkJZ2V0X2Jhc2VfZGF0YShwYXJlbnQpOwoJCQlwYXJlbnQtPnJldGFpbl9kYXRhKys7CgkJfQoJCXdvcmtfdW5sb2NrKCk7CgoJCWlmIChwYXJlbnQpIHsKCQkJY2hpbGQgPSByZXNvbHZlX2RlbHRhKGNoaWxkX29iaiwgcGFyZW50KTsKCQkJaWYgKCFjaGlsZC0+Y2hpbGRyZW5fcmVtYWluaW5nKQoJCQkJRlJFRV9BTkRfTlVMTChjaGlsZC0+ZGF0YSk7CgkJfSBlbHNlIHsKCQkJY2hpbGQgPSBtYWtlX2Jhc2UoY2hpbGRfb2JqLCBOVUxMKTsKCQkJaWYgKGNoaWxkLT5jaGlsZHJlbl9yZW1haW5pbmcpIHsKCQkJCS8qCgkJCQkgKiBTaW5jZSB0aGlzIGNoaWxkIGhhcyBpdHMgb3duIGRlbHRhIGNoaWxkcmVuLAoJCQkJICogd2Ugd2lsbCBuZWVkIHRoaXMgZGF0YSBpbiB0aGUgZnV0dXJlLgoJCQkJICogSW5mbGF0ZSBub3cgc28gdGhhdCBmdXR1cmUgaXRlcmF0aW9ucyB3aWxsCgkJCQkgKiBoYXZlIGFjY2VzcyB0byB0aGlzIG9iamVjdCdzIGRhdGEgd2hpbGUKCQkJCSAqIG91dHNpZGUgdGhlIHdvcmsgbXV0ZXguCgkJCQkgKi8KCQkJCWNoaWxkLT5kYXRhID0gZ2V0X2RhdGFfZnJvbV9wYWNrKGNoaWxkX29iaik7CgkJCQljaGlsZC0+c2l6ZSA9IGNoaWxkX29iai0+c2l6ZTsKCQkJfQoJCX0KCgkJd29ya19sb2NrKCk7CgkJaWYgKHBhcmVudCkKCQkJcGFyZW50LT5yZXRhaW5fZGF0YS0tOwoJCWlmIChjaGlsZC0+ZGF0YSkgewoJCQkvKgoJCQkgKiBUaGlzIGNoaWxkIGhhcyBpdHMgb3duIGNoaWxkcmVuLCBzbyBhZGQgaXQgdG8KCQkJICogd29ya19oZWFkLgoJCQkgKi8KCQkJbGlzdF9hZGQoJmNoaWxkLT5saXN0LCAmd29ya19oZWFkKTsKCQkJYmFzZV9jYWNoZV91c2VkICs9IGNoaWxkLT5zaXplOwoJCQlwcnVuZV9iYXNlX2RhdGEoTlVMTCk7CgkJCWZyZWVfYmFzZV9kYXRhKGNoaWxkKTsKCQl9IGVsc2UgewoJCQkvKgoJCQkgKiBUaGlzIGNoaWxkIGRvZXMgbm90IGhhdmUgaXRzIG93biBjaGlsZHJlbi4gSXQgbWF5IGJlCgkJCSAqIHRoZSBsYXN0IGRlc2NlbmRhbnQgb2YgaXRzIGFuY2VzdG9yczsgZnJlZSB0aG9zZQoJCQkgKiB0aGF0IHdlIGNhbi4KCQkJICovCgkJCXN0cnVjdCBiYXNlX2RhdGEgKnAgPSBwYXJlbnQ7CgoJCQl3aGlsZSAocCkgewoJCQkJc3RydWN0IGJhc2VfZGF0YSAqbmV4dF9wOwoKCQkJCXAtPmNoaWxkcmVuX3JlbWFpbmluZy0tOwoJCQkJaWYgKHAtPmNoaWxkcmVuX3JlbWFpbmluZykKCQkJCQlicmVhazsKCgkJCQluZXh0X3AgPSBwLT5iYXNlOwoJCQkJZnJlZV9iYXNlX2RhdGEocCk7CgkJCQlsaXN0X2RlbCgmcC0+bGlzdCk7CgkJCQlmcmVlKHApOwoKCQkJCXAgPSBuZXh0X3A7CgkJCX0KCQkJRlJFRV9BTkRfTlVMTChjaGlsZCk7CgkJfQoJCXdvcmtfdW5sb2NrKCk7Cgl9CglyZXR1cm4gTlVMTDsKfQoKLyoKICogRmlyc3QgcGFzczoKICogLSBmaW5kIGxvY2F0aW9ucyBvZiBhbGwgb2JqZWN0czsKICogLSBjYWxjdWxhdGUgU0hBMSBvZiBhbGwgbm9uLWRlbHRhIG9iamVjdHM7CiAqIC0gcmVtZW1iZXIgYmFzZSAoU0hBMSBvciBvZmZzZXQpIGZvciBhbGwgZGVsdGFzLgogKi8Kc3RhdGljIHZvaWQgcGFyc2VfcGFja19vYmplY3RzKHVuc2lnbmVkIGNoYXIgKmhhc2gpCnsKCWludCBpLCBucl9kZWxheXMgPSAwOwoJc3RydWN0IG9mc19kZWx0YV9lbnRyeSAqb2ZzX2RlbHRhID0gb2ZzX2RlbHRhczsKCXN0cnVjdCBvYmplY3RfaWQgcmVmX2RlbHRhX29pZDsKCXN0cnVjdCBzdGF0IHN0OwoKCWlmICh2ZXJib3NlKQoJCXByb2dyZXNzID0gc3RhcnRfcHJvZ3Jlc3MoCgkJCQlwcm9ncmVzc190aXRsZSA/IHByb2dyZXNzX3RpdGxlIDoKCQkJCWZyb21fc3RkaW4gPyBfKCJSZWNlaXZpbmcgb2JqZWN0cyIpIDogXygiSW5kZXhpbmcgb2JqZWN0cyIpLAoJCQkJbnJfb2JqZWN0cyk7Cglmb3IgKGkgPSAwOyBpIDwgbnJfb2JqZWN0czsgaSsrKSB7CgkJc3RydWN0IG9iamVjdF9lbnRyeSAqb2JqID0gJm9iamVjdHNbaV07CgkJdm9pZCAqZGF0YSA9IHVucGFja19yYXdfZW50cnkob2JqLCAmb2ZzX2RlbHRhLT5vZmZzZXQsCgkJCQkJICAgICAgJnJlZl9kZWx0YV9vaWQsCgkJCQkJICAgICAgJm9iai0+aWR4Lm9pZCk7CgkJb2JqLT5yZWFsX3R5cGUgPSBvYmotPnR5cGU7CgkJaWYgKG9iai0+dHlwZSA9PSBPQkpfT0ZTX0RFTFRBKSB7CgkJCW5yX29mc19kZWx0YXMrKzsKCQkJb2ZzX2RlbHRhLT5vYmpfbm8gPSBpOwoJCQlvZnNfZGVsdGErKzsKCQl9IGVsc2UgaWYgKG9iai0+dHlwZSA9PSBPQkpfUkVGX0RFTFRBKSB7CgkJCUFMTE9DX0dST1cocmVmX2RlbHRhcywgbnJfcmVmX2RlbHRhcyArIDEsIHJlZl9kZWx0YXNfYWxsb2MpOwoJCQlvaWRjcHkoJnJlZl9kZWx0YXNbbnJfcmVmX2RlbHRhc10ub2lkLCAmcmVmX2RlbHRhX29pZCk7CgkJCXJlZl9kZWx0YXNbbnJfcmVmX2RlbHRhc10ub2JqX25vID0gaTsKCQkJbnJfcmVmX2RlbHRhcysrOwoJCX0gZWxzZSBpZiAoIWRhdGEpIHsKCQkJLyogbGFyZ2UgYmxvYnMsIGNoZWNrIGxhdGVyICovCgkJCW9iai0+cmVhbF90eXBlID0gT0JKX0JBRDsKCQkJbnJfZGVsYXlzKys7CgkJfSBlbHNlCgkJCXNoYTFfb2JqZWN0KGRhdGEsIE5VTEwsIG9iai0+c2l6ZSwgb2JqLT50eXBlLAoJCQkJICAgICZvYmotPmlkeC5vaWQpOwoJCWZyZWUoZGF0YSk7CgkJZGlzcGxheV9wcm9ncmVzcyhwcm9ncmVzcywgaSsxKTsKCX0KCW9iamVjdHNbaV0uaWR4Lm9mZnNldCA9IGNvbnN1bWVkX2J5dGVzOwoJc3RvcF9wcm9ncmVzcygmcHJvZ3Jlc3MpOwoKCS8qIENoZWNrIHBhY2sgaW50ZWdyaXR5ICovCglmbHVzaCgpOwoJdGhlX2hhc2hfYWxnby0+ZmluYWxfZm4oaGFzaCwgJmlucHV0X2N0eCk7CglpZiAoIWhhc2hlcShmaWxsKHRoZV9oYXNoX2FsZ28tPnJhd3N6KSwgaGFzaCkpCgkJZGllKF8oInBhY2sgaXMgY29ycnVwdGVkIChTSEExIG1pc21hdGNoKSIpKTsKCXVzZSh0aGVfaGFzaF9hbGdvLT5yYXdzeik7CgoJLyogSWYgaW5wdXRfZmQgaXMgYSBmaWxlLCB3ZSBzaG91bGQgaGF2ZSByZWFjaGVkIGl0cyBlbmQgbm93LiAqLwoJaWYgKGZzdGF0KGlucHV0X2ZkLCAmc3QpKQoJCWRpZV9lcnJubyhfKCJjYW5ub3QgZnN0YXQgcGFja2ZpbGUiKSk7CglpZiAoU19JU1JFRyhzdC5zdF9tb2RlKSAmJgoJCQlsc2VlayhpbnB1dF9mZCwgMCwgU0VFS19DVVIpIC0gaW5wdXRfbGVuICE9IHN0LnN0X3NpemUpCgkJZGllKF8oInBhY2sgaGFzIGp1bmsgYXQgdGhlIGVuZCIpKTsKCglmb3IgKGkgPSAwOyBpIDwgbnJfb2JqZWN0czsgaSsrKSB7CgkJc3RydWN0IG9iamVjdF9lbnRyeSAqb2JqID0gJm9iamVjdHNbaV07CgkJaWYgKG9iai0+cmVhbF90eXBlICE9IE9CSl9CQUQpCgkJCWNvbnRpbnVlOwoJCW9iai0+cmVhbF90eXBlID0gb2JqLT50eXBlOwoJCXNoYTFfb2JqZWN0KE5VTEwsIG9iaiwgb2JqLT5zaXplLCBvYmotPnR5cGUsCgkJCSAgICAmb2JqLT5pZHgub2lkKTsKCQlucl9kZWxheXMtLTsKCX0KCWlmIChucl9kZWxheXMpCgkJZGllKF8oImNvbmZ1c2lvbiBiZXlvbmQgaW5zYW5pdHkgaW4gcGFyc2VfcGFja19vYmplY3RzKCkiKSk7Cn0KCi8qCiAqIFNlY29uZCBwYXNzOgogKiAtIGZvciBhbGwgbm9uLWRlbHRhIG9iamVjdHMsIGxvb2sgaWYgaXQgaXMgdXNlZCBhcyBhIGJhc2UgZm9yCiAqICAgZGVsdGFzOwogKiAtIGlmIHVzZWQgYXMgYSBiYXNlLCB1bmNvbXByZXNzIHRoZSBvYmplY3QgYW5kIGFwcGx5IGFsbCBkZWx0YXMsCiAqICAgcmVjdXJzaXZlbHkgY2hlY2tpbmcgaWYgdGhlIHJlc3VsdGluZyBvYmplY3QgaXMgdXNlZCBhcyBhIGJhc2UKICogICBmb3Igc29tZSBtb3JlIGRlbHRhcy4KICovCnN0YXRpYyB2b2lkIHJlc29sdmVfZGVsdGFzKHZvaWQpCnsKCWludCBpOwoKCWlmICghbnJfb2ZzX2RlbHRhcyAmJiAhbnJfcmVmX2RlbHRhcykKCQlyZXR1cm47CgoJLyogU29ydCBkZWx0YXMgYnkgYmFzZSBTSEExL29mZnNldCBmb3IgZmFzdCBzZWFyY2hpbmcgKi8KCVFTT1JUKG9mc19kZWx0YXMsIG5yX29mc19kZWx0YXMsIGNvbXBhcmVfb2ZzX2RlbHRhX2VudHJ5KTsKCVFTT1JUKHJlZl9kZWx0YXMsIG5yX3JlZl9kZWx0YXMsIGNvbXBhcmVfcmVmX2RlbHRhX2VudHJ5KTsKCglpZiAodmVyYm9zZSB8fCBzaG93X3Jlc29sdmluZ19wcm9ncmVzcykKCQlwcm9ncmVzcyA9IHN0YXJ0X3Byb2dyZXNzKF8oIlJlc29sdmluZyBkZWx0YXMiKSwKCQkJCQkgIG5yX3JlZl9kZWx0YXMgKyBucl9vZnNfZGVsdGFzKTsKCglucl9kaXNwYXRjaGVkID0gMDsKCWJhc2VfY2FjaGVfbGltaXQgPSBkZWx0YV9iYXNlX2NhY2hlX2xpbWl0ICogbnJfdGhyZWFkczsKCWlmIChucl90aHJlYWRzID4gMSB8fCBnZXRlbnYoIkdJVF9GT1JDRV9USFJFQURTIikpIHsKCQlpbml0X3RocmVhZCgpOwoJCXdvcmtfbG9jaygpOwoJCWZvciAoaSA9IDA7IGkgPCBucl90aHJlYWRzOyBpKyspIHsKCQkJaW50IHJldCA9IHB0aHJlYWRfY3JlYXRlKCZ0aHJlYWRfZGF0YVtpXS50aHJlYWQsIE5VTEwsCgkJCQkJCSB0aHJlYWRlZF9zZWNvbmRfcGFzcywgdGhyZWFkX2RhdGEgKyBpKTsKCQkJaWYgKHJldCkKCQkJCWRpZShfKCJ1bmFibGUgdG8gY3JlYXRlIHRocmVhZDogJXMiKSwKCQkJCSAgICBzdHJlcnJvcihyZXQpKTsKCQl9CgkJd29ya191bmxvY2soKTsKCQlmb3IgKGkgPSAwOyBpIDwgbnJfdGhyZWFkczsgaSsrKQoJCQlwdGhyZWFkX2pvaW4odGhyZWFkX2RhdGFbaV0udGhyZWFkLCBOVUxMKTsKCQljbGVhbnVwX3RocmVhZCgpOwoJCXJldHVybjsKCX0KCXRocmVhZGVkX3NlY29uZF9wYXNzKCZub3RocmVhZF9kYXRhKTsKfQoKLyoKICogVGhpcmQgcGFzczoKICogLSBhcHBlbmQgb2JqZWN0cyB0byBjb252ZXJ0IHRoaW4gcGFjayB0byBmdWxsIHBhY2sgaWYgcmVxdWlyZWQKICogLSB3cml0ZSB0aGUgZmluYWwgcGFjayBoYXNoCiAqLwpzdGF0aWMgdm9pZCBmaXhfdW5yZXNvbHZlZF9kZWx0YXMoc3RydWN0IGhhc2hmaWxlICpmKTsKc3RhdGljIHZvaWQgY29uY2x1ZGVfcGFjayhpbnQgZml4X3RoaW5fcGFjaywgY29uc3QgY2hhciAqY3Vycl9wYWNrLCB1bnNpZ25lZCBjaGFyICpwYWNrX2hhc2gpCnsKCWlmIChucl9yZWZfZGVsdGFzICsgbnJfb2ZzX2RlbHRhcyA9PSBucl9yZXNvbHZlZF9kZWx0YXMpIHsKCQlzdG9wX3Byb2dyZXNzKCZwcm9ncmVzcyk7CgkJLyogRmx1c2ggcmVtYWluaW5nIHBhY2sgZmluYWwgaGFzaC4gKi8KCQlmbHVzaCgpOwoJCXJldHVybjsKCX0KCglpZiAoZml4X3RoaW5fcGFjaykgewoJCXN0cnVjdCBoYXNoZmlsZSAqZjsKCQl1bnNpZ25lZCBjaGFyIHJlYWRfaGFzaFtHSVRfTUFYX1JBV1NaXSwgdGFpbF9oYXNoW0dJVF9NQVhfUkFXU1pdOwoJCXN0cnVjdCBzdHJidWYgbXNnID0gU1RSQlVGX0lOSVQ7CgkJaW50IG5yX3VucmVzb2x2ZWQgPSBucl9vZnNfZGVsdGFzICsgbnJfcmVmX2RlbHRhcyAtIG5yX3Jlc29sdmVkX2RlbHRhczsKCQlpbnQgbnJfb2JqZWN0c19pbml0aWFsID0gbnJfb2JqZWN0czsKCQlpZiAobnJfdW5yZXNvbHZlZCA8PSAwKQoJCQlkaWUoXygiY29uZnVzaW9uIGJleW9uZCBpbnNhbml0eSIpKTsKCQlSRUFMTE9DX0FSUkFZKG9iamVjdHMsIG5yX29iamVjdHMgKyBucl91bnJlc29sdmVkICsgMSk7CgkJbWVtc2V0KG9iamVjdHMgKyBucl9vYmplY3RzICsgMSwgMCwKCQkgICAgICAgbnJfdW5yZXNvbHZlZCAqIHNpemVvZigqb2JqZWN0cykpOwoJCWYgPSBoYXNoZmQob3V0cHV0X2ZkLCBjdXJyX3BhY2spOwoJCWZpeF91bnJlc29sdmVkX2RlbHRhcyhmKTsKCQlzdHJidWZfYWRkZigmbXNnLCBRXygiY29tcGxldGVkIHdpdGggJWQgbG9jYWwgb2JqZWN0IiwKCQkJCSAgICAgImNvbXBsZXRlZCB3aXRoICVkIGxvY2FsIG9iamVjdHMiLAoJCQkJICAgICBucl9vYmplY3RzIC0gbnJfb2JqZWN0c19pbml0aWFsKSwKCQkJICAgIG5yX29iamVjdHMgLSBucl9vYmplY3RzX2luaXRpYWwpOwoJCXN0b3BfcHJvZ3Jlc3NfbXNnKCZwcm9ncmVzcywgbXNnLmJ1Zik7CgkJc3RyYnVmX3JlbGVhc2UoJm1zZyk7CgkJZmluYWxpemVfaGFzaGZpbGUoZiwgdGFpbF9oYXNoLCBGU1lOQ19DT01QT05FTlRfUEFDSywgMCk7CgkJaGFzaGNweShyZWFkX2hhc2gsIHBhY2tfaGFzaCk7CgkJZml4dXBfcGFja19oZWFkZXJfZm9vdGVyKG91dHB1dF9mZCwgcGFja19oYXNoLAoJCQkJCSBjdXJyX3BhY2ssIG5yX29iamVjdHMsCgkJCQkJIHJlYWRfaGFzaCwgY29uc3VtZWRfYnl0ZXMtdGhlX2hhc2hfYWxnby0+cmF3c3opOwoJCWlmICghaGFzaGVxKHJlYWRfaGFzaCwgdGFpbF9oYXNoKSkKCQkJZGllKF8oIlVuZXhwZWN0ZWQgdGFpbCBjaGVja3N1bSBmb3IgJXMgIgoJCQkgICAgICAiKGRpc2sgY29ycnVwdGlvbj8pIiksIGN1cnJfcGFjayk7Cgl9CglpZiAobnJfb2ZzX2RlbHRhcyArIG5yX3JlZl9kZWx0YXMgIT0gbnJfcmVzb2x2ZWRfZGVsdGFzKQoJCWRpZShRXygicGFjayBoYXMgJWQgdW5yZXNvbHZlZCBkZWx0YSIsCgkJICAgICAgICJwYWNrIGhhcyAlZCB1bnJlc29sdmVkIGRlbHRhcyIsCgkJICAgICAgIG5yX29mc19kZWx0YXMgKyBucl9yZWZfZGVsdGFzIC0gbnJfcmVzb2x2ZWRfZGVsdGFzKSwKCQkgICAgbnJfb2ZzX2RlbHRhcyArIG5yX3JlZl9kZWx0YXMgLSBucl9yZXNvbHZlZF9kZWx0YXMpOwp9CgpzdGF0aWMgaW50IHdyaXRlX2NvbXByZXNzZWQoc3RydWN0IGhhc2hmaWxlICpmLCB2b2lkICppbiwgdW5zaWduZWQgaW50IHNpemUpCnsKCWdpdF96c3RyZWFtIHN0cmVhbTsKCWludCBzdGF0dXM7Cgl1bnNpZ25lZCBjaGFyIG91dGJ1Zls0MDk2XTsKCglnaXRfZGVmbGF0ZV9pbml0KCZzdHJlYW0sIHpsaWJfY29tcHJlc3Npb25fbGV2ZWwpOwoJc3RyZWFtLm5leHRfaW4gPSBpbjsKCXN0cmVhbS5hdmFpbF9pbiA9IHNpemU7CgoJZG8gewoJCXN0cmVhbS5uZXh0X291dCA9IG91dGJ1ZjsKCQlzdHJlYW0uYXZhaWxfb3V0ID0gc2l6ZW9mKG91dGJ1Zik7CgkJc3RhdHVzID0gZ2l0X2RlZmxhdGUoJnN0cmVhbSwgWl9GSU5JU0gpOwoJCWhhc2h3cml0ZShmLCBvdXRidWYsIHNpemVvZihvdXRidWYpIC0gc3RyZWFtLmF2YWlsX291dCk7Cgl9IHdoaWxlIChzdGF0dXMgPT0gWl9PSyk7CgoJaWYgKHN0YXR1cyAhPSBaX1NUUkVBTV9FTkQpCgkJZGllKF8oInVuYWJsZSB0byBkZWZsYXRlIGFwcGVuZGVkIG9iamVjdCAoJWQpIiksIHN0YXR1cyk7CglzaXplID0gc3RyZWFtLnRvdGFsX291dDsKCWdpdF9kZWZsYXRlX2VuZCgmc3RyZWFtKTsKCXJldHVybiBzaXplOwp9CgpzdGF0aWMgc3RydWN0IG9iamVjdF9lbnRyeSAqYXBwZW5kX29ial90b19wYWNrKHN0cnVjdCBoYXNoZmlsZSAqZiwKCQkJICAgICAgIGNvbnN0IHVuc2lnbmVkIGNoYXIgKnNoYTEsIHZvaWQgKmJ1ZiwKCQkJICAgICAgIHVuc2lnbmVkIGxvbmcgc2l6ZSwgZW51bSBvYmplY3RfdHlwZSB0eXBlKQp7CglzdHJ1Y3Qgb2JqZWN0X2VudHJ5ICpvYmogPSAmb2JqZWN0c1tucl9vYmplY3RzKytdOwoJdW5zaWduZWQgY2hhciBoZWFkZXJbMTBdOwoJdW5zaWduZWQgbG9uZyBzID0gc2l6ZTsKCWludCBuID0gMDsKCXVuc2lnbmVkIGNoYXIgYyA9ICh0eXBlIDw8IDQpIHwgKHMgJiAxNSk7CglzID4+PSA0OwoJd2hpbGUgKHMpIHsKCQloZWFkZXJbbisrXSA9IGMgfCAweDgwOwoJCWMgPSBzICYgMHg3ZjsKCQlzID4+PSA3OwoJfQoJaGVhZGVyW24rK10gPSBjOwoJY3JjMzJfYmVnaW4oZik7CgloYXNod3JpdGUoZiwgaGVhZGVyLCBuKTsKCW9ialswXS5zaXplID0gc2l6ZTsKCW9ialswXS5oZHJfc2l6ZSA9IG47CglvYmpbMF0udHlwZSA9IHR5cGU7CglvYmpbMF0ucmVhbF90eXBlID0gdHlwZTsKCW9ialsxXS5pZHgub2Zmc2V0ID0gb2JqWzBdLmlkeC5vZmZzZXQgKyBuOwoJb2JqWzFdLmlkeC5vZmZzZXQgKz0gd3JpdGVfY29tcHJlc3NlZChmLCBidWYsIHNpemUpOwoJb2JqWzBdLmlkeC5jcmMzMiA9IGNyYzMyX2VuZChmKTsKCWhhc2hmbHVzaChmKTsKCW9pZHJlYWQoJm9iai0+aWR4Lm9pZCwgc2hhMSk7CglyZXR1cm4gb2JqOwp9CgpzdGF0aWMgaW50IGRlbHRhX3Bvc19jb21wYXJlKGNvbnN0IHZvaWQgKl9hLCBjb25zdCB2b2lkICpfYikKewoJc3RydWN0IHJlZl9kZWx0YV9lbnRyeSAqYSA9ICooc3RydWN0IHJlZl9kZWx0YV9lbnRyeSAqKilfYTsKCXN0cnVjdCByZWZfZGVsdGFfZW50cnkgKmIgPSAqKHN0cnVjdCByZWZfZGVsdGFfZW50cnkgKiopX2I7CglyZXR1cm4gYS0+b2JqX25vIC0gYi0+b2JqX25vOwp9CgpzdGF0aWMgdm9pZCBmaXhfdW5yZXNvbHZlZF9kZWx0YXMoc3RydWN0IGhhc2hmaWxlICpmKQp7CglzdHJ1Y3QgcmVmX2RlbHRhX2VudHJ5ICoqc29ydGVkX2J5X3BvczsKCWludCBpOwoKCS8qCgkgKiBTaW5jZSBtYW55IHVucmVzb2x2ZWQgZGVsdGFzIG1heSB3ZWxsIGJlIHRoZW1zZWx2ZXMgYmFzZSBvYmplY3RzCgkgKiBmb3IgbW9yZSB1bnJlc29sdmVkIGRlbHRhcywgd2UgcmVhbGx5IHdhbnQgdG8gaW5jbHVkZSB0aGUKCSAqIHNtYWxsZXN0IG51bWJlciBvZiBiYXNlIG9iamVjdHMgdGhhdCB3b3VsZCBjb3ZlciBhcyBtdWNoIGRlbHRhCgkgKiBhcyBwb3NzaWJsZSBieSBwaWNraW5nIHRoZQoJICogdHJ1bmMgZGVsdGFzIGZpcnN0LCBhbGxvd2luZyBmb3Igb3RoZXIgZGVsdGFzIHRvIHJlc29sdmUgd2l0aG91dAoJICogYWRkaXRpb25hbCBiYXNlIG9iamVjdHMuICBTaW5jZSBtb3N0IGJhc2Ugb2JqZWN0cyBhcmUgdG8gYmUgZm91bmQKCSAqIGJlZm9yZSBkZWx0YXMgZGVwZW5kaW5nIG9uIHRoZW0sIGEgZ29vZCBoZXVyaXN0aWMgaXMgdG8gc3RhcnQKCSAqIHJlc29sdmluZyBkZWx0YXMgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlaXIgcG9zaXRpb24gaW4gdGhlIHBhY2suCgkgKi8KCUFMTE9DX0FSUkFZKHNvcnRlZF9ieV9wb3MsIG5yX3JlZl9kZWx0YXMpOwoJZm9yIChpID0gMDsgaSA8IG5yX3JlZl9kZWx0YXM7IGkrKykKCQlzb3J0ZWRfYnlfcG9zW2ldID0gJnJlZl9kZWx0YXNbaV07CglRU09SVChzb3J0ZWRfYnlfcG9zLCBucl9yZWZfZGVsdGFzLCBkZWx0YV9wb3NfY29tcGFyZSk7CgoJaWYgKGhhc19wcm9taXNvcl9yZW1vdGUoKSkgewoJCS8qCgkJICogUHJlZmV0Y2ggdGhlIGRlbHRhIGJhc2VzLgoJCSAqLwoJCXN0cnVjdCBvaWRfYXJyYXkgdG9fZmV0Y2ggPSBPSURfQVJSQVlfSU5JVDsKCQlmb3IgKGkgPSAwOyBpIDwgbnJfcmVmX2RlbHRhczsgaSsrKSB7CgkJCXN0cnVjdCByZWZfZGVsdGFfZW50cnkgKmQgPSBzb3J0ZWRfYnlfcG9zW2ldOwoJCQlpZiAoIW9pZF9vYmplY3RfaW5mb19leHRlbmRlZCh0aGVfcmVwb3NpdG9yeSwgJmQtPm9pZCwKCQkJCQkJICAgICAgTlVMTCwKCQkJCQkJICAgICAgT0JKRUNUX0lORk9fRk9SX1BSRUZFVENIKSkKCQkJCWNvbnRpbnVlOwoJCQlvaWRfYXJyYXlfYXBwZW5kKCZ0b19mZXRjaCwgJmQtPm9pZCk7CgkJfQoJCXByb21pc29yX3JlbW90ZV9nZXRfZGlyZWN0KHRoZV9yZXBvc2l0b3J5LAoJCQkJCSAgIHRvX2ZldGNoLm9pZCwgdG9fZmV0Y2gubnIpOwoJCW9pZF9hcnJheV9jbGVhcigmdG9fZmV0Y2gpOwoJfQoKCWZvciAoaSA9IDA7IGkgPCBucl9yZWZfZGVsdGFzOyBpKyspIHsKCQlzdHJ1Y3QgcmVmX2RlbHRhX2VudHJ5ICpkID0gc29ydGVkX2J5X3Bvc1tpXTsKCQllbnVtIG9iamVjdF90eXBlIHR5cGU7CgkJdm9pZCAqZGF0YTsKCQl1bnNpZ25lZCBsb25nIHNpemU7CgoJCWlmIChvYmplY3RzW2QtPm9ial9ub10ucmVhbF90eXBlICE9IE9CSl9SRUZfREVMVEEpCgkJCWNvbnRpbnVlOwoJCWRhdGEgPSByZWFkX29iamVjdF9maWxlKCZkLT5vaWQsICZ0eXBlLCAmc2l6ZSk7CgkJaWYgKCFkYXRhKQoJCQljb250aW51ZTsKCgkJaWYgKGNoZWNrX29iamVjdF9zaWduYXR1cmUodGhlX3JlcG9zaXRvcnksICZkLT5vaWQsIGRhdGEsIHNpemUsCgkJCQkJICAgdHlwZSkgPCAwKQoJCQlkaWUoXygibG9jYWwgb2JqZWN0ICVzIGlzIGNvcnJ1cHQiKSwgb2lkX3RvX2hleCgmZC0+b2lkKSk7CgoJCS8qCgkJICogQWRkIHRoaXMgYXMgYW4gb2JqZWN0IHRvIHRoZSBvYmplY3RzIGFycmF5IGFuZCBjYWxsCgkJICogdGhyZWFkZWRfc2Vjb25kX3Bhc3MoKSAod2hpY2ggd2lsbCBwaWNrIHVwIHRoZSBhZGRlZAoJCSAqIG9iamVjdCkuCgkJICovCgkJYXBwZW5kX29ial90b19wYWNrKGYsIGQtPm9pZC5oYXNoLCBkYXRhLCBzaXplLCB0eXBlKTsKCQlmcmVlKGRhdGEpOwoJCXRocmVhZGVkX3NlY29uZF9wYXNzKE5VTEwpOwoKCQlkaXNwbGF5X3Byb2dyZXNzKHByb2dyZXNzLCBucl9yZXNvbHZlZF9kZWx0YXMpOwoJfQoJZnJlZShzb3J0ZWRfYnlfcG9zKTsKfQoKc3RhdGljIGNvbnN0IGNoYXIgKmRlcml2ZV9maWxlbmFtZShjb25zdCBjaGFyICpwYWNrX25hbWUsIGNvbnN0IGNoYXIgKnN0cmlwLAoJCQkJICAgY29uc3QgY2hhciAqc3VmZml4LCBzdHJ1Y3Qgc3RyYnVmICpidWYpCnsKCXNpemVfdCBsZW47CglpZiAoIXN0cmlwX3N1ZmZpeChwYWNrX25hbWUsIHN0cmlwLCAmbGVuKSB8fCAhbGVuIHx8CgkgICAgcGFja19uYW1lW2xlbiAtIDFdICE9ICcuJykKCQlkaWUoXygicGFja2ZpbGUgbmFtZSAnJXMnIGRvZXMgbm90IGVuZCB3aXRoICcuJXMnIiksCgkJICAgIHBhY2tfbmFtZSwgc3RyaXApOwoJc3RyYnVmX2FkZChidWYsIHBhY2tfbmFtZSwgbGVuKTsKCXN0cmJ1Zl9hZGRzdHIoYnVmLCBzdWZmaXgpOwoJcmV0dXJuIGJ1Zi0+YnVmOwp9CgpzdGF0aWMgdm9pZCB3cml0ZV9zcGVjaWFsX2ZpbGUoY29uc3QgY2hhciAqc3VmZml4LCBjb25zdCBjaGFyICptc2csCgkJCSAgICAgICBjb25zdCBjaGFyICpwYWNrX25hbWUsIGNvbnN0IHVuc2lnbmVkIGNoYXIgKmhhc2gsCgkJCSAgICAgICBjb25zdCBjaGFyICoqcmVwb3J0KQp7CglzdHJ1Y3Qgc3RyYnVmIG5hbWVfYnVmID0gU1RSQlVGX0lOSVQ7Cgljb25zdCBjaGFyICpmaWxlbmFtZTsKCWludCBmZDsKCWludCBtc2dfbGVuID0gc3RybGVuKG1zZyk7CgoJaWYgKHBhY2tfbmFtZSkKCQlmaWxlbmFtZSA9IGRlcml2ZV9maWxlbmFtZShwYWNrX25hbWUsICJwYWNrIiwgc3VmZml4LCAmbmFtZV9idWYpOwoJZWxzZQoJCWZpbGVuYW1lID0gb2RiX3BhY2tfbmFtZSgmbmFtZV9idWYsIGhhc2gsIHN1ZmZpeCk7CgoJZmQgPSBvZGJfcGFja19rZWVwKGZpbGVuYW1lKTsKCWlmIChmZCA8IDApIHsKCQlpZiAoZXJybm8gIT0gRUVYSVNUKQoJCQlkaWVfZXJybm8oXygiY2Fubm90IHdyaXRlICVzIGZpbGUgJyVzJyIpLAoJCQkJICBzdWZmaXgsIGZpbGVuYW1lKTsKCX0gZWxzZSB7CgkJaWYgKG1zZ19sZW4gPiAwKSB7CgkJCXdyaXRlX29yX2RpZShmZCwgbXNnLCBtc2dfbGVuKTsKCQkJd3JpdGVfb3JfZGllKGZkLCAiXG4iLCAxKTsKCQl9CgkJaWYgKGNsb3NlKGZkKSAhPSAwKQoJCQlkaWVfZXJybm8oXygiY2Fubm90IGNsb3NlIHdyaXR0ZW4gJXMgZmlsZSAnJXMnIiksCgkJCQkgIHN1ZmZpeCwgZmlsZW5hbWUpOwoJCWlmIChyZXBvcnQpCgkJCSpyZXBvcnQgPSBzdWZmaXg7Cgl9CglzdHJidWZfcmVsZWFzZSgmbmFtZV9idWYpOwp9CgpzdGF0aWMgdm9pZCByZW5hbWVfdG1wX3BhY2tmaWxlKGNvbnN0IGNoYXIgKipmaW5hbF9uYW1lLAoJCQkJY29uc3QgY2hhciAqY3Vycl9uYW1lLAoJCQkJc3RydWN0IHN0cmJ1ZiAqbmFtZSwgdW5zaWduZWQgY2hhciAqaGFzaCwKCQkJCWNvbnN0IGNoYXIgKmV4dCwgaW50IG1ha2VfcmVhZF9vbmx5X2lmX3NhbWUpCnsKCWlmICgqZmluYWxfbmFtZSAhPSBjdXJyX25hbWUpIHsKCQlpZiAoISpmaW5hbF9uYW1lKQoJCQkqZmluYWxfbmFtZSA9IG9kYl9wYWNrX25hbWUobmFtZSwgaGFzaCwgZXh0KTsKCQlpZiAoZmluYWxpemVfb2JqZWN0X2ZpbGUoY3Vycl9uYW1lLCAqZmluYWxfbmFtZSkpCgkJCWRpZShfKCJ1bmFibGUgdG8gcmVuYW1lIHRlbXBvcmFyeSAnKi4lcycgZmlsZSB0byAnJXMnIiksCgkJCSAgICBleHQsICpmaW5hbF9uYW1lKTsKCX0gZWxzZSBpZiAobWFrZV9yZWFkX29ubHlfaWZfc2FtZSkgewoJCWNobW9kKCpmaW5hbF9uYW1lLCAwNDQ0KTsKCX0KfQoKc3RhdGljIHZvaWQgZmluYWwoY29uc3QgY2hhciAqZmluYWxfcGFja19uYW1lLCBjb25zdCBjaGFyICpjdXJyX3BhY2tfbmFtZSwKCQkgIGNvbnN0IGNoYXIgKmZpbmFsX2luZGV4X25hbWUsIGNvbnN0IGNoYXIgKmN1cnJfaW5kZXhfbmFtZSwKCQkgIGNvbnN0IGNoYXIgKmZpbmFsX3Jldl9pbmRleF9uYW1lLCBjb25zdCBjaGFyICpjdXJyX3Jldl9pbmRleF9uYW1lLAoJCSAgY29uc3QgY2hhciAqa2VlcF9tc2csIGNvbnN0IGNoYXIgKnByb21pc29yX21zZywKCQkgIHVuc2lnbmVkIGNoYXIgKmhhc2gpCnsKCWNvbnN0IGNoYXIgKnJlcG9ydCA9ICJwYWNrIjsKCXN0cnVjdCBzdHJidWYgcGFja19uYW1lID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3Qgc3RyYnVmIGluZGV4X25hbWUgPSBTVFJCVUZfSU5JVDsKCXN0cnVjdCBzdHJidWYgcmV2X2luZGV4X25hbWUgPSBTVFJCVUZfSU5JVDsKCWludCBlcnI7CgoJaWYgKCFmcm9tX3N0ZGluKSB7CgkJY2xvc2UoaW5wdXRfZmQpOwoJfSBlbHNlIHsKCQlmc3luY19jb21wb25lbnRfb3JfZGllKEZTWU5DX0NPTVBPTkVOVF9QQUNLLCBvdXRwdXRfZmQsIGN1cnJfcGFja19uYW1lKTsKCQllcnIgPSBjbG9zZShvdXRwdXRfZmQpOwoJCWlmIChlcnIpCgkJCWRpZV9lcnJubyhfKCJlcnJvciB3aGlsZSBjbG9zaW5nIHBhY2sgZmlsZSIpKTsKCX0KCglpZiAoa2VlcF9tc2cpCgkJd3JpdGVfc3BlY2lhbF9maWxlKCJrZWVwIiwga2VlcF9tc2csIGZpbmFsX3BhY2tfbmFtZSwgaGFzaCwKCQkJCSAgICZyZXBvcnQpOwoJaWYgKHByb21pc29yX21zZykKCQl3cml0ZV9zcGVjaWFsX2ZpbGUoInByb21pc29yIiwgcHJvbWlzb3JfbXNnLCBmaW5hbF9wYWNrX25hbWUsCgkJCQkgICBoYXNoLCBOVUxMKTsKCglyZW5hbWVfdG1wX3BhY2tmaWxlKCZmaW5hbF9wYWNrX25hbWUsIGN1cnJfcGFja19uYW1lLCAmcGFja19uYW1lLAoJCQkgICAgaGFzaCwgInBhY2siLCBmcm9tX3N0ZGluKTsKCWlmIChjdXJyX3Jldl9pbmRleF9uYW1lKQoJCXJlbmFtZV90bXBfcGFja2ZpbGUoJmZpbmFsX3Jldl9pbmRleF9uYW1lLCBjdXJyX3Jldl9pbmRleF9uYW1lLAoJCQkJICAgICZyZXZfaW5kZXhfbmFtZSwgaGFzaCwgInJldiIsIDEpOwoJcmVuYW1lX3RtcF9wYWNrZmlsZSgmZmluYWxfaW5kZXhfbmFtZSwgY3Vycl9pbmRleF9uYW1lLCAmaW5kZXhfbmFtZSwKCQkJICAgIGhhc2gsICJpZHgiLCAxKTsKCglpZiAoZG9fZnNja19vYmplY3QpIHsKCQlzdHJ1Y3QgcGFja2VkX2dpdCAqcDsKCQlwID0gYWRkX3BhY2tlZF9naXQoZmluYWxfaW5kZXhfbmFtZSwgc3RybGVuKGZpbmFsX2luZGV4X25hbWUpLCAwKTsKCQlpZiAocCkKCQkJaW5zdGFsbF9wYWNrZWRfZ2l0KHRoZV9yZXBvc2l0b3J5LCBwKTsKCX0KCglpZiAoIWZyb21fc3RkaW4pIHsKCQlwcmludGYoIiVzXG4iLCBoYXNoX3RvX2hleChoYXNoKSk7Cgl9IGVsc2UgewoJCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7CgoJCXN0cmJ1Zl9hZGRmKCZidWYsICIlc1x0JXNcbiIsIHJlcG9ydCwgaGFzaF90b19oZXgoaGFzaCkpOwoJCXdyaXRlX29yX2RpZSgxLCBidWYuYnVmLCBidWYubGVuKTsKCQlzdHJidWZfcmVsZWFzZSgmYnVmKTsKCgkJLyoKCQkgKiBMZXQncyBqdXN0IG1pbWljIGdpdC11bnBhY2stb2JqZWN0cyBoZXJlIGFuZCB3cml0ZQoJCSAqIHRoZSBsYXN0IHBhcnQgb2YgdGhlIGlucHV0IGJ1ZmZlciB0byBzdGRvdXQuCgkJICovCgkJd2hpbGUgKGlucHV0X2xlbikgewoJCQllcnIgPSB4d3JpdGUoMSwgaW5wdXRfYnVmZmVyICsgaW5wdXRfb2Zmc2V0LCBpbnB1dF9sZW4pOwoJCQlpZiAoZXJyIDw9IDApCgkJCQlicmVhazsKCQkJaW5wdXRfbGVuIC09IGVycjsKCQkJaW5wdXRfb2Zmc2V0ICs9IGVycjsKCQl9Cgl9CgoJc3RyYnVmX3JlbGVhc2UoJnJldl9pbmRleF9uYW1lKTsKCXN0cmJ1Zl9yZWxlYXNlKCZpbmRleF9uYW1lKTsKCXN0cmJ1Zl9yZWxlYXNlKCZwYWNrX25hbWUpOwp9CgpzdGF0aWMgaW50IGdpdF9pbmRleF9wYWNrX2NvbmZpZyhjb25zdCBjaGFyICprLCBjb25zdCBjaGFyICp2LCB2b2lkICpjYikKewoJc3RydWN0IHBhY2tfaWR4X29wdGlvbiAqb3B0cyA9IGNiOwoKCWlmICghc3RyY21wKGssICJwYWNrLmluZGV4dmVyc2lvbiIpKSB7CgkJb3B0cy0+dmVyc2lvbiA9IGdpdF9jb25maWdfaW50KGssIHYpOwoJCWlmIChvcHRzLT52ZXJzaW9uID4gMikKCQkJZGllKF8oImJhZCBwYWNrLmluZGV4VmVyc2lvbj0lIlBSSXUzMiksIG9wdHMtPnZlcnNpb24pOwoJCXJldHVybiAwOwoJfQoJaWYgKCFzdHJjbXAoaywgInBhY2sudGhyZWFkcyIpKSB7CgkJbnJfdGhyZWFkcyA9IGdpdF9jb25maWdfaW50KGssIHYpOwoJCWlmIChucl90aHJlYWRzIDwgMCkKCQkJZGllKF8oImludmFsaWQgbnVtYmVyIG9mIHRocmVhZHMgc3BlY2lmaWVkICglZCkiKSwKCQkJICAgIG5yX3RocmVhZHMpOwoJCWlmICghSEFWRV9USFJFQURTICYmIG5yX3RocmVhZHMgIT0gMSkgewoJCQl3YXJuaW5nKF8oIm5vIHRocmVhZHMgc3VwcG9ydCwgaWdub3JpbmcgJXMiKSwgayk7CgkJCW5yX3RocmVhZHMgPSAxOwoJCX0KCQlyZXR1cm4gMDsKCX0KCWlmICghc3RyY21wKGssICJwYWNrLndyaXRlcmV2ZXJzZWluZGV4IikpIHsKCQlpZiAoZ2l0X2NvbmZpZ19ib29sKGssIHYpKQoJCQlvcHRzLT5mbGFncyB8PSBXUklURV9SRVY7CgkJZWxzZQoJCQlvcHRzLT5mbGFncyAmPSB+V1JJVEVfUkVWOwoJfQoJcmV0dXJuIGdpdF9kZWZhdWx0X2NvbmZpZyhrLCB2LCBjYik7Cn0KCnN0YXRpYyBpbnQgY21wX3VpbnQzMihjb25zdCB2b2lkICphXywgY29uc3Qgdm9pZCAqYl8pCnsKCXVpbnQzMl90IGEgPSAqKCh1aW50MzJfdCAqKWFfKTsKCXVpbnQzMl90IGIgPSAqKCh1aW50MzJfdCAqKWJfKTsKCglyZXR1cm4gKGEgPCBiKSA/IC0xIDogKGEgIT0gYik7Cn0KCnN0YXRpYyB2b2lkIHJlYWRfdjJfYW5vbWFsb3VzX29mZnNldHMoc3RydWN0IHBhY2tlZF9naXQgKnAsCgkJCQkgICAgICBzdHJ1Y3QgcGFja19pZHhfb3B0aW9uICpvcHRzKQp7Cgljb25zdCB1aW50MzJfdCAqaWR4MSwgKmlkeDI7Cgl1aW50MzJfdCBpOwoKCS8qIFRoZSBhZGRyZXNzIG9mIHRoZSA0LWJ5dGUgb2Zmc2V0IHRhYmxlICovCglpZHgxID0gKCgoY29uc3QgdWludDMyX3QgKikoKGNvbnN0IHVpbnQ4X3QgKilwLT5pbmRleF9kYXRhICsgcC0+Y3JjX29mZnNldCkpCgkJKyAoc2l6ZV90KXAtPm51bV9vYmplY3RzIC8qIENSQzMyIHRhYmxlICovCgkJKTsKCgkvKiBUaGUgYWRkcmVzcyBvZiB0aGUgOC1ieXRlIG9mZnNldCB0YWJsZSAqLwoJaWR4MiA9IGlkeDEgKyBwLT5udW1fb2JqZWN0czsKCglmb3IgKGkgPSAwOyBpIDwgcC0+bnVtX29iamVjdHM7IGkrKykgewoJCXVpbnQzMl90IG9mZiA9IG50b2hsKGlkeDFbaV0pOwoJCWlmICghKG9mZiAmIDB4ODAwMDAwMDApKQoJCQljb250aW51ZTsKCQlvZmYgPSBvZmYgJiAweDdmZmZmZmZmOwoJCWNoZWNrX3BhY2tfaW5kZXhfcHRyKHAsICZpZHgyW29mZiAqIDJdKTsKCQlpZiAoaWR4MltvZmYgKiAyXSkKCQkJY29udGludWU7CgkJLyoKCQkgKiBUaGUgcmVhbCBvZmZzZXQgaXMgbnRvaGwoaWR4MltvZmYgKiAyXSkgaW4gaGlnaCA0CgkJICogb2N0ZXRzLCBhbmQgbnRvaGwoaWR4MltvZmYgKiAyICsgMV0pIGluIGxvdyA0CgkJICogb2N0ZXRzLiAgQnV0IGlkeDJbb2ZmICogMl0gaXMgWmVybyEhIQoJCSAqLwoJCUFMTE9DX0dST1cob3B0cy0+YW5vbWFseSwgb3B0cy0+YW5vbWFseV9uciArIDEsIG9wdHMtPmFub21hbHlfYWxsb2MpOwoJCW9wdHMtPmFub21hbHlbb3B0cy0+YW5vbWFseV9ucisrXSA9IG50b2hsKGlkeDJbb2ZmICogMiArIDFdKTsKCX0KCglRU09SVChvcHRzLT5hbm9tYWx5LCBvcHRzLT5hbm9tYWx5X25yLCBjbXBfdWludDMyKTsKfQoKc3RhdGljIHZvaWQgcmVhZF9pZHhfb3B0aW9uKHN0cnVjdCBwYWNrX2lkeF9vcHRpb24gKm9wdHMsIGNvbnN0IGNoYXIgKnBhY2tfbmFtZSkKewoJc3RydWN0IHBhY2tlZF9naXQgKnAgPSBhZGRfcGFja2VkX2dpdChwYWNrX25hbWUsIHN0cmxlbihwYWNrX25hbWUpLCAxKTsKCglpZiAoIXApCgkJZGllKF8oIkNhbm5vdCBvcGVuIGV4aXN0aW5nIHBhY2sgZmlsZSAnJXMnIiksIHBhY2tfbmFtZSk7CglpZiAob3Blbl9wYWNrX2luZGV4KHApKQoJCWRpZShfKCJDYW5ub3Qgb3BlbiBleGlzdGluZyBwYWNrIGlkeCBmaWxlIGZvciAnJXMnIiksIHBhY2tfbmFtZSk7CgoJLyogUmVhZCB0aGUgYXR0cmlidXRlcyBmcm9tIHRoZSBleGlzdGluZyBpZHggZmlsZSAqLwoJb3B0cy0+dmVyc2lvbiA9IHAtPmluZGV4X3ZlcnNpb247CgoJaWYgKG9wdHMtPnZlcnNpb24gPT0gMikKCQlyZWFkX3YyX2Fub21hbG91c19vZmZzZXRzKHAsIG9wdHMpOwoKCS8qCgkgKiBHZXQgcmlkIG9mIHRoZSBpZHggZmlsZSBhcyB3ZSBkbyBub3QgbmVlZCBpdCBhbnltb3JlLgoJICogTkVFRFNXT1JLOiBleHRyYWN0IHRoaXMgYml0IGZyb20gZnJlZV9wYWNrX2J5X25hbWUoKSBpbgoJICogb2JqZWN0LWZpbGUuYywgcGVyaGFwcz8gIEl0IHNob3VsZG4ndCBtYXR0ZXIgdmVyeSBtdWNoIGFzIHdlCgkgKiBrbm93IHdlIGhhdmVuJ3QgaW5zdGFsbGVkIHRoaXMgcGFjayAoaGVuY2Ugd2UgbmV2ZXIgaGF2ZQoJICogcmVhZCBhbnl0aGluZyBmcm9tIGl0KS4KCSAqLwoJY2xvc2VfcGFja19pbmRleChwKTsKCWZyZWUocCk7Cn0KCnN0YXRpYyB2b2lkIHNob3dfcGFja19pbmZvKGludCBzdGF0X29ubHkpCnsKCWludCBpLCBiYXNlb2JqZWN0cyA9IG5yX29iamVjdHMgLSBucl9yZWZfZGVsdGFzIC0gbnJfb2ZzX2RlbHRhczsKCXVuc2lnbmVkIGxvbmcgKmNoYWluX2hpc3RvZ3JhbSA9IE5VTEw7CgoJaWYgKGRlZXBlc3RfZGVsdGEpCgkJQ0FMTE9DX0FSUkFZKGNoYWluX2hpc3RvZ3JhbSwgZGVlcGVzdF9kZWx0YSk7CgoJZm9yIChpID0gMDsgaSA8IG5yX29iamVjdHM7IGkrKykgewoJCXN0cnVjdCBvYmplY3RfZW50cnkgKm9iaiA9ICZvYmplY3RzW2ldOwoKCQlpZiAoaXNfZGVsdGFfdHlwZShvYmotPnR5cGUpKQoJCQljaGFpbl9oaXN0b2dyYW1bb2JqX3N0YXRbaV0uZGVsdGFfZGVwdGggLSAxXSsrOwoJCWlmIChzdGF0X29ubHkpCgkJCWNvbnRpbnVlOwoJCXByaW50ZigiJXMgJS02cyAlIlBSSXVNQVgiICUiUFJJdU1BWCIgJSJQUkl1TUFYLAoJCSAgICAgICBvaWRfdG9faGV4KCZvYmotPmlkeC5vaWQpLAoJCSAgICAgICB0eXBlX25hbWUob2JqLT5yZWFsX3R5cGUpLCAodWludG1heF90KW9iai0+c2l6ZSwKCQkgICAgICAgKHVpbnRtYXhfdCkob2JqWzFdLmlkeC5vZmZzZXQgLSBvYmotPmlkeC5vZmZzZXQpLAoJCSAgICAgICAodWludG1heF90KW9iai0+aWR4Lm9mZnNldCk7CgkJaWYgKGlzX2RlbHRhX3R5cGUob2JqLT50eXBlKSkgewoJCQlzdHJ1Y3Qgb2JqZWN0X2VudHJ5ICpib2JqID0gJm9iamVjdHNbb2JqX3N0YXRbaV0uYmFzZV9vYmplY3Rfbm9dOwoJCQlwcmludGYoIiAldSAlcyIsIG9ial9zdGF0W2ldLmRlbHRhX2RlcHRoLAoJCQkgICAgICAgb2lkX3RvX2hleCgmYm9iai0+aWR4Lm9pZCkpOwoJCX0KCQlwdXRjaGFyKCdcbicpOwoJfQoKCWlmIChiYXNlb2JqZWN0cykKCQlwcmludGZfbG4oUV8oIm5vbiBkZWx0YTogJWQgb2JqZWN0IiwKCQkJICAgICAibm9uIGRlbHRhOiAlZCBvYmplY3RzIiwKCQkJICAgICBiYXNlb2JqZWN0cyksCgkJCSAgYmFzZW9iamVjdHMpOwoJZm9yIChpID0gMDsgaSA8IGRlZXBlc3RfZGVsdGE7IGkrKykgewoJCWlmICghY2hhaW5faGlzdG9ncmFtW2ldKQoJCQljb250aW51ZTsKCQlwcmludGZfbG4oUV8oImNoYWluIGxlbmd0aCA9ICVkOiAlbHUgb2JqZWN0IiwKCQkJICAgICAiY2hhaW4gbGVuZ3RoID0gJWQ6ICVsdSBvYmplY3RzIiwKCQkJICAgICBjaGFpbl9oaXN0b2dyYW1baV0pLAoJCQkgIGkgKyAxLAoJCQkgIGNoYWluX2hpc3RvZ3JhbVtpXSk7Cgl9CglmcmVlKGNoYWluX2hpc3RvZ3JhbSk7Cn0KCmludCBjbWRfaW5kZXhfcGFjayhpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsIGNvbnN0IGNoYXIgKnByZWZpeCkKewoJaW50IGksIGZpeF90aGluX3BhY2sgPSAwLCB2ZXJpZnkgPSAwLCBzdGF0X29ubHkgPSAwLCByZXZfaW5kZXg7Cgljb25zdCBjaGFyICpjdXJyX2luZGV4OwoJY29uc3QgY2hhciAqY3Vycl9yZXZfaW5kZXggPSBOVUxMOwoJY29uc3QgY2hhciAqaW5kZXhfbmFtZSA9IE5VTEwsICpwYWNrX25hbWUgPSBOVUxMLCAqcmV2X2luZGV4X25hbWUgPSBOVUxMOwoJY29uc3QgY2hhciAqa2VlcF9tc2cgPSBOVUxMOwoJY29uc3QgY2hhciAqcHJvbWlzb3JfbXNnID0gTlVMTDsKCXN0cnVjdCBzdHJidWYgaW5kZXhfbmFtZV9idWYgPSBTVFJCVUZfSU5JVDsKCXN0cnVjdCBzdHJidWYgcmV2X2luZGV4X25hbWVfYnVmID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3QgcGFja19pZHhfZW50cnkgKippZHhfb2JqZWN0czsKCXN0cnVjdCBwYWNrX2lkeF9vcHRpb24gb3B0czsKCXVuc2lnbmVkIGNoYXIgcGFja19oYXNoW0dJVF9NQVhfUkFXU1pdOwoJdW5zaWduZWQgZm9yZWlnbl9uciA9IDE7CS8qIHplcm8gaXMgYSAiZ29vZCIgdmFsdWUsIGFzc3VtZSBiYWQgKi8KCWludCByZXBvcnRfZW5kX29mX2lucHV0ID0gMDsKCWludCBoYXNoX2FsZ28gPSAwOwoKCS8qCgkgKiBpbmRleC1wYWNrIG5ldmVyIG5lZWRzIHRvIGZldGNoIG1pc3Npbmcgb2JqZWN0cyBleGNlcHQgd2hlbgoJICogUkVGX0RFTFRBIGJhc2VzIGFyZSBtaXNzaW5nICh3aGljaCBhcmUgZXhwbGljaXRseSBoYW5kbGVkKS4gSXQgb25seQoJICogYWNjZXNzZXMgdGhlIHJlcG8gdG8gZG8gaGFzaCBjb2xsaXNpb24gY2hlY2tzIGFuZCB0byBjaGVjayB3aGljaAoJICogUkVGX0RFTFRBIGJhc2VzIG5lZWQgdG8gYmUgZmV0Y2hlZC4KCSAqLwoJZmV0Y2hfaWZfbWlzc2luZyA9IDA7CgoJaWYgKGFyZ2MgPT0gMiAmJiAhc3RyY21wKGFyZ3ZbMV0sICItaCIpKQoJCXVzYWdlKGluZGV4X3BhY2tfdXNhZ2UpOwoKCXJlYWRfcmVwbGFjZV9yZWZzID0gMDsKCWZzY2tfb3B0aW9ucy53YWxrID0gbWFya19saW5rOwoKCXJlc2V0X3BhY2tfaWR4X29wdGlvbigmb3B0cyk7CglnaXRfY29uZmlnKGdpdF9pbmRleF9wYWNrX2NvbmZpZywgJm9wdHMpOwoJaWYgKHByZWZpeCAmJiBjaGRpcihwcmVmaXgpKQoJCWRpZShfKCJDYW5ub3QgY29tZSBiYWNrIHRvIGN3ZCIpKTsKCglpZiAoZ2l0X2Vudl9ib29sKEdJVF9URVNUX1dSSVRFX1JFVl9JTkRFWCwgMCkpCgkJcmV2X2luZGV4ID0gMTsKCWVsc2UKCQlyZXZfaW5kZXggPSAhIShvcHRzLmZsYWdzICYgKFdSSVRFX1JFVl9WRVJJRlkgfCBXUklURV9SRVYpKTsKCglmb3IgKGkgPSAxOyBpIDwgYXJnYzsgaSsrKSB7CgkJY29uc3QgY2hhciAqYXJnID0gYXJndltpXTsKCgkJaWYgKCphcmcgPT0gJy0nKSB7CgkJCWlmICghc3RyY21wKGFyZywgIi0tc3RkaW4iKSkgewoJCQkJZnJvbV9zdGRpbiA9IDE7CgkJCX0gZWxzZSBpZiAoIXN0cmNtcChhcmcsICItLWZpeC10aGluIikpIHsKCQkJCWZpeF90aGluX3BhY2sgPSAxOwoJCQl9IGVsc2UgaWYgKHNraXBfdG9fb3B0aW9uYWxfYXJnKGFyZywgIi0tc3RyaWN0IiwgJmFyZykpIHsKCQkJCXN0cmljdCA9IDE7CgkJCQlkb19mc2NrX29iamVjdCA9IDE7CgkJCQlmc2NrX3NldF9tc2dfdHlwZXMoJmZzY2tfb3B0aW9ucywgYXJnKTsKCQkJfSBlbHNlIGlmICghc3RyY21wKGFyZywgIi0tY2hlY2stc2VsZi1jb250YWluZWQtYW5kLWNvbm5lY3RlZCIpKSB7CgkJCQlzdHJpY3QgPSAxOwoJCQkJY2hlY2tfc2VsZl9jb250YWluZWRfYW5kX2Nvbm5lY3RlZCA9IDE7CgkJCX0gZWxzZSBpZiAoIXN0cmNtcChhcmcsICItLWZzY2stb2JqZWN0cyIpKSB7CgkJCQlkb19mc2NrX29iamVjdCA9IDE7CgkJCX0gZWxzZSBpZiAoIXN0cmNtcChhcmcsICItLXZlcmlmeSIpKSB7CgkJCQl2ZXJpZnkgPSAxOwoJCQl9IGVsc2UgaWYgKCFzdHJjbXAoYXJnLCAiLS12ZXJpZnktc3RhdCIpKSB7CgkJCQl2ZXJpZnkgPSAxOwoJCQkJc2hvd19zdGF0ID0gMTsKCQkJfSBlbHNlIGlmICghc3RyY21wKGFyZywgIi0tdmVyaWZ5LXN0YXQtb25seSIpKSB7CgkJCQl2ZXJpZnkgPSAxOwoJCQkJc2hvd19zdGF0ID0gMTsKCQkJCXN0YXRfb25seSA9IDE7CgkJCX0gZWxzZSBpZiAoc2tpcF90b19vcHRpb25hbF9hcmcoYXJnLCAiLS1rZWVwIiwgJmtlZXBfbXNnKSkgewoJCQkJOyAvKiBub3RoaW5nIHRvIGRvICovCgkJCX0gZWxzZSBpZiAoc2tpcF90b19vcHRpb25hbF9hcmcoYXJnLCAiLS1wcm9taXNvciIsICZwcm9taXNvcl9tc2cpKSB7CgkJCQk7IC8qIGFscmVhZHkgcGFyc2VkICovCgkJCX0gZWxzZSBpZiAoc3RhcnRzX3dpdGgoYXJnLCAiLS10aHJlYWRzPSIpKSB7CgkJCQljaGFyICplbmQ7CgkJCQlucl90aHJlYWRzID0gc3RydG91bChhcmcrMTAsICZlbmQsIDApOwoJCQkJaWYgKCFhcmdbMTBdIHx8ICplbmQgfHwgbnJfdGhyZWFkcyA8IDApCgkJCQkJdXNhZ2UoaW5kZXhfcGFja191c2FnZSk7CgkJCQlpZiAoIUhBVkVfVEhSRUFEUyAmJiBucl90aHJlYWRzICE9IDEpIHsKCQkJCQl3YXJuaW5nKF8oIm5vIHRocmVhZHMgc3VwcG9ydCwgaWdub3JpbmcgJXMiKSwgYXJnKTsKCQkJCQlucl90aHJlYWRzID0gMTsKCQkJCX0KCQkJfSBlbHNlIGlmIChzdGFydHNfd2l0aChhcmcsICItLXBhY2tfaGVhZGVyPSIpKSB7CgkJCQlzdHJ1Y3QgcGFja19oZWFkZXIgKmhkcjsKCQkJCWNoYXIgKmM7CgoJCQkJaGRyID0gKHN0cnVjdCBwYWNrX2hlYWRlciAqKWlucHV0X2J1ZmZlcjsKCQkJCWhkci0+aGRyX3NpZ25hdHVyZSA9IGh0b25sKFBBQ0tfU0lHTkFUVVJFKTsKCQkJCWhkci0+aGRyX3ZlcnNpb24gPSBodG9ubChzdHJ0b3VsKGFyZyArIDE0LCAmYywgMTApKTsKCQkJCWlmICgqYyAhPSAnLCcpCgkJCQkJZGllKF8oImJhZCAlcyIpLCBhcmcpOwoJCQkJaGRyLT5oZHJfZW50cmllcyA9IGh0b25sKHN0cnRvdWwoYyArIDEsICZjLCAxMCkpOwoJCQkJaWYgKCpjKQoJCQkJCWRpZShfKCJiYWQgJXMiKSwgYXJnKTsKCQkJCWlucHV0X2xlbiA9IHNpemVvZigqaGRyKTsKCQkJfSBlbHNlIGlmICghc3RyY21wKGFyZywgIi12IikpIHsKCQkJCXZlcmJvc2UgPSAxOwoJCQl9IGVsc2UgaWYgKCFzdHJjbXAoYXJnLCAiLS1wcm9ncmVzcy10aXRsZSIpKSB7CgkJCQlpZiAocHJvZ3Jlc3NfdGl0bGUgfHwgKGkrMSkgPj0gYXJnYykKCQkJCQl1c2FnZShpbmRleF9wYWNrX3VzYWdlKTsKCQkJCXByb2dyZXNzX3RpdGxlID0gYXJndlsrK2ldOwoJCQl9IGVsc2UgaWYgKCFzdHJjbXAoYXJnLCAiLS1zaG93LXJlc29sdmluZy1wcm9ncmVzcyIpKSB7CgkJCQlzaG93X3Jlc29sdmluZ19wcm9ncmVzcyA9IDE7CgkJCX0gZWxzZSBpZiAoIXN0cmNtcChhcmcsICItLXJlcG9ydC1lbmQtb2YtaW5wdXQiKSkgewoJCQkJcmVwb3J0X2VuZF9vZl9pbnB1dCA9IDE7CgkJCX0gZWxzZSBpZiAoIXN0cmNtcChhcmcsICItbyIpKSB7CgkJCQlpZiAoaW5kZXhfbmFtZSB8fCAoaSsxKSA+PSBhcmdjKQoJCQkJCXVzYWdlKGluZGV4X3BhY2tfdXNhZ2UpOwoJCQkJaW5kZXhfbmFtZSA9IGFyZ3ZbKytpXTsKCQkJfSBlbHNlIGlmIChzdGFydHNfd2l0aChhcmcsICItLWluZGV4LXZlcnNpb249IikpIHsKCQkJCWNoYXIgKmM7CgkJCQlvcHRzLnZlcnNpb24gPSBzdHJ0b3VsKGFyZyArIDE2LCAmYywgMTApOwoJCQkJaWYgKG9wdHMudmVyc2lvbiA+IDIpCgkJCQkJZGllKF8oImJhZCAlcyIpLCBhcmcpOwoJCQkJaWYgKCpjID09ICcsJykKCQkJCQlvcHRzLm9mZjMyX2xpbWl0ID0gc3RydG91bChjKzEsICZjLCAwKTsKCQkJCWlmICgqYyB8fCBvcHRzLm9mZjMyX2xpbWl0ICYgMHg4MDAwMDAwMCkKCQkJCQlkaWUoXygiYmFkICVzIiksIGFyZyk7CgkJCX0gZWxzZSBpZiAoc2tpcF9wcmVmaXgoYXJnLCAiLS1tYXgtaW5wdXQtc2l6ZT0iLCAmYXJnKSkgewoJCQkJbWF4X2lucHV0X3NpemUgPSBzdHJ0b3VtYXgoYXJnLCBOVUxMLCAxMCk7CgkJCX0gZWxzZSBpZiAoc2tpcF9wcmVmaXgoYXJnLCAiLS1vYmplY3QtZm9ybWF0PSIsICZhcmcpKSB7CgkJCQloYXNoX2FsZ28gPSBoYXNoX2FsZ29fYnlfbmFtZShhcmcpOwoJCQkJaWYgKGhhc2hfYWxnbyA9PSBHSVRfSEFTSF9VTktOT1dOKQoJCQkJCWRpZShfKCJ1bmtub3duIGhhc2ggYWxnb3JpdGhtICclcyciKSwgYXJnKTsKCQkJCXJlcG9fc2V0X2hhc2hfYWxnbyh0aGVfcmVwb3NpdG9yeSwgaGFzaF9hbGdvKTsKCQkJfSBlbHNlIGlmICghc3RyY21wKGFyZywgIi0tcmV2LWluZGV4IikpIHsKCQkJCXJldl9pbmRleCA9IDE7CgkJCX0gZWxzZSBpZiAoIXN0cmNtcChhcmcsICItLW5vLXJldi1pbmRleCIpKSB7CgkJCQlyZXZfaW5kZXggPSAwOwoJCQl9IGVsc2UKCQkJCXVzYWdlKGluZGV4X3BhY2tfdXNhZ2UpOwoJCQljb250aW51ZTsKCQl9CgoJCWlmIChwYWNrX25hbWUpCgkJCXVzYWdlKGluZGV4X3BhY2tfdXNhZ2UpOwoJCXBhY2tfbmFtZSA9IGFyZzsKCX0KCglpZiAoIXBhY2tfbmFtZSAmJiAhZnJvbV9zdGRpbikKCQl1c2FnZShpbmRleF9wYWNrX3VzYWdlKTsKCWlmIChmaXhfdGhpbl9wYWNrICYmICFmcm9tX3N0ZGluKQoJCWRpZShfKCJ0aGUgb3B0aW9uICclcycgcmVxdWlyZXMgJyVzJyIpLCAiLS1maXgtdGhpbiIsICItLXN0ZGluIik7CglpZiAoZnJvbV9zdGRpbiAmJiAhc3RhcnR1cF9pbmZvLT5oYXZlX3JlcG9zaXRvcnkpCgkJZGllKF8oIi0tc3RkaW4gcmVxdWlyZXMgYSBnaXQgcmVwb3NpdG9yeSIpKTsKCWlmIChmcm9tX3N0ZGluICYmIGhhc2hfYWxnbykKCQlkaWUoXygib3B0aW9ucyAnJXMnIGFuZCAnJXMnIGNhbm5vdCBiZSB1c2VkIHRvZ2V0aGVyIiksICItLW9iamVjdC1mb3JtYXQiLCAiLS1zdGRpbiIpOwoJaWYgKCFpbmRleF9uYW1lICYmIHBhY2tfbmFtZSkKCQlpbmRleF9uYW1lID0gZGVyaXZlX2ZpbGVuYW1lKHBhY2tfbmFtZSwgInBhY2siLCAiaWR4IiwgJmluZGV4X25hbWVfYnVmKTsKCglvcHRzLmZsYWdzICY9IH4oV1JJVEVfUkVWIHwgV1JJVEVfUkVWX1ZFUklGWSk7CglpZiAocmV2X2luZGV4KSB7CgkJb3B0cy5mbGFncyB8PSB2ZXJpZnkgPyBXUklURV9SRVZfVkVSSUZZIDogV1JJVEVfUkVWOwoJCWlmIChpbmRleF9uYW1lKQoJCQlyZXZfaW5kZXhfbmFtZSA9IGRlcml2ZV9maWxlbmFtZShpbmRleF9uYW1lLAoJCQkJCQkJICJpZHgiLCAicmV2IiwKCQkJCQkJCSAmcmV2X2luZGV4X25hbWVfYnVmKTsKCX0KCglpZiAodmVyaWZ5KSB7CgkJaWYgKCFpbmRleF9uYW1lKQoJCQlkaWUoXygiLS12ZXJpZnkgd2l0aCBubyBwYWNrZmlsZSBuYW1lIGdpdmVuIikpOwoJCXJlYWRfaWR4X29wdGlvbigmb3B0cywgaW5kZXhfbmFtZSk7CgkJb3B0cy5mbGFncyB8PSBXUklURV9JRFhfVkVSSUZZIHwgV1JJVEVfSURYX1NUUklDVDsKCX0KCWlmIChzdHJpY3QpCgkJb3B0cy5mbGFncyB8PSBXUklURV9JRFhfU1RSSUNUOwoKCWlmIChIQVZFX1RIUkVBRFMgJiYgIW5yX3RocmVhZHMpIHsKCQlucl90aHJlYWRzID0gb25saW5lX2NwdXMoKTsKCQkvKgoJCSAqIEV4cGVyaW1lbnRzIHNob3cgdGhhdCBnb2luZyBhYm92ZSAyMCB0aHJlYWRzIGRvZXNuJ3QgaGVscCwKCQkgKiBubyBtYXR0ZXIgaG93IG1hbnkgY29yZXMgeW91IGhhdmUuIEJlbG93IHRoYXQsIHdlIHRlbmQgdG8KCQkgKiBtYXggYXQgaGFsZiB0aGUgbnVtYmVyIG9mIG9ubGluZV9jcHVzKCksIHByZXN1bWFibHkgYmVjYXVzZQoJCSAqIGhhbGYgb2YgdGhvc2UgYXJlIGh5cGVydGhyZWFkcyByYXRoZXIgdGhhbiBmdWxsIGNvcmVzLiBXZSdsbAoJCSAqIG5ldmVyIHJlZHVjZSB0aGUgbGV2ZWwgYmVsb3cgIjMiLCB0aG91Z2gsIHRvIG1hdGNoIGEKCQkgKiBoaXN0b3JpY2FsIHZhbHVlIHRoYXQgbm9ib2R5IGNvbXBsYWluZWQgYWJvdXQuCgkJICovCgkJaWYgKG5yX3RocmVhZHMgPCA0KQoJCQk7IC8qIHRvbyBmZXcgY29yZXMgdG8gY29uc2lkZXIgY2FwcGluZyAqLwoJCWVsc2UgaWYgKG5yX3RocmVhZHMgPCA2KQoJCQlucl90aHJlYWRzID0gMzsgLyogaGlzdG9yaWMgY2FwICovCgkJZWxzZSBpZiAobnJfdGhyZWFkcyA8IDQwKQoJCQlucl90aHJlYWRzIC89IDI7CgkJZWxzZQoJCQlucl90aHJlYWRzID0gMjA7IC8qIGhhcmQgY2FwICovCgl9CgoJY3Vycl9wYWNrID0gb3Blbl9wYWNrX2ZpbGUocGFja19uYW1lKTsKCXBhcnNlX3BhY2tfaGVhZGVyKCk7CglDQUxMT0NfQVJSQVkob2JqZWN0cywgc3RfYWRkKG5yX29iamVjdHMsIDEpKTsKCWlmIChzaG93X3N0YXQpCgkJQ0FMTE9DX0FSUkFZKG9ial9zdGF0LCBzdF9hZGQobnJfb2JqZWN0cywgMSkpOwoJQ0FMTE9DX0FSUkFZKG9mc19kZWx0YXMsIG5yX29iamVjdHMpOwoJcGFyc2VfcGFja19vYmplY3RzKHBhY2tfaGFzaCk7CglpZiAocmVwb3J0X2VuZF9vZl9pbnB1dCkKCQl3cml0ZV9pbl9mdWxsKDIsICJcMCIsIDEpOwoJcmVzb2x2ZV9kZWx0YXMoKTsKCWNvbmNsdWRlX3BhY2soZml4X3RoaW5fcGFjaywgY3Vycl9wYWNrLCBwYWNrX2hhc2gpOwoJZnJlZShvZnNfZGVsdGFzKTsKCWZyZWUocmVmX2RlbHRhcyk7CglpZiAoc3RyaWN0KQoJCWZvcmVpZ25fbnIgPSBjaGVja19vYmplY3RzKCk7CgoJaWYgKHNob3dfc3RhdCkKCQlzaG93X3BhY2tfaW5mbyhzdGF0X29ubHkpOwoKCUFMTE9DX0FSUkFZKGlkeF9vYmplY3RzLCBucl9vYmplY3RzKTsKCWZvciAoaSA9IDA7IGkgPCBucl9vYmplY3RzOyBpKyspCgkJaWR4X29iamVjdHNbaV0gPSAmb2JqZWN0c1tpXS5pZHg7CgljdXJyX2luZGV4ID0gd3JpdGVfaWR4X2ZpbGUoaW5kZXhfbmFtZSwgaWR4X29iamVjdHMsIG5yX29iamVjdHMsICZvcHRzLCBwYWNrX2hhc2gpOwoJaWYgKHJldl9pbmRleCkKCQljdXJyX3Jldl9pbmRleCA9IHdyaXRlX3Jldl9maWxlKHJldl9pbmRleF9uYW1lLCBpZHhfb2JqZWN0cywKCQkJCQkJbnJfb2JqZWN0cywgcGFja19oYXNoLAoJCQkJCQlvcHRzLmZsYWdzKTsKCWZyZWUoaWR4X29iamVjdHMpOwoKCWlmICghdmVyaWZ5KQoJCWZpbmFsKHBhY2tfbmFtZSwgY3Vycl9wYWNrLAoJCSAgICAgIGluZGV4X25hbWUsIGN1cnJfaW5kZXgsCgkJICAgICAgcmV2X2luZGV4X25hbWUsIGN1cnJfcmV2X2luZGV4LAoJCSAgICAgIGtlZXBfbXNnLCBwcm9taXNvcl9tc2csCgkJICAgICAgcGFja19oYXNoKTsKCWVsc2UKCQljbG9zZShpbnB1dF9mZCk7CgoJaWYgKGRvX2ZzY2tfb2JqZWN0ICYmIGZzY2tfZmluaXNoKCZmc2NrX29wdGlvbnMpKQoJCWRpZShfKCJmc2NrIGVycm9yIGluIHBhY2sgb2JqZWN0cyIpKTsKCglmcmVlKG9wdHMuYW5vbWFseSk7CglmcmVlKG9iamVjdHMpOwoJc3RyYnVmX3JlbGVhc2UoJmluZGV4X25hbWVfYnVmKTsKCXN0cmJ1Zl9yZWxlYXNlKCZyZXZfaW5kZXhfbmFtZV9idWYpOwoJaWYgKCFwYWNrX25hbWUpCgkJZnJlZSgodm9pZCAqKSBjdXJyX3BhY2spOwoJaWYgKCFpbmRleF9uYW1lKQoJCWZyZWUoKHZvaWQgKikgY3Vycl9pbmRleCk7CglpZiAoIXJldl9pbmRleF9uYW1lKQoJCWZyZWUoKHZvaWQgKikgY3Vycl9yZXZfaW5kZXgpOwoKCS8qCgkgKiBMZXQgdGhlIGNhbGxlciBrbm93IHRoaXMgcGFjayBpcyBub3Qgc2VsZiBjb250YWluZWQKCSAqLwoJaWYgKGNoZWNrX3NlbGZfY29udGFpbmVkX2FuZF9jb25uZWN0ZWQgJiYgZm9yZWlnbl9ucikKCQlyZXR1cm4gMTsKCglyZXR1cm4gMDsKfQo=",
    "text": "#include \"builtin.h\"\n#include \"config.h\"\n#include \"delta.h\"\n#include \"pack.h\"\n#include \"csum-file.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"tag.h\"\n#include \"tree.h\"\n#include \"progress.h\"\n#include \"fsck.h\"\n#include \"exec-cmd.h\"\n#include \"streaming.h\"\n#include \"thread-utils.h\"\n#include \"packfile.h\"\n#include \"object-store.h\"\n#include \"promisor-remote.h\"\n\nstatic const char index_pack_usage[] =\n\"git index-pack [-v] [-o <index-file>] [--keep | --keep=<msg>] [--[no-]rev-index] [--verify] [--strict] (<pack-file> | --stdin [--fix-thin] [<pack-file>])\";\n\nstruct object_entry {\n\tstruct pack_idx_entry idx;\n\tunsigned long size;\n\tunsigned char hdr_size;\n\tsigned char type;\n\tsigned char real_type;\n};\n\nstruct object_stat {\n\tunsigned delta_depth;\n\tint base_object_no;\n};\n\nstruct base_data {\n\t/* Initialized by make_base(). */\n\tstruct base_data *base;\n\tstruct object_entry *obj;\n\tint ref_first, ref_last;\n\tint ofs_first, ofs_last;\n\t/*\n\t * Threads should increment retain_data if they are about to call\n\t * patch_delta() using this struct's data as a base, and decrement this\n\t * when they are done. While retain_data is nonzero, this struct's data\n\t * will not be freed even if the delta base cache limit is exceeded.\n\t */\n\tint retain_data;\n\t/*\n\t * The number of direct children that have not been fully processed\n\t * (entered work_head, entered done_head, left done_head). When this\n\t * number reaches zero, this struct base_data can be freed.\n\t */\n\tint children_remaining;\n\n\t/* Not initialized by make_base(). */\n\tstruct list_head list;\n\tvoid *data;\n\tunsigned long size;\n};\n\n/*\n * Stack of struct base_data that have unprocessed children.\n * threaded_second_pass() uses this as a source of work (the other being the\n * objects array).\n *\n * Guarded by work_mutex.\n */\nstatic LIST_HEAD(work_head);\n\n/*\n * Stack of struct base_data that have children, all of whom have been\n * processed or are being processed, and at least one child is being processed.\n * These struct base_data must be kept around until the last child is\n * processed.\n *\n * Guarded by work_mutex.\n */\nstatic LIST_HEAD(done_head);\n\n/*\n * All threads share one delta base cache.\n *\n * base_cache_used is guarded by work_mutex, and base_cache_limit is read-only\n * in a thread.\n */\nstatic size_t base_cache_used;\nstatic size_t base_cache_limit;\n\nstruct thread_local {\n\tpthread_t thread;\n\tint pack_fd;\n};\n\n/* Remember to update object flag allocation in object.h */\n#define FLAG_LINK (1u<<20)\n#define FLAG_CHECKED (1u<<21)\n\nstruct ofs_delta_entry {\n\toff_t offset;\n\tint obj_no;\n};\n\nstruct ref_delta_entry {\n\tstruct object_id oid;\n\tint obj_no;\n};\n\nstatic struct object_entry *objects;\nstatic struct object_stat *obj_stat;\nstatic struct ofs_delta_entry *ofs_deltas;\nstatic struct ref_delta_entry *ref_deltas;\nstatic struct thread_local nothread_data;\nstatic int nr_objects;\nstatic int nr_ofs_deltas;\nstatic int nr_ref_deltas;\nstatic int ref_deltas_alloc;\nstatic int nr_resolved_deltas;\nstatic int nr_threads;\n\nstatic int from_stdin;\nstatic int strict;\nstatic int do_fsck_object;\nstatic struct fsck_options fsck_options = FSCK_OPTIONS_MISSING_GITMODULES;\nstatic int verbose;\nstatic const char *progress_title;\nstatic int show_resolving_progress;\nstatic int show_stat;\nstatic int check_self_contained_and_connected;\n\nstatic struct progress *progress;\n\n/* We always read in 4kB chunks. */\nstatic unsigned char input_buffer[4096];\nstatic unsigned int input_offset, input_len;\nstatic off_t consumed_bytes;\nstatic off_t max_input_size;\nstatic unsigned deepest_delta;\nstatic git_hash_ctx input_ctx;\nstatic uint32_t input_crc32;\nstatic int input_fd, output_fd;\nstatic const char *curr_pack;\n\nstatic struct thread_local *thread_data;\nstatic int nr_dispatched;\nstatic int threads_active;\n\nstatic pthread_mutex_t read_mutex;\n#define read_lock()\t\tlock_mutex(&read_mutex)\n#define read_unlock()\t\tunlock_mutex(&read_mutex)\n\nstatic pthread_mutex_t counter_mutex;\n#define counter_lock()\t\tlock_mutex(&counter_mutex)\n#define counter_unlock()\tunlock_mutex(&counter_mutex)\n\nstatic pthread_mutex_t work_mutex;\n#define work_lock()\t\tlock_mutex(&work_mutex)\n#define work_unlock()\t\tunlock_mutex(&work_mutex)\n\nstatic pthread_mutex_t deepest_delta_mutex;\n#define deepest_delta_lock()\tlock_mutex(&deepest_delta_mutex)\n#define deepest_delta_unlock()\tunlock_mutex(&deepest_delta_mutex)\n\nstatic pthread_key_t key;\n\nstatic inline void lock_mutex(pthread_mutex_t *mutex)\n{\n\tif (threads_active)\n\t\tpthread_mutex_lock(mutex);\n}\n\nstatic inline void unlock_mutex(pthread_mutex_t *mutex)\n{\n\tif (threads_active)\n\t\tpthread_mutex_unlock(mutex);\n}\n\n/*\n * Mutex and conditional variable can't be statically-initialized on Windows.\n */\nstatic void init_thread(void)\n{\n\tint i;\n\tinit_recursive_mutex(&read_mutex);\n\tpthread_mutex_init(&counter_mutex, NULL);\n\tpthread_mutex_init(&work_mutex, NULL);\n\tif (show_stat)\n\t\tpthread_mutex_init(&deepest_delta_mutex, NULL);\n\tpthread_key_create(&key, NULL);\n\tCALLOC_ARRAY(thread_data, nr_threads);\n\tfor (i = 0; i < nr_threads; i++) {\n\t\tthread_data[i].pack_fd = xopen(curr_pack, O_RDONLY);\n\t}\n\n\tthreads_active = 1;\n}\n\nstatic void cleanup_thread(void)\n{\n\tint i;\n\tif (!threads_active)\n\t\treturn;\n\tthreads_active = 0;\n\tpthread_mutex_destroy(&read_mutex);\n\tpthread_mutex_destroy(&counter_mutex);\n\tpthread_mutex_destroy(&work_mutex);\n\tif (show_stat)\n\t\tpthread_mutex_destroy(&deepest_delta_mutex);\n\tfor (i = 0; i < nr_threads; i++)\n\t\tclose(thread_data[i].pack_fd);\n\tpthread_key_delete(key);\n\tfree(thread_data);\n}\n\nstatic int mark_link(struct object *obj, enum object_type type,\n\t\t     void *data, struct fsck_options *options)\n{\n\tif (!obj)\n\t\treturn -1;\n\n\tif (type != OBJ_ANY && obj->type != type)\n\t\tdie(_(\"object type mismatch at %s\"), oid_to_hex(&obj->oid));\n\n\tobj->flags |= FLAG_LINK;\n\treturn 0;\n}\n\n/* The content of each linked object must have been checked\n   or it must be already present in the object database */\nstatic unsigned check_object(struct object *obj)\n{\n\tif (!obj)\n\t\treturn 0;\n\n\tif (!(obj->flags & FLAG_LINK))\n\t\treturn 0;\n\n\tif (!(obj->flags & FLAG_CHECKED)) {\n\t\tunsigned long size;\n\t\tint type = oid_object_info(the_repository, &obj->oid, &size);\n\t\tif (type <= 0)\n\t\t\tdie(_(\"did not receive expected object %s\"),\n\t\t\t      oid_to_hex(&obj->oid));\n\t\tif (type != obj->type)\n\t\t\tdie(_(\"object %s: expected type %s, found %s\"),\n\t\t\t    oid_to_hex(&obj->oid),\n\t\t\t    type_name(obj->type), type_name(type));\n\t\tobj->flags |= FLAG_CHECKED;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned check_objects(void)\n{\n\tunsigned i, max, foreign_nr = 0;\n\n\tmax = get_max_object_index();\n\n\tif (verbose)\n\t\tprogress = start_delayed_progress(_(\"Checking objects\"), max);\n\n\tfor (i = 0; i < max; i++) {\n\t\tforeign_nr += check_object(get_indexed_object(i));\n\t\tdisplay_progress(progress, i + 1);\n\t}\n\n\tstop_progress(&progress);\n\treturn foreign_nr;\n}\n\n\n/* Discard current buffer used content. */\nstatic void flush(void)\n{\n\tif (input_offset) {\n\t\tif (output_fd >= 0)\n\t\t\twrite_or_die(output_fd, input_buffer, input_offset);\n\t\tthe_hash_algo->update_fn(&input_ctx, input_buffer, input_offset);\n\t\tmemmove(input_buffer, input_buffer + input_offset, input_len);\n\t\tinput_offset = 0;\n\t}\n}\n\n/*\n * Make sure at least \"min\" bytes are available in the buffer, and\n * return the pointer to the buffer.\n */\nstatic void *fill(int min)\n{\n\tif (min <= input_len)\n\t\treturn input_buffer + input_offset;\n\tif (min > sizeof(input_buffer))\n\t\tdie(Q_(\"cannot fill %d byte\",\n\t\t       \"cannot fill %d bytes\",\n\t\t       min),\n\t\t    min);\n\tflush();\n\tdo {\n\t\tssize_t ret = xread(input_fd, input_buffer + input_len,\n\t\t\t\tsizeof(input_buffer) - input_len);\n\t\tif (ret <= 0) {\n\t\t\tif (!ret)\n\t\t\t\tdie(_(\"early EOF\"));\n\t\t\tdie_errno(_(\"read error on input\"));\n\t\t}\n\t\tinput_len += ret;\n\t\tif (from_stdin)\n\t\t\tdisplay_throughput(progress, consumed_bytes + input_len);\n\t} while (input_len < min);\n\treturn input_buffer;\n}\n\nstatic void use(int bytes)\n{\n\tif (bytes > input_len)\n\t\tdie(_(\"used more bytes than were available\"));\n\tinput_crc32 = crc32(input_crc32, input_buffer + input_offset, bytes);\n\tinput_len -= bytes;\n\tinput_offset += bytes;\n\n\t/* make sure off_t is sufficiently large not to wrap */\n\tif (signed_add_overflows(consumed_bytes, bytes))\n\t\tdie(_(\"pack too large for current definition of off_t\"));\n\tconsumed_bytes += bytes;\n\tif (max_input_size && consumed_bytes > max_input_size) {\n\t\tstruct strbuf size_limit = STRBUF_INIT;\n\t\tstrbuf_humanise_bytes(&size_limit, max_input_size);\n\t\tdie(_(\"pack exceeds maximum allowed size (%s)\"),\n\t\t    size_limit.buf);\n\t}\n}\n\nstatic const char *open_pack_file(const char *pack_name)\n{\n\tif (from_stdin) {\n\t\tinput_fd = 0;\n\t\tif (!pack_name) {\n\t\t\tstruct strbuf tmp_file = STRBUF_INIT;\n\t\t\toutput_fd = odb_mkstemp(&tmp_file,\n\t\t\t\t\t\t\"pack/tmp_pack_XXXXXX\");\n\t\t\tpack_name = strbuf_detach(&tmp_file, NULL);\n\t\t} else {\n\t\t\toutput_fd = xopen(pack_name, O_CREAT|O_EXCL|O_RDWR, 0600);\n\t\t}\n\t\tnothread_data.pack_fd = output_fd;\n\t} else {\n\t\tinput_fd = xopen(pack_name, O_RDONLY);\n\t\toutput_fd = -1;\n\t\tnothread_data.pack_fd = input_fd;\n\t}\n\tthe_hash_algo->init_fn(&input_ctx);\n\treturn pack_name;\n}\n\nstatic void parse_pack_header(void)\n{\n\tstruct pack_header *hdr = fill(sizeof(struct pack_header));\n\n\t/* Header consistency check */\n\tif (hdr->hdr_signature != htonl(PACK_SIGNATURE))\n\t\tdie(_(\"pack signature mismatch\"));\n\tif (!pack_version_ok(hdr->hdr_version))\n\t\tdie(_(\"pack version %\"PRIu32\" unsupported\"),\n\t\t\tntohl(hdr->hdr_version));\n\n\tnr_objects = ntohl(hdr->hdr_entries);\n\tuse(sizeof(struct pack_header));\n}\n\n__attribute__((format (printf, 2, 3)))\nstatic NORETURN void bad_object(off_t offset, const char *format, ...)\n{\n\tva_list params;\n\tchar buf[1024];\n\n\tva_start(params, format);\n\tvsnprintf(buf, sizeof(buf), format, params);\n\tva_end(params);\n\tdie(_(\"pack has bad object at offset %\"PRIuMAX\": %s\"),\n\t    (uintmax_t)offset, buf);\n}\n\nstatic inline struct thread_local *get_thread_data(void)\n{\n\tif (HAVE_THREADS) {\n\t\tif (threads_active)\n\t\t\treturn pthread_getspecific(key);\n\t\tassert(!threads_active &&\n\t\t       \"This should only be reached when all threads are gone\");\n\t}\n\treturn &nothread_data;\n}\n\nstatic void set_thread_data(struct thread_local *data)\n{\n\tif (threads_active)\n\t\tpthread_setspecific(key, data);\n}\n\nstatic void free_base_data(struct base_data *c)\n{\n\tif (c->data) {\n\t\tFREE_AND_NULL(c->data);\n\t\tbase_cache_used -= c->size;\n\t}\n}\n\nstatic void prune_base_data(struct base_data *retain)\n{\n\tstruct list_head *pos;\n\n\tif (base_cache_used <= base_cache_limit)\n\t\treturn;\n\n\tlist_for_each_prev(pos, &done_head) {\n\t\tstruct base_data *b = list_entry(pos, struct base_data, list);\n\t\tif (b->retain_data || b == retain)\n\t\t\tcontinue;\n\t\tif (b->data) {\n\t\t\tfree_base_data(b);\n\t\t\tif (base_cache_used <= base_cache_limit)\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\tlist_for_each_prev(pos, &work_head) {\n\t\tstruct base_data *b = list_entry(pos, struct base_data, list);\n\t\tif (b->retain_data || b == retain)\n\t\t\tcontinue;\n\t\tif (b->data) {\n\t\t\tfree_base_data(b);\n\t\t\tif (base_cache_used <= base_cache_limit)\n\t\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic int is_delta_type(enum object_type type)\n{\n\treturn (type == OBJ_REF_DELTA || type == OBJ_OFS_DELTA);\n}\n\nstatic void *unpack_entry_data(off_t offset, unsigned long size,\n\t\t\t       enum object_type type, struct object_id *oid)\n{\n\tstatic char fixed_buf[8192];\n\tint status;\n\tgit_zstream stream;\n\tvoid *buf;\n\tgit_hash_ctx c;\n\tchar hdr[32];\n\tint hdrlen;\n\n\tif (!is_delta_type(type)) {\n\t\thdrlen = format_object_header(hdr, sizeof(hdr), type, size);\n\t\tthe_hash_algo->init_fn(&c);\n\t\tthe_hash_algo->update_fn(&c, hdr, hdrlen);\n\t} else\n\t\toid = NULL;\n\tif (type == OBJ_BLOB && size > big_file_threshold)\n\t\tbuf = fixed_buf;\n\telse\n\t\tbuf = xmallocz(size);\n\n\tmemset(&stream, 0, sizeof(stream));\n\tgit_inflate_init(&stream);\n\tstream.next_out = buf;\n\tstream.avail_out = buf == fixed_buf ? sizeof(fixed_buf) : size;\n\n\tdo {\n\t\tunsigned char *last_out = stream.next_out;\n\t\tstream.next_in = fill(1);\n\t\tstream.avail_in = input_len;\n\t\tstatus = git_inflate(&stream, 0);\n\t\tuse(input_len - stream.avail_in);\n\t\tif (oid)\n\t\t\tthe_hash_algo->update_fn(&c, last_out, stream.next_out - last_out);\n\t\tif (buf == fixed_buf) {\n\t\t\tstream.next_out = buf;\n\t\t\tstream.avail_out = sizeof(fixed_buf);\n\t\t}\n\t} while (status == Z_OK);\n\tif (stream.total_out != size || status != Z_STREAM_END)\n\t\tbad_object(offset, _(\"inflate returned %d\"), status);\n\tgit_inflate_end(&stream);\n\tif (oid)\n\t\tthe_hash_algo->final_oid_fn(oid, &c);\n\treturn buf == fixed_buf ? NULL : buf;\n}\n\nstatic void *unpack_raw_entry(struct object_entry *obj,\n\t\t\t      off_t *ofs_offset,\n\t\t\t      struct object_id *ref_oid,\n\t\t\t      struct object_id *oid)\n{\n\tunsigned char *p;\n\tunsigned long size, c;\n\toff_t base_offset;\n\tunsigned shift;\n\tvoid *data;\n\n\tobj->idx.offset = consumed_bytes;\n\tinput_crc32 = crc32(0, NULL, 0);\n\n\tp = fill(1);\n\tc = *p;\n\tuse(1);\n\tobj->type = (c >> 4) & 7;\n\tsize = (c & 15);\n\tshift = 4;\n\twhile (c & 0x80) {\n\t\tp = fill(1);\n\t\tc = *p;\n\t\tuse(1);\n\t\tsize += (c & 0x7f) << shift;\n\t\tshift += 7;\n\t}\n\tobj->size = size;\n\n\tswitch (obj->type) {\n\tcase OBJ_REF_DELTA:\n\t\toidread(ref_oid, fill(the_hash_algo->rawsz));\n\t\tuse(the_hash_algo->rawsz);\n\t\tbreak;\n\tcase OBJ_OFS_DELTA:\n\t\tp = fill(1);\n\t\tc = *p;\n\t\tuse(1);\n\t\tbase_offset = c & 127;\n\t\twhile (c & 128) {\n\t\t\tbase_offset += 1;\n\t\t\tif (!base_offset || MSB(base_offset, 7))\n\t\t\t\tbad_object(obj->idx.offset, _(\"offset value overflow for delta base object\"));\n\t\t\tp = fill(1);\n\t\t\tc = *p;\n\t\t\tuse(1);\n\t\t\tbase_offset = (base_offset << 7) + (c & 127);\n\t\t}\n\t\t*ofs_offset = obj->idx.offset - base_offset;\n\t\tif (*ofs_offset <= 0 || *ofs_offset >= obj->idx.offset)\n\t\t\tbad_object(obj->idx.offset, _(\"delta base offset is out of bound\"));\n\t\tbreak;\n\tcase OBJ_COMMIT:\n\tcase OBJ_TREE:\n\tcase OBJ_BLOB:\n\tcase OBJ_TAG:\n\t\tbreak;\n\tdefault:\n\t\tbad_object(obj->idx.offset, _(\"unknown object type %d\"), obj->type);\n\t}\n\tobj->hdr_size = consumed_bytes - obj->idx.offset;\n\n\tdata = unpack_entry_data(obj->idx.offset, obj->size, obj->type, oid);\n\tobj->idx.crc32 = input_crc32;\n\treturn data;\n}\n\nstatic void *unpack_data(struct object_entry *obj,\n\t\t\t int (*consume)(const unsigned char *, unsigned long, void *),\n\t\t\t void *cb_data)\n{\n\toff_t from = obj[0].idx.offset + obj[0].hdr_size;\n\toff_t len = obj[1].idx.offset - from;\n\tunsigned char *data, *inbuf;\n\tgit_zstream stream;\n\tint status;\n\n\tdata = xmallocz(consume ? 64*1024 : obj->size);\n\tinbuf = xmalloc((len < 64*1024) ? (int)len : 64*1024);\n\n\tmemset(&stream, 0, sizeof(stream));\n\tgit_inflate_init(&stream);\n\tstream.next_out = data;\n\tstream.avail_out = consume ? 64*1024 : obj->size;\n\n\tdo {\n\t\tssize_t n = (len < 64*1024) ? (ssize_t)len : 64*1024;\n\t\tn = xpread(get_thread_data()->pack_fd, inbuf, n, from);\n\t\tif (n < 0)\n\t\t\tdie_errno(_(\"cannot pread pack file\"));\n\t\tif (!n)\n\t\t\tdie(Q_(\"premature end of pack file, %\"PRIuMAX\" byte missing\",\n\t\t\t       \"premature end of pack file, %\"PRIuMAX\" bytes missing\",\n\t\t\t       len),\n\t\t\t    (uintmax_t)len);\n\t\tfrom += n;\n\t\tlen -= n;\n\t\tstream.next_in = inbuf;\n\t\tstream.avail_in = n;\n\t\tif (!consume)\n\t\t\tstatus = git_inflate(&stream, 0);\n\t\telse {\n\t\t\tdo {\n\t\t\t\tstatus = git_inflate(&stream, 0);\n\t\t\t\tif (consume(data, stream.next_out - data, cb_data)) {\n\t\t\t\t\tfree(inbuf);\n\t\t\t\t\tfree(data);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tstream.next_out = data;\n\t\t\t\tstream.avail_out = 64*1024;\n\t\t\t} while (status == Z_OK && stream.avail_in);\n\t\t}\n\t} while (len && status == Z_OK && !stream.avail_in);\n\n\t/* This has been inflated OK when first encountered, so... */\n\tif (status != Z_STREAM_END || stream.total_out != obj->size)\n\t\tdie(_(\"serious inflate inconsistency\"));\n\n\tgit_inflate_end(&stream);\n\tfree(inbuf);\n\tif (consume) {\n\t\tFREE_AND_NULL(data);\n\t}\n\treturn data;\n}\n\nstatic void *get_data_from_pack(struct object_entry *obj)\n{\n\treturn unpack_data(obj, NULL, NULL);\n}\n\nstatic int compare_ofs_delta_bases(off_t offset1, off_t offset2,\n\t\t\t\t   enum object_type type1,\n\t\t\t\t   enum object_type type2)\n{\n\tint cmp = type1 - type2;\n\tif (cmp)\n\t\treturn cmp;\n\treturn offset1 < offset2 ? -1 :\n\t       offset1 > offset2 ?  1 :\n\t       0;\n}\n\nstatic int find_ofs_delta(const off_t offset)\n{\n\tint first = 0, last = nr_ofs_deltas;\n\n\twhile (first < last) {\n\t\tint next = first + (last - first) / 2;\n\t\tstruct ofs_delta_entry *delta = &ofs_deltas[next];\n\t\tint cmp;\n\n\t\tcmp = compare_ofs_delta_bases(offset, delta->offset,\n\t\t\t\t\t      OBJ_OFS_DELTA,\n\t\t\t\t\t      objects[delta->obj_no].type);\n\t\tif (!cmp)\n\t\t\treturn next;\n\t\tif (cmp < 0) {\n\t\t\tlast = next;\n\t\t\tcontinue;\n\t\t}\n\t\tfirst = next+1;\n\t}\n\treturn -first-1;\n}\n\nstatic void find_ofs_delta_children(off_t offset,\n\t\t\t\t    int *first_index, int *last_index)\n{\n\tint first = find_ofs_delta(offset);\n\tint last = first;\n\tint end = nr_ofs_deltas - 1;\n\n\tif (first < 0) {\n\t\t*first_index = 0;\n\t\t*last_index = -1;\n\t\treturn;\n\t}\n\twhile (first > 0 && ofs_deltas[first - 1].offset == offset)\n\t\t--first;\n\twhile (last < end && ofs_deltas[last + 1].offset == offset)\n\t\t++last;\n\t*first_index = first;\n\t*last_index = last;\n}\n\nstatic int compare_ref_delta_bases(const struct object_id *oid1,\n\t\t\t\t   const struct object_id *oid2,\n\t\t\t\t   enum object_type type1,\n\t\t\t\t   enum object_type type2)\n{\n\tint cmp = type1 - type2;\n\tif (cmp)\n\t\treturn cmp;\n\treturn oidcmp(oid1, oid2);\n}\n\nstatic int find_ref_delta(const struct object_id *oid)\n{\n\tint first = 0, last = nr_ref_deltas;\n\n\twhile (first < last) {\n\t\tint next = first + (last - first) / 2;\n\t\tstruct ref_delta_entry *delta = &ref_deltas[next];\n\t\tint cmp;\n\n\t\tcmp = compare_ref_delta_bases(oid, &delta->oid,\n\t\t\t\t\t      OBJ_REF_DELTA,\n\t\t\t\t\t      objects[delta->obj_no].type);\n\t\tif (!cmp)\n\t\t\treturn next;\n\t\tif (cmp < 0) {\n\t\t\tlast = next;\n\t\t\tcontinue;\n\t\t}\n\t\tfirst = next+1;\n\t}\n\treturn -first-1;\n}\n\nstatic void find_ref_delta_children(const struct object_id *oid,\n\t\t\t\t    int *first_index, int *last_index)\n{\n\tint first = find_ref_delta(oid);\n\tint last = first;\n\tint end = nr_ref_deltas - 1;\n\n\tif (first < 0) {\n\t\t*first_index = 0;\n\t\t*last_index = -1;\n\t\treturn;\n\t}\n\twhile (first > 0 && oideq(&ref_deltas[first - 1].oid, oid))\n\t\t--first;\n\twhile (last < end && oideq(&ref_deltas[last + 1].oid, oid))\n\t\t++last;\n\t*first_index = first;\n\t*last_index = last;\n}\n\nstruct compare_data {\n\tstruct object_entry *entry;\n\tstruct git_istream *st;\n\tunsigned char *buf;\n\tunsigned long buf_size;\n};\n\nstatic int compare_objects(const unsigned char *buf, unsigned long size,\n\t\t\t   void *cb_data)\n{\n\tstruct compare_data *data = cb_data;\n\n\tif (data->buf_size < size) {\n\t\tfree(data->buf);\n\t\tdata->buf = xmalloc(size);\n\t\tdata->buf_size = size;\n\t}\n\n\twhile (size) {\n\t\tssize_t len = read_istream(data->st, data->buf, size);\n\t\tif (len == 0)\n\t\t\tdie(_(\"SHA1 COLLISION FOUND WITH %s !\"),\n\t\t\t    oid_to_hex(&data->entry->idx.oid));\n\t\tif (len < 0)\n\t\t\tdie(_(\"unable to read %s\"),\n\t\t\t    oid_to_hex(&data->entry->idx.oid));\n\t\tif (memcmp(buf, data->buf, len))\n\t\t\tdie(_(\"SHA1 COLLISION FOUND WITH %s !\"),\n\t\t\t    oid_to_hex(&data->entry->idx.oid));\n\t\tsize -= len;\n\t\tbuf += len;\n\t}\n\treturn 0;\n}\n\nstatic int check_collison(struct object_entry *entry)\n{\n\tstruct compare_data data;\n\tenum object_type type;\n\tunsigned long size;\n\n\tif (entry->size <= big_file_threshold || entry->type != OBJ_BLOB)\n\t\treturn -1;\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.entry = entry;\n\tdata.st = open_istream(the_repository, &entry->idx.oid, &type, &size,\n\t\t\t       NULL);\n\tif (!data.st)\n\t\treturn -1;\n\tif (size != entry->size || type != entry->type)\n\t\tdie(_(\"SHA1 COLLISION FOUND WITH %s !\"),\n\t\t    oid_to_hex(&entry->idx.oid));\n\tunpack_data(entry, compare_objects, &data);\n\tclose_istream(data.st);\n\tfree(data.buf);\n\treturn 0;\n}\n\nstatic void sha1_object(const void *data, struct object_entry *obj_entry,\n\t\t\tunsigned long size, enum object_type type,\n\t\t\tconst struct object_id *oid)\n{\n\tvoid *new_data = NULL;\n\tint collision_test_needed = 0;\n\n\tassert(data || obj_entry);\n\n\tif (startup_info->have_repository) {\n\t\tread_lock();\n\t\tcollision_test_needed =\n\t\t\thas_object_file_with_flags(oid, OBJECT_INFO_QUICK);\n\t\tread_unlock();\n\t}\n\n\tif (collision_test_needed && !data) {\n\t\tread_lock();\n\t\tif (!check_collison(obj_entry))\n\t\t\tcollision_test_needed = 0;\n\t\tread_unlock();\n\t}\n\tif (collision_test_needed) {\n\t\tvoid *has_data;\n\t\tenum object_type has_type;\n\t\tunsigned long has_size;\n\t\tread_lock();\n\t\thas_type = oid_object_info(the_repository, oid, &has_size);\n\t\tif (has_type < 0)\n\t\t\tdie(_(\"cannot read existing object info %s\"), oid_to_hex(oid));\n\t\tif (has_type != type || has_size != size)\n\t\t\tdie(_(\"SHA1 COLLISION FOUND WITH %s !\"), oid_to_hex(oid));\n\t\thas_data = read_object_file(oid, &has_type, &has_size);\n\t\tread_unlock();\n\t\tif (!data)\n\t\t\tdata = new_data = get_data_from_pack(obj_entry);\n\t\tif (!has_data)\n\t\t\tdie(_(\"cannot read existing object %s\"), oid_to_hex(oid));\n\t\tif (size != has_size || type != has_type ||\n\t\t    memcmp(data, has_data, size) != 0)\n\t\t\tdie(_(\"SHA1 COLLISION FOUND WITH %s !\"), oid_to_hex(oid));\n\t\tfree(has_data);\n\t}\n\n\tif (strict || do_fsck_object) {\n\t\tread_lock();\n\t\tif (type == OBJ_BLOB) {\n\t\t\tstruct blob *blob = lookup_blob(the_repository, oid);\n\t\t\tif (blob)\n\t\t\t\tblob->object.flags |= FLAG_CHECKED;\n\t\t\telse\n\t\t\t\tdie(_(\"invalid blob object %s\"), oid_to_hex(oid));\n\t\t\tif (do_fsck_object &&\n\t\t\t    fsck_object(&blob->object, (void *)data, size, &fsck_options))\n\t\t\t\tdie(_(\"fsck error in packed object\"));\n\t\t} else {\n\t\t\tstruct object *obj;\n\t\t\tint eaten;\n\t\t\tvoid *buf = (void *) data;\n\n\t\t\tassert(data && \"data can only be NULL for large _blobs_\");\n\n\t\t\t/*\n\t\t\t * we do not need to free the memory here, as the\n\t\t\t * buf is deleted by the caller.\n\t\t\t */\n\t\t\tobj = parse_object_buffer(the_repository, oid, type,\n\t\t\t\t\t\t  size, buf,\n\t\t\t\t\t\t  &eaten);\n\t\t\tif (!obj)\n\t\t\t\tdie(_(\"invalid %s\"), type_name(type));\n\t\t\tif (do_fsck_object &&\n\t\t\t    fsck_object(obj, buf, size, &fsck_options))\n\t\t\t\tdie(_(\"fsck error in packed object\"));\n\t\t\tif (strict && fsck_walk(obj, NULL, &fsck_options))\n\t\t\t\tdie(_(\"Not all child objects of %s are reachable\"), oid_to_hex(&obj->oid));\n\n\t\t\tif (obj->type == OBJ_TREE) {\n\t\t\t\tstruct tree *item = (struct tree *) obj;\n\t\t\t\titem->buffer = NULL;\n\t\t\t\tobj->parsed = 0;\n\t\t\t}\n\t\t\tif (obj->type == OBJ_COMMIT) {\n\t\t\t\tstruct commit *commit = (struct commit *) obj;\n\t\t\t\tif (detach_commit_buffer(commit, NULL) != data)\n\t\t\t\t\tBUG(\"parse_object_buffer transmogrified our buffer\");\n\t\t\t}\n\t\t\tobj->flags |= FLAG_CHECKED;\n\t\t}\n\t\tread_unlock();\n\t}\n\n\tfree(new_data);\n}\n\n/*\n * Ensure that this node has been reconstructed and return its contents.\n *\n * In the typical and best case, this node would already be reconstructed\n * (through the invocation to resolve_delta() in threaded_second_pass()) and it\n * would not be pruned. However, if pruning of this node was necessary due to\n * reaching delta_base_cache_limit, this function will find the closest\n * ancestor with reconstructed data that has not been pruned (or if there is\n * none, the ultimate base object), and reconstruct each node in the delta\n * chain in order to generate the reconstructed data for this node.\n */\nstatic void *get_base_data(struct base_data *c)\n{\n\tif (!c->data) {\n\t\tstruct object_entry *obj = c->obj;\n\t\tstruct base_data **delta = NULL;\n\t\tint delta_nr = 0, delta_alloc = 0;\n\n\t\twhile (is_delta_type(c->obj->type) && !c->data) {\n\t\t\tALLOC_GROW(delta, delta_nr + 1, delta_alloc);\n\t\t\tdelta[delta_nr++] = c;\n\t\t\tc = c->base;\n\t\t}\n\t\tif (!delta_nr) {\n\t\t\tc->data = get_data_from_pack(obj);\n\t\t\tc->size = obj->size;\n\t\t\tbase_cache_used += c->size;\n\t\t\tprune_base_data(c);\n\t\t}\n\t\tfor (; delta_nr > 0; delta_nr--) {\n\t\t\tvoid *base, *raw;\n\t\t\tc = delta[delta_nr - 1];\n\t\t\tobj = c->obj;\n\t\t\tbase = get_base_data(c->base);\n\t\t\traw = get_data_from_pack(obj);\n\t\t\tc->data = patch_delta(\n\t\t\t\tbase, c->base->size,\n\t\t\t\traw, obj->size,\n\t\t\t\t&c->size);\n\t\t\tfree(raw);\n\t\t\tif (!c->data)\n\t\t\t\tbad_object(obj->idx.offset, _(\"failed to apply delta\"));\n\t\t\tbase_cache_used += c->size;\n\t\t\tprune_base_data(c);\n\t\t}\n\t\tfree(delta);\n\t}\n\treturn c->data;\n}\n\nstatic struct base_data *make_base(struct object_entry *obj,\n\t\t\t\t   struct base_data *parent)\n{\n\tstruct base_data *base = xcalloc(1, sizeof(struct base_data));\n\tbase->base = parent;\n\tbase->obj = obj;\n\tfind_ref_delta_children(&obj->idx.oid,\n\t\t\t\t&base->ref_first, &base->ref_last);\n\tfind_ofs_delta_children(obj->idx.offset,\n\t\t\t\t&base->ofs_first, &base->ofs_last);\n\tbase->children_remaining = base->ref_last - base->ref_first +\n\t\tbase->ofs_last - base->ofs_first + 2;\n\treturn base;\n}\n\nstatic struct base_data *resolve_delta(struct object_entry *delta_obj,\n\t\t\t\t       struct base_data *base)\n{\n\tvoid *delta_data, *result_data;\n\tstruct base_data *result;\n\tunsigned long result_size;\n\n\tif (show_stat) {\n\t\tint i = delta_obj - objects;\n\t\tint j = base->obj - objects;\n\t\tobj_stat[i].delta_depth = obj_stat[j].delta_depth + 1;\n\t\tdeepest_delta_lock();\n\t\tif (deepest_delta < obj_stat[i].delta_depth)\n\t\t\tdeepest_delta = obj_stat[i].delta_depth;\n\t\tdeepest_delta_unlock();\n\t\tobj_stat[i].base_object_no = j;\n\t}\n\tdelta_data = get_data_from_pack(delta_obj);\n\tassert(base->data);\n\tresult_data = patch_delta(base->data, base->size,\n\t\t\t\t  delta_data, delta_obj->size, &result_size);\n\tfree(delta_data);\n\tif (!result_data)\n\t\tbad_object(delta_obj->idx.offset, _(\"failed to apply delta\"));\n\thash_object_file(the_hash_algo, result_data, result_size,\n\t\t\t delta_obj->real_type, &delta_obj->idx.oid);\n\tsha1_object(result_data, NULL, result_size, delta_obj->real_type,\n\t\t    &delta_obj->idx.oid);\n\n\tresult = make_base(delta_obj, base);\n\tresult->data = result_data;\n\tresult->size = result_size;\n\n\tcounter_lock();\n\tnr_resolved_deltas++;\n\tcounter_unlock();\n\n\treturn result;\n}\n\nstatic int compare_ofs_delta_entry(const void *a, const void *b)\n{\n\tconst struct ofs_delta_entry *delta_a = a;\n\tconst struct ofs_delta_entry *delta_b = b;\n\n\treturn delta_a->offset < delta_b->offset ? -1 :\n\t       delta_a->offset > delta_b->offset ?  1 :\n\t       0;\n}\n\nstatic int compare_ref_delta_entry(const void *a, const void *b)\n{\n\tconst struct ref_delta_entry *delta_a = a;\n\tconst struct ref_delta_entry *delta_b = b;\n\n\treturn oidcmp(&delta_a->oid, &delta_b->oid);\n}\n\nstatic void *threaded_second_pass(void *data)\n{\n\tif (data)\n\t\tset_thread_data(data);\n\tfor (;;) {\n\t\tstruct base_data *parent = NULL;\n\t\tstruct object_entry *child_obj;\n\t\tstruct base_data *child;\n\n\t\tcounter_lock();\n\t\tdisplay_progress(progress, nr_resolved_deltas);\n\t\tcounter_unlock();\n\n\t\twork_lock();\n\t\tif (list_empty(&work_head)) {\n\t\t\t/*\n\t\t\t * Take an object from the object array.\n\t\t\t */\n\t\t\twhile (nr_dispatched < nr_objects &&\n\t\t\t       is_delta_type(objects[nr_dispatched].type))\n\t\t\t\tnr_dispatched++;\n\t\t\tif (nr_dispatched >= nr_objects) {\n\t\t\t\twork_unlock();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tchild_obj = &objects[nr_dispatched++];\n\t\t} else {\n\t\t\t/*\n\t\t\t * Peek at the top of the stack, and take a child from\n\t\t\t * it.\n\t\t\t */\n\t\t\tparent = list_first_entry(&work_head, struct base_data,\n\t\t\t\t\t\t  list);\n\n\t\t\tif (parent->ref_first <= parent->ref_last) {\n\t\t\t\tint offset = ref_deltas[parent->ref_first++].obj_no;\n\t\t\t\tchild_obj = objects + offset;\n\t\t\t\tif (child_obj->real_type != OBJ_REF_DELTA)\n\t\t\t\t\tdie(\"REF_DELTA at offset %\"PRIuMAX\" already resolved (duplicate base %s?)\",\n\t\t\t\t\t    (uintmax_t) child_obj->idx.offset,\n\t\t\t\t\t    oid_to_hex(&parent->obj->idx.oid));\n\t\t\t\tchild_obj->real_type = parent->obj->real_type;\n\t\t\t} else {\n\t\t\t\tchild_obj = objects +\n\t\t\t\t\tofs_deltas[parent->ofs_first++].obj_no;\n\t\t\t\tassert(child_obj->real_type == OBJ_OFS_DELTA);\n\t\t\t\tchild_obj->real_type = parent->obj->real_type;\n\t\t\t}\n\n\t\t\tif (parent->ref_first > parent->ref_last &&\n\t\t\t    parent->ofs_first > parent->ofs_last) {\n\t\t\t\t/*\n\t\t\t\t * This parent has run out of children, so move\n\t\t\t\t * it to done_head.\n\t\t\t\t */\n\t\t\t\tlist_del(&parent->list);\n\t\t\t\tlist_add(&parent->list, &done_head);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Ensure that the parent has data, since we will need\n\t\t\t * it later.\n\t\t\t *\n\t\t\t * NEEDSWORK: If parent data needs to be reloaded, this\n\t\t\t * prolongs the time that the current thread spends in\n\t\t\t * the mutex. A mitigating factor is that parent data\n\t\t\t * needs to be reloaded only if the delta base cache\n\t\t\t * limit is exceeded, so in the typical case, this does\n\t\t\t * not happen.\n\t\t\t */\n\t\t\tget_base_data(parent);\n\t\t\tparent->retain_data++;\n\t\t}\n\t\twork_unlock();\n\n\t\tif (parent) {\n\t\t\tchild = resolve_delta(child_obj, parent);\n\t\t\tif (!child->children_remaining)\n\t\t\t\tFREE_AND_NULL(child->data);\n\t\t} else {\n\t\t\tchild = make_base(child_obj, NULL);\n\t\t\tif (child->children_remaining) {\n\t\t\t\t/*\n\t\t\t\t * Since this child has its own delta children,\n\t\t\t\t * we will need this data in the future.\n\t\t\t\t * Inflate now so that future iterations will\n\t\t\t\t * have access to this object's data while\n\t\t\t\t * outside the work mutex.\n\t\t\t\t */\n\t\t\t\tchild->data = get_data_from_pack(child_obj);\n\t\t\t\tchild->size = child_obj->size;\n\t\t\t}\n\t\t}\n\n\t\twork_lock();\n\t\tif (parent)\n\t\t\tparent->retain_data--;\n\t\tif (child->data) {\n\t\t\t/*\n\t\t\t * This child has its own children, so add it to\n\t\t\t * work_head.\n\t\t\t */\n\t\t\tlist_add(&child->list, &work_head);\n\t\t\tbase_cache_used += child->size;\n\t\t\tprune_base_data(NULL);\n\t\t\tfree_base_data(child);\n\t\t} else {\n\t\t\t/*\n\t\t\t * This child does not have its own children. It may be\n\t\t\t * the last descendant of its ancestors; free those\n\t\t\t * that we can.\n\t\t\t */\n\t\t\tstruct base_data *p = parent;\n\n\t\t\twhile (p) {\n\t\t\t\tstruct base_data *next_p;\n\n\t\t\t\tp->children_remaining--;\n\t\t\t\tif (p->children_remaining)\n\t\t\t\t\tbreak;\n\n\t\t\t\tnext_p = p->base;\n\t\t\t\tfree_base_data(p);\n\t\t\t\tlist_del(&p->list);\n\t\t\t\tfree(p);\n\n\t\t\t\tp = next_p;\n\t\t\t}\n\t\t\tFREE_AND_NULL(child);\n\t\t}\n\t\twork_unlock();\n\t}\n\treturn NULL;\n}\n\n/*\n * First pass:\n * - find locations of all objects;\n * - calculate SHA1 of all non-delta objects;\n * - remember base (SHA1 or offset) for all deltas.\n */\nstatic void parse_pack_objects(unsigned char *hash)\n{\n\tint i, nr_delays = 0;\n\tstruct ofs_delta_entry *ofs_delta = ofs_deltas;\n\tstruct object_id ref_delta_oid;\n\tstruct stat st;\n\n\tif (verbose)\n\t\tprogress = start_progress(\n\t\t\t\tprogress_title ? progress_title :\n\t\t\t\tfrom_stdin ? _(\"Receiving objects\") : _(\"Indexing objects\"),\n\t\t\t\tnr_objects);\n\tfor (i = 0; i < nr_objects; i++) {\n\t\tstruct object_entry *obj = &objects[i];\n\t\tvoid *data = unpack_raw_entry(obj, &ofs_delta->offset,\n\t\t\t\t\t      &ref_delta_oid,\n\t\t\t\t\t      &obj->idx.oid);\n\t\tobj->real_type = obj->type;\n\t\tif (obj->type == OBJ_OFS_DELTA) {\n\t\t\tnr_ofs_deltas++;\n\t\t\tofs_delta->obj_no = i;\n\t\t\tofs_delta++;\n\t\t} else if (obj->type == OBJ_REF_DELTA) {\n\t\t\tALLOC_GROW(ref_deltas, nr_ref_deltas + 1, ref_deltas_alloc);\n\t\t\toidcpy(&ref_deltas[nr_ref_deltas].oid, &ref_delta_oid);\n\t\t\tref_deltas[nr_ref_deltas].obj_no = i;\n\t\t\tnr_ref_deltas++;\n\t\t} else if (!data) {\n\t\t\t/* large blobs, check later */\n\t\t\tobj->real_type = OBJ_BAD;\n\t\t\tnr_delays++;\n\t\t} else\n\t\t\tsha1_object(data, NULL, obj->size, obj->type,\n\t\t\t\t    &obj->idx.oid);\n\t\tfree(data);\n\t\tdisplay_progress(progress, i+1);\n\t}\n\tobjects[i].idx.offset = consumed_bytes;\n\tstop_progress(&progress);\n\n\t/* Check pack integrity */\n\tflush();\n\tthe_hash_algo->final_fn(hash, &input_ctx);\n\tif (!hasheq(fill(the_hash_algo->rawsz), hash))\n\t\tdie(_(\"pack is corrupted (SHA1 mismatch)\"));\n\tuse(the_hash_algo->rawsz);\n\n\t/* If input_fd is a file, we should have reached its end now. */\n\tif (fstat(input_fd, &st))\n\t\tdie_errno(_(\"cannot fstat packfile\"));\n\tif (S_ISREG(st.st_mode) &&\n\t\t\tlseek(input_fd, 0, SEEK_CUR) - input_len != st.st_size)\n\t\tdie(_(\"pack has junk at the end\"));\n\n\tfor (i = 0; i < nr_objects; i++) {\n\t\tstruct object_entry *obj = &objects[i];\n\t\tif (obj->real_type != OBJ_BAD)\n\t\t\tcontinue;\n\t\tobj->real_type = obj->type;\n\t\tsha1_object(NULL, obj, obj->size, obj->type,\n\t\t\t    &obj->idx.oid);\n\t\tnr_delays--;\n\t}\n\tif (nr_delays)\n\t\tdie(_(\"confusion beyond insanity in parse_pack_objects()\"));\n}\n\n/*\n * Second pass:\n * - for all non-delta objects, look if it is used as a base for\n *   deltas;\n * - if used as a base, uncompress the object and apply all deltas,\n *   recursively checking if the resulting object is used as a base\n *   for some more deltas.\n */\nstatic void resolve_deltas(void)\n{\n\tint i;\n\n\tif (!nr_ofs_deltas && !nr_ref_deltas)\n\t\treturn;\n\n\t/* Sort deltas by base SHA1/offset for fast searching */\n\tQSORT(ofs_deltas, nr_ofs_deltas, compare_ofs_delta_entry);\n\tQSORT(ref_deltas, nr_ref_deltas, compare_ref_delta_entry);\n\n\tif (verbose || show_resolving_progress)\n\t\tprogress = start_progress(_(\"Resolving deltas\"),\n\t\t\t\t\t  nr_ref_deltas + nr_ofs_deltas);\n\n\tnr_dispatched = 0;\n\tbase_cache_limit = delta_base_cache_limit * nr_threads;\n\tif (nr_threads > 1 || getenv(\"GIT_FORCE_THREADS\")) {\n\t\tinit_thread();\n\t\twork_lock();\n\t\tfor (i = 0; i < nr_threads; i++) {\n\t\t\tint ret = pthread_create(&thread_data[i].thread, NULL,\n\t\t\t\t\t\t threaded_second_pass, thread_data + i);\n\t\t\tif (ret)\n\t\t\t\tdie(_(\"unable to create thread: %s\"),\n\t\t\t\t    strerror(ret));\n\t\t}\n\t\twork_unlock();\n\t\tfor (i = 0; i < nr_threads; i++)\n\t\t\tpthread_join(thread_data[i].thread, NULL);\n\t\tcleanup_thread();\n\t\treturn;\n\t}\n\tthreaded_second_pass(&nothread_data);\n}\n\n/*\n * Third pass:\n * - append objects to convert thin pack to full pack if required\n * - write the final pack hash\n */\nstatic void fix_unresolved_deltas(struct hashfile *f);\nstatic void conclude_pack(int fix_thin_pack, const char *curr_pack, unsigned char *pack_hash)\n{\n\tif (nr_ref_deltas + nr_ofs_deltas == nr_resolved_deltas) {\n\t\tstop_progress(&progress);\n\t\t/* Flush remaining pack final hash. */\n\t\tflush();\n\t\treturn;\n\t}\n\n\tif (fix_thin_pack) {\n\t\tstruct hashfile *f;\n\t\tunsigned char read_hash[GIT_MAX_RAWSZ], tail_hash[GIT_MAX_RAWSZ];\n\t\tstruct strbuf msg = STRBUF_INIT;\n\t\tint nr_unresolved = nr_ofs_deltas + nr_ref_deltas - nr_resolved_deltas;\n\t\tint nr_objects_initial = nr_objects;\n\t\tif (nr_unresolved <= 0)\n\t\t\tdie(_(\"confusion beyond insanity\"));\n\t\tREALLOC_ARRAY(objects, nr_objects + nr_unresolved + 1);\n\t\tmemset(objects + nr_objects + 1, 0,\n\t\t       nr_unresolved * sizeof(*objects));\n\t\tf = hashfd(output_fd, curr_pack);\n\t\tfix_unresolved_deltas(f);\n\t\tstrbuf_addf(&msg, Q_(\"completed with %d local object\",\n\t\t\t\t     \"completed with %d local objects\",\n\t\t\t\t     nr_objects - nr_objects_initial),\n\t\t\t    nr_objects - nr_objects_initial);\n\t\tstop_progress_msg(&progress, msg.buf);\n\t\tstrbuf_release(&msg);\n\t\tfinalize_hashfile(f, tail_hash, FSYNC_COMPONENT_PACK, 0);\n\t\thashcpy(read_hash, pack_hash);\n\t\tfixup_pack_header_footer(output_fd, pack_hash,\n\t\t\t\t\t curr_pack, nr_objects,\n\t\t\t\t\t read_hash, consumed_bytes-the_hash_algo->rawsz);\n\t\tif (!hasheq(read_hash, tail_hash))\n\t\t\tdie(_(\"Unexpected tail checksum for %s \"\n\t\t\t      \"(disk corruption?)\"), curr_pack);\n\t}\n\tif (nr_ofs_deltas + nr_ref_deltas != nr_resolved_deltas)\n\t\tdie(Q_(\"pack has %d unresolved delta\",\n\t\t       \"pack has %d unresolved deltas\",\n\t\t       nr_ofs_deltas + nr_ref_deltas - nr_resolved_deltas),\n\t\t    nr_ofs_deltas + nr_ref_deltas - nr_resolved_deltas);\n}\n\nstatic int write_compressed(struct hashfile *f, void *in, unsigned int size)\n{\n\tgit_zstream stream;\n\tint status;\n\tunsigned char outbuf[4096];\n\n\tgit_deflate_init(&stream, zlib_compression_level);\n\tstream.next_in = in;\n\tstream.avail_in = size;\n\n\tdo {\n\t\tstream.next_out = outbuf;\n\t\tstream.avail_out = sizeof(outbuf);\n\t\tstatus = git_deflate(&stream, Z_FINISH);\n\t\thashwrite(f, outbuf, sizeof(outbuf) - stream.avail_out);\n\t} while (status == Z_OK);\n\n\tif (status != Z_STREAM_END)\n\t\tdie(_(\"unable to deflate appended object (%d)\"), status);\n\tsize = stream.total_out;\n\tgit_deflate_end(&stream);\n\treturn size;\n}\n\nstatic struct object_entry *append_obj_to_pack(struct hashfile *f,\n\t\t\t       const unsigned char *sha1, void *buf,\n\t\t\t       unsigned long size, enum object_type type)\n{\n\tstruct object_entry *obj = &objects[nr_objects++];\n\tunsigned char header[10];\n\tunsigned long s = size;\n\tint n = 0;\n\tunsigned char c = (type << 4) | (s & 15);\n\ts >>= 4;\n\twhile (s) {\n\t\theader[n++] = c | 0x80;\n\t\tc = s & 0x7f;\n\t\ts >>= 7;\n\t}\n\theader[n++] = c;\n\tcrc32_begin(f);\n\thashwrite(f, header, n);\n\tobj[0].size = size;\n\tobj[0].hdr_size = n;\n\tobj[0].type = type;\n\tobj[0].real_type = type;\n\tobj[1].idx.offset = obj[0].idx.offset + n;\n\tobj[1].idx.offset += write_compressed(f, buf, size);\n\tobj[0].idx.crc32 = crc32_end(f);\n\thashflush(f);\n\toidread(&obj->idx.oid, sha1);\n\treturn obj;\n}\n\nstatic int delta_pos_compare(const void *_a, const void *_b)\n{\n\tstruct ref_delta_entry *a = *(struct ref_delta_entry **)_a;\n\tstruct ref_delta_entry *b = *(struct ref_delta_entry **)_b;\n\treturn a->obj_no - b->obj_no;\n}\n\nstatic void fix_unresolved_deltas(struct hashfile *f)\n{\n\tstruct ref_delta_entry **sorted_by_pos;\n\tint i;\n\n\t/*\n\t * Since many unresolved deltas may well be themselves base objects\n\t * for more unresolved deltas, we really want to include the\n\t * smallest number of base objects that would cover as much delta\n\t * as possible by picking the\n\t * trunc deltas first, allowing for other deltas to resolve without\n\t * additional base objects.  Since most base objects are to be found\n\t * before deltas depending on them, a good heuristic is to start\n\t * resolving deltas in the same order as their position in the pack.\n\t */\n\tALLOC_ARRAY(sorted_by_pos, nr_ref_deltas);\n\tfor (i = 0; i < nr_ref_deltas; i++)\n\t\tsorted_by_pos[i] = &ref_deltas[i];\n\tQSORT(sorted_by_pos, nr_ref_deltas, delta_pos_compare);\n\n\tif (has_promisor_remote()) {\n\t\t/*\n\t\t * Prefetch the delta bases.\n\t\t */\n\t\tstruct oid_array to_fetch = OID_ARRAY_INIT;\n\t\tfor (i = 0; i < nr_ref_deltas; i++) {\n\t\t\tstruct ref_delta_entry *d = sorted_by_pos[i];\n\t\t\tif (!oid_object_info_extended(the_repository, &d->oid,\n\t\t\t\t\t\t      NULL,\n\t\t\t\t\t\t      OBJECT_INFO_FOR_PREFETCH))\n\t\t\t\tcontinue;\n\t\t\toid_array_append(&to_fetch, &d->oid);\n\t\t}\n\t\tpromisor_remote_get_direct(the_repository,\n\t\t\t\t\t   to_fetch.oid, to_fetch.nr);\n\t\toid_array_clear(&to_fetch);\n\t}\n\n\tfor (i = 0; i < nr_ref_deltas; i++) {\n\t\tstruct ref_delta_entry *d = sorted_by_pos[i];\n\t\tenum object_type type;\n\t\tvoid *data;\n\t\tunsigned long size;\n\n\t\tif (objects[d->obj_no].real_type != OBJ_REF_DELTA)\n\t\t\tcontinue;\n\t\tdata = read_object_file(&d->oid, &type, &size);\n\t\tif (!data)\n\t\t\tcontinue;\n\n\t\tif (check_object_signature(the_repository, &d->oid, data, size,\n\t\t\t\t\t   type) < 0)\n\t\t\tdie(_(\"local object %s is corrupt\"), oid_to_hex(&d->oid));\n\n\t\t/*\n\t\t * Add this as an object to the objects array and call\n\t\t * threaded_second_pass() (which will pick up the added\n\t\t * object).\n\t\t */\n\t\tappend_obj_to_pack(f, d->oid.hash, data, size, type);\n\t\tfree(data);\n\t\tthreaded_second_pass(NULL);\n\n\t\tdisplay_progress(progress, nr_resolved_deltas);\n\t}\n\tfree(sorted_by_pos);\n}\n\nstatic const char *derive_filename(const char *pack_name, const char *strip,\n\t\t\t\t   const char *suffix, struct strbuf *buf)\n{\n\tsize_t len;\n\tif (!strip_suffix(pack_name, strip, &len) || !len ||\n\t    pack_name[len - 1] != '.')\n\t\tdie(_(\"packfile name '%s' does not end with '.%s'\"),\n\t\t    pack_name, strip);\n\tstrbuf_add(buf, pack_name, len);\n\tstrbuf_addstr(buf, suffix);\n\treturn buf->buf;\n}\n\nstatic void write_special_file(const char *suffix, const char *msg,\n\t\t\t       const char *pack_name, const unsigned char *hash,\n\t\t\t       const char **report)\n{\n\tstruct strbuf name_buf = STRBUF_INIT;\n\tconst char *filename;\n\tint fd;\n\tint msg_len = strlen(msg);\n\n\tif (pack_name)\n\t\tfilename = derive_filename(pack_name, \"pack\", suffix, &name_buf);\n\telse\n\t\tfilename = odb_pack_name(&name_buf, hash, suffix);\n\n\tfd = odb_pack_keep(filename);\n\tif (fd < 0) {\n\t\tif (errno != EEXIST)\n\t\t\tdie_errno(_(\"cannot write %s file '%s'\"),\n\t\t\t\t  suffix, filename);\n\t} else {\n\t\tif (msg_len > 0) {\n\t\t\twrite_or_die(fd, msg, msg_len);\n\t\t\twrite_or_die(fd, \"\\n\", 1);\n\t\t}\n\t\tif (close(fd) != 0)\n\t\t\tdie_errno(_(\"cannot close written %s file '%s'\"),\n\t\t\t\t  suffix, filename);\n\t\tif (report)\n\t\t\t*report = suffix;\n\t}\n\tstrbuf_release(&name_buf);\n}\n\nstatic void rename_tmp_packfile(const char **final_name,\n\t\t\t\tconst char *curr_name,\n\t\t\t\tstruct strbuf *name, unsigned char *hash,\n\t\t\t\tconst char *ext, int make_read_only_if_same)\n{\n\tif (*final_name != curr_name) {\n\t\tif (!*final_name)\n\t\t\t*final_name = odb_pack_name(name, hash, ext);\n\t\tif (finalize_object_file(curr_name, *final_name))\n\t\t\tdie(_(\"unable to rename temporary '*.%s' file to '%s'\"),\n\t\t\t    ext, *final_name);\n\t} else if (make_read_only_if_same) {\n\t\tchmod(*final_name, 0444);\n\t}\n}\n\nstatic void final(const char *final_pack_name, const char *curr_pack_name,\n\t\t  const char *final_index_name, const char *curr_index_name,\n\t\t  const char *final_rev_index_name, const char *curr_rev_index_name,\n\t\t  const char *keep_msg, const char *promisor_msg,\n\t\t  unsigned char *hash)\n{\n\tconst char *report = \"pack\";\n\tstruct strbuf pack_name = STRBUF_INIT;\n\tstruct strbuf index_name = STRBUF_INIT;\n\tstruct strbuf rev_index_name = STRBUF_INIT;\n\tint err;\n\n\tif (!from_stdin) {\n\t\tclose(input_fd);\n\t} else {\n\t\tfsync_component_or_die(FSYNC_COMPONENT_PACK, output_fd, curr_pack_name);\n\t\terr = close(output_fd);\n\t\tif (err)\n\t\t\tdie_errno(_(\"error while closing pack file\"));\n\t}\n\n\tif (keep_msg)\n\t\twrite_special_file(\"keep\", keep_msg, final_pack_name, hash,\n\t\t\t\t   &report);\n\tif (promisor_msg)\n\t\twrite_special_file(\"promisor\", promisor_msg, final_pack_name,\n\t\t\t\t   hash, NULL);\n\n\trename_tmp_packfile(&final_pack_name, curr_pack_name, &pack_name,\n\t\t\t    hash, \"pack\", from_stdin);\n\tif (curr_rev_index_name)\n\t\trename_tmp_packfile(&final_rev_index_name, curr_rev_index_name,\n\t\t\t\t    &rev_index_name, hash, \"rev\", 1);\n\trename_tmp_packfile(&final_index_name, curr_index_name, &index_name,\n\t\t\t    hash, \"idx\", 1);\n\n\tif (do_fsck_object) {\n\t\tstruct packed_git *p;\n\t\tp = add_packed_git(final_index_name, strlen(final_index_name), 0);\n\t\tif (p)\n\t\t\tinstall_packed_git(the_repository, p);\n\t}\n\n\tif (!from_stdin) {\n\t\tprintf(\"%s\\n\", hash_to_hex(hash));\n\t} else {\n\t\tstruct strbuf buf = STRBUF_INIT;\n\n\t\tstrbuf_addf(&buf, \"%s\\t%s\\n\", report, hash_to_hex(hash));\n\t\twrite_or_die(1, buf.buf, buf.len);\n\t\tstrbuf_release(&buf);\n\n\t\t/*\n\t\t * Let's just mimic git-unpack-objects here and write\n\t\t * the last part of the input buffer to stdout.\n\t\t */\n\t\twhile (input_len) {\n\t\t\terr = xwrite(1, input_buffer + input_offset, input_len);\n\t\t\tif (err <= 0)\n\t\t\t\tbreak;\n\t\t\tinput_len -= err;\n\t\t\tinput_offset += err;\n\t\t}\n\t}\n\n\tstrbuf_release(&rev_index_name);\n\tstrbuf_release(&index_name);\n\tstrbuf_release(&pack_name);\n}\n\nstatic int git_index_pack_config(const char *k, const char *v, void *cb)\n{\n\tstruct pack_idx_option *opts = cb;\n\n\tif (!strcmp(k, \"pack.indexversion\")) {\n\t\topts->version = git_config_int(k, v);\n\t\tif (opts->version > 2)\n\t\t\tdie(_(\"bad pack.indexVersion=%\"PRIu32), opts->version);\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"pack.threads\")) {\n\t\tnr_threads = git_config_int(k, v);\n\t\tif (nr_threads < 0)\n\t\t\tdie(_(\"invalid number of threads specified (%d)\"),\n\t\t\t    nr_threads);\n\t\tif (!HAVE_THREADS && nr_threads != 1) {\n\t\t\twarning(_(\"no threads support, ignoring %s\"), k);\n\t\t\tnr_threads = 1;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"pack.writereverseindex\")) {\n\t\tif (git_config_bool(k, v))\n\t\t\topts->flags |= WRITE_REV;\n\t\telse\n\t\t\topts->flags &= ~WRITE_REV;\n\t}\n\treturn git_default_config(k, v, cb);\n}\n\nstatic int cmp_uint32(const void *a_, const void *b_)\n{\n\tuint32_t a = *((uint32_t *)a_);\n\tuint32_t b = *((uint32_t *)b_);\n\n\treturn (a < b) ? -1 : (a != b);\n}\n\nstatic void read_v2_anomalous_offsets(struct packed_git *p,\n\t\t\t\t      struct pack_idx_option *opts)\n{\n\tconst uint32_t *idx1, *idx2;\n\tuint32_t i;\n\n\t/* The address of the 4-byte offset table */\n\tidx1 = (((const uint32_t *)((const uint8_t *)p->index_data + p->crc_offset))\n\t\t+ (size_t)p->num_objects /* CRC32 table */\n\t\t);\n\n\t/* The address of the 8-byte offset table */\n\tidx2 = idx1 + p->num_objects;\n\n\tfor (i = 0; i < p->num_objects; i++) {\n\t\tuint32_t off = ntohl(idx1[i]);\n\t\tif (!(off & 0x80000000))\n\t\t\tcontinue;\n\t\toff = off & 0x7fffffff;\n\t\tcheck_pack_index_ptr(p, &idx2[off * 2]);\n\t\tif (idx2[off * 2])\n\t\t\tcontinue;\n\t\t/*\n\t\t * The real offset is ntohl(idx2[off * 2]) in high 4\n\t\t * octets, and ntohl(idx2[off * 2 + 1]) in low 4\n\t\t * octets.  But idx2[off * 2] is Zero!!!\n\t\t */\n\t\tALLOC_GROW(opts->anomaly, opts->anomaly_nr + 1, opts->anomaly_alloc);\n\t\topts->anomaly[opts->anomaly_nr++] = ntohl(idx2[off * 2 + 1]);\n\t}\n\n\tQSORT(opts->anomaly, opts->anomaly_nr, cmp_uint32);\n}\n\nstatic void read_idx_option(struct pack_idx_option *opts, const char *pack_name)\n{\n\tstruct packed_git *p = add_packed_git(pack_name, strlen(pack_name), 1);\n\n\tif (!p)\n\t\tdie(_(\"Cannot open existing pack file '%s'\"), pack_name);\n\tif (open_pack_index(p))\n\t\tdie(_(\"Cannot open existing pack idx file for '%s'\"), pack_name);\n\n\t/* Read the attributes from the existing idx file */\n\topts->version = p->index_version;\n\n\tif (opts->version == 2)\n\t\tread_v2_anomalous_offsets(p, opts);\n\n\t/*\n\t * Get rid of the idx file as we do not need it anymore.\n\t * NEEDSWORK: extract this bit from free_pack_by_name() in\n\t * object-file.c, perhaps?  It shouldn't matter very much as we\n\t * know we haven't installed this pack (hence we never have\n\t * read anything from it).\n\t */\n\tclose_pack_index(p);\n\tfree(p);\n}\n\nstatic void show_pack_info(int stat_only)\n{\n\tint i, baseobjects = nr_objects - nr_ref_deltas - nr_ofs_deltas;\n\tunsigned long *chain_histogram = NULL;\n\n\tif (deepest_delta)\n\t\tCALLOC_ARRAY(chain_histogram, deepest_delta);\n\n\tfor (i = 0; i < nr_objects; i++) {\n\t\tstruct object_entry *obj = &objects[i];\n\n\t\tif (is_delta_type(obj->type))\n\t\t\tchain_histogram[obj_stat[i].delta_depth - 1]++;\n\t\tif (stat_only)\n\t\t\tcontinue;\n\t\tprintf(\"%s %-6s %\"PRIuMAX\" %\"PRIuMAX\" %\"PRIuMAX,\n\t\t       oid_to_hex(&obj->idx.oid),\n\t\t       type_name(obj->real_type), (uintmax_t)obj->size,\n\t\t       (uintmax_t)(obj[1].idx.offset - obj->idx.offset),\n\t\t       (uintmax_t)obj->idx.offset);\n\t\tif (is_delta_type(obj->type)) {\n\t\t\tstruct object_entry *bobj = &objects[obj_stat[i].base_object_no];\n\t\t\tprintf(\" %u %s\", obj_stat[i].delta_depth,\n\t\t\t       oid_to_hex(&bobj->idx.oid));\n\t\t}\n\t\tputchar('\\n');\n\t}\n\n\tif (baseobjects)\n\t\tprintf_ln(Q_(\"non delta: %d object\",\n\t\t\t     \"non delta: %d objects\",\n\t\t\t     baseobjects),\n\t\t\t  baseobjects);\n\tfor (i = 0; i < deepest_delta; i++) {\n\t\tif (!chain_histogram[i])\n\t\t\tcontinue;\n\t\tprintf_ln(Q_(\"chain length = %d: %lu object\",\n\t\t\t     \"chain length = %d: %lu objects\",\n\t\t\t     chain_histogram[i]),\n\t\t\t  i + 1,\n\t\t\t  chain_histogram[i]);\n\t}\n\tfree(chain_histogram);\n}\n\nint cmd_index_pack(int argc, const char **argv, const char *prefix)\n{\n\tint i, fix_thin_pack = 0, verify = 0, stat_only = 0, rev_index;\n\tconst char *curr_index;\n\tconst char *curr_rev_index = NULL;\n\tconst char *index_name = NULL, *pack_name = NULL, *rev_index_name = NULL;\n\tconst char *keep_msg = NULL;\n\tconst char *promisor_msg = NULL;\n\tstruct strbuf index_name_buf = STRBUF_INIT;\n\tstruct strbuf rev_index_name_buf = STRBUF_INIT;\n\tstruct pack_idx_entry **idx_objects;\n\tstruct pack_idx_option opts;\n\tunsigned char pack_hash[GIT_MAX_RAWSZ];\n\tunsigned foreign_nr = 1;\t/* zero is a \"good\" value, assume bad */\n\tint report_end_of_input = 0;\n\tint hash_algo = 0;\n\n\t/*\n\t * index-pack never needs to fetch missing objects except when\n\t * REF_DELTA bases are missing (which are explicitly handled). It only\n\t * accesses the repo to do hash collision checks and to check which\n\t * REF_DELTA bases need to be fetched.\n\t */\n\tfetch_if_missing = 0;\n\n\tif (argc == 2 && !strcmp(argv[1], \"-h\"))\n\t\tusage(index_pack_usage);\n\n\tread_replace_refs = 0;\n\tfsck_options.walk = mark_link;\n\n\treset_pack_idx_option(&opts);\n\tgit_config(git_index_pack_config, &opts);\n\tif (prefix && chdir(prefix))\n\t\tdie(_(\"Cannot come back to cwd\"));\n\n\tif (git_env_bool(GIT_TEST_WRITE_REV_INDEX, 0))\n\t\trev_index = 1;\n\telse\n\t\trev_index = !!(opts.flags & (WRITE_REV_VERIFY | WRITE_REV));\n\n\tfor (i = 1; i < argc; i++) {\n\t\tconst char *arg = argv[i];\n\n\t\tif (*arg == '-') {\n\t\t\tif (!strcmp(arg, \"--stdin\")) {\n\t\t\t\tfrom_stdin = 1;\n\t\t\t} else if (!strcmp(arg, \"--fix-thin\")) {\n\t\t\t\tfix_thin_pack = 1;\n\t\t\t} else if (skip_to_optional_arg(arg, \"--strict\", &arg)) {\n\t\t\t\tstrict = 1;\n\t\t\t\tdo_fsck_object = 1;\n\t\t\t\tfsck_set_msg_types(&fsck_options, arg);\n\t\t\t} else if (!strcmp(arg, \"--check-self-contained-and-connected\")) {\n\t\t\t\tstrict = 1;\n\t\t\t\tcheck_self_contained_and_connected = 1;\n\t\t\t} else if (!strcmp(arg, \"--fsck-objects\")) {\n\t\t\t\tdo_fsck_object = 1;\n\t\t\t} else if (!strcmp(arg, \"--verify\")) {\n\t\t\t\tverify = 1;\n\t\t\t} else if (!strcmp(arg, \"--verify-stat\")) {\n\t\t\t\tverify = 1;\n\t\t\t\tshow_stat = 1;\n\t\t\t} else if (!strcmp(arg, \"--verify-stat-only\")) {\n\t\t\t\tverify = 1;\n\t\t\t\tshow_stat = 1;\n\t\t\t\tstat_only = 1;\n\t\t\t} else if (skip_to_optional_arg(arg, \"--keep\", &keep_msg)) {\n\t\t\t\t; /* nothing to do */\n\t\t\t} else if (skip_to_optional_arg(arg, \"--promisor\", &promisor_msg)) {\n\t\t\t\t; /* already parsed */\n\t\t\t} else if (starts_with(arg, \"--threads=\")) {\n\t\t\t\tchar *end;\n\t\t\t\tnr_threads = strtoul(arg+10, &end, 0);\n\t\t\t\tif (!arg[10] || *end || nr_threads < 0)\n\t\t\t\t\tusage(index_pack_usage);\n\t\t\t\tif (!HAVE_THREADS && nr_threads != 1) {\n\t\t\t\t\twarning(_(\"no threads support, ignoring %s\"), arg);\n\t\t\t\t\tnr_threads = 1;\n\t\t\t\t}\n\t\t\t} else if (starts_with(arg, \"--pack_header=\")) {\n\t\t\t\tstruct pack_header *hdr;\n\t\t\t\tchar *c;\n\n\t\t\t\thdr = (struct pack_header *)input_buffer;\n\t\t\t\thdr->hdr_signature = htonl(PACK_SIGNATURE);\n\t\t\t\thdr->hdr_version = htonl(strtoul(arg + 14, &c, 10));\n\t\t\t\tif (*c != ',')\n\t\t\t\t\tdie(_(\"bad %s\"), arg);\n\t\t\t\thdr->hdr_entries = htonl(strtoul(c + 1, &c, 10));\n\t\t\t\tif (*c)\n\t\t\t\t\tdie(_(\"bad %s\"), arg);\n\t\t\t\tinput_len = sizeof(*hdr);\n\t\t\t} else if (!strcmp(arg, \"-v\")) {\n\t\t\t\tverbose = 1;\n\t\t\t} else if (!strcmp(arg, \"--progress-title\")) {\n\t\t\t\tif (progress_title || (i+1) >= argc)\n\t\t\t\t\tusage(index_pack_usage);\n\t\t\t\tprogress_title = argv[++i];\n\t\t\t} else if (!strcmp(arg, \"--show-resolving-progress\")) {\n\t\t\t\tshow_resolving_progress = 1;\n\t\t\t} else if (!strcmp(arg, \"--report-end-of-input\")) {\n\t\t\t\treport_end_of_input = 1;\n\t\t\t} else if (!strcmp(arg, \"-o\")) {\n\t\t\t\tif (index_name || (i+1) >= argc)\n\t\t\t\t\tusage(index_pack_usage);\n\t\t\t\tindex_name = argv[++i];\n\t\t\t} else if (starts_with(arg, \"--index-version=\")) {\n\t\t\t\tchar *c;\n\t\t\t\topts.version = strtoul(arg + 16, &c, 10);\n\t\t\t\tif (opts.version > 2)\n\t\t\t\t\tdie(_(\"bad %s\"), arg);\n\t\t\t\tif (*c == ',')\n\t\t\t\t\topts.off32_limit = strtoul(c+1, &c, 0);\n\t\t\t\tif (*c || opts.off32_limit & 0x80000000)\n\t\t\t\t\tdie(_(\"bad %s\"), arg);\n\t\t\t} else if (skip_prefix(arg, \"--max-input-size=\", &arg)) {\n\t\t\t\tmax_input_size = strtoumax(arg, NULL, 10);\n\t\t\t} else if (skip_prefix(arg, \"--object-format=\", &arg)) {\n\t\t\t\thash_algo = hash_algo_by_name(arg);\n\t\t\t\tif (hash_algo == GIT_HASH_UNKNOWN)\n\t\t\t\t\tdie(_(\"unknown hash algorithm '%s'\"), arg);\n\t\t\t\trepo_set_hash_algo(the_repository, hash_algo);\n\t\t\t} else if (!strcmp(arg, \"--rev-index\")) {\n\t\t\t\trev_index = 1;\n\t\t\t} else if (!strcmp(arg, \"--no-rev-index\")) {\n\t\t\t\trev_index = 0;\n\t\t\t} else\n\t\t\t\tusage(index_pack_usage);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pack_name)\n\t\t\tusage(index_pack_usage);\n\t\tpack_name = arg;\n\t}\n\n\tif (!pack_name && !from_stdin)\n\t\tusage(index_pack_usage);\n\tif (fix_thin_pack && !from_stdin)\n\t\tdie(_(\"the option '%s' requires '%s'\"), \"--fix-thin\", \"--stdin\");\n\tif (from_stdin && !startup_info->have_repository)\n\t\tdie(_(\"--stdin requires a git repository\"));\n\tif (from_stdin && hash_algo)\n\t\tdie(_(\"options '%s' and '%s' cannot be used together\"), \"--object-format\", \"--stdin\");\n\tif (!index_name && pack_name)\n\t\tindex_name = derive_filename(pack_name, \"pack\", \"idx\", &index_name_buf);\n\n\topts.flags &= ~(WRITE_REV | WRITE_REV_VERIFY);\n\tif (rev_index) {\n\t\topts.flags |= verify ? WRITE_REV_VERIFY : WRITE_REV;\n\t\tif (index_name)\n\t\t\trev_index_name = derive_filename(index_name,\n\t\t\t\t\t\t\t \"idx\", \"rev\",\n\t\t\t\t\t\t\t &rev_index_name_buf);\n\t}\n\n\tif (verify) {\n\t\tif (!index_name)\n\t\t\tdie(_(\"--verify with no packfile name given\"));\n\t\tread_idx_option(&opts, index_name);\n\t\topts.flags |= WRITE_IDX_VERIFY | WRITE_IDX_STRICT;\n\t}\n\tif (strict)\n\t\topts.flags |= WRITE_IDX_STRICT;\n\n\tif (HAVE_THREADS && !nr_threads) {\n\t\tnr_threads = online_cpus();\n\t\t/*\n\t\t * Experiments show that going above 20 threads doesn't help,\n\t\t * no matter how many cores you have. Below that, we tend to\n\t\t * max at half the number of online_cpus(), presumably because\n\t\t * half of those are hyperthreads rather than full cores. We'll\n\t\t * never reduce the level below \"3\", though, to match a\n\t\t * historical value that nobody complained about.\n\t\t */\n\t\tif (nr_threads < 4)\n\t\t\t; /* too few cores to consider capping */\n\t\telse if (nr_threads < 6)\n\t\t\tnr_threads = 3; /* historic cap */\n\t\telse if (nr_threads < 40)\n\t\t\tnr_threads /= 2;\n\t\telse\n\t\t\tnr_threads = 20; /* hard cap */\n\t}\n\n\tcurr_pack = open_pack_file(pack_name);\n\tparse_pack_header();\n\tCALLOC_ARRAY(objects, st_add(nr_objects, 1));\n\tif (show_stat)\n\t\tCALLOC_ARRAY(obj_stat, st_add(nr_objects, 1));\n\tCALLOC_ARRAY(ofs_deltas, nr_objects);\n\tparse_pack_objects(pack_hash);\n\tif (report_end_of_input)\n\t\twrite_in_full(2, \"\\0\", 1);\n\tresolve_deltas();\n\tconclude_pack(fix_thin_pack, curr_pack, pack_hash);\n\tfree(ofs_deltas);\n\tfree(ref_deltas);\n\tif (strict)\n\t\tforeign_nr = check_objects();\n\n\tif (show_stat)\n\t\tshow_pack_info(stat_only);\n\n\tALLOC_ARRAY(idx_objects, nr_objects);\n\tfor (i = 0; i < nr_objects; i++)\n\t\tidx_objects[i] = &objects[i].idx;\n\tcurr_index = write_idx_file(index_name, idx_objects, nr_objects, &opts, pack_hash);\n\tif (rev_index)\n\t\tcurr_rev_index = write_rev_file(rev_index_name, idx_objects,\n\t\t\t\t\t\tnr_objects, pack_hash,\n\t\t\t\t\t\topts.flags);\n\tfree(idx_objects);\n\n\tif (!verify)\n\t\tfinal(pack_name, curr_pack,\n\t\t      index_name, curr_index,\n\t\t      rev_index_name, curr_rev_index,\n\t\t      keep_msg, promisor_msg,\n\t\t      pack_hash);\n\telse\n\t\tclose(input_fd);\n\n\tif (do_fsck_object && fsck_finish(&fsck_options))\n\t\tdie(_(\"fsck error in pack objects\"));\n\n\tfree(opts.anomaly);\n\tfree(objects);\n\tstrbuf_release(&index_name_buf);\n\tstrbuf_release(&rev_index_name_buf);\n\tif (!pack_name)\n\t\tfree((void *) curr_pack);\n\tif (!index_name)\n\t\tfree((void *) curr_index);\n\tif (!rev_index_name)\n\t\tfree((void *) curr_rev_index);\n\n\t/*\n\t * Let the caller know this pack is not self contained\n\t */\n\tif (check_self_contained_and_connected && foreign_nr)\n\t\treturn 1;\n\n\treturn 0;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00c756df5d4b61950760594e575a7d35dec3dbc6",
  "sha1_ok": true,
  "size": 53147
}
