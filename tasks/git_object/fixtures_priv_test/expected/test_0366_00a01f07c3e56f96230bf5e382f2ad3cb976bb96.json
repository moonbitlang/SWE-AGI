{
  "content": {
    "base64": "LyoKICogQnVpbHRpbiAiZ2l0IGNvbW1pdCIKICoKICogQ29weXJpZ2h0IChjKSAyMDA3IEtyaXN0aWFuIEjDuGdzYmVyZyA8a3JoQHJlZGhhdC5jb20+CiAqIEJhc2VkIG9uIGdpdC1jb21taXQuc2ggYnkgSnVuaW8gQyBIYW1hbm8gYW5kIExpbnVzIFRvcnZhbGRzCiAqLwoKI2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJjb25maWcuaCIKI2luY2x1ZGUgImxvY2tmaWxlLmgiCiNpbmNsdWRlICJjYWNoZS10cmVlLmgiCiNpbmNsdWRlICJjb2xvci5oIgojaW5jbHVkZSAiZGlyLmgiCiNpbmNsdWRlICJidWlsdGluLmgiCiNpbmNsdWRlICJkaWZmLmgiCiNpbmNsdWRlICJkaWZmY29yZS5oIgojaW5jbHVkZSAiY29tbWl0LmgiCiNpbmNsdWRlICJyZXZpc2lvbi5oIgojaW5jbHVkZSAid3Qtc3RhdHVzLmgiCiNpbmNsdWRlICJydW4tY29tbWFuZC5oIgojaW5jbHVkZSAicmVmcy5oIgojaW5jbHVkZSAibG9nLXRyZWUuaCIKI2luY2x1ZGUgInN0cmJ1Zi5oIgojaW5jbHVkZSAidXRmOC5oIgojaW5jbHVkZSAicGFyc2Utb3B0aW9ucy5oIgojaW5jbHVkZSAic3RyaW5nLWxpc3QuaCIKI2luY2x1ZGUgInJlcmVyZS5oIgojaW5jbHVkZSAidW5wYWNrLXRyZWVzLmgiCiNpbmNsdWRlICJxdW90ZS5oIgojaW5jbHVkZSAic3VibW9kdWxlLmgiCiNpbmNsdWRlICJncGctaW50ZXJmYWNlLmgiCiNpbmNsdWRlICJjb2x1bW4uaCIKI2luY2x1ZGUgInNlcXVlbmNlci5oIgojaW5jbHVkZSAibm90ZXMtdXRpbHMuaCIKI2luY2x1ZGUgIm1haWxtYXAuaCIKI2luY2x1ZGUgInNpZ2NoYWluLmgiCgpzdGF0aWMgY29uc3QgY2hhciAqIGNvbnN0IGJ1aWx0aW5fY29tbWl0X3VzYWdlW10gPSB7CglOXygiZ2l0IGNvbW1pdCBbPG9wdGlvbnM+XSBbLS1dIDxwYXRoc3BlYz4uLi4iKSwKCU5VTEwKfTsKCnN0YXRpYyBjb25zdCBjaGFyICogY29uc3QgYnVpbHRpbl9zdGF0dXNfdXNhZ2VbXSA9IHsKCU5fKCJnaXQgc3RhdHVzIFs8b3B0aW9ucz5dIFstLV0gPHBhdGhzcGVjPi4uLiIpLAoJTlVMTAp9OwoKc3RhdGljIGNvbnN0IGNoYXIgaW1wbGljaXRfaWRlbnRfYWR2aWNlX25vY29uZmlnW10gPQpOXygiWW91ciBuYW1lIGFuZCBlbWFpbCBhZGRyZXNzIHdlcmUgY29uZmlndXJlZCBhdXRvbWF0aWNhbGx5IGJhc2VkXG4iCiJvbiB5b3VyIHVzZXJuYW1lIGFuZCBob3N0bmFtZS4gUGxlYXNlIGNoZWNrIHRoYXQgdGhleSBhcmUgYWNjdXJhdGUuXG4iCiJZb3UgY2FuIHN1cHByZXNzIHRoaXMgbWVzc2FnZSBieSBzZXR0aW5nIHRoZW0gZXhwbGljaXRseS4gUnVuIHRoZVxuIgoiZm9sbG93aW5nIGNvbW1hbmQgYW5kIGZvbGxvdyB0aGUgaW5zdHJ1Y3Rpb25zIGluIHlvdXIgZWRpdG9yIHRvIGVkaXRcbiIKInlvdXIgY29uZmlndXJhdGlvbiBmaWxlOlxuIgoiXG4iCiIgICAgZ2l0IGNvbmZpZyAtLWdsb2JhbCAtLWVkaXRcbiIKIlxuIgoiQWZ0ZXIgZG9pbmcgdGhpcywgeW91IG1heSBmaXggdGhlIGlkZW50aXR5IHVzZWQgZm9yIHRoaXMgY29tbWl0IHdpdGg6XG4iCiJcbiIKIiAgICBnaXQgY29tbWl0IC0tYW1lbmQgLS1yZXNldC1hdXRob3JcbiIpOwoKc3RhdGljIGNvbnN0IGNoYXIgaW1wbGljaXRfaWRlbnRfYWR2aWNlX2NvbmZpZ1tdID0KTl8oIllvdXIgbmFtZSBhbmQgZW1haWwgYWRkcmVzcyB3ZXJlIGNvbmZpZ3VyZWQgYXV0b21hdGljYWxseSBiYXNlZFxuIgoib24geW91ciB1c2VybmFtZSBhbmQgaG9zdG5hbWUuIFBsZWFzZSBjaGVjayB0aGF0IHRoZXkgYXJlIGFjY3VyYXRlLlxuIgoiWW91IGNhbiBzdXBwcmVzcyB0aGlzIG1lc3NhZ2UgYnkgc2V0dGluZyB0aGVtIGV4cGxpY2l0bHk6XG4iCiJcbiIKIiAgICBnaXQgY29uZmlnIC0tZ2xvYmFsIHVzZXIubmFtZSBcIllvdXIgTmFtZVwiXG4iCiIgICAgZ2l0IGNvbmZpZyAtLWdsb2JhbCB1c2VyLmVtYWlsIHlvdUBleGFtcGxlLmNvbVxuIgoiXG4iCiJBZnRlciBkb2luZyB0aGlzLCB5b3UgbWF5IGZpeCB0aGUgaWRlbnRpdHkgdXNlZCBmb3IgdGhpcyBjb21taXQgd2l0aDpcbiIKIlxuIgoiICAgIGdpdCBjb21taXQgLS1hbWVuZCAtLXJlc2V0LWF1dGhvclxuIik7CgpzdGF0aWMgY29uc3QgY2hhciBlbXB0eV9hbWVuZF9hZHZpY2VbXSA9Ck5fKCJZb3UgYXNrZWQgdG8gYW1lbmQgdGhlIG1vc3QgcmVjZW50IGNvbW1pdCwgYnV0IGRvaW5nIHNvIHdvdWxkIG1ha2VcbiIKIml0IGVtcHR5LiBZb3UgY2FuIHJlcGVhdCB5b3VyIGNvbW1hbmQgd2l0aCAtLWFsbG93LWVtcHR5LCBvciB5b3UgY2FuXG4iCiJyZW1vdmUgdGhlIGNvbW1pdCBlbnRpcmVseSB3aXRoIFwiZ2l0IHJlc2V0IEhFQUReXCIuXG4iKTsKCnN0YXRpYyBjb25zdCBjaGFyIGVtcHR5X2NoZXJyeV9waWNrX2FkdmljZVtdID0KTl8oIlRoZSBwcmV2aW91cyBjaGVycnktcGljayBpcyBub3cgZW1wdHksIHBvc3NpYmx5IGR1ZSB0byBjb25mbGljdCByZXNvbHV0aW9uLlxuIgoiSWYgeW91IHdpc2ggdG8gY29tbWl0IGl0IGFueXdheSwgdXNlOlxuIgoiXG4iCiIgICAgZ2l0IGNvbW1pdCAtLWFsbG93LWVtcHR5XG4iCiJcbiIpOwoKc3RhdGljIGNvbnN0IGNoYXIgZW1wdHlfY2hlcnJ5X3BpY2tfYWR2aWNlX3NpbmdsZVtdID0KTl8oIk90aGVyd2lzZSwgcGxlYXNlIHVzZSAnZ2l0IHJlc2V0J1xuIik7CgpzdGF0aWMgY29uc3QgY2hhciBlbXB0eV9jaGVycnlfcGlja19hZHZpY2VfbXVsdGlbXSA9Ck5fKCJJZiB5b3Ugd2lzaCB0byBza2lwIHRoaXMgY29tbWl0LCB1c2U6XG4iCiJcbiIKIiAgICBnaXQgcmVzZXRcbiIKIlxuIgoiVGhlbiBcImdpdCBjaGVycnktcGljayAtLWNvbnRpbnVlXCIgd2lsbCByZXN1bWUgY2hlcnJ5LXBpY2tpbmdcbiIKInRoZSByZW1haW5pbmcgY29tbWl0cy5cbiIpOwoKc3RhdGljIEdJVF9QQVRIX0ZVTkMoZ2l0X3BhdGhfY29tbWl0X2VkaXRtc2csICJDT01NSVRfRURJVE1TRyIpCgpzdGF0aWMgY29uc3QgY2hhciAqdXNlX21lc3NhZ2VfYnVmZmVyOwpzdGF0aWMgc3RydWN0IGxvY2tfZmlsZSBpbmRleF9sb2NrOyAvKiByZWFsIGluZGV4ICovCnN0YXRpYyBzdHJ1Y3QgbG9ja19maWxlIGZhbHNlX2xvY2s7IC8qIHVzZWQgb25seSBmb3IgcGFydGlhbCBjb21taXRzICovCnN0YXRpYyBlbnVtIHsKCUNPTU1JVF9BU19JUyA9IDEsCglDT01NSVRfTk9STUFMLAoJQ09NTUlUX1BBUlRJQUwKfSBjb21taXRfc3R5bGU7CgpzdGF0aWMgY29uc3QgY2hhciAqbG9nZmlsZSwgKmZvcmNlX2F1dGhvcjsKc3RhdGljIGNvbnN0IGNoYXIgKnRlbXBsYXRlX2ZpbGU7Ci8qCiAqIFRoZSBfbWVzc2FnZSB2YXJpYWJsZXMgYXJlIGNvbW1pdCBuYW1lcyBmcm9tIHdoaWNoIHRvIHRha2UKICogdGhlIGNvbW1pdCBtZXNzYWdlIGFuZC9vciBhdXRob3JzaGlwLgogKi8Kc3RhdGljIGNvbnN0IGNoYXIgKmF1dGhvcl9tZXNzYWdlLCAqYXV0aG9yX21lc3NhZ2VfYnVmZmVyOwpzdGF0aWMgY2hhciAqZWRpdF9tZXNzYWdlLCAqdXNlX21lc3NhZ2U7CnN0YXRpYyBjaGFyICpmaXh1cF9tZXNzYWdlLCAqc3F1YXNoX21lc3NhZ2U7CnN0YXRpYyBpbnQgYWxsLCBhbHNvLCBpbnRlcmFjdGl2ZSwgcGF0Y2hfaW50ZXJhY3RpdmUsIG9ubHksIGFtZW5kLCBzaWdub2ZmOwpzdGF0aWMgaW50IGVkaXRfZmxhZyA9IC0xOyAvKiB1bnNwZWNpZmllZCAqLwpzdGF0aWMgaW50IHF1aWV0LCB2ZXJib3NlLCBub192ZXJpZnksIGFsbG93X2VtcHR5LCBkcnlfcnVuLCByZW5ld19hdXRob3JzaGlwOwpzdGF0aWMgaW50IGNvbmZpZ19jb21taXRfdmVyYm9zZSA9IC0xOyAvKiB1bnNwZWNpZmllZCAqLwpzdGF0aWMgaW50IG5vX3Bvc3RfcmV3cml0ZSwgYWxsb3dfZW1wdHlfbWVzc2FnZTsKc3RhdGljIGNoYXIgKnVudHJhY2tlZF9maWxlc19hcmcsICpmb3JjZV9kYXRlLCAqaWdub3JlX3N1Ym1vZHVsZV9hcmc7CnN0YXRpYyBjaGFyICpzaWduX2NvbW1pdDsKCi8qCiAqIFRoZSBkZWZhdWx0IGNvbW1pdCBtZXNzYWdlIGNsZWFudXAgbW9kZSB3aWxsIHJlbW92ZSB0aGUgbGluZXMKICogYmVnaW5uaW5nIHdpdGggIyAoc2hlbGwgY29tbWVudHMpIGFuZCBsZWFkaW5nIGFuZCB0cmFpbGluZwogKiB3aGl0ZXNwYWNlcyAoZW1wdHkgbGluZXMgb3IgY29udGFpbmluZyBvbmx5IHdoaXRlc3BhY2VzKQogKiBpZiBlZGl0b3IgaXMgdXNlZCwgYW5kIG9ubHkgdGhlIHdoaXRlc3BhY2VzIGlmIHRoZSBtZXNzYWdlCiAqIGlzIHNwZWNpZmllZCBleHBsaWNpdGx5LgogKi8Kc3RhdGljIGVudW0gewoJQ0xFQU5VUF9TUEFDRSwKCUNMRUFOVVBfTk9ORSwKCUNMRUFOVVBfU0NJU1NPUlMsCglDTEVBTlVQX0FMTAp9IGNsZWFudXBfbW9kZTsKc3RhdGljIGNvbnN0IGNoYXIgKmNsZWFudXBfYXJnOwoKc3RhdGljIGVudW0gY29tbWl0X3doZW5jZSB3aGVuY2U7CnN0YXRpYyBpbnQgc2VxdWVuY2VyX2luX3VzZTsKc3RhdGljIGludCB1c2VfZWRpdG9yID0gMSwgaW5jbHVkZV9zdGF0dXMgPSAxOwpzdGF0aWMgaW50IHNob3dfaWdub3JlZF9pbl9zdGF0dXMsIGhhdmVfb3B0aW9uX207CnN0YXRpYyBjb25zdCBjaGFyICpvbmx5X2luY2x1ZGVfYXNzdW1lZDsKc3RhdGljIHN0cnVjdCBzdHJidWYgbWVzc2FnZSA9IFNUUkJVRl9JTklUOwoKc3RhdGljIGVudW0gd3Rfc3RhdHVzX2Zvcm1hdCBzdGF0dXNfZm9ybWF0ID0gU1RBVFVTX0ZPUk1BVF9VTlNQRUNJRklFRDsKCnN0YXRpYyBpbnQgb3B0X3BhcnNlX3BvcmNlbGFpbihjb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHQsIGNvbnN0IGNoYXIgKmFyZywgaW50IHVuc2V0KQp7CgllbnVtIHd0X3N0YXR1c19mb3JtYXQgKnZhbHVlID0gKGVudW0gd3Rfc3RhdHVzX2Zvcm1hdCAqKW9wdC0+dmFsdWU7CglpZiAodW5zZXQpCgkJKnZhbHVlID0gU1RBVFVTX0ZPUk1BVF9OT05FOwoJZWxzZSBpZiAoIWFyZykKCQkqdmFsdWUgPSBTVEFUVVNfRk9STUFUX1BPUkNFTEFJTjsKCWVsc2UgaWYgKCFzdHJjbXAoYXJnLCAidjEiKSB8fCAhc3RyY21wKGFyZywgIjEiKSkKCQkqdmFsdWUgPSBTVEFUVVNfRk9STUFUX1BPUkNFTEFJTjsKCWVsc2UgaWYgKCFzdHJjbXAoYXJnLCAidjIiKSB8fCAhc3RyY21wKGFyZywgIjIiKSkKCQkqdmFsdWUgPSBTVEFUVVNfRk9STUFUX1BPUkNFTEFJTl9WMjsKCWVsc2UKCQlkaWUoInVuc3VwcG9ydGVkIHBvcmNlbGFpbiB2ZXJzaW9uICclcyciLCBhcmcpOwoKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IG9wdF9wYXJzZV9tKGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdCwgY29uc3QgY2hhciAqYXJnLCBpbnQgdW5zZXQpCnsKCXN0cnVjdCBzdHJidWYgKmJ1ZiA9IG9wdC0+dmFsdWU7CglpZiAodW5zZXQpIHsKCQloYXZlX29wdGlvbl9tID0gMDsKCQlzdHJidWZfc2V0bGVuKGJ1ZiwgMCk7Cgl9IGVsc2UgewoJCWhhdmVfb3B0aW9uX20gPSAxOwoJCWlmIChidWYtPmxlbikKCQkJc3RyYnVmX2FkZGNoKGJ1ZiwgJ1xuJyk7CgkJc3RyYnVmX2FkZHN0cihidWYsIGFyZyk7CgkJc3RyYnVmX2NvbXBsZXRlX2xpbmUoYnVmKTsKCX0KCXJldHVybiAwOwp9CgpzdGF0aWMgdm9pZCBkZXRlcm1pbmVfd2hlbmNlKHN0cnVjdCB3dF9zdGF0dXMgKnMpCnsKCWlmIChmaWxlX2V4aXN0cyhnaXRfcGF0aF9tZXJnZV9oZWFkKCkpKQoJCXdoZW5jZSA9IEZST01fTUVSR0U7CgllbHNlIGlmIChmaWxlX2V4aXN0cyhnaXRfcGF0aF9jaGVycnlfcGlja19oZWFkKCkpKSB7CgkJd2hlbmNlID0gRlJPTV9DSEVSUllfUElDSzsKCQlpZiAoZmlsZV9leGlzdHMoZ2l0X3BhdGhfc2VxX2RpcigpKSkKCQkJc2VxdWVuY2VyX2luX3VzZSA9IDE7Cgl9CgllbHNlCgkJd2hlbmNlID0gRlJPTV9DT01NSVQ7CglpZiAocykKCQlzLT53aGVuY2UgPSB3aGVuY2U7Cn0KCnN0YXRpYyB2b2lkIHN0YXR1c19pbml0X2NvbmZpZyhzdHJ1Y3Qgd3Rfc3RhdHVzICpzLCBjb25maWdfZm5fdCBmbikKewoJd3Rfc3RhdHVzX3ByZXBhcmUocyk7CglnaXRtb2R1bGVzX2NvbmZpZygpOwoJZ2l0X2NvbmZpZyhmbiwgcyk7CglkZXRlcm1pbmVfd2hlbmNlKHMpOwoJaW5pdF9kaWZmX3VpX2RlZmF1bHRzKCk7CglzLT5oaW50cyA9IGFkdmljZV9zdGF0dXNfaGludHM7IC8qIG11c3QgY29tZSBhZnRlciBnaXRfY29uZmlnKCkgKi8KfQoKc3RhdGljIHZvaWQgcm9sbGJhY2tfaW5kZXhfZmlsZXModm9pZCkKewoJc3dpdGNoIChjb21taXRfc3R5bGUpIHsKCWNhc2UgQ09NTUlUX0FTX0lTOgoJCWJyZWFrOyAvKiBub3RoaW5nIHRvIGRvICovCgljYXNlIENPTU1JVF9OT1JNQUw6CgkJcm9sbGJhY2tfbG9ja19maWxlKCZpbmRleF9sb2NrKTsKCQlicmVhazsKCWNhc2UgQ09NTUlUX1BBUlRJQUw6CgkJcm9sbGJhY2tfbG9ja19maWxlKCZpbmRleF9sb2NrKTsKCQlyb2xsYmFja19sb2NrX2ZpbGUoJmZhbHNlX2xvY2spOwoJCWJyZWFrOwoJfQp9CgpzdGF0aWMgaW50IGNvbW1pdF9pbmRleF9maWxlcyh2b2lkKQp7CglpbnQgZXJyID0gMDsKCglzd2l0Y2ggKGNvbW1pdF9zdHlsZSkgewoJY2FzZSBDT01NSVRfQVNfSVM6CgkJYnJlYWs7IC8qIG5vdGhpbmcgdG8gZG8gKi8KCWNhc2UgQ09NTUlUX05PUk1BTDoKCQllcnIgPSBjb21taXRfbG9ja19maWxlKCZpbmRleF9sb2NrKTsKCQlicmVhazsKCWNhc2UgQ09NTUlUX1BBUlRJQUw6CgkJZXJyID0gY29tbWl0X2xvY2tfZmlsZSgmaW5kZXhfbG9jayk7CgkJcm9sbGJhY2tfbG9ja19maWxlKCZmYWxzZV9sb2NrKTsKCQlicmVhazsKCX0KCglyZXR1cm4gZXJyOwp9CgovKgogKiBUYWtlIGEgdW5pb24gb2YgcGF0aHMgaW4gdGhlIGluZGV4IGFuZCB0aGUgbmFtZWQgdHJlZSAodHlwaWNhbGx5LCAiSEVBRCIpLAogKiBhbmQgcmV0dXJuIHRoZSBwYXRocyB0aGF0IG1hdGNoIHRoZSBnaXZlbiBwYXR0ZXJuIGluIGxpc3QuCiAqLwpzdGF0aWMgaW50IGxpc3RfcGF0aHMoc3RydWN0IHN0cmluZ19saXN0ICpsaXN0LCBjb25zdCBjaGFyICp3aXRoX3RyZWUsCgkJICAgICAgY29uc3QgY2hhciAqcHJlZml4LCBjb25zdCBzdHJ1Y3QgcGF0aHNwZWMgKnBhdHRlcm4pCnsKCWludCBpLCByZXQ7CgljaGFyICptOwoKCWlmICghcGF0dGVybi0+bnIpCgkJcmV0dXJuIDA7CgoJbSA9IHhjYWxsb2MoMSwgcGF0dGVybi0+bnIpOwoKCWlmICh3aXRoX3RyZWUpIHsKCQljaGFyICptYXhfcHJlZml4ID0gY29tbW9uX3ByZWZpeChwYXR0ZXJuKTsKCQlvdmVybGF5X3RyZWVfb25faW5kZXgoJnRoZV9pbmRleCwgd2l0aF90cmVlLAoJCQkJICAgICAgbWF4X3ByZWZpeCA/IG1heF9wcmVmaXggOiBwcmVmaXgpOwoJCWZyZWUobWF4X3ByZWZpeCk7Cgl9CgoJZm9yIChpID0gMDsgaSA8IGFjdGl2ZV9ucjsgaSsrKSB7CgkJY29uc3Qgc3RydWN0IGNhY2hlX2VudHJ5ICpjZSA9IGFjdGl2ZV9jYWNoZVtpXTsKCQlzdHJ1Y3Qgc3RyaW5nX2xpc3RfaXRlbSAqaXRlbTsKCgkJaWYgKGNlLT5jZV9mbGFncyAmIENFX1VQREFURSkKCQkJY29udGludWU7CgkJaWYgKCFjZV9wYXRoX21hdGNoKGNlLCBwYXR0ZXJuLCBtKSkKCQkJY29udGludWU7CgkJaXRlbSA9IHN0cmluZ19saXN0X2luc2VydChsaXN0LCBjZS0+bmFtZSk7CgkJaWYgKGNlX3NraXBfd29ya3RyZWUoY2UpKQoJCQlpdGVtLT51dGlsID0gaXRlbTsgLyogYmV0dGVyIGEgdmFsaWQgcG9pbnRlciB0aGFuIGEgZmFrZSBvbmUgKi8KCX0KCglyZXQgPSByZXBvcnRfcGF0aF9lcnJvcihtLCBwYXR0ZXJuLCBwcmVmaXgpOwoJZnJlZShtKTsKCXJldHVybiByZXQ7Cn0KCnN0YXRpYyB2b2lkIGFkZF9yZW1vdmVfZmlsZXMoc3RydWN0IHN0cmluZ19saXN0ICpsaXN0KQp7CglpbnQgaTsKCWZvciAoaSA9IDA7IGkgPCBsaXN0LT5ucjsgaSsrKSB7CgkJc3RydWN0IHN0YXQgc3Q7CgkJc3RydWN0IHN0cmluZ19saXN0X2l0ZW0gKnAgPSAmKGxpc3QtPml0ZW1zW2ldKTsKCgkJLyogcC0+dXRpbCBpcyBza2lwLXdvcmt0cmVlICovCgkJaWYgKHAtPnV0aWwpCgkJCWNvbnRpbnVlOwoKCQlpZiAoIWxzdGF0KHAtPnN0cmluZywgJnN0KSkgewoJCQlpZiAoYWRkX3RvX2NhY2hlKHAtPnN0cmluZywgJnN0LCAwKSkKCQkJCWRpZShfKCJ1cGRhdGluZyBmaWxlcyBmYWlsZWQiKSk7CgkJfSBlbHNlCgkJCXJlbW92ZV9maWxlX2Zyb21fY2FjaGUocC0+c3RyaW5nKTsKCX0KfQoKc3RhdGljIHZvaWQgY3JlYXRlX2Jhc2VfaW5kZXgoY29uc3Qgc3RydWN0IGNvbW1pdCAqY3VycmVudF9oZWFkKQp7CglzdHJ1Y3QgdHJlZSAqdHJlZTsKCXN0cnVjdCB1bnBhY2tfdHJlZXNfb3B0aW9ucyBvcHRzOwoJc3RydWN0IHRyZWVfZGVzYyB0OwoKCWlmICghY3VycmVudF9oZWFkKSB7CgkJZGlzY2FyZF9jYWNoZSgpOwoJCXJldHVybjsKCX0KCgltZW1zZXQoJm9wdHMsIDAsIHNpemVvZihvcHRzKSk7CglvcHRzLmhlYWRfaWR4ID0gMTsKCW9wdHMuaW5kZXhfb25seSA9IDE7CglvcHRzLm1lcmdlID0gMTsKCW9wdHMuc3JjX2luZGV4ID0gJnRoZV9pbmRleDsKCW9wdHMuZHN0X2luZGV4ID0gJnRoZV9pbmRleDsKCglvcHRzLmZuID0gb25ld2F5X21lcmdlOwoJdHJlZSA9IHBhcnNlX3RyZWVfaW5kaXJlY3QoJmN1cnJlbnRfaGVhZC0+b2JqZWN0Lm9pZCk7CglpZiAoIXRyZWUpCgkJZGllKF8oImZhaWxlZCB0byB1bnBhY2sgSEVBRCB0cmVlIG9iamVjdCIpKTsKCXBhcnNlX3RyZWUodHJlZSk7Cglpbml0X3RyZWVfZGVzYygmdCwgdHJlZS0+YnVmZmVyLCB0cmVlLT5zaXplKTsKCWlmICh1bnBhY2tfdHJlZXMoMSwgJnQsICZvcHRzKSkKCQlleGl0KDEyOCk7IC8qIFdlJ3ZlIGFscmVhZHkgcmVwb3J0ZWQgdGhlIGVycm9yLCBmaW5pc2ggZHlpbmcgKi8KfQoKc3RhdGljIHZvaWQgcmVmcmVzaF9jYWNoZV9vcl9kaWUoaW50IHJlZnJlc2hfZmxhZ3MpCnsKCS8qCgkgKiByZWZyZXNoX2ZsYWdzIGNvbnRhaW5zIFJFRlJFU0hfUVVJRVQsIHNvIHRoZSBvbmx5IGVycm9ycwoJICogYXJlIGZvciB1bm1lcmdlZCBlbnRyaWVzLgoJICovCglpZiAocmVmcmVzaF9jYWNoZShyZWZyZXNoX2ZsYWdzIHwgUkVGUkVTSF9JTl9QT1JDRUxBSU4pKQoJCWRpZV9yZXNvbHZlX2NvbmZsaWN0KCJjb21taXQiKTsKfQoKc3RhdGljIGNvbnN0IGNoYXIgKnByZXBhcmVfaW5kZXgoaW50IGFyZ2MsIGNvbnN0IGNoYXIgKiphcmd2LCBjb25zdCBjaGFyICpwcmVmaXgsCgkJCQkgY29uc3Qgc3RydWN0IGNvbW1pdCAqY3VycmVudF9oZWFkLCBpbnQgaXNfc3RhdHVzKQp7CglzdHJ1Y3Qgc3RyaW5nX2xpc3QgcGFydGlhbDsKCXN0cnVjdCBwYXRoc3BlYyBwYXRoc3BlYzsKCWludCByZWZyZXNoX2ZsYWdzID0gUkVGUkVTSF9RVUlFVDsKCWNvbnN0IGNoYXIgKnJldDsKCglpZiAoaXNfc3RhdHVzKQoJCXJlZnJlc2hfZmxhZ3MgfD0gUkVGUkVTSF9VTk1FUkdFRDsKCXBhcnNlX3BhdGhzcGVjKCZwYXRoc3BlYywgMCwKCQkgICAgICAgUEFUSFNQRUNfUFJFRkVSX0ZVTEwsCgkJICAgICAgIHByZWZpeCwgYXJndik7CgoJaWYgKHJlYWRfY2FjaGVfcHJlbG9hZCgmcGF0aHNwZWMpIDwgMCkKCQlkaWUoXygiaW5kZXggZmlsZSBjb3JydXB0IikpOwoKCWlmIChpbnRlcmFjdGl2ZSkgewoJCWNoYXIgKm9sZF9pbmRleF9lbnYgPSBOVUxMOwoJCWhvbGRfbG9ja2VkX2luZGV4KCZpbmRleF9sb2NrLCBMT0NLX0RJRV9PTl9FUlJPUik7CgoJCXJlZnJlc2hfY2FjaGVfb3JfZGllKHJlZnJlc2hfZmxhZ3MpOwoKCQlpZiAod3JpdGVfbG9ja2VkX2luZGV4KCZ0aGVfaW5kZXgsICZpbmRleF9sb2NrLCBDTE9TRV9MT0NLKSkKCQkJZGllKF8oInVuYWJsZSB0byBjcmVhdGUgdGVtcG9yYXJ5IGluZGV4IikpOwoKCQlvbGRfaW5kZXhfZW52ID0gZ2V0ZW52KElOREVYX0VOVklST05NRU5UKTsKCQlzZXRlbnYoSU5ERVhfRU5WSVJPTk1FTlQsIGdldF9sb2NrX2ZpbGVfcGF0aCgmaW5kZXhfbG9jayksIDEpOwoKCQlpZiAoaW50ZXJhY3RpdmVfYWRkKGFyZ2MsIGFyZ3YsIHByZWZpeCwgcGF0Y2hfaW50ZXJhY3RpdmUpICE9IDApCgkJCWRpZShfKCJpbnRlcmFjdGl2ZSBhZGQgZmFpbGVkIikpOwoKCQlpZiAob2xkX2luZGV4X2VudiAmJiAqb2xkX2luZGV4X2VudikKCQkJc2V0ZW52KElOREVYX0VOVklST05NRU5ULCBvbGRfaW5kZXhfZW52LCAxKTsKCQllbHNlCgkJCXVuc2V0ZW52KElOREVYX0VOVklST05NRU5UKTsKCgkJZGlzY2FyZF9jYWNoZSgpOwoJCXJlYWRfY2FjaGVfZnJvbShnZXRfbG9ja19maWxlX3BhdGgoJmluZGV4X2xvY2spKTsKCQlpZiAodXBkYXRlX21haW5fY2FjaGVfdHJlZShXUklURV9UUkVFX1NJTEVOVCkgPT0gMCkgewoJCQlpZiAocmVvcGVuX2xvY2tfZmlsZSgmaW5kZXhfbG9jaykgPCAwKQoJCQkJZGllKF8oInVuYWJsZSB0byB3cml0ZSBpbmRleCBmaWxlIikpOwoJCQlpZiAod3JpdGVfbG9ja2VkX2luZGV4KCZ0aGVfaW5kZXgsICZpbmRleF9sb2NrLCBDTE9TRV9MT0NLKSkKCQkJCWRpZShfKCJ1bmFibGUgdG8gdXBkYXRlIHRlbXBvcmFyeSBpbmRleCIpKTsKCQl9IGVsc2UKCQkJd2FybmluZyhfKCJGYWlsZWQgdG8gdXBkYXRlIG1haW4gY2FjaGUgdHJlZSIpKTsKCgkJY29tbWl0X3N0eWxlID0gQ09NTUlUX05PUk1BTDsKCQlyZXR1cm4gZ2V0X2xvY2tfZmlsZV9wYXRoKCZpbmRleF9sb2NrKTsKCX0KCgkvKgoJICogTm9uIHBhcnRpYWwsIG5vbiBhcy1pcyBjb21taXQuCgkgKgoJICogKDEpIGdldCB0aGUgcmVhbCBpbmRleDsKCSAqICgyKSB1cGRhdGUgdGhlX2luZGV4IGFzIG5lY2Vzc2FyeTsKCSAqICgzKSB3cml0ZSB0aGVfaW5kZXggb3V0IHRvIHRoZSByZWFsIGluZGV4IChzdGlsbCBsb2NrZWQpOwoJICogKDQpIHJldHVybiB0aGUgbmFtZSBvZiB0aGUgbG9ja2VkIGluZGV4IGZpbGUuCgkgKgoJICogVGhlIGNhbGxlciBzaG91bGQgcnVuIGhvb2tzIG9uIHRoZSBsb2NrZWQgcmVhbCBpbmRleCwgYW5kCgkgKiAoQSkgaWYgYWxsIGdvZXMgd2VsbCwgY29tbWl0IHRoZSByZWFsIGluZGV4OwoJICogKEIpIG9uIGZhaWx1cmUsIHJvbGxiYWNrIHRoZSByZWFsIGluZGV4LgoJICovCglpZiAoYWxsIHx8IChhbHNvICYmIHBhdGhzcGVjLm5yKSkgewoJCWhvbGRfbG9ja2VkX2luZGV4KCZpbmRleF9sb2NrLCBMT0NLX0RJRV9PTl9FUlJPUik7CgkJYWRkX2ZpbGVzX3RvX2NhY2hlKGFsc28gPyBwcmVmaXggOiBOVUxMLCAmcGF0aHNwZWMsIDApOwoJCXJlZnJlc2hfY2FjaGVfb3JfZGllKHJlZnJlc2hfZmxhZ3MpOwoJCXVwZGF0ZV9tYWluX2NhY2hlX3RyZWUoV1JJVEVfVFJFRV9TSUxFTlQpOwoJCWlmICh3cml0ZV9sb2NrZWRfaW5kZXgoJnRoZV9pbmRleCwgJmluZGV4X2xvY2ssIENMT1NFX0xPQ0spKQoJCQlkaWUoXygidW5hYmxlIHRvIHdyaXRlIG5ld19pbmRleCBmaWxlIikpOwoJCWNvbW1pdF9zdHlsZSA9IENPTU1JVF9OT1JNQUw7CgkJcmV0dXJuIGdldF9sb2NrX2ZpbGVfcGF0aCgmaW5kZXhfbG9jayk7Cgl9CgoJLyoKCSAqIEFzLWlzIGNvbW1pdC4KCSAqCgkgKiAoMSkgcmV0dXJuIHRoZSBuYW1lIG9mIHRoZSByZWFsIGluZGV4IGZpbGUuCgkgKgoJICogVGhlIGNhbGxlciBzaG91bGQgcnVuIGhvb2tzIG9uIHRoZSByZWFsIGluZGV4LAoJICogYW5kIGNyZWF0ZSBjb21taXQgZnJvbSB0aGVfaW5kZXguCgkgKiBXZSBzdGlsbCBuZWVkIHRvIHJlZnJlc2ggdGhlIGluZGV4IGhlcmUuCgkgKi8KCWlmICghb25seSAmJiAhcGF0aHNwZWMubnIpIHsKCQlob2xkX2xvY2tlZF9pbmRleCgmaW5kZXhfbG9jaywgTE9DS19ESUVfT05fRVJST1IpOwoJCXJlZnJlc2hfY2FjaGVfb3JfZGllKHJlZnJlc2hfZmxhZ3MpOwoJCWlmIChhY3RpdmVfY2FjaGVfY2hhbmdlZAoJCSAgICB8fCAhY2FjaGVfdHJlZV9mdWxseV92YWxpZChhY3RpdmVfY2FjaGVfdHJlZSkpCgkJCXVwZGF0ZV9tYWluX2NhY2hlX3RyZWUoV1JJVEVfVFJFRV9TSUxFTlQpOwoJCWlmIChhY3RpdmVfY2FjaGVfY2hhbmdlZCkgewoJCQlpZiAod3JpdGVfbG9ja2VkX2luZGV4KCZ0aGVfaW5kZXgsICZpbmRleF9sb2NrLAoJCQkJCSAgICAgICBDT01NSVRfTE9DSykpCgkJCQlkaWUoXygidW5hYmxlIHRvIHdyaXRlIG5ld19pbmRleCBmaWxlIikpOwoJCX0gZWxzZSB7CgkJCXJvbGxiYWNrX2xvY2tfZmlsZSgmaW5kZXhfbG9jayk7CgkJfQoJCWNvbW1pdF9zdHlsZSA9IENPTU1JVF9BU19JUzsKCQlyZXR1cm4gZ2V0X2luZGV4X2ZpbGUoKTsKCX0KCgkvKgoJICogQSBwYXJ0aWFsIGNvbW1pdC4KCSAqCgkgKiAoMCkgZmluZCB0aGUgc2V0IG9mIGFmZmVjdGVkIHBhdGhzOwoJICogKDEpIGdldCBsb2NrIG9uIHRoZSByZWFsIGluZGV4IGZpbGU7CgkgKiAoMikgdXBkYXRlIHRoZV9pbmRleCB3aXRoIHRoZSBnaXZlbiBwYXRoczsKCSAqICgzKSB3cml0ZSB0aGVfaW5kZXggb3V0IHRvIHRoZSByZWFsIGluZGV4IChzdGlsbCBsb2NrZWQpOwoJICogKDQpIGdldCBsb2NrIG9uIHRoZSBmYWxzZSBpbmRleCBmaWxlOwoJICogKDUpIHJlc2V0IHRoZV9pbmRleCBmcm9tIEhFQUQ7CgkgKiAoNikgdXBkYXRlIHRoZV9pbmRleCB0aGUgc2FtZSB3YXkgYXMgKDIpOwoJICogKDcpIHdyaXRlIHRoZV9pbmRleCBvdXQgdG8gdGhlIGZhbHNlIGluZGV4IGZpbGU7CgkgKiAoOCkgcmV0dXJuIHRoZSBuYW1lIG9mIHRoZSBmYWxzZSBpbmRleCBmaWxlIChzdGlsbCBsb2NrZWQpOwoJICoKCSAqIFRoZSBjYWxsZXIgc2hvdWxkIHJ1biBob29rcyBvbiB0aGUgbG9ja2VkIGZhbHNlIGluZGV4LCBhbmQKCSAqIGNyZWF0ZSBjb21taXQgZnJvbSBpdC4gIFRoZW4KCSAqIChBKSBpZiBhbGwgZ29lcyB3ZWxsLCBjb21taXQgdGhlIHJlYWwgaW5kZXg7CgkgKiAoQikgb24gZmFpbHVyZSwgcm9sbGJhY2sgdGhlIHJlYWwgaW5kZXg7CgkgKiBJbiBlaXRoZXIgY2FzZSwgcm9sbGJhY2sgdGhlIGZhbHNlIGluZGV4LgoJICovCgljb21taXRfc3R5bGUgPSBDT01NSVRfUEFSVElBTDsKCglpZiAod2hlbmNlICE9IEZST01fQ09NTUlUKSB7CgkJaWYgKHdoZW5jZSA9PSBGUk9NX01FUkdFKQoJCQlkaWUoXygiY2Fubm90IGRvIGEgcGFydGlhbCBjb21taXQgZHVyaW5nIGEgbWVyZ2UuIikpOwoJCWVsc2UgaWYgKHdoZW5jZSA9PSBGUk9NX0NIRVJSWV9QSUNLKQoJCQlkaWUoXygiY2Fubm90IGRvIGEgcGFydGlhbCBjb21taXQgZHVyaW5nIGEgY2hlcnJ5LXBpY2suIikpOwoJfQoKCXN0cmluZ19saXN0X2luaXQoJnBhcnRpYWwsIDEpOwoJaWYgKGxpc3RfcGF0aHMoJnBhcnRpYWwsICFjdXJyZW50X2hlYWQgPyBOVUxMIDogIkhFQUQiLCBwcmVmaXgsICZwYXRoc3BlYykpCgkJZXhpdCgxKTsKCglkaXNjYXJkX2NhY2hlKCk7CglpZiAocmVhZF9jYWNoZSgpIDwgMCkKCQlkaWUoXygiY2Fubm90IHJlYWQgdGhlIGluZGV4IikpOwoKCWhvbGRfbG9ja2VkX2luZGV4KCZpbmRleF9sb2NrLCBMT0NLX0RJRV9PTl9FUlJPUik7CglhZGRfcmVtb3ZlX2ZpbGVzKCZwYXJ0aWFsKTsKCXJlZnJlc2hfY2FjaGUoUkVGUkVTSF9RVUlFVCk7Cgl1cGRhdGVfbWFpbl9jYWNoZV90cmVlKFdSSVRFX1RSRUVfU0lMRU5UKTsKCWlmICh3cml0ZV9sb2NrZWRfaW5kZXgoJnRoZV9pbmRleCwgJmluZGV4X2xvY2ssIENMT1NFX0xPQ0spKQoJCWRpZShfKCJ1bmFibGUgdG8gd3JpdGUgbmV3X2luZGV4IGZpbGUiKSk7CgoJaG9sZF9sb2NrX2ZpbGVfZm9yX3VwZGF0ZSgmZmFsc2VfbG9jaywKCQkJCSAgZ2l0X3BhdGgoIm5leHQtaW5kZXgtJSJQUkl1TUFYLAoJCQkJCSAgICh1aW50bWF4X3QpIGdldHBpZCgpKSwKCQkJCSAgTE9DS19ESUVfT05fRVJST1IpOwoKCWNyZWF0ZV9iYXNlX2luZGV4KGN1cnJlbnRfaGVhZCk7CglhZGRfcmVtb3ZlX2ZpbGVzKCZwYXJ0aWFsKTsKCXJlZnJlc2hfY2FjaGUoUkVGUkVTSF9RVUlFVCk7CgoJaWYgKHdyaXRlX2xvY2tlZF9pbmRleCgmdGhlX2luZGV4LCAmZmFsc2VfbG9jaywgQ0xPU0VfTE9DSykpCgkJZGllKF8oInVuYWJsZSB0byB3cml0ZSB0ZW1wb3JhcnkgaW5kZXggZmlsZSIpKTsKCglkaXNjYXJkX2NhY2hlKCk7CglyZXQgPSBnZXRfbG9ja19maWxlX3BhdGgoJmZhbHNlX2xvY2spOwoJcmVhZF9jYWNoZV9mcm9tKHJldCk7CglyZXR1cm4gcmV0Owp9CgpzdGF0aWMgaW50IHJ1bl9zdGF0dXMoRklMRSAqZnAsIGNvbnN0IGNoYXIgKmluZGV4X2ZpbGUsIGNvbnN0IGNoYXIgKnByZWZpeCwgaW50IG5vd2FybiwKCQkgICAgICBzdHJ1Y3Qgd3Rfc3RhdHVzICpzKQp7CglzdHJ1Y3Qgb2JqZWN0X2lkIG9pZDsKCglpZiAocy0+cmVsYXRpdmVfcGF0aHMpCgkJcy0+cHJlZml4ID0gcHJlZml4OwoKCWlmIChhbWVuZCkgewoJCXMtPmFtZW5kID0gMTsKCQlzLT5yZWZlcmVuY2UgPSAiSEVBRF4xIjsKCX0KCXMtPnZlcmJvc2UgPSB2ZXJib3NlOwoJcy0+aW5kZXhfZmlsZSA9IGluZGV4X2ZpbGU7CglzLT5mcCA9IGZwOwoJcy0+bm93YXJuID0gbm93YXJuOwoJcy0+aXNfaW5pdGlhbCA9IGdldF9zaGExKHMtPnJlZmVyZW5jZSwgb2lkLmhhc2gpID8gMSA6IDA7CglpZiAoIXMtPmlzX2luaXRpYWwpCgkJaGFzaGNweShzLT5zaGExX2NvbW1pdCwgb2lkLmhhc2gpOwoJcy0+c3RhdHVzX2Zvcm1hdCA9IHN0YXR1c19mb3JtYXQ7CglzLT5pZ25vcmVfc3VibW9kdWxlX2FyZyA9IGlnbm9yZV9zdWJtb2R1bGVfYXJnOwoKCXd0X3N0YXR1c19jb2xsZWN0KHMpOwoJd3Rfc3RhdHVzX3ByaW50KHMpOwoKCXJldHVybiBzLT5jb21taXRhYmxlOwp9CgpzdGF0aWMgaW50IGlzX2FfbWVyZ2UoY29uc3Qgc3RydWN0IGNvbW1pdCAqY3VycmVudF9oZWFkKQp7CglyZXR1cm4gISEoY3VycmVudF9oZWFkLT5wYXJlbnRzICYmIGN1cnJlbnRfaGVhZC0+cGFyZW50cy0+bmV4dCk7Cn0KCnN0YXRpYyB2b2lkIGFzc2VydF9zcGxpdF9pZGVudChzdHJ1Y3QgaWRlbnRfc3BsaXQgKmlkLCBjb25zdCBzdHJ1Y3Qgc3RyYnVmICpidWYpCnsKCWlmIChzcGxpdF9pZGVudF9saW5lKGlkLCBidWYtPmJ1ZiwgYnVmLT5sZW4pIHx8ICFpZC0+ZGF0ZV9iZWdpbikKCQlkaWUoIkJVRzogdW5hYmxlIHRvIHBhcnNlIG91ciBvd24gaWRlbnQ6ICVzIiwgYnVmLT5idWYpOwp9CgpzdGF0aWMgdm9pZCBleHBvcnRfb25lKGNvbnN0IGNoYXIgKnZhciwgY29uc3QgY2hhciAqcywgY29uc3QgY2hhciAqZSwgaW50IGhhY2spCnsKCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7CglpZiAoaGFjaykKCQlzdHJidWZfYWRkY2goJmJ1ZiwgaGFjayk7CglzdHJidWZfYWRkZigmYnVmLCAiJS4qcyIsIChpbnQpKGUgLSBzKSwgcyk7CglzZXRlbnYodmFyLCBidWYuYnVmLCAxKTsKCXN0cmJ1Zl9yZWxlYXNlKCZidWYpOwp9CgpzdGF0aWMgaW50IHBhcnNlX2ZvcmNlX2RhdGUoY29uc3QgY2hhciAqaW4sIHN0cnVjdCBzdHJidWYgKm91dCkKewoJc3RyYnVmX2FkZGNoKG91dCwgJ0AnKTsKCglpZiAocGFyc2VfZGF0ZShpbiwgb3V0KSA8IDApIHsKCQlpbnQgZXJyb3JzID0gMDsKCQl1bnNpZ25lZCBsb25nIHQgPSBhcHByb3hpZGF0ZV9jYXJlZnVsKGluLCAmZXJyb3JzKTsKCQlpZiAoZXJyb3JzKQoJCQlyZXR1cm4gLTE7CgkJc3RyYnVmX2FkZGYob3V0LCAiJWx1IiwgdCk7Cgl9CgoJcmV0dXJuIDA7Cn0KCnN0YXRpYyB2b2lkIHNldF9pZGVudF92YXIoY2hhciAqKmJ1ZiwgY2hhciAqdmFsKQp7CglmcmVlKCpidWYpOwoJKmJ1ZiA9IHZhbDsKfQoKc3RhdGljIHZvaWQgZGV0ZXJtaW5lX2F1dGhvcl9pbmZvKHN0cnVjdCBzdHJidWYgKmF1dGhvcl9pZGVudCkKewoJY2hhciAqbmFtZSwgKmVtYWlsLCAqZGF0ZTsKCXN0cnVjdCBpZGVudF9zcGxpdCBhdXRob3I7CgoJbmFtZSA9IHhzdHJkdXBfb3JfbnVsbChnZXRlbnYoIkdJVF9BVVRIT1JfTkFNRSIpKTsKCWVtYWlsID0geHN0cmR1cF9vcl9udWxsKGdldGVudigiR0lUX0FVVEhPUl9FTUFJTCIpKTsKCWRhdGUgPSB4c3RyZHVwX29yX251bGwoZ2V0ZW52KCJHSVRfQVVUSE9SX0RBVEUiKSk7CgoJaWYgKGF1dGhvcl9tZXNzYWdlKSB7CgkJc3RydWN0IGlkZW50X3NwbGl0IGlkZW50OwoJCXNpemVfdCBsZW47CgkJY29uc3QgY2hhciAqYTsKCgkJYSA9IGZpbmRfY29tbWl0X2hlYWRlcihhdXRob3JfbWVzc2FnZV9idWZmZXIsICJhdXRob3IiLCAmbGVuKTsKCQlpZiAoIWEpCgkJCWRpZShfKCJjb21taXQgJyVzJyBsYWNrcyBhdXRob3IgaGVhZGVyIiksIGF1dGhvcl9tZXNzYWdlKTsKCQlpZiAoc3BsaXRfaWRlbnRfbGluZSgmaWRlbnQsIGEsIGxlbikgPCAwKQoJCQlkaWUoXygiY29tbWl0ICclcycgaGFzIG1hbGZvcm1lZCBhdXRob3IgbGluZSIpLCBhdXRob3JfbWVzc2FnZSk7CgoJCXNldF9pZGVudF92YXIoJm5hbWUsIHhtZW1kdXB6KGlkZW50Lm5hbWVfYmVnaW4sIGlkZW50Lm5hbWVfZW5kIC0gaWRlbnQubmFtZV9iZWdpbikpOwoJCXNldF9pZGVudF92YXIoJmVtYWlsLCB4bWVtZHVweihpZGVudC5tYWlsX2JlZ2luLCBpZGVudC5tYWlsX2VuZCAtIGlkZW50Lm1haWxfYmVnaW4pKTsKCgkJaWYgKGlkZW50LmRhdGVfYmVnaW4pIHsKCQkJc3RydWN0IHN0cmJ1ZiBkYXRlX2J1ZiA9IFNUUkJVRl9JTklUOwoJCQlzdHJidWZfYWRkY2goJmRhdGVfYnVmLCAnQCcpOwoJCQlzdHJidWZfYWRkKCZkYXRlX2J1ZiwgaWRlbnQuZGF0ZV9iZWdpbiwgaWRlbnQuZGF0ZV9lbmQgLSBpZGVudC5kYXRlX2JlZ2luKTsKCQkJc3RyYnVmX2FkZGNoKCZkYXRlX2J1ZiwgJyAnKTsKCQkJc3RyYnVmX2FkZCgmZGF0ZV9idWYsIGlkZW50LnR6X2JlZ2luLCBpZGVudC50el9lbmQgLSBpZGVudC50el9iZWdpbik7CgkJCXNldF9pZGVudF92YXIoJmRhdGUsIHN0cmJ1Zl9kZXRhY2goJmRhdGVfYnVmLCBOVUxMKSk7CgkJfQoJfQoKCWlmIChmb3JjZV9hdXRob3IpIHsKCQlzdHJ1Y3QgaWRlbnRfc3BsaXQgaWRlbnQ7CgoJCWlmIChzcGxpdF9pZGVudF9saW5lKCZpZGVudCwgZm9yY2VfYXV0aG9yLCBzdHJsZW4oZm9yY2VfYXV0aG9yKSkgPCAwKQoJCQlkaWUoXygibWFsZm9ybWVkIC0tYXV0aG9yIHBhcmFtZXRlciIpKTsKCQlzZXRfaWRlbnRfdmFyKCZuYW1lLCB4bWVtZHVweihpZGVudC5uYW1lX2JlZ2luLCBpZGVudC5uYW1lX2VuZCAtIGlkZW50Lm5hbWVfYmVnaW4pKTsKCQlzZXRfaWRlbnRfdmFyKCZlbWFpbCwgeG1lbWR1cHooaWRlbnQubWFpbF9iZWdpbiwgaWRlbnQubWFpbF9lbmQgLSBpZGVudC5tYWlsX2JlZ2luKSk7Cgl9CgoJaWYgKGZvcmNlX2RhdGUpIHsKCQlzdHJ1Y3Qgc3RyYnVmIGRhdGVfYnVmID0gU1RSQlVGX0lOSVQ7CgkJaWYgKHBhcnNlX2ZvcmNlX2RhdGUoZm9yY2VfZGF0ZSwgJmRhdGVfYnVmKSkKCQkJZGllKF8oImludmFsaWQgZGF0ZSBmb3JtYXQ6ICVzIiksIGZvcmNlX2RhdGUpOwoJCXNldF9pZGVudF92YXIoJmRhdGUsIHN0cmJ1Zl9kZXRhY2goJmRhdGVfYnVmLCBOVUxMKSk7Cgl9CgoJc3RyYnVmX2FkZHN0cihhdXRob3JfaWRlbnQsIGZtdF9pZGVudChuYW1lLCBlbWFpbCwgZGF0ZSwgSURFTlRfU1RSSUNUKSk7Cglhc3NlcnRfc3BsaXRfaWRlbnQoJmF1dGhvciwgYXV0aG9yX2lkZW50KTsKCWV4cG9ydF9vbmUoIkdJVF9BVVRIT1JfTkFNRSIsIGF1dGhvci5uYW1lX2JlZ2luLCBhdXRob3IubmFtZV9lbmQsIDApOwoJZXhwb3J0X29uZSgiR0lUX0FVVEhPUl9FTUFJTCIsIGF1dGhvci5tYWlsX2JlZ2luLCBhdXRob3IubWFpbF9lbmQsIDApOwoJZXhwb3J0X29uZSgiR0lUX0FVVEhPUl9EQVRFIiwgYXV0aG9yLmRhdGVfYmVnaW4sIGF1dGhvci50el9lbmQsICdAJyk7CglmcmVlKG5hbWUpOwoJZnJlZShlbWFpbCk7CglmcmVlKGRhdGUpOwp9CgpzdGF0aWMgaW50IGF1dGhvcl9kYXRlX2lzX2ludGVyZXN0aW5nKHZvaWQpCnsKCXJldHVybiBhdXRob3JfbWVzc2FnZSB8fCBmb3JjZV9kYXRlOwp9CgpzdGF0aWMgdm9pZCBhZGp1c3RfY29tbWVudF9saW5lX2NoYXIoY29uc3Qgc3RydWN0IHN0cmJ1ZiAqc2IpCnsKCWNoYXIgY2FuZGlkYXRlc1tdID0gIiM7QCEkJV4mfDoiOwoJY2hhciAqY2FuZGlkYXRlOwoJY29uc3QgY2hhciAqcDsKCgljb21tZW50X2xpbmVfY2hhciA9IGNhbmRpZGF0ZXNbMF07CglpZiAoIW1lbWNocihzYi0+YnVmLCBjb21tZW50X2xpbmVfY2hhciwgc2ItPmxlbikpCgkJcmV0dXJuOwoKCXAgPSBzYi0+YnVmOwoJY2FuZGlkYXRlID0gc3RyY2hyKGNhbmRpZGF0ZXMsICpwKTsKCWlmIChjYW5kaWRhdGUpCgkJKmNhbmRpZGF0ZSA9ICcgJzsKCWZvciAocCA9IHNiLT5idWY7ICpwOyBwKyspIHsKCQlpZiAoKHBbMF0gPT0gJ1xuJyB8fCBwWzBdID09ICdccicpICYmIHBbMV0pIHsKCQkJY2FuZGlkYXRlID0gc3RyY2hyKGNhbmRpZGF0ZXMsIHBbMV0pOwoJCQlpZiAoY2FuZGlkYXRlKQoJCQkJKmNhbmRpZGF0ZSA9ICcgJzsKCQl9Cgl9CgoJZm9yIChwID0gY2FuZGlkYXRlczsgKnAgPT0gJyAnOyBwKyspCgkJOwoJaWYgKCEqcCkKCQlkaWUoXygidW5hYmxlIHRvIHNlbGVjdCBhIGNvbW1lbnQgY2hhcmFjdGVyIHRoYXQgaXMgbm90IHVzZWRcbiIKCQkgICAgICAiaW4gdGhlIGN1cnJlbnQgY29tbWl0IG1lc3NhZ2UiKSk7Cgljb21tZW50X2xpbmVfY2hhciA9ICpwOwp9CgpzdGF0aWMgaW50IHByZXBhcmVfdG9fY29tbWl0KGNvbnN0IGNoYXIgKmluZGV4X2ZpbGUsIGNvbnN0IGNoYXIgKnByZWZpeCwKCQkJICAgICBzdHJ1Y3QgY29tbWl0ICpjdXJyZW50X2hlYWQsCgkJCSAgICAgc3RydWN0IHd0X3N0YXR1cyAqcywKCQkJICAgICBzdHJ1Y3Qgc3RyYnVmICphdXRob3JfaWRlbnQpCnsKCXN0cnVjdCBzdGF0IHN0YXRidWY7CglzdHJ1Y3Qgc3RyYnVmIGNvbW1pdHRlcl9pZGVudCA9IFNUUkJVRl9JTklUOwoJaW50IGNvbW1pdGFibGU7CglzdHJ1Y3Qgc3RyYnVmIHNiID0gU1RSQlVGX0lOSVQ7Cgljb25zdCBjaGFyICpob29rX2FyZzEgPSBOVUxMOwoJY29uc3QgY2hhciAqaG9va19hcmcyID0gTlVMTDsKCWludCBjbGVhbl9tZXNzYWdlX2NvbnRlbnRzID0gKGNsZWFudXBfbW9kZSAhPSBDTEVBTlVQX05PTkUpOwoJaW50IG9sZF9kaXNwbGF5X2NvbW1lbnRfcHJlZml4OwoKCS8qIFRoaXMgY2hlY2tzIGFuZCBiYXJmcyBpZiBhdXRob3IgaXMgYmFkbHkgc3BlY2lmaWVkICovCglkZXRlcm1pbmVfYXV0aG9yX2luZm8oYXV0aG9yX2lkZW50KTsKCglpZiAoIW5vX3ZlcmlmeSAmJiBydW5fY29tbWl0X2hvb2sodXNlX2VkaXRvciwgaW5kZXhfZmlsZSwgInByZS1jb21taXQiLCBOVUxMKSkKCQlyZXR1cm4gMDsKCglpZiAoc3F1YXNoX21lc3NhZ2UpIHsKCQkvKgoJCSAqIEluc2VydCB0aGUgcHJvcGVyIHN1YmplY3QgbGluZSBiZWZvcmUgb3RoZXIgY29tbWl0CgkJICogbWVzc2FnZSBvcHRpb25zIGFkZCB0aGVpciBjb250ZW50LgoJCSAqLwoJCWlmICh1c2VfbWVzc2FnZSAmJiAhc3RyY21wKHVzZV9tZXNzYWdlLCBzcXVhc2hfbWVzc2FnZSkpCgkJCXN0cmJ1Zl9hZGRzdHIoJnNiLCAic3F1YXNoISAiKTsKCQllbHNlIHsKCQkJc3RydWN0IHByZXR0eV9wcmludF9jb250ZXh0IGN0eCA9IHswfTsKCQkJc3RydWN0IGNvbW1pdCAqYzsKCQkJYyA9IGxvb2t1cF9jb21taXRfcmVmZXJlbmNlX2J5X25hbWUoc3F1YXNoX21lc3NhZ2UpOwoJCQlpZiAoIWMpCgkJCQlkaWUoXygiY291bGQgbm90IGxvb2t1cCBjb21taXQgJXMiKSwgc3F1YXNoX21lc3NhZ2UpOwoJCQljdHgub3V0cHV0X2VuY29kaW5nID0gZ2V0X2NvbW1pdF9vdXRwdXRfZW5jb2RpbmcoKTsKCQkJZm9ybWF0X2NvbW1pdF9tZXNzYWdlKGMsICJzcXVhc2ghICVzXG5cbiIsICZzYiwKCQkJCQkgICAgICAmY3R4KTsKCQl9Cgl9CgoJaWYgKGhhdmVfb3B0aW9uX20pIHsKCQlzdHJidWZfYWRkYnVmKCZzYiwgJm1lc3NhZ2UpOwoJCWhvb2tfYXJnMSA9ICJtZXNzYWdlIjsKCX0gZWxzZSBpZiAobG9nZmlsZSAmJiAhc3RyY21wKGxvZ2ZpbGUsICItIikpIHsKCQlpZiAoaXNhdHR5KDApKQoJCQlmcHJpbnRmKHN0ZGVyciwgXygiKHJlYWRpbmcgbG9nIG1lc3NhZ2UgZnJvbSBzdGFuZGFyZCBpbnB1dClcbiIpKTsKCQlpZiAoc3RyYnVmX3JlYWQoJnNiLCAwLCAwKSA8IDApCgkJCWRpZV9lcnJubyhfKCJjb3VsZCBub3QgcmVhZCBsb2cgZnJvbSBzdGFuZGFyZCBpbnB1dCIpKTsKCQlob29rX2FyZzEgPSAibWVzc2FnZSI7Cgl9IGVsc2UgaWYgKGxvZ2ZpbGUpIHsKCQlpZiAoc3RyYnVmX3JlYWRfZmlsZSgmc2IsIGxvZ2ZpbGUsIDApIDwgMCkKCQkJZGllX2Vycm5vKF8oImNvdWxkIG5vdCByZWFkIGxvZyBmaWxlICclcyciKSwKCQkJCSAgbG9nZmlsZSk7CgkJaG9va19hcmcxID0gIm1lc3NhZ2UiOwoJfSBlbHNlIGlmICh1c2VfbWVzc2FnZSkgewoJCWNoYXIgKmJ1ZmZlcjsKCQlidWZmZXIgPSBzdHJzdHIodXNlX21lc3NhZ2VfYnVmZmVyLCAiXG5cbiIpOwoJCWlmIChidWZmZXIpCgkJCXN0cmJ1Zl9hZGRzdHIoJnNiLCBza2lwX2JsYW5rX2xpbmVzKGJ1ZmZlciArIDIpKTsKCQlob29rX2FyZzEgPSAiY29tbWl0IjsKCQlob29rX2FyZzIgPSB1c2VfbWVzc2FnZTsKCX0gZWxzZSBpZiAoZml4dXBfbWVzc2FnZSkgewoJCXN0cnVjdCBwcmV0dHlfcHJpbnRfY29udGV4dCBjdHggPSB7MH07CgkJc3RydWN0IGNvbW1pdCAqY29tbWl0OwoJCWNvbW1pdCA9IGxvb2t1cF9jb21taXRfcmVmZXJlbmNlX2J5X25hbWUoZml4dXBfbWVzc2FnZSk7CgkJaWYgKCFjb21taXQpCgkJCWRpZShfKCJjb3VsZCBub3QgbG9va3VwIGNvbW1pdCAlcyIpLCBmaXh1cF9tZXNzYWdlKTsKCQljdHgub3V0cHV0X2VuY29kaW5nID0gZ2V0X2NvbW1pdF9vdXRwdXRfZW5jb2RpbmcoKTsKCQlmb3JtYXRfY29tbWl0X21lc3NhZ2UoY29tbWl0LCAiZml4dXAhICVzXG5cbiIsCgkJCQkgICAgICAmc2IsICZjdHgpOwoJCWhvb2tfYXJnMSA9ICJtZXNzYWdlIjsKCX0gZWxzZSBpZiAoIXN0YXQoZ2l0X3BhdGhfbWVyZ2VfbXNnKCksICZzdGF0YnVmKSkgewoJCS8qCgkJICogcHJlcGVuZCBTUVVBU0hfTVNHIGhlcmUgaWYgaXQgZXhpc3RzIGFuZCBhCgkJICogIm1lcmdlIC0tc3F1YXNoIiB3YXMgb3JpZ2luYWxseSBwZXJmb3JtZWQKCQkgKi8KCQlpZiAoIXN0YXQoZ2l0X3BhdGhfc3F1YXNoX21zZygpLCAmc3RhdGJ1ZikpIHsKCQkJaWYgKHN0cmJ1Zl9yZWFkX2ZpbGUoJnNiLCBnaXRfcGF0aF9zcXVhc2hfbXNnKCksIDApIDwgMCkKCQkJCWRpZV9lcnJubyhfKCJjb3VsZCBub3QgcmVhZCBTUVVBU0hfTVNHIikpOwoJCQlob29rX2FyZzEgPSAic3F1YXNoIjsKCQl9IGVsc2UKCQkJaG9va19hcmcxID0gIm1lcmdlIjsKCQlpZiAoc3RyYnVmX3JlYWRfZmlsZSgmc2IsIGdpdF9wYXRoX21lcmdlX21zZygpLCAwKSA8IDApCgkJCWRpZV9lcnJubyhfKCJjb3VsZCBub3QgcmVhZCBNRVJHRV9NU0ciKSk7Cgl9IGVsc2UgaWYgKCFzdGF0KGdpdF9wYXRoX3NxdWFzaF9tc2coKSwgJnN0YXRidWYpKSB7CgkJaWYgKHN0cmJ1Zl9yZWFkX2ZpbGUoJnNiLCBnaXRfcGF0aF9zcXVhc2hfbXNnKCksIDApIDwgMCkKCQkJZGllX2Vycm5vKF8oImNvdWxkIG5vdCByZWFkIFNRVUFTSF9NU0ciKSk7CgkJaG9va19hcmcxID0gInNxdWFzaCI7Cgl9IGVsc2UgaWYgKHRlbXBsYXRlX2ZpbGUpIHsKCQlpZiAoc3RyYnVmX3JlYWRfZmlsZSgmc2IsIHRlbXBsYXRlX2ZpbGUsIDApIDwgMCkKCQkJZGllX2Vycm5vKF8oImNvdWxkIG5vdCByZWFkICclcyciKSwgdGVtcGxhdGVfZmlsZSk7CgkJaG9va19hcmcxID0gInRlbXBsYXRlIjsKCQljbGVhbl9tZXNzYWdlX2NvbnRlbnRzID0gMDsKCX0KCgkvKgoJICogVGhlIHJlbWFpbmluZyBjYXNlcyBkb24ndCBtb2RpZnkgdGhlIHRlbXBsYXRlIG1lc3NhZ2UsIGJ1dAoJICoganVzdCBzZXQgdGhlIGFyZ3VtZW50KHMpIHRvIHRoZSBwcmVwYXJlLWNvbW1pdC1tc2cgaG9vay4KCSAqLwoJZWxzZSBpZiAod2hlbmNlID09IEZST01fTUVSR0UpCgkJaG9va19hcmcxID0gIm1lcmdlIjsKCWVsc2UgaWYgKHdoZW5jZSA9PSBGUk9NX0NIRVJSWV9QSUNLKSB7CgkJaG9va19hcmcxID0gImNvbW1pdCI7CgkJaG9va19hcmcyID0gIkNIRVJSWV9QSUNLX0hFQUQiOwoJfQoKCWlmIChzcXVhc2hfbWVzc2FnZSkgewoJCS8qCgkJICogSWYgc3F1YXNoX2NvbW1pdCB3YXMgdXNlZCBmb3IgdGhlIGNvbW1pdCBzdWJqZWN0LAoJCSAqIHRoZW4gd2UncmUgcG9zc2libHkgaGlqYWNraW5nIG90aGVyIGNvbW1pdCBsb2cgb3B0aW9ucy4KCQkgKiBSZXNldCB0aGUgaG9vayBhcmdzIHRvIHRlbGwgdGhlIHJlYWwgc3RvcnkuCgkJICovCgkJaG9va19hcmcxID0gIm1lc3NhZ2UiOwoJCWhvb2tfYXJnMiA9ICIiOwoJfQoKCXMtPmZwID0gZm9wZW5fZm9yX3dyaXRpbmcoZ2l0X3BhdGhfY29tbWl0X2VkaXRtc2coKSk7CglpZiAocy0+ZnAgPT0gTlVMTCkKCQlkaWVfZXJybm8oXygiY291bGQgbm90IG9wZW4gJyVzJyIpLCBnaXRfcGF0aF9jb21taXRfZWRpdG1zZygpKTsKCgkvKiBJZ25vcmUgc3RhdHVzLmRpc3BsYXlDb21tZW50UHJlZml4OiB3ZSBkbyBuZWVkIGNvbW1lbnRzIGluIENPTU1JVF9FRElUTVNHLiAqLwoJb2xkX2Rpc3BsYXlfY29tbWVudF9wcmVmaXggPSBzLT5kaXNwbGF5X2NvbW1lbnRfcHJlZml4OwoJcy0+ZGlzcGxheV9jb21tZW50X3ByZWZpeCA9IDE7CgoJLyoKCSAqIE1vc3QgaGludHMgYXJlIGNvdW50ZXItcHJvZHVjdGl2ZSB3aGVuIHRoZSBjb21taXQgaGFzCgkgKiBhbHJlYWR5IHN0YXJ0ZWQuCgkgKi8KCXMtPmhpbnRzID0gMDsKCglpZiAoY2xlYW5fbWVzc2FnZV9jb250ZW50cykKCQlzdHJidWZfc3RyaXBzcGFjZSgmc2IsIDApOwoKCWlmIChzaWdub2ZmKQoJCWFwcGVuZF9zaWdub2ZmKCZzYiwgaWdub3JlX25vbl90cmFpbGVyKHNiLmJ1Ziwgc2IubGVuKSwgMCk7CgoJaWYgKGZ3cml0ZShzYi5idWYsIDEsIHNiLmxlbiwgcy0+ZnApIDwgc2IubGVuKQoJCWRpZV9lcnJubyhfKCJjb3VsZCBub3Qgd3JpdGUgY29tbWl0IHRlbXBsYXRlIikpOwoKCWlmIChhdXRvX2NvbW1lbnRfbGluZV9jaGFyKQoJCWFkanVzdF9jb21tZW50X2xpbmVfY2hhcigmc2IpOwoJc3RyYnVmX3JlbGVhc2UoJnNiKTsKCgkvKiBUaGlzIGNoZWNrcyBpZiBjb21taXR0ZXIgaWRlbnQgaXMgZXhwbGljaXRseSBnaXZlbiAqLwoJc3RyYnVmX2FkZHN0cigmY29tbWl0dGVyX2lkZW50LCBnaXRfY29tbWl0dGVyX2luZm8oSURFTlRfU1RSSUNUKSk7CglpZiAodXNlX2VkaXRvciAmJiBpbmNsdWRlX3N0YXR1cykgewoJCWludCBpZGVudF9zaG93biA9IDA7CgkJaW50IHNhdmVkX2NvbG9yX3NldHRpbmc7CgkJc3RydWN0IGlkZW50X3NwbGl0IGNpLCBhaTsKCgkJaWYgKHdoZW5jZSAhPSBGUk9NX0NPTU1JVCkgewoJCQlpZiAoY2xlYW51cF9tb2RlID09IENMRUFOVVBfU0NJU1NPUlMpCgkJCQl3dF9zdGF0dXNfYWRkX2N1dF9saW5lKHMtPmZwKTsKCQkJc3RhdHVzX3ByaW50Zl9sbihzLCBHSVRfQ09MT1JfTk9STUFMLAoJCQkgICAgd2hlbmNlID09IEZST01fTUVSR0UKCQkJCT8gXygiXG4iCgkJCQkJIkl0IGxvb2tzIGxpa2UgeW91IG1heSBiZSBjb21taXR0aW5nIGEgbWVyZ2UuXG4iCgkJCQkJIklmIHRoaXMgaXMgbm90IGNvcnJlY3QsIHBsZWFzZSByZW1vdmUgdGhlIGZpbGVcbiIKCQkJCQkiCSVzXG4iCgkJCQkJImFuZCB0cnkgYWdhaW4uXG4iKQoJCQkJOiBfKCJcbiIKCQkJCQkiSXQgbG9va3MgbGlrZSB5b3UgbWF5IGJlIGNvbW1pdHRpbmcgYSBjaGVycnktcGljay5cbiIKCQkJCQkiSWYgdGhpcyBpcyBub3QgY29ycmVjdCwgcGxlYXNlIHJlbW92ZSB0aGUgZmlsZVxuIgoJCQkJCSIJJXNcbiIKCQkJCQkiYW5kIHRyeSBhZ2Fpbi5cbiIpLAoJCQkJd2hlbmNlID09IEZST01fTUVSR0UgPwoJCQkJCWdpdF9wYXRoX21lcmdlX2hlYWQoKSA6CgkJCQkJZ2l0X3BhdGhfY2hlcnJ5X3BpY2tfaGVhZCgpKTsKCQl9CgoJCWZwcmludGYocy0+ZnAsICJcbiIpOwoJCWlmIChjbGVhbnVwX21vZGUgPT0gQ0xFQU5VUF9BTEwpCgkJCXN0YXR1c19wcmludGYocywgR0lUX0NPTE9SX05PUk1BTCwKCQkJCV8oIlBsZWFzZSBlbnRlciB0aGUgY29tbWl0IG1lc3NhZ2UgZm9yIHlvdXIgY2hhbmdlcy4iCgkJCQkgICIgTGluZXMgc3RhcnRpbmdcbndpdGggJyVjJyB3aWxsIGJlIGlnbm9yZWQsIGFuZCBhbiBlbXB0eSIKCQkJCSAgIiBtZXNzYWdlIGFib3J0cyB0aGUgY29tbWl0LlxuIiksIGNvbW1lbnRfbGluZV9jaGFyKTsKCQllbHNlIGlmIChjbGVhbnVwX21vZGUgPT0gQ0xFQU5VUF9TQ0lTU09SUyAmJiB3aGVuY2UgPT0gRlJPTV9DT01NSVQpCgkJCXd0X3N0YXR1c19hZGRfY3V0X2xpbmUocy0+ZnApOwoJCWVsc2UgLyogQ0xFQU5VUF9TUEFDRSwgdGhhdCBpcy4gKi8KCQkJc3RhdHVzX3ByaW50ZihzLCBHSVRfQ09MT1JfTk9STUFMLAoJCQkJXygiUGxlYXNlIGVudGVyIHRoZSBjb21taXQgbWVzc2FnZSBmb3IgeW91ciBjaGFuZ2VzLiIKCQkJCSAgIiBMaW5lcyBzdGFydGluZ1xuIgoJCQkJICAid2l0aCAnJWMnIHdpbGwgYmUga2VwdDsgeW91IG1heSByZW1vdmUgdGhlbSIKCQkJCSAgIiB5b3Vyc2VsZiBpZiB5b3Ugd2FudCB0by5cbiIKCQkJCSAgIkFuIGVtcHR5IG1lc3NhZ2UgYWJvcnRzIHRoZSBjb21taXQuXG4iKSwgY29tbWVudF9saW5lX2NoYXIpOwoJCWlmIChvbmx5X2luY2x1ZGVfYXNzdW1lZCkKCQkJc3RhdHVzX3ByaW50Zl9sbihzLCBHSVRfQ09MT1JfTk9STUFMLAoJCQkJCSIlcyIsIG9ubHlfaW5jbHVkZV9hc3N1bWVkKTsKCgkJLyoKCQkgKiBUaGVzZSBzaG91bGQgbmV2ZXIgZmFpbCBiZWNhdXNlIHRoZXkgY29tZSBmcm9tIG91ciBvd24KCQkgKiBmbXRfaWRlbnQuIFRoZXkgbWF5IGZhaWwgdGhlIHNhbmVfaWRlbnQgdGVzdCwgYnV0IHdlIGtub3cKCQkgKiB0aGF0IHRoZSBuYW1lIGFuZCBtYWlsIHBvaW50ZXJzIHdpbGwgYXQgbGVhc3QgYmUgdmFsaWQsCgkJICogd2hpY2ggaXMgZW5vdWdoIGZvciBvdXIgdGVzdHMgYW5kIHByaW50aW5nIGhlcmUuCgkJICovCgkJYXNzZXJ0X3NwbGl0X2lkZW50KCZhaSwgYXV0aG9yX2lkZW50KTsKCQlhc3NlcnRfc3BsaXRfaWRlbnQoJmNpLCAmY29tbWl0dGVyX2lkZW50KTsKCgkJaWYgKGlkZW50X2NtcCgmYWksICZjaSkpCgkJCXN0YXR1c19wcmludGZfbG4ocywgR0lUX0NPTE9SX05PUk1BTCwKCQkJCV8oIiVzIgoJCQkJIkF1dGhvcjogICAgJS4qcyA8JS4qcz4iKSwKCQkJCWlkZW50X3Nob3duKysgPyAiIiA6ICJcbiIsCgkJCQkoaW50KShhaS5uYW1lX2VuZCAtIGFpLm5hbWVfYmVnaW4pLCBhaS5uYW1lX2JlZ2luLAoJCQkJKGludCkoYWkubWFpbF9lbmQgLSBhaS5tYWlsX2JlZ2luKSwgYWkubWFpbF9iZWdpbik7CgoJCWlmIChhdXRob3JfZGF0ZV9pc19pbnRlcmVzdGluZygpKQoJCQlzdGF0dXNfcHJpbnRmX2xuKHMsIEdJVF9DT0xPUl9OT1JNQUwsCgkJCQlfKCIlcyIKCQkJCSJEYXRlOiAgICAgICVzIiksCgkJCQlpZGVudF9zaG93bisrID8gIiIgOiAiXG4iLAoJCQkJc2hvd19pZGVudF9kYXRlKCZhaSwgREFURV9NT0RFKE5PUk1BTCkpKTsKCgkJaWYgKCFjb21taXR0ZXJfaWRlbnRfc3VmZmljaWVudGx5X2dpdmVuKCkpCgkJCXN0YXR1c19wcmludGZfbG4ocywgR0lUX0NPTE9SX05PUk1BTCwKCQkJCV8oIiVzIgoJCQkJIkNvbW1pdHRlcjogJS4qcyA8JS4qcz4iKSwKCQkJCWlkZW50X3Nob3duKysgPyAiIiA6ICJcbiIsCgkJCQkoaW50KShjaS5uYW1lX2VuZCAtIGNpLm5hbWVfYmVnaW4pLCBjaS5uYW1lX2JlZ2luLAoJCQkJKGludCkoY2kubWFpbF9lbmQgLSBjaS5tYWlsX2JlZ2luKSwgY2kubWFpbF9iZWdpbik7CgoJCWlmIChpZGVudF9zaG93bikKCQkJc3RhdHVzX3ByaW50Zl9sbihzLCBHSVRfQ09MT1JfTk9STUFMLCAiJXMiLCAiIik7CgoJCXNhdmVkX2NvbG9yX3NldHRpbmcgPSBzLT51c2VfY29sb3I7CgkJcy0+dXNlX2NvbG9yID0gMDsKCQljb21taXRhYmxlID0gcnVuX3N0YXR1cyhzLT5mcCwgaW5kZXhfZmlsZSwgcHJlZml4LCAxLCBzKTsKCQlzLT51c2VfY29sb3IgPSBzYXZlZF9jb2xvcl9zZXR0aW5nOwoJfSBlbHNlIHsKCQlzdHJ1Y3Qgb2JqZWN0X2lkIG9pZDsKCQljb25zdCBjaGFyICpwYXJlbnQgPSAiSEVBRCI7CgoJCWlmICghYWN0aXZlX25yICYmIHJlYWRfY2FjaGUoKSA8IDApCgkJCWRpZShfKCJDYW5ub3QgcmVhZCBpbmRleCIpKTsKCgkJaWYgKGFtZW5kKQoJCQlwYXJlbnQgPSAiSEVBRF4xIjsKCgkJaWYgKGdldF9zaGExKHBhcmVudCwgb2lkLmhhc2gpKSB7CgkJCWludCBpLCBpdGFfbnIgPSAwOwoKCQkJZm9yIChpID0gMDsgaSA8IGFjdGl2ZV9ucjsgaSsrKQoJCQkJaWYgKGNlX2ludGVudF90b19hZGQoYWN0aXZlX2NhY2hlW2ldKSkKCQkJCQlpdGFfbnIrKzsKCQkJY29tbWl0YWJsZSA9IGFjdGl2ZV9uciAtIGl0YV9uciA+IDA7CgkJfSBlbHNlIHsKCQkJLyoKCQkJICogVW5sZXNzIHRoZSB1c2VyIGRpZCBleHBsaWNpdGx5IHJlcXVlc3QgYSBzdWJtb2R1bGUKCQkJICogaWdub3JlIG1vZGUgYnkgcGFzc2luZyBhIGNvbW1hbmQgbGluZSBvcHRpb24gd2UgZG8KCQkJICogbm90IGlnbm9yZSBhbnkgY2hhbmdlZCBzdWJtb2R1bGUgU0hBLTFzIHdoZW4KCQkJICogY29tcGFyaW5nIGluZGV4IGFuZCBwYXJlbnQsIG5vIG1hdHRlciB3aGF0IGlzCgkJCSAqIGNvbmZpZ3VyZWQuIE90aGVyd2lzZSB3ZSB3b24ndCBjb21taXQgYW55CgkJCSAqIHN1Ym1vZHVsZXMgd2hpY2ggd2VyZSBtYW51YWxseSBzdGFnZWQsIHdoaWNoIHdvdWxkCgkJCSAqIGJlIHJlYWxseSBjb25mdXNpbmcuCgkJCSAqLwoJCQlpbnQgZGlmZl9mbGFncyA9IERJRkZfT1BUX09WRVJSSURFX1NVQk1PRFVMRV9DT05GSUc7CgkJCWlmIChpZ25vcmVfc3VibW9kdWxlX2FyZyAmJgoJCQkgICAgIXN0cmNtcChpZ25vcmVfc3VibW9kdWxlX2FyZywgImFsbCIpKQoJCQkJZGlmZl9mbGFncyB8PSBESUZGX09QVF9JR05PUkVfU1VCTU9EVUxFUzsKCQkJY29tbWl0YWJsZSA9IGluZGV4X2RpZmZlcnNfZnJvbShwYXJlbnQsIGRpZmZfZmxhZ3MsIDEpOwoJCX0KCX0KCXN0cmJ1Zl9yZWxlYXNlKCZjb21taXR0ZXJfaWRlbnQpOwoKCWZjbG9zZShzLT5mcCk7CgoJLyoKCSAqIFJlamVjdCBhbiBhdHRlbXB0IHRvIHJlY29yZCBhIG5vbi1tZXJnZSBlbXB0eSBjb21taXQgd2l0aG91dAoJICogZXhwbGljaXQgLS1hbGxvdy1lbXB0eS4gSW4gdGhlIGNoZXJyeS1waWNrIGNhc2UsIGl0IG1heSBiZQoJICogZW1wdHkgZHVlIHRvIGNvbmZsaWN0IHJlc29sdXRpb24sIHdoaWNoIHRoZSB1c2VyIHNob3VsZCBva2F5LgoJICovCglpZiAoIWNvbW1pdGFibGUgJiYgd2hlbmNlICE9IEZST01fTUVSR0UgJiYgIWFsbG93X2VtcHR5ICYmCgkgICAgIShhbWVuZCAmJiBpc19hX21lcmdlKGN1cnJlbnRfaGVhZCkpKSB7CgkJcy0+ZGlzcGxheV9jb21tZW50X3ByZWZpeCA9IG9sZF9kaXNwbGF5X2NvbW1lbnRfcHJlZml4OwoJCXJ1bl9zdGF0dXMoc3Rkb3V0LCBpbmRleF9maWxlLCBwcmVmaXgsIDAsIHMpOwoJCWlmIChhbWVuZCkKCQkJZnB1dHMoXyhlbXB0eV9hbWVuZF9hZHZpY2UpLCBzdGRlcnIpOwoJCWVsc2UgaWYgKHdoZW5jZSA9PSBGUk9NX0NIRVJSWV9QSUNLKSB7CgkJCWZwdXRzKF8oZW1wdHlfY2hlcnJ5X3BpY2tfYWR2aWNlKSwgc3RkZXJyKTsKCQkJaWYgKCFzZXF1ZW5jZXJfaW5fdXNlKQoJCQkJZnB1dHMoXyhlbXB0eV9jaGVycnlfcGlja19hZHZpY2Vfc2luZ2xlKSwgc3RkZXJyKTsKCQkJZWxzZQoJCQkJZnB1dHMoXyhlbXB0eV9jaGVycnlfcGlja19hZHZpY2VfbXVsdGkpLCBzdGRlcnIpOwoJCX0KCQlyZXR1cm4gMDsKCX0KCgkvKgoJICogUmUtcmVhZCB0aGUgaW5kZXggYXMgcHJlLWNvbW1pdCBob29rIGNvdWxkIGhhdmUgdXBkYXRlZCBpdCwKCSAqIGFuZCB3cml0ZSBpdCBvdXQgYXMgYSB0cmVlLiAgV2UgbXVzdCBkbyB0aGlzIGJlZm9yZSB3ZSBpbnZva2UKCSAqIHRoZSBlZGl0b3IgYW5kIGFmdGVyIHdlIGludm9rZSBydW5fc3RhdHVzIGFib3ZlLgoJICovCglkaXNjYXJkX2NhY2hlKCk7CglyZWFkX2NhY2hlX2Zyb20oaW5kZXhfZmlsZSk7CglpZiAodXBkYXRlX21haW5fY2FjaGVfdHJlZSgwKSkgewoJCWVycm9yKF8oIkVycm9yIGJ1aWxkaW5nIHRyZWVzIikpOwoJCXJldHVybiAwOwoJfQoKCWlmIChydW5fY29tbWl0X2hvb2sodXNlX2VkaXRvciwgaW5kZXhfZmlsZSwgInByZXBhcmUtY29tbWl0LW1zZyIsCgkJCSAgICBnaXRfcGF0aF9jb21taXRfZWRpdG1zZygpLCBob29rX2FyZzEsIGhvb2tfYXJnMiwgTlVMTCkpCgkJcmV0dXJuIDA7CgoJaWYgKHVzZV9lZGl0b3IpIHsKCQlzdHJ1Y3QgYXJndl9hcnJheSBlbnYgPSBBUkdWX0FSUkFZX0lOSVQ7CgoJCWFyZ3ZfYXJyYXlfcHVzaGYoJmVudiwgIkdJVF9JTkRFWF9GSUxFPSVzIiwgaW5kZXhfZmlsZSk7CgkJaWYgKGxhdW5jaF9lZGl0b3IoZ2l0X3BhdGhfY29tbWl0X2VkaXRtc2coKSwgTlVMTCwgZW52LmFyZ3YpKSB7CgkJCWZwcmludGYoc3RkZXJyLAoJCQlfKCJQbGVhc2Ugc3VwcGx5IHRoZSBtZXNzYWdlIHVzaW5nIGVpdGhlciAtbSBvciAtRiBvcHRpb24uXG4iKSk7CgkJCWV4aXQoMSk7CgkJfQoJCWFyZ3ZfYXJyYXlfY2xlYXIoJmVudik7Cgl9CgoJaWYgKCFub192ZXJpZnkgJiYKCSAgICBydW5fY29tbWl0X2hvb2sodXNlX2VkaXRvciwgaW5kZXhfZmlsZSwgImNvbW1pdC1tc2ciLCBnaXRfcGF0aF9jb21taXRfZWRpdG1zZygpLCBOVUxMKSkgewoJCXJldHVybiAwOwoJfQoKCXJldHVybiAxOwp9CgpzdGF0aWMgaW50IHJlc3RfaXNfZW1wdHkoc3RydWN0IHN0cmJ1ZiAqc2IsIGludCBzdGFydCkKewoJaW50IGksIGVvbDsKCWNvbnN0IGNoYXIgKm5sOwoKCS8qIENoZWNrIGlmIHRoZSByZXN0IGlzIGp1c3Qgd2hpdGVzcGFjZSBhbmQgU2lnbmVkLW9mLWJ5J3MuICovCglmb3IgKGkgPSBzdGFydDsgaSA8IHNiLT5sZW47IGkrKykgewoJCW5sID0gbWVtY2hyKHNiLT5idWYgKyBpLCAnXG4nLCBzYi0+bGVuIC0gaSk7CgkJaWYgKG5sKQoJCQllb2wgPSBubCAtIHNiLT5idWY7CgkJZWxzZQoJCQllb2wgPSBzYi0+bGVuOwoKCQlpZiAoc3RybGVuKHNpZ25fb2ZmX2hlYWRlcikgPD0gZW9sIC0gaSAmJgoJCSAgICBzdGFydHNfd2l0aChzYi0+YnVmICsgaSwgc2lnbl9vZmZfaGVhZGVyKSkgewoJCQlpID0gZW9sOwoJCQljb250aW51ZTsKCQl9CgkJd2hpbGUgKGkgPCBlb2wpCgkJCWlmICghaXNzcGFjZShzYi0+YnVmW2krK10pKQoJCQkJcmV0dXJuIDA7Cgl9CgoJcmV0dXJuIDE7Cn0KCi8qCiAqIEZpbmQgb3V0IGlmIHRoZSBtZXNzYWdlIGluIHRoZSBzdHJidWYgY29udGFpbnMgb25seSB3aGl0ZXNwYWNlIGFuZAogKiBTaWduZWQtb2ZmLWJ5IGxpbmVzLgogKi8Kc3RhdGljIGludCBtZXNzYWdlX2lzX2VtcHR5KHN0cnVjdCBzdHJidWYgKnNiKQp7CglpZiAoY2xlYW51cF9tb2RlID09IENMRUFOVVBfTk9ORSAmJiBzYi0+bGVuKQoJCXJldHVybiAwOwoJcmV0dXJuIHJlc3RfaXNfZW1wdHkoc2IsIDApOwp9CgovKgogKiBTZWUgaWYgdGhlIHVzZXIgZWRpdGVkIHRoZSBtZXNzYWdlIGluIHRoZSBlZGl0b3Igb3IgbGVmdCB3aGF0CiAqIHdhcyBpbiB0aGUgdGVtcGxhdGUgaW50YWN0CiAqLwpzdGF0aWMgaW50IHRlbXBsYXRlX3VudG91Y2hlZChzdHJ1Y3Qgc3RyYnVmICpzYikKewoJc3RydWN0IHN0cmJ1ZiB0bXBsID0gU1RSQlVGX0lOSVQ7Cgljb25zdCBjaGFyICpzdGFydDsKCglpZiAoY2xlYW51cF9tb2RlID09IENMRUFOVVBfTk9ORSAmJiBzYi0+bGVuKQoJCXJldHVybiAwOwoKCWlmICghdGVtcGxhdGVfZmlsZSB8fCBzdHJidWZfcmVhZF9maWxlKCZ0bXBsLCB0ZW1wbGF0ZV9maWxlLCAwKSA8PSAwKQoJCXJldHVybiAwOwoKCXN0cmJ1Zl9zdHJpcHNwYWNlKCZ0bXBsLCBjbGVhbnVwX21vZGUgPT0gQ0xFQU5VUF9BTEwpOwoJaWYgKCFza2lwX3ByZWZpeChzYi0+YnVmLCB0bXBsLmJ1ZiwgJnN0YXJ0KSkKCQlzdGFydCA9IHNiLT5idWY7CglzdHJidWZfcmVsZWFzZSgmdG1wbCk7CglyZXR1cm4gcmVzdF9pc19lbXB0eShzYiwgc3RhcnQgLSBzYi0+YnVmKTsKfQoKc3RhdGljIGNvbnN0IGNoYXIgKmZpbmRfYXV0aG9yX2J5X25pY2tuYW1lKGNvbnN0IGNoYXIgKm5hbWUpCnsKCXN0cnVjdCByZXZfaW5mbyByZXZzOwoJc3RydWN0IGNvbW1pdCAqY29tbWl0OwoJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCXN0cnVjdCBzdHJpbmdfbGlzdCBtYWlsbWFwID0gU1RSSU5HX0xJU1RfSU5JVF9OT0RVUDsKCWNvbnN0IGNoYXIgKmF2WzIwXTsKCWludCBhYyA9IDA7CgoJaW5pdF9yZXZpc2lvbnMoJnJldnMsIE5VTEwpOwoJc3RyYnVmX2FkZGYoJmJ1ZiwgIi0tYXV0aG9yPSVzIiwgbmFtZSk7CglhdlsrK2FjXSA9ICItLWFsbCI7CglhdlsrK2FjXSA9ICItaSI7CglhdlsrK2FjXSA9IGJ1Zi5idWY7CglhdlsrK2FjXSA9IE5VTEw7CglzZXR1cF9yZXZpc2lvbnMoYWMsIGF2LCAmcmV2cywgTlVMTCk7CglyZXZzLm1haWxtYXAgPSAmbWFpbG1hcDsKCXJlYWRfbWFpbG1hcChyZXZzLm1haWxtYXAsIE5VTEwpOwoKCWlmIChwcmVwYXJlX3JldmlzaW9uX3dhbGsoJnJldnMpKQoJCWRpZShfKCJyZXZpc2lvbiB3YWxrIHNldHVwIGZhaWxlZCIpKTsKCWNvbW1pdCA9IGdldF9yZXZpc2lvbigmcmV2cyk7CglpZiAoY29tbWl0KSB7CgkJc3RydWN0IHByZXR0eV9wcmludF9jb250ZXh0IGN0eCA9IHswfTsKCQljdHguZGF0ZV9tb2RlLnR5cGUgPSBEQVRFX05PUk1BTDsKCQlzdHJidWZfcmVsZWFzZSgmYnVmKTsKCQlmb3JtYXRfY29tbWl0X21lc3NhZ2UoY29tbWl0LCAiJWFOIDwlYUU+IiwgJmJ1ZiwgJmN0eCk7CgkJY2xlYXJfbWFpbG1hcCgmbWFpbG1hcCk7CgkJcmV0dXJuIHN0cmJ1Zl9kZXRhY2goJmJ1ZiwgTlVMTCk7Cgl9CglkaWUoXygiLS1hdXRob3IgJyVzJyBpcyBub3QgJ05hbWUgPGVtYWlsPicgYW5kIG1hdGNoZXMgbm8gZXhpc3RpbmcgYXV0aG9yIiksIG5hbWUpOwp9CgoKc3RhdGljIHZvaWQgaGFuZGxlX3VudHJhY2tlZF9maWxlc19hcmcoc3RydWN0IHd0X3N0YXR1cyAqcykKewoJaWYgKCF1bnRyYWNrZWRfZmlsZXNfYXJnKQoJCTsgLyogZGVmYXVsdCBhbHJlYWR5IGluaXRpYWxpemVkICovCgllbHNlIGlmICghc3RyY21wKHVudHJhY2tlZF9maWxlc19hcmcsICJubyIpKQoJCXMtPnNob3dfdW50cmFja2VkX2ZpbGVzID0gU0hPV19OT19VTlRSQUNLRURfRklMRVM7CgllbHNlIGlmICghc3RyY21wKHVudHJhY2tlZF9maWxlc19hcmcsICJub3JtYWwiKSkKCQlzLT5zaG93X3VudHJhY2tlZF9maWxlcyA9IFNIT1dfTk9STUFMX1VOVFJBQ0tFRF9GSUxFUzsKCWVsc2UgaWYgKCFzdHJjbXAodW50cmFja2VkX2ZpbGVzX2FyZywgImFsbCIpKQoJCXMtPnNob3dfdW50cmFja2VkX2ZpbGVzID0gU0hPV19BTExfVU5UUkFDS0VEX0ZJTEVTOwoJZWxzZQoJCWRpZShfKCJJbnZhbGlkIHVudHJhY2tlZCBmaWxlcyBtb2RlICclcyciKSwgdW50cmFja2VkX2ZpbGVzX2FyZyk7Cn0KCnN0YXRpYyBjb25zdCBjaGFyICpyZWFkX2NvbW1pdF9tZXNzYWdlKGNvbnN0IGNoYXIgKm5hbWUpCnsKCWNvbnN0IGNoYXIgKm91dF9lbmM7CglzdHJ1Y3QgY29tbWl0ICpjb21taXQ7CgoJY29tbWl0ID0gbG9va3VwX2NvbW1pdF9yZWZlcmVuY2VfYnlfbmFtZShuYW1lKTsKCWlmICghY29tbWl0KQoJCWRpZShfKCJjb3VsZCBub3QgbG9va3VwIGNvbW1pdCAlcyIpLCBuYW1lKTsKCW91dF9lbmMgPSBnZXRfY29tbWl0X291dHB1dF9lbmNvZGluZygpOwoJcmV0dXJuIGxvZ21zZ19yZWVuY29kZShjb21taXQsIE5VTEwsIG91dF9lbmMpOwp9CgovKgogKiBFbnVtZXJhdGUgd2hhdCBuZWVkcyB0byBiZSBwcm9wYWdhdGVkIHdoZW4gLS1wb3JjZWxhaW4KICogaXMgbm90IGluIGVmZmVjdCBoZXJlLgogKi8Kc3RhdGljIHN0cnVjdCBzdGF0dXNfZGVmZXJyZWRfY29uZmlnIHsKCWVudW0gd3Rfc3RhdHVzX2Zvcm1hdCBzdGF0dXNfZm9ybWF0OwoJaW50IHNob3dfYnJhbmNoOwp9IHN0YXR1c19kZWZlcnJlZF9jb25maWcgPSB7CglTVEFUVVNfRk9STUFUX1VOU1BFQ0lGSUVELAoJLTEgLyogdW5zcGVjaWZpZWQgKi8KfTsKCnN0YXRpYyB2b2lkIGZpbmFsaXplX2RlZmVycmVkX2NvbmZpZyhzdHJ1Y3Qgd3Rfc3RhdHVzICpzKQp7CglpbnQgdXNlX2RlZmVycmVkX2NvbmZpZyA9IChzdGF0dXNfZm9ybWF0ICE9IFNUQVRVU19GT1JNQVRfUE9SQ0VMQUlOICYmCgkJCQkgICBzdGF0dXNfZm9ybWF0ICE9IFNUQVRVU19GT1JNQVRfUE9SQ0VMQUlOX1YyICYmCgkJCQkgICAhcy0+bnVsbF90ZXJtaW5hdGlvbik7CgoJaWYgKHMtPm51bGxfdGVybWluYXRpb24pIHsKCQlpZiAoc3RhdHVzX2Zvcm1hdCA9PSBTVEFUVVNfRk9STUFUX05PTkUgfHwKCQkgICAgc3RhdHVzX2Zvcm1hdCA9PSBTVEFUVVNfRk9STUFUX1VOU1BFQ0lGSUVEKQoJCQlzdGF0dXNfZm9ybWF0ID0gU1RBVFVTX0ZPUk1BVF9QT1JDRUxBSU47CgkJZWxzZSBpZiAoc3RhdHVzX2Zvcm1hdCA9PSBTVEFUVVNfRk9STUFUX0xPTkcpCgkJCWRpZShfKCItLWxvbmcgYW5kIC16IGFyZSBpbmNvbXBhdGlibGUiKSk7Cgl9CgoJaWYgKHVzZV9kZWZlcnJlZF9jb25maWcgJiYgc3RhdHVzX2Zvcm1hdCA9PSBTVEFUVVNfRk9STUFUX1VOU1BFQ0lGSUVEKQoJCXN0YXR1c19mb3JtYXQgPSBzdGF0dXNfZGVmZXJyZWRfY29uZmlnLnN0YXR1c19mb3JtYXQ7CglpZiAoc3RhdHVzX2Zvcm1hdCA9PSBTVEFUVVNfRk9STUFUX1VOU1BFQ0lGSUVEKQoJCXN0YXR1c19mb3JtYXQgPSBTVEFUVVNfRk9STUFUX05PTkU7CgoJaWYgKHVzZV9kZWZlcnJlZF9jb25maWcgJiYgcy0+c2hvd19icmFuY2ggPCAwKQoJCXMtPnNob3dfYnJhbmNoID0gc3RhdHVzX2RlZmVycmVkX2NvbmZpZy5zaG93X2JyYW5jaDsKCWlmIChzLT5zaG93X2JyYW5jaCA8IDApCgkJcy0+c2hvd19icmFuY2ggPSAwOwp9CgpzdGF0aWMgaW50IHBhcnNlX2FuZF92YWxpZGF0ZV9vcHRpb25zKGludCBhcmdjLCBjb25zdCBjaGFyICphcmd2W10sCgkJCQkgICAgICBjb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHRpb25zLAoJCQkJICAgICAgY29uc3QgY2hhciAqIGNvbnN0IHVzYWdlW10sCgkJCQkgICAgICBjb25zdCBjaGFyICpwcmVmaXgsCgkJCQkgICAgICBzdHJ1Y3QgY29tbWl0ICpjdXJyZW50X2hlYWQsCgkJCQkgICAgICBzdHJ1Y3Qgd3Rfc3RhdHVzICpzKQp7CglpbnQgZiA9IDA7CgoJYXJnYyA9IHBhcnNlX29wdGlvbnMoYXJnYywgYXJndiwgcHJlZml4LCBvcHRpb25zLCB1c2FnZSwgMCk7CglmaW5hbGl6ZV9kZWZlcnJlZF9jb25maWcocyk7CgoJaWYgKGZvcmNlX2F1dGhvciAmJiAhc3RyY2hyKGZvcmNlX2F1dGhvciwgJz4nKSkKCQlmb3JjZV9hdXRob3IgPSBmaW5kX2F1dGhvcl9ieV9uaWNrbmFtZShmb3JjZV9hdXRob3IpOwoKCWlmIChmb3JjZV9hdXRob3IgJiYgcmVuZXdfYXV0aG9yc2hpcCkKCQlkaWUoXygiVXNpbmcgYm90aCAtLXJlc2V0LWF1dGhvciBhbmQgLS1hdXRob3IgZG9lcyBub3QgbWFrZSBzZW5zZSIpKTsKCglpZiAobG9nZmlsZSB8fCBoYXZlX29wdGlvbl9tIHx8IHVzZV9tZXNzYWdlIHx8IGZpeHVwX21lc3NhZ2UpCgkJdXNlX2VkaXRvciA9IDA7CglpZiAoMCA8PSBlZGl0X2ZsYWcpCgkJdXNlX2VkaXRvciA9IGVkaXRfZmxhZzsKCgkvKiBTYW5pdHkgY2hlY2sgb3B0aW9ucyAqLwoJaWYgKGFtZW5kICYmICFjdXJyZW50X2hlYWQpCgkJZGllKF8oIllvdSBoYXZlIG5vdGhpbmcgdG8gYW1lbmQuIikpOwoJaWYgKGFtZW5kICYmIHdoZW5jZSAhPSBGUk9NX0NPTU1JVCkgewoJCWlmICh3aGVuY2UgPT0gRlJPTV9NRVJHRSkKCQkJZGllKF8oIllvdSBhcmUgaW4gdGhlIG1pZGRsZSBvZiBhIG1lcmdlIC0tIGNhbm5vdCBhbWVuZC4iKSk7CgkJZWxzZSBpZiAod2hlbmNlID09IEZST01fQ0hFUlJZX1BJQ0spCgkJCWRpZShfKCJZb3UgYXJlIGluIHRoZSBtaWRkbGUgb2YgYSBjaGVycnktcGljayAtLSBjYW5ub3QgYW1lbmQuIikpOwoJfQoJaWYgKGZpeHVwX21lc3NhZ2UgJiYgc3F1YXNoX21lc3NhZ2UpCgkJZGllKF8oIk9wdGlvbnMgLS1zcXVhc2ggYW5kIC0tZml4dXAgY2Fubm90IGJlIHVzZWQgdG9nZXRoZXIiKSk7CglpZiAodXNlX21lc3NhZ2UpCgkJZisrOwoJaWYgKGVkaXRfbWVzc2FnZSkKCQlmKys7CglpZiAoZml4dXBfbWVzc2FnZSkKCQlmKys7CglpZiAobG9nZmlsZSkKCQlmKys7CglpZiAoZiA+IDEpCgkJZGllKF8oIk9ubHkgb25lIG9mIC1jLy1DLy1GLy0tZml4dXAgY2FuIGJlIHVzZWQuIikpOwoJaWYgKGhhdmVfb3B0aW9uX20gJiYgZiA+IDApCgkJZGllKChfKCJPcHRpb24gLW0gY2Fubm90IGJlIGNvbWJpbmVkIHdpdGggLWMvLUMvLUYvLS1maXh1cC4iKSkpOwoJaWYgKGYgfHwgaGF2ZV9vcHRpb25fbSkKCQl0ZW1wbGF0ZV9maWxlID0gTlVMTDsKCWlmIChlZGl0X21lc3NhZ2UpCgkJdXNlX21lc3NhZ2UgPSBlZGl0X21lc3NhZ2U7CglpZiAoYW1lbmQgJiYgIXVzZV9tZXNzYWdlICYmICFmaXh1cF9tZXNzYWdlKQoJCXVzZV9tZXNzYWdlID0gIkhFQUQiOwoJaWYgKCF1c2VfbWVzc2FnZSAmJiB3aGVuY2UgIT0gRlJPTV9DSEVSUllfUElDSyAmJiByZW5ld19hdXRob3JzaGlwKQoJCWRpZShfKCItLXJlc2V0LWF1dGhvciBjYW4gYmUgdXNlZCBvbmx5IHdpdGggLUMsIC1jIG9yIC0tYW1lbmQuIikpOwoJaWYgKHVzZV9tZXNzYWdlKSB7CgkJdXNlX21lc3NhZ2VfYnVmZmVyID0gcmVhZF9jb21taXRfbWVzc2FnZSh1c2VfbWVzc2FnZSk7CgkJaWYgKCFyZW5ld19hdXRob3JzaGlwKSB7CgkJCWF1dGhvcl9tZXNzYWdlID0gdXNlX21lc3NhZ2U7CgkJCWF1dGhvcl9tZXNzYWdlX2J1ZmZlciA9IHVzZV9tZXNzYWdlX2J1ZmZlcjsKCQl9Cgl9CglpZiAod2hlbmNlID09IEZST01fQ0hFUlJZX1BJQ0sgJiYgIXJlbmV3X2F1dGhvcnNoaXApIHsKCQlhdXRob3JfbWVzc2FnZSA9ICJDSEVSUllfUElDS19IRUFEIjsKCQlhdXRob3JfbWVzc2FnZV9idWZmZXIgPSByZWFkX2NvbW1pdF9tZXNzYWdlKGF1dGhvcl9tZXNzYWdlKTsKCX0KCglpZiAocGF0Y2hfaW50ZXJhY3RpdmUpCgkJaW50ZXJhY3RpdmUgPSAxOwoKCWlmIChhbHNvICsgb25seSArIGFsbCArIGludGVyYWN0aXZlID4gMSkKCQlkaWUoXygiT25seSBvbmUgb2YgLS1pbmNsdWRlLy0tb25seS8tLWFsbC8tLWludGVyYWN0aXZlLy0tcGF0Y2ggY2FuIGJlIHVzZWQuIikpOwoJaWYgKGFyZ2MgPT0gMCAmJiAoYWxzbyB8fCAob25seSAmJiAhYW1lbmQgJiYgIWFsbG93X2VtcHR5KSkpCgkJZGllKF8oIk5vIHBhdGhzIHdpdGggLS1pbmNsdWRlLy0tb25seSBkb2VzIG5vdCBtYWtlIHNlbnNlLiIpKTsKCWlmIChhcmdjID4gMCAmJiAhYWxzbyAmJiAhb25seSkKCQlvbmx5X2luY2x1ZGVfYXNzdW1lZCA9IF8oIkV4cGxpY2l0IHBhdGhzIHNwZWNpZmllZCB3aXRob3V0IC1pIG9yIC1vOyBhc3N1bWluZyAtLW9ubHkgcGF0aHMuLi4iKTsKCWlmICghY2xlYW51cF9hcmcgfHwgIXN0cmNtcChjbGVhbnVwX2FyZywgImRlZmF1bHQiKSkKCQljbGVhbnVwX21vZGUgPSB1c2VfZWRpdG9yID8gQ0xFQU5VUF9BTEwgOiBDTEVBTlVQX1NQQUNFOwoJZWxzZSBpZiAoIXN0cmNtcChjbGVhbnVwX2FyZywgInZlcmJhdGltIikpCgkJY2xlYW51cF9tb2RlID0gQ0xFQU5VUF9OT05FOwoJZWxzZSBpZiAoIXN0cmNtcChjbGVhbnVwX2FyZywgIndoaXRlc3BhY2UiKSkKCQljbGVhbnVwX21vZGUgPSBDTEVBTlVQX1NQQUNFOwoJZWxzZSBpZiAoIXN0cmNtcChjbGVhbnVwX2FyZywgInN0cmlwIikpCgkJY2xlYW51cF9tb2RlID0gQ0xFQU5VUF9BTEw7CgllbHNlIGlmICghc3RyY21wKGNsZWFudXBfYXJnLCAic2Npc3NvcnMiKSkKCQljbGVhbnVwX21vZGUgPSB1c2VfZWRpdG9yID8gQ0xFQU5VUF9TQ0lTU09SUyA6IENMRUFOVVBfU1BBQ0U7CgllbHNlCgkJZGllKF8oIkludmFsaWQgY2xlYW51cCBtb2RlICVzIiksIGNsZWFudXBfYXJnKTsKCgloYW5kbGVfdW50cmFja2VkX2ZpbGVzX2FyZyhzKTsKCglpZiAoYWxsICYmIGFyZ2MgPiAwKQoJCWRpZShfKCJQYXRocyB3aXRoIC1hIGRvZXMgbm90IG1ha2Ugc2Vuc2UuIikpOwoKCWlmIChzdGF0dXNfZm9ybWF0ICE9IFNUQVRVU19GT1JNQVRfTk9ORSkKCQlkcnlfcnVuID0gMTsKCglyZXR1cm4gYXJnYzsKfQoKc3RhdGljIGludCBkcnlfcnVuX2NvbW1pdChpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsIGNvbnN0IGNoYXIgKnByZWZpeCwKCQkJICBjb25zdCBzdHJ1Y3QgY29tbWl0ICpjdXJyZW50X2hlYWQsIHN0cnVjdCB3dF9zdGF0dXMgKnMpCnsKCWludCBjb21taXRhYmxlOwoJY29uc3QgY2hhciAqaW5kZXhfZmlsZTsKCglpbmRleF9maWxlID0gcHJlcGFyZV9pbmRleChhcmdjLCBhcmd2LCBwcmVmaXgsIGN1cnJlbnRfaGVhZCwgMSk7Cgljb21taXRhYmxlID0gcnVuX3N0YXR1cyhzdGRvdXQsIGluZGV4X2ZpbGUsIHByZWZpeCwgMCwgcyk7Cglyb2xsYmFja19pbmRleF9maWxlcygpOwoKCXJldHVybiBjb21taXRhYmxlID8gMCA6IDE7Cn0KCnN0YXRpYyBpbnQgcGFyc2Vfc3RhdHVzX3Nsb3QoY29uc3QgY2hhciAqc2xvdCkKewoJaWYgKCFzdHJjYXNlY21wKHNsb3QsICJoZWFkZXIiKSkKCQlyZXR1cm4gV1RfU1RBVFVTX0hFQURFUjsKCWlmICghc3RyY2FzZWNtcChzbG90LCAiYnJhbmNoIikpCgkJcmV0dXJuIFdUX1NUQVRVU19PTkJSQU5DSDsKCWlmICghc3RyY2FzZWNtcChzbG90LCAidXBkYXRlZCIpIHx8ICFzdHJjYXNlY21wKHNsb3QsICJhZGRlZCIpKQoJCXJldHVybiBXVF9TVEFUVVNfVVBEQVRFRDsKCWlmICghc3RyY2FzZWNtcChzbG90LCAiY2hhbmdlZCIpKQoJCXJldHVybiBXVF9TVEFUVVNfQ0hBTkdFRDsKCWlmICghc3RyY2FzZWNtcChzbG90LCAidW50cmFja2VkIikpCgkJcmV0dXJuIFdUX1NUQVRVU19VTlRSQUNLRUQ7CglpZiAoIXN0cmNhc2VjbXAoc2xvdCwgIm5vYnJhbmNoIikpCgkJcmV0dXJuIFdUX1NUQVRVU19OT0JSQU5DSDsKCWlmICghc3RyY2FzZWNtcChzbG90LCAidW5tZXJnZWQiKSkKCQlyZXR1cm4gV1RfU1RBVFVTX1VOTUVSR0VEOwoJaWYgKCFzdHJjYXNlY21wKHNsb3QsICJsb2NhbEJyYW5jaCIpKQoJCXJldHVybiBXVF9TVEFUVVNfTE9DQUxfQlJBTkNIOwoJaWYgKCFzdHJjYXNlY21wKHNsb3QsICJyZW1vdGVCcmFuY2giKSkKCQlyZXR1cm4gV1RfU1RBVFVTX1JFTU9URV9CUkFOQ0g7CglyZXR1cm4gLTE7Cn0KCnN0YXRpYyBpbnQgZ2l0X3N0YXR1c19jb25maWcoY29uc3QgY2hhciAqaywgY29uc3QgY2hhciAqdiwgdm9pZCAqY2IpCnsKCXN0cnVjdCB3dF9zdGF0dXMgKnMgPSBjYjsKCWNvbnN0IGNoYXIgKnNsb3RfbmFtZTsKCglpZiAoc3RhcnRzX3dpdGgoaywgImNvbHVtbi4iKSkKCQlyZXR1cm4gZ2l0X2NvbHVtbl9jb25maWcoaywgdiwgInN0YXR1cyIsICZzLT5jb2xvcHRzKTsKCWlmICghc3RyY21wKGssICJzdGF0dXMuc3VibW9kdWxlc3VtbWFyeSIpKSB7CgkJaW50IGlzX2Jvb2w7CgkJcy0+c3VibW9kdWxlX3N1bW1hcnkgPSBnaXRfY29uZmlnX2Jvb2xfb3JfaW50KGssIHYsICZpc19ib29sKTsKCQlpZiAoaXNfYm9vbCAmJiBzLT5zdWJtb2R1bGVfc3VtbWFyeSkKCQkJcy0+c3VibW9kdWxlX3N1bW1hcnkgPSAtMTsKCQlyZXR1cm4gMDsKCX0KCWlmICghc3RyY21wKGssICJzdGF0dXMuc2hvcnQiKSkgewoJCWlmIChnaXRfY29uZmlnX2Jvb2woaywgdikpCgkJCXN0YXR1c19kZWZlcnJlZF9jb25maWcuc3RhdHVzX2Zvcm1hdCA9IFNUQVRVU19GT1JNQVRfU0hPUlQ7CgkJZWxzZQoJCQlzdGF0dXNfZGVmZXJyZWRfY29uZmlnLnN0YXR1c19mb3JtYXQgPSBTVEFUVVNfRk9STUFUX05PTkU7CgkJcmV0dXJuIDA7Cgl9CglpZiAoIXN0cmNtcChrLCAic3RhdHVzLmJyYW5jaCIpKSB7CgkJc3RhdHVzX2RlZmVycmVkX2NvbmZpZy5zaG93X2JyYW5jaCA9IGdpdF9jb25maWdfYm9vbChrLCB2KTsKCQlyZXR1cm4gMDsKCX0KCWlmICghc3RyY21wKGssICJzdGF0dXMuc2hvd3N0YXNoIikpIHsKCQlzLT5zaG93X3N0YXNoID0gZ2l0X2NvbmZpZ19ib29sKGssIHYpOwoJCXJldHVybiAwOwoJfQoJaWYgKCFzdHJjbXAoaywgInN0YXR1cy5jb2xvciIpIHx8ICFzdHJjbXAoaywgImNvbG9yLnN0YXR1cyIpKSB7CgkJcy0+dXNlX2NvbG9yID0gZ2l0X2NvbmZpZ19jb2xvcmJvb2woaywgdik7CgkJcmV0dXJuIDA7Cgl9CglpZiAoIXN0cmNtcChrLCAic3RhdHVzLmRpc3BsYXljb21tZW50cHJlZml4IikpIHsKCQlzLT5kaXNwbGF5X2NvbW1lbnRfcHJlZml4ID0gZ2l0X2NvbmZpZ19ib29sKGssIHYpOwoJCXJldHVybiAwOwoJfQoJaWYgKHNraXBfcHJlZml4KGssICJzdGF0dXMuY29sb3IuIiwgJnNsb3RfbmFtZSkgfHwKCSAgICBza2lwX3ByZWZpeChrLCAiY29sb3Iuc3RhdHVzLiIsICZzbG90X25hbWUpKSB7CgkJaW50IHNsb3QgPSBwYXJzZV9zdGF0dXNfc2xvdChzbG90X25hbWUpOwoJCWlmIChzbG90IDwgMCkKCQkJcmV0dXJuIDA7CgkJaWYgKCF2KQoJCQlyZXR1cm4gY29uZmlnX2Vycm9yX25vbmJvb2woayk7CgkJcmV0dXJuIGNvbG9yX3BhcnNlKHYsIHMtPmNvbG9yX3BhbGV0dGVbc2xvdF0pOwoJfQoJaWYgKCFzdHJjbXAoaywgInN0YXR1cy5yZWxhdGl2ZXBhdGhzIikpIHsKCQlzLT5yZWxhdGl2ZV9wYXRocyA9IGdpdF9jb25maWdfYm9vbChrLCB2KTsKCQlyZXR1cm4gMDsKCX0KCWlmICghc3RyY21wKGssICJzdGF0dXMuc2hvd3VudHJhY2tlZGZpbGVzIikpIHsKCQlpZiAoIXYpCgkJCXJldHVybiBjb25maWdfZXJyb3Jfbm9uYm9vbChrKTsKCQllbHNlIGlmICghc3RyY21wKHYsICJubyIpKQoJCQlzLT5zaG93X3VudHJhY2tlZF9maWxlcyA9IFNIT1dfTk9fVU5UUkFDS0VEX0ZJTEVTOwoJCWVsc2UgaWYgKCFzdHJjbXAodiwgIm5vcm1hbCIpKQoJCQlzLT5zaG93X3VudHJhY2tlZF9maWxlcyA9IFNIT1dfTk9STUFMX1VOVFJBQ0tFRF9GSUxFUzsKCQllbHNlIGlmICghc3RyY21wKHYsICJhbGwiKSkKCQkJcy0+c2hvd191bnRyYWNrZWRfZmlsZXMgPSBTSE9XX0FMTF9VTlRSQUNLRURfRklMRVM7CgkJZWxzZQoJCQlyZXR1cm4gZXJyb3IoXygiSW52YWxpZCB1bnRyYWNrZWQgZmlsZXMgbW9kZSAnJXMnIiksIHYpOwoJCXJldHVybiAwOwoJfQoJcmV0dXJuIGdpdF9kaWZmX3VpX2NvbmZpZyhrLCB2LCBOVUxMKTsKfQoKaW50IGNtZF9zdGF0dXMoaW50IGFyZ2MsIGNvbnN0IGNoYXIgKiphcmd2LCBjb25zdCBjaGFyICpwcmVmaXgpCnsKCXN0YXRpYyBzdHJ1Y3Qgd3Rfc3RhdHVzIHM7CglpbnQgZmQ7CglzdHJ1Y3Qgb2JqZWN0X2lkIG9pZDsKCXN0YXRpYyBzdHJ1Y3Qgb3B0aW9uIGJ1aWx0aW5fc3RhdHVzX29wdGlvbnNbXSA9IHsKCQlPUFRfX1ZFUkJPU0UoJnZlcmJvc2UsIE5fKCJiZSB2ZXJib3NlIikpLAoJCU9QVF9TRVRfSU5UKCdzJywgInNob3J0IiwgJnN0YXR1c19mb3JtYXQsCgkJCSAgICBOXygic2hvdyBzdGF0dXMgY29uY2lzZWx5IiksIFNUQVRVU19GT1JNQVRfU0hPUlQpLAoJCU9QVF9CT09MKCdiJywgImJyYW5jaCIsICZzLnNob3dfYnJhbmNoLAoJCQkgTl8oInNob3cgYnJhbmNoIGluZm9ybWF0aW9uIikpLAoJCU9QVF9CT09MKDAsICJzaG93LXN0YXNoIiwgJnMuc2hvd19zdGFzaCwKCQkJIE5fKCJzaG93IHN0YXNoIGluZm9ybWF0aW9uIikpLAoJCXsgT1BUSU9OX0NBTExCQUNLLCAwLCAicG9yY2VsYWluIiwgJnN0YXR1c19mb3JtYXQsCgkJICBOXygidmVyc2lvbiIpLCBOXygibWFjaGluZS1yZWFkYWJsZSBvdXRwdXQiKSwKCQkgIFBBUlNFX09QVF9PUFRBUkcsIG9wdF9wYXJzZV9wb3JjZWxhaW4gfSwKCQlPUFRfU0VUX0lOVCgwLCAibG9uZyIsICZzdGF0dXNfZm9ybWF0LAoJCQkgICAgTl8oInNob3cgc3RhdHVzIGluIGxvbmcgZm9ybWF0IChkZWZhdWx0KSIpLAoJCQkgICAgU1RBVFVTX0ZPUk1BVF9MT05HKSwKCQlPUFRfQk9PTCgneicsICJudWxsIiwgJnMubnVsbF90ZXJtaW5hdGlvbiwKCQkJIE5fKCJ0ZXJtaW5hdGUgZW50cmllcyB3aXRoIE5VTCIpKSwKCQl7IE9QVElPTl9TVFJJTkcsICd1JywgInVudHJhY2tlZC1maWxlcyIsICZ1bnRyYWNrZWRfZmlsZXNfYXJnLAoJCSAgTl8oIm1vZGUiKSwKCQkgIE5fKCJzaG93IHVudHJhY2tlZCBmaWxlcywgb3B0aW9uYWwgbW9kZXM6IGFsbCwgbm9ybWFsLCBuby4gKERlZmF1bHQ6IGFsbCkiKSwKCQkgIFBBUlNFX09QVF9PUFRBUkcsIE5VTEwsIChpbnRwdHJfdCkiYWxsIiB9LAoJCU9QVF9CT09MKDAsICJpZ25vcmVkIiwgJnNob3dfaWdub3JlZF9pbl9zdGF0dXMsCgkJCSBOXygic2hvdyBpZ25vcmVkIGZpbGVzIikpLAoJCXsgT1BUSU9OX1NUUklORywgMCwgImlnbm9yZS1zdWJtb2R1bGVzIiwgJmlnbm9yZV9zdWJtb2R1bGVfYXJnLCBOXygid2hlbiIpLAoJCSAgTl8oImlnbm9yZSBjaGFuZ2VzIHRvIHN1Ym1vZHVsZXMsIG9wdGlvbmFsIHdoZW46IGFsbCwgZGlydHksIHVudHJhY2tlZC4gKERlZmF1bHQ6IGFsbCkiKSwKCQkgIFBBUlNFX09QVF9PUFRBUkcsIE5VTEwsIChpbnRwdHJfdCkiYWxsIiB9LAoJCU9QVF9DT0xVTU4oMCwgImNvbHVtbiIsICZzLmNvbG9wdHMsIE5fKCJsaXN0IHVudHJhY2tlZCBmaWxlcyBpbiBjb2x1bW5zIikpLAoJCU9QVF9FTkQoKSwKCX07CgoJaWYgKGFyZ2MgPT0gMiAmJiAhc3RyY21wKGFyZ3ZbMV0sICItaCIpKQoJCXVzYWdlX3dpdGhfb3B0aW9ucyhidWlsdGluX3N0YXR1c191c2FnZSwgYnVpbHRpbl9zdGF0dXNfb3B0aW9ucyk7CgoJc3RhdHVzX2luaXRfY29uZmlnKCZzLCBnaXRfc3RhdHVzX2NvbmZpZyk7CglhcmdjID0gcGFyc2Vfb3B0aW9ucyhhcmdjLCBhcmd2LCBwcmVmaXgsCgkJCSAgICAgYnVpbHRpbl9zdGF0dXNfb3B0aW9ucywKCQkJICAgICBidWlsdGluX3N0YXR1c191c2FnZSwgMCk7CglmaW5hbGl6ZV9jb2xvcHRzKCZzLmNvbG9wdHMsIC0xKTsKCWZpbmFsaXplX2RlZmVycmVkX2NvbmZpZygmcyk7CgoJaGFuZGxlX3VudHJhY2tlZF9maWxlc19hcmcoJnMpOwoJaWYgKHNob3dfaWdub3JlZF9pbl9zdGF0dXMpCgkJcy5zaG93X2lnbm9yZWRfZmlsZXMgPSAxOwoJcGFyc2VfcGF0aHNwZWMoJnMucGF0aHNwZWMsIDAsCgkJICAgICAgIFBBVEhTUEVDX1BSRUZFUl9GVUxMLAoJCSAgICAgICBwcmVmaXgsIGFyZ3YpOwoKCXJlYWRfY2FjaGVfcHJlbG9hZCgmcy5wYXRoc3BlYyk7CglyZWZyZXNoX2luZGV4KCZ0aGVfaW5kZXgsIFJFRlJFU0hfUVVJRVR8UkVGUkVTSF9VTk1FUkdFRCwgJnMucGF0aHNwZWMsIE5VTEwsIE5VTEwpOwoKCWZkID0gaG9sZF9sb2NrZWRfaW5kZXgoJmluZGV4X2xvY2ssIDApOwoKCXMuaXNfaW5pdGlhbCA9IGdldF9zaGExKHMucmVmZXJlbmNlLCBvaWQuaGFzaCkgPyAxIDogMDsKCWlmICghcy5pc19pbml0aWFsKQoJCWhhc2hjcHkocy5zaGExX2NvbW1pdCwgb2lkLmhhc2gpOwoKCXMuaWdub3JlX3N1Ym1vZHVsZV9hcmcgPSBpZ25vcmVfc3VibW9kdWxlX2FyZzsKCXMuc3RhdHVzX2Zvcm1hdCA9IHN0YXR1c19mb3JtYXQ7CglzLnZlcmJvc2UgPSB2ZXJib3NlOwoKCXd0X3N0YXR1c19jb2xsZWN0KCZzKTsKCglpZiAoMCA8PSBmZCkKCQl1cGRhdGVfaW5kZXhfaWZfYWJsZSgmdGhlX2luZGV4LCAmaW5kZXhfbG9jayk7CgoJaWYgKHMucmVsYXRpdmVfcGF0aHMpCgkJcy5wcmVmaXggPSBwcmVmaXg7CgoJd3Rfc3RhdHVzX3ByaW50KCZzKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgY29uc3QgY2hhciAqaW1wbGljaXRfaWRlbnRfYWR2aWNlKHZvaWQpCnsKCWNoYXIgKnVzZXJfY29uZmlnID0gZXhwYW5kX3VzZXJfcGF0aCgifi8uZ2l0Y29uZmlnIiwgMCk7CgljaGFyICp4ZGdfY29uZmlnID0geGRnX2NvbmZpZ19ob21lKCJjb25maWciKTsKCWludCBjb25maWdfZXhpc3RzID0gZmlsZV9leGlzdHModXNlcl9jb25maWcpIHx8IGZpbGVfZXhpc3RzKHhkZ19jb25maWcpOwoKCWZyZWUodXNlcl9jb25maWcpOwoJZnJlZSh4ZGdfY29uZmlnKTsKCglpZiAoY29uZmlnX2V4aXN0cykKCQlyZXR1cm4gXyhpbXBsaWNpdF9pZGVudF9hZHZpY2VfY29uZmlnKTsKCWVsc2UKCQlyZXR1cm4gXyhpbXBsaWNpdF9pZGVudF9hZHZpY2Vfbm9jb25maWcpOwoKfQoKc3RhdGljIHZvaWQgcHJpbnRfc3VtbWFyeShjb25zdCBjaGFyICpwcmVmaXgsIGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwKCQkJICBpbnQgaW5pdGlhbF9jb21taXQpCnsKCXN0cnVjdCByZXZfaW5mbyByZXY7CglzdHJ1Y3QgY29tbWl0ICpjb21taXQ7CglzdHJ1Y3Qgc3RyYnVmIGZvcm1hdCA9IFNUUkJVRl9JTklUOwoJc3RydWN0IG9iamVjdF9pZCBqdW5rX29pZDsKCWNvbnN0IGNoYXIgKmhlYWQ7CglzdHJ1Y3QgcHJldHR5X3ByaW50X2NvbnRleHQgcGN0eCA9IHswfTsKCXN0cnVjdCBzdHJidWYgYXV0aG9yX2lkZW50ID0gU1RSQlVGX0lOSVQ7CglzdHJ1Y3Qgc3RyYnVmIGNvbW1pdHRlcl9pZGVudCA9IFNUUkJVRl9JTklUOwoKCWNvbW1pdCA9IGxvb2t1cF9jb21taXQob2lkKTsKCWlmICghY29tbWl0KQoJCWRpZShfKCJjb3VsZG4ndCBsb29rIHVwIG5ld2x5IGNyZWF0ZWQgY29tbWl0IikpOwoJaWYgKHBhcnNlX2NvbW1pdChjb21taXQpKQoJCWRpZShfKCJjb3VsZCBub3QgcGFyc2UgbmV3bHkgY3JlYXRlZCBjb21taXQiKSk7CgoJc3RyYnVmX2FkZHN0cigmZm9ybWF0LCAiZm9ybWF0OiVoXSAlcyIpOwoKCWZvcm1hdF9jb21taXRfbWVzc2FnZShjb21taXQsICIlYW4gPCVhZT4iLCAmYXV0aG9yX2lkZW50LCAmcGN0eCk7Cglmb3JtYXRfY29tbWl0X21lc3NhZ2UoY29tbWl0LCAiJWNuIDwlY2U+IiwgJmNvbW1pdHRlcl9pZGVudCwgJnBjdHgpOwoJaWYgKHN0cmJ1Zl9jbXAoJmF1dGhvcl9pZGVudCwgJmNvbW1pdHRlcl9pZGVudCkpIHsKCQlzdHJidWZfYWRkc3RyKCZmb3JtYXQsICJcbiBBdXRob3I6ICIpOwoJCXN0cmJ1Zl9hZGRidWZfcGVyY2VudHF1b3RlKCZmb3JtYXQsICZhdXRob3JfaWRlbnQpOwoJfQoJaWYgKGF1dGhvcl9kYXRlX2lzX2ludGVyZXN0aW5nKCkpIHsKCQlzdHJ1Y3Qgc3RyYnVmIGRhdGUgPSBTVFJCVUZfSU5JVDsKCQlmb3JtYXRfY29tbWl0X21lc3NhZ2UoY29tbWl0LCAiJWFkIiwgJmRhdGUsICZwY3R4KTsKCQlzdHJidWZfYWRkc3RyKCZmb3JtYXQsICJcbiBEYXRlOiAiKTsKCQlzdHJidWZfYWRkYnVmX3BlcmNlbnRxdW90ZSgmZm9ybWF0LCAmZGF0ZSk7CgkJc3RyYnVmX3JlbGVhc2UoJmRhdGUpOwoJfQoJaWYgKCFjb21taXR0ZXJfaWRlbnRfc3VmZmljaWVudGx5X2dpdmVuKCkpIHsKCQlzdHJidWZfYWRkc3RyKCZmb3JtYXQsICJcbiBDb21taXR0ZXI6ICIpOwoJCXN0cmJ1Zl9hZGRidWZfcGVyY2VudHF1b3RlKCZmb3JtYXQsICZjb21taXR0ZXJfaWRlbnQpOwoJCWlmIChhZHZpY2VfaW1wbGljaXRfaWRlbnRpdHkpIHsKCQkJc3RyYnVmX2FkZGNoKCZmb3JtYXQsICdcbicpOwoJCQlzdHJidWZfYWRkc3RyKCZmb3JtYXQsIGltcGxpY2l0X2lkZW50X2FkdmljZSgpKTsKCQl9Cgl9CglzdHJidWZfcmVsZWFzZSgmYXV0aG9yX2lkZW50KTsKCXN0cmJ1Zl9yZWxlYXNlKCZjb21taXR0ZXJfaWRlbnQpOwoKCWluaXRfcmV2aXNpb25zKCZyZXYsIHByZWZpeCk7CglzZXR1cF9yZXZpc2lvbnMoMCwgTlVMTCwgJnJldiwgTlVMTCk7CgoJcmV2LmRpZmYgPSAxOwoJcmV2LmRpZmZvcHQub3V0cHV0X2Zvcm1hdCA9CgkJRElGRl9GT1JNQVRfU0hPUlRTVEFUIHwgRElGRl9GT1JNQVRfU1VNTUFSWTsKCglyZXYudmVyYm9zZV9oZWFkZXIgPSAxOwoJcmV2LnNob3dfcm9vdF9kaWZmID0gMTsKCWdldF9jb21taXRfZm9ybWF0KGZvcm1hdC5idWYsICZyZXYpOwoJcmV2LmFsd2F5c19zaG93X2hlYWRlciA9IDA7CglyZXYuZGlmZm9wdC5kZXRlY3RfcmVuYW1lID0gMTsKCXJldi5kaWZmb3B0LmJyZWFrX29wdCA9IDA7CglkaWZmX3NldHVwX2RvbmUoJnJldi5kaWZmb3B0KTsKCgloZWFkID0gcmVzb2x2ZV9yZWZfdW5zYWZlKCJIRUFEIiwgMCwganVua19vaWQuaGFzaCwgTlVMTCk7CglpZiAoIXN0cmNtcChoZWFkLCAiSEVBRCIpKQoJCWhlYWQgPSBfKCJkZXRhY2hlZCBIRUFEIik7CgllbHNlCgkJc2tpcF9wcmVmaXgoaGVhZCwgInJlZnMvaGVhZHMvIiwgJmhlYWQpOwoJcHJpbnRmKCJbJXMlcyAiLCBoZWFkLCBpbml0aWFsX2NvbW1pdCA/IF8oIiAocm9vdC1jb21taXQpIikgOiAiIik7CgoJaWYgKCFsb2dfdHJlZV9jb21taXQoJnJldiwgY29tbWl0KSkgewoJCXJldi5hbHdheXNfc2hvd19oZWFkZXIgPSAxOwoJCXJldi51c2VfdGVybWluYXRvciA9IDE7CgkJbG9nX3RyZWVfY29tbWl0KCZyZXYsIGNvbW1pdCk7Cgl9CgoJc3RyYnVmX3JlbGVhc2UoJmZvcm1hdCk7Cn0KCnN0YXRpYyBpbnQgZ2l0X2NvbW1pdF9jb25maWcoY29uc3QgY2hhciAqaywgY29uc3QgY2hhciAqdiwgdm9pZCAqY2IpCnsKCXN0cnVjdCB3dF9zdGF0dXMgKnMgPSBjYjsKCWludCBzdGF0dXM7CgoJaWYgKCFzdHJjbXAoaywgImNvbW1pdC50ZW1wbGF0ZSIpKQoJCXJldHVybiBnaXRfY29uZmlnX3BhdGhuYW1lKCZ0ZW1wbGF0ZV9maWxlLCBrLCB2KTsKCWlmICghc3RyY21wKGssICJjb21taXQuc3RhdHVzIikpIHsKCQlpbmNsdWRlX3N0YXR1cyA9IGdpdF9jb25maWdfYm9vbChrLCB2KTsKCQlyZXR1cm4gMDsKCX0KCWlmICghc3RyY21wKGssICJjb21taXQuY2xlYW51cCIpKQoJCXJldHVybiBnaXRfY29uZmlnX3N0cmluZygmY2xlYW51cF9hcmcsIGssIHYpOwoJaWYgKCFzdHJjbXAoaywgImNvbW1pdC5ncGdzaWduIikpIHsKCQlzaWduX2NvbW1pdCA9IGdpdF9jb25maWdfYm9vbChrLCB2KSA/ICIiIDogTlVMTDsKCQlyZXR1cm4gMDsKCX0KCWlmICghc3RyY21wKGssICJjb21taXQudmVyYm9zZSIpKSB7CgkJaW50IGlzX2Jvb2w7CgkJY29uZmlnX2NvbW1pdF92ZXJib3NlID0gZ2l0X2NvbmZpZ19ib29sX29yX2ludChrLCB2LCAmaXNfYm9vbCk7CgkJcmV0dXJuIDA7Cgl9CgoJc3RhdHVzID0gZ2l0X2dwZ19jb25maWcoaywgdiwgTlVMTCk7CglpZiAoc3RhdHVzKQoJCXJldHVybiBzdGF0dXM7CglyZXR1cm4gZ2l0X3N0YXR1c19jb25maWcoaywgdiwgcyk7Cn0KCnN0YXRpYyBpbnQgcnVuX3Jld3JpdGVfaG9vayhjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvbGRvaWQsCgkJCSAgICBjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpuZXdvaWQpCnsKCXN0cnVjdCBjaGlsZF9wcm9jZXNzIHByb2MgPSBDSElMRF9QUk9DRVNTX0lOSVQ7Cgljb25zdCBjaGFyICphcmd2WzNdOwoJaW50IGNvZGU7CglzdHJ1Y3Qgc3RyYnVmIHNiID0gU1RSQlVGX0lOSVQ7CgoJYXJndlswXSA9IGZpbmRfaG9vaygicG9zdC1yZXdyaXRlIik7CglpZiAoIWFyZ3ZbMF0pCgkJcmV0dXJuIDA7CgoJYXJndlsxXSA9ICJhbWVuZCI7Cglhcmd2WzJdID0gTlVMTDsKCglwcm9jLmFyZ3YgPSBhcmd2OwoJcHJvYy5pbiA9IC0xOwoJcHJvYy5zdGRvdXRfdG9fc3RkZXJyID0gMTsKCgljb2RlID0gc3RhcnRfY29tbWFuZCgmcHJvYyk7CglpZiAoY29kZSkKCQlyZXR1cm4gY29kZTsKCXN0cmJ1Zl9hZGRmKCZzYiwgIiVzICVzXG4iLCBvaWRfdG9faGV4KG9sZG9pZCksIG9pZF90b19oZXgobmV3b2lkKSk7CglzaWdjaGFpbl9wdXNoKFNJR1BJUEUsIFNJR19JR04pOwoJd3JpdGVfaW5fZnVsbChwcm9jLmluLCBzYi5idWYsIHNiLmxlbik7CgljbG9zZShwcm9jLmluKTsKCXN0cmJ1Zl9yZWxlYXNlKCZzYik7CglzaWdjaGFpbl9wb3AoU0lHUElQRSk7CglyZXR1cm4gZmluaXNoX2NvbW1hbmQoJnByb2MpOwp9CgppbnQgcnVuX2NvbW1pdF9ob29rKGludCBlZGl0b3JfaXNfdXNlZCwgY29uc3QgY2hhciAqaW5kZXhfZmlsZSwgY29uc3QgY2hhciAqbmFtZSwgLi4uKQp7CglzdHJ1Y3QgYXJndl9hcnJheSBob29rX2VudiA9IEFSR1ZfQVJSQVlfSU5JVDsKCXZhX2xpc3QgYXJnczsKCWludCByZXQ7CgoJYXJndl9hcnJheV9wdXNoZigmaG9va19lbnYsICJHSVRfSU5ERVhfRklMRT0lcyIsIGluZGV4X2ZpbGUpOwoKCS8qCgkgKiBMZXQgdGhlIGhvb2sga25vdyB0aGF0IG5vIGVkaXRvciB3aWxsIGJlIGxhdW5jaGVkLgoJICovCglpZiAoIWVkaXRvcl9pc191c2VkKQoJCWFyZ3ZfYXJyYXlfcHVzaCgmaG9va19lbnYsICJHSVRfRURJVE9SPToiKTsKCgl2YV9zdGFydChhcmdzLCBuYW1lKTsKCXJldCA9IHJ1bl9ob29rX3ZlKGhvb2tfZW52LmFyZ3YsbmFtZSwgYXJncyk7Cgl2YV9lbmQoYXJncyk7Cglhcmd2X2FycmF5X2NsZWFyKCZob29rX2Vudik7CgoJcmV0dXJuIHJldDsKfQoKaW50IGNtZF9jb21taXQoaW50IGFyZ2MsIGNvbnN0IGNoYXIgKiphcmd2LCBjb25zdCBjaGFyICpwcmVmaXgpCnsKCXN0YXRpYyBzdHJ1Y3Qgd3Rfc3RhdHVzIHM7CglzdGF0aWMgc3RydWN0IG9wdGlvbiBidWlsdGluX2NvbW1pdF9vcHRpb25zW10gPSB7CgkJT1BUX19RVUlFVCgmcXVpZXQsIE5fKCJzdXBwcmVzcyBzdW1tYXJ5IGFmdGVyIHN1Y2Nlc3NmdWwgY29tbWl0IikpLAoJCU9QVF9fVkVSQk9TRSgmdmVyYm9zZSwgTl8oInNob3cgZGlmZiBpbiBjb21taXQgbWVzc2FnZSB0ZW1wbGF0ZSIpKSwKCgkJT1BUX0dST1VQKE5fKCJDb21taXQgbWVzc2FnZSBvcHRpb25zIikpLAoJCU9QVF9GSUxFTkFNRSgnRicsICJmaWxlIiwgJmxvZ2ZpbGUsIE5fKCJyZWFkIG1lc3NhZ2UgZnJvbSBmaWxlIikpLAoJCU9QVF9TVFJJTkcoMCwgImF1dGhvciIsICZmb3JjZV9hdXRob3IsIE5fKCJhdXRob3IiKSwgTl8oIm92ZXJyaWRlIGF1dGhvciBmb3IgY29tbWl0IikpLAoJCU9QVF9TVFJJTkcoMCwgImRhdGUiLCAmZm9yY2VfZGF0ZSwgTl8oImRhdGUiKSwgTl8oIm92ZXJyaWRlIGRhdGUgZm9yIGNvbW1pdCIpKSwKCQlPUFRfQ0FMTEJBQ0soJ20nLCAibWVzc2FnZSIsICZtZXNzYWdlLCBOXygibWVzc2FnZSIpLCBOXygiY29tbWl0IG1lc3NhZ2UiKSwgb3B0X3BhcnNlX20pLAoJCU9QVF9TVFJJTkcoJ2MnLCAicmVlZGl0LW1lc3NhZ2UiLCAmZWRpdF9tZXNzYWdlLCBOXygiY29tbWl0IiksIE5fKCJyZXVzZSBhbmQgZWRpdCBtZXNzYWdlIGZyb20gc3BlY2lmaWVkIGNvbW1pdCIpKSwKCQlPUFRfU1RSSU5HKCdDJywgInJldXNlLW1lc3NhZ2UiLCAmdXNlX21lc3NhZ2UsIE5fKCJjb21taXQiKSwgTl8oInJldXNlIG1lc3NhZ2UgZnJvbSBzcGVjaWZpZWQgY29tbWl0IikpLAoJCU9QVF9TVFJJTkcoMCwgImZpeHVwIiwgJmZpeHVwX21lc3NhZ2UsIE5fKCJjb21taXQiKSwgTl8oInVzZSBhdXRvc3F1YXNoIGZvcm1hdHRlZCBtZXNzYWdlIHRvIGZpeHVwIHNwZWNpZmllZCBjb21taXQiKSksCgkJT1BUX1NUUklORygwLCAic3F1YXNoIiwgJnNxdWFzaF9tZXNzYWdlLCBOXygiY29tbWl0IiksIE5fKCJ1c2UgYXV0b3NxdWFzaCBmb3JtYXR0ZWQgbWVzc2FnZSB0byBzcXVhc2ggc3BlY2lmaWVkIGNvbW1pdCIpKSwKCQlPUFRfQk9PTCgwLCAicmVzZXQtYXV0aG9yIiwgJnJlbmV3X2F1dGhvcnNoaXAsIE5fKCJ0aGUgY29tbWl0IGlzIGF1dGhvcmVkIGJ5IG1lIG5vdyAodXNlZCB3aXRoIC1DLy1jLy0tYW1lbmQpIikpLAoJCU9QVF9CT09MKCdzJywgInNpZ25vZmYiLCAmc2lnbm9mZiwgTl8oImFkZCBTaWduZWQtb2ZmLWJ5OiIpKSwKCQlPUFRfRklMRU5BTUUoJ3QnLCAidGVtcGxhdGUiLCAmdGVtcGxhdGVfZmlsZSwgTl8oInVzZSBzcGVjaWZpZWQgdGVtcGxhdGUgZmlsZSIpKSwKCQlPUFRfQk9PTCgnZScsICJlZGl0IiwgJmVkaXRfZmxhZywgTl8oImZvcmNlIGVkaXQgb2YgY29tbWl0IikpLAoJCU9QVF9TVFJJTkcoMCwgImNsZWFudXAiLCAmY2xlYW51cF9hcmcsIE5fKCJkZWZhdWx0IiksIE5fKCJob3cgdG8gc3RyaXAgc3BhY2VzIGFuZCAjY29tbWVudHMgZnJvbSBtZXNzYWdlIikpLAoJCU9QVF9CT09MKDAsICJzdGF0dXMiLCAmaW5jbHVkZV9zdGF0dXMsIE5fKCJpbmNsdWRlIHN0YXR1cyBpbiBjb21taXQgbWVzc2FnZSB0ZW1wbGF0ZSIpKSwKCQl7IE9QVElPTl9TVFJJTkcsICdTJywgImdwZy1zaWduIiwgJnNpZ25fY29tbWl0LCBOXygia2V5LWlkIiksCgkJICBOXygiR1BHIHNpZ24gY29tbWl0IiksIFBBUlNFX09QVF9PUFRBUkcsIE5VTEwsIChpbnRwdHJfdCkgIiIgfSwKCQkvKiBlbmQgY29tbWl0IG1lc3NhZ2Ugb3B0aW9ucyAqLwoKCQlPUFRfR1JPVVAoTl8oIkNvbW1pdCBjb250ZW50cyBvcHRpb25zIikpLAoJCU9QVF9CT09MKCdhJywgImFsbCIsICZhbGwsIE5fKCJjb21taXQgYWxsIGNoYW5nZWQgZmlsZXMiKSksCgkJT1BUX0JPT0woJ2knLCAiaW5jbHVkZSIsICZhbHNvLCBOXygiYWRkIHNwZWNpZmllZCBmaWxlcyB0byBpbmRleCBmb3IgY29tbWl0IikpLAoJCU9QVF9CT09MKDAsICJpbnRlcmFjdGl2ZSIsICZpbnRlcmFjdGl2ZSwgTl8oImludGVyYWN0aXZlbHkgYWRkIGZpbGVzIikpLAoJCU9QVF9CT09MKCdwJywgInBhdGNoIiwgJnBhdGNoX2ludGVyYWN0aXZlLCBOXygiaW50ZXJhY3RpdmVseSBhZGQgY2hhbmdlcyIpKSwKCQlPUFRfQk9PTCgnbycsICJvbmx5IiwgJm9ubHksIE5fKCJjb21taXQgb25seSBzcGVjaWZpZWQgZmlsZXMiKSksCgkJT1BUX0JPT0woJ24nLCAibm8tdmVyaWZ5IiwgJm5vX3ZlcmlmeSwgTl8oImJ5cGFzcyBwcmUtY29tbWl0IGFuZCBjb21taXQtbXNnIGhvb2tzIikpLAoJCU9QVF9CT09MKDAsICJkcnktcnVuIiwgJmRyeV9ydW4sIE5fKCJzaG93IHdoYXQgd291bGQgYmUgY29tbWl0dGVkIikpLAoJCU9QVF9TRVRfSU5UKDAsICJzaG9ydCIsICZzdGF0dXNfZm9ybWF0LCBOXygic2hvdyBzdGF0dXMgY29uY2lzZWx5IiksCgkJCSAgICBTVEFUVVNfRk9STUFUX1NIT1JUKSwKCQlPUFRfQk9PTCgwLCAiYnJhbmNoIiwgJnMuc2hvd19icmFuY2gsIE5fKCJzaG93IGJyYW5jaCBpbmZvcm1hdGlvbiIpKSwKCQlPUFRfU0VUX0lOVCgwLCAicG9yY2VsYWluIiwgJnN0YXR1c19mb3JtYXQsCgkJCSAgICBOXygibWFjaGluZS1yZWFkYWJsZSBvdXRwdXQiKSwgU1RBVFVTX0ZPUk1BVF9QT1JDRUxBSU4pLAoJCU9QVF9TRVRfSU5UKDAsICJsb25nIiwgJnN0YXR1c19mb3JtYXQsCgkJCSAgICBOXygic2hvdyBzdGF0dXMgaW4gbG9uZyBmb3JtYXQgKGRlZmF1bHQpIiksCgkJCSAgICBTVEFUVVNfRk9STUFUX0xPTkcpLAoJCU9QVF9CT09MKCd6JywgIm51bGwiLCAmcy5udWxsX3Rlcm1pbmF0aW9uLAoJCQkgTl8oInRlcm1pbmF0ZSBlbnRyaWVzIHdpdGggTlVMIikpLAoJCU9QVF9CT09MKDAsICJhbWVuZCIsICZhbWVuZCwgTl8oImFtZW5kIHByZXZpb3VzIGNvbW1pdCIpKSwKCQlPUFRfQk9PTCgwLCAibm8tcG9zdC1yZXdyaXRlIiwgJm5vX3Bvc3RfcmV3cml0ZSwgTl8oImJ5cGFzcyBwb3N0LXJld3JpdGUgaG9vayIpKSwKCQl7IE9QVElPTl9TVFJJTkcsICd1JywgInVudHJhY2tlZC1maWxlcyIsICZ1bnRyYWNrZWRfZmlsZXNfYXJnLCBOXygibW9kZSIpLCBOXygic2hvdyB1bnRyYWNrZWQgZmlsZXMsIG9wdGlvbmFsIG1vZGVzOiBhbGwsIG5vcm1hbCwgbm8uIChEZWZhdWx0OiBhbGwpIiksIFBBUlNFX09QVF9PUFRBUkcsIE5VTEwsIChpbnRwdHJfdCkiYWxsIiB9LAoJCS8qIGVuZCBjb21taXQgY29udGVudHMgb3B0aW9ucyAqLwoKCQlPUFRfSElEREVOX0JPT0woMCwgImFsbG93LWVtcHR5IiwgJmFsbG93X2VtcHR5LAoJCQkJTl8oIm9rIHRvIHJlY29yZCBhbiBlbXB0eSBjaGFuZ2UiKSksCgkJT1BUX0hJRERFTl9CT09MKDAsICJhbGxvdy1lbXB0eS1tZXNzYWdlIiwgJmFsbG93X2VtcHR5X21lc3NhZ2UsCgkJCQlOXygib2sgdG8gcmVjb3JkIGEgY2hhbmdlIHdpdGggYW4gZW1wdHkgbWVzc2FnZSIpKSwKCgkJT1BUX0VORCgpCgl9OwoKCXN0cnVjdCBzdHJidWYgc2IgPSBTVFJCVUZfSU5JVDsKCXN0cnVjdCBzdHJidWYgYXV0aG9yX2lkZW50ID0gU1RSQlVGX0lOSVQ7Cgljb25zdCBjaGFyICppbmRleF9maWxlLCAqcmVmbG9nX21zZzsKCWNoYXIgKm5sOwoJc3RydWN0IG9iamVjdF9pZCBvaWQ7CglzdHJ1Y3QgY29tbWl0X2xpc3QgKnBhcmVudHMgPSBOVUxMOwoJc3RydWN0IHN0YXQgc3RhdGJ1ZjsKCXN0cnVjdCBjb21taXQgKmN1cnJlbnRfaGVhZCA9IE5VTEw7CglzdHJ1Y3QgY29tbWl0X2V4dHJhX2hlYWRlciAqZXh0cmEgPSBOVUxMOwoJc3RydWN0IHJlZl90cmFuc2FjdGlvbiAqdHJhbnNhY3Rpb247CglzdHJ1Y3Qgc3RyYnVmIGVyciA9IFNUUkJVRl9JTklUOwoKCWlmIChhcmdjID09IDIgJiYgIXN0cmNtcChhcmd2WzFdLCAiLWgiKSkKCQl1c2FnZV93aXRoX29wdGlvbnMoYnVpbHRpbl9jb21taXRfdXNhZ2UsIGJ1aWx0aW5fY29tbWl0X29wdGlvbnMpOwoKCXN0YXR1c19pbml0X2NvbmZpZygmcywgZ2l0X2NvbW1pdF9jb25maWcpOwoJc3RhdHVzX2Zvcm1hdCA9IFNUQVRVU19GT1JNQVRfTk9ORTsgLyogSWdub3JlIHN0YXR1cy5zaG9ydCAqLwoJcy5jb2xvcHRzID0gMDsKCglpZiAoZ2V0X3NoYTEoIkhFQUQiLCBvaWQuaGFzaCkpCgkJY3VycmVudF9oZWFkID0gTlVMTDsKCWVsc2UgewoJCWN1cnJlbnRfaGVhZCA9IGxvb2t1cF9jb21taXRfb3JfZGllKCZvaWQsICJIRUFEIik7CgkJaWYgKHBhcnNlX2NvbW1pdChjdXJyZW50X2hlYWQpKQoJCQlkaWUoXygiY291bGQgbm90IHBhcnNlIEhFQUQgY29tbWl0IikpOwoJfQoJdmVyYm9zZSA9IC0xOyAvKiB1bnNwZWNpZmllZCAqLwoJYXJnYyA9IHBhcnNlX2FuZF92YWxpZGF0ZV9vcHRpb25zKGFyZ2MsIGFyZ3YsIGJ1aWx0aW5fY29tbWl0X29wdGlvbnMsCgkJCQkJICBidWlsdGluX2NvbW1pdF91c2FnZSwKCQkJCQkgIHByZWZpeCwgY3VycmVudF9oZWFkLCAmcyk7CglpZiAodmVyYm9zZSA9PSAtMSkKCQl2ZXJib3NlID0gKGNvbmZpZ19jb21taXRfdmVyYm9zZSA8IDApID8gMCA6IGNvbmZpZ19jb21taXRfdmVyYm9zZTsKCglpZiAoZHJ5X3J1bikKCQlyZXR1cm4gZHJ5X3J1bl9jb21taXQoYXJnYywgYXJndiwgcHJlZml4LCBjdXJyZW50X2hlYWQsICZzKTsKCWluZGV4X2ZpbGUgPSBwcmVwYXJlX2luZGV4KGFyZ2MsIGFyZ3YsIHByZWZpeCwgY3VycmVudF9oZWFkLCAwKTsKCgkvKiBTZXQgdXAgZXZlcnl0aGluZyBmb3Igd3JpdGluZyB0aGUgY29tbWl0IG9iamVjdC4gIFRoaXMgaW5jbHVkZXMKCSAgIHJ1bm5pbmcgaG9va3MsIHdyaXRpbmcgdGhlIHRyZWVzLCBhbmQgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgdXNlci4gICovCglpZiAoIXByZXBhcmVfdG9fY29tbWl0KGluZGV4X2ZpbGUsIHByZWZpeCwKCQkJICAgICAgIGN1cnJlbnRfaGVhZCwgJnMsICZhdXRob3JfaWRlbnQpKSB7CgkJcm9sbGJhY2tfaW5kZXhfZmlsZXMoKTsKCQlyZXR1cm4gMTsKCX0KCgkvKiBEZXRlcm1pbmUgcGFyZW50cyAqLwoJcmVmbG9nX21zZyA9IGdldGVudigiR0lUX1JFRkxPR19BQ1RJT04iKTsKCWlmICghY3VycmVudF9oZWFkKSB7CgkJaWYgKCFyZWZsb2dfbXNnKQoJCQlyZWZsb2dfbXNnID0gImNvbW1pdCAoaW5pdGlhbCkiOwoJfSBlbHNlIGlmIChhbWVuZCkgewoJCWlmICghcmVmbG9nX21zZykKCQkJcmVmbG9nX21zZyA9ICJjb21taXQgKGFtZW5kKSI7CgkJcGFyZW50cyA9IGNvcHlfY29tbWl0X2xpc3QoY3VycmVudF9oZWFkLT5wYXJlbnRzKTsKCX0gZWxzZSBpZiAod2hlbmNlID09IEZST01fTUVSR0UpIHsKCQlzdHJ1Y3Qgc3RyYnVmIG0gPSBTVFJCVUZfSU5JVDsKCQlGSUxFICpmcDsKCQlpbnQgYWxsb3dfZmFzdF9mb3J3YXJkID0gMTsKCQlzdHJ1Y3QgY29tbWl0X2xpc3QgKipwcHRyID0gJnBhcmVudHM7CgoJCWlmICghcmVmbG9nX21zZykKCQkJcmVmbG9nX21zZyA9ICJjb21taXQgKG1lcmdlKSI7CgkJcHB0ciA9IGNvbW1pdF9saXN0X2FwcGVuZChjdXJyZW50X2hlYWQsIHBwdHIpOwoJCWZwID0geGZvcGVuKGdpdF9wYXRoX21lcmdlX2hlYWQoKSwgInIiKTsKCQl3aGlsZSAoc3RyYnVmX2dldGxpbmVfbGYoJm0sIGZwKSAhPSBFT0YpIHsKCQkJc3RydWN0IGNvbW1pdCAqcGFyZW50OwoKCQkJcGFyZW50ID0gZ2V0X21lcmdlX3BhcmVudChtLmJ1Zik7CgkJCWlmICghcGFyZW50KQoJCQkJZGllKF8oIkNvcnJ1cHQgTUVSR0VfSEVBRCBmaWxlICglcykiKSwgbS5idWYpOwoJCQlwcHRyID0gY29tbWl0X2xpc3RfYXBwZW5kKHBhcmVudCwgcHB0cik7CgkJfQoJCWZjbG9zZShmcCk7CgkJc3RyYnVmX3JlbGVhc2UoJm0pOwoJCWlmICghc3RhdChnaXRfcGF0aF9tZXJnZV9tb2RlKCksICZzdGF0YnVmKSkgewoJCQlpZiAoc3RyYnVmX3JlYWRfZmlsZSgmc2IsIGdpdF9wYXRoX21lcmdlX21vZGUoKSwgMCkgPCAwKQoJCQkJZGllX2Vycm5vKF8oImNvdWxkIG5vdCByZWFkIE1FUkdFX01PREUiKSk7CgkJCWlmICghc3RyY21wKHNiLmJ1ZiwgIm5vLWZmIikpCgkJCQlhbGxvd19mYXN0X2ZvcndhcmQgPSAwOwoJCX0KCQlpZiAoYWxsb3dfZmFzdF9mb3J3YXJkKQoJCQlwYXJlbnRzID0gcmVkdWNlX2hlYWRzKHBhcmVudHMpOwoJfSBlbHNlIHsKCQlpZiAoIXJlZmxvZ19tc2cpCgkJCXJlZmxvZ19tc2cgPSAod2hlbmNlID09IEZST01fQ0hFUlJZX1BJQ0spCgkJCQkJPyAiY29tbWl0IChjaGVycnktcGljaykiCgkJCQkJOiAiY29tbWl0IjsKCQljb21taXRfbGlzdF9pbnNlcnQoY3VycmVudF9oZWFkLCAmcGFyZW50cyk7Cgl9CgoJLyogRmluYWxseSwgZ2V0IHRoZSBjb21taXQgbWVzc2FnZSAqLwoJc3RyYnVmX3Jlc2V0KCZzYik7CglpZiAoc3RyYnVmX3JlYWRfZmlsZSgmc2IsIGdpdF9wYXRoX2NvbW1pdF9lZGl0bXNnKCksIDApIDwgMCkgewoJCWludCBzYXZlZF9lcnJubyA9IGVycm5vOwoJCXJvbGxiYWNrX2luZGV4X2ZpbGVzKCk7CgkJZGllKF8oImNvdWxkIG5vdCByZWFkIGNvbW1pdCBtZXNzYWdlOiAlcyIpLCBzdHJlcnJvcihzYXZlZF9lcnJubykpOwoJfQoKCWlmICh2ZXJib3NlIHx8IC8qIFRydW5jYXRlIHRoZSBtZXNzYWdlIGp1c3QgYmVmb3JlIHRoZSBkaWZmLCBpZiBhbnkuICovCgkgICAgY2xlYW51cF9tb2RlID09IENMRUFOVVBfU0NJU1NPUlMpCgkJc3RyYnVmX3NldGxlbigmc2IsIHd0X3N0YXR1c19sb2NhdGVfZW5kKHNiLmJ1Ziwgc2IubGVuKSk7CgoJaWYgKGNsZWFudXBfbW9kZSAhPSBDTEVBTlVQX05PTkUpCgkJc3RyYnVmX3N0cmlwc3BhY2UoJnNiLCBjbGVhbnVwX21vZGUgPT0gQ0xFQU5VUF9BTEwpOwoJaWYgKHRlbXBsYXRlX3VudG91Y2hlZCgmc2IpICYmICFhbGxvd19lbXB0eV9tZXNzYWdlKSB7CgkJcm9sbGJhY2tfaW5kZXhfZmlsZXMoKTsKCQlmcHJpbnRmKHN0ZGVyciwgXygiQWJvcnRpbmcgY29tbWl0OyB5b3UgZGlkIG5vdCBlZGl0IHRoZSBtZXNzYWdlLlxuIikpOwoJCWV4aXQoMSk7Cgl9CglpZiAobWVzc2FnZV9pc19lbXB0eSgmc2IpICYmICFhbGxvd19lbXB0eV9tZXNzYWdlKSB7CgkJcm9sbGJhY2tfaW5kZXhfZmlsZXMoKTsKCQlmcHJpbnRmKHN0ZGVyciwgXygiQWJvcnRpbmcgY29tbWl0IGR1ZSB0byBlbXB0eSBjb21taXQgbWVzc2FnZS5cbiIpKTsKCQlleGl0KDEpOwoJfQoKCWlmIChhbWVuZCkgewoJCWNvbnN0IGNoYXIgKmV4Y2x1ZGVfZ3Bnc2lnWzJdID0geyAiZ3Bnc2lnIiwgTlVMTCB9OwoJCWV4dHJhID0gcmVhZF9jb21taXRfZXh0cmFfaGVhZGVycyhjdXJyZW50X2hlYWQsIGV4Y2x1ZGVfZ3Bnc2lnKTsKCX0gZWxzZSB7CgkJc3RydWN0IGNvbW1pdF9leHRyYV9oZWFkZXIgKip0YWlsID0gJmV4dHJhOwoJCWFwcGVuZF9tZXJnZV90YWdfaGVhZGVycyhwYXJlbnRzLCAmdGFpbCk7Cgl9CgoJaWYgKGNvbW1pdF90cmVlX2V4dGVuZGVkKHNiLmJ1Ziwgc2IubGVuLCBhY3RpdmVfY2FjaGVfdHJlZS0+b2lkLmhhc2gsCgkJCSBwYXJlbnRzLCBvaWQuaGFzaCwgYXV0aG9yX2lkZW50LmJ1Ziwgc2lnbl9jb21taXQsIGV4dHJhKSkgewoJCXJvbGxiYWNrX2luZGV4X2ZpbGVzKCk7CgkJZGllKF8oImZhaWxlZCB0byB3cml0ZSBjb21taXQgb2JqZWN0IikpOwoJfQoJc3RyYnVmX3JlbGVhc2UoJmF1dGhvcl9pZGVudCk7CglmcmVlX2NvbW1pdF9leHRyYV9oZWFkZXJzKGV4dHJhKTsKCglubCA9IHN0cmNocihzYi5idWYsICdcbicpOwoJaWYgKG5sKQoJCXN0cmJ1Zl9zZXRsZW4oJnNiLCBubCArIDEgLSBzYi5idWYpOwoJZWxzZQoJCXN0cmJ1Zl9hZGRjaCgmc2IsICdcbicpOwoJc3RyYnVmX2luc2VydCgmc2IsIDAsIHJlZmxvZ19tc2csIHN0cmxlbihyZWZsb2dfbXNnKSk7CglzdHJidWZfaW5zZXJ0KCZzYiwgc3RybGVuKHJlZmxvZ19tc2cpLCAiOiAiLCAyKTsKCgl0cmFuc2FjdGlvbiA9IHJlZl90cmFuc2FjdGlvbl9iZWdpbigmZXJyKTsKCWlmICghdHJhbnNhY3Rpb24gfHwKCSAgICByZWZfdHJhbnNhY3Rpb25fdXBkYXRlKHRyYW5zYWN0aW9uLCAiSEVBRCIsIG9pZC5oYXNoLAoJCQkJICAgY3VycmVudF9oZWFkCgkJCQkgICA/IGN1cnJlbnRfaGVhZC0+b2JqZWN0Lm9pZC5oYXNoIDogbnVsbF9zaGExLAoJCQkJICAgMCwgc2IuYnVmLCAmZXJyKSB8fAoJICAgIHJlZl90cmFuc2FjdGlvbl9jb21taXQodHJhbnNhY3Rpb24sICZlcnIpKSB7CgkJcm9sbGJhY2tfaW5kZXhfZmlsZXMoKTsKCQlkaWUoIiVzIiwgZXJyLmJ1Zik7Cgl9CglyZWZfdHJhbnNhY3Rpb25fZnJlZSh0cmFuc2FjdGlvbik7CgoJdW5saW5rKGdpdF9wYXRoX2NoZXJyeV9waWNrX2hlYWQoKSk7Cgl1bmxpbmsoZ2l0X3BhdGhfcmV2ZXJ0X2hlYWQoKSk7Cgl1bmxpbmsoZ2l0X3BhdGhfbWVyZ2VfaGVhZCgpKTsKCXVubGluayhnaXRfcGF0aF9tZXJnZV9tc2coKSk7Cgl1bmxpbmsoZ2l0X3BhdGhfbWVyZ2VfbW9kZSgpKTsKCXVubGluayhnaXRfcGF0aF9zcXVhc2hfbXNnKCkpOwoKCWlmIChjb21taXRfaW5kZXhfZmlsZXMoKSkKCQlkaWUgKF8oIlJlcG9zaXRvcnkgaGFzIGJlZW4gdXBkYXRlZCwgYnV0IHVuYWJsZSB0byB3cml0ZVxuIgoJCSAgICAgIm5ld19pbmRleCBmaWxlLiBDaGVjayB0aGF0IGRpc2sgaXMgbm90IGZ1bGwgYW5kIHF1b3RhIGlzXG4iCgkJICAgICAibm90IGV4Y2VlZGVkLCBhbmQgdGhlbiBcImdpdCByZXNldCBIRUFEXCIgdG8gcmVjb3Zlci4iKSk7CgoJcmVyZXJlKDApOwoJcnVuX2NvbW1pdF9ob29rKHVzZV9lZGl0b3IsIGdldF9pbmRleF9maWxlKCksICJwb3N0LWNvbW1pdCIsIE5VTEwpOwoJaWYgKGFtZW5kICYmICFub19wb3N0X3Jld3JpdGUpIHsKCQlzdHJ1Y3Qgbm90ZXNfcmV3cml0ZV9jZmcgKmNmZzsKCQljZmcgPSBpbml0X2NvcHlfbm90ZXNfZm9yX3Jld3JpdGUoImFtZW5kIik7CgkJaWYgKGNmZykgewoJCQkvKiB3ZSBhcmUgYW1lbmRpbmcsIHNvIGN1cnJlbnRfaGVhZCBpcyBub3QgTlVMTCAqLwoJCQljb3B5X25vdGVfZm9yX3Jld3JpdGUoY2ZnLCAmY3VycmVudF9oZWFkLT5vYmplY3Qub2lkLCAmb2lkKTsKCQkJZmluaXNoX2NvcHlfbm90ZXNfZm9yX3Jld3JpdGUoY2ZnLCAiTm90ZXMgYWRkZWQgYnkgJ2dpdCBjb21taXQgLS1hbWVuZCciKTsKCQl9CgkJcnVuX3Jld3JpdGVfaG9vaygmY3VycmVudF9oZWFkLT5vYmplY3Qub2lkLCAmb2lkKTsKCX0KCWlmICghcXVpZXQpCgkJcHJpbnRfc3VtbWFyeShwcmVmaXgsICZvaWQsICFjdXJyZW50X2hlYWQpOwoKCXN0cmJ1Zl9yZWxlYXNlKCZlcnIpOwoJcmV0dXJuIDA7Cn0K",
    "text": "/*\n * Builtin \"git commit\"\n *\n * Copyright (c) 2007 Kristian H\u00f8gsberg <krh@redhat.com>\n * Based on git-commit.sh by Junio C Hamano and Linus Torvalds\n */\n\n#include \"cache.h\"\n#include \"config.h\"\n#include \"lockfile.h\"\n#include \"cache-tree.h\"\n#include \"color.h\"\n#include \"dir.h\"\n#include \"builtin.h\"\n#include \"diff.h\"\n#include \"diffcore.h\"\n#include \"commit.h\"\n#include \"revision.h\"\n#include \"wt-status.h\"\n#include \"run-command.h\"\n#include \"refs.h\"\n#include \"log-tree.h\"\n#include \"strbuf.h\"\n#include \"utf8.h\"\n#include \"parse-options.h\"\n#include \"string-list.h\"\n#include \"rerere.h\"\n#include \"unpack-trees.h\"\n#include \"quote.h\"\n#include \"submodule.h\"\n#include \"gpg-interface.h\"\n#include \"column.h\"\n#include \"sequencer.h\"\n#include \"notes-utils.h\"\n#include \"mailmap.h\"\n#include \"sigchain.h\"\n\nstatic const char * const builtin_commit_usage[] = {\n\tN_(\"git commit [<options>] [--] <pathspec>...\"),\n\tNULL\n};\n\nstatic const char * const builtin_status_usage[] = {\n\tN_(\"git status [<options>] [--] <pathspec>...\"),\n\tNULL\n};\n\nstatic const char implicit_ident_advice_noconfig[] =\nN_(\"Your name and email address were configured automatically based\\n\"\n\"on your username and hostname. Please check that they are accurate.\\n\"\n\"You can suppress this message by setting them explicitly. Run the\\n\"\n\"following command and follow the instructions in your editor to edit\\n\"\n\"your configuration file:\\n\"\n\"\\n\"\n\"    git config --global --edit\\n\"\n\"\\n\"\n\"After doing this, you may fix the identity used for this commit with:\\n\"\n\"\\n\"\n\"    git commit --amend --reset-author\\n\");\n\nstatic const char implicit_ident_advice_config[] =\nN_(\"Your name and email address were configured automatically based\\n\"\n\"on your username and hostname. Please check that they are accurate.\\n\"\n\"You can suppress this message by setting them explicitly:\\n\"\n\"\\n\"\n\"    git config --global user.name \\\"Your Name\\\"\\n\"\n\"    git config --global user.email you@example.com\\n\"\n\"\\n\"\n\"After doing this, you may fix the identity used for this commit with:\\n\"\n\"\\n\"\n\"    git commit --amend --reset-author\\n\");\n\nstatic const char empty_amend_advice[] =\nN_(\"You asked to amend the most recent commit, but doing so would make\\n\"\n\"it empty. You can repeat your command with --allow-empty, or you can\\n\"\n\"remove the commit entirely with \\\"git reset HEAD^\\\".\\n\");\n\nstatic const char empty_cherry_pick_advice[] =\nN_(\"The previous cherry-pick is now empty, possibly due to conflict resolution.\\n\"\n\"If you wish to commit it anyway, use:\\n\"\n\"\\n\"\n\"    git commit --allow-empty\\n\"\n\"\\n\");\n\nstatic const char empty_cherry_pick_advice_single[] =\nN_(\"Otherwise, please use 'git reset'\\n\");\n\nstatic const char empty_cherry_pick_advice_multi[] =\nN_(\"If you wish to skip this commit, use:\\n\"\n\"\\n\"\n\"    git reset\\n\"\n\"\\n\"\n\"Then \\\"git cherry-pick --continue\\\" will resume cherry-picking\\n\"\n\"the remaining commits.\\n\");\n\nstatic GIT_PATH_FUNC(git_path_commit_editmsg, \"COMMIT_EDITMSG\")\n\nstatic const char *use_message_buffer;\nstatic struct lock_file index_lock; /* real index */\nstatic struct lock_file false_lock; /* used only for partial commits */\nstatic enum {\n\tCOMMIT_AS_IS = 1,\n\tCOMMIT_NORMAL,\n\tCOMMIT_PARTIAL\n} commit_style;\n\nstatic const char *logfile, *force_author;\nstatic const char *template_file;\n/*\n * The _message variables are commit names from which to take\n * the commit message and/or authorship.\n */\nstatic const char *author_message, *author_message_buffer;\nstatic char *edit_message, *use_message;\nstatic char *fixup_message, *squash_message;\nstatic int all, also, interactive, patch_interactive, only, amend, signoff;\nstatic int edit_flag = -1; /* unspecified */\nstatic int quiet, verbose, no_verify, allow_empty, dry_run, renew_authorship;\nstatic int config_commit_verbose = -1; /* unspecified */\nstatic int no_post_rewrite, allow_empty_message;\nstatic char *untracked_files_arg, *force_date, *ignore_submodule_arg;\nstatic char *sign_commit;\n\n/*\n * The default commit message cleanup mode will remove the lines\n * beginning with # (shell comments) and leading and trailing\n * whitespaces (empty lines or containing only whitespaces)\n * if editor is used, and only the whitespaces if the message\n * is specified explicitly.\n */\nstatic enum {\n\tCLEANUP_SPACE,\n\tCLEANUP_NONE,\n\tCLEANUP_SCISSORS,\n\tCLEANUP_ALL\n} cleanup_mode;\nstatic const char *cleanup_arg;\n\nstatic enum commit_whence whence;\nstatic int sequencer_in_use;\nstatic int use_editor = 1, include_status = 1;\nstatic int show_ignored_in_status, have_option_m;\nstatic const char *only_include_assumed;\nstatic struct strbuf message = STRBUF_INIT;\n\nstatic enum wt_status_format status_format = STATUS_FORMAT_UNSPECIFIED;\n\nstatic int opt_parse_porcelain(const struct option *opt, const char *arg, int unset)\n{\n\tenum wt_status_format *value = (enum wt_status_format *)opt->value;\n\tif (unset)\n\t\t*value = STATUS_FORMAT_NONE;\n\telse if (!arg)\n\t\t*value = STATUS_FORMAT_PORCELAIN;\n\telse if (!strcmp(arg, \"v1\") || !strcmp(arg, \"1\"))\n\t\t*value = STATUS_FORMAT_PORCELAIN;\n\telse if (!strcmp(arg, \"v2\") || !strcmp(arg, \"2\"))\n\t\t*value = STATUS_FORMAT_PORCELAIN_V2;\n\telse\n\t\tdie(\"unsupported porcelain version '%s'\", arg);\n\n\treturn 0;\n}\n\nstatic int opt_parse_m(const struct option *opt, const char *arg, int unset)\n{\n\tstruct strbuf *buf = opt->value;\n\tif (unset) {\n\t\thave_option_m = 0;\n\t\tstrbuf_setlen(buf, 0);\n\t} else {\n\t\thave_option_m = 1;\n\t\tif (buf->len)\n\t\t\tstrbuf_addch(buf, '\\n');\n\t\tstrbuf_addstr(buf, arg);\n\t\tstrbuf_complete_line(buf);\n\t}\n\treturn 0;\n}\n\nstatic void determine_whence(struct wt_status *s)\n{\n\tif (file_exists(git_path_merge_head()))\n\t\twhence = FROM_MERGE;\n\telse if (file_exists(git_path_cherry_pick_head())) {\n\t\twhence = FROM_CHERRY_PICK;\n\t\tif (file_exists(git_path_seq_dir()))\n\t\t\tsequencer_in_use = 1;\n\t}\n\telse\n\t\twhence = FROM_COMMIT;\n\tif (s)\n\t\ts->whence = whence;\n}\n\nstatic void status_init_config(struct wt_status *s, config_fn_t fn)\n{\n\twt_status_prepare(s);\n\tgitmodules_config();\n\tgit_config(fn, s);\n\tdetermine_whence(s);\n\tinit_diff_ui_defaults();\n\ts->hints = advice_status_hints; /* must come after git_config() */\n}\n\nstatic void rollback_index_files(void)\n{\n\tswitch (commit_style) {\n\tcase COMMIT_AS_IS:\n\t\tbreak; /* nothing to do */\n\tcase COMMIT_NORMAL:\n\t\trollback_lock_file(&index_lock);\n\t\tbreak;\n\tcase COMMIT_PARTIAL:\n\t\trollback_lock_file(&index_lock);\n\t\trollback_lock_file(&false_lock);\n\t\tbreak;\n\t}\n}\n\nstatic int commit_index_files(void)\n{\n\tint err = 0;\n\n\tswitch (commit_style) {\n\tcase COMMIT_AS_IS:\n\t\tbreak; /* nothing to do */\n\tcase COMMIT_NORMAL:\n\t\terr = commit_lock_file(&index_lock);\n\t\tbreak;\n\tcase COMMIT_PARTIAL:\n\t\terr = commit_lock_file(&index_lock);\n\t\trollback_lock_file(&false_lock);\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\n/*\n * Take a union of paths in the index and the named tree (typically, \"HEAD\"),\n * and return the paths that match the given pattern in list.\n */\nstatic int list_paths(struct string_list *list, const char *with_tree,\n\t\t      const char *prefix, const struct pathspec *pattern)\n{\n\tint i, ret;\n\tchar *m;\n\n\tif (!pattern->nr)\n\t\treturn 0;\n\n\tm = xcalloc(1, pattern->nr);\n\n\tif (with_tree) {\n\t\tchar *max_prefix = common_prefix(pattern);\n\t\toverlay_tree_on_index(&the_index, with_tree,\n\t\t\t\t      max_prefix ? max_prefix : prefix);\n\t\tfree(max_prefix);\n\t}\n\n\tfor (i = 0; i < active_nr; i++) {\n\t\tconst struct cache_entry *ce = active_cache[i];\n\t\tstruct string_list_item *item;\n\n\t\tif (ce->ce_flags & CE_UPDATE)\n\t\t\tcontinue;\n\t\tif (!ce_path_match(ce, pattern, m))\n\t\t\tcontinue;\n\t\titem = string_list_insert(list, ce->name);\n\t\tif (ce_skip_worktree(ce))\n\t\t\titem->util = item; /* better a valid pointer than a fake one */\n\t}\n\n\tret = report_path_error(m, pattern, prefix);\n\tfree(m);\n\treturn ret;\n}\n\nstatic void add_remove_files(struct string_list *list)\n{\n\tint i;\n\tfor (i = 0; i < list->nr; i++) {\n\t\tstruct stat st;\n\t\tstruct string_list_item *p = &(list->items[i]);\n\n\t\t/* p->util is skip-worktree */\n\t\tif (p->util)\n\t\t\tcontinue;\n\n\t\tif (!lstat(p->string, &st)) {\n\t\t\tif (add_to_cache(p->string, &st, 0))\n\t\t\t\tdie(_(\"updating files failed\"));\n\t\t} else\n\t\t\tremove_file_from_cache(p->string);\n\t}\n}\n\nstatic void create_base_index(const struct commit *current_head)\n{\n\tstruct tree *tree;\n\tstruct unpack_trees_options opts;\n\tstruct tree_desc t;\n\n\tif (!current_head) {\n\t\tdiscard_cache();\n\t\treturn;\n\t}\n\n\tmemset(&opts, 0, sizeof(opts));\n\topts.head_idx = 1;\n\topts.index_only = 1;\n\topts.merge = 1;\n\topts.src_index = &the_index;\n\topts.dst_index = &the_index;\n\n\topts.fn = oneway_merge;\n\ttree = parse_tree_indirect(&current_head->object.oid);\n\tif (!tree)\n\t\tdie(_(\"failed to unpack HEAD tree object\"));\n\tparse_tree(tree);\n\tinit_tree_desc(&t, tree->buffer, tree->size);\n\tif (unpack_trees(1, &t, &opts))\n\t\texit(128); /* We've already reported the error, finish dying */\n}\n\nstatic void refresh_cache_or_die(int refresh_flags)\n{\n\t/*\n\t * refresh_flags contains REFRESH_QUIET, so the only errors\n\t * are for unmerged entries.\n\t */\n\tif (refresh_cache(refresh_flags | REFRESH_IN_PORCELAIN))\n\t\tdie_resolve_conflict(\"commit\");\n}\n\nstatic const char *prepare_index(int argc, const char **argv, const char *prefix,\n\t\t\t\t const struct commit *current_head, int is_status)\n{\n\tstruct string_list partial;\n\tstruct pathspec pathspec;\n\tint refresh_flags = REFRESH_QUIET;\n\tconst char *ret;\n\n\tif (is_status)\n\t\trefresh_flags |= REFRESH_UNMERGED;\n\tparse_pathspec(&pathspec, 0,\n\t\t       PATHSPEC_PREFER_FULL,\n\t\t       prefix, argv);\n\n\tif (read_cache_preload(&pathspec) < 0)\n\t\tdie(_(\"index file corrupt\"));\n\n\tif (interactive) {\n\t\tchar *old_index_env = NULL;\n\t\thold_locked_index(&index_lock, LOCK_DIE_ON_ERROR);\n\n\t\trefresh_cache_or_die(refresh_flags);\n\n\t\tif (write_locked_index(&the_index, &index_lock, CLOSE_LOCK))\n\t\t\tdie(_(\"unable to create temporary index\"));\n\n\t\told_index_env = getenv(INDEX_ENVIRONMENT);\n\t\tsetenv(INDEX_ENVIRONMENT, get_lock_file_path(&index_lock), 1);\n\n\t\tif (interactive_add(argc, argv, prefix, patch_interactive) != 0)\n\t\t\tdie(_(\"interactive add failed\"));\n\n\t\tif (old_index_env && *old_index_env)\n\t\t\tsetenv(INDEX_ENVIRONMENT, old_index_env, 1);\n\t\telse\n\t\t\tunsetenv(INDEX_ENVIRONMENT);\n\n\t\tdiscard_cache();\n\t\tread_cache_from(get_lock_file_path(&index_lock));\n\t\tif (update_main_cache_tree(WRITE_TREE_SILENT) == 0) {\n\t\t\tif (reopen_lock_file(&index_lock) < 0)\n\t\t\t\tdie(_(\"unable to write index file\"));\n\t\t\tif (write_locked_index(&the_index, &index_lock, CLOSE_LOCK))\n\t\t\t\tdie(_(\"unable to update temporary index\"));\n\t\t} else\n\t\t\twarning(_(\"Failed to update main cache tree\"));\n\n\t\tcommit_style = COMMIT_NORMAL;\n\t\treturn get_lock_file_path(&index_lock);\n\t}\n\n\t/*\n\t * Non partial, non as-is commit.\n\t *\n\t * (1) get the real index;\n\t * (2) update the_index as necessary;\n\t * (3) write the_index out to the real index (still locked);\n\t * (4) return the name of the locked index file.\n\t *\n\t * The caller should run hooks on the locked real index, and\n\t * (A) if all goes well, commit the real index;\n\t * (B) on failure, rollback the real index.\n\t */\n\tif (all || (also && pathspec.nr)) {\n\t\thold_locked_index(&index_lock, LOCK_DIE_ON_ERROR);\n\t\tadd_files_to_cache(also ? prefix : NULL, &pathspec, 0);\n\t\trefresh_cache_or_die(refresh_flags);\n\t\tupdate_main_cache_tree(WRITE_TREE_SILENT);\n\t\tif (write_locked_index(&the_index, &index_lock, CLOSE_LOCK))\n\t\t\tdie(_(\"unable to write new_index file\"));\n\t\tcommit_style = COMMIT_NORMAL;\n\t\treturn get_lock_file_path(&index_lock);\n\t}\n\n\t/*\n\t * As-is commit.\n\t *\n\t * (1) return the name of the real index file.\n\t *\n\t * The caller should run hooks on the real index,\n\t * and create commit from the_index.\n\t * We still need to refresh the index here.\n\t */\n\tif (!only && !pathspec.nr) {\n\t\thold_locked_index(&index_lock, LOCK_DIE_ON_ERROR);\n\t\trefresh_cache_or_die(refresh_flags);\n\t\tif (active_cache_changed\n\t\t    || !cache_tree_fully_valid(active_cache_tree))\n\t\t\tupdate_main_cache_tree(WRITE_TREE_SILENT);\n\t\tif (active_cache_changed) {\n\t\t\tif (write_locked_index(&the_index, &index_lock,\n\t\t\t\t\t       COMMIT_LOCK))\n\t\t\t\tdie(_(\"unable to write new_index file\"));\n\t\t} else {\n\t\t\trollback_lock_file(&index_lock);\n\t\t}\n\t\tcommit_style = COMMIT_AS_IS;\n\t\treturn get_index_file();\n\t}\n\n\t/*\n\t * A partial commit.\n\t *\n\t * (0) find the set of affected paths;\n\t * (1) get lock on the real index file;\n\t * (2) update the_index with the given paths;\n\t * (3) write the_index out to the real index (still locked);\n\t * (4) get lock on the false index file;\n\t * (5) reset the_index from HEAD;\n\t * (6) update the_index the same way as (2);\n\t * (7) write the_index out to the false index file;\n\t * (8) return the name of the false index file (still locked);\n\t *\n\t * The caller should run hooks on the locked false index, and\n\t * create commit from it.  Then\n\t * (A) if all goes well, commit the real index;\n\t * (B) on failure, rollback the real index;\n\t * In either case, rollback the false index.\n\t */\n\tcommit_style = COMMIT_PARTIAL;\n\n\tif (whence != FROM_COMMIT) {\n\t\tif (whence == FROM_MERGE)\n\t\t\tdie(_(\"cannot do a partial commit during a merge.\"));\n\t\telse if (whence == FROM_CHERRY_PICK)\n\t\t\tdie(_(\"cannot do a partial commit during a cherry-pick.\"));\n\t}\n\n\tstring_list_init(&partial, 1);\n\tif (list_paths(&partial, !current_head ? NULL : \"HEAD\", prefix, &pathspec))\n\t\texit(1);\n\n\tdiscard_cache();\n\tif (read_cache() < 0)\n\t\tdie(_(\"cannot read the index\"));\n\n\thold_locked_index(&index_lock, LOCK_DIE_ON_ERROR);\n\tadd_remove_files(&partial);\n\trefresh_cache(REFRESH_QUIET);\n\tupdate_main_cache_tree(WRITE_TREE_SILENT);\n\tif (write_locked_index(&the_index, &index_lock, CLOSE_LOCK))\n\t\tdie(_(\"unable to write new_index file\"));\n\n\thold_lock_file_for_update(&false_lock,\n\t\t\t\t  git_path(\"next-index-%\"PRIuMAX,\n\t\t\t\t\t   (uintmax_t) getpid()),\n\t\t\t\t  LOCK_DIE_ON_ERROR);\n\n\tcreate_base_index(current_head);\n\tadd_remove_files(&partial);\n\trefresh_cache(REFRESH_QUIET);\n\n\tif (write_locked_index(&the_index, &false_lock, CLOSE_LOCK))\n\t\tdie(_(\"unable to write temporary index file\"));\n\n\tdiscard_cache();\n\tret = get_lock_file_path(&false_lock);\n\tread_cache_from(ret);\n\treturn ret;\n}\n\nstatic int run_status(FILE *fp, const char *index_file, const char *prefix, int nowarn,\n\t\t      struct wt_status *s)\n{\n\tstruct object_id oid;\n\n\tif (s->relative_paths)\n\t\ts->prefix = prefix;\n\n\tif (amend) {\n\t\ts->amend = 1;\n\t\ts->reference = \"HEAD^1\";\n\t}\n\ts->verbose = verbose;\n\ts->index_file = index_file;\n\ts->fp = fp;\n\ts->nowarn = nowarn;\n\ts->is_initial = get_sha1(s->reference, oid.hash) ? 1 : 0;\n\tif (!s->is_initial)\n\t\thashcpy(s->sha1_commit, oid.hash);\n\ts->status_format = status_format;\n\ts->ignore_submodule_arg = ignore_submodule_arg;\n\n\twt_status_collect(s);\n\twt_status_print(s);\n\n\treturn s->commitable;\n}\n\nstatic int is_a_merge(const struct commit *current_head)\n{\n\treturn !!(current_head->parents && current_head->parents->next);\n}\n\nstatic void assert_split_ident(struct ident_split *id, const struct strbuf *buf)\n{\n\tif (split_ident_line(id, buf->buf, buf->len) || !id->date_begin)\n\t\tdie(\"BUG: unable to parse our own ident: %s\", buf->buf);\n}\n\nstatic void export_one(const char *var, const char *s, const char *e, int hack)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tif (hack)\n\t\tstrbuf_addch(&buf, hack);\n\tstrbuf_addf(&buf, \"%.*s\", (int)(e - s), s);\n\tsetenv(var, buf.buf, 1);\n\tstrbuf_release(&buf);\n}\n\nstatic int parse_force_date(const char *in, struct strbuf *out)\n{\n\tstrbuf_addch(out, '@');\n\n\tif (parse_date(in, out) < 0) {\n\t\tint errors = 0;\n\t\tunsigned long t = approxidate_careful(in, &errors);\n\t\tif (errors)\n\t\t\treturn -1;\n\t\tstrbuf_addf(out, \"%lu\", t);\n\t}\n\n\treturn 0;\n}\n\nstatic void set_ident_var(char **buf, char *val)\n{\n\tfree(*buf);\n\t*buf = val;\n}\n\nstatic void determine_author_info(struct strbuf *author_ident)\n{\n\tchar *name, *email, *date;\n\tstruct ident_split author;\n\n\tname = xstrdup_or_null(getenv(\"GIT_AUTHOR_NAME\"));\n\temail = xstrdup_or_null(getenv(\"GIT_AUTHOR_EMAIL\"));\n\tdate = xstrdup_or_null(getenv(\"GIT_AUTHOR_DATE\"));\n\n\tif (author_message) {\n\t\tstruct ident_split ident;\n\t\tsize_t len;\n\t\tconst char *a;\n\n\t\ta = find_commit_header(author_message_buffer, \"author\", &len);\n\t\tif (!a)\n\t\t\tdie(_(\"commit '%s' lacks author header\"), author_message);\n\t\tif (split_ident_line(&ident, a, len) < 0)\n\t\t\tdie(_(\"commit '%s' has malformed author line\"), author_message);\n\n\t\tset_ident_var(&name, xmemdupz(ident.name_begin, ident.name_end - ident.name_begin));\n\t\tset_ident_var(&email, xmemdupz(ident.mail_begin, ident.mail_end - ident.mail_begin));\n\n\t\tif (ident.date_begin) {\n\t\t\tstruct strbuf date_buf = STRBUF_INIT;\n\t\t\tstrbuf_addch(&date_buf, '@');\n\t\t\tstrbuf_add(&date_buf, ident.date_begin, ident.date_end - ident.date_begin);\n\t\t\tstrbuf_addch(&date_buf, ' ');\n\t\t\tstrbuf_add(&date_buf, ident.tz_begin, ident.tz_end - ident.tz_begin);\n\t\t\tset_ident_var(&date, strbuf_detach(&date_buf, NULL));\n\t\t}\n\t}\n\n\tif (force_author) {\n\t\tstruct ident_split ident;\n\n\t\tif (split_ident_line(&ident, force_author, strlen(force_author)) < 0)\n\t\t\tdie(_(\"malformed --author parameter\"));\n\t\tset_ident_var(&name, xmemdupz(ident.name_begin, ident.name_end - ident.name_begin));\n\t\tset_ident_var(&email, xmemdupz(ident.mail_begin, ident.mail_end - ident.mail_begin));\n\t}\n\n\tif (force_date) {\n\t\tstruct strbuf date_buf = STRBUF_INIT;\n\t\tif (parse_force_date(force_date, &date_buf))\n\t\t\tdie(_(\"invalid date format: %s\"), force_date);\n\t\tset_ident_var(&date, strbuf_detach(&date_buf, NULL));\n\t}\n\n\tstrbuf_addstr(author_ident, fmt_ident(name, email, date, IDENT_STRICT));\n\tassert_split_ident(&author, author_ident);\n\texport_one(\"GIT_AUTHOR_NAME\", author.name_begin, author.name_end, 0);\n\texport_one(\"GIT_AUTHOR_EMAIL\", author.mail_begin, author.mail_end, 0);\n\texport_one(\"GIT_AUTHOR_DATE\", author.date_begin, author.tz_end, '@');\n\tfree(name);\n\tfree(email);\n\tfree(date);\n}\n\nstatic int author_date_is_interesting(void)\n{\n\treturn author_message || force_date;\n}\n\nstatic void adjust_comment_line_char(const struct strbuf *sb)\n{\n\tchar candidates[] = \"#;@!$%^&|:\";\n\tchar *candidate;\n\tconst char *p;\n\n\tcomment_line_char = candidates[0];\n\tif (!memchr(sb->buf, comment_line_char, sb->len))\n\t\treturn;\n\n\tp = sb->buf;\n\tcandidate = strchr(candidates, *p);\n\tif (candidate)\n\t\t*candidate = ' ';\n\tfor (p = sb->buf; *p; p++) {\n\t\tif ((p[0] == '\\n' || p[0] == '\\r') && p[1]) {\n\t\t\tcandidate = strchr(candidates, p[1]);\n\t\t\tif (candidate)\n\t\t\t\t*candidate = ' ';\n\t\t}\n\t}\n\n\tfor (p = candidates; *p == ' '; p++)\n\t\t;\n\tif (!*p)\n\t\tdie(_(\"unable to select a comment character that is not used\\n\"\n\t\t      \"in the current commit message\"));\n\tcomment_line_char = *p;\n}\n\nstatic int prepare_to_commit(const char *index_file, const char *prefix,\n\t\t\t     struct commit *current_head,\n\t\t\t     struct wt_status *s,\n\t\t\t     struct strbuf *author_ident)\n{\n\tstruct stat statbuf;\n\tstruct strbuf committer_ident = STRBUF_INIT;\n\tint commitable;\n\tstruct strbuf sb = STRBUF_INIT;\n\tconst char *hook_arg1 = NULL;\n\tconst char *hook_arg2 = NULL;\n\tint clean_message_contents = (cleanup_mode != CLEANUP_NONE);\n\tint old_display_comment_prefix;\n\n\t/* This checks and barfs if author is badly specified */\n\tdetermine_author_info(author_ident);\n\n\tif (!no_verify && run_commit_hook(use_editor, index_file, \"pre-commit\", NULL))\n\t\treturn 0;\n\n\tif (squash_message) {\n\t\t/*\n\t\t * Insert the proper subject line before other commit\n\t\t * message options add their content.\n\t\t */\n\t\tif (use_message && !strcmp(use_message, squash_message))\n\t\t\tstrbuf_addstr(&sb, \"squash! \");\n\t\telse {\n\t\t\tstruct pretty_print_context ctx = {0};\n\t\t\tstruct commit *c;\n\t\t\tc = lookup_commit_reference_by_name(squash_message);\n\t\t\tif (!c)\n\t\t\t\tdie(_(\"could not lookup commit %s\"), squash_message);\n\t\t\tctx.output_encoding = get_commit_output_encoding();\n\t\t\tformat_commit_message(c, \"squash! %s\\n\\n\", &sb,\n\t\t\t\t\t      &ctx);\n\t\t}\n\t}\n\n\tif (have_option_m) {\n\t\tstrbuf_addbuf(&sb, &message);\n\t\thook_arg1 = \"message\";\n\t} else if (logfile && !strcmp(logfile, \"-\")) {\n\t\tif (isatty(0))\n\t\t\tfprintf(stderr, _(\"(reading log message from standard input)\\n\"));\n\t\tif (strbuf_read(&sb, 0, 0) < 0)\n\t\t\tdie_errno(_(\"could not read log from standard input\"));\n\t\thook_arg1 = \"message\";\n\t} else if (logfile) {\n\t\tif (strbuf_read_file(&sb, logfile, 0) < 0)\n\t\t\tdie_errno(_(\"could not read log file '%s'\"),\n\t\t\t\t  logfile);\n\t\thook_arg1 = \"message\";\n\t} else if (use_message) {\n\t\tchar *buffer;\n\t\tbuffer = strstr(use_message_buffer, \"\\n\\n\");\n\t\tif (buffer)\n\t\t\tstrbuf_addstr(&sb, skip_blank_lines(buffer + 2));\n\t\thook_arg1 = \"commit\";\n\t\thook_arg2 = use_message;\n\t} else if (fixup_message) {\n\t\tstruct pretty_print_context ctx = {0};\n\t\tstruct commit *commit;\n\t\tcommit = lookup_commit_reference_by_name(fixup_message);\n\t\tif (!commit)\n\t\t\tdie(_(\"could not lookup commit %s\"), fixup_message);\n\t\tctx.output_encoding = get_commit_output_encoding();\n\t\tformat_commit_message(commit, \"fixup! %s\\n\\n\",\n\t\t\t\t      &sb, &ctx);\n\t\thook_arg1 = \"message\";\n\t} else if (!stat(git_path_merge_msg(), &statbuf)) {\n\t\t/*\n\t\t * prepend SQUASH_MSG here if it exists and a\n\t\t * \"merge --squash\" was originally performed\n\t\t */\n\t\tif (!stat(git_path_squash_msg(), &statbuf)) {\n\t\t\tif (strbuf_read_file(&sb, git_path_squash_msg(), 0) < 0)\n\t\t\t\tdie_errno(_(\"could not read SQUASH_MSG\"));\n\t\t\thook_arg1 = \"squash\";\n\t\t} else\n\t\t\thook_arg1 = \"merge\";\n\t\tif (strbuf_read_file(&sb, git_path_merge_msg(), 0) < 0)\n\t\t\tdie_errno(_(\"could not read MERGE_MSG\"));\n\t} else if (!stat(git_path_squash_msg(), &statbuf)) {\n\t\tif (strbuf_read_file(&sb, git_path_squash_msg(), 0) < 0)\n\t\t\tdie_errno(_(\"could not read SQUASH_MSG\"));\n\t\thook_arg1 = \"squash\";\n\t} else if (template_file) {\n\t\tif (strbuf_read_file(&sb, template_file, 0) < 0)\n\t\t\tdie_errno(_(\"could not read '%s'\"), template_file);\n\t\thook_arg1 = \"template\";\n\t\tclean_message_contents = 0;\n\t}\n\n\t/*\n\t * The remaining cases don't modify the template message, but\n\t * just set the argument(s) to the prepare-commit-msg hook.\n\t */\n\telse if (whence == FROM_MERGE)\n\t\thook_arg1 = \"merge\";\n\telse if (whence == FROM_CHERRY_PICK) {\n\t\thook_arg1 = \"commit\";\n\t\thook_arg2 = \"CHERRY_PICK_HEAD\";\n\t}\n\n\tif (squash_message) {\n\t\t/*\n\t\t * If squash_commit was used for the commit subject,\n\t\t * then we're possibly hijacking other commit log options.\n\t\t * Reset the hook args to tell the real story.\n\t\t */\n\t\thook_arg1 = \"message\";\n\t\thook_arg2 = \"\";\n\t}\n\n\ts->fp = fopen_for_writing(git_path_commit_editmsg());\n\tif (s->fp == NULL)\n\t\tdie_errno(_(\"could not open '%s'\"), git_path_commit_editmsg());\n\n\t/* Ignore status.displayCommentPrefix: we do need comments in COMMIT_EDITMSG. */\n\told_display_comment_prefix = s->display_comment_prefix;\n\ts->display_comment_prefix = 1;\n\n\t/*\n\t * Most hints are counter-productive when the commit has\n\t * already started.\n\t */\n\ts->hints = 0;\n\n\tif (clean_message_contents)\n\t\tstrbuf_stripspace(&sb, 0);\n\n\tif (signoff)\n\t\tappend_signoff(&sb, ignore_non_trailer(sb.buf, sb.len), 0);\n\n\tif (fwrite(sb.buf, 1, sb.len, s->fp) < sb.len)\n\t\tdie_errno(_(\"could not write commit template\"));\n\n\tif (auto_comment_line_char)\n\t\tadjust_comment_line_char(&sb);\n\tstrbuf_release(&sb);\n\n\t/* This checks if committer ident is explicitly given */\n\tstrbuf_addstr(&committer_ident, git_committer_info(IDENT_STRICT));\n\tif (use_editor && include_status) {\n\t\tint ident_shown = 0;\n\t\tint saved_color_setting;\n\t\tstruct ident_split ci, ai;\n\n\t\tif (whence != FROM_COMMIT) {\n\t\t\tif (cleanup_mode == CLEANUP_SCISSORS)\n\t\t\t\twt_status_add_cut_line(s->fp);\n\t\t\tstatus_printf_ln(s, GIT_COLOR_NORMAL,\n\t\t\t    whence == FROM_MERGE\n\t\t\t\t? _(\"\\n\"\n\t\t\t\t\t\"It looks like you may be committing a merge.\\n\"\n\t\t\t\t\t\"If this is not correct, please remove the file\\n\"\n\t\t\t\t\t\"\t%s\\n\"\n\t\t\t\t\t\"and try again.\\n\")\n\t\t\t\t: _(\"\\n\"\n\t\t\t\t\t\"It looks like you may be committing a cherry-pick.\\n\"\n\t\t\t\t\t\"If this is not correct, please remove the file\\n\"\n\t\t\t\t\t\"\t%s\\n\"\n\t\t\t\t\t\"and try again.\\n\"),\n\t\t\t\twhence == FROM_MERGE ?\n\t\t\t\t\tgit_path_merge_head() :\n\t\t\t\t\tgit_path_cherry_pick_head());\n\t\t}\n\n\t\tfprintf(s->fp, \"\\n\");\n\t\tif (cleanup_mode == CLEANUP_ALL)\n\t\t\tstatus_printf(s, GIT_COLOR_NORMAL,\n\t\t\t\t_(\"Please enter the commit message for your changes.\"\n\t\t\t\t  \" Lines starting\\nwith '%c' will be ignored, and an empty\"\n\t\t\t\t  \" message aborts the commit.\\n\"), comment_line_char);\n\t\telse if (cleanup_mode == CLEANUP_SCISSORS && whence == FROM_COMMIT)\n\t\t\twt_status_add_cut_line(s->fp);\n\t\telse /* CLEANUP_SPACE, that is. */\n\t\t\tstatus_printf(s, GIT_COLOR_NORMAL,\n\t\t\t\t_(\"Please enter the commit message for your changes.\"\n\t\t\t\t  \" Lines starting\\n\"\n\t\t\t\t  \"with '%c' will be kept; you may remove them\"\n\t\t\t\t  \" yourself if you want to.\\n\"\n\t\t\t\t  \"An empty message aborts the commit.\\n\"), comment_line_char);\n\t\tif (only_include_assumed)\n\t\t\tstatus_printf_ln(s, GIT_COLOR_NORMAL,\n\t\t\t\t\t\"%s\", only_include_assumed);\n\n\t\t/*\n\t\t * These should never fail because they come from our own\n\t\t * fmt_ident. They may fail the sane_ident test, but we know\n\t\t * that the name and mail pointers will at least be valid,\n\t\t * which is enough for our tests and printing here.\n\t\t */\n\t\tassert_split_ident(&ai, author_ident);\n\t\tassert_split_ident(&ci, &committer_ident);\n\n\t\tif (ident_cmp(&ai, &ci))\n\t\t\tstatus_printf_ln(s, GIT_COLOR_NORMAL,\n\t\t\t\t_(\"%s\"\n\t\t\t\t\"Author:    %.*s <%.*s>\"),\n\t\t\t\tident_shown++ ? \"\" : \"\\n\",\n\t\t\t\t(int)(ai.name_end - ai.name_begin), ai.name_begin,\n\t\t\t\t(int)(ai.mail_end - ai.mail_begin), ai.mail_begin);\n\n\t\tif (author_date_is_interesting())\n\t\t\tstatus_printf_ln(s, GIT_COLOR_NORMAL,\n\t\t\t\t_(\"%s\"\n\t\t\t\t\"Date:      %s\"),\n\t\t\t\tident_shown++ ? \"\" : \"\\n\",\n\t\t\t\tshow_ident_date(&ai, DATE_MODE(NORMAL)));\n\n\t\tif (!committer_ident_sufficiently_given())\n\t\t\tstatus_printf_ln(s, GIT_COLOR_NORMAL,\n\t\t\t\t_(\"%s\"\n\t\t\t\t\"Committer: %.*s <%.*s>\"),\n\t\t\t\tident_shown++ ? \"\" : \"\\n\",\n\t\t\t\t(int)(ci.name_end - ci.name_begin), ci.name_begin,\n\t\t\t\t(int)(ci.mail_end - ci.mail_begin), ci.mail_begin);\n\n\t\tif (ident_shown)\n\t\t\tstatus_printf_ln(s, GIT_COLOR_NORMAL, \"%s\", \"\");\n\n\t\tsaved_color_setting = s->use_color;\n\t\ts->use_color = 0;\n\t\tcommitable = run_status(s->fp, index_file, prefix, 1, s);\n\t\ts->use_color = saved_color_setting;\n\t} else {\n\t\tstruct object_id oid;\n\t\tconst char *parent = \"HEAD\";\n\n\t\tif (!active_nr && read_cache() < 0)\n\t\t\tdie(_(\"Cannot read index\"));\n\n\t\tif (amend)\n\t\t\tparent = \"HEAD^1\";\n\n\t\tif (get_sha1(parent, oid.hash)) {\n\t\t\tint i, ita_nr = 0;\n\n\t\t\tfor (i = 0; i < active_nr; i++)\n\t\t\t\tif (ce_intent_to_add(active_cache[i]))\n\t\t\t\t\tita_nr++;\n\t\t\tcommitable = active_nr - ita_nr > 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Unless the user did explicitly request a submodule\n\t\t\t * ignore mode by passing a command line option we do\n\t\t\t * not ignore any changed submodule SHA-1s when\n\t\t\t * comparing index and parent, no matter what is\n\t\t\t * configured. Otherwise we won't commit any\n\t\t\t * submodules which were manually staged, which would\n\t\t\t * be really confusing.\n\t\t\t */\n\t\t\tint diff_flags = DIFF_OPT_OVERRIDE_SUBMODULE_CONFIG;\n\t\t\tif (ignore_submodule_arg &&\n\t\t\t    !strcmp(ignore_submodule_arg, \"all\"))\n\t\t\t\tdiff_flags |= DIFF_OPT_IGNORE_SUBMODULES;\n\t\t\tcommitable = index_differs_from(parent, diff_flags, 1);\n\t\t}\n\t}\n\tstrbuf_release(&committer_ident);\n\n\tfclose(s->fp);\n\n\t/*\n\t * Reject an attempt to record a non-merge empty commit without\n\t * explicit --allow-empty. In the cherry-pick case, it may be\n\t * empty due to conflict resolution, which the user should okay.\n\t */\n\tif (!commitable && whence != FROM_MERGE && !allow_empty &&\n\t    !(amend && is_a_merge(current_head))) {\n\t\ts->display_comment_prefix = old_display_comment_prefix;\n\t\trun_status(stdout, index_file, prefix, 0, s);\n\t\tif (amend)\n\t\t\tfputs(_(empty_amend_advice), stderr);\n\t\telse if (whence == FROM_CHERRY_PICK) {\n\t\t\tfputs(_(empty_cherry_pick_advice), stderr);\n\t\t\tif (!sequencer_in_use)\n\t\t\t\tfputs(_(empty_cherry_pick_advice_single), stderr);\n\t\t\telse\n\t\t\t\tfputs(_(empty_cherry_pick_advice_multi), stderr);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Re-read the index as pre-commit hook could have updated it,\n\t * and write it out as a tree.  We must do this before we invoke\n\t * the editor and after we invoke run_status above.\n\t */\n\tdiscard_cache();\n\tread_cache_from(index_file);\n\tif (update_main_cache_tree(0)) {\n\t\terror(_(\"Error building trees\"));\n\t\treturn 0;\n\t}\n\n\tif (run_commit_hook(use_editor, index_file, \"prepare-commit-msg\",\n\t\t\t    git_path_commit_editmsg(), hook_arg1, hook_arg2, NULL))\n\t\treturn 0;\n\n\tif (use_editor) {\n\t\tstruct argv_array env = ARGV_ARRAY_INIT;\n\n\t\targv_array_pushf(&env, \"GIT_INDEX_FILE=%s\", index_file);\n\t\tif (launch_editor(git_path_commit_editmsg(), NULL, env.argv)) {\n\t\t\tfprintf(stderr,\n\t\t\t_(\"Please supply the message using either -m or -F option.\\n\"));\n\t\t\texit(1);\n\t\t}\n\t\targv_array_clear(&env);\n\t}\n\n\tif (!no_verify &&\n\t    run_commit_hook(use_editor, index_file, \"commit-msg\", git_path_commit_editmsg(), NULL)) {\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int rest_is_empty(struct strbuf *sb, int start)\n{\n\tint i, eol;\n\tconst char *nl;\n\n\t/* Check if the rest is just whitespace and Signed-of-by's. */\n\tfor (i = start; i < sb->len; i++) {\n\t\tnl = memchr(sb->buf + i, '\\n', sb->len - i);\n\t\tif (nl)\n\t\t\teol = nl - sb->buf;\n\t\telse\n\t\t\teol = sb->len;\n\n\t\tif (strlen(sign_off_header) <= eol - i &&\n\t\t    starts_with(sb->buf + i, sign_off_header)) {\n\t\t\ti = eol;\n\t\t\tcontinue;\n\t\t}\n\t\twhile (i < eol)\n\t\t\tif (!isspace(sb->buf[i++]))\n\t\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n/*\n * Find out if the message in the strbuf contains only whitespace and\n * Signed-off-by lines.\n */\nstatic int message_is_empty(struct strbuf *sb)\n{\n\tif (cleanup_mode == CLEANUP_NONE && sb->len)\n\t\treturn 0;\n\treturn rest_is_empty(sb, 0);\n}\n\n/*\n * See if the user edited the message in the editor or left what\n * was in the template intact\n */\nstatic int template_untouched(struct strbuf *sb)\n{\n\tstruct strbuf tmpl = STRBUF_INIT;\n\tconst char *start;\n\n\tif (cleanup_mode == CLEANUP_NONE && sb->len)\n\t\treturn 0;\n\n\tif (!template_file || strbuf_read_file(&tmpl, template_file, 0) <= 0)\n\t\treturn 0;\n\n\tstrbuf_stripspace(&tmpl, cleanup_mode == CLEANUP_ALL);\n\tif (!skip_prefix(sb->buf, tmpl.buf, &start))\n\t\tstart = sb->buf;\n\tstrbuf_release(&tmpl);\n\treturn rest_is_empty(sb, start - sb->buf);\n}\n\nstatic const char *find_author_by_nickname(const char *name)\n{\n\tstruct rev_info revs;\n\tstruct commit *commit;\n\tstruct strbuf buf = STRBUF_INIT;\n\tstruct string_list mailmap = STRING_LIST_INIT_NODUP;\n\tconst char *av[20];\n\tint ac = 0;\n\n\tinit_revisions(&revs, NULL);\n\tstrbuf_addf(&buf, \"--author=%s\", name);\n\tav[++ac] = \"--all\";\n\tav[++ac] = \"-i\";\n\tav[++ac] = buf.buf;\n\tav[++ac] = NULL;\n\tsetup_revisions(ac, av, &revs, NULL);\n\trevs.mailmap = &mailmap;\n\tread_mailmap(revs.mailmap, NULL);\n\n\tif (prepare_revision_walk(&revs))\n\t\tdie(_(\"revision walk setup failed\"));\n\tcommit = get_revision(&revs);\n\tif (commit) {\n\t\tstruct pretty_print_context ctx = {0};\n\t\tctx.date_mode.type = DATE_NORMAL;\n\t\tstrbuf_release(&buf);\n\t\tformat_commit_message(commit, \"%aN <%aE>\", &buf, &ctx);\n\t\tclear_mailmap(&mailmap);\n\t\treturn strbuf_detach(&buf, NULL);\n\t}\n\tdie(_(\"--author '%s' is not 'Name <email>' and matches no existing author\"), name);\n}\n\n\nstatic void handle_untracked_files_arg(struct wt_status *s)\n{\n\tif (!untracked_files_arg)\n\t\t; /* default already initialized */\n\telse if (!strcmp(untracked_files_arg, \"no\"))\n\t\ts->show_untracked_files = SHOW_NO_UNTRACKED_FILES;\n\telse if (!strcmp(untracked_files_arg, \"normal\"))\n\t\ts->show_untracked_files = SHOW_NORMAL_UNTRACKED_FILES;\n\telse if (!strcmp(untracked_files_arg, \"all\"))\n\t\ts->show_untracked_files = SHOW_ALL_UNTRACKED_FILES;\n\telse\n\t\tdie(_(\"Invalid untracked files mode '%s'\"), untracked_files_arg);\n}\n\nstatic const char *read_commit_message(const char *name)\n{\n\tconst char *out_enc;\n\tstruct commit *commit;\n\n\tcommit = lookup_commit_reference_by_name(name);\n\tif (!commit)\n\t\tdie(_(\"could not lookup commit %s\"), name);\n\tout_enc = get_commit_output_encoding();\n\treturn logmsg_reencode(commit, NULL, out_enc);\n}\n\n/*\n * Enumerate what needs to be propagated when --porcelain\n * is not in effect here.\n */\nstatic struct status_deferred_config {\n\tenum wt_status_format status_format;\n\tint show_branch;\n} status_deferred_config = {\n\tSTATUS_FORMAT_UNSPECIFIED,\n\t-1 /* unspecified */\n};\n\nstatic void finalize_deferred_config(struct wt_status *s)\n{\n\tint use_deferred_config = (status_format != STATUS_FORMAT_PORCELAIN &&\n\t\t\t\t   status_format != STATUS_FORMAT_PORCELAIN_V2 &&\n\t\t\t\t   !s->null_termination);\n\n\tif (s->null_termination) {\n\t\tif (status_format == STATUS_FORMAT_NONE ||\n\t\t    status_format == STATUS_FORMAT_UNSPECIFIED)\n\t\t\tstatus_format = STATUS_FORMAT_PORCELAIN;\n\t\telse if (status_format == STATUS_FORMAT_LONG)\n\t\t\tdie(_(\"--long and -z are incompatible\"));\n\t}\n\n\tif (use_deferred_config && status_format == STATUS_FORMAT_UNSPECIFIED)\n\t\tstatus_format = status_deferred_config.status_format;\n\tif (status_format == STATUS_FORMAT_UNSPECIFIED)\n\t\tstatus_format = STATUS_FORMAT_NONE;\n\n\tif (use_deferred_config && s->show_branch < 0)\n\t\ts->show_branch = status_deferred_config.show_branch;\n\tif (s->show_branch < 0)\n\t\ts->show_branch = 0;\n}\n\nstatic int parse_and_validate_options(int argc, const char *argv[],\n\t\t\t\t      const struct option *options,\n\t\t\t\t      const char * const usage[],\n\t\t\t\t      const char *prefix,\n\t\t\t\t      struct commit *current_head,\n\t\t\t\t      struct wt_status *s)\n{\n\tint f = 0;\n\n\targc = parse_options(argc, argv, prefix, options, usage, 0);\n\tfinalize_deferred_config(s);\n\n\tif (force_author && !strchr(force_author, '>'))\n\t\tforce_author = find_author_by_nickname(force_author);\n\n\tif (force_author && renew_authorship)\n\t\tdie(_(\"Using both --reset-author and --author does not make sense\"));\n\n\tif (logfile || have_option_m || use_message || fixup_message)\n\t\tuse_editor = 0;\n\tif (0 <= edit_flag)\n\t\tuse_editor = edit_flag;\n\n\t/* Sanity check options */\n\tif (amend && !current_head)\n\t\tdie(_(\"You have nothing to amend.\"));\n\tif (amend && whence != FROM_COMMIT) {\n\t\tif (whence == FROM_MERGE)\n\t\t\tdie(_(\"You are in the middle of a merge -- cannot amend.\"));\n\t\telse if (whence == FROM_CHERRY_PICK)\n\t\t\tdie(_(\"You are in the middle of a cherry-pick -- cannot amend.\"));\n\t}\n\tif (fixup_message && squash_message)\n\t\tdie(_(\"Options --squash and --fixup cannot be used together\"));\n\tif (use_message)\n\t\tf++;\n\tif (edit_message)\n\t\tf++;\n\tif (fixup_message)\n\t\tf++;\n\tif (logfile)\n\t\tf++;\n\tif (f > 1)\n\t\tdie(_(\"Only one of -c/-C/-F/--fixup can be used.\"));\n\tif (have_option_m && f > 0)\n\t\tdie((_(\"Option -m cannot be combined with -c/-C/-F/--fixup.\")));\n\tif (f || have_option_m)\n\t\ttemplate_file = NULL;\n\tif (edit_message)\n\t\tuse_message = edit_message;\n\tif (amend && !use_message && !fixup_message)\n\t\tuse_message = \"HEAD\";\n\tif (!use_message && whence != FROM_CHERRY_PICK && renew_authorship)\n\t\tdie(_(\"--reset-author can be used only with -C, -c or --amend.\"));\n\tif (use_message) {\n\t\tuse_message_buffer = read_commit_message(use_message);\n\t\tif (!renew_authorship) {\n\t\t\tauthor_message = use_message;\n\t\t\tauthor_message_buffer = use_message_buffer;\n\t\t}\n\t}\n\tif (whence == FROM_CHERRY_PICK && !renew_authorship) {\n\t\tauthor_message = \"CHERRY_PICK_HEAD\";\n\t\tauthor_message_buffer = read_commit_message(author_message);\n\t}\n\n\tif (patch_interactive)\n\t\tinteractive = 1;\n\n\tif (also + only + all + interactive > 1)\n\t\tdie(_(\"Only one of --include/--only/--all/--interactive/--patch can be used.\"));\n\tif (argc == 0 && (also || (only && !amend && !allow_empty)))\n\t\tdie(_(\"No paths with --include/--only does not make sense.\"));\n\tif (argc > 0 && !also && !only)\n\t\tonly_include_assumed = _(\"Explicit paths specified without -i or -o; assuming --only paths...\");\n\tif (!cleanup_arg || !strcmp(cleanup_arg, \"default\"))\n\t\tcleanup_mode = use_editor ? CLEANUP_ALL : CLEANUP_SPACE;\n\telse if (!strcmp(cleanup_arg, \"verbatim\"))\n\t\tcleanup_mode = CLEANUP_NONE;\n\telse if (!strcmp(cleanup_arg, \"whitespace\"))\n\t\tcleanup_mode = CLEANUP_SPACE;\n\telse if (!strcmp(cleanup_arg, \"strip\"))\n\t\tcleanup_mode = CLEANUP_ALL;\n\telse if (!strcmp(cleanup_arg, \"scissors\"))\n\t\tcleanup_mode = use_editor ? CLEANUP_SCISSORS : CLEANUP_SPACE;\n\telse\n\t\tdie(_(\"Invalid cleanup mode %s\"), cleanup_arg);\n\n\thandle_untracked_files_arg(s);\n\n\tif (all && argc > 0)\n\t\tdie(_(\"Paths with -a does not make sense.\"));\n\n\tif (status_format != STATUS_FORMAT_NONE)\n\t\tdry_run = 1;\n\n\treturn argc;\n}\n\nstatic int dry_run_commit(int argc, const char **argv, const char *prefix,\n\t\t\t  const struct commit *current_head, struct wt_status *s)\n{\n\tint commitable;\n\tconst char *index_file;\n\n\tindex_file = prepare_index(argc, argv, prefix, current_head, 1);\n\tcommitable = run_status(stdout, index_file, prefix, 0, s);\n\trollback_index_files();\n\n\treturn commitable ? 0 : 1;\n}\n\nstatic int parse_status_slot(const char *slot)\n{\n\tif (!strcasecmp(slot, \"header\"))\n\t\treturn WT_STATUS_HEADER;\n\tif (!strcasecmp(slot, \"branch\"))\n\t\treturn WT_STATUS_ONBRANCH;\n\tif (!strcasecmp(slot, \"updated\") || !strcasecmp(slot, \"added\"))\n\t\treturn WT_STATUS_UPDATED;\n\tif (!strcasecmp(slot, \"changed\"))\n\t\treturn WT_STATUS_CHANGED;\n\tif (!strcasecmp(slot, \"untracked\"))\n\t\treturn WT_STATUS_UNTRACKED;\n\tif (!strcasecmp(slot, \"nobranch\"))\n\t\treturn WT_STATUS_NOBRANCH;\n\tif (!strcasecmp(slot, \"unmerged\"))\n\t\treturn WT_STATUS_UNMERGED;\n\tif (!strcasecmp(slot, \"localBranch\"))\n\t\treturn WT_STATUS_LOCAL_BRANCH;\n\tif (!strcasecmp(slot, \"remoteBranch\"))\n\t\treturn WT_STATUS_REMOTE_BRANCH;\n\treturn -1;\n}\n\nstatic int git_status_config(const char *k, const char *v, void *cb)\n{\n\tstruct wt_status *s = cb;\n\tconst char *slot_name;\n\n\tif (starts_with(k, \"column.\"))\n\t\treturn git_column_config(k, v, \"status\", &s->colopts);\n\tif (!strcmp(k, \"status.submodulesummary\")) {\n\t\tint is_bool;\n\t\ts->submodule_summary = git_config_bool_or_int(k, v, &is_bool);\n\t\tif (is_bool && s->submodule_summary)\n\t\t\ts->submodule_summary = -1;\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"status.short\")) {\n\t\tif (git_config_bool(k, v))\n\t\t\tstatus_deferred_config.status_format = STATUS_FORMAT_SHORT;\n\t\telse\n\t\t\tstatus_deferred_config.status_format = STATUS_FORMAT_NONE;\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"status.branch\")) {\n\t\tstatus_deferred_config.show_branch = git_config_bool(k, v);\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"status.showstash\")) {\n\t\ts->show_stash = git_config_bool(k, v);\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"status.color\") || !strcmp(k, \"color.status\")) {\n\t\ts->use_color = git_config_colorbool(k, v);\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"status.displaycommentprefix\")) {\n\t\ts->display_comment_prefix = git_config_bool(k, v);\n\t\treturn 0;\n\t}\n\tif (skip_prefix(k, \"status.color.\", &slot_name) ||\n\t    skip_prefix(k, \"color.status.\", &slot_name)) {\n\t\tint slot = parse_status_slot(slot_name);\n\t\tif (slot < 0)\n\t\t\treturn 0;\n\t\tif (!v)\n\t\t\treturn config_error_nonbool(k);\n\t\treturn color_parse(v, s->color_palette[slot]);\n\t}\n\tif (!strcmp(k, \"status.relativepaths\")) {\n\t\ts->relative_paths = git_config_bool(k, v);\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"status.showuntrackedfiles\")) {\n\t\tif (!v)\n\t\t\treturn config_error_nonbool(k);\n\t\telse if (!strcmp(v, \"no\"))\n\t\t\ts->show_untracked_files = SHOW_NO_UNTRACKED_FILES;\n\t\telse if (!strcmp(v, \"normal\"))\n\t\t\ts->show_untracked_files = SHOW_NORMAL_UNTRACKED_FILES;\n\t\telse if (!strcmp(v, \"all\"))\n\t\t\ts->show_untracked_files = SHOW_ALL_UNTRACKED_FILES;\n\t\telse\n\t\t\treturn error(_(\"Invalid untracked files mode '%s'\"), v);\n\t\treturn 0;\n\t}\n\treturn git_diff_ui_config(k, v, NULL);\n}\n\nint cmd_status(int argc, const char **argv, const char *prefix)\n{\n\tstatic struct wt_status s;\n\tint fd;\n\tstruct object_id oid;\n\tstatic struct option builtin_status_options[] = {\n\t\tOPT__VERBOSE(&verbose, N_(\"be verbose\")),\n\t\tOPT_SET_INT('s', \"short\", &status_format,\n\t\t\t    N_(\"show status concisely\"), STATUS_FORMAT_SHORT),\n\t\tOPT_BOOL('b', \"branch\", &s.show_branch,\n\t\t\t N_(\"show branch information\")),\n\t\tOPT_BOOL(0, \"show-stash\", &s.show_stash,\n\t\t\t N_(\"show stash information\")),\n\t\t{ OPTION_CALLBACK, 0, \"porcelain\", &status_format,\n\t\t  N_(\"version\"), N_(\"machine-readable output\"),\n\t\t  PARSE_OPT_OPTARG, opt_parse_porcelain },\n\t\tOPT_SET_INT(0, \"long\", &status_format,\n\t\t\t    N_(\"show status in long format (default)\"),\n\t\t\t    STATUS_FORMAT_LONG),\n\t\tOPT_BOOL('z', \"null\", &s.null_termination,\n\t\t\t N_(\"terminate entries with NUL\")),\n\t\t{ OPTION_STRING, 'u', \"untracked-files\", &untracked_files_arg,\n\t\t  N_(\"mode\"),\n\t\t  N_(\"show untracked files, optional modes: all, normal, no. (Default: all)\"),\n\t\t  PARSE_OPT_OPTARG, NULL, (intptr_t)\"all\" },\n\t\tOPT_BOOL(0, \"ignored\", &show_ignored_in_status,\n\t\t\t N_(\"show ignored files\")),\n\t\t{ OPTION_STRING, 0, \"ignore-submodules\", &ignore_submodule_arg, N_(\"when\"),\n\t\t  N_(\"ignore changes to submodules, optional when: all, dirty, untracked. (Default: all)\"),\n\t\t  PARSE_OPT_OPTARG, NULL, (intptr_t)\"all\" },\n\t\tOPT_COLUMN(0, \"column\", &s.colopts, N_(\"list untracked files in columns\")),\n\t\tOPT_END(),\n\t};\n\n\tif (argc == 2 && !strcmp(argv[1], \"-h\"))\n\t\tusage_with_options(builtin_status_usage, builtin_status_options);\n\n\tstatus_init_config(&s, git_status_config);\n\targc = parse_options(argc, argv, prefix,\n\t\t\t     builtin_status_options,\n\t\t\t     builtin_status_usage, 0);\n\tfinalize_colopts(&s.colopts, -1);\n\tfinalize_deferred_config(&s);\n\n\thandle_untracked_files_arg(&s);\n\tif (show_ignored_in_status)\n\t\ts.show_ignored_files = 1;\n\tparse_pathspec(&s.pathspec, 0,\n\t\t       PATHSPEC_PREFER_FULL,\n\t\t       prefix, argv);\n\n\tread_cache_preload(&s.pathspec);\n\trefresh_index(&the_index, REFRESH_QUIET|REFRESH_UNMERGED, &s.pathspec, NULL, NULL);\n\n\tfd = hold_locked_index(&index_lock, 0);\n\n\ts.is_initial = get_sha1(s.reference, oid.hash) ? 1 : 0;\n\tif (!s.is_initial)\n\t\thashcpy(s.sha1_commit, oid.hash);\n\n\ts.ignore_submodule_arg = ignore_submodule_arg;\n\ts.status_format = status_format;\n\ts.verbose = verbose;\n\n\twt_status_collect(&s);\n\n\tif (0 <= fd)\n\t\tupdate_index_if_able(&the_index, &index_lock);\n\n\tif (s.relative_paths)\n\t\ts.prefix = prefix;\n\n\twt_status_print(&s);\n\treturn 0;\n}\n\nstatic const char *implicit_ident_advice(void)\n{\n\tchar *user_config = expand_user_path(\"~/.gitconfig\", 0);\n\tchar *xdg_config = xdg_config_home(\"config\");\n\tint config_exists = file_exists(user_config) || file_exists(xdg_config);\n\n\tfree(user_config);\n\tfree(xdg_config);\n\n\tif (config_exists)\n\t\treturn _(implicit_ident_advice_config);\n\telse\n\t\treturn _(implicit_ident_advice_noconfig);\n\n}\n\nstatic void print_summary(const char *prefix, const struct object_id *oid,\n\t\t\t  int initial_commit)\n{\n\tstruct rev_info rev;\n\tstruct commit *commit;\n\tstruct strbuf format = STRBUF_INIT;\n\tstruct object_id junk_oid;\n\tconst char *head;\n\tstruct pretty_print_context pctx = {0};\n\tstruct strbuf author_ident = STRBUF_INIT;\n\tstruct strbuf committer_ident = STRBUF_INIT;\n\n\tcommit = lookup_commit(oid);\n\tif (!commit)\n\t\tdie(_(\"couldn't look up newly created commit\"));\n\tif (parse_commit(commit))\n\t\tdie(_(\"could not parse newly created commit\"));\n\n\tstrbuf_addstr(&format, \"format:%h] %s\");\n\n\tformat_commit_message(commit, \"%an <%ae>\", &author_ident, &pctx);\n\tformat_commit_message(commit, \"%cn <%ce>\", &committer_ident, &pctx);\n\tif (strbuf_cmp(&author_ident, &committer_ident)) {\n\t\tstrbuf_addstr(&format, \"\\n Author: \");\n\t\tstrbuf_addbuf_percentquote(&format, &author_ident);\n\t}\n\tif (author_date_is_interesting()) {\n\t\tstruct strbuf date = STRBUF_INIT;\n\t\tformat_commit_message(commit, \"%ad\", &date, &pctx);\n\t\tstrbuf_addstr(&format, \"\\n Date: \");\n\t\tstrbuf_addbuf_percentquote(&format, &date);\n\t\tstrbuf_release(&date);\n\t}\n\tif (!committer_ident_sufficiently_given()) {\n\t\tstrbuf_addstr(&format, \"\\n Committer: \");\n\t\tstrbuf_addbuf_percentquote(&format, &committer_ident);\n\t\tif (advice_implicit_identity) {\n\t\t\tstrbuf_addch(&format, '\\n');\n\t\t\tstrbuf_addstr(&format, implicit_ident_advice());\n\t\t}\n\t}\n\tstrbuf_release(&author_ident);\n\tstrbuf_release(&committer_ident);\n\n\tinit_revisions(&rev, prefix);\n\tsetup_revisions(0, NULL, &rev, NULL);\n\n\trev.diff = 1;\n\trev.diffopt.output_format =\n\t\tDIFF_FORMAT_SHORTSTAT | DIFF_FORMAT_SUMMARY;\n\n\trev.verbose_header = 1;\n\trev.show_root_diff = 1;\n\tget_commit_format(format.buf, &rev);\n\trev.always_show_header = 0;\n\trev.diffopt.detect_rename = 1;\n\trev.diffopt.break_opt = 0;\n\tdiff_setup_done(&rev.diffopt);\n\n\thead = resolve_ref_unsafe(\"HEAD\", 0, junk_oid.hash, NULL);\n\tif (!strcmp(head, \"HEAD\"))\n\t\thead = _(\"detached HEAD\");\n\telse\n\t\tskip_prefix(head, \"refs/heads/\", &head);\n\tprintf(\"[%s%s \", head, initial_commit ? _(\" (root-commit)\") : \"\");\n\n\tif (!log_tree_commit(&rev, commit)) {\n\t\trev.always_show_header = 1;\n\t\trev.use_terminator = 1;\n\t\tlog_tree_commit(&rev, commit);\n\t}\n\n\tstrbuf_release(&format);\n}\n\nstatic int git_commit_config(const char *k, const char *v, void *cb)\n{\n\tstruct wt_status *s = cb;\n\tint status;\n\n\tif (!strcmp(k, \"commit.template\"))\n\t\treturn git_config_pathname(&template_file, k, v);\n\tif (!strcmp(k, \"commit.status\")) {\n\t\tinclude_status = git_config_bool(k, v);\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"commit.cleanup\"))\n\t\treturn git_config_string(&cleanup_arg, k, v);\n\tif (!strcmp(k, \"commit.gpgsign\")) {\n\t\tsign_commit = git_config_bool(k, v) ? \"\" : NULL;\n\t\treturn 0;\n\t}\n\tif (!strcmp(k, \"commit.verbose\")) {\n\t\tint is_bool;\n\t\tconfig_commit_verbose = git_config_bool_or_int(k, v, &is_bool);\n\t\treturn 0;\n\t}\n\n\tstatus = git_gpg_config(k, v, NULL);\n\tif (status)\n\t\treturn status;\n\treturn git_status_config(k, v, s);\n}\n\nstatic int run_rewrite_hook(const struct object_id *oldoid,\n\t\t\t    const struct object_id *newoid)\n{\n\tstruct child_process proc = CHILD_PROCESS_INIT;\n\tconst char *argv[3];\n\tint code;\n\tstruct strbuf sb = STRBUF_INIT;\n\n\targv[0] = find_hook(\"post-rewrite\");\n\tif (!argv[0])\n\t\treturn 0;\n\n\targv[1] = \"amend\";\n\targv[2] = NULL;\n\n\tproc.argv = argv;\n\tproc.in = -1;\n\tproc.stdout_to_stderr = 1;\n\n\tcode = start_command(&proc);\n\tif (code)\n\t\treturn code;\n\tstrbuf_addf(&sb, \"%s %s\\n\", oid_to_hex(oldoid), oid_to_hex(newoid));\n\tsigchain_push(SIGPIPE, SIG_IGN);\n\twrite_in_full(proc.in, sb.buf, sb.len);\n\tclose(proc.in);\n\tstrbuf_release(&sb);\n\tsigchain_pop(SIGPIPE);\n\treturn finish_command(&proc);\n}\n\nint run_commit_hook(int editor_is_used, const char *index_file, const char *name, ...)\n{\n\tstruct argv_array hook_env = ARGV_ARRAY_INIT;\n\tva_list args;\n\tint ret;\n\n\targv_array_pushf(&hook_env, \"GIT_INDEX_FILE=%s\", index_file);\n\n\t/*\n\t * Let the hook know that no editor will be launched.\n\t */\n\tif (!editor_is_used)\n\t\targv_array_push(&hook_env, \"GIT_EDITOR=:\");\n\n\tva_start(args, name);\n\tret = run_hook_ve(hook_env.argv,name, args);\n\tva_end(args);\n\targv_array_clear(&hook_env);\n\n\treturn ret;\n}\n\nint cmd_commit(int argc, const char **argv, const char *prefix)\n{\n\tstatic struct wt_status s;\n\tstatic struct option builtin_commit_options[] = {\n\t\tOPT__QUIET(&quiet, N_(\"suppress summary after successful commit\")),\n\t\tOPT__VERBOSE(&verbose, N_(\"show diff in commit message template\")),\n\n\t\tOPT_GROUP(N_(\"Commit message options\")),\n\t\tOPT_FILENAME('F', \"file\", &logfile, N_(\"read message from file\")),\n\t\tOPT_STRING(0, \"author\", &force_author, N_(\"author\"), N_(\"override author for commit\")),\n\t\tOPT_STRING(0, \"date\", &force_date, N_(\"date\"), N_(\"override date for commit\")),\n\t\tOPT_CALLBACK('m', \"message\", &message, N_(\"message\"), N_(\"commit message\"), opt_parse_m),\n\t\tOPT_STRING('c', \"reedit-message\", &edit_message, N_(\"commit\"), N_(\"reuse and edit message from specified commit\")),\n\t\tOPT_STRING('C', \"reuse-message\", &use_message, N_(\"commit\"), N_(\"reuse message from specified commit\")),\n\t\tOPT_STRING(0, \"fixup\", &fixup_message, N_(\"commit\"), N_(\"use autosquash formatted message to fixup specified commit\")),\n\t\tOPT_STRING(0, \"squash\", &squash_message, N_(\"commit\"), N_(\"use autosquash formatted message to squash specified commit\")),\n\t\tOPT_BOOL(0, \"reset-author\", &renew_authorship, N_(\"the commit is authored by me now (used with -C/-c/--amend)\")),\n\t\tOPT_BOOL('s', \"signoff\", &signoff, N_(\"add Signed-off-by:\")),\n\t\tOPT_FILENAME('t', \"template\", &template_file, N_(\"use specified template file\")),\n\t\tOPT_BOOL('e', \"edit\", &edit_flag, N_(\"force edit of commit\")),\n\t\tOPT_STRING(0, \"cleanup\", &cleanup_arg, N_(\"default\"), N_(\"how to strip spaces and #comments from message\")),\n\t\tOPT_BOOL(0, \"status\", &include_status, N_(\"include status in commit message template\")),\n\t\t{ OPTION_STRING, 'S', \"gpg-sign\", &sign_commit, N_(\"key-id\"),\n\t\t  N_(\"GPG sign commit\"), PARSE_OPT_OPTARG, NULL, (intptr_t) \"\" },\n\t\t/* end commit message options */\n\n\t\tOPT_GROUP(N_(\"Commit contents options\")),\n\t\tOPT_BOOL('a', \"all\", &all, N_(\"commit all changed files\")),\n\t\tOPT_BOOL('i', \"include\", &also, N_(\"add specified files to index for commit\")),\n\t\tOPT_BOOL(0, \"interactive\", &interactive, N_(\"interactively add files\")),\n\t\tOPT_BOOL('p', \"patch\", &patch_interactive, N_(\"interactively add changes\")),\n\t\tOPT_BOOL('o', \"only\", &only, N_(\"commit only specified files\")),\n\t\tOPT_BOOL('n', \"no-verify\", &no_verify, N_(\"bypass pre-commit and commit-msg hooks\")),\n\t\tOPT_BOOL(0, \"dry-run\", &dry_run, N_(\"show what would be committed\")),\n\t\tOPT_SET_INT(0, \"short\", &status_format, N_(\"show status concisely\"),\n\t\t\t    STATUS_FORMAT_SHORT),\n\t\tOPT_BOOL(0, \"branch\", &s.show_branch, N_(\"show branch information\")),\n\t\tOPT_SET_INT(0, \"porcelain\", &status_format,\n\t\t\t    N_(\"machine-readable output\"), STATUS_FORMAT_PORCELAIN),\n\t\tOPT_SET_INT(0, \"long\", &status_format,\n\t\t\t    N_(\"show status in long format (default)\"),\n\t\t\t    STATUS_FORMAT_LONG),\n\t\tOPT_BOOL('z', \"null\", &s.null_termination,\n\t\t\t N_(\"terminate entries with NUL\")),\n\t\tOPT_BOOL(0, \"amend\", &amend, N_(\"amend previous commit\")),\n\t\tOPT_BOOL(0, \"no-post-rewrite\", &no_post_rewrite, N_(\"bypass post-rewrite hook\")),\n\t\t{ OPTION_STRING, 'u', \"untracked-files\", &untracked_files_arg, N_(\"mode\"), N_(\"show untracked files, optional modes: all, normal, no. (Default: all)\"), PARSE_OPT_OPTARG, NULL, (intptr_t)\"all\" },\n\t\t/* end commit contents options */\n\n\t\tOPT_HIDDEN_BOOL(0, \"allow-empty\", &allow_empty,\n\t\t\t\tN_(\"ok to record an empty change\")),\n\t\tOPT_HIDDEN_BOOL(0, \"allow-empty-message\", &allow_empty_message,\n\t\t\t\tN_(\"ok to record a change with an empty message\")),\n\n\t\tOPT_END()\n\t};\n\n\tstruct strbuf sb = STRBUF_INIT;\n\tstruct strbuf author_ident = STRBUF_INIT;\n\tconst char *index_file, *reflog_msg;\n\tchar *nl;\n\tstruct object_id oid;\n\tstruct commit_list *parents = NULL;\n\tstruct stat statbuf;\n\tstruct commit *current_head = NULL;\n\tstruct commit_extra_header *extra = NULL;\n\tstruct ref_transaction *transaction;\n\tstruct strbuf err = STRBUF_INIT;\n\n\tif (argc == 2 && !strcmp(argv[1], \"-h\"))\n\t\tusage_with_options(builtin_commit_usage, builtin_commit_options);\n\n\tstatus_init_config(&s, git_commit_config);\n\tstatus_format = STATUS_FORMAT_NONE; /* Ignore status.short */\n\ts.colopts = 0;\n\n\tif (get_sha1(\"HEAD\", oid.hash))\n\t\tcurrent_head = NULL;\n\telse {\n\t\tcurrent_head = lookup_commit_or_die(&oid, \"HEAD\");\n\t\tif (parse_commit(current_head))\n\t\t\tdie(_(\"could not parse HEAD commit\"));\n\t}\n\tverbose = -1; /* unspecified */\n\targc = parse_and_validate_options(argc, argv, builtin_commit_options,\n\t\t\t\t\t  builtin_commit_usage,\n\t\t\t\t\t  prefix, current_head, &s);\n\tif (verbose == -1)\n\t\tverbose = (config_commit_verbose < 0) ? 0 : config_commit_verbose;\n\n\tif (dry_run)\n\t\treturn dry_run_commit(argc, argv, prefix, current_head, &s);\n\tindex_file = prepare_index(argc, argv, prefix, current_head, 0);\n\n\t/* Set up everything for writing the commit object.  This includes\n\t   running hooks, writing the trees, and interacting with the user.  */\n\tif (!prepare_to_commit(index_file, prefix,\n\t\t\t       current_head, &s, &author_ident)) {\n\t\trollback_index_files();\n\t\treturn 1;\n\t}\n\n\t/* Determine parents */\n\treflog_msg = getenv(\"GIT_REFLOG_ACTION\");\n\tif (!current_head) {\n\t\tif (!reflog_msg)\n\t\t\treflog_msg = \"commit (initial)\";\n\t} else if (amend) {\n\t\tif (!reflog_msg)\n\t\t\treflog_msg = \"commit (amend)\";\n\t\tparents = copy_commit_list(current_head->parents);\n\t} else if (whence == FROM_MERGE) {\n\t\tstruct strbuf m = STRBUF_INIT;\n\t\tFILE *fp;\n\t\tint allow_fast_forward = 1;\n\t\tstruct commit_list **pptr = &parents;\n\n\t\tif (!reflog_msg)\n\t\t\treflog_msg = \"commit (merge)\";\n\t\tpptr = commit_list_append(current_head, pptr);\n\t\tfp = xfopen(git_path_merge_head(), \"r\");\n\t\twhile (strbuf_getline_lf(&m, fp) != EOF) {\n\t\t\tstruct commit *parent;\n\n\t\t\tparent = get_merge_parent(m.buf);\n\t\t\tif (!parent)\n\t\t\t\tdie(_(\"Corrupt MERGE_HEAD file (%s)\"), m.buf);\n\t\t\tpptr = commit_list_append(parent, pptr);\n\t\t}\n\t\tfclose(fp);\n\t\tstrbuf_release(&m);\n\t\tif (!stat(git_path_merge_mode(), &statbuf)) {\n\t\t\tif (strbuf_read_file(&sb, git_path_merge_mode(), 0) < 0)\n\t\t\t\tdie_errno(_(\"could not read MERGE_MODE\"));\n\t\t\tif (!strcmp(sb.buf, \"no-ff\"))\n\t\t\t\tallow_fast_forward = 0;\n\t\t}\n\t\tif (allow_fast_forward)\n\t\t\tparents = reduce_heads(parents);\n\t} else {\n\t\tif (!reflog_msg)\n\t\t\treflog_msg = (whence == FROM_CHERRY_PICK)\n\t\t\t\t\t? \"commit (cherry-pick)\"\n\t\t\t\t\t: \"commit\";\n\t\tcommit_list_insert(current_head, &parents);\n\t}\n\n\t/* Finally, get the commit message */\n\tstrbuf_reset(&sb);\n\tif (strbuf_read_file(&sb, git_path_commit_editmsg(), 0) < 0) {\n\t\tint saved_errno = errno;\n\t\trollback_index_files();\n\t\tdie(_(\"could not read commit message: %s\"), strerror(saved_errno));\n\t}\n\n\tif (verbose || /* Truncate the message just before the diff, if any. */\n\t    cleanup_mode == CLEANUP_SCISSORS)\n\t\tstrbuf_setlen(&sb, wt_status_locate_end(sb.buf, sb.len));\n\n\tif (cleanup_mode != CLEANUP_NONE)\n\t\tstrbuf_stripspace(&sb, cleanup_mode == CLEANUP_ALL);\n\tif (template_untouched(&sb) && !allow_empty_message) {\n\t\trollback_index_files();\n\t\tfprintf(stderr, _(\"Aborting commit; you did not edit the message.\\n\"));\n\t\texit(1);\n\t}\n\tif (message_is_empty(&sb) && !allow_empty_message) {\n\t\trollback_index_files();\n\t\tfprintf(stderr, _(\"Aborting commit due to empty commit message.\\n\"));\n\t\texit(1);\n\t}\n\n\tif (amend) {\n\t\tconst char *exclude_gpgsig[2] = { \"gpgsig\", NULL };\n\t\textra = read_commit_extra_headers(current_head, exclude_gpgsig);\n\t} else {\n\t\tstruct commit_extra_header **tail = &extra;\n\t\tappend_merge_tag_headers(parents, &tail);\n\t}\n\n\tif (commit_tree_extended(sb.buf, sb.len, active_cache_tree->oid.hash,\n\t\t\t parents, oid.hash, author_ident.buf, sign_commit, extra)) {\n\t\trollback_index_files();\n\t\tdie(_(\"failed to write commit object\"));\n\t}\n\tstrbuf_release(&author_ident);\n\tfree_commit_extra_headers(extra);\n\n\tnl = strchr(sb.buf, '\\n');\n\tif (nl)\n\t\tstrbuf_setlen(&sb, nl + 1 - sb.buf);\n\telse\n\t\tstrbuf_addch(&sb, '\\n');\n\tstrbuf_insert(&sb, 0, reflog_msg, strlen(reflog_msg));\n\tstrbuf_insert(&sb, strlen(reflog_msg), \": \", 2);\n\n\ttransaction = ref_transaction_begin(&err);\n\tif (!transaction ||\n\t    ref_transaction_update(transaction, \"HEAD\", oid.hash,\n\t\t\t\t   current_head\n\t\t\t\t   ? current_head->object.oid.hash : null_sha1,\n\t\t\t\t   0, sb.buf, &err) ||\n\t    ref_transaction_commit(transaction, &err)) {\n\t\trollback_index_files();\n\t\tdie(\"%s\", err.buf);\n\t}\n\tref_transaction_free(transaction);\n\n\tunlink(git_path_cherry_pick_head());\n\tunlink(git_path_revert_head());\n\tunlink(git_path_merge_head());\n\tunlink(git_path_merge_msg());\n\tunlink(git_path_merge_mode());\n\tunlink(git_path_squash_msg());\n\n\tif (commit_index_files())\n\t\tdie (_(\"Repository has been updated, but unable to write\\n\"\n\t\t     \"new_index file. Check that disk is not full and quota is\\n\"\n\t\t     \"not exceeded, and then \\\"git reset HEAD\\\" to recover.\"));\n\n\trerere(0);\n\trun_commit_hook(use_editor, get_index_file(), \"post-commit\", NULL);\n\tif (amend && !no_post_rewrite) {\n\t\tstruct notes_rewrite_cfg *cfg;\n\t\tcfg = init_copy_notes_for_rewrite(\"amend\");\n\t\tif (cfg) {\n\t\t\t/* we are amending, so current_head is not NULL */\n\t\t\tcopy_note_for_rewrite(cfg, &current_head->object.oid, &oid);\n\t\t\tfinish_copy_notes_for_rewrite(cfg, \"Notes added by 'git commit --amend'\");\n\t\t}\n\t\trun_rewrite_hook(&current_head->object.oid, &oid);\n\t}\n\tif (!quiet)\n\t\tprint_summary(prefix, &oid, !current_head);\n\n\tstrbuf_release(&err);\n\treturn 0;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00a01f07c3e56f96230bf5e382f2ad3cb976bb96",
  "sha1_ok": true,
  "size": 54669
}
