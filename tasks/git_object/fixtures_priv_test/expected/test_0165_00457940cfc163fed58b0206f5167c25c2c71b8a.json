{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCiNpbmNsdWRlICJyZWZzLmgiCiNpbmNsdWRlICJ1dGY4LmgiCgppbnQgc3RhcnRzX3dpdGgoY29uc3QgY2hhciAqc3RyLCBjb25zdCBjaGFyICpwcmVmaXgpCnsKCWZvciAoOyA7IHN0cisrLCBwcmVmaXgrKykKCQlpZiAoISpwcmVmaXgpCgkJCXJldHVybiAxOwoJCWVsc2UgaWYgKCpzdHIgIT0gKnByZWZpeCkKCQkJcmV0dXJuIDA7Cn0KCi8qCiAqIFVzZWQgYXMgdGhlIGRlZmF1bHQgLT5idWYgdmFsdWUsIHNvIHRoYXQgcGVvcGxlIGNhbiBhbHdheXMgYXNzdW1lCiAqIGJ1ZiBpcyBub24gTlVMTCBhbmQgLT5idWYgaXMgTlVMIHRlcm1pbmF0ZWQgZXZlbiBmb3IgYSBmcmVzaGx5CiAqIGluaXRpYWxpemVkIHN0cmJ1Zi4KICovCmNoYXIgc3RyYnVmX3Nsb3BidWZbMV07Cgp2b2lkIHN0cmJ1Zl9pbml0KHN0cnVjdCBzdHJidWYgKnNiLCBzaXplX3QgaGludCkKewoJc2ItPmFsbG9jID0gc2ItPmxlbiA9IDA7CglzYi0+YnVmID0gc3RyYnVmX3Nsb3BidWY7CglpZiAoaGludCkKCQlzdHJidWZfZ3JvdyhzYiwgaGludCk7Cn0KCnZvaWQgc3RyYnVmX3JlbGVhc2Uoc3RydWN0IHN0cmJ1ZiAqc2IpCnsKCWlmIChzYi0+YWxsb2MpIHsKCQlmcmVlKHNiLT5idWYpOwoJCXN0cmJ1Zl9pbml0KHNiLCAwKTsKCX0KfQoKY2hhciAqc3RyYnVmX2RldGFjaChzdHJ1Y3Qgc3RyYnVmICpzYiwgc2l6ZV90ICpzeikKewoJY2hhciAqcmVzOwoJc3RyYnVmX2dyb3coc2IsIDApOwoJcmVzID0gc2ItPmJ1ZjsKCWlmIChzeikKCQkqc3ogPSBzYi0+bGVuOwoJc3RyYnVmX2luaXQoc2IsIDApOwoJcmV0dXJuIHJlczsKfQoKdm9pZCBzdHJidWZfYXR0YWNoKHN0cnVjdCBzdHJidWYgKnNiLCB2b2lkICpidWYsIHNpemVfdCBsZW4sIHNpemVfdCBhbGxvYykKewoJc3RyYnVmX3JlbGVhc2Uoc2IpOwoJc2ItPmJ1ZiAgID0gYnVmOwoJc2ItPmxlbiAgID0gbGVuOwoJc2ItPmFsbG9jID0gYWxsb2M7CglzdHJidWZfZ3JvdyhzYiwgMCk7CglzYi0+YnVmW3NiLT5sZW5dID0gJ1wwJzsKfQoKdm9pZCBzdHJidWZfZ3JvdyhzdHJ1Y3Qgc3RyYnVmICpzYiwgc2l6ZV90IGV4dHJhKQp7CglpbnQgbmV3X2J1ZiA9ICFzYi0+YWxsb2M7CglpZiAodW5zaWduZWRfYWRkX292ZXJmbG93cyhleHRyYSwgMSkgfHwKCSAgICB1bnNpZ25lZF9hZGRfb3ZlcmZsb3dzKHNiLT5sZW4sIGV4dHJhICsgMSkpCgkJZGllKCJ5b3Ugd2FudCB0byB1c2Ugd2F5IHRvbyBtdWNoIG1lbW9yeSIpOwoJaWYgKG5ld19idWYpCgkJc2ItPmJ1ZiA9IE5VTEw7CglBTExPQ19HUk9XKHNiLT5idWYsIHNiLT5sZW4gKyBleHRyYSArIDEsIHNiLT5hbGxvYyk7CglpZiAobmV3X2J1ZikKCQlzYi0+YnVmWzBdID0gJ1wwJzsKfQoKdm9pZCBzdHJidWZfdHJpbShzdHJ1Y3Qgc3RyYnVmICpzYikKewoJc3RyYnVmX3J0cmltKHNiKTsKCXN0cmJ1Zl9sdHJpbShzYik7Cn0Kdm9pZCBzdHJidWZfcnRyaW0oc3RydWN0IHN0cmJ1ZiAqc2IpCnsKCXdoaWxlIChzYi0+bGVuID4gMCAmJiBpc3NwYWNlKCh1bnNpZ25lZCBjaGFyKXNiLT5idWZbc2ItPmxlbiAtIDFdKSkKCQlzYi0+bGVuLS07CglzYi0+YnVmW3NiLT5sZW5dID0gJ1wwJzsKfQoKdm9pZCBzdHJidWZfbHRyaW0oc3RydWN0IHN0cmJ1ZiAqc2IpCnsKCWNoYXIgKmIgPSBzYi0+YnVmOwoJd2hpbGUgKHNiLT5sZW4gPiAwICYmIGlzc3BhY2UoKmIpKSB7CgkJYisrOwoJCXNiLT5sZW4tLTsKCX0KCW1lbW1vdmUoc2ItPmJ1ZiwgYiwgc2ItPmxlbik7CglzYi0+YnVmW3NiLT5sZW5dID0gJ1wwJzsKfQoKaW50IHN0cmJ1Zl9yZWVuY29kZShzdHJ1Y3Qgc3RyYnVmICpzYiwgY29uc3QgY2hhciAqZnJvbSwgY29uc3QgY2hhciAqdG8pCnsKCWNoYXIgKm91dDsKCWludCBsZW47CgoJaWYgKHNhbWVfZW5jb2RpbmcoZnJvbSwgdG8pKQoJCXJldHVybiAwOwoKCW91dCA9IHJlZW5jb2RlX3N0cmluZ19sZW4oc2ItPmJ1Ziwgc2ItPmxlbiwgdG8sIGZyb20sICZsZW4pOwoJaWYgKCFvdXQpCgkJcmV0dXJuIC0xOwoKCXN0cmJ1Zl9hdHRhY2goc2IsIG91dCwgbGVuLCBsZW4pOwoJcmV0dXJuIDA7Cn0KCnZvaWQgc3RyYnVmX3RvbG93ZXIoc3RydWN0IHN0cmJ1ZiAqc2IpCnsKCWNoYXIgKnAgPSBzYi0+YnVmLCAqZW5kID0gc2ItPmJ1ZiArIHNiLT5sZW47Cglmb3IgKDsgcCA8IGVuZDsgcCsrKQoJCSpwID0gdG9sb3dlcigqcCk7Cn0KCnN0cnVjdCBzdHJidWYgKipzdHJidWZfc3BsaXRfYnVmKGNvbnN0IGNoYXIgKnN0ciwgc2l6ZV90IHNsZW4sCgkJCQkgaW50IHRlcm1pbmF0b3IsIGludCBtYXgpCnsKCXN0cnVjdCBzdHJidWYgKipyZXQgPSBOVUxMOwoJc2l6ZV90IG5yID0gMCwgYWxsb2MgPSAwOwoJc3RydWN0IHN0cmJ1ZiAqdDsKCgl3aGlsZSAoc2xlbikgewoJCWludCBsZW4gPSBzbGVuOwoJCWlmIChtYXggPD0gMCB8fCBuciArIDEgPCBtYXgpIHsKCQkJY29uc3QgY2hhciAqZW5kID0gbWVtY2hyKHN0ciwgdGVybWluYXRvciwgc2xlbik7CgkJCWlmIChlbmQpCgkJCQlsZW4gPSBlbmQgLSBzdHIgKyAxOwoJCX0KCQl0ID0geG1hbGxvYyhzaXplb2Yoc3RydWN0IHN0cmJ1ZikpOwoJCXN0cmJ1Zl9pbml0KHQsIGxlbik7CgkJc3RyYnVmX2FkZCh0LCBzdHIsIGxlbik7CgkJQUxMT0NfR1JPVyhyZXQsIG5yICsgMiwgYWxsb2MpOwoJCXJldFtucisrXSA9IHQ7CgkJc3RyICs9IGxlbjsKCQlzbGVuIC09IGxlbjsKCX0KCUFMTE9DX0dST1cocmV0LCBuciArIDEsIGFsbG9jKTsgLyogSW4gY2FzZSBzdHJpbmcgd2FzIGVtcHR5ICovCglyZXRbbnJdID0gTlVMTDsKCXJldHVybiByZXQ7Cn0KCnZvaWQgc3RyYnVmX2xpc3RfZnJlZShzdHJ1Y3Qgc3RyYnVmICoqc2JzKQp7CglzdHJ1Y3Qgc3RyYnVmICoqcyA9IHNiczsKCgl3aGlsZSAoKnMpIHsKCQlzdHJidWZfcmVsZWFzZSgqcyk7CgkJZnJlZSgqcysrKTsKCX0KCWZyZWUoc2JzKTsKfQoKaW50IHN0cmJ1Zl9jbXAoY29uc3Qgc3RydWN0IHN0cmJ1ZiAqYSwgY29uc3Qgc3RydWN0IHN0cmJ1ZiAqYikKewoJaW50IGxlbiA9IGEtPmxlbiA8IGItPmxlbiA/IGEtPmxlbjogYi0+bGVuOwoJaW50IGNtcCA9IG1lbWNtcChhLT5idWYsIGItPmJ1ZiwgbGVuKTsKCWlmIChjbXApCgkJcmV0dXJuIGNtcDsKCXJldHVybiBhLT5sZW4gPCBiLT5sZW4gPyAtMTogYS0+bGVuICE9IGItPmxlbjsKfQoKdm9pZCBzdHJidWZfc3BsaWNlKHN0cnVjdCBzdHJidWYgKnNiLCBzaXplX3QgcG9zLCBzaXplX3QgbGVuLAoJCQkJICAgY29uc3Qgdm9pZCAqZGF0YSwgc2l6ZV90IGRsZW4pCnsKCWlmICh1bnNpZ25lZF9hZGRfb3ZlcmZsb3dzKHBvcywgbGVuKSkKCQlkaWUoInlvdSB3YW50IHRvIHVzZSB3YXkgdG9vIG11Y2ggbWVtb3J5Iik7CglpZiAocG9zID4gc2ItPmxlbikKCQlkaWUoImBwb3MnIGlzIHRvbyBmYXIgYWZ0ZXIgdGhlIGVuZCBvZiB0aGUgYnVmZmVyIik7CglpZiAocG9zICsgbGVuID4gc2ItPmxlbikKCQlkaWUoImBwb3MgKyBsZW4nIGlzIHRvbyBmYXIgYWZ0ZXIgdGhlIGVuZCBvZiB0aGUgYnVmZmVyIik7CgoJaWYgKGRsZW4gPj0gbGVuKQoJCXN0cmJ1Zl9ncm93KHNiLCBkbGVuIC0gbGVuKTsKCW1lbW1vdmUoc2ItPmJ1ZiArIHBvcyArIGRsZW4sCgkJCXNiLT5idWYgKyBwb3MgKyBsZW4sCgkJCXNiLT5sZW4gLSBwb3MgLSBsZW4pOwoJbWVtY3B5KHNiLT5idWYgKyBwb3MsIGRhdGEsIGRsZW4pOwoJc3RyYnVmX3NldGxlbihzYiwgc2ItPmxlbiArIGRsZW4gLSBsZW4pOwp9Cgp2b2lkIHN0cmJ1Zl9pbnNlcnQoc3RydWN0IHN0cmJ1ZiAqc2IsIHNpemVfdCBwb3MsIGNvbnN0IHZvaWQgKmRhdGEsIHNpemVfdCBsZW4pCnsKCXN0cmJ1Zl9zcGxpY2Uoc2IsIHBvcywgMCwgZGF0YSwgbGVuKTsKfQoKdm9pZCBzdHJidWZfcmVtb3ZlKHN0cnVjdCBzdHJidWYgKnNiLCBzaXplX3QgcG9zLCBzaXplX3QgbGVuKQp7CglzdHJidWZfc3BsaWNlKHNiLCBwb3MsIGxlbiwgIiIsIDApOwp9Cgp2b2lkIHN0cmJ1Zl9hZGQoc3RydWN0IHN0cmJ1ZiAqc2IsIGNvbnN0IHZvaWQgKmRhdGEsIHNpemVfdCBsZW4pCnsKCXN0cmJ1Zl9ncm93KHNiLCBsZW4pOwoJbWVtY3B5KHNiLT5idWYgKyBzYi0+bGVuLCBkYXRhLCBsZW4pOwoJc3RyYnVmX3NldGxlbihzYiwgc2ItPmxlbiArIGxlbik7Cn0KCnZvaWQgc3RyYnVmX2FkZGJ1ZihzdHJ1Y3Qgc3RyYnVmICpzYiwgY29uc3Qgc3RydWN0IHN0cmJ1ZiAqc2IyKQp7CglzdHJidWZfZ3JvdyhzYiwgc2IyLT5sZW4pOwoJbWVtY3B5KHNiLT5idWYgKyBzYi0+bGVuLCBzYjItPmJ1Ziwgc2IyLT5sZW4pOwoJc3RyYnVmX3NldGxlbihzYiwgc2ItPmxlbiArIHNiMi0+bGVuKTsKfQoKdm9pZCBzdHJidWZfYWRkZHVwKHN0cnVjdCBzdHJidWYgKnNiLCBzaXplX3QgcG9zLCBzaXplX3QgbGVuKQp7CglzdHJidWZfZ3JvdyhzYiwgbGVuKTsKCW1lbWNweShzYi0+YnVmICsgc2ItPmxlbiwgc2ItPmJ1ZiArIHBvcywgbGVuKTsKCXN0cmJ1Zl9zZXRsZW4oc2IsIHNiLT5sZW4gKyBsZW4pOwp9Cgp2b2lkIHN0cmJ1Zl9hZGRjaGFycyhzdHJ1Y3Qgc3RyYnVmICpzYiwgaW50IGMsIHNpemVfdCBuKQp7CglzdHJidWZfZ3JvdyhzYiwgbik7CgltZW1zZXQoc2ItPmJ1ZiArIHNiLT5sZW4sIGMsIG4pOwoJc3RyYnVmX3NldGxlbihzYiwgc2ItPmxlbiArIG4pOwp9Cgp2b2lkIHN0cmJ1Zl9hZGRmKHN0cnVjdCBzdHJidWYgKnNiLCBjb25zdCBjaGFyICpmbXQsIC4uLikKewoJdmFfbGlzdCBhcDsKCXZhX3N0YXJ0KGFwLCBmbXQpOwoJc3RyYnVmX3ZhZGRmKHNiLCBmbXQsIGFwKTsKCXZhX2VuZChhcCk7Cn0KCnN0YXRpYyB2b2lkIGFkZF9saW5lcyhzdHJ1Y3Qgc3RyYnVmICpvdXQsCgkJCWNvbnN0IGNoYXIgKnByZWZpeDEsCgkJCWNvbnN0IGNoYXIgKnByZWZpeDIsCgkJCWNvbnN0IGNoYXIgKmJ1Ziwgc2l6ZV90IHNpemUpCnsKCXdoaWxlIChzaXplKSB7CgkJY29uc3QgY2hhciAqcHJlZml4OwoJCWNvbnN0IGNoYXIgKm5leHQgPSBtZW1jaHIoYnVmLCAnXG4nLCBzaXplKTsKCQluZXh0ID0gbmV4dCA/IChuZXh0ICsgMSkgOiAoYnVmICsgc2l6ZSk7CgoJCXByZWZpeCA9ICgocHJlZml4MiAmJiAoYnVmWzBdID09ICdcbicgfHwgYnVmWzBdID09ICdcdCcpKQoJCQkgID8gcHJlZml4MiA6IHByZWZpeDEpOwoJCXN0cmJ1Zl9hZGRzdHIob3V0LCBwcmVmaXgpOwoJCXN0cmJ1Zl9hZGQob3V0LCBidWYsIG5leHQgLSBidWYpOwoJCXNpemUgLT0gbmV4dCAtIGJ1ZjsKCQlidWYgPSBuZXh0OwoJfQoJc3RyYnVmX2NvbXBsZXRlX2xpbmUob3V0KTsKfQoKdm9pZCBzdHJidWZfYWRkX2NvbW1lbnRlZF9saW5lcyhzdHJ1Y3Qgc3RyYnVmICpvdXQsIGNvbnN0IGNoYXIgKmJ1Ziwgc2l6ZV90IHNpemUpCnsKCXN0YXRpYyBjaGFyIHByZWZpeDFbM107CglzdGF0aWMgY2hhciBwcmVmaXgyWzJdOwoKCWlmIChwcmVmaXgxWzBdICE9IGNvbW1lbnRfbGluZV9jaGFyKSB7CgkJeHNucHJpbnRmKHByZWZpeDEsIHNpemVvZihwcmVmaXgxKSwgIiVjICIsIGNvbW1lbnRfbGluZV9jaGFyKTsKCQl4c25wcmludGYocHJlZml4Miwgc2l6ZW9mKHByZWZpeDIpLCAiJWMiLCBjb21tZW50X2xpbmVfY2hhcik7Cgl9CglhZGRfbGluZXMob3V0LCBwcmVmaXgxLCBwcmVmaXgyLCBidWYsIHNpemUpOwp9Cgp2b2lkIHN0cmJ1Zl9jb21tZW50ZWRfYWRkZihzdHJ1Y3Qgc3RyYnVmICpzYiwgY29uc3QgY2hhciAqZm10LCAuLi4pCnsKCXZhX2xpc3QgcGFyYW1zOwoJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCWludCBpbmNvbXBsZXRlX2xpbmUgPSBzYi0+bGVuICYmIHNiLT5idWZbc2ItPmxlbiAtIDFdICE9ICdcbic7CgoJdmFfc3RhcnQocGFyYW1zLCBmbXQpOwoJc3RyYnVmX3ZhZGRmKCZidWYsIGZtdCwgcGFyYW1zKTsKCXZhX2VuZChwYXJhbXMpOwoKCXN0cmJ1Zl9hZGRfY29tbWVudGVkX2xpbmVzKHNiLCBidWYuYnVmLCBidWYubGVuKTsKCWlmIChpbmNvbXBsZXRlX2xpbmUpCgkJc2ItPmJ1ZlstLXNiLT5sZW5dID0gJ1wwJzsKCglzdHJidWZfcmVsZWFzZSgmYnVmKTsKfQoKdm9pZCBzdHJidWZfdmFkZGYoc3RydWN0IHN0cmJ1ZiAqc2IsIGNvbnN0IGNoYXIgKmZtdCwgdmFfbGlzdCBhcCkKewoJaW50IGxlbjsKCXZhX2xpc3QgY3A7CgoJaWYgKCFzdHJidWZfYXZhaWwoc2IpKQoJCXN0cmJ1Zl9ncm93KHNiLCA2NCk7Cgl2YV9jb3B5KGNwLCBhcCk7CglsZW4gPSB2c25wcmludGYoc2ItPmJ1ZiArIHNiLT5sZW4sIHNiLT5hbGxvYyAtIHNiLT5sZW4sIGZtdCwgY3ApOwoJdmFfZW5kKGNwKTsKCWlmIChsZW4gPCAwKQoJCWRpZSgiQlVHOiB5b3VyIHZzbnByaW50ZiBpcyBicm9rZW4gKHJldHVybmVkICVkKSIsIGxlbik7CglpZiAobGVuID4gc3RyYnVmX2F2YWlsKHNiKSkgewoJCXN0cmJ1Zl9ncm93KHNiLCBsZW4pOwoJCWxlbiA9IHZzbnByaW50ZihzYi0+YnVmICsgc2ItPmxlbiwgc2ItPmFsbG9jIC0gc2ItPmxlbiwgZm10LCBhcCk7CgkJaWYgKGxlbiA+IHN0cmJ1Zl9hdmFpbChzYikpCgkJCWRpZSgiQlVHOiB5b3VyIHZzbnByaW50ZiBpcyBicm9rZW4gKGluc2F0aWFibGUpIik7Cgl9CglzdHJidWZfc2V0bGVuKHNiLCBzYi0+bGVuICsgbGVuKTsKfQoKdm9pZCBzdHJidWZfZXhwYW5kKHN0cnVjdCBzdHJidWYgKnNiLCBjb25zdCBjaGFyICpmb3JtYXQsIGV4cGFuZF9mbl90IGZuLAoJCSAgIHZvaWQgKmNvbnRleHQpCnsKCWZvciAoOzspIHsKCQljb25zdCBjaGFyICpwZXJjZW50OwoJCXNpemVfdCBjb25zdW1lZDsKCgkJcGVyY2VudCA9IHN0cmNocm51bChmb3JtYXQsICclJyk7CgkJc3RyYnVmX2FkZChzYiwgZm9ybWF0LCBwZXJjZW50IC0gZm9ybWF0KTsKCQlpZiAoISpwZXJjZW50KQoJCQlicmVhazsKCQlmb3JtYXQgPSBwZXJjZW50ICsgMTsKCgkJaWYgKCpmb3JtYXQgPT0gJyUnKSB7CgkJCXN0cmJ1Zl9hZGRjaChzYiwgJyUnKTsKCQkJZm9ybWF0Kys7CgkJCWNvbnRpbnVlOwoJCX0KCgkJY29uc3VtZWQgPSBmbihzYiwgZm9ybWF0LCBjb250ZXh0KTsKCQlpZiAoY29uc3VtZWQpCgkJCWZvcm1hdCArPSBjb25zdW1lZDsKCQllbHNlCgkJCXN0cmJ1Zl9hZGRjaChzYiwgJyUnKTsKCX0KfQoKc2l6ZV90IHN0cmJ1Zl9leHBhbmRfZGljdF9jYihzdHJ1Y3Qgc3RyYnVmICpzYiwgY29uc3QgY2hhciAqcGxhY2Vob2xkZXIsCgkJdm9pZCAqY29udGV4dCkKewoJc3RydWN0IHN0cmJ1Zl9leHBhbmRfZGljdF9lbnRyeSAqZSA9IGNvbnRleHQ7CglzaXplX3QgbGVuOwoKCWZvciAoOyBlLT5wbGFjZWhvbGRlciAmJiAobGVuID0gc3RybGVuKGUtPnBsYWNlaG9sZGVyKSk7IGUrKykgewoJCWlmICghc3RybmNtcChwbGFjZWhvbGRlciwgZS0+cGxhY2Vob2xkZXIsIGxlbikpIHsKCQkJaWYgKGUtPnZhbHVlKQoJCQkJc3RyYnVmX2FkZHN0cihzYiwgZS0+dmFsdWUpOwoJCQlyZXR1cm4gbGVuOwoJCX0KCX0KCXJldHVybiAwOwp9Cgp2b2lkIHN0cmJ1Zl9hZGRidWZfcGVyY2VudHF1b3RlKHN0cnVjdCBzdHJidWYgKmRzdCwgY29uc3Qgc3RydWN0IHN0cmJ1ZiAqc3JjKQp7CglpbnQgaSwgbGVuID0gc3JjLT5sZW47CgoJZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7CgkJaWYgKHNyYy0+YnVmW2ldID09ICclJykKCQkJc3RyYnVmX2FkZGNoKGRzdCwgJyUnKTsKCQlzdHJidWZfYWRkY2goZHN0LCBzcmMtPmJ1ZltpXSk7Cgl9Cn0KCnNpemVfdCBzdHJidWZfZnJlYWQoc3RydWN0IHN0cmJ1ZiAqc2IsIHNpemVfdCBzaXplLCBGSUxFICpmKQp7CglzaXplX3QgcmVzOwoJc2l6ZV90IG9sZGFsbG9jID0gc2ItPmFsbG9jOwoKCXN0cmJ1Zl9ncm93KHNiLCBzaXplKTsKCXJlcyA9IGZyZWFkKHNiLT5idWYgKyBzYi0+bGVuLCAxLCBzaXplLCBmKTsKCWlmIChyZXMgPiAwKQoJCXN0cmJ1Zl9zZXRsZW4oc2IsIHNiLT5sZW4gKyByZXMpOwoJZWxzZSBpZiAob2xkYWxsb2MgPT0gMCkKCQlzdHJidWZfcmVsZWFzZShzYik7CglyZXR1cm4gcmVzOwp9Cgpzc2l6ZV90IHN0cmJ1Zl9yZWFkKHN0cnVjdCBzdHJidWYgKnNiLCBpbnQgZmQsIHNpemVfdCBoaW50KQp7CglzaXplX3Qgb2xkbGVuID0gc2ItPmxlbjsKCXNpemVfdCBvbGRhbGxvYyA9IHNiLT5hbGxvYzsKCglzdHJidWZfZ3JvdyhzYiwgaGludCA/IGhpbnQgOiA4MTkyKTsKCWZvciAoOzspIHsKCQlzc2l6ZV90IHdhbnQgPSBzYi0+YWxsb2MgLSBzYi0+bGVuIC0gMTsKCQlzc2l6ZV90IGdvdCA9IHJlYWRfaW5fZnVsbChmZCwgc2ItPmJ1ZiArIHNiLT5sZW4sIHdhbnQpOwoKCQlpZiAoZ290IDwgMCkgewoJCQlpZiAob2xkYWxsb2MgPT0gMCkKCQkJCXN0cmJ1Zl9yZWxlYXNlKHNiKTsKCQkJZWxzZQoJCQkJc3RyYnVmX3NldGxlbihzYiwgb2xkbGVuKTsKCQkJcmV0dXJuIC0xOwoJCX0KCQlzYi0+bGVuICs9IGdvdDsKCQlpZiAoZ290IDwgd2FudCkKCQkJYnJlYWs7CgkJc3RyYnVmX2dyb3coc2IsIDgxOTIpOwoJfQoKCXNiLT5idWZbc2ItPmxlbl0gPSAnXDAnOwoJcmV0dXJuIHNiLT5sZW4gLSBvbGRsZW47Cn0KCnNzaXplX3Qgc3RyYnVmX3JlYWRfb25jZShzdHJ1Y3Qgc3RyYnVmICpzYiwgaW50IGZkLCBzaXplX3QgaGludCkKewoJc3NpemVfdCBjbnQ7CgoJc3RyYnVmX2dyb3coc2IsIGhpbnQgPyBoaW50IDogODE5Mik7CgljbnQgPSB4cmVhZChmZCwgc2ItPmJ1ZiArIHNiLT5sZW4sIHNiLT5hbGxvYyAtIHNiLT5sZW4gLSAxKTsKCWlmIChjbnQgPiAwKQoJCXN0cmJ1Zl9zZXRsZW4oc2IsIHNiLT5sZW4gKyBjbnQpOwoJcmV0dXJuIGNudDsKfQoKc3NpemVfdCBzdHJidWZfd3JpdGUoc3RydWN0IHN0cmJ1ZiAqc2IsIEZJTEUgKmYpCnsKCXJldHVybiBzYi0+bGVuID8gZndyaXRlKHNiLT5idWYsIDEsIHNiLT5sZW4sIGYpIDogMDsKfQoKCiNkZWZpbmUgU1RSQlVGX01BWExJTksgKDIqUEFUSF9NQVgpCgppbnQgc3RyYnVmX3JlYWRsaW5rKHN0cnVjdCBzdHJidWYgKnNiLCBjb25zdCBjaGFyICpwYXRoLCBzaXplX3QgaGludCkKewoJc2l6ZV90IG9sZGFsbG9jID0gc2ItPmFsbG9jOwoKCWlmIChoaW50IDwgMzIpCgkJaGludCA9IDMyOwoKCXdoaWxlIChoaW50IDwgU1RSQlVGX01BWExJTkspIHsKCQlpbnQgbGVuOwoKCQlzdHJidWZfZ3JvdyhzYiwgaGludCk7CgkJbGVuID0gcmVhZGxpbmsocGF0aCwgc2ItPmJ1ZiwgaGludCk7CgkJaWYgKGxlbiA8IDApIHsKCQkJaWYgKGVycm5vICE9IEVSQU5HRSkKCQkJCWJyZWFrOwoJCX0gZWxzZSBpZiAobGVuIDwgaGludCkgewoJCQlzdHJidWZfc2V0bGVuKHNiLCBsZW4pOwoJCQlyZXR1cm4gMDsKCQl9CgoJCS8qIC4uIHRoZSBidWZmZXIgd2FzIHRvbyBzbWFsbCAtIHRyeSBhZ2FpbiAqLwoJCWhpbnQgKj0gMjsKCX0KCWlmIChvbGRhbGxvYyA9PSAwKQoJCXN0cmJ1Zl9yZWxlYXNlKHNiKTsKCXJldHVybiAtMTsKfQoKaW50IHN0cmJ1Zl9nZXRjd2Qoc3RydWN0IHN0cmJ1ZiAqc2IpCnsKCXNpemVfdCBvbGRhbGxvYyA9IHNiLT5hbGxvYzsKCXNpemVfdCBndWVzc2VkX2xlbiA9IDEyODsKCglmb3IgKDs7IGd1ZXNzZWRfbGVuICo9IDIpIHsKCQlzdHJidWZfZ3JvdyhzYiwgZ3Vlc3NlZF9sZW4pOwoJCWlmIChnZXRjd2Qoc2ItPmJ1Ziwgc2ItPmFsbG9jKSkgewoJCQlzdHJidWZfc2V0bGVuKHNiLCBzdHJsZW4oc2ItPmJ1ZikpOwoJCQlyZXR1cm4gMDsKCQl9CgoJCS8qCgkJICogSWYgZ2V0Y3dkKDMpIGlzIGltcGxlbWVudGVkIGFzIGEgc3lzY2FsbCB0aGF0IGZhbGxzCgkJICogYmFjayB0byBhIHJlZ3VsYXIgbG9va3VwIHVzaW5nIHJlYWRkaXIoMykgZXRjLiB0aGVuCgkJICogd2UgbWF5IGJlIGFibGUgdG8gYXZvaWQgRUFDQ0VTIGJ5IHByb3ZpZGluZyBlbm91Z2gKCQkgKiBzcGFjZSB0byB0aGUgc3lzY2FsbCBhcyBpdCdzIG5vdCBuZWNlc3NhcmlseSBib3VuZAoJCSAqIHRvIHRoZSBzYW1lIHJlc3RyaWN0aW9ucyBhcyB0aGUgZmFsbGJhY2suCgkJICovCgkJaWYgKGVycm5vID09IEVBQ0NFUyAmJiBndWVzc2VkX2xlbiA8IFBBVEhfTUFYKQoJCQljb250aW51ZTsKCgkJaWYgKGVycm5vICE9IEVSQU5HRSkKCQkJYnJlYWs7Cgl9CglpZiAob2xkYWxsb2MgPT0gMCkKCQlzdHJidWZfcmVsZWFzZShzYik7CgllbHNlCgkJc3RyYnVmX3Jlc2V0KHNiKTsKCXJldHVybiAtMTsKfQoKI2lmZGVmIEhBVkVfR0VUREVMSU0KaW50IHN0cmJ1Zl9nZXR3aG9sZWxpbmUoc3RydWN0IHN0cmJ1ZiAqc2IsIEZJTEUgKmZwLCBpbnQgdGVybSkKewoJc3NpemVfdCByOwoKCWlmIChmZW9mKGZwKSkKCQlyZXR1cm4gRU9GOwoKCXN0cmJ1Zl9yZXNldChzYik7CgoJLyogVHJhbnNsYXRlIHNsb3BidWYgdG8gTlVMTCwgYXMgd2UgY2Fubm90IGNhbGwgcmVhbGxvYyBvbiBpdCAqLwoJaWYgKCFzYi0+YWxsb2MpCgkJc2ItPmJ1ZiA9IE5VTEw7CglyID0gZ2V0ZGVsaW0oJnNiLT5idWYsICZzYi0+YWxsb2MsIHRlcm0sIGZwKTsKCglpZiAociA+IDApIHsKCQlzYi0+bGVuID0gcjsKCQlyZXR1cm4gMDsKCX0KCWFzc2VydChyID09IC0xKTsKCgkvKgoJICogTm9ybWFsbHkgd2Ugd291bGQgaGF2ZSBjYWxsZWQgeHJlYWxsb2MsIHdoaWNoIHdpbGwgdHJ5IHRvIGZyZWUKCSAqIG1lbW9yeSBhbmQgcmVjb3Zlci4gQnV0IHdlIGhhdmUgbm8gd2F5IHRvIHRlbGwgZ2V0ZGVsaW0oKSB0byBkbyBzby4KCSAqIFdvcnNlLCB3ZSBjYW5ub3QgdHJ5IHRvIHJlY292ZXIgRU5PTUVNIG91cnNlbHZlcywgYmVjYXVzZSB3ZSBoYXZlCgkgKiBubyBpZGVhIGhvdyBtYW55IGJ5dGVzIHdlcmUgcmVhZCBieSBnZXRkZWxpbS4KCSAqCgkgKiBEeWluZyBoZXJlIGlzIHJlYXNvbmFibGUuIEl0IG1pcnJvcnMgd2hhdCB4cmVhbGxvYyB3b3VsZCBkbyBvbgoJICogY2F0YXN0cm9waGljIG1lbW9yeSBmYWlsdXJlLiBXZSBza2lwIHRoZSBvcHBvcnR1bml0eSB0byBmcmVlIHBhY2sKCSAqIG1lbW9yeSBhbmQgcmV0cnksIGJ1dCB0aGF0J3MgdW5saWtlbHkgdG8gaGVscCBmb3IgYSBtYWxsb2Mgc21hbGwKCSAqIGVub3VnaCB0byBob2xkIGEgc2luZ2xlIGxpbmUgb2YgaW5wdXQsIGFueXdheS4KCSAqLwoJaWYgKGVycm5vID09IEVOT01FTSkKCQlkaWUoIk91dCBvZiBtZW1vcnksIGdldGRlbGltIGZhaWxlZCIpOwoKCS8qCgkgKiBSZXN0b3JlIHN0cmJ1ZiBpbnZhcmlhbnRzOyBpZiBnZXRkZWxpbSBsZWZ0IHVzIHdpdGggYSBOVUxMIHBvaW50ZXIsCgkgKiB3ZSBjYW4ganVzdCByZS1pbml0LCBidXQgb3RoZXJ3aXNlIHdlIHNob3VsZCBtYWtlIHN1cmUgdGhhdCBvdXIKCSAqIGxlbmd0aCBpcyBlbXB0eSwgYW5kIHRoYXQgdGhlIHJlc3VsdCBpcyBOVUwtdGVybWluYXRlZC4KCSAqLwoJaWYgKCFzYi0+YnVmKQoJCXN0cmJ1Zl9pbml0KHNiLCAwKTsKCWVsc2UKCQlzdHJidWZfcmVzZXQoc2IpOwoJcmV0dXJuIEVPRjsKfQojZWxzZQppbnQgc3RyYnVmX2dldHdob2xlbGluZShzdHJ1Y3Qgc3RyYnVmICpzYiwgRklMRSAqZnAsIGludCB0ZXJtKQp7CglpbnQgY2g7CgoJaWYgKGZlb2YoZnApKQoJCXJldHVybiBFT0Y7CgoJc3RyYnVmX3Jlc2V0KHNiKTsKCWZsb2NrZmlsZShmcCk7Cgl3aGlsZSAoKGNoID0gZ2V0Y191bmxvY2tlZChmcCkpICE9IEVPRikgewoJCWlmICghc3RyYnVmX2F2YWlsKHNiKSkKCQkJc3RyYnVmX2dyb3coc2IsIDEpOwoJCXNiLT5idWZbc2ItPmxlbisrXSA9IGNoOwoJCWlmIChjaCA9PSB0ZXJtKQoJCQlicmVhazsKCX0KCWZ1bmxvY2tmaWxlKGZwKTsKCWlmIChjaCA9PSBFT0YgJiYgc2ItPmxlbiA9PSAwKQoJCXJldHVybiBFT0Y7CgoJc2ItPmJ1ZltzYi0+bGVuXSA9ICdcMCc7CglyZXR1cm4gMDsKfQojZW5kaWYKCnN0YXRpYyBpbnQgc3RyYnVmX2dldGRlbGltKHN0cnVjdCBzdHJidWYgKnNiLCBGSUxFICpmcCwgaW50IHRlcm0pCnsKCWlmIChzdHJidWZfZ2V0d2hvbGVsaW5lKHNiLCBmcCwgdGVybSkpCgkJcmV0dXJuIEVPRjsKCWlmIChzYi0+YnVmW3NiLT5sZW4gLSAxXSA9PSB0ZXJtKQoJCXN0cmJ1Zl9zZXRsZW4oc2IsIHNiLT5sZW4gLSAxKTsKCXJldHVybiAwOwp9CgppbnQgc3RyYnVmX2dldGxpbmUoc3RydWN0IHN0cmJ1ZiAqc2IsIEZJTEUgKmZwKQp7CglpZiAoc3RyYnVmX2dldHdob2xlbGluZShzYiwgZnAsICdcbicpKQoJCXJldHVybiBFT0Y7CglpZiAoc2ItPmJ1ZltzYi0+bGVuIC0gMV0gPT0gJ1xuJykgewoJCXN0cmJ1Zl9zZXRsZW4oc2IsIHNiLT5sZW4gLSAxKTsKCQlpZiAoc2ItPmxlbiAmJiBzYi0+YnVmW3NiLT5sZW4gLSAxXSA9PSAnXHInKQoJCQlzdHJidWZfc2V0bGVuKHNiLCBzYi0+bGVuIC0gMSk7Cgl9CglyZXR1cm4gMDsKfQoKaW50IHN0cmJ1Zl9nZXRsaW5lX2xmKHN0cnVjdCBzdHJidWYgKnNiLCBGSUxFICpmcCkKewoJcmV0dXJuIHN0cmJ1Zl9nZXRkZWxpbShzYiwgZnAsICdcbicpOwp9CgppbnQgc3RyYnVmX2dldGxpbmVfbnVsKHN0cnVjdCBzdHJidWYgKnNiLCBGSUxFICpmcCkKewoJcmV0dXJuIHN0cmJ1Zl9nZXRkZWxpbShzYiwgZnAsICdcMCcpOwp9CgppbnQgc3RyYnVmX2dldHdob2xlbGluZV9mZChzdHJ1Y3Qgc3RyYnVmICpzYiwgaW50IGZkLCBpbnQgdGVybSkKewoJc3RyYnVmX3Jlc2V0KHNiKTsKCgl3aGlsZSAoMSkgewoJCWNoYXIgY2g7CgkJc3NpemVfdCBsZW4gPSB4cmVhZChmZCwgJmNoLCAxKTsKCQlpZiAobGVuIDw9IDApCgkJCXJldHVybiBFT0Y7CgkJc3RyYnVmX2FkZGNoKHNiLCBjaCk7CgkJaWYgKGNoID09IHRlcm0pCgkJCWJyZWFrOwoJfQoJcmV0dXJuIDA7Cn0KCnNzaXplX3Qgc3RyYnVmX3JlYWRfZmlsZShzdHJ1Y3Qgc3RyYnVmICpzYiwgY29uc3QgY2hhciAqcGF0aCwgc2l6ZV90IGhpbnQpCnsKCWludCBmZDsKCXNzaXplX3QgbGVuOwoKCWZkID0gb3BlbihwYXRoLCBPX1JET05MWSk7CglpZiAoZmQgPCAwKQoJCXJldHVybiAtMTsKCWxlbiA9IHN0cmJ1Zl9yZWFkKHNiLCBmZCwgaGludCk7CgljbG9zZShmZCk7CglpZiAobGVuIDwgMCkKCQlyZXR1cm4gLTE7CgoJcmV0dXJuIGxlbjsKfQoKdm9pZCBzdHJidWZfYWRkX2xpbmVzKHN0cnVjdCBzdHJidWYgKm91dCwgY29uc3QgY2hhciAqcHJlZml4LAoJCSAgICAgIGNvbnN0IGNoYXIgKmJ1Ziwgc2l6ZV90IHNpemUpCnsKCWFkZF9saW5lcyhvdXQsIHByZWZpeCwgTlVMTCwgYnVmLCBzaXplKTsKfQoKdm9pZCBzdHJidWZfYWRkc3RyX3htbF9xdW90ZWQoc3RydWN0IHN0cmJ1ZiAqYnVmLCBjb25zdCBjaGFyICpzKQp7Cgl3aGlsZSAoKnMpIHsKCQlzaXplX3QgbGVuID0gc3RyY3NwbihzLCAiXCI8PiYiKTsKCQlzdHJidWZfYWRkKGJ1ZiwgcywgbGVuKTsKCQlzICs9IGxlbjsKCQlzd2l0Y2ggKCpzKSB7CgkJY2FzZSAnIic6CgkJCXN0cmJ1Zl9hZGRzdHIoYnVmLCAiJnF1b3Q7Iik7CgkJCWJyZWFrOwoJCWNhc2UgJzwnOgoJCQlzdHJidWZfYWRkc3RyKGJ1ZiwgIiZsdDsiKTsKCQkJYnJlYWs7CgkJY2FzZSAnPic6CgkJCXN0cmJ1Zl9hZGRzdHIoYnVmLCAiJmd0OyIpOwoJCQlicmVhazsKCQljYXNlICcmJzoKCQkJc3RyYnVmX2FkZHN0cihidWYsICImYW1wOyIpOwoJCQlicmVhazsKCQljYXNlIDA6CgkJCXJldHVybjsKCQl9CgkJcysrOwoJfQp9CgpzdGF0aWMgaW50IGlzX3JmYzM5ODZfcmVzZXJ2ZWQoY2hhciBjaCkKewoJc3dpdGNoIChjaCkgewoJCWNhc2UgJyEnOiBjYXNlICcqJzogY2FzZSAnXCcnOiBjYXNlICcoJzogY2FzZSAnKSc6IGNhc2UgJzsnOgoJCWNhc2UgJzonOiBjYXNlICdAJzogY2FzZSAnJic6IGNhc2UgJz0nOiBjYXNlICcrJzogY2FzZSAnJCc6CgkJY2FzZSAnLCc6IGNhc2UgJy8nOiBjYXNlICc/JzogY2FzZSAnIyc6IGNhc2UgJ1snOiBjYXNlICddJzoKCQkJcmV0dXJuIDE7Cgl9CglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBpc19yZmMzOTg2X3VucmVzZXJ2ZWQoY2hhciBjaCkKewoJcmV0dXJuIGlzYWxudW0oY2gpIHx8CgkJY2ggPT0gJy0nIHx8IGNoID09ICdfJyB8fCBjaCA9PSAnLicgfHwgY2ggPT0gJ34nOwp9CgpzdGF0aWMgdm9pZCBzdHJidWZfYWRkX3VybGVuY29kZShzdHJ1Y3Qgc3RyYnVmICpzYiwgY29uc3QgY2hhciAqcywgc2l6ZV90IGxlbiwKCQkJCSBpbnQgcmVzZXJ2ZWQpCnsKCXN0cmJ1Zl9ncm93KHNiLCBsZW4pOwoJd2hpbGUgKGxlbi0tKSB7CgkJY2hhciBjaCA9ICpzKys7CgkJaWYgKGlzX3JmYzM5ODZfdW5yZXNlcnZlZChjaCkgfHwKCQkgICAgKCFyZXNlcnZlZCAmJiBpc19yZmMzOTg2X3Jlc2VydmVkKGNoKSkpCgkJCXN0cmJ1Zl9hZGRjaChzYiwgY2gpOwoJCWVsc2UKCQkJc3RyYnVmX2FkZGYoc2IsICIlJSUwMngiLCBjaCk7Cgl9Cn0KCnZvaWQgc3RyYnVmX2FkZHN0cl91cmxlbmNvZGUoc3RydWN0IHN0cmJ1ZiAqc2IsIGNvbnN0IGNoYXIgKnMsCgkJCSAgICAgaW50IHJlc2VydmVkKQp7CglzdHJidWZfYWRkX3VybGVuY29kZShzYiwgcywgc3RybGVuKHMpLCByZXNlcnZlZCk7Cn0KCnZvaWQgc3RyYnVmX2h1bWFuaXNlX2J5dGVzKHN0cnVjdCBzdHJidWYgKmJ1Ziwgb2ZmX3QgYnl0ZXMpCnsKCWlmIChieXRlcyA+IDEgPDwgMzApIHsKCQlzdHJidWZfYWRkZihidWYsICIldS4lMi4ydSBHaUIiLAoJCQkgICAgKGludCkoYnl0ZXMgPj4gMzApLAoJCQkgICAgKGludCkoYnl0ZXMgJiAoKDEgPDwgMzApIC0gMSkpIC8gMTA3Mzc0MTkpOwoJfSBlbHNlIGlmIChieXRlcyA+IDEgPDwgMjApIHsKCQlpbnQgeCA9IGJ5dGVzICsgNTI0MzsgIC8qIGZvciByb3VuZGluZyAqLwoJCXN0cmJ1Zl9hZGRmKGJ1ZiwgIiV1LiUyLjJ1IE1pQiIsCgkJCSAgICB4ID4+IDIwLCAoKHggJiAoKDEgPDwgMjApIC0gMSkpICogMTAwKSA+PiAyMCk7Cgl9IGVsc2UgaWYgKGJ5dGVzID4gMSA8PCAxMCkgewoJCWludCB4ID0gYnl0ZXMgKyA1OyAgLyogZm9yIHJvdW5kaW5nICovCgkJc3RyYnVmX2FkZGYoYnVmLCAiJXUuJTIuMnUgS2lCIiwKCQkJICAgIHggPj4gMTAsICgoeCAmICgoMSA8PCAxMCkgLSAxKSkgKiAxMDApID4+IDEwKTsKCX0gZWxzZSB7CgkJc3RyYnVmX2FkZGYoYnVmLCAiJXUgYnl0ZXMiLCAoaW50KWJ5dGVzKTsKCX0KfQoKdm9pZCBzdHJidWZfYWRkX2Fic29sdXRlX3BhdGgoc3RydWN0IHN0cmJ1ZiAqc2IsIGNvbnN0IGNoYXIgKnBhdGgpCnsKCWlmICghKnBhdGgpCgkJZGllKCJUaGUgZW1wdHkgc3RyaW5nIGlzIG5vdCBhIHZhbGlkIHBhdGgiKTsKCWlmICghaXNfYWJzb2x1dGVfcGF0aChwYXRoKSkgewoJCXN0cnVjdCBzdGF0IGN3ZF9zdGF0LCBwd2Rfc3RhdDsKCQlzaXplX3Qgb3JpZ19sZW4gPSBzYi0+bGVuOwoJCWNoYXIgKmN3ZCA9IHhnZXRjd2QoKTsKCQljaGFyICpwd2QgPSBnZXRlbnYoIlBXRCIpOwoJCWlmIChwd2QgJiYgc3RyY21wKHB3ZCwgY3dkKSAmJgoJCSAgICAhc3RhdChjd2QsICZjd2Rfc3RhdCkgJiYKCQkgICAgKGN3ZF9zdGF0LnN0X2RldiB8fCBjd2Rfc3RhdC5zdF9pbm8pICYmCgkJICAgICFzdGF0KHB3ZCwgJnB3ZF9zdGF0KSAmJgoJCSAgICBwd2Rfc3RhdC5zdF9kZXYgPT0gY3dkX3N0YXQuc3RfZGV2ICYmCgkJICAgIHB3ZF9zdGF0LnN0X2lubyA9PSBjd2Rfc3RhdC5zdF9pbm8pCgkJCXN0cmJ1Zl9hZGRzdHIoc2IsIHB3ZCk7CgkJZWxzZQoJCQlzdHJidWZfYWRkc3RyKHNiLCBjd2QpOwoJCWlmIChzYi0+bGVuID4gb3JpZ19sZW4gJiYgIWlzX2Rpcl9zZXAoc2ItPmJ1ZltzYi0+bGVuIC0gMV0pKQoJCQlzdHJidWZfYWRkY2goc2IsICcvJyk7CgkJZnJlZShjd2QpOwoJfQoJc3RyYnVmX2FkZHN0cihzYiwgcGF0aCk7Cn0KCnZvaWQgc3RyYnVmX2FkZF9yZWFsX3BhdGgoc3RydWN0IHN0cmJ1ZiAqc2IsIGNvbnN0IGNoYXIgKnBhdGgpCnsKCWlmIChzYi0+bGVuKSB7CgkJc3RydWN0IHN0cmJ1ZiByZXNvbHZlZCA9IFNUUkJVRl9JTklUOwoJCXN0cmJ1Zl9yZWFscGF0aCgmcmVzb2x2ZWQsIHBhdGgsIDEpOwoJCXN0cmJ1Zl9hZGRidWYoc2IsICZyZXNvbHZlZCk7CgkJc3RyYnVmX3JlbGVhc2UoJnJlc29sdmVkKTsKCX0gZWxzZQoJCXN0cmJ1Zl9yZWFscGF0aChzYiwgcGF0aCwgMSk7Cn0KCmludCBwcmludGZfbG4oY29uc3QgY2hhciAqZm10LCAuLi4pCnsKCWludCByZXQ7Cgl2YV9saXN0IGFwOwoJdmFfc3RhcnQoYXAsIGZtdCk7CglyZXQgPSB2cHJpbnRmKGZtdCwgYXApOwoJdmFfZW5kKGFwKTsKCWlmIChyZXQgPCAwIHx8IHB1dGNoYXIoJ1xuJykgPT0gRU9GKQoJCXJldHVybiAtMTsKCXJldHVybiByZXQgKyAxOwp9CgppbnQgZnByaW50Zl9sbihGSUxFICpmcCwgY29uc3QgY2hhciAqZm10LCAuLi4pCnsKCWludCByZXQ7Cgl2YV9saXN0IGFwOwoJdmFfc3RhcnQoYXAsIGZtdCk7CglyZXQgPSB2ZnByaW50ZihmcCwgZm10LCBhcCk7Cgl2YV9lbmQoYXApOwoJaWYgKHJldCA8IDAgfHwgcHV0YygnXG4nLCBmcCkgPT0gRU9GKQoJCXJldHVybiAtMTsKCXJldHVybiByZXQgKyAxOwp9CgpjaGFyICp4c3RyZHVwX3RvbG93ZXIoY29uc3QgY2hhciAqc3RyaW5nKQp7CgljaGFyICpyZXN1bHQ7CglzaXplX3QgbGVuLCBpOwoKCWxlbiA9IHN0cmxlbihzdHJpbmcpOwoJcmVzdWx0ID0geG1hbGxvY3oobGVuKTsKCWZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykKCQlyZXN1bHRbaV0gPSB0b2xvd2VyKHN0cmluZ1tpXSk7CglyZXN1bHRbaV0gPSAnXDAnOwoJcmV0dXJuIHJlc3VsdDsKfQoKY2hhciAqeHN0cnZmbXQoY29uc3QgY2hhciAqZm10LCB2YV9saXN0IGFwKQp7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoJc3RyYnVmX3ZhZGRmKCZidWYsIGZtdCwgYXApOwoJcmV0dXJuIHN0cmJ1Zl9kZXRhY2goJmJ1ZiwgTlVMTCk7Cn0KCmNoYXIgKnhzdHJmbXQoY29uc3QgY2hhciAqZm10LCAuLi4pCnsKCXZhX2xpc3QgYXA7CgljaGFyICpyZXQ7CgoJdmFfc3RhcnQoYXAsIGZtdCk7CglyZXQgPSB4c3RydmZtdChmbXQsIGFwKTsKCXZhX2VuZChhcCk7CgoJcmV0dXJuIHJldDsKfQoKdm9pZCBzdHJidWZfYWRkZnRpbWUoc3RydWN0IHN0cmJ1ZiAqc2IsIGNvbnN0IGNoYXIgKmZtdCwgY29uc3Qgc3RydWN0IHRtICp0bSkKewoJc2l6ZV90IGhpbnQgPSAxMjg7CglzaXplX3QgbGVuOwoKCWlmICghKmZtdCkKCQlyZXR1cm47CgoJc3RyYnVmX2dyb3coc2IsIGhpbnQpOwoJbGVuID0gc3RyZnRpbWUoc2ItPmJ1ZiArIHNiLT5sZW4sIHNiLT5hbGxvYyAtIHNiLT5sZW4sIGZtdCwgdG0pOwoKCWlmICghbGVuKSB7CgkJLyoKCQkgKiBzdHJmdGltZSByZXBvcnRzICIwIiBpZiBpdCBjb3VsZCBub3QgZml0IHRoZSByZXN1bHQgaW4gdGhlIGJ1ZmZlci4KCQkgKiBVbmZvcnR1bmF0ZWx5LCBpdCBhbHNvIHJlcG9ydHMgIjAiIGlmIHRoZSByZXF1ZXN0ZWQgdGltZSBzdHJpbmcKCQkgKiB0YWtlcyAwIGJ5dGVzLiBTbyBvdXIgc3RyYXRlZ3kgaXMgdG8gbXVuZ2UgdGhlIGZvcm1hdCBzbyB0aGF0IHRoZQoJCSAqIG91dHB1dCBjb250YWlucyBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyLCBhbmQgdGhlbiBkcm9wIHRoZSBleHRyYQoJCSAqIGNoYXJhY3RlciBiZWZvcmUgcmV0dXJuaW5nLgoJCSAqLwoJCXN0cnVjdCBzdHJidWYgbXVuZ2VkX2ZtdCA9IFNUUkJVRl9JTklUOwoJCXN0cmJ1Zl9hZGRmKCZtdW5nZWRfZm10LCAiJXMgIiwgZm10KTsKCQl3aGlsZSAoIWxlbikgewoJCQloaW50ICo9IDI7CgkJCXN0cmJ1Zl9ncm93KHNiLCBoaW50KTsKCQkJbGVuID0gc3RyZnRpbWUoc2ItPmJ1ZiArIHNiLT5sZW4sIHNiLT5hbGxvYyAtIHNiLT5sZW4sCgkJCQkgICAgICAgbXVuZ2VkX2ZtdC5idWYsIHRtKTsKCQl9CgkJc3RyYnVmX3JlbGVhc2UoJm11bmdlZF9mbXQpOwoJCWxlbi0tOyAvKiBkcm9wIG11bmdlZCBzcGFjZSAqLwoJfQoJc3RyYnVmX3NldGxlbihzYiwgc2ItPmxlbiArIGxlbik7Cn0KCnZvaWQgc3RyYnVmX2FkZF91bmlxdWVfYWJicmV2KHN0cnVjdCBzdHJidWYgKnNiLCBjb25zdCB1bnNpZ25lZCBjaGFyICpzaGExLAoJCQkgICAgICBpbnQgYWJicmV2X2xlbikKewoJaW50IHI7CglzdHJidWZfZ3JvdyhzYiwgR0lUX1NIQTFfSEVYU1ogKyAxKTsKCXIgPSBmaW5kX3VuaXF1ZV9hYmJyZXZfcihzYi0+YnVmICsgc2ItPmxlbiwgc2hhMSwgYWJicmV2X2xlbik7CglzdHJidWZfc2V0bGVuKHNiLCBzYi0+bGVuICsgcik7Cn0KCi8qCiAqIFJldHVybnMgdGhlIGxlbmd0aCBvZiBhIGxpbmUsIHdpdGhvdXQgdHJhaWxpbmcgc3BhY2VzLgogKgogKiBJZiB0aGUgbGluZSBlbmRzIHdpdGggbmV3bGluZSwgaXQgd2lsbCBiZSByZW1vdmVkIHRvby4KICovCnN0YXRpYyBzaXplX3QgY2xlYW51cChjaGFyICpsaW5lLCBzaXplX3QgbGVuKQp7Cgl3aGlsZSAobGVuKSB7CgkJdW5zaWduZWQgY2hhciBjID0gbGluZVtsZW4gLSAxXTsKCQlpZiAoIWlzc3BhY2UoYykpCgkJCWJyZWFrOwoJCWxlbi0tOwoJfQoKCXJldHVybiBsZW47Cn0KCi8qCiAqIFJlbW92ZSBlbXB0eSBsaW5lcyBmcm9tIHRoZSBiZWdpbm5pbmcgYW5kIGVuZAogKiBhbmQgYWxzbyB0cmFpbGluZyBzcGFjZXMgZnJvbSBldmVyeSBsaW5lLgogKgogKiBUdXJuIG11bHRpcGxlIGNvbnNlY3V0aXZlIGVtcHR5IGxpbmVzIGJldHdlZW4gcGFyYWdyYXBocwogKiBpbnRvIGp1c3Qgb25lIGVtcHR5IGxpbmUuCiAqCiAqIElmIHRoZSBpbnB1dCBoYXMgb25seSBlbXB0eSBsaW5lcyBhbmQgc3BhY2VzLAogKiBubyBvdXRwdXQgd2lsbCBiZSBwcm9kdWNlZC4KICoKICogSWYgbGFzdCBsaW5lIGRvZXMgbm90IGhhdmUgYSBuZXdsaW5lIGF0IHRoZSBlbmQsIG9uZSBpcyBhZGRlZC4KICoKICogRW5hYmxlIHNraXBfY29tbWVudHMgdG8gc2tpcCBldmVyeSBsaW5lIHN0YXJ0aW5nIHdpdGggY29tbWVudAogKiBjaGFyYWN0ZXIuCiAqLwp2b2lkIHN0cmJ1Zl9zdHJpcHNwYWNlKHN0cnVjdCBzdHJidWYgKnNiLCBpbnQgc2tpcF9jb21tZW50cykKewoJaW50IGVtcHRpZXMgPSAwOwoJc2l6ZV90IGksIGosIGxlbiwgbmV3bGVuOwoJY2hhciAqZW9sOwoKCS8qIFdlIG1heSBoYXZlIHRvIGFkZCBhIG5ld2xpbmUuICovCglzdHJidWZfZ3JvdyhzYiwgMSk7CgoJZm9yIChpID0gaiA9IDA7IGkgPCBzYi0+bGVuOyBpICs9IGxlbiwgaiArPSBuZXdsZW4pIHsKCQllb2wgPSBtZW1jaHIoc2ItPmJ1ZiArIGksICdcbicsIHNiLT5sZW4gLSBpKTsKCQlsZW4gPSBlb2wgPyBlb2wgLSAoc2ItPmJ1ZiArIGkpICsgMSA6IHNiLT5sZW4gLSBpOwoKCQlpZiAoc2tpcF9jb21tZW50cyAmJiBsZW4gJiYgc2ItPmJ1ZltpXSA9PSBjb21tZW50X2xpbmVfY2hhcikgewoJCQluZXdsZW4gPSAwOwoJCQljb250aW51ZTsKCQl9CgkJbmV3bGVuID0gY2xlYW51cChzYi0+YnVmICsgaSwgbGVuKTsKCgkJLyogTm90IGp1c3QgYW4gZW1wdHkgbGluZT8gKi8KCQlpZiAobmV3bGVuKSB7CgkJCWlmIChlbXB0aWVzID4gMCAmJiBqID4gMCkKCQkJCXNiLT5idWZbaisrXSA9ICdcbic7CgkJCWVtcHRpZXMgPSAwOwoJCQltZW1tb3ZlKHNiLT5idWYgKyBqLCBzYi0+YnVmICsgaSwgbmV3bGVuKTsKCQkJc2ItPmJ1ZltuZXdsZW4gKyBqKytdID0gJ1xuJzsKCQl9IGVsc2UgewoJCQllbXB0aWVzKys7CgkJfQoJfQoKCXN0cmJ1Zl9zZXRsZW4oc2IsIGopOwp9CgppbnQgc3RyYnVmX25vcm1hbGl6ZV9wYXRoKHN0cnVjdCBzdHJidWYgKnNyYykKewoJc3RydWN0IHN0cmJ1ZiBkc3QgPSBTVFJCVUZfSU5JVDsKCglzdHJidWZfZ3JvdygmZHN0LCBzcmMtPmxlbik7CglpZiAobm9ybWFsaXplX3BhdGhfY29weShkc3QuYnVmLCBzcmMtPmJ1ZikgPCAwKSB7CgkJc3RyYnVmX3JlbGVhc2UoJmRzdCk7CgkJcmV0dXJuIC0xOwoJfQoKCS8qCgkgKiBub3JtYWxpemVfcGF0aCBkb2VzIG5vdCB0ZWxsIHVzIHRoZSBuZXcgbGVuZ3RoLCBzbyB3ZSBoYXZlIHRvCgkgKiBjb21wdXRlIGl0IGJ5IGxvb2tpbmcgZm9yIHRoZSBuZXcgTlVMIGl0IHBsYWNlZAoJICovCglzdHJidWZfc2V0bGVuKCZkc3QsIHN0cmxlbihkc3QuYnVmKSk7CglzdHJidWZfc3dhcChzcmMsICZkc3QpOwoJc3RyYnVmX3JlbGVhc2UoJmRzdCk7CglyZXR1cm4gMDsKfQo=",
    "text": "#include \"cache.h\"\n#include \"refs.h\"\n#include \"utf8.h\"\n\nint starts_with(const char *str, const char *prefix)\n{\n\tfor (; ; str++, prefix++)\n\t\tif (!*prefix)\n\t\t\treturn 1;\n\t\telse if (*str != *prefix)\n\t\t\treturn 0;\n}\n\n/*\n * Used as the default ->buf value, so that people can always assume\n * buf is non NULL and ->buf is NUL terminated even for a freshly\n * initialized strbuf.\n */\nchar strbuf_slopbuf[1];\n\nvoid strbuf_init(struct strbuf *sb, size_t hint)\n{\n\tsb->alloc = sb->len = 0;\n\tsb->buf = strbuf_slopbuf;\n\tif (hint)\n\t\tstrbuf_grow(sb, hint);\n}\n\nvoid strbuf_release(struct strbuf *sb)\n{\n\tif (sb->alloc) {\n\t\tfree(sb->buf);\n\t\tstrbuf_init(sb, 0);\n\t}\n}\n\nchar *strbuf_detach(struct strbuf *sb, size_t *sz)\n{\n\tchar *res;\n\tstrbuf_grow(sb, 0);\n\tres = sb->buf;\n\tif (sz)\n\t\t*sz = sb->len;\n\tstrbuf_init(sb, 0);\n\treturn res;\n}\n\nvoid strbuf_attach(struct strbuf *sb, void *buf, size_t len, size_t alloc)\n{\n\tstrbuf_release(sb);\n\tsb->buf   = buf;\n\tsb->len   = len;\n\tsb->alloc = alloc;\n\tstrbuf_grow(sb, 0);\n\tsb->buf[sb->len] = '\\0';\n}\n\nvoid strbuf_grow(struct strbuf *sb, size_t extra)\n{\n\tint new_buf = !sb->alloc;\n\tif (unsigned_add_overflows(extra, 1) ||\n\t    unsigned_add_overflows(sb->len, extra + 1))\n\t\tdie(\"you want to use way too much memory\");\n\tif (new_buf)\n\t\tsb->buf = NULL;\n\tALLOC_GROW(sb->buf, sb->len + extra + 1, sb->alloc);\n\tif (new_buf)\n\t\tsb->buf[0] = '\\0';\n}\n\nvoid strbuf_trim(struct strbuf *sb)\n{\n\tstrbuf_rtrim(sb);\n\tstrbuf_ltrim(sb);\n}\nvoid strbuf_rtrim(struct strbuf *sb)\n{\n\twhile (sb->len > 0 && isspace((unsigned char)sb->buf[sb->len - 1]))\n\t\tsb->len--;\n\tsb->buf[sb->len] = '\\0';\n}\n\nvoid strbuf_ltrim(struct strbuf *sb)\n{\n\tchar *b = sb->buf;\n\twhile (sb->len > 0 && isspace(*b)) {\n\t\tb++;\n\t\tsb->len--;\n\t}\n\tmemmove(sb->buf, b, sb->len);\n\tsb->buf[sb->len] = '\\0';\n}\n\nint strbuf_reencode(struct strbuf *sb, const char *from, const char *to)\n{\n\tchar *out;\n\tint len;\n\n\tif (same_encoding(from, to))\n\t\treturn 0;\n\n\tout = reencode_string_len(sb->buf, sb->len, to, from, &len);\n\tif (!out)\n\t\treturn -1;\n\n\tstrbuf_attach(sb, out, len, len);\n\treturn 0;\n}\n\nvoid strbuf_tolower(struct strbuf *sb)\n{\n\tchar *p = sb->buf, *end = sb->buf + sb->len;\n\tfor (; p < end; p++)\n\t\t*p = tolower(*p);\n}\n\nstruct strbuf **strbuf_split_buf(const char *str, size_t slen,\n\t\t\t\t int terminator, int max)\n{\n\tstruct strbuf **ret = NULL;\n\tsize_t nr = 0, alloc = 0;\n\tstruct strbuf *t;\n\n\twhile (slen) {\n\t\tint len = slen;\n\t\tif (max <= 0 || nr + 1 < max) {\n\t\t\tconst char *end = memchr(str, terminator, slen);\n\t\t\tif (end)\n\t\t\t\tlen = end - str + 1;\n\t\t}\n\t\tt = xmalloc(sizeof(struct strbuf));\n\t\tstrbuf_init(t, len);\n\t\tstrbuf_add(t, str, len);\n\t\tALLOC_GROW(ret, nr + 2, alloc);\n\t\tret[nr++] = t;\n\t\tstr += len;\n\t\tslen -= len;\n\t}\n\tALLOC_GROW(ret, nr + 1, alloc); /* In case string was empty */\n\tret[nr] = NULL;\n\treturn ret;\n}\n\nvoid strbuf_list_free(struct strbuf **sbs)\n{\n\tstruct strbuf **s = sbs;\n\n\twhile (*s) {\n\t\tstrbuf_release(*s);\n\t\tfree(*s++);\n\t}\n\tfree(sbs);\n}\n\nint strbuf_cmp(const struct strbuf *a, const struct strbuf *b)\n{\n\tint len = a->len < b->len ? a->len: b->len;\n\tint cmp = memcmp(a->buf, b->buf, len);\n\tif (cmp)\n\t\treturn cmp;\n\treturn a->len < b->len ? -1: a->len != b->len;\n}\n\nvoid strbuf_splice(struct strbuf *sb, size_t pos, size_t len,\n\t\t\t\t   const void *data, size_t dlen)\n{\n\tif (unsigned_add_overflows(pos, len))\n\t\tdie(\"you want to use way too much memory\");\n\tif (pos > sb->len)\n\t\tdie(\"`pos' is too far after the end of the buffer\");\n\tif (pos + len > sb->len)\n\t\tdie(\"`pos + len' is too far after the end of the buffer\");\n\n\tif (dlen >= len)\n\t\tstrbuf_grow(sb, dlen - len);\n\tmemmove(sb->buf + pos + dlen,\n\t\t\tsb->buf + pos + len,\n\t\t\tsb->len - pos - len);\n\tmemcpy(sb->buf + pos, data, dlen);\n\tstrbuf_setlen(sb, sb->len + dlen - len);\n}\n\nvoid strbuf_insert(struct strbuf *sb, size_t pos, const void *data, size_t len)\n{\n\tstrbuf_splice(sb, pos, 0, data, len);\n}\n\nvoid strbuf_remove(struct strbuf *sb, size_t pos, size_t len)\n{\n\tstrbuf_splice(sb, pos, len, \"\", 0);\n}\n\nvoid strbuf_add(struct strbuf *sb, const void *data, size_t len)\n{\n\tstrbuf_grow(sb, len);\n\tmemcpy(sb->buf + sb->len, data, len);\n\tstrbuf_setlen(sb, sb->len + len);\n}\n\nvoid strbuf_addbuf(struct strbuf *sb, const struct strbuf *sb2)\n{\n\tstrbuf_grow(sb, sb2->len);\n\tmemcpy(sb->buf + sb->len, sb2->buf, sb2->len);\n\tstrbuf_setlen(sb, sb->len + sb2->len);\n}\n\nvoid strbuf_adddup(struct strbuf *sb, size_t pos, size_t len)\n{\n\tstrbuf_grow(sb, len);\n\tmemcpy(sb->buf + sb->len, sb->buf + pos, len);\n\tstrbuf_setlen(sb, sb->len + len);\n}\n\nvoid strbuf_addchars(struct strbuf *sb, int c, size_t n)\n{\n\tstrbuf_grow(sb, n);\n\tmemset(sb->buf + sb->len, c, n);\n\tstrbuf_setlen(sb, sb->len + n);\n}\n\nvoid strbuf_addf(struct strbuf *sb, const char *fmt, ...)\n{\n\tva_list ap;\n\tva_start(ap, fmt);\n\tstrbuf_vaddf(sb, fmt, ap);\n\tva_end(ap);\n}\n\nstatic void add_lines(struct strbuf *out,\n\t\t\tconst char *prefix1,\n\t\t\tconst char *prefix2,\n\t\t\tconst char *buf, size_t size)\n{\n\twhile (size) {\n\t\tconst char *prefix;\n\t\tconst char *next = memchr(buf, '\\n', size);\n\t\tnext = next ? (next + 1) : (buf + size);\n\n\t\tprefix = ((prefix2 && (buf[0] == '\\n' || buf[0] == '\\t'))\n\t\t\t  ? prefix2 : prefix1);\n\t\tstrbuf_addstr(out, prefix);\n\t\tstrbuf_add(out, buf, next - buf);\n\t\tsize -= next - buf;\n\t\tbuf = next;\n\t}\n\tstrbuf_complete_line(out);\n}\n\nvoid strbuf_add_commented_lines(struct strbuf *out, const char *buf, size_t size)\n{\n\tstatic char prefix1[3];\n\tstatic char prefix2[2];\n\n\tif (prefix1[0] != comment_line_char) {\n\t\txsnprintf(prefix1, sizeof(prefix1), \"%c \", comment_line_char);\n\t\txsnprintf(prefix2, sizeof(prefix2), \"%c\", comment_line_char);\n\t}\n\tadd_lines(out, prefix1, prefix2, buf, size);\n}\n\nvoid strbuf_commented_addf(struct strbuf *sb, const char *fmt, ...)\n{\n\tva_list params;\n\tstruct strbuf buf = STRBUF_INIT;\n\tint incomplete_line = sb->len && sb->buf[sb->len - 1] != '\\n';\n\n\tva_start(params, fmt);\n\tstrbuf_vaddf(&buf, fmt, params);\n\tva_end(params);\n\n\tstrbuf_add_commented_lines(sb, buf.buf, buf.len);\n\tif (incomplete_line)\n\t\tsb->buf[--sb->len] = '\\0';\n\n\tstrbuf_release(&buf);\n}\n\nvoid strbuf_vaddf(struct strbuf *sb, const char *fmt, va_list ap)\n{\n\tint len;\n\tva_list cp;\n\n\tif (!strbuf_avail(sb))\n\t\tstrbuf_grow(sb, 64);\n\tva_copy(cp, ap);\n\tlen = vsnprintf(sb->buf + sb->len, sb->alloc - sb->len, fmt, cp);\n\tva_end(cp);\n\tif (len < 0)\n\t\tdie(\"BUG: your vsnprintf is broken (returned %d)\", len);\n\tif (len > strbuf_avail(sb)) {\n\t\tstrbuf_grow(sb, len);\n\t\tlen = vsnprintf(sb->buf + sb->len, sb->alloc - sb->len, fmt, ap);\n\t\tif (len > strbuf_avail(sb))\n\t\t\tdie(\"BUG: your vsnprintf is broken (insatiable)\");\n\t}\n\tstrbuf_setlen(sb, sb->len + len);\n}\n\nvoid strbuf_expand(struct strbuf *sb, const char *format, expand_fn_t fn,\n\t\t   void *context)\n{\n\tfor (;;) {\n\t\tconst char *percent;\n\t\tsize_t consumed;\n\n\t\tpercent = strchrnul(format, '%');\n\t\tstrbuf_add(sb, format, percent - format);\n\t\tif (!*percent)\n\t\t\tbreak;\n\t\tformat = percent + 1;\n\n\t\tif (*format == '%') {\n\t\t\tstrbuf_addch(sb, '%');\n\t\t\tformat++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tconsumed = fn(sb, format, context);\n\t\tif (consumed)\n\t\t\tformat += consumed;\n\t\telse\n\t\t\tstrbuf_addch(sb, '%');\n\t}\n}\n\nsize_t strbuf_expand_dict_cb(struct strbuf *sb, const char *placeholder,\n\t\tvoid *context)\n{\n\tstruct strbuf_expand_dict_entry *e = context;\n\tsize_t len;\n\n\tfor (; e->placeholder && (len = strlen(e->placeholder)); e++) {\n\t\tif (!strncmp(placeholder, e->placeholder, len)) {\n\t\t\tif (e->value)\n\t\t\t\tstrbuf_addstr(sb, e->value);\n\t\t\treturn len;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid strbuf_addbuf_percentquote(struct strbuf *dst, const struct strbuf *src)\n{\n\tint i, len = src->len;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (src->buf[i] == '%')\n\t\t\tstrbuf_addch(dst, '%');\n\t\tstrbuf_addch(dst, src->buf[i]);\n\t}\n}\n\nsize_t strbuf_fread(struct strbuf *sb, size_t size, FILE *f)\n{\n\tsize_t res;\n\tsize_t oldalloc = sb->alloc;\n\n\tstrbuf_grow(sb, size);\n\tres = fread(sb->buf + sb->len, 1, size, f);\n\tif (res > 0)\n\t\tstrbuf_setlen(sb, sb->len + res);\n\telse if (oldalloc == 0)\n\t\tstrbuf_release(sb);\n\treturn res;\n}\n\nssize_t strbuf_read(struct strbuf *sb, int fd, size_t hint)\n{\n\tsize_t oldlen = sb->len;\n\tsize_t oldalloc = sb->alloc;\n\n\tstrbuf_grow(sb, hint ? hint : 8192);\n\tfor (;;) {\n\t\tssize_t want = sb->alloc - sb->len - 1;\n\t\tssize_t got = read_in_full(fd, sb->buf + sb->len, want);\n\n\t\tif (got < 0) {\n\t\t\tif (oldalloc == 0)\n\t\t\t\tstrbuf_release(sb);\n\t\t\telse\n\t\t\t\tstrbuf_setlen(sb, oldlen);\n\t\t\treturn -1;\n\t\t}\n\t\tsb->len += got;\n\t\tif (got < want)\n\t\t\tbreak;\n\t\tstrbuf_grow(sb, 8192);\n\t}\n\n\tsb->buf[sb->len] = '\\0';\n\treturn sb->len - oldlen;\n}\n\nssize_t strbuf_read_once(struct strbuf *sb, int fd, size_t hint)\n{\n\tssize_t cnt;\n\n\tstrbuf_grow(sb, hint ? hint : 8192);\n\tcnt = xread(fd, sb->buf + sb->len, sb->alloc - sb->len - 1);\n\tif (cnt > 0)\n\t\tstrbuf_setlen(sb, sb->len + cnt);\n\treturn cnt;\n}\n\nssize_t strbuf_write(struct strbuf *sb, FILE *f)\n{\n\treturn sb->len ? fwrite(sb->buf, 1, sb->len, f) : 0;\n}\n\n\n#define STRBUF_MAXLINK (2*PATH_MAX)\n\nint strbuf_readlink(struct strbuf *sb, const char *path, size_t hint)\n{\n\tsize_t oldalloc = sb->alloc;\n\n\tif (hint < 32)\n\t\thint = 32;\n\n\twhile (hint < STRBUF_MAXLINK) {\n\t\tint len;\n\n\t\tstrbuf_grow(sb, hint);\n\t\tlen = readlink(path, sb->buf, hint);\n\t\tif (len < 0) {\n\t\t\tif (errno != ERANGE)\n\t\t\t\tbreak;\n\t\t} else if (len < hint) {\n\t\t\tstrbuf_setlen(sb, len);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* .. the buffer was too small - try again */\n\t\thint *= 2;\n\t}\n\tif (oldalloc == 0)\n\t\tstrbuf_release(sb);\n\treturn -1;\n}\n\nint strbuf_getcwd(struct strbuf *sb)\n{\n\tsize_t oldalloc = sb->alloc;\n\tsize_t guessed_len = 128;\n\n\tfor (;; guessed_len *= 2) {\n\t\tstrbuf_grow(sb, guessed_len);\n\t\tif (getcwd(sb->buf, sb->alloc)) {\n\t\t\tstrbuf_setlen(sb, strlen(sb->buf));\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * If getcwd(3) is implemented as a syscall that falls\n\t\t * back to a regular lookup using readdir(3) etc. then\n\t\t * we may be able to avoid EACCES by providing enough\n\t\t * space to the syscall as it's not necessarily bound\n\t\t * to the same restrictions as the fallback.\n\t\t */\n\t\tif (errno == EACCES && guessed_len < PATH_MAX)\n\t\t\tcontinue;\n\n\t\tif (errno != ERANGE)\n\t\t\tbreak;\n\t}\n\tif (oldalloc == 0)\n\t\tstrbuf_release(sb);\n\telse\n\t\tstrbuf_reset(sb);\n\treturn -1;\n}\n\n#ifdef HAVE_GETDELIM\nint strbuf_getwholeline(struct strbuf *sb, FILE *fp, int term)\n{\n\tssize_t r;\n\n\tif (feof(fp))\n\t\treturn EOF;\n\n\tstrbuf_reset(sb);\n\n\t/* Translate slopbuf to NULL, as we cannot call realloc on it */\n\tif (!sb->alloc)\n\t\tsb->buf = NULL;\n\tr = getdelim(&sb->buf, &sb->alloc, term, fp);\n\n\tif (r > 0) {\n\t\tsb->len = r;\n\t\treturn 0;\n\t}\n\tassert(r == -1);\n\n\t/*\n\t * Normally we would have called xrealloc, which will try to free\n\t * memory and recover. But we have no way to tell getdelim() to do so.\n\t * Worse, we cannot try to recover ENOMEM ourselves, because we have\n\t * no idea how many bytes were read by getdelim.\n\t *\n\t * Dying here is reasonable. It mirrors what xrealloc would do on\n\t * catastrophic memory failure. We skip the opportunity to free pack\n\t * memory and retry, but that's unlikely to help for a malloc small\n\t * enough to hold a single line of input, anyway.\n\t */\n\tif (errno == ENOMEM)\n\t\tdie(\"Out of memory, getdelim failed\");\n\n\t/*\n\t * Restore strbuf invariants; if getdelim left us with a NULL pointer,\n\t * we can just re-init, but otherwise we should make sure that our\n\t * length is empty, and that the result is NUL-terminated.\n\t */\n\tif (!sb->buf)\n\t\tstrbuf_init(sb, 0);\n\telse\n\t\tstrbuf_reset(sb);\n\treturn EOF;\n}\n#else\nint strbuf_getwholeline(struct strbuf *sb, FILE *fp, int term)\n{\n\tint ch;\n\n\tif (feof(fp))\n\t\treturn EOF;\n\n\tstrbuf_reset(sb);\n\tflockfile(fp);\n\twhile ((ch = getc_unlocked(fp)) != EOF) {\n\t\tif (!strbuf_avail(sb))\n\t\t\tstrbuf_grow(sb, 1);\n\t\tsb->buf[sb->len++] = ch;\n\t\tif (ch == term)\n\t\t\tbreak;\n\t}\n\tfunlockfile(fp);\n\tif (ch == EOF && sb->len == 0)\n\t\treturn EOF;\n\n\tsb->buf[sb->len] = '\\0';\n\treturn 0;\n}\n#endif\n\nstatic int strbuf_getdelim(struct strbuf *sb, FILE *fp, int term)\n{\n\tif (strbuf_getwholeline(sb, fp, term))\n\t\treturn EOF;\n\tif (sb->buf[sb->len - 1] == term)\n\t\tstrbuf_setlen(sb, sb->len - 1);\n\treturn 0;\n}\n\nint strbuf_getline(struct strbuf *sb, FILE *fp)\n{\n\tif (strbuf_getwholeline(sb, fp, '\\n'))\n\t\treturn EOF;\n\tif (sb->buf[sb->len - 1] == '\\n') {\n\t\tstrbuf_setlen(sb, sb->len - 1);\n\t\tif (sb->len && sb->buf[sb->len - 1] == '\\r')\n\t\t\tstrbuf_setlen(sb, sb->len - 1);\n\t}\n\treturn 0;\n}\n\nint strbuf_getline_lf(struct strbuf *sb, FILE *fp)\n{\n\treturn strbuf_getdelim(sb, fp, '\\n');\n}\n\nint strbuf_getline_nul(struct strbuf *sb, FILE *fp)\n{\n\treturn strbuf_getdelim(sb, fp, '\\0');\n}\n\nint strbuf_getwholeline_fd(struct strbuf *sb, int fd, int term)\n{\n\tstrbuf_reset(sb);\n\n\twhile (1) {\n\t\tchar ch;\n\t\tssize_t len = xread(fd, &ch, 1);\n\t\tif (len <= 0)\n\t\t\treturn EOF;\n\t\tstrbuf_addch(sb, ch);\n\t\tif (ch == term)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}\n\nssize_t strbuf_read_file(struct strbuf *sb, const char *path, size_t hint)\n{\n\tint fd;\n\tssize_t len;\n\n\tfd = open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn -1;\n\tlen = strbuf_read(sb, fd, hint);\n\tclose(fd);\n\tif (len < 0)\n\t\treturn -1;\n\n\treturn len;\n}\n\nvoid strbuf_add_lines(struct strbuf *out, const char *prefix,\n\t\t      const char *buf, size_t size)\n{\n\tadd_lines(out, prefix, NULL, buf, size);\n}\n\nvoid strbuf_addstr_xml_quoted(struct strbuf *buf, const char *s)\n{\n\twhile (*s) {\n\t\tsize_t len = strcspn(s, \"\\\"<>&\");\n\t\tstrbuf_add(buf, s, len);\n\t\ts += len;\n\t\tswitch (*s) {\n\t\tcase '\"':\n\t\t\tstrbuf_addstr(buf, \"&quot;\");\n\t\t\tbreak;\n\t\tcase '<':\n\t\t\tstrbuf_addstr(buf, \"&lt;\");\n\t\t\tbreak;\n\t\tcase '>':\n\t\t\tstrbuf_addstr(buf, \"&gt;\");\n\t\t\tbreak;\n\t\tcase '&':\n\t\t\tstrbuf_addstr(buf, \"&amp;\");\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\treturn;\n\t\t}\n\t\ts++;\n\t}\n}\n\nstatic int is_rfc3986_reserved(char ch)\n{\n\tswitch (ch) {\n\t\tcase '!': case '*': case '\\'': case '(': case ')': case ';':\n\t\tcase ':': case '@': case '&': case '=': case '+': case '$':\n\t\tcase ',': case '/': case '?': case '#': case '[': case ']':\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int is_rfc3986_unreserved(char ch)\n{\n\treturn isalnum(ch) ||\n\t\tch == '-' || ch == '_' || ch == '.' || ch == '~';\n}\n\nstatic void strbuf_add_urlencode(struct strbuf *sb, const char *s, size_t len,\n\t\t\t\t int reserved)\n{\n\tstrbuf_grow(sb, len);\n\twhile (len--) {\n\t\tchar ch = *s++;\n\t\tif (is_rfc3986_unreserved(ch) ||\n\t\t    (!reserved && is_rfc3986_reserved(ch)))\n\t\t\tstrbuf_addch(sb, ch);\n\t\telse\n\t\t\tstrbuf_addf(sb, \"%%%02x\", ch);\n\t}\n}\n\nvoid strbuf_addstr_urlencode(struct strbuf *sb, const char *s,\n\t\t\t     int reserved)\n{\n\tstrbuf_add_urlencode(sb, s, strlen(s), reserved);\n}\n\nvoid strbuf_humanise_bytes(struct strbuf *buf, off_t bytes)\n{\n\tif (bytes > 1 << 30) {\n\t\tstrbuf_addf(buf, \"%u.%2.2u GiB\",\n\t\t\t    (int)(bytes >> 30),\n\t\t\t    (int)(bytes & ((1 << 30) - 1)) / 10737419);\n\t} else if (bytes > 1 << 20) {\n\t\tint x = bytes + 5243;  /* for rounding */\n\t\tstrbuf_addf(buf, \"%u.%2.2u MiB\",\n\t\t\t    x >> 20, ((x & ((1 << 20) - 1)) * 100) >> 20);\n\t} else if (bytes > 1 << 10) {\n\t\tint x = bytes + 5;  /* for rounding */\n\t\tstrbuf_addf(buf, \"%u.%2.2u KiB\",\n\t\t\t    x >> 10, ((x & ((1 << 10) - 1)) * 100) >> 10);\n\t} else {\n\t\tstrbuf_addf(buf, \"%u bytes\", (int)bytes);\n\t}\n}\n\nvoid strbuf_add_absolute_path(struct strbuf *sb, const char *path)\n{\n\tif (!*path)\n\t\tdie(\"The empty string is not a valid path\");\n\tif (!is_absolute_path(path)) {\n\t\tstruct stat cwd_stat, pwd_stat;\n\t\tsize_t orig_len = sb->len;\n\t\tchar *cwd = xgetcwd();\n\t\tchar *pwd = getenv(\"PWD\");\n\t\tif (pwd && strcmp(pwd, cwd) &&\n\t\t    !stat(cwd, &cwd_stat) &&\n\t\t    (cwd_stat.st_dev || cwd_stat.st_ino) &&\n\t\t    !stat(pwd, &pwd_stat) &&\n\t\t    pwd_stat.st_dev == cwd_stat.st_dev &&\n\t\t    pwd_stat.st_ino == cwd_stat.st_ino)\n\t\t\tstrbuf_addstr(sb, pwd);\n\t\telse\n\t\t\tstrbuf_addstr(sb, cwd);\n\t\tif (sb->len > orig_len && !is_dir_sep(sb->buf[sb->len - 1]))\n\t\t\tstrbuf_addch(sb, '/');\n\t\tfree(cwd);\n\t}\n\tstrbuf_addstr(sb, path);\n}\n\nvoid strbuf_add_real_path(struct strbuf *sb, const char *path)\n{\n\tif (sb->len) {\n\t\tstruct strbuf resolved = STRBUF_INIT;\n\t\tstrbuf_realpath(&resolved, path, 1);\n\t\tstrbuf_addbuf(sb, &resolved);\n\t\tstrbuf_release(&resolved);\n\t} else\n\t\tstrbuf_realpath(sb, path, 1);\n}\n\nint printf_ln(const char *fmt, ...)\n{\n\tint ret;\n\tva_list ap;\n\tva_start(ap, fmt);\n\tret = vprintf(fmt, ap);\n\tva_end(ap);\n\tif (ret < 0 || putchar('\\n') == EOF)\n\t\treturn -1;\n\treturn ret + 1;\n}\n\nint fprintf_ln(FILE *fp, const char *fmt, ...)\n{\n\tint ret;\n\tva_list ap;\n\tva_start(ap, fmt);\n\tret = vfprintf(fp, fmt, ap);\n\tva_end(ap);\n\tif (ret < 0 || putc('\\n', fp) == EOF)\n\t\treturn -1;\n\treturn ret + 1;\n}\n\nchar *xstrdup_tolower(const char *string)\n{\n\tchar *result;\n\tsize_t len, i;\n\n\tlen = strlen(string);\n\tresult = xmallocz(len);\n\tfor (i = 0; i < len; i++)\n\t\tresult[i] = tolower(string[i]);\n\tresult[i] = '\\0';\n\treturn result;\n}\n\nchar *xstrvfmt(const char *fmt, va_list ap)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tstrbuf_vaddf(&buf, fmt, ap);\n\treturn strbuf_detach(&buf, NULL);\n}\n\nchar *xstrfmt(const char *fmt, ...)\n{\n\tva_list ap;\n\tchar *ret;\n\n\tva_start(ap, fmt);\n\tret = xstrvfmt(fmt, ap);\n\tva_end(ap);\n\n\treturn ret;\n}\n\nvoid strbuf_addftime(struct strbuf *sb, const char *fmt, const struct tm *tm)\n{\n\tsize_t hint = 128;\n\tsize_t len;\n\n\tif (!*fmt)\n\t\treturn;\n\n\tstrbuf_grow(sb, hint);\n\tlen = strftime(sb->buf + sb->len, sb->alloc - sb->len, fmt, tm);\n\n\tif (!len) {\n\t\t/*\n\t\t * strftime reports \"0\" if it could not fit the result in the buffer.\n\t\t * Unfortunately, it also reports \"0\" if the requested time string\n\t\t * takes 0 bytes. So our strategy is to munge the format so that the\n\t\t * output contains at least one character, and then drop the extra\n\t\t * character before returning.\n\t\t */\n\t\tstruct strbuf munged_fmt = STRBUF_INIT;\n\t\tstrbuf_addf(&munged_fmt, \"%s \", fmt);\n\t\twhile (!len) {\n\t\t\thint *= 2;\n\t\t\tstrbuf_grow(sb, hint);\n\t\t\tlen = strftime(sb->buf + sb->len, sb->alloc - sb->len,\n\t\t\t\t       munged_fmt.buf, tm);\n\t\t}\n\t\tstrbuf_release(&munged_fmt);\n\t\tlen--; /* drop munged space */\n\t}\n\tstrbuf_setlen(sb, sb->len + len);\n}\n\nvoid strbuf_add_unique_abbrev(struct strbuf *sb, const unsigned char *sha1,\n\t\t\t      int abbrev_len)\n{\n\tint r;\n\tstrbuf_grow(sb, GIT_SHA1_HEXSZ + 1);\n\tr = find_unique_abbrev_r(sb->buf + sb->len, sha1, abbrev_len);\n\tstrbuf_setlen(sb, sb->len + r);\n}\n\n/*\n * Returns the length of a line, without trailing spaces.\n *\n * If the line ends with newline, it will be removed too.\n */\nstatic size_t cleanup(char *line, size_t len)\n{\n\twhile (len) {\n\t\tunsigned char c = line[len - 1];\n\t\tif (!isspace(c))\n\t\t\tbreak;\n\t\tlen--;\n\t}\n\n\treturn len;\n}\n\n/*\n * Remove empty lines from the beginning and end\n * and also trailing spaces from every line.\n *\n * Turn multiple consecutive empty lines between paragraphs\n * into just one empty line.\n *\n * If the input has only empty lines and spaces,\n * no output will be produced.\n *\n * If last line does not have a newline at the end, one is added.\n *\n * Enable skip_comments to skip every line starting with comment\n * character.\n */\nvoid strbuf_stripspace(struct strbuf *sb, int skip_comments)\n{\n\tint empties = 0;\n\tsize_t i, j, len, newlen;\n\tchar *eol;\n\n\t/* We may have to add a newline. */\n\tstrbuf_grow(sb, 1);\n\n\tfor (i = j = 0; i < sb->len; i += len, j += newlen) {\n\t\teol = memchr(sb->buf + i, '\\n', sb->len - i);\n\t\tlen = eol ? eol - (sb->buf + i) + 1 : sb->len - i;\n\n\t\tif (skip_comments && len && sb->buf[i] == comment_line_char) {\n\t\t\tnewlen = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tnewlen = cleanup(sb->buf + i, len);\n\n\t\t/* Not just an empty line? */\n\t\tif (newlen) {\n\t\t\tif (empties > 0 && j > 0)\n\t\t\t\tsb->buf[j++] = '\\n';\n\t\t\tempties = 0;\n\t\t\tmemmove(sb->buf + j, sb->buf + i, newlen);\n\t\t\tsb->buf[newlen + j++] = '\\n';\n\t\t} else {\n\t\t\tempties++;\n\t\t}\n\t}\n\n\tstrbuf_setlen(sb, j);\n}\n\nint strbuf_normalize_path(struct strbuf *src)\n{\n\tstruct strbuf dst = STRBUF_INIT;\n\n\tstrbuf_grow(&dst, src->len);\n\tif (normalize_path_copy(dst.buf, src->buf) < 0) {\n\t\tstrbuf_release(&dst);\n\t\treturn -1;\n\t}\n\n\t/*\n\t * normalize_path does not tell us the new length, so we have to\n\t * compute it by looking for the new NUL it placed\n\t */\n\tstrbuf_setlen(&dst, strlen(dst.buf));\n\tstrbuf_swap(src, &dst);\n\tstrbuf_release(&dst);\n\treturn 0;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00457940cfc163fed58b0206f5167c25c2c71b8a",
  "sha1_ok": true,
  "size": 19697
}
