{
  "content": {
    "base64": "LyoKICogVGhpcyBtZXJnZXMgdGhlIGZpbGUgbGlzdGluZyBpbiB0aGUgZGlyZWN0b3J5IGNhY2hlIGluZGV4CiAqIHdpdGggdGhlIGFjdHVhbCB3b3JraW5nIGRpcmVjdG9yeSBsaXN0LCBhbmQgc2hvd3MgZGlmZmVyZW50CiAqIGNvbWJpbmF0aW9ucyBvZiB0aGUgdHdvLgogKgogKiBDb3B5cmlnaHQgKEMpIExpbnVzIFRvcnZhbGRzLCAyMDA1CiAqLwojaW5jbHVkZSAiY2FjaGUuaCIKI2luY2x1ZGUgInF1b3RlLmgiCiNpbmNsdWRlICJkaXIuaCIKI2luY2x1ZGUgImJ1aWx0aW4uaCIKI2luY2x1ZGUgInRyZWUuaCIKI2luY2x1ZGUgInBhcnNlLW9wdGlvbnMuaCIKI2luY2x1ZGUgInJlc29sdmUtdW5kby5oIgojaW5jbHVkZSAic3RyaW5nLWxpc3QuaCIKI2luY2x1ZGUgInBhdGhzcGVjLmgiCiNpbmNsdWRlICJydW4tY29tbWFuZC5oIgojaW5jbHVkZSAic3VibW9kdWxlLmgiCgpzdGF0aWMgaW50IGFiYnJldjsKc3RhdGljIGludCBzaG93X2RlbGV0ZWQ7CnN0YXRpYyBpbnQgc2hvd19jYWNoZWQ7CnN0YXRpYyBpbnQgc2hvd19vdGhlcnM7CnN0YXRpYyBpbnQgc2hvd19zdGFnZTsKc3RhdGljIGludCBzaG93X3VubWVyZ2VkOwpzdGF0aWMgaW50IHNob3dfcmVzb2x2ZV91bmRvOwpzdGF0aWMgaW50IHNob3dfbW9kaWZpZWQ7CnN0YXRpYyBpbnQgc2hvd19raWxsZWQ7CnN0YXRpYyBpbnQgc2hvd192YWxpZF9iaXQ7CnN0YXRpYyBpbnQgbGluZV90ZXJtaW5hdG9yID0gJ1xuJzsKc3RhdGljIGludCBkZWJ1Z19tb2RlOwpzdGF0aWMgaW50IHNob3dfZW9sOwpzdGF0aWMgaW50IHJlY3Vyc2Vfc3VibW9kdWxlczsKc3RhdGljIHN0cnVjdCBhcmd2X2FycmF5IHN1Ym1vZHVsZV9vcHRpb25zID0gQVJHVl9BUlJBWV9JTklUOwoKc3RhdGljIGNvbnN0IGNoYXIgKnByZWZpeDsKc3RhdGljIGNvbnN0IGNoYXIgKnN1cGVyX3ByZWZpeDsKc3RhdGljIGludCBtYXhfcHJlZml4X2xlbjsKc3RhdGljIGludCBwcmVmaXhfbGVuOwpzdGF0aWMgc3RydWN0IHBhdGhzcGVjIHBhdGhzcGVjOwpzdGF0aWMgaW50IGVycm9yX3VubWF0Y2g7CnN0YXRpYyBjaGFyICpwc19tYXRjaGVkOwpzdGF0aWMgY29uc3QgY2hhciAqd2l0aF90cmVlOwpzdGF0aWMgaW50IGV4Y19naXZlbjsKc3RhdGljIGludCBleGNsdWRlX2FyZ3M7CgpzdGF0aWMgY29uc3QgY2hhciAqdGFnX2NhY2hlZCA9ICIiOwpzdGF0aWMgY29uc3QgY2hhciAqdGFnX3VubWVyZ2VkID0gIiI7CnN0YXRpYyBjb25zdCBjaGFyICp0YWdfcmVtb3ZlZCA9ICIiOwpzdGF0aWMgY29uc3QgY2hhciAqdGFnX290aGVyID0gIiI7CnN0YXRpYyBjb25zdCBjaGFyICp0YWdfa2lsbGVkID0gIiI7CnN0YXRpYyBjb25zdCBjaGFyICp0YWdfbW9kaWZpZWQgPSAiIjsKc3RhdGljIGNvbnN0IGNoYXIgKnRhZ19za2lwX3dvcmt0cmVlID0gIiI7CnN0YXRpYyBjb25zdCBjaGFyICp0YWdfcmVzb2x2ZV91bmRvID0gIiI7CgpzdGF0aWMgdm9pZCB3cml0ZV9lb2xpbmZvKGNvbnN0IHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UsIGNvbnN0IGNoYXIgKnBhdGgpCnsKCWlmICghc2hvd19lb2wpCgkJcmV0dXJuOwoJZWxzZSB7CgkJc3RydWN0IHN0YXQgc3Q7CgkJY29uc3QgY2hhciAqaV90eHQgPSAiIjsKCQljb25zdCBjaGFyICp3X3R4dCA9ICIiOwoJCWNvbnN0IGNoYXIgKmFfdHh0ID0gZ2V0X2NvbnZlcnRfYXR0cl9hc2NpaShwYXRoKTsKCQlpZiAoY2UgJiYgU19JU1JFRyhjZS0+Y2VfbW9kZSkpCgkJCWlfdHh0ID0gZ2V0X2NhY2hlZF9jb252ZXJ0X3N0YXRzX2FzY2lpKCZ0aGVfaW5kZXgsCgkJCQkJCQkgICAgICAgY2UtPm5hbWUpOwoJCWlmICghbHN0YXQocGF0aCwgJnN0KSAmJiBTX0lTUkVHKHN0LnN0X21vZGUpKQoJCQl3X3R4dCA9IGdldF93dF9jb252ZXJ0X3N0YXRzX2FzY2lpKHBhdGgpOwoJCXByaW50ZigiaS8lLTVzIHcvJS01cyBhdHRyLyUtMTdzXHQiLCBpX3R4dCwgd190eHQsIGFfdHh0KTsKCX0KfQoKc3RhdGljIHZvaWQgd3JpdGVfbmFtZShjb25zdCBjaGFyICpuYW1lKQp7CgkvKgoJICogUHJlcGVuZCB0aGUgc3VwZXJfcHJlZml4IHRvIG5hbWUgdG8gY29uc3RydWN0IHRoZSBmdWxsX25hbWUgdG8gYmUKCSAqIHdyaXR0ZW4uCgkgKi8KCXN0cnVjdCBzdHJidWYgZnVsbF9uYW1lID0gU1RSQlVGX0lOSVQ7CglpZiAoc3VwZXJfcHJlZml4KSB7CgkJc3RyYnVmX2FkZHN0cigmZnVsbF9uYW1lLCBzdXBlcl9wcmVmaXgpOwoJCXN0cmJ1Zl9hZGRzdHIoJmZ1bGxfbmFtZSwgbmFtZSk7CgkJbmFtZSA9IGZ1bGxfbmFtZS5idWY7Cgl9CgoJLyoKCSAqIFdpdGggIi0tZnVsbC1uYW1lIiwgcHJlZml4X2xlbj0wOyB0aGlzIGNhbGxlciBuZWVkcyB0byBwYXNzCgkgKiBhbiBlbXB0eSBzdHJpbmcgaW4gdGhhdCBjYXNlIChhIE5VTEwgaXMgZ29vZCBmb3IgIiIpLgoJICovCgl3cml0ZV9uYW1lX3F1b3RlZF9yZWxhdGl2ZShuYW1lLCBwcmVmaXhfbGVuID8gcHJlZml4IDogTlVMTCwKCQkJCSAgIHN0ZG91dCwgbGluZV90ZXJtaW5hdG9yKTsKCglzdHJidWZfcmVsZWFzZSgmZnVsbF9uYW1lKTsKfQoKc3RhdGljIHZvaWQgc2hvd19kaXJfZW50cnkoY29uc3QgY2hhciAqdGFnLCBzdHJ1Y3QgZGlyX2VudHJ5ICplbnQpCnsKCWludCBsZW4gPSBtYXhfcHJlZml4X2xlbjsKCglpZiAobGVuID4gZW50LT5sZW4pCgkJZGllKCJnaXQgbHMtZmlsZXM6IGludGVybmFsIGVycm9yIC0gZGlyZWN0b3J5IGVudHJ5IG5vdCBzdXBlcnNldCBvZiBwcmVmaXgiKTsKCglpZiAoIWRpcl9wYXRoX21hdGNoKGVudCwgJnBhdGhzcGVjLCBsZW4sIHBzX21hdGNoZWQpKQoJCXJldHVybjsKCglmcHV0cyh0YWcsIHN0ZG91dCk7Cgl3cml0ZV9lb2xpbmZvKE5VTEwsIGVudC0+bmFtZSk7Cgl3cml0ZV9uYW1lKGVudC0+bmFtZSk7Cn0KCnN0YXRpYyB2b2lkIHNob3dfb3RoZXJfZmlsZXMoc3RydWN0IGRpcl9zdHJ1Y3QgKmRpcikKewoJaW50IGk7CgoJZm9yIChpID0gMDsgaSA8IGRpci0+bnI7IGkrKykgewoJCXN0cnVjdCBkaXJfZW50cnkgKmVudCA9IGRpci0+ZW50cmllc1tpXTsKCQlpZiAoIWNhY2hlX25hbWVfaXNfb3RoZXIoZW50LT5uYW1lLCBlbnQtPmxlbikpCgkJCWNvbnRpbnVlOwoJCXNob3dfZGlyX2VudHJ5KHRhZ19vdGhlciwgZW50KTsKCX0KfQoKc3RhdGljIHZvaWQgc2hvd19raWxsZWRfZmlsZXMoc3RydWN0IGRpcl9zdHJ1Y3QgKmRpcikKewoJaW50IGk7Cglmb3IgKGkgPSAwOyBpIDwgZGlyLT5ucjsgaSsrKSB7CgkJc3RydWN0IGRpcl9lbnRyeSAqZW50ID0gZGlyLT5lbnRyaWVzW2ldOwoJCWNoYXIgKmNwLCAqc3A7CgkJaW50IHBvcywgbGVuLCBraWxsZWQgPSAwOwoKCQlmb3IgKGNwID0gZW50LT5uYW1lOyBjcCAtIGVudC0+bmFtZSA8IGVudC0+bGVuOyBjcCA9IHNwICsgMSkgewoJCQlzcCA9IHN0cmNocihjcCwgJy8nKTsKCQkJaWYgKCFzcCkgewoJCQkJLyogSWYgZW50LT5uYW1lIGlzIHByZWZpeCBvZiBhbiBlbnRyeSBpbiB0aGUKCQkJCSAqIGNhY2hlLCBpdCB3aWxsIGJlIGtpbGxlZC4KCQkJCSAqLwoJCQkJcG9zID0gY2FjaGVfbmFtZV9wb3MoZW50LT5uYW1lLCBlbnQtPmxlbik7CgkJCQlpZiAoMCA8PSBwb3MpCgkJCQkJZGllKCJCVUc6IGtpbGxlZC1maWxlICUuKnMgbm90IGZvdW5kIiwKCQkJCQkJZW50LT5sZW4sIGVudC0+bmFtZSk7CgkJCQlwb3MgPSAtcG9zIC0gMTsKCQkJCXdoaWxlIChwb3MgPCBhY3RpdmVfbnIgJiYKCQkJCSAgICAgICBjZV9zdGFnZShhY3RpdmVfY2FjaGVbcG9zXSkpCgkJCQkJcG9zKys7IC8qIHNraXAgdW5tZXJnZWQgKi8KCQkJCWlmIChhY3RpdmVfbnIgPD0gcG9zKQoJCQkJCWJyZWFrOwoJCQkJLyogcG9zIHBvaW50cyBhdCBhIG5hbWUgaW1tZWRpYXRlbHkgYWZ0ZXIKCQkJCSAqIGVudC0+bmFtZSBpbiB0aGUgY2FjaGUuICBEb2VzIGl0IGV4cGVjdAoJCQkJICogZW50LT5uYW1lIHRvIGJlIGEgZGlyZWN0b3J5PwoJCQkJICovCgkJCQlsZW4gPSBjZV9uYW1lbGVuKGFjdGl2ZV9jYWNoZVtwb3NdKTsKCQkJCWlmICgoZW50LT5sZW4gPCBsZW4pICYmCgkJCQkgICAgIXN0cm5jbXAoYWN0aXZlX2NhY2hlW3Bvc10tPm5hbWUsCgkJCQkJICAgICBlbnQtPm5hbWUsIGVudC0+bGVuKSAmJgoJCQkJICAgIGFjdGl2ZV9jYWNoZVtwb3NdLT5uYW1lW2VudC0+bGVuXSA9PSAnLycpCgkJCQkJa2lsbGVkID0gMTsKCQkJCWJyZWFrOwoJCQl9CgkJCWlmICgwIDw9IGNhY2hlX25hbWVfcG9zKGVudC0+bmFtZSwgc3AgLSBlbnQtPm5hbWUpKSB7CgkJCQkvKiBJZiBhbnkgb2YgdGhlIGxlYWRpbmcgZGlyZWN0b3JpZXMgaW4KCQkJCSAqIGVudC0+bmFtZSBpcyByZWdpc3RlcmVkIGluIHRoZSBjYWNoZSwKCQkJCSAqIGVudC0+bmFtZSB3aWxsIGJlIGtpbGxlZC4KCQkJCSAqLwoJCQkJa2lsbGVkID0gMTsKCQkJCWJyZWFrOwoJCQl9CgkJfQoJCWlmIChraWxsZWQpCgkJCXNob3dfZGlyX2VudHJ5KHRhZ19raWxsZWQsIGRpci0+ZW50cmllc1tpXSk7Cgl9Cn0KCi8qCiAqIENvbXBpbGUgYW4gYXJndl9hcnJheSB3aXRoIGFsbCBvZiB0aGUgb3B0aW9ucyBzdXBwb3J0ZWQgYnkgLS1yZWN1cnNlX3N1Ym1vZHVsZXMKICovCnN0YXRpYyB2b2lkIGNvbXBpbGVfc3VibW9kdWxlX29wdGlvbnMoY29uc3QgY2hhciAqKmFyZ3YsCgkJCQkgICAgICBjb25zdCBzdHJ1Y3QgZGlyX3N0cnVjdCAqZGlyLAoJCQkJICAgICAgaW50IHNob3dfdGFnKQp7CglpZiAobGluZV90ZXJtaW5hdG9yID09ICdcMCcpCgkJYXJndl9hcnJheV9wdXNoKCZzdWJtb2R1bGVfb3B0aW9ucywgIi16Iik7CglpZiAoc2hvd190YWcpCgkJYXJndl9hcnJheV9wdXNoKCZzdWJtb2R1bGVfb3B0aW9ucywgIi10Iik7CglpZiAoc2hvd192YWxpZF9iaXQpCgkJYXJndl9hcnJheV9wdXNoKCZzdWJtb2R1bGVfb3B0aW9ucywgIi12Iik7CglpZiAoc2hvd19jYWNoZWQpCgkJYXJndl9hcnJheV9wdXNoKCZzdWJtb2R1bGVfb3B0aW9ucywgIi0tY2FjaGVkIik7CglpZiAoc2hvd19lb2wpCgkJYXJndl9hcnJheV9wdXNoKCZzdWJtb2R1bGVfb3B0aW9ucywgIi0tZW9sIik7CglpZiAoZGVidWdfbW9kZSkKCQlhcmd2X2FycmF5X3B1c2goJnN1Ym1vZHVsZV9vcHRpb25zLCAiLS1kZWJ1ZyIpOwoKCS8qIEFkZCBQYXRoc3BlY3MgKi8KCWFyZ3ZfYXJyYXlfcHVzaCgmc3VibW9kdWxlX29wdGlvbnMsICItLSIpOwoJZm9yICg7ICphcmd2OyBhcmd2KyspCgkJYXJndl9hcnJheV9wdXNoKCZzdWJtb2R1bGVfb3B0aW9ucywgKmFyZ3YpOwp9CgovKioKICogUmVjdXJzaXZlbHkgY2FsbCBscy1maWxlcyBvbiBhIHN1Ym1vZHVsZQogKi8Kc3RhdGljIHZvaWQgc2hvd19naXRsaW5rKGNvbnN0IHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UpCnsKCXN0cnVjdCBjaGlsZF9wcm9jZXNzIGNwID0gQ0hJTERfUFJPQ0VTU19JTklUOwoJaW50IHN0YXR1czsKCWNoYXIgKmRpcjsKCglwcmVwYXJlX3N1Ym1vZHVsZV9yZXBvX2VudigmY3AuZW52X2FycmF5KTsKCWFyZ3ZfYXJyYXlfcHVzaCgmY3AuZW52X2FycmF5LCBHSVRfRElSX0VOVklST05NRU5UKTsKCglpZiAocHJlZml4X2xlbikKCQlhcmd2X2FycmF5X3B1c2hmKCZjcC5lbnZfYXJyYXksICIlcz0lcyIsCgkJCQkgR0lUX1RPUExFVkVMX1BSRUZJWF9FTlZJUk9OTUVOVCwKCQkJCSBwcmVmaXgpOwoJYXJndl9hcnJheV9wdXNoZigmY3AuYXJncywgIi0tc3VwZXItcHJlZml4PSVzJXMvIiwKCQkJIHN1cGVyX3ByZWZpeCA/IHN1cGVyX3ByZWZpeCA6ICIiLAoJCQkgY2UtPm5hbWUpOwoJYXJndl9hcnJheV9wdXNoKCZjcC5hcmdzLCAibHMtZmlsZXMiKTsKCWFyZ3ZfYXJyYXlfcHVzaCgmY3AuYXJncywgIi0tcmVjdXJzZS1zdWJtb2R1bGVzIik7CgoJLyogYWRkIHN1cHBvcnRlZCBvcHRpb25zICovCglhcmd2X2FycmF5X3B1c2h2KCZjcC5hcmdzLCBzdWJtb2R1bGVfb3B0aW9ucy5hcmd2KTsKCgljcC5naXRfY21kID0gMTsKCWRpciA9IG1rcGF0aGR1cCgiJXMvJXMiLCBnZXRfZ2l0X3dvcmtfdHJlZSgpLCBjZS0+bmFtZSk7CgljcC5kaXIgPSBkaXI7CglzdGF0dXMgPSBydW5fY29tbWFuZCgmY3ApOwoJZnJlZShkaXIpOwoJaWYgKHN0YXR1cykKCQlleGl0KHN0YXR1cyk7Cn0KCnN0YXRpYyB2b2lkIHNob3dfY2VfZW50cnkoY29uc3QgY2hhciAqdGFnLCBjb25zdCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlKQp7CglzdHJ1Y3Qgc3RyYnVmIG5hbWUgPSBTVFJCVUZfSU5JVDsKCWludCBsZW4gPSBtYXhfcHJlZml4X2xlbjsKCWlmIChzdXBlcl9wcmVmaXgpCgkJc3RyYnVmX2FkZHN0cigmbmFtZSwgc3VwZXJfcHJlZml4KTsKCXN0cmJ1Zl9hZGRzdHIoJm5hbWUsIGNlLT5uYW1lKTsKCglpZiAobGVuID4gY2VfbmFtZWxlbihjZSkpCgkJZGllKCJnaXQgbHMtZmlsZXM6IGludGVybmFsIGVycm9yIC0gY2FjaGUgZW50cnkgbm90IHN1cGVyc2V0IG9mIHByZWZpeCIpOwoKCWlmIChyZWN1cnNlX3N1Ym1vZHVsZXMgJiYgU19JU0dJVExJTksoY2UtPmNlX21vZGUpICYmCgkgICAgc3VibW9kdWxlX3BhdGhfbWF0Y2goJnBhdGhzcGVjLCBuYW1lLmJ1ZiwgcHNfbWF0Y2hlZCkpIHsKCQlzaG93X2dpdGxpbmsoY2UpOwoJfSBlbHNlIGlmIChtYXRjaF9wYXRoc3BlYygmcGF0aHNwZWMsIG5hbWUuYnVmLCBuYW1lLmxlbiwKCQkJCSAgbGVuLCBwc19tYXRjaGVkLAoJCQkJICBTX0lTRElSKGNlLT5jZV9tb2RlKSB8fAoJCQkJICBTX0lTR0lUTElOSyhjZS0+Y2VfbW9kZSkpKSB7CgkJaWYgKHRhZyAmJiAqdGFnICYmIHNob3dfdmFsaWRfYml0ICYmCgkJICAgIChjZS0+Y2VfZmxhZ3MgJiBDRV9WQUxJRCkpIHsKCQkJc3RhdGljIGNoYXIgYWx0dGFnWzRdOwoJCQltZW1jcHkoYWx0dGFnLCB0YWcsIDMpOwoJCQlpZiAoaXNhbHBoYSh0YWdbMF0pKQoJCQkJYWx0dGFnWzBdID0gdG9sb3dlcih0YWdbMF0pOwoJCQllbHNlIGlmICh0YWdbMF0gPT0gJz8nKQoJCQkJYWx0dGFnWzBdID0gJyEnOwoJCQllbHNlIHsKCQkJCWFsdHRhZ1swXSA9ICd2JzsKCQkJCWFsdHRhZ1sxXSA9IHRhZ1swXTsKCQkJCWFsdHRhZ1syXSA9ICcgJzsKCQkJCWFsdHRhZ1szXSA9IDA7CgkJCX0KCQkJdGFnID0gYWx0dGFnOwoJCX0KCgkJaWYgKCFzaG93X3N0YWdlKSB7CgkJCWZwdXRzKHRhZywgc3Rkb3V0KTsKCQl9IGVsc2UgewoJCQlwcmludGYoIiVzJTA2byAlcyAlZFx0IiwKCQkJICAgICAgIHRhZywKCQkJICAgICAgIGNlLT5jZV9tb2RlLAoJCQkgICAgICAgZmluZF91bmlxdWVfYWJicmV2KGNlLT5vaWQuaGFzaCwgYWJicmV2KSwKCQkJICAgICAgIGNlX3N0YWdlKGNlKSk7CgkJfQoJCXdyaXRlX2VvbGluZm8oY2UsIGNlLT5uYW1lKTsKCQl3cml0ZV9uYW1lKGNlLT5uYW1lKTsKCQlpZiAoZGVidWdfbW9kZSkgewoJCQljb25zdCBzdHJ1Y3Qgc3RhdF9kYXRhICpzZCA9ICZjZS0+Y2Vfc3RhdF9kYXRhOwoKCQkJcHJpbnRmKCIgIGN0aW1lOiAlZDolZFxuIiwgc2QtPnNkX2N0aW1lLnNlYywgc2QtPnNkX2N0aW1lLm5zZWMpOwoJCQlwcmludGYoIiAgbXRpbWU6ICVkOiVkXG4iLCBzZC0+c2RfbXRpbWUuc2VjLCBzZC0+c2RfbXRpbWUubnNlYyk7CgkJCXByaW50ZigiICBkZXY6ICVkXHRpbm86ICVkXG4iLCBzZC0+c2RfZGV2LCBzZC0+c2RfaW5vKTsKCQkJcHJpbnRmKCIgIHVpZDogJWRcdGdpZDogJWRcbiIsIHNkLT5zZF91aWQsIHNkLT5zZF9naWQpOwoJCQlwcmludGYoIiAgc2l6ZTogJWRcdGZsYWdzOiAleFxuIiwgc2QtPnNkX3NpemUsIGNlLT5jZV9mbGFncyk7CgkJfQoJfQoKCXN0cmJ1Zl9yZWxlYXNlKCZuYW1lKTsKfQoKc3RhdGljIHZvaWQgc2hvd19ydV9pbmZvKHZvaWQpCnsKCXN0cnVjdCBzdHJpbmdfbGlzdF9pdGVtICppdGVtOwoKCWlmICghdGhlX2luZGV4LnJlc29sdmVfdW5kbykKCQlyZXR1cm47CgoJZm9yX2VhY2hfc3RyaW5nX2xpc3RfaXRlbShpdGVtLCB0aGVfaW5kZXgucmVzb2x2ZV91bmRvKSB7CgkJY29uc3QgY2hhciAqcGF0aCA9IGl0ZW0tPnN0cmluZzsKCQlzdHJ1Y3QgcmVzb2x2ZV91bmRvX2luZm8gKnVpID0gaXRlbS0+dXRpbDsKCQlpbnQgaSwgbGVuOwoKCQlsZW4gPSBzdHJsZW4ocGF0aCk7CgkJaWYgKGxlbiA8IG1heF9wcmVmaXhfbGVuKQoJCQljb250aW51ZTsgLyogb3V0c2lkZSBvZiB0aGUgcHJlZml4ICovCgkJaWYgKCFtYXRjaF9wYXRoc3BlYygmcGF0aHNwZWMsIHBhdGgsIGxlbiwKCQkJCSAgICBtYXhfcHJlZml4X2xlbiwgcHNfbWF0Y2hlZCwgMCkpCgkJCWNvbnRpbnVlOyAvKiB1bmludGVyZXN0ZWQgKi8KCQlmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7CgkJCWlmICghdWktPm1vZGVbaV0pCgkJCQljb250aW51ZTsKCQkJcHJpbnRmKCIlcyUwNm8gJXMgJWRcdCIsIHRhZ19yZXNvbHZlX3VuZG8sIHVpLT5tb2RlW2ldLAoJCQkgICAgICAgZmluZF91bmlxdWVfYWJicmV2KHVpLT5zaGExW2ldLCBhYmJyZXYpLAoJCQkgICAgICAgaSArIDEpOwoJCQl3cml0ZV9uYW1lKHBhdGgpOwoJCX0KCX0KfQoKc3RhdGljIGludCBjZV9leGNsdWRlZChzdHJ1Y3QgZGlyX3N0cnVjdCAqZGlyLCBjb25zdCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlKQp7CglpbnQgZHR5cGUgPSBjZV90b19kdHlwZShjZSk7CglyZXR1cm4gaXNfZXhjbHVkZWQoZGlyLCAmdGhlX2luZGV4LCBjZS0+bmFtZSwgJmR0eXBlKTsKfQoKc3RhdGljIHZvaWQgc2hvd19maWxlcyhzdHJ1Y3QgZGlyX3N0cnVjdCAqZGlyKQp7CglpbnQgaTsKCgkvKiBGb3IgY2FjaGVkL2RlbGV0ZWQgZmlsZXMgd2UgZG9uJ3QgbmVlZCB0byBldmVuIGRvIHRoZSByZWFkZGlyICovCglpZiAoc2hvd19vdGhlcnMgfHwgc2hvd19raWxsZWQpIHsKCQlpZiAoIXNob3dfb3RoZXJzKQoJCQlkaXItPmZsYWdzIHw9IERJUl9DT0xMRUNUX0tJTExFRF9PTkxZOwoJCWZpbGxfZGlyZWN0b3J5KGRpciwgJnRoZV9pbmRleCwgJnBhdGhzcGVjKTsKCQlpZiAoc2hvd19vdGhlcnMpCgkJCXNob3dfb3RoZXJfZmlsZXMoZGlyKTsKCQlpZiAoc2hvd19raWxsZWQpCgkJCXNob3dfa2lsbGVkX2ZpbGVzKGRpcik7Cgl9CglpZiAoc2hvd19jYWNoZWQgfHwgc2hvd19zdGFnZSkgewoJCWZvciAoaSA9IDA7IGkgPCBhY3RpdmVfbnI7IGkrKykgewoJCQljb25zdCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlID0gYWN0aXZlX2NhY2hlW2ldOwoJCQlpZiAoKGRpci0+ZmxhZ3MgJiBESVJfU0hPV19JR05PUkVEKSAmJgoJCQkgICAgIWNlX2V4Y2x1ZGVkKGRpciwgY2UpKQoJCQkJY29udGludWU7CgkJCWlmIChzaG93X3VubWVyZ2VkICYmICFjZV9zdGFnZShjZSkpCgkJCQljb250aW51ZTsKCQkJaWYgKGNlLT5jZV9mbGFncyAmIENFX1VQREFURSkKCQkJCWNvbnRpbnVlOwoJCQlzaG93X2NlX2VudHJ5KGNlX3N0YWdlKGNlKSA/IHRhZ191bm1lcmdlZCA6CgkJCQkoY2Vfc2tpcF93b3JrdHJlZShjZSkgPyB0YWdfc2tpcF93b3JrdHJlZSA6IHRhZ19jYWNoZWQpLCBjZSk7CgkJfQoJfQoJaWYgKHNob3dfZGVsZXRlZCB8fCBzaG93X21vZGlmaWVkKSB7CgkJZm9yIChpID0gMDsgaSA8IGFjdGl2ZV9ucjsgaSsrKSB7CgkJCWNvbnN0IHN0cnVjdCBjYWNoZV9lbnRyeSAqY2UgPSBhY3RpdmVfY2FjaGVbaV07CgkJCXN0cnVjdCBzdGF0IHN0OwoJCQlpbnQgZXJyOwoJCQlpZiAoKGRpci0+ZmxhZ3MgJiBESVJfU0hPV19JR05PUkVEKSAmJgoJCQkgICAgIWNlX2V4Y2x1ZGVkKGRpciwgY2UpKQoJCQkJY29udGludWU7CgkJCWlmIChjZS0+Y2VfZmxhZ3MgJiBDRV9VUERBVEUpCgkJCQljb250aW51ZTsKCQkJaWYgKGNlX3NraXBfd29ya3RyZWUoY2UpKQoJCQkJY29udGludWU7CgkJCWVyciA9IGxzdGF0KGNlLT5uYW1lLCAmc3QpOwoJCQlpZiAoc2hvd19kZWxldGVkICYmIGVycikKCQkJCXNob3dfY2VfZW50cnkodGFnX3JlbW92ZWQsIGNlKTsKCQkJaWYgKHNob3dfbW9kaWZpZWQgJiYgY2VfbW9kaWZpZWQoY2UsICZzdCwgMCkpCgkJCQlzaG93X2NlX2VudHJ5KHRhZ19tb2RpZmllZCwgY2UpOwoJCX0KCX0KfQoKLyoKICogUHJ1bmUgdGhlIGluZGV4IHRvIG9ubHkgY29udGFpbiBzdHVmZiBzdGFydGluZyB3aXRoICJwcmVmaXgiCiAqLwpzdGF0aWMgdm9pZCBwcnVuZV9jYWNoZShjb25zdCBjaGFyICpwcmVmaXgsIHNpemVfdCBwcmVmaXhsZW4pCnsKCWludCBwb3M7Cgl1bnNpZ25lZCBpbnQgZmlyc3QsIGxhc3Q7CgoJaWYgKCFwcmVmaXgpCgkJcmV0dXJuOwoJcG9zID0gY2FjaGVfbmFtZV9wb3MocHJlZml4LCBwcmVmaXhsZW4pOwoJaWYgKHBvcyA8IDApCgkJcG9zID0gLXBvcy0xOwoJZmlyc3QgPSBwb3M7CglsYXN0ID0gYWN0aXZlX25yOwoJd2hpbGUgKGxhc3QgPiBmaXJzdCkgewoJCWludCBuZXh0ID0gKGxhc3QgKyBmaXJzdCkgPj4gMTsKCQljb25zdCBzdHJ1Y3QgY2FjaGVfZW50cnkgKmNlID0gYWN0aXZlX2NhY2hlW25leHRdOwoJCWlmICghc3RybmNtcChjZS0+bmFtZSwgcHJlZml4LCBwcmVmaXhsZW4pKSB7CgkJCWZpcnN0ID0gbmV4dCsxOwoJCQljb250aW51ZTsKCQl9CgkJbGFzdCA9IG5leHQ7Cgl9CgltZW1tb3ZlKGFjdGl2ZV9jYWNoZSwgYWN0aXZlX2NhY2hlICsgcG9zLAoJCShsYXN0IC0gcG9zKSAqIHNpemVvZihzdHJ1Y3QgY2FjaGVfZW50cnkgKikpOwoJYWN0aXZlX25yID0gbGFzdCAtIHBvczsKfQoKc3RhdGljIGludCBnZXRfY29tbW9uX3ByZWZpeF9sZW4oY29uc3QgY2hhciAqY29tbW9uX3ByZWZpeCkKewoJaW50IGNvbW1vbl9wcmVmaXhfbGVuOwoKCWlmICghY29tbW9uX3ByZWZpeCkKCQlyZXR1cm4gMDsKCgljb21tb25fcHJlZml4X2xlbiA9IHN0cmxlbihjb21tb25fcHJlZml4KTsKCgkvKgoJICogSWYgdGhlIHByZWZpeCBoYXMgYSB0cmFpbGluZyBzbGFzaCwgc3RyaXAgaXQgc28gdGhhdCBzdWJtb2R1bGVzIHdvbnQKCSAqIGJlIHBydW5lZCBmcm9tIHRoZSBpbmRleC4KCSAqLwoJaWYgKGNvbW1vbl9wcmVmaXhbY29tbW9uX3ByZWZpeF9sZW4gLSAxXSA9PSAnLycpCgkJY29tbW9uX3ByZWZpeF9sZW4tLTsKCglyZXR1cm4gY29tbW9uX3ByZWZpeF9sZW47Cn0KCi8qCiAqIFJlYWQgdGhlIHRyZWUgc3BlY2lmaWVkIHdpdGggLS13aXRoLXRyZWUgb3B0aW9uCiAqICh0eXBpY2FsbHksIEhFQUQpIGludG8gc3RhZ2UgIzEgYW5kIHRoZW4KICogc3F1YXNoIHRoZW0gZG93biB0byBzdGFnZSAjMC4gIFRoaXMgaXMgdXNlZCBmb3IKICogLS1lcnJvci11bm1hdGNoIHRvIGxpc3QgYW5kIGNoZWNrIHRoZSBwYXRoIHBhdHRlcm5zCiAqIHRoYXQgd2VyZSBnaXZlbiBmcm9tIHRoZSBjb21tYW5kIGxpbmUuICBXZSBhcmUgbm90CiAqIGdvaW5nIHRvIHdyaXRlIHRoaXMgaW5kZXggb3V0LgogKi8Kdm9pZCBvdmVybGF5X3RyZWVfb25fY2FjaGUoY29uc3QgY2hhciAqdHJlZV9uYW1lLCBjb25zdCBjaGFyICpwcmVmaXgpCnsKCXN0cnVjdCB0cmVlICp0cmVlOwoJc3RydWN0IG9iamVjdF9pZCBvaWQ7CglzdHJ1Y3QgcGF0aHNwZWMgcGF0aHNwZWM7CglzdHJ1Y3QgY2FjaGVfZW50cnkgKmxhc3Rfc3RhZ2UwID0gTlVMTDsKCWludCBpOwoKCWlmIChnZXRfb2lkKHRyZWVfbmFtZSwgJm9pZCkpCgkJZGllKCJ0cmVlLWlzaCAlcyBub3QgZm91bmQuIiwgdHJlZV9uYW1lKTsKCXRyZWUgPSBwYXJzZV90cmVlX2luZGlyZWN0KCZvaWQpOwoJaWYgKCF0cmVlKQoJCWRpZSgiYmFkIHRyZWUtaXNoICVzIiwgdHJlZV9uYW1lKTsKCgkvKiBIb2lzdCB0aGUgdW5tZXJnZWQgZW50cmllcyB1cCB0byBzdGFnZSAjMyB0byBtYWtlIHJvb20gKi8KCWZvciAoaSA9IDA7IGkgPCBhY3RpdmVfbnI7IGkrKykgewoJCXN0cnVjdCBjYWNoZV9lbnRyeSAqY2UgPSBhY3RpdmVfY2FjaGVbaV07CgkJaWYgKCFjZV9zdGFnZShjZSkpCgkJCWNvbnRpbnVlOwoJCWNlLT5jZV9mbGFncyB8PSBDRV9TVEFHRU1BU0s7Cgl9CgoJaWYgKHByZWZpeCkgewoJCXN0YXRpYyBjb25zdCBjaGFyICoobWF0Y2hidWZbMV0pOwoJCW1hdGNoYnVmWzBdID0gTlVMTDsKCQlwYXJzZV9wYXRoc3BlYygmcGF0aHNwZWMsIFBBVEhTUEVDX0FMTF9NQUdJQywKCQkJICAgICAgIFBBVEhTUEVDX1BSRUZFUl9DV0QsIHByZWZpeCwgbWF0Y2hidWYpOwoJfSBlbHNlCgkJbWVtc2V0KCZwYXRoc3BlYywgMCwgc2l6ZW9mKHBhdGhzcGVjKSk7CglpZiAocmVhZF90cmVlKHRyZWUsIDEsICZwYXRoc3BlYykpCgkJZGllKCJ1bmFibGUgdG8gcmVhZCB0cmVlIGVudHJpZXMgJXMiLCB0cmVlX25hbWUpOwoKCWZvciAoaSA9IDA7IGkgPCBhY3RpdmVfbnI7IGkrKykgewoJCXN0cnVjdCBjYWNoZV9lbnRyeSAqY2UgPSBhY3RpdmVfY2FjaGVbaV07CgkJc3dpdGNoIChjZV9zdGFnZShjZSkpIHsKCQljYXNlIDA6CgkJCWxhc3Rfc3RhZ2UwID0gY2U7CgkJCS8qIGZhbGx0aHJ1ICovCgkJZGVmYXVsdDoKCQkJY29udGludWU7CgkJY2FzZSAxOgoJCQkvKgoJCQkgKiBJZiB0aGVyZSBpcyBzdGFnZSAjMCBlbnRyeSBmb3IgdGhpcywgd2UgZG8gbm90CgkJCSAqIG5lZWQgdG8gc2hvdyBpdC4gIFdlIHVzZSBDRV9VUERBVEUgYml0IHRvIG1hcmsKCQkJICogc3VjaCBhbiBlbnRyeS4KCQkJICovCgkJCWlmIChsYXN0X3N0YWdlMCAmJgoJCQkgICAgIXN0cmNtcChsYXN0X3N0YWdlMC0+bmFtZSwgY2UtPm5hbWUpKQoJCQkJY2UtPmNlX2ZsYWdzIHw9IENFX1VQREFURTsKCQl9Cgl9Cn0KCnN0YXRpYyBjb25zdCBjaGFyICogY29uc3QgbHNfZmlsZXNfdXNhZ2VbXSA9IHsKCU5fKCJnaXQgbHMtZmlsZXMgWzxvcHRpb25zPl0gWzxmaWxlPi4uLl0iKSwKCU5VTEwKfTsKCnN0YXRpYyBpbnQgb3B0aW9uX3BhcnNlX2V4Y2x1ZGUoY29uc3Qgc3RydWN0IG9wdGlvbiAqb3B0LAoJCQkJY29uc3QgY2hhciAqYXJnLCBpbnQgdW5zZXQpCnsKCXN0cnVjdCBzdHJpbmdfbGlzdCAqZXhjbHVkZV9saXN0ID0gb3B0LT52YWx1ZTsKCglleGNfZ2l2ZW4gPSAxOwoJc3RyaW5nX2xpc3RfYXBwZW5kKGV4Y2x1ZGVfbGlzdCwgYXJnKTsKCglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBvcHRpb25fcGFyc2VfZXhjbHVkZV9mcm9tKGNvbnN0IHN0cnVjdCBvcHRpb24gKm9wdCwKCQkJCSAgICAgY29uc3QgY2hhciAqYXJnLCBpbnQgdW5zZXQpCnsKCXN0cnVjdCBkaXJfc3RydWN0ICpkaXIgPSBvcHQtPnZhbHVlOwoKCWV4Y19naXZlbiA9IDE7CglhZGRfZXhjbHVkZXNfZnJvbV9maWxlKGRpciwgYXJnKTsKCglyZXR1cm4gMDsKfQoKc3RhdGljIGludCBvcHRpb25fcGFyc2VfZXhjbHVkZV9zdGFuZGFyZChjb25zdCBzdHJ1Y3Qgb3B0aW9uICpvcHQsCgkJCQkJIGNvbnN0IGNoYXIgKmFyZywgaW50IHVuc2V0KQp7CglzdHJ1Y3QgZGlyX3N0cnVjdCAqZGlyID0gb3B0LT52YWx1ZTsKCglleGNfZ2l2ZW4gPSAxOwoJc2V0dXBfc3RhbmRhcmRfZXhjbHVkZXMoZGlyKTsKCglyZXR1cm4gMDsKfQoKaW50IGNtZF9sc19maWxlcyhpbnQgYXJnYywgY29uc3QgY2hhciAqKmFyZ3YsIGNvbnN0IGNoYXIgKmNtZF9wcmVmaXgpCnsKCWludCByZXF1aXJlX3dvcmtfdHJlZSA9IDAsIHNob3dfdGFnID0gMCwgaTsKCWNvbnN0IGNoYXIgKm1heF9wcmVmaXg7CglzdHJ1Y3QgZGlyX3N0cnVjdCBkaXI7CglzdHJ1Y3QgZXhjbHVkZV9saXN0ICplbDsKCXN0cnVjdCBzdHJpbmdfbGlzdCBleGNsdWRlX2xpc3QgPSBTVFJJTkdfTElTVF9JTklUX05PRFVQOwoJc3RydWN0IG9wdGlvbiBidWlsdGluX2xzX2ZpbGVzX29wdGlvbnNbXSA9IHsKCQkvKiBUaGluayB0d2ljZSBiZWZvcmUgYWRkaW5nICItLW51bCIgc3lub255bSB0byB0aGlzICovCgkJT1BUX1NFVF9JTlQoJ3onLCBOVUxMLCAmbGluZV90ZXJtaW5hdG9yLAoJCQlOXygicGF0aHMgYXJlIHNlcGFyYXRlZCB3aXRoIE5VTCBjaGFyYWN0ZXIiKSwgJ1wwJyksCgkJT1BUX0JPT0woJ3QnLCBOVUxMLCAmc2hvd190YWcsCgkJCU5fKCJpZGVudGlmeSB0aGUgZmlsZSBzdGF0dXMgd2l0aCB0YWdzIikpLAoJCU9QVF9CT09MKCd2JywgTlVMTCwgJnNob3dfdmFsaWRfYml0LAoJCQlOXygidXNlIGxvd2VyY2FzZSBsZXR0ZXJzIGZvciAnYXNzdW1lIHVuY2hhbmdlZCcgZmlsZXMiKSksCgkJT1BUX0JPT0woJ2MnLCAiY2FjaGVkIiwgJnNob3dfY2FjaGVkLAoJCQlOXygic2hvdyBjYWNoZWQgZmlsZXMgaW4gdGhlIG91dHB1dCAoZGVmYXVsdCkiKSksCgkJT1BUX0JPT0woJ2QnLCAiZGVsZXRlZCIsICZzaG93X2RlbGV0ZWQsCgkJCU5fKCJzaG93IGRlbGV0ZWQgZmlsZXMgaW4gdGhlIG91dHB1dCIpKSwKCQlPUFRfQk9PTCgnbScsICJtb2RpZmllZCIsICZzaG93X21vZGlmaWVkLAoJCQlOXygic2hvdyBtb2RpZmllZCBmaWxlcyBpbiB0aGUgb3V0cHV0IikpLAoJCU9QVF9CT09MKCdvJywgIm90aGVycyIsICZzaG93X290aGVycywKCQkJTl8oInNob3cgb3RoZXIgZmlsZXMgaW4gdGhlIG91dHB1dCIpKSwKCQlPUFRfQklUKCdpJywgImlnbm9yZWQiLCAmZGlyLmZsYWdzLAoJCQlOXygic2hvdyBpZ25vcmVkIGZpbGVzIGluIHRoZSBvdXRwdXQiKSwKCQkJRElSX1NIT1dfSUdOT1JFRCksCgkJT1BUX0JPT0woJ3MnLCAic3RhZ2UiLCAmc2hvd19zdGFnZSwKCQkJTl8oInNob3cgc3RhZ2VkIGNvbnRlbnRzJyBvYmplY3QgbmFtZSBpbiB0aGUgb3V0cHV0IikpLAoJCU9QVF9CT09MKCdrJywgImtpbGxlZCIsICZzaG93X2tpbGxlZCwKCQkJTl8oInNob3cgZmlsZXMgb24gdGhlIGZpbGVzeXN0ZW0gdGhhdCBuZWVkIHRvIGJlIHJlbW92ZWQiKSksCgkJT1BUX0JJVCgwLCAiZGlyZWN0b3J5IiwgJmRpci5mbGFncywKCQkJTl8oInNob3cgJ290aGVyJyBkaXJlY3RvcmllcycgbmFtZXMgb25seSIpLAoJCQlESVJfU0hPV19PVEhFUl9ESVJFQ1RPUklFUyksCgkJT1BUX0JPT0woMCwgImVvbCIsICZzaG93X2VvbCwgTl8oInNob3cgbGluZSBlbmRpbmdzIG9mIGZpbGVzIikpLAoJCU9QVF9ORUdCSVQoMCwgImVtcHR5LWRpcmVjdG9yeSIsICZkaXIuZmxhZ3MsCgkJCU5fKCJkb24ndCBzaG93IGVtcHR5IGRpcmVjdG9yaWVzIiksCgkJCURJUl9ISURFX0VNUFRZX0RJUkVDVE9SSUVTKSwKCQlPUFRfQk9PTCgndScsICJ1bm1lcmdlZCIsICZzaG93X3VubWVyZ2VkLAoJCQlOXygic2hvdyB1bm1lcmdlZCBmaWxlcyBpbiB0aGUgb3V0cHV0IikpLAoJCU9QVF9CT09MKDAsICJyZXNvbHZlLXVuZG8iLCAmc2hvd19yZXNvbHZlX3VuZG8sCgkJCSAgICBOXygic2hvdyByZXNvbHZlLXVuZG8gaW5mb3JtYXRpb24iKSksCgkJeyBPUFRJT05fQ0FMTEJBQ0ssICd4JywgImV4Y2x1ZGUiLCAmZXhjbHVkZV9saXN0LCBOXygicGF0dGVybiIpLAoJCQlOXygic2tpcCBmaWxlcyBtYXRjaGluZyBwYXR0ZXJuIiksCgkJCTAsIG9wdGlvbl9wYXJzZV9leGNsdWRlIH0sCgkJeyBPUFRJT05fQ0FMTEJBQ0ssICdYJywgImV4Y2x1ZGUtZnJvbSIsICZkaXIsIE5fKCJmaWxlIiksCgkJCU5fKCJleGNsdWRlIHBhdHRlcm5zIGFyZSByZWFkIGZyb20gPGZpbGU+IiksCgkJCTAsIG9wdGlvbl9wYXJzZV9leGNsdWRlX2Zyb20gfSwKCQlPUFRfU1RSSU5HKDAsICJleGNsdWRlLXBlci1kaXJlY3RvcnkiLCAmZGlyLmV4Y2x1ZGVfcGVyX2RpciwgTl8oImZpbGUiKSwKCQkJTl8oInJlYWQgYWRkaXRpb25hbCBwZXItZGlyZWN0b3J5IGV4Y2x1ZGUgcGF0dGVybnMgaW4gPGZpbGU+IikpLAoJCXsgT1BUSU9OX0NBTExCQUNLLCAwLCAiZXhjbHVkZS1zdGFuZGFyZCIsICZkaXIsIE5VTEwsCgkJCU5fKCJhZGQgdGhlIHN0YW5kYXJkIGdpdCBleGNsdXNpb25zIiksCgkJCVBBUlNFX09QVF9OT0FSRywgb3B0aW9uX3BhcnNlX2V4Y2x1ZGVfc3RhbmRhcmQgfSwKCQl7IE9QVElPTl9TRVRfSU5ULCAwLCAiZnVsbC1uYW1lIiwgJnByZWZpeF9sZW4sIE5VTEwsCgkJCU5fKCJtYWtlIHRoZSBvdXRwdXQgcmVsYXRpdmUgdG8gdGhlIHByb2plY3QgdG9wIGRpcmVjdG9yeSIpLAoJCQlQQVJTRV9PUFRfTk9BUkcgfCBQQVJTRV9PUFRfTk9ORUcsIE5VTEwgfSwKCQlPUFRfQk9PTCgwLCAicmVjdXJzZS1zdWJtb2R1bGVzIiwgJnJlY3Vyc2Vfc3VibW9kdWxlcywKCQkJTl8oInJlY3Vyc2UgdGhyb3VnaCBzdWJtb2R1bGVzIikpLAoJCU9QVF9CT09MKDAsICJlcnJvci11bm1hdGNoIiwgJmVycm9yX3VubWF0Y2gsCgkJCU5fKCJpZiBhbnkgPGZpbGU+IGlzIG5vdCBpbiB0aGUgaW5kZXgsIHRyZWF0IHRoaXMgYXMgYW4gZXJyb3IiKSksCgkJT1BUX1NUUklORygwLCAid2l0aC10cmVlIiwgJndpdGhfdHJlZSwgTl8oInRyZWUtaXNoIiksCgkJCU5fKCJwcmV0ZW5kIHRoYXQgcGF0aHMgcmVtb3ZlZCBzaW5jZSA8dHJlZS1pc2g+IGFyZSBzdGlsbCBwcmVzZW50IikpLAoJCU9QVF9fQUJCUkVWKCZhYmJyZXYpLAoJCU9QVF9CT09MKDAsICJkZWJ1ZyIsICZkZWJ1Z19tb2RlLCBOXygic2hvdyBkZWJ1Z2dpbmcgZGF0YSIpKSwKCQlPUFRfRU5EKCkKCX07CgoJaWYgKGFyZ2MgPT0gMiAmJiAhc3RyY21wKGFyZ3ZbMV0sICItaCIpKQoJCXVzYWdlX3dpdGhfb3B0aW9ucyhsc19maWxlc191c2FnZSwgYnVpbHRpbl9sc19maWxlc19vcHRpb25zKTsKCgltZW1zZXQoJmRpciwgMCwgc2l6ZW9mKGRpcikpOwoJcHJlZml4ID0gY21kX3ByZWZpeDsKCWlmIChwcmVmaXgpCgkJcHJlZml4X2xlbiA9IHN0cmxlbihwcmVmaXgpOwoJc3VwZXJfcHJlZml4ID0gZ2V0X3N1cGVyX3ByZWZpeCgpOwoJZ2l0X2NvbmZpZyhnaXRfZGVmYXVsdF9jb25maWcsIE5VTEwpOwoKCWlmIChyZWFkX2NhY2hlKCkgPCAwKQoJCWRpZSgiaW5kZXggZmlsZSBjb3JydXB0Iik7CgoJYXJnYyA9IHBhcnNlX29wdGlvbnMoYXJnYywgYXJndiwgcHJlZml4LCBidWlsdGluX2xzX2ZpbGVzX29wdGlvbnMsCgkJCWxzX2ZpbGVzX3VzYWdlLCAwKTsKCWVsID0gYWRkX2V4Y2x1ZGVfbGlzdCgmZGlyLCBFWENfQ01ETCwgIi0tZXhjbHVkZSBvcHRpb24iKTsKCWZvciAoaSA9IDA7IGkgPCBleGNsdWRlX2xpc3QubnI7IGkrKykgewoJCWFkZF9leGNsdWRlKGV4Y2x1ZGVfbGlzdC5pdGVtc1tpXS5zdHJpbmcsICIiLCAwLCBlbCwgLS1leGNsdWRlX2FyZ3MpOwoJfQoJaWYgKHNob3dfdGFnIHx8IHNob3dfdmFsaWRfYml0KSB7CgkJdGFnX2NhY2hlZCA9ICJIICI7CgkJdGFnX3VubWVyZ2VkID0gIk0gIjsKCQl0YWdfcmVtb3ZlZCA9ICJSICI7CgkJdGFnX21vZGlmaWVkID0gIkMgIjsKCQl0YWdfb3RoZXIgPSAiPyAiOwoJCXRhZ19raWxsZWQgPSAiSyAiOwoJCXRhZ19za2lwX3dvcmt0cmVlID0gIlMgIjsKCQl0YWdfcmVzb2x2ZV91bmRvID0gIlUgIjsKCX0KCWlmIChzaG93X21vZGlmaWVkIHx8IHNob3dfb3RoZXJzIHx8IHNob3dfZGVsZXRlZCB8fCAoZGlyLmZsYWdzICYgRElSX1NIT1dfSUdOT1JFRCkgfHwgc2hvd19raWxsZWQpCgkJcmVxdWlyZV93b3JrX3RyZWUgPSAxOwoJaWYgKHNob3dfdW5tZXJnZWQpCgkJLyoKCQkgKiBUaGVyZSdzIG5vIHBvaW50IGluIHNob3dpbmcgdW5tZXJnZWQgdW5sZXNzCgkJICogeW91IGFsc28gc2hvdyB0aGUgc3RhZ2UgaW5mb3JtYXRpb24uCgkJICovCgkJc2hvd19zdGFnZSA9IDE7CglpZiAoZGlyLmV4Y2x1ZGVfcGVyX2RpcikKCQlleGNfZ2l2ZW4gPSAxOwoKCWlmIChyZXF1aXJlX3dvcmtfdHJlZSAmJiAhaXNfaW5zaWRlX3dvcmtfdHJlZSgpKQoJCXNldHVwX3dvcmtfdHJlZSgpOwoKCWlmIChyZWN1cnNlX3N1Ym1vZHVsZXMpCgkJY29tcGlsZV9zdWJtb2R1bGVfb3B0aW9ucyhhcmd2LCAmZGlyLCBzaG93X3RhZyk7CgoJaWYgKHJlY3Vyc2Vfc3VibW9kdWxlcyAmJgoJICAgIChzaG93X3N0YWdlIHx8IHNob3dfZGVsZXRlZCB8fCBzaG93X290aGVycyB8fCBzaG93X3VubWVyZ2VkIHx8CgkgICAgIHNob3dfa2lsbGVkIHx8IHNob3dfbW9kaWZpZWQgfHwgc2hvd19yZXNvbHZlX3VuZG8gfHwgd2l0aF90cmVlKSkKCQlkaWUoImxzLWZpbGVzIC0tcmVjdXJzZS1zdWJtb2R1bGVzIHVuc3VwcG9ydGVkIG1vZGUiKTsKCglpZiAocmVjdXJzZV9zdWJtb2R1bGVzICYmIGVycm9yX3VubWF0Y2gpCgkJZGllKCJscy1maWxlcyAtLXJlY3Vyc2Utc3VibW9kdWxlcyBkb2VzIG5vdCBzdXBwb3J0ICIKCQkgICAgIi0tZXJyb3ItdW5tYXRjaCIpOwoKCXBhcnNlX3BhdGhzcGVjKCZwYXRoc3BlYywgMCwKCQkgICAgICAgUEFUSFNQRUNfUFJFRkVSX0NXRCwKCQkgICAgICAgcHJlZml4LCBhcmd2KTsKCgkvKgoJICogRmluZCBjb21tb24gcHJlZml4IGZvciBhbGwgcGF0aHNwZWMncwoJICogVGhpcyBpcyB1c2VkIGFzIGEgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uIHdoaWNoIHVuZm9ydHVuYXRlbHkgY2Fubm90CgkgKiBiZSBkb25lIHdoZW4gcmVjdXJzaW5nIGludG8gc3VibW9kdWxlcwoJICovCglpZiAocmVjdXJzZV9zdWJtb2R1bGVzKQoJCW1heF9wcmVmaXggPSBOVUxMOwoJZWxzZQoJCW1heF9wcmVmaXggPSBjb21tb25fcHJlZml4KCZwYXRoc3BlYyk7CgltYXhfcHJlZml4X2xlbiA9IGdldF9jb21tb25fcHJlZml4X2xlbihtYXhfcHJlZml4KTsKCglwcnVuZV9jYWNoZShtYXhfcHJlZml4LCBtYXhfcHJlZml4X2xlbik7CgoJLyogVHJlYXQgdW5tYXRjaGluZyBwYXRoc3BlYyBlbGVtZW50cyBhcyBlcnJvcnMgKi8KCWlmIChwYXRoc3BlYy5uciAmJiBlcnJvcl91bm1hdGNoKQoJCXBzX21hdGNoZWQgPSB4Y2FsbG9jKHBhdGhzcGVjLm5yLCAxKTsKCglpZiAoKGRpci5mbGFncyAmIERJUl9TSE9XX0lHTk9SRUQpICYmICFleGNfZ2l2ZW4pCgkJZGllKCJscy1maWxlcyAtLWlnbm9yZWQgbmVlZHMgc29tZSBleGNsdWRlIHBhdHRlcm4iKTsKCgkvKiBXaXRoIG5vIGZsYWdzLCB3ZSBkZWZhdWx0IHRvIHNob3dpbmcgdGhlIGNhY2hlZCBmaWxlcyAqLwoJaWYgKCEoc2hvd19zdGFnZSB8fCBzaG93X2RlbGV0ZWQgfHwgc2hvd19vdGhlcnMgfHwgc2hvd191bm1lcmdlZCB8fAoJICAgICAgc2hvd19raWxsZWQgfHwgc2hvd19tb2RpZmllZCB8fCBzaG93X3Jlc29sdmVfdW5kbykpCgkJc2hvd19jYWNoZWQgPSAxOwoKCWlmICh3aXRoX3RyZWUpIHsKCQkvKgoJCSAqIEJhc2ljIHNhbml0eSBjaGVjazsgc2hvdy1zdGFnZXMgYW5kIHNob3ctdW5tZXJnZWQKCQkgKiB3b3VsZCBub3QgbWFrZSBhbnkgc2Vuc2Ugd2l0aCB0aGlzIG9wdGlvbi4KCQkgKi8KCQlpZiAoc2hvd19zdGFnZSB8fCBzaG93X3VubWVyZ2VkKQoJCQlkaWUoImxzLWZpbGVzIC0td2l0aC10cmVlIGlzIGluY29tcGF0aWJsZSB3aXRoIC1zIG9yIC11Iik7CgkJb3ZlcmxheV90cmVlX29uX2NhY2hlKHdpdGhfdHJlZSwgbWF4X3ByZWZpeCk7Cgl9CglzaG93X2ZpbGVzKCZkaXIpOwoJaWYgKHNob3dfcmVzb2x2ZV91bmRvKQoJCXNob3dfcnVfaW5mbygpOwoKCWlmIChwc19tYXRjaGVkKSB7CgkJaW50IGJhZDsKCQliYWQgPSByZXBvcnRfcGF0aF9lcnJvcihwc19tYXRjaGVkLCAmcGF0aHNwZWMsIHByZWZpeCk7CgkJaWYgKGJhZCkKCQkJZnByaW50ZihzdGRlcnIsICJEaWQgeW91IGZvcmdldCB0byAnZ2l0IGFkZCc/XG4iKTsKCgkJcmV0dXJuIGJhZCA/IDEgOiAwOwoJfQoKCXJldHVybiAwOwp9Cg==",
    "text": "/*\n * This merges the file listing in the directory cache index\n * with the actual working directory list, and shows different\n * combinations of the two.\n *\n * Copyright (C) Linus Torvalds, 2005\n */\n#include \"cache.h\"\n#include \"quote.h\"\n#include \"dir.h\"\n#include \"builtin.h\"\n#include \"tree.h\"\n#include \"parse-options.h\"\n#include \"resolve-undo.h\"\n#include \"string-list.h\"\n#include \"pathspec.h\"\n#include \"run-command.h\"\n#include \"submodule.h\"\n\nstatic int abbrev;\nstatic int show_deleted;\nstatic int show_cached;\nstatic int show_others;\nstatic int show_stage;\nstatic int show_unmerged;\nstatic int show_resolve_undo;\nstatic int show_modified;\nstatic int show_killed;\nstatic int show_valid_bit;\nstatic int line_terminator = '\\n';\nstatic int debug_mode;\nstatic int show_eol;\nstatic int recurse_submodules;\nstatic struct argv_array submodule_options = ARGV_ARRAY_INIT;\n\nstatic const char *prefix;\nstatic const char *super_prefix;\nstatic int max_prefix_len;\nstatic int prefix_len;\nstatic struct pathspec pathspec;\nstatic int error_unmatch;\nstatic char *ps_matched;\nstatic const char *with_tree;\nstatic int exc_given;\nstatic int exclude_args;\n\nstatic const char *tag_cached = \"\";\nstatic const char *tag_unmerged = \"\";\nstatic const char *tag_removed = \"\";\nstatic const char *tag_other = \"\";\nstatic const char *tag_killed = \"\";\nstatic const char *tag_modified = \"\";\nstatic const char *tag_skip_worktree = \"\";\nstatic const char *tag_resolve_undo = \"\";\n\nstatic void write_eolinfo(const struct cache_entry *ce, const char *path)\n{\n\tif (!show_eol)\n\t\treturn;\n\telse {\n\t\tstruct stat st;\n\t\tconst char *i_txt = \"\";\n\t\tconst char *w_txt = \"\";\n\t\tconst char *a_txt = get_convert_attr_ascii(path);\n\t\tif (ce && S_ISREG(ce->ce_mode))\n\t\t\ti_txt = get_cached_convert_stats_ascii(&the_index,\n\t\t\t\t\t\t\t       ce->name);\n\t\tif (!lstat(path, &st) && S_ISREG(st.st_mode))\n\t\t\tw_txt = get_wt_convert_stats_ascii(path);\n\t\tprintf(\"i/%-5s w/%-5s attr/%-17s\\t\", i_txt, w_txt, a_txt);\n\t}\n}\n\nstatic void write_name(const char *name)\n{\n\t/*\n\t * Prepend the super_prefix to name to construct the full_name to be\n\t * written.\n\t */\n\tstruct strbuf full_name = STRBUF_INIT;\n\tif (super_prefix) {\n\t\tstrbuf_addstr(&full_name, super_prefix);\n\t\tstrbuf_addstr(&full_name, name);\n\t\tname = full_name.buf;\n\t}\n\n\t/*\n\t * With \"--full-name\", prefix_len=0; this caller needs to pass\n\t * an empty string in that case (a NULL is good for \"\").\n\t */\n\twrite_name_quoted_relative(name, prefix_len ? prefix : NULL,\n\t\t\t\t   stdout, line_terminator);\n\n\tstrbuf_release(&full_name);\n}\n\nstatic void show_dir_entry(const char *tag, struct dir_entry *ent)\n{\n\tint len = max_prefix_len;\n\n\tif (len > ent->len)\n\t\tdie(\"git ls-files: internal error - directory entry not superset of prefix\");\n\n\tif (!dir_path_match(ent, &pathspec, len, ps_matched))\n\t\treturn;\n\n\tfputs(tag, stdout);\n\twrite_eolinfo(NULL, ent->name);\n\twrite_name(ent->name);\n}\n\nstatic void show_other_files(struct dir_struct *dir)\n{\n\tint i;\n\n\tfor (i = 0; i < dir->nr; i++) {\n\t\tstruct dir_entry *ent = dir->entries[i];\n\t\tif (!cache_name_is_other(ent->name, ent->len))\n\t\t\tcontinue;\n\t\tshow_dir_entry(tag_other, ent);\n\t}\n}\n\nstatic void show_killed_files(struct dir_struct *dir)\n{\n\tint i;\n\tfor (i = 0; i < dir->nr; i++) {\n\t\tstruct dir_entry *ent = dir->entries[i];\n\t\tchar *cp, *sp;\n\t\tint pos, len, killed = 0;\n\n\t\tfor (cp = ent->name; cp - ent->name < ent->len; cp = sp + 1) {\n\t\t\tsp = strchr(cp, '/');\n\t\t\tif (!sp) {\n\t\t\t\t/* If ent->name is prefix of an entry in the\n\t\t\t\t * cache, it will be killed.\n\t\t\t\t */\n\t\t\t\tpos = cache_name_pos(ent->name, ent->len);\n\t\t\t\tif (0 <= pos)\n\t\t\t\t\tdie(\"BUG: killed-file %.*s not found\",\n\t\t\t\t\t\tent->len, ent->name);\n\t\t\t\tpos = -pos - 1;\n\t\t\t\twhile (pos < active_nr &&\n\t\t\t\t       ce_stage(active_cache[pos]))\n\t\t\t\t\tpos++; /* skip unmerged */\n\t\t\t\tif (active_nr <= pos)\n\t\t\t\t\tbreak;\n\t\t\t\t/* pos points at a name immediately after\n\t\t\t\t * ent->name in the cache.  Does it expect\n\t\t\t\t * ent->name to be a directory?\n\t\t\t\t */\n\t\t\t\tlen = ce_namelen(active_cache[pos]);\n\t\t\t\tif ((ent->len < len) &&\n\t\t\t\t    !strncmp(active_cache[pos]->name,\n\t\t\t\t\t     ent->name, ent->len) &&\n\t\t\t\t    active_cache[pos]->name[ent->len] == '/')\n\t\t\t\t\tkilled = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (0 <= cache_name_pos(ent->name, sp - ent->name)) {\n\t\t\t\t/* If any of the leading directories in\n\t\t\t\t * ent->name is registered in the cache,\n\t\t\t\t * ent->name will be killed.\n\t\t\t\t */\n\t\t\t\tkilled = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (killed)\n\t\t\tshow_dir_entry(tag_killed, dir->entries[i]);\n\t}\n}\n\n/*\n * Compile an argv_array with all of the options supported by --recurse_submodules\n */\nstatic void compile_submodule_options(const char **argv,\n\t\t\t\t      const struct dir_struct *dir,\n\t\t\t\t      int show_tag)\n{\n\tif (line_terminator == '\\0')\n\t\targv_array_push(&submodule_options, \"-z\");\n\tif (show_tag)\n\t\targv_array_push(&submodule_options, \"-t\");\n\tif (show_valid_bit)\n\t\targv_array_push(&submodule_options, \"-v\");\n\tif (show_cached)\n\t\targv_array_push(&submodule_options, \"--cached\");\n\tif (show_eol)\n\t\targv_array_push(&submodule_options, \"--eol\");\n\tif (debug_mode)\n\t\targv_array_push(&submodule_options, \"--debug\");\n\n\t/* Add Pathspecs */\n\targv_array_push(&submodule_options, \"--\");\n\tfor (; *argv; argv++)\n\t\targv_array_push(&submodule_options, *argv);\n}\n\n/**\n * Recursively call ls-files on a submodule\n */\nstatic void show_gitlink(const struct cache_entry *ce)\n{\n\tstruct child_process cp = CHILD_PROCESS_INIT;\n\tint status;\n\tchar *dir;\n\n\tprepare_submodule_repo_env(&cp.env_array);\n\targv_array_push(&cp.env_array, GIT_DIR_ENVIRONMENT);\n\n\tif (prefix_len)\n\t\targv_array_pushf(&cp.env_array, \"%s=%s\",\n\t\t\t\t GIT_TOPLEVEL_PREFIX_ENVIRONMENT,\n\t\t\t\t prefix);\n\targv_array_pushf(&cp.args, \"--super-prefix=%s%s/\",\n\t\t\t super_prefix ? super_prefix : \"\",\n\t\t\t ce->name);\n\targv_array_push(&cp.args, \"ls-files\");\n\targv_array_push(&cp.args, \"--recurse-submodules\");\n\n\t/* add supported options */\n\targv_array_pushv(&cp.args, submodule_options.argv);\n\n\tcp.git_cmd = 1;\n\tdir = mkpathdup(\"%s/%s\", get_git_work_tree(), ce->name);\n\tcp.dir = dir;\n\tstatus = run_command(&cp);\n\tfree(dir);\n\tif (status)\n\t\texit(status);\n}\n\nstatic void show_ce_entry(const char *tag, const struct cache_entry *ce)\n{\n\tstruct strbuf name = STRBUF_INIT;\n\tint len = max_prefix_len;\n\tif (super_prefix)\n\t\tstrbuf_addstr(&name, super_prefix);\n\tstrbuf_addstr(&name, ce->name);\n\n\tif (len > ce_namelen(ce))\n\t\tdie(\"git ls-files: internal error - cache entry not superset of prefix\");\n\n\tif (recurse_submodules && S_ISGITLINK(ce->ce_mode) &&\n\t    submodule_path_match(&pathspec, name.buf, ps_matched)) {\n\t\tshow_gitlink(ce);\n\t} else if (match_pathspec(&pathspec, name.buf, name.len,\n\t\t\t\t  len, ps_matched,\n\t\t\t\t  S_ISDIR(ce->ce_mode) ||\n\t\t\t\t  S_ISGITLINK(ce->ce_mode))) {\n\t\tif (tag && *tag && show_valid_bit &&\n\t\t    (ce->ce_flags & CE_VALID)) {\n\t\t\tstatic char alttag[4];\n\t\t\tmemcpy(alttag, tag, 3);\n\t\t\tif (isalpha(tag[0]))\n\t\t\t\talttag[0] = tolower(tag[0]);\n\t\t\telse if (tag[0] == '?')\n\t\t\t\talttag[0] = '!';\n\t\t\telse {\n\t\t\t\talttag[0] = 'v';\n\t\t\t\talttag[1] = tag[0];\n\t\t\t\talttag[2] = ' ';\n\t\t\t\talttag[3] = 0;\n\t\t\t}\n\t\t\ttag = alttag;\n\t\t}\n\n\t\tif (!show_stage) {\n\t\t\tfputs(tag, stdout);\n\t\t} else {\n\t\t\tprintf(\"%s%06o %s %d\\t\",\n\t\t\t       tag,\n\t\t\t       ce->ce_mode,\n\t\t\t       find_unique_abbrev(ce->oid.hash, abbrev),\n\t\t\t       ce_stage(ce));\n\t\t}\n\t\twrite_eolinfo(ce, ce->name);\n\t\twrite_name(ce->name);\n\t\tif (debug_mode) {\n\t\t\tconst struct stat_data *sd = &ce->ce_stat_data;\n\n\t\t\tprintf(\"  ctime: %d:%d\\n\", sd->sd_ctime.sec, sd->sd_ctime.nsec);\n\t\t\tprintf(\"  mtime: %d:%d\\n\", sd->sd_mtime.sec, sd->sd_mtime.nsec);\n\t\t\tprintf(\"  dev: %d\\tino: %d\\n\", sd->sd_dev, sd->sd_ino);\n\t\t\tprintf(\"  uid: %d\\tgid: %d\\n\", sd->sd_uid, sd->sd_gid);\n\t\t\tprintf(\"  size: %d\\tflags: %x\\n\", sd->sd_size, ce->ce_flags);\n\t\t}\n\t}\n\n\tstrbuf_release(&name);\n}\n\nstatic void show_ru_info(void)\n{\n\tstruct string_list_item *item;\n\n\tif (!the_index.resolve_undo)\n\t\treturn;\n\n\tfor_each_string_list_item(item, the_index.resolve_undo) {\n\t\tconst char *path = item->string;\n\t\tstruct resolve_undo_info *ui = item->util;\n\t\tint i, len;\n\n\t\tlen = strlen(path);\n\t\tif (len < max_prefix_len)\n\t\t\tcontinue; /* outside of the prefix */\n\t\tif (!match_pathspec(&pathspec, path, len,\n\t\t\t\t    max_prefix_len, ps_matched, 0))\n\t\t\tcontinue; /* uninterested */\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tif (!ui->mode[i])\n\t\t\t\tcontinue;\n\t\t\tprintf(\"%s%06o %s %d\\t\", tag_resolve_undo, ui->mode[i],\n\t\t\t       find_unique_abbrev(ui->sha1[i], abbrev),\n\t\t\t       i + 1);\n\t\t\twrite_name(path);\n\t\t}\n\t}\n}\n\nstatic int ce_excluded(struct dir_struct *dir, const struct cache_entry *ce)\n{\n\tint dtype = ce_to_dtype(ce);\n\treturn is_excluded(dir, &the_index, ce->name, &dtype);\n}\n\nstatic void show_files(struct dir_struct *dir)\n{\n\tint i;\n\n\t/* For cached/deleted files we don't need to even do the readdir */\n\tif (show_others || show_killed) {\n\t\tif (!show_others)\n\t\t\tdir->flags |= DIR_COLLECT_KILLED_ONLY;\n\t\tfill_directory(dir, &the_index, &pathspec);\n\t\tif (show_others)\n\t\t\tshow_other_files(dir);\n\t\tif (show_killed)\n\t\t\tshow_killed_files(dir);\n\t}\n\tif (show_cached || show_stage) {\n\t\tfor (i = 0; i < active_nr; i++) {\n\t\t\tconst struct cache_entry *ce = active_cache[i];\n\t\t\tif ((dir->flags & DIR_SHOW_IGNORED) &&\n\t\t\t    !ce_excluded(dir, ce))\n\t\t\t\tcontinue;\n\t\t\tif (show_unmerged && !ce_stage(ce))\n\t\t\t\tcontinue;\n\t\t\tif (ce->ce_flags & CE_UPDATE)\n\t\t\t\tcontinue;\n\t\t\tshow_ce_entry(ce_stage(ce) ? tag_unmerged :\n\t\t\t\t(ce_skip_worktree(ce) ? tag_skip_worktree : tag_cached), ce);\n\t\t}\n\t}\n\tif (show_deleted || show_modified) {\n\t\tfor (i = 0; i < active_nr; i++) {\n\t\t\tconst struct cache_entry *ce = active_cache[i];\n\t\t\tstruct stat st;\n\t\t\tint err;\n\t\t\tif ((dir->flags & DIR_SHOW_IGNORED) &&\n\t\t\t    !ce_excluded(dir, ce))\n\t\t\t\tcontinue;\n\t\t\tif (ce->ce_flags & CE_UPDATE)\n\t\t\t\tcontinue;\n\t\t\tif (ce_skip_worktree(ce))\n\t\t\t\tcontinue;\n\t\t\terr = lstat(ce->name, &st);\n\t\t\tif (show_deleted && err)\n\t\t\t\tshow_ce_entry(tag_removed, ce);\n\t\t\tif (show_modified && ce_modified(ce, &st, 0))\n\t\t\t\tshow_ce_entry(tag_modified, ce);\n\t\t}\n\t}\n}\n\n/*\n * Prune the index to only contain stuff starting with \"prefix\"\n */\nstatic void prune_cache(const char *prefix, size_t prefixlen)\n{\n\tint pos;\n\tunsigned int first, last;\n\n\tif (!prefix)\n\t\treturn;\n\tpos = cache_name_pos(prefix, prefixlen);\n\tif (pos < 0)\n\t\tpos = -pos-1;\n\tfirst = pos;\n\tlast = active_nr;\n\twhile (last > first) {\n\t\tint next = (last + first) >> 1;\n\t\tconst struct cache_entry *ce = active_cache[next];\n\t\tif (!strncmp(ce->name, prefix, prefixlen)) {\n\t\t\tfirst = next+1;\n\t\t\tcontinue;\n\t\t}\n\t\tlast = next;\n\t}\n\tmemmove(active_cache, active_cache + pos,\n\t\t(last - pos) * sizeof(struct cache_entry *));\n\tactive_nr = last - pos;\n}\n\nstatic int get_common_prefix_len(const char *common_prefix)\n{\n\tint common_prefix_len;\n\n\tif (!common_prefix)\n\t\treturn 0;\n\n\tcommon_prefix_len = strlen(common_prefix);\n\n\t/*\n\t * If the prefix has a trailing slash, strip it so that submodules wont\n\t * be pruned from the index.\n\t */\n\tif (common_prefix[common_prefix_len - 1] == '/')\n\t\tcommon_prefix_len--;\n\n\treturn common_prefix_len;\n}\n\n/*\n * Read the tree specified with --with-tree option\n * (typically, HEAD) into stage #1 and then\n * squash them down to stage #0.  This is used for\n * --error-unmatch to list and check the path patterns\n * that were given from the command line.  We are not\n * going to write this index out.\n */\nvoid overlay_tree_on_cache(const char *tree_name, const char *prefix)\n{\n\tstruct tree *tree;\n\tstruct object_id oid;\n\tstruct pathspec pathspec;\n\tstruct cache_entry *last_stage0 = NULL;\n\tint i;\n\n\tif (get_oid(tree_name, &oid))\n\t\tdie(\"tree-ish %s not found.\", tree_name);\n\ttree = parse_tree_indirect(&oid);\n\tif (!tree)\n\t\tdie(\"bad tree-ish %s\", tree_name);\n\n\t/* Hoist the unmerged entries up to stage #3 to make room */\n\tfor (i = 0; i < active_nr; i++) {\n\t\tstruct cache_entry *ce = active_cache[i];\n\t\tif (!ce_stage(ce))\n\t\t\tcontinue;\n\t\tce->ce_flags |= CE_STAGEMASK;\n\t}\n\n\tif (prefix) {\n\t\tstatic const char *(matchbuf[1]);\n\t\tmatchbuf[0] = NULL;\n\t\tparse_pathspec(&pathspec, PATHSPEC_ALL_MAGIC,\n\t\t\t       PATHSPEC_PREFER_CWD, prefix, matchbuf);\n\t} else\n\t\tmemset(&pathspec, 0, sizeof(pathspec));\n\tif (read_tree(tree, 1, &pathspec))\n\t\tdie(\"unable to read tree entries %s\", tree_name);\n\n\tfor (i = 0; i < active_nr; i++) {\n\t\tstruct cache_entry *ce = active_cache[i];\n\t\tswitch (ce_stage(ce)) {\n\t\tcase 0:\n\t\t\tlast_stage0 = ce;\n\t\t\t/* fallthru */\n\t\tdefault:\n\t\t\tcontinue;\n\t\tcase 1:\n\t\t\t/*\n\t\t\t * If there is stage #0 entry for this, we do not\n\t\t\t * need to show it.  We use CE_UPDATE bit to mark\n\t\t\t * such an entry.\n\t\t\t */\n\t\t\tif (last_stage0 &&\n\t\t\t    !strcmp(last_stage0->name, ce->name))\n\t\t\t\tce->ce_flags |= CE_UPDATE;\n\t\t}\n\t}\n}\n\nstatic const char * const ls_files_usage[] = {\n\tN_(\"git ls-files [<options>] [<file>...]\"),\n\tNULL\n};\n\nstatic int option_parse_exclude(const struct option *opt,\n\t\t\t\tconst char *arg, int unset)\n{\n\tstruct string_list *exclude_list = opt->value;\n\n\texc_given = 1;\n\tstring_list_append(exclude_list, arg);\n\n\treturn 0;\n}\n\nstatic int option_parse_exclude_from(const struct option *opt,\n\t\t\t\t     const char *arg, int unset)\n{\n\tstruct dir_struct *dir = opt->value;\n\n\texc_given = 1;\n\tadd_excludes_from_file(dir, arg);\n\n\treturn 0;\n}\n\nstatic int option_parse_exclude_standard(const struct option *opt,\n\t\t\t\t\t const char *arg, int unset)\n{\n\tstruct dir_struct *dir = opt->value;\n\n\texc_given = 1;\n\tsetup_standard_excludes(dir);\n\n\treturn 0;\n}\n\nint cmd_ls_files(int argc, const char **argv, const char *cmd_prefix)\n{\n\tint require_work_tree = 0, show_tag = 0, i;\n\tconst char *max_prefix;\n\tstruct dir_struct dir;\n\tstruct exclude_list *el;\n\tstruct string_list exclude_list = STRING_LIST_INIT_NODUP;\n\tstruct option builtin_ls_files_options[] = {\n\t\t/* Think twice before adding \"--nul\" synonym to this */\n\t\tOPT_SET_INT('z', NULL, &line_terminator,\n\t\t\tN_(\"paths are separated with NUL character\"), '\\0'),\n\t\tOPT_BOOL('t', NULL, &show_tag,\n\t\t\tN_(\"identify the file status with tags\")),\n\t\tOPT_BOOL('v', NULL, &show_valid_bit,\n\t\t\tN_(\"use lowercase letters for 'assume unchanged' files\")),\n\t\tOPT_BOOL('c', \"cached\", &show_cached,\n\t\t\tN_(\"show cached files in the output (default)\")),\n\t\tOPT_BOOL('d', \"deleted\", &show_deleted,\n\t\t\tN_(\"show deleted files in the output\")),\n\t\tOPT_BOOL('m', \"modified\", &show_modified,\n\t\t\tN_(\"show modified files in the output\")),\n\t\tOPT_BOOL('o', \"others\", &show_others,\n\t\t\tN_(\"show other files in the output\")),\n\t\tOPT_BIT('i', \"ignored\", &dir.flags,\n\t\t\tN_(\"show ignored files in the output\"),\n\t\t\tDIR_SHOW_IGNORED),\n\t\tOPT_BOOL('s', \"stage\", &show_stage,\n\t\t\tN_(\"show staged contents' object name in the output\")),\n\t\tOPT_BOOL('k', \"killed\", &show_killed,\n\t\t\tN_(\"show files on the filesystem that need to be removed\")),\n\t\tOPT_BIT(0, \"directory\", &dir.flags,\n\t\t\tN_(\"show 'other' directories' names only\"),\n\t\t\tDIR_SHOW_OTHER_DIRECTORIES),\n\t\tOPT_BOOL(0, \"eol\", &show_eol, N_(\"show line endings of files\")),\n\t\tOPT_NEGBIT(0, \"empty-directory\", &dir.flags,\n\t\t\tN_(\"don't show empty directories\"),\n\t\t\tDIR_HIDE_EMPTY_DIRECTORIES),\n\t\tOPT_BOOL('u', \"unmerged\", &show_unmerged,\n\t\t\tN_(\"show unmerged files in the output\")),\n\t\tOPT_BOOL(0, \"resolve-undo\", &show_resolve_undo,\n\t\t\t    N_(\"show resolve-undo information\")),\n\t\t{ OPTION_CALLBACK, 'x', \"exclude\", &exclude_list, N_(\"pattern\"),\n\t\t\tN_(\"skip files matching pattern\"),\n\t\t\t0, option_parse_exclude },\n\t\t{ OPTION_CALLBACK, 'X', \"exclude-from\", &dir, N_(\"file\"),\n\t\t\tN_(\"exclude patterns are read from <file>\"),\n\t\t\t0, option_parse_exclude_from },\n\t\tOPT_STRING(0, \"exclude-per-directory\", &dir.exclude_per_dir, N_(\"file\"),\n\t\t\tN_(\"read additional per-directory exclude patterns in <file>\")),\n\t\t{ OPTION_CALLBACK, 0, \"exclude-standard\", &dir, NULL,\n\t\t\tN_(\"add the standard git exclusions\"),\n\t\t\tPARSE_OPT_NOARG, option_parse_exclude_standard },\n\t\t{ OPTION_SET_INT, 0, \"full-name\", &prefix_len, NULL,\n\t\t\tN_(\"make the output relative to the project top directory\"),\n\t\t\tPARSE_OPT_NOARG | PARSE_OPT_NONEG, NULL },\n\t\tOPT_BOOL(0, \"recurse-submodules\", &recurse_submodules,\n\t\t\tN_(\"recurse through submodules\")),\n\t\tOPT_BOOL(0, \"error-unmatch\", &error_unmatch,\n\t\t\tN_(\"if any <file> is not in the index, treat this as an error\")),\n\t\tOPT_STRING(0, \"with-tree\", &with_tree, N_(\"tree-ish\"),\n\t\t\tN_(\"pretend that paths removed since <tree-ish> are still present\")),\n\t\tOPT__ABBREV(&abbrev),\n\t\tOPT_BOOL(0, \"debug\", &debug_mode, N_(\"show debugging data\")),\n\t\tOPT_END()\n\t};\n\n\tif (argc == 2 && !strcmp(argv[1], \"-h\"))\n\t\tusage_with_options(ls_files_usage, builtin_ls_files_options);\n\n\tmemset(&dir, 0, sizeof(dir));\n\tprefix = cmd_prefix;\n\tif (prefix)\n\t\tprefix_len = strlen(prefix);\n\tsuper_prefix = get_super_prefix();\n\tgit_config(git_default_config, NULL);\n\n\tif (read_cache() < 0)\n\t\tdie(\"index file corrupt\");\n\n\targc = parse_options(argc, argv, prefix, builtin_ls_files_options,\n\t\t\tls_files_usage, 0);\n\tel = add_exclude_list(&dir, EXC_CMDL, \"--exclude option\");\n\tfor (i = 0; i < exclude_list.nr; i++) {\n\t\tadd_exclude(exclude_list.items[i].string, \"\", 0, el, --exclude_args);\n\t}\n\tif (show_tag || show_valid_bit) {\n\t\ttag_cached = \"H \";\n\t\ttag_unmerged = \"M \";\n\t\ttag_removed = \"R \";\n\t\ttag_modified = \"C \";\n\t\ttag_other = \"? \";\n\t\ttag_killed = \"K \";\n\t\ttag_skip_worktree = \"S \";\n\t\ttag_resolve_undo = \"U \";\n\t}\n\tif (show_modified || show_others || show_deleted || (dir.flags & DIR_SHOW_IGNORED) || show_killed)\n\t\trequire_work_tree = 1;\n\tif (show_unmerged)\n\t\t/*\n\t\t * There's no point in showing unmerged unless\n\t\t * you also show the stage information.\n\t\t */\n\t\tshow_stage = 1;\n\tif (dir.exclude_per_dir)\n\t\texc_given = 1;\n\n\tif (require_work_tree && !is_inside_work_tree())\n\t\tsetup_work_tree();\n\n\tif (recurse_submodules)\n\t\tcompile_submodule_options(argv, &dir, show_tag);\n\n\tif (recurse_submodules &&\n\t    (show_stage || show_deleted || show_others || show_unmerged ||\n\t     show_killed || show_modified || show_resolve_undo || with_tree))\n\t\tdie(\"ls-files --recurse-submodules unsupported mode\");\n\n\tif (recurse_submodules && error_unmatch)\n\t\tdie(\"ls-files --recurse-submodules does not support \"\n\t\t    \"--error-unmatch\");\n\n\tparse_pathspec(&pathspec, 0,\n\t\t       PATHSPEC_PREFER_CWD,\n\t\t       prefix, argv);\n\n\t/*\n\t * Find common prefix for all pathspec's\n\t * This is used as a performance optimization which unfortunately cannot\n\t * be done when recursing into submodules\n\t */\n\tif (recurse_submodules)\n\t\tmax_prefix = NULL;\n\telse\n\t\tmax_prefix = common_prefix(&pathspec);\n\tmax_prefix_len = get_common_prefix_len(max_prefix);\n\n\tprune_cache(max_prefix, max_prefix_len);\n\n\t/* Treat unmatching pathspec elements as errors */\n\tif (pathspec.nr && error_unmatch)\n\t\tps_matched = xcalloc(pathspec.nr, 1);\n\n\tif ((dir.flags & DIR_SHOW_IGNORED) && !exc_given)\n\t\tdie(\"ls-files --ignored needs some exclude pattern\");\n\n\t/* With no flags, we default to showing the cached files */\n\tif (!(show_stage || show_deleted || show_others || show_unmerged ||\n\t      show_killed || show_modified || show_resolve_undo))\n\t\tshow_cached = 1;\n\n\tif (with_tree) {\n\t\t/*\n\t\t * Basic sanity check; show-stages and show-unmerged\n\t\t * would not make any sense with this option.\n\t\t */\n\t\tif (show_stage || show_unmerged)\n\t\t\tdie(\"ls-files --with-tree is incompatible with -s or -u\");\n\t\toverlay_tree_on_cache(with_tree, max_prefix);\n\t}\n\tshow_files(&dir);\n\tif (show_resolve_undo)\n\t\tshow_ru_info();\n\n\tif (ps_matched) {\n\t\tint bad;\n\t\tbad = report_path_error(ps_matched, &pathspec, prefix);\n\t\tif (bad)\n\t\t\tfprintf(stderr, \"Did you forget to 'git add'?\\n\");\n\n\t\treturn bad ? 1 : 0;\n\t}\n\n\treturn 0;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0044abf66952c9ed7c50e7ed20b667e6dd386681",
  "sha1_ok": true,
  "size": 19195
}
