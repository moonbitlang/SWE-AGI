{
  "content": {
    "base64": "I2RlZmluZSBVU0VfVEhFX1JFUE9TSVRPUllfVkFSSUFCTEUKI2luY2x1ZGUgImJ1aWx0aW4uaCIKI2luY2x1ZGUgImdldHRleHQuaCIKI2luY2x1ZGUgImhleC5oIgojaW5jbHVkZSAiY29uZmlnLmgiCiNpbmNsdWRlICJjb21taXQuaCIKI2luY2x1ZGUgInRyZWUuaCIKI2luY2x1ZGUgImJsb2IuaCIKI2luY2x1ZGUgInRhZy5oIgojaW5jbHVkZSAicmVmcy5oIgojaW5jbHVkZSAicGFjay5oIgojaW5jbHVkZSAiY2FjaGUtdHJlZS5oIgojaW5jbHVkZSAiZnNjay5oIgojaW5jbHVkZSAicGFyc2Utb3B0aW9ucy5oIgojaW5jbHVkZSAicHJvZ3Jlc3MuaCIKI2luY2x1ZGUgInN0cmVhbWluZy5oIgojaW5jbHVkZSAicGFja2ZpbGUuaCIKI2luY2x1ZGUgIm9iamVjdC1maWxlLmgiCiNpbmNsdWRlICJvYmplY3QtbmFtZS5oIgojaW5jbHVkZSAib2RiLmgiCiNpbmNsdWRlICJwYXRoLmgiCiNpbmNsdWRlICJyZWFkLWNhY2hlLWxsLmgiCiNpbmNsdWRlICJyZXBsYWNlLW9iamVjdC5oIgojaW5jbHVkZSAicmVzb2x2ZS11bmRvLmgiCiNpbmNsdWRlICJydW4tY29tbWFuZC5oIgojaW5jbHVkZSAic3BhcnNlLWluZGV4LmgiCiNpbmNsdWRlICJ3b3JrdHJlZS5oIgojaW5jbHVkZSAicGFjay1yZXZpbmRleC5oIgojaW5jbHVkZSAicGFjay1iaXRtYXAuaCIKCiNkZWZpbmUgUkVBQ0hBQkxFIDB4MDAwMQojZGVmaW5lIFNFRU4gICAgICAweDAwMDIKI2RlZmluZSBIQVNfT0JKICAgMHgwMDA0Ci8qIFRoaXMgZmxhZyBpcyBzZXQgaWYgc29tZXRoaW5nIHBvaW50cyB0byB0aGlzIG9iamVjdC4gKi8KI2RlZmluZSBVU0VEICAgICAgMHgwMDA4CgpzdGF0aWMgaW50IHNob3dfcm9vdDsKc3RhdGljIGludCBzaG93X3RhZ3M7CnN0YXRpYyBpbnQgc2hvd191bnJlYWNoYWJsZTsKc3RhdGljIGludCBpbmNsdWRlX3JlZmxvZ3MgPSAxOwpzdGF0aWMgaW50IGNoZWNrX2Z1bGwgPSAxOwpzdGF0aWMgaW50IGNvbm5lY3Rpdml0eV9vbmx5OwpzdGF0aWMgaW50IGNoZWNrX3N0cmljdDsKc3RhdGljIGludCBrZWVwX2NhY2hlX29iamVjdHM7CnN0YXRpYyBzdHJ1Y3QgZnNja19vcHRpb25zIGZzY2tfd2Fsa19vcHRpb25zID0gRlNDS19PUFRJT05TX0RFRkFVTFQ7CnN0YXRpYyBzdHJ1Y3QgZnNja19vcHRpb25zIGZzY2tfb2JqX29wdGlvbnMgPSBGU0NLX09QVElPTlNfREVGQVVMVDsKc3RhdGljIGludCBlcnJvcnNfZm91bmQ7CnN0YXRpYyBpbnQgd3JpdGVfbG9zdF9hbmRfZm91bmQ7CnN0YXRpYyBpbnQgdmVyYm9zZTsKc3RhdGljIGludCBzaG93X3Byb2dyZXNzID0gLTE7CnN0YXRpYyBpbnQgc2hvd19kYW5nbGluZyA9IDE7CnN0YXRpYyBpbnQgbmFtZV9vYmplY3RzOwpzdGF0aWMgaW50IGNoZWNrX3JlZmVyZW5jZXMgPSAxOwojZGVmaW5lIEVSUk9SX09CSkVDVCAwMQojZGVmaW5lIEVSUk9SX1JFQUNIQUJMRSAwMgojZGVmaW5lIEVSUk9SX1BBQ0sgMDQKI2RlZmluZSBFUlJPUl9SRUZTIDAxMAojZGVmaW5lIEVSUk9SX0NPTU1JVF9HUkFQSCAwMjAKI2RlZmluZSBFUlJPUl9NVUxUSV9QQUNLX0lOREVYIDA0MAojZGVmaW5lIEVSUk9SX1BBQ0tfUkVWX0lOREVYIDAxMDAKI2RlZmluZSBFUlJPUl9CSVRNQVAgMDIwMAoKc3RhdGljIGNvbnN0IGNoYXIgKmRlc2NyaWJlX29iamVjdChjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQpCnsKCXJldHVybiBmc2NrX2Rlc2NyaWJlX29iamVjdCgmZnNja193YWxrX29wdGlvbnMsIG9pZCk7Cn0KCnN0YXRpYyBjb25zdCBjaGFyICpwcmludGFibGVfdHlwZShjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsCgkJCQkgIGVudW0gb2JqZWN0X3R5cGUgdHlwZSkKewoJY29uc3QgY2hhciAqcmV0OwoKCWlmICh0eXBlID09IE9CSl9OT05FKQoJCXR5cGUgPSBvZGJfcmVhZF9vYmplY3RfaW5mbyh0aGVfcmVwb3NpdG9yeS0+b2JqZWN0cywKCQkJCQkgICAgb2lkLCBOVUxMKTsKCglyZXQgPSB0eXBlX25hbWUodHlwZSk7CglpZiAoIXJldCkKCQlyZXQgPSBfKCJ1bmtub3duIik7CgoJcmV0dXJuIHJldDsKfQoKc3RhdGljIGludCBvYmplcnJvcihzdHJ1Y3Qgb2JqZWN0ICpvYmosIGNvbnN0IGNoYXIgKmVycikKewoJZXJyb3JzX2ZvdW5kIHw9IEVSUk9SX09CSkVDVDsKCS8qIFRSQU5TTEFUT1JTOiBlLmcuIGVycm9yIGluIHRyZWUgMDFiZmRhOiA8bW9yZSBleHBsYW5hdGlvbj4gKi8KCWZwcmludGZfbG4oc3RkZXJyLCBfKCJlcnJvciBpbiAlcyAlczogJXMiKSwKCQkgICBwcmludGFibGVfdHlwZSgmb2JqLT5vaWQsIG9iai0+dHlwZSksCgkJICAgZGVzY3JpYmVfb2JqZWN0KCZvYmotPm9pZCksIGVycik7CglyZXR1cm4gLTE7Cn0KCnN0YXRpYyBpbnQgZnNja19vYmplY3RzX2Vycm9yX2Z1bmMoc3RydWN0IGZzY2tfb3B0aW9ucyAqbyBVTlVTRUQsCgkJCQkgICB2b2lkICpmc2NrX3JlcG9ydCwKCQkJCSAgIGVudW0gZnNja19tc2dfdHlwZSBtc2dfdHlwZSwKCQkJCSAgIGVudW0gZnNja19tc2dfaWQgbXNnX2lkIFVOVVNFRCwKCQkJCSAgIGNvbnN0IGNoYXIgKm1lc3NhZ2UpCnsKCXN0cnVjdCBmc2NrX29iamVjdF9yZXBvcnQgKnJlcG9ydCA9IGZzY2tfcmVwb3J0OwoJY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkID0gcmVwb3J0LT5vaWQ7CgllbnVtIG9iamVjdF90eXBlIG9iamVjdF90eXBlID0gcmVwb3J0LT5vYmplY3RfdHlwZTsKCglzd2l0Y2ggKG1zZ190eXBlKSB7CgljYXNlIEZTQ0tfV0FSTjoKCQkvKiBUUkFOU0xBVE9SUzogZS5nLiB3YXJuaW5nIGluIHRyZWUgMDFiZmRhOiA8bW9yZSBleHBsYW5hdGlvbj4gKi8KCQlmcHJpbnRmX2xuKHN0ZGVyciwgXygid2FybmluZyBpbiAlcyAlczogJXMiKSwKCQkJICAgcHJpbnRhYmxlX3R5cGUob2lkLCBvYmplY3RfdHlwZSksCgkJCSAgIGRlc2NyaWJlX29iamVjdChvaWQpLCBtZXNzYWdlKTsKCQlyZXR1cm4gMDsKCWNhc2UgRlNDS19FUlJPUjoKCQkvKiBUUkFOU0xBVE9SUzogZS5nLiBlcnJvciBpbiB0cmVlIDAxYmZkYTogPG1vcmUgZXhwbGFuYXRpb24+ICovCgkJZnByaW50Zl9sbihzdGRlcnIsIF8oImVycm9yIGluICVzICVzOiAlcyIpLAoJCQkgICBwcmludGFibGVfdHlwZShvaWQsIG9iamVjdF90eXBlKSwKCQkJICAgZGVzY3JpYmVfb2JqZWN0KG9pZCksIG1lc3NhZ2UpOwoJCXJldHVybiAxOwoJZGVmYXVsdDoKCQlCVUcoIiVkIChGU0NLX0lHTk9SRT8pIHNob3VsZCBuZXZlciB0cmlnZ2VyIHRoaXMgY2FsbGJhY2siLAoJCSAgICBtc2dfdHlwZSk7Cgl9Cn0KCnN0YXRpYyBzdHJ1Y3Qgb2JqZWN0X2FycmF5IHBlbmRpbmc7CgpzdGF0aWMgaW50IG1hcmtfb2JqZWN0KHN0cnVjdCBvYmplY3QgKm9iaiwgZW51bSBvYmplY3RfdHlwZSB0eXBlLAoJCSAgICAgICB2b2lkICpkYXRhLCBzdHJ1Y3QgZnNja19vcHRpb25zICpvcHRpb25zIFVOVVNFRCkKewoJc3RydWN0IG9iamVjdCAqcGFyZW50ID0gZGF0YTsKCgkvKgoJICogVGhlIG9ubHkgY2FzZSBkYXRhIGlzIE5VTEwgb3IgdHlwZSBpcyBPQkpfQU5ZIGlzIHdoZW4KCSAqIG1hcmtfb2JqZWN0X3JlYWNoYWJsZSgpIGNhbGxzIHVzLiAgQWxsIHRoZSBjYWxsZXJzIG9mCgkgKiB0aGF0IGZ1bmN0aW9uIGhhcyBub24tTlVMTCBvYmogaGVuY2UgLi4uCgkgKi8KCWlmICghb2JqKSB7CgkJLyogLi4uIHRoZXNlIHJlZmVyZW5jZXMgdG8gcGFyZW50LT5mbGQgYXJlIHNhZmUgaGVyZSAqLwoJCXByaW50Zl9sbihfKCJicm9rZW4gbGluayBmcm9tICU3cyAlcyIpLAoJCQkgIHByaW50YWJsZV90eXBlKCZwYXJlbnQtPm9pZCwgcGFyZW50LT50eXBlKSwKCQkJICBkZXNjcmliZV9vYmplY3QoJnBhcmVudC0+b2lkKSk7CgkJcHJpbnRmX2xuKF8oImJyb2tlbiBsaW5rIGZyb20gJTdzICVzIiksCgkJCSAgKHR5cGUgPT0gT0JKX0FOWSA/IF8oInVua25vd24iKSA6IHR5cGVfbmFtZSh0eXBlKSksCgkJCSAgXygidW5rbm93biIpKTsKCQllcnJvcnNfZm91bmQgfD0gRVJST1JfUkVBQ0hBQkxFOwoJCXJldHVybiAxOwoJfQoKCWlmICh0eXBlICE9IE9CSl9BTlkgJiYgb2JqLT50eXBlICE9IHR5cGUpCgkJLyogLi4uIGFuZCB0aGUgcmVmZXJlbmNlIHRvIHBhcmVudCBpcyBzYWZlIGhlcmUgKi8KCQlvYmplcnJvcihwYXJlbnQsIF8oIndyb25nIG9iamVjdCB0eXBlIGluIGxpbmsiKSk7CgoJaWYgKG9iai0+ZmxhZ3MgJiBSRUFDSEFCTEUpCgkJcmV0dXJuIDA7CglvYmotPmZsYWdzIHw9IFJFQUNIQUJMRTsKCglpZiAoaXNfcHJvbWlzb3Jfb2JqZWN0KHRoZV9yZXBvc2l0b3J5LCAmb2JqLT5vaWQpKQoJCS8qCgkJICogRnVydGhlciByZWN1cnNpb24gZG9lcyBub3QgbmVlZCB0byBiZSBwZXJmb3JtZWQgb24gdGhpcwoJCSAqIG9iamVjdCBzaW5jZSBpdCBpcyBhIHByb21pc29yIG9iamVjdCAoc28gaXQgZG9lcyBub3QgbmVlZCB0bwoJCSAqIGJlIGFkZGVkIHRvICJwZW5kaW5nIikuCgkJICovCgkJcmV0dXJuIDA7CgoJaWYgKCEob2JqLT5mbGFncyAmIEhBU19PQkopKSB7CgkJaWYgKHBhcmVudCAmJiAhb2RiX2hhc19vYmplY3QodGhlX3JlcG9zaXRvcnktPm9iamVjdHMsICZvYmotPm9pZCwgMSkpIHsKCQkJcHJpbnRmX2xuKF8oImJyb2tlbiBsaW5rIGZyb20gJTdzICVzXG4iCgkJCQkgICAgIiAgICAgICAgICAgICAgdG8gJTdzICVzIiksCgkJCQkgIHByaW50YWJsZV90eXBlKCZwYXJlbnQtPm9pZCwgcGFyZW50LT50eXBlKSwKCQkJCSAgZGVzY3JpYmVfb2JqZWN0KCZwYXJlbnQtPm9pZCksCgkJCQkgIHByaW50YWJsZV90eXBlKCZvYmotPm9pZCwgb2JqLT50eXBlKSwKCQkJCSAgZGVzY3JpYmVfb2JqZWN0KCZvYmotPm9pZCkpOwoJCQllcnJvcnNfZm91bmQgfD0gRVJST1JfUkVBQ0hBQkxFOwoJCX0KCQlyZXR1cm4gMTsKCX0KCglhZGRfb2JqZWN0X2FycmF5KG9iaiwgTlVMTCwgJnBlbmRpbmcpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyB2b2lkIG1hcmtfb2JqZWN0X3JlYWNoYWJsZShzdHJ1Y3Qgb2JqZWN0ICpvYmopCnsKCW1hcmtfb2JqZWN0KG9iaiwgT0JKX0FOWSwgTlVMTCwgTlVMTCk7Cn0KCnN0YXRpYyBpbnQgdHJhdmVyc2Vfb25lX29iamVjdChzdHJ1Y3Qgb2JqZWN0ICpvYmopCnsKCWludCByZXN1bHQgPSBmc2NrX3dhbGsob2JqLCBvYmosICZmc2NrX3dhbGtfb3B0aW9ucyk7CgoJaWYgKG9iai0+dHlwZSA9PSBPQkpfVFJFRSkgewoJCXN0cnVjdCB0cmVlICp0cmVlID0gKHN0cnVjdCB0cmVlICopb2JqOwoJCWZyZWVfdHJlZV9idWZmZXIodHJlZSk7Cgl9CglyZXR1cm4gcmVzdWx0Owp9CgpzdGF0aWMgaW50IHRyYXZlcnNlX3JlYWNoYWJsZSh2b2lkKQp7CglzdHJ1Y3QgcHJvZ3Jlc3MgKnByb2dyZXNzID0gTlVMTDsKCXVuc2lnbmVkIGludCBuciA9IDA7CglpbnQgcmVzdWx0ID0gMDsKCWlmIChzaG93X3Byb2dyZXNzKQoJCXByb2dyZXNzID0gc3RhcnRfZGVsYXllZF9wcm9ncmVzcyh0aGVfcmVwb3NpdG9yeSwKCQkJCQkJICBfKCJDaGVja2luZyBjb25uZWN0aXZpdHkiKSwgMCk7Cgl3aGlsZSAocGVuZGluZy5ucikgewoJCXJlc3VsdCB8PSB0cmF2ZXJzZV9vbmVfb2JqZWN0KG9iamVjdF9hcnJheV9wb3AoJnBlbmRpbmcpKTsKCQlkaXNwbGF5X3Byb2dyZXNzKHByb2dyZXNzLCArK25yKTsKCX0KCXN0b3BfcHJvZ3Jlc3MoJnByb2dyZXNzKTsKCXJldHVybiAhIXJlc3VsdDsKfQoKc3RhdGljIGludCBtYXJrX3VzZWQoc3RydWN0IG9iamVjdCAqb2JqLCBlbnVtIG9iamVjdF90eXBlIHR5cGUgVU5VU0VELAoJCSAgICAgdm9pZCAqZGF0YSBVTlVTRUQsIHN0cnVjdCBmc2NrX29wdGlvbnMgKm9wdGlvbnMgVU5VU0VEKQp7CglpZiAoIW9iaikKCQlyZXR1cm4gMTsKCW9iai0+ZmxhZ3MgfD0gVVNFRDsKCXJldHVybiAwOwp9CgpzdGF0aWMgdm9pZCBtYXJrX3VucmVhY2hhYmxlX3JlZmVyZW50cyhjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQpCnsKCXN0cnVjdCBmc2NrX29wdGlvbnMgb3B0aW9ucyA9IEZTQ0tfT1BUSU9OU19ERUZBVUxUOwoJc3RydWN0IG9iamVjdCAqb2JqID0gbG9va3VwX29iamVjdCh0aGVfcmVwb3NpdG9yeSwgb2lkKTsKCglpZiAoIW9iaiB8fCAhKG9iai0+ZmxhZ3MgJiBIQVNfT0JKKSkKCQlyZXR1cm47IC8qIG5vdCBwYXJ0IG9mIG91ciBvcmlnaW5hbCBzZXQgKi8KCWlmIChvYmotPmZsYWdzICYgUkVBQ0hBQkxFKQoJCXJldHVybjsgLyogcmVhY2hhYmxlIG9iamVjdHMgYWxyZWFkeSB0cmF2ZXJzZWQgKi8KCgkvKgoJICogQXZvaWQgcGFzc2luZyBPQkpfTk9ORSB0byBmc2NrX3dhbGssIHdoaWNoIHdpbGwgcGFyc2UgdGhlIG9iamVjdAoJICogKGFuZCB3ZSB3YW50IHRvIGF2b2lkIHBhcnNpbmcgYmxvYnMpLgoJICovCglpZiAob2JqLT50eXBlID09IE9CSl9OT05FKSB7CgkJZW51bSBvYmplY3RfdHlwZSB0eXBlID0gb2RiX3JlYWRfb2JqZWN0X2luZm8odGhlX3JlcG9zaXRvcnktPm9iamVjdHMsCgkJCQkJCQkgICAgICZvYmotPm9pZCwgTlVMTCk7CgkJaWYgKHR5cGUgPiAwKQoJCQlvYmplY3RfYXNfdHlwZShvYmosIHR5cGUsIDApOwoJfQoKCW9wdGlvbnMud2FsayA9IG1hcmtfdXNlZDsKCWZzY2tfd2FsayhvYmosIE5VTEwsICZvcHRpb25zKTsKCWlmIChvYmotPnR5cGUgPT0gT0JKX1RSRUUpCgkJZnJlZV90cmVlX2J1ZmZlcigoc3RydWN0IHRyZWUgKilvYmopOwp9CgpzdGF0aWMgaW50IG1hcmtfbG9vc2VfdW5yZWFjaGFibGVfcmVmZXJlbnRzKGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwKCQkJCQkgICAgY29uc3QgY2hhciAqcGF0aCBVTlVTRUQsCgkJCQkJICAgIHZvaWQgKmRhdGEgVU5VU0VEKQp7CgltYXJrX3VucmVhY2hhYmxlX3JlZmVyZW50cyhvaWQpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgbWFya19wYWNrZWRfdW5yZWFjaGFibGVfcmVmZXJlbnRzKGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwKCQkJCQkgICAgIHN0cnVjdCBwYWNrZWRfZ2l0ICpwYWNrIFVOVVNFRCwKCQkJCQkgICAgIHVpbnQzMl90IHBvcyBVTlVTRUQsCgkJCQkJICAgICB2b2lkICpkYXRhIFVOVVNFRCkKewoJbWFya191bnJlYWNoYWJsZV9yZWZlcmVudHMob2lkKTsKCXJldHVybiAwOwp9CgovKgogKiBDaGVjayBhIHNpbmdsZSByZWFjaGFibGUgb2JqZWN0CiAqLwpzdGF0aWMgdm9pZCBjaGVja19yZWFjaGFibGVfb2JqZWN0KHN0cnVjdCBvYmplY3QgKm9iaikKewoJLyoKCSAqIFdlIG9idmlvdXNseSB3YW50IHRoZSBvYmplY3QgdG8gYmUgcGFyc2VkLAoJICogZXhjZXB0IGlmIGl0IHdhcyBpbiBhIHBhY2stZmlsZSBhbmQgd2UgZGlkbid0CgkgKiBkbyBhIGZ1bGwgZnNjawoJICovCglpZiAoIShvYmotPmZsYWdzICYgSEFTX09CSikpIHsKCQlpZiAoaXNfcHJvbWlzb3Jfb2JqZWN0KHRoZV9yZXBvc2l0b3J5LCAmb2JqLT5vaWQpKQoJCQlyZXR1cm47CgkJaWYgKGhhc19vYmplY3RfcGFjayh0aGVfcmVwb3NpdG9yeSwgJm9iai0+b2lkKSkKCQkJcmV0dXJuOyAvKiBpdCBpcyBpbiBwYWNrIC0gZm9yZ2V0IGFib3V0IGl0ICovCgkJcHJpbnRmX2xuKF8oIm1pc3NpbmcgJXMgJXMiKSwKCQkJICBwcmludGFibGVfdHlwZSgmb2JqLT5vaWQsIG9iai0+dHlwZSksCgkJCSAgZGVzY3JpYmVfb2JqZWN0KCZvYmotPm9pZCkpOwoJCWVycm9yc19mb3VuZCB8PSBFUlJPUl9SRUFDSEFCTEU7CgkJcmV0dXJuOwoJfQp9CgovKgogKiBDaGVjayBhIHNpbmdsZSB1bnJlYWNoYWJsZSBvYmplY3QKICovCnN0YXRpYyB2b2lkIGNoZWNrX3VucmVhY2hhYmxlX29iamVjdChzdHJ1Y3Qgb2JqZWN0ICpvYmopCnsKCS8qCgkgKiBNaXNzaW5nIHVucmVhY2hhYmxlIG9iamVjdD8gSWdub3JlIGl0LiBJdCdzIG5vdCBsaWtlCgkgKiB3ZSBtaXNzIGl0IChzaW5jZSBpdCBjYW4ndCBiZSByZWFjaGVkKSwgbm9yIGRvIHdlIHdhbnQKCSAqIHRvIGNvbXBsYWluIGFib3V0IGl0IGJlaW5nIHVucmVhY2hhYmxlIChzaW5jZSBpdCBkb2VzCgkgKiBub3QgZXhpc3QpLgoJICovCglpZiAoIShvYmotPmZsYWdzICYgSEFTX09CSikpCgkJcmV0dXJuOwoKCS8qCgkgKiBVbnJlYWNoYWJsZSBvYmplY3QgdGhhdCBleGlzdHM/IFNob3cgaXQgaWYgYXNrZWQgdG8sCgkgKiBzaW5jZSB0aGlzIGlzIHNvbWV0aGluZyB0aGF0IGlzIHBydW5hYmxlLgoJICovCglpZiAoc2hvd191bnJlYWNoYWJsZSkgewoJCXByaW50Zl9sbihfKCJ1bnJlYWNoYWJsZSAlcyAlcyIpLAoJCQkgIHByaW50YWJsZV90eXBlKCZvYmotPm9pZCwgb2JqLT50eXBlKSwKCQkJICBkZXNjcmliZV9vYmplY3QoJm9iai0+b2lkKSk7CgkJcmV0dXJuOwoJfQoKCS8qCgkgKiAiIVVTRUQiIG1lYW5zIHRoYXQgbm90aGluZyBhdCBhbGwgcG9pbnRzIHRvIGl0LCBpbmNsdWRpbmcKCSAqIG90aGVyIHVucmVhY2hhYmxlIG9iamVjdHMuIEluIG90aGVyIHdvcmRzLCBpdCdzIHRoZSAidGlwIgoJICogb2Ygc29tZSBzZXQgb2YgdW5yZWFjaGFibGUgb2JqZWN0cywgdXN1YWxseSBhIGNvbW1pdCB0aGF0CgkgKiBnb3QgZHJvcHBlZC4KCSAqCgkgKiBTdWNoIHN0YXJ0aW5nIHBvaW50cyBhcmUgbW9yZSBpbnRlcmVzdGluZyB0aGFuIHNvbWUgcmFuZG9tCgkgKiBzZXQgb2YgdW5yZWFjaGFibGUgb2JqZWN0cywgc28gd2Ugc2hvdyB0aGVtIGV2ZW4gaWYgdGhlIHVzZXIKCSAqIGhhc24ndCBhc2tlZCBmb3IgX2FsbF8gdW5yZWFjaGFibGUgb2JqZWN0cy4gSWYgeW91IGhhdmUKCSAqIGRlbGV0ZWQgYSBicmFuY2ggYnkgbWlzdGFrZSwgdGhpcyBpcyBhIHByaW1lIGNhbmRpZGF0ZSB0bwoJICogc3RhcnQgbG9va2luZyBhdCwgZm9yIGV4YW1wbGUuCgkgKi8KCWlmICghKG9iai0+ZmxhZ3MgJiBVU0VEKSkgewoJCWlmIChzaG93X2RhbmdsaW5nKQoJCQlwcmludGZfbG4oXygiZGFuZ2xpbmcgJXMgJXMiKSwKCQkJCSAgcHJpbnRhYmxlX3R5cGUoJm9iai0+b2lkLCBvYmotPnR5cGUpLAoJCQkJICBkZXNjcmliZV9vYmplY3QoJm9iai0+b2lkKSk7CgkJaWYgKHdyaXRlX2xvc3RfYW5kX2ZvdW5kKSB7CgkJCWNoYXIgKmZpbGVuYW1lID0gcmVwb19naXRfcGF0aCh0aGVfcmVwb3NpdG9yeSwgImxvc3QtZm91bmQvJXMvJXMiLAoJCQkJb2JqLT50eXBlID09IE9CSl9DT01NSVQgPyAiY29tbWl0IiA6ICJvdGhlciIsCgkJCQlkZXNjcmliZV9vYmplY3QoJm9iai0+b2lkKSk7CgkJCUZJTEUgKmY7CgoJCQlpZiAoc2FmZV9jcmVhdGVfbGVhZGluZ19kaXJlY3Rvcmllc19jb25zdCh0aGVfcmVwb3NpdG9yeSwgZmlsZW5hbWUpKSB7CgkJCQllcnJvcihfKCJjb3VsZCBub3QgY3JlYXRlIGxvc3QtZm91bmQiKSk7CgkJCQlmcmVlKGZpbGVuYW1lKTsKCQkJCXJldHVybjsKCQkJfQoJCQlmID0geGZvcGVuKGZpbGVuYW1lLCAidyIpOwoJCQlpZiAob2JqLT50eXBlID09IE9CSl9CTE9CKSB7CgkJCQlpZiAoc3RyZWFtX2Jsb2JfdG9fZmQoZmlsZW5vKGYpLCAmb2JqLT5vaWQsIE5VTEwsIDEpKQoJCQkJCWRpZV9lcnJubyhfKCJjb3VsZCBub3Qgd3JpdGUgJyVzJyIpLCBmaWxlbmFtZSk7CgkJCX0gZWxzZQoJCQkJZnByaW50ZihmLCAiJXNcbiIsIGRlc2NyaWJlX29iamVjdCgmb2JqLT5vaWQpKTsKCQkJaWYgKGZjbG9zZShmKSkKCQkJCWRpZV9lcnJubyhfKCJjb3VsZCBub3QgZmluaXNoICclcyciKSwKCQkJCQkgIGZpbGVuYW1lKTsKCQkJZnJlZShmaWxlbmFtZSk7CgkJfQoJCXJldHVybjsKCX0KCgkvKgoJICogT3RoZXJ3aXNlPyBJdCdzIHRoZXJlLCBpdCdzIHVucmVhY2hhYmxlLCBhbmQgc29tZSBvdGhlciB1bnJlYWNoYWJsZQoJICogb2JqZWN0IHBvaW50cyB0byBpdC4gSWdub3JlIGl0IC0gaXQncyBub3QgaW50ZXJlc3RpbmcsIGFuZCB3ZSBzaG93ZWQKCSAqIGFsbCB0aGUgaW50ZXJlc3RpbmcgY2FzZXMgYWJvdmUuCgkgKi8KfQoKc3RhdGljIHZvaWQgY2hlY2tfb2JqZWN0KHN0cnVjdCBvYmplY3QgKm9iaikKewoJaWYgKHZlcmJvc2UpCgkJZnByaW50Zl9sbihzdGRlcnIsIF8oIkNoZWNraW5nICVzIiksIGRlc2NyaWJlX29iamVjdCgmb2JqLT5vaWQpKTsKCglpZiAob2JqLT5mbGFncyAmIFJFQUNIQUJMRSkKCQljaGVja19yZWFjaGFibGVfb2JqZWN0KG9iaik7CgllbHNlCgkJY2hlY2tfdW5yZWFjaGFibGVfb2JqZWN0KG9iaik7Cn0KCnN0YXRpYyB2b2lkIGNoZWNrX2Nvbm5lY3Rpdml0eSh2b2lkKQp7CglpbnQgaSwgbWF4OwoKCS8qIFRyYXZlcnNlIHRoZSBwZW5kaW5nIHJlYWNoYWJsZSBvYmplY3RzICovCgl0cmF2ZXJzZV9yZWFjaGFibGUoKTsKCgkvKgoJICogV2l0aCAtLWNvbm5lY3Rpdml0eS1vbmx5LCB3ZSB3b24ndCBoYXZlIGFjdHVhbGx5IG9wZW5lZCBhbmQgbWFya2VkCgkgKiB1bnJlYWNoYWJsZSBvYmplY3RzIHdpdGggVVNFRC4gRG8gdGhhdCBub3cgdG8gbWFrZSAtLWRhbmdsaW5nLCBldGMKCSAqIGFjY3VyYXRlLgoJICovCglpZiAoY29ubmVjdGl2aXR5X29ubHkgJiYgKHNob3dfZGFuZ2xpbmcgfHwgd3JpdGVfbG9zdF9hbmRfZm91bmQpKSB7CgkJLyoKCQkgKiBFdmVuIHRob3VnaCB3ZSBhbHJlYWR5IGhhdmUgYSAic3RydWN0IG9iamVjdCIgZm9yIGVhY2ggb2YKCQkgKiB0aGVzZSBpbiBtZW1vcnksIHdlIG11c3Qgbm90IGl0ZXJhdGUgb3ZlciB0aGUgaW50ZXJuYWwKCQkgKiBvYmplY3QgaGFzaCBhcyB3ZSBkbyBiZWxvdy4gT3VyIGxvb3Agd291bGQgcG90ZW50aWFsbHkKCQkgKiByZXNpemUgdGhlIGhhc2gsIG1ha2luZyBvdXIgaXRlcmF0aW9uIGludmFsaWQuCgkJICoKCQkgKiBJbnN0ZWFkLCB3ZSdsbCBqdXN0IGdvIGJhY2sgdG8gdGhlIHNvdXJjZSBsaXN0IG9mIG9iamVjdHMsCgkJICogYW5kIGlnbm9yZSBhbnkgdGhhdCB3ZXJlbid0IHByZXNlbnQgaW4gb3VyIGVhcmxpZXIKCQkgKiB0cmF2ZXJzYWwuCgkJICovCgkJZm9yX2VhY2hfbG9vc2Vfb2JqZWN0KG1hcmtfbG9vc2VfdW5yZWFjaGFibGVfcmVmZXJlbnRzLCBOVUxMLCAwKTsKCQlmb3JfZWFjaF9wYWNrZWRfb2JqZWN0KHRoZV9yZXBvc2l0b3J5LAoJCQkJICAgICAgIG1hcmtfcGFja2VkX3VucmVhY2hhYmxlX3JlZmVyZW50cywKCQkJCSAgICAgICBOVUxMLAoJCQkJICAgICAgIDApOwoJfQoKCS8qIExvb2sgdXAgYWxsIHRoZSByZXF1aXJlbWVudHMsIHdhcm4gYWJvdXQgbWlzc2luZyBvYmplY3RzLi4gKi8KCW1heCA9IGdldF9tYXhfb2JqZWN0X2luZGV4KHRoZV9yZXBvc2l0b3J5KTsKCWlmICh2ZXJib3NlKQoJCWZwcmludGZfbG4oc3RkZXJyLCBfKCJDaGVja2luZyBjb25uZWN0aXZpdHkgKCVkIG9iamVjdHMpIiksIG1heCk7CgoJZm9yIChpID0gMDsgaSA8IG1heDsgaSsrKSB7CgkJc3RydWN0IG9iamVjdCAqb2JqID0gZ2V0X2luZGV4ZWRfb2JqZWN0KHRoZV9yZXBvc2l0b3J5LCBpKTsKCgkJaWYgKG9iaikKCQkJY2hlY2tfb2JqZWN0KG9iaik7Cgl9Cn0KCnN0YXRpYyBpbnQgZnNja19vYmooc3RydWN0IG9iamVjdCAqb2JqLCB2b2lkICpidWZmZXIsIHVuc2lnbmVkIGxvbmcgc2l6ZSkKewoJaW50IGVycjsKCglpZiAob2JqLT5mbGFncyAmIFNFRU4pCgkJcmV0dXJuIDA7CglvYmotPmZsYWdzIHw9IFNFRU47CgoJaWYgKHZlcmJvc2UpCgkJZnByaW50Zl9sbihzdGRlcnIsIF8oIkNoZWNraW5nICVzICVzIiksCgkJCSAgIHByaW50YWJsZV90eXBlKCZvYmotPm9pZCwgb2JqLT50eXBlKSwKCQkJICAgZGVzY3JpYmVfb2JqZWN0KCZvYmotPm9pZCkpOwoKCWlmIChmc2NrX3dhbGsob2JqLCBOVUxMLCAmZnNja19vYmpfb3B0aW9ucykpCgkJb2JqZXJyb3Iob2JqLCBfKCJicm9rZW4gbGlua3MiKSk7CgllcnIgPSBmc2NrX29iamVjdChvYmosIGJ1ZmZlciwgc2l6ZSwgJmZzY2tfb2JqX29wdGlvbnMpOwoJaWYgKGVycikKCQlnb3RvIG91dDsKCglpZiAob2JqLT50eXBlID09IE9CSl9DT01NSVQpIHsKCQlzdHJ1Y3QgY29tbWl0ICpjb21taXQgPSAoc3RydWN0IGNvbW1pdCAqKSBvYmo7CgoJCWlmICghY29tbWl0LT5wYXJlbnRzICYmIHNob3dfcm9vdCkKCQkJcHJpbnRmX2xuKF8oInJvb3QgJXMiKSwKCQkJCSAgZGVzY3JpYmVfb2JqZWN0KCZjb21taXQtPm9iamVjdC5vaWQpKTsKCX0KCglpZiAob2JqLT50eXBlID09IE9CSl9UQUcpIHsKCQlzdHJ1Y3QgdGFnICp0YWcgPSAoc3RydWN0IHRhZyAqKSBvYmo7CgoJCWlmIChzaG93X3RhZ3MgJiYgdGFnLT50YWdnZWQpIHsKCQkJcHJpbnRmX2xuKF8oInRhZ2dlZCAlcyAlcyAoJXMpIGluICVzIiksCgkJCQkgIHByaW50YWJsZV90eXBlKCZ0YWctPnRhZ2dlZC0+b2lkLCB0YWctPnRhZ2dlZC0+dHlwZSksCgkJCQkgIGRlc2NyaWJlX29iamVjdCgmdGFnLT50YWdnZWQtPm9pZCksCgkJCQkgIHRhZy0+dGFnLAoJCQkJICBkZXNjcmliZV9vYmplY3QoJnRhZy0+b2JqZWN0Lm9pZCkpOwoJCX0KCX0KCm91dDoKCWlmIChvYmotPnR5cGUgPT0gT0JKX1RSRUUpCgkJZnJlZV90cmVlX2J1ZmZlcigoc3RydWN0IHRyZWUgKilvYmopOwoJcmV0dXJuIGVycjsKfQoKc3RhdGljIGludCBmc2NrX29ial9idWZmZXIoY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLCBlbnVtIG9iamVjdF90eXBlIHR5cGUsCgkJCSAgIHVuc2lnbmVkIGxvbmcgc2l6ZSwgdm9pZCAqYnVmZmVyLCBpbnQgKmVhdGVuKQp7CgkvKgoJICogTm90ZSwgYnVmZmVyIG1heSBiZSBOVUxMIGlmIHR5cGUgaXMgT0JKX0JMT0IuIFNlZQoJICogdmVyaWZ5X3BhY2tmaWxlKCksIGRhdGFfdmFsaWQgdmFyaWFibGUgZm9yIGRldGFpbHMuCgkgKi8KCXN0cnVjdCBvYmplY3QgKm9iajsKCW9iaiA9IHBhcnNlX29iamVjdF9idWZmZXIodGhlX3JlcG9zaXRvcnksIG9pZCwgdHlwZSwgc2l6ZSwgYnVmZmVyLAoJCQkJICBlYXRlbik7CglpZiAoIW9iaikgewoJCWVycm9yc19mb3VuZCB8PSBFUlJPUl9PQkpFQ1Q7CgkJcmV0dXJuIGVycm9yKF8oIiVzOiBvYmplY3QgY29ycnVwdCBvciBtaXNzaW5nIiksCgkJCSAgICAgb2lkX3RvX2hleChvaWQpKTsKCX0KCW9iai0+ZmxhZ3MgJj0gfihSRUFDSEFCTEUgfCBTRUVOKTsKCW9iai0+ZmxhZ3MgfD0gSEFTX09CSjsKCXJldHVybiBmc2NrX29iaihvYmosIGJ1ZmZlciwgc2l6ZSk7Cn0KCnN0YXRpYyBpbnQgZGVmYXVsdF9yZWZzOwoKc3RhdGljIHZvaWQgZnNja19oYW5kbGVfcmVmbG9nX29pZChjb25zdCBjaGFyICpyZWZuYW1lLCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsCgl0aW1lc3RhbXBfdCB0aW1lc3RhbXApCnsKCXN0cnVjdCBvYmplY3QgKm9iajsKCglpZiAoIWlzX251bGxfb2lkKG9pZCkpIHsKCQlvYmogPSBsb29rdXBfb2JqZWN0KHRoZV9yZXBvc2l0b3J5LCBvaWQpOwoJCWlmIChvYmogJiYgKG9iai0+ZmxhZ3MgJiBIQVNfT0JKKSkgewoJCQlpZiAodGltZXN0YW1wKQoJCQkJZnNja19wdXRfb2JqZWN0X25hbWUoJmZzY2tfd2Fsa19vcHRpb25zLCBvaWQsCgkJCQkJCSAgICAgIiVzQHslIlBSSXRpbWUifSIsCgkJCQkJCSAgICAgcmVmbmFtZSwgdGltZXN0YW1wKTsKCQkJb2JqLT5mbGFncyB8PSBVU0VEOwoJCQltYXJrX29iamVjdF9yZWFjaGFibGUob2JqKTsKCQl9IGVsc2UgaWYgKCFpc19wcm9taXNvcl9vYmplY3QodGhlX3JlcG9zaXRvcnksIG9pZCkpIHsKCQkJZXJyb3IoXygiJXM6IGludmFsaWQgcmVmbG9nIGVudHJ5ICVzIiksCgkJCSAgICAgIHJlZm5hbWUsIG9pZF90b19oZXgob2lkKSk7CgkJCWVycm9yc19mb3VuZCB8PSBFUlJPUl9SRUFDSEFCTEU7CgkJfQoJfQp9CgpzdGF0aWMgaW50IGZzY2tfaGFuZGxlX3JlZmxvZ19lbnQoc3RydWN0IG9iamVjdF9pZCAqb29pZCwgc3RydWN0IG9iamVjdF9pZCAqbm9pZCwKCQkJCSAgY29uc3QgY2hhciAqZW1haWwgVU5VU0VELAoJCQkJICB0aW1lc3RhbXBfdCB0aW1lc3RhbXAsIGludCB0eiBVTlVTRUQsCgkJCQkgIGNvbnN0IGNoYXIgKm1lc3NhZ2UgVU5VU0VELCB2b2lkICpjYl9kYXRhKQp7Cgljb25zdCBjaGFyICpyZWZuYW1lID0gY2JfZGF0YTsKCglpZiAodmVyYm9zZSkKCQlmcHJpbnRmX2xuKHN0ZGVyciwgXygiQ2hlY2tpbmcgcmVmbG9nICVzLT4lcyIpLAoJCQkgICBvaWRfdG9faGV4KG9vaWQpLCBvaWRfdG9faGV4KG5vaWQpKTsKCglmc2NrX2hhbmRsZV9yZWZsb2dfb2lkKHJlZm5hbWUsIG9vaWQsIDApOwoJZnNja19oYW5kbGVfcmVmbG9nX29pZChyZWZuYW1lLCBub2lkLCB0aW1lc3RhbXApOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgZnNja19oYW5kbGVfcmVmbG9nKGNvbnN0IGNoYXIgKmxvZ25hbWUsIHZvaWQgKmNiX2RhdGEpCnsKCXN0cnVjdCBzdHJidWYgcmVmbmFtZSA9IFNUUkJVRl9JTklUOwoKCXN0cmJ1Zl93b3JrdHJlZV9yZWYoY2JfZGF0YSwgJnJlZm5hbWUsIGxvZ25hbWUpOwoJcmVmc19mb3JfZWFjaF9yZWZsb2dfZW50KGdldF9tYWluX3JlZl9zdG9yZSh0aGVfcmVwb3NpdG9yeSksCgkJCQkgcmVmbmFtZS5idWYsIGZzY2tfaGFuZGxlX3JlZmxvZ19lbnQsCgkJCQkgcmVmbmFtZS5idWYpOwoJc3RyYnVmX3JlbGVhc2UoJnJlZm5hbWUpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgZnNja19oYW5kbGVfcmVmKGNvbnN0IGNoYXIgKnJlZm5hbWUsIGNvbnN0IGNoYXIgKnJlZmVyZW50IFVOVVNFRCwgY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkLAoJCQkgICBpbnQgZmxhZyBVTlVTRUQsIHZvaWQgKmNiX2RhdGEgVU5VU0VEKQp7CglzdHJ1Y3Qgb2JqZWN0ICpvYmo7CgoJb2JqID0gcGFyc2Vfb2JqZWN0KHRoZV9yZXBvc2l0b3J5LCBvaWQpOwoJaWYgKCFvYmopIHsKCQlpZiAoaXNfcHJvbWlzb3Jfb2JqZWN0KHRoZV9yZXBvc2l0b3J5LCBvaWQpKSB7CgkJCS8qCgkJCSAqIEluY3JlbWVudCBkZWZhdWx0X3JlZnMgYW55d2F5LCBiZWNhdXNlIHRoaXMgaXMgYQoJCQkgKiB2YWxpZCByZWYuCgkJCSAqLwoJCQkgZGVmYXVsdF9yZWZzKys7CgkJCSByZXR1cm4gMDsKCQl9CgkJZXJyb3IoXygiJXM6IGludmFsaWQgc2hhMSBwb2ludGVyICVzIiksCgkJICAgICAgcmVmbmFtZSwgb2lkX3RvX2hleChvaWQpKTsKCQllcnJvcnNfZm91bmQgfD0gRVJST1JfUkVBQ0hBQkxFOwoJCS8qIFdlJ2xsIGNvbnRpbnVlIHdpdGggdGhlIHJlc3QgZGVzcGl0ZSB0aGUgZXJyb3IuLiAqLwoJCXJldHVybiAwOwoJfQoJaWYgKG9iai0+dHlwZSAhPSBPQkpfQ09NTUlUICYmIGlzX2JyYW5jaChyZWZuYW1lKSkgewoJCWVycm9yKF8oIiVzOiBub3QgYSBjb21taXQiKSwgcmVmbmFtZSk7CgkJZXJyb3JzX2ZvdW5kIHw9IEVSUk9SX1JFRlM7Cgl9CglkZWZhdWx0X3JlZnMrKzsKCW9iai0+ZmxhZ3MgfD0gVVNFRDsKCWZzY2tfcHV0X29iamVjdF9uYW1lKCZmc2NrX3dhbGtfb3B0aW9ucywKCQkJICAgICBvaWQsICIlcyIsIHJlZm5hbWUpOwoJbWFya19vYmplY3RfcmVhY2hhYmxlKG9iaik7CgoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgZnNja19oZWFkX2xpbmsoY29uc3QgY2hhciAqaGVhZF9yZWZfbmFtZSwKCQkJICBjb25zdCBjaGFyICoqaGVhZF9wb2ludHNfYXQsCgkJCSAgc3RydWN0IG9iamVjdF9pZCAqaGVhZF9vaWQpOwoKc3RhdGljIHZvaWQgZ2V0X2RlZmF1bHRfaGVhZHModm9pZCkKewoJc3RydWN0IHdvcmt0cmVlICoqd29ya3RyZWVzLCAqKnA7Cgljb25zdCBjaGFyICpoZWFkX3BvaW50c19hdDsKCXN0cnVjdCBvYmplY3RfaWQgaGVhZF9vaWQ7CgoJcmVmc19mb3JfZWFjaF9yYXdyZWYoZ2V0X21haW5fcmVmX3N0b3JlKHRoZV9yZXBvc2l0b3J5KSwKCQkJICAgICBmc2NrX2hhbmRsZV9yZWYsIE5VTEwpOwoKCXdvcmt0cmVlcyA9IGdldF93b3JrdHJlZXMoKTsKCWZvciAocCA9IHdvcmt0cmVlczsgKnA7IHArKykgewoJCXN0cnVjdCB3b3JrdHJlZSAqd3QgPSAqcDsKCQlzdHJ1Y3Qgc3RyYnVmIHJlZiA9IFNUUkJVRl9JTklUOwoKCQlzdHJidWZfd29ya3RyZWVfcmVmKHd0LCAmcmVmLCAiSEVBRCIpOwoJCWZzY2tfaGVhZF9saW5rKHJlZi5idWYsICZoZWFkX3BvaW50c19hdCwgJmhlYWRfb2lkKTsKCQlpZiAoaGVhZF9wb2ludHNfYXQgJiYgIWlzX251bGxfb2lkKCZoZWFkX29pZCkpCgkJCWZzY2tfaGFuZGxlX3JlZihyZWYuYnVmLCBOVUxMLCAmaGVhZF9vaWQsIDAsIE5VTEwpOwoJCXN0cmJ1Zl9yZWxlYXNlKCZyZWYpOwoKCQlpZiAoaW5jbHVkZV9yZWZsb2dzKQoJCQlyZWZzX2Zvcl9lYWNoX3JlZmxvZyhnZXRfd29ya3RyZWVfcmVmX3N0b3JlKHd0KSwKCQkJCQkgICAgIGZzY2tfaGFuZGxlX3JlZmxvZywgd3QpOwoJfQoJZnJlZV93b3JrdHJlZXMod29ya3RyZWVzKTsKCgkvKgoJICogTm90IGhhdmluZyBhbnkgZGVmYXVsdCBoZWFkcyBpc24ndCByZWFsbHkgZmF0YWwsIGJ1dAoJICogaXQgZG9lcyBtZWFuIHRoYXQgIi0tdW5yZWFjaGFibGUiIG5vIGxvbmdlciBtYWtlcyBhbnkKCSAqIHNlbnNlIChzaW5jZSBpbiB0aGlzIGNhc2UgZXZlcnl0aGluZyB3aWxsIG9idmlvdXNseQoJICogYmUgdW5yZWFjaGFibGUgYnkgZGVmaW5pdGlvbi4KCSAqCgkgKiBTaG93aW5nIGRhbmdsaW5nIG9iamVjdHMgaXMgdmFsaWQsIHRob3VnaCAoYXMgdGhvc2UKCSAqIGRhbmdsaW5nIG9iamVjdHMgYXJlIGxpa2VseSBsb3N0IGhlYWRzKS4KCSAqCgkgKiBTbyB3ZSBqdXN0IHByaW50IGEgd2FybmluZyBhYm91dCBpdCwgYW5kIGNsZWFyIHRoZQoJICogInNob3dfdW5yZWFjaGFibGUiIGZsYWcuCgkgKi8KCWlmICghZGVmYXVsdF9yZWZzKSB7CgkJZnByaW50Zl9sbihzdGRlcnIsIF8oIm5vdGljZTogTm8gZGVmYXVsdCByZWZlcmVuY2VzIikpOwoJCXNob3dfdW5yZWFjaGFibGUgPSAwOwoJfQp9CgpzdHJ1Y3QgZm9yX2VhY2hfbG9vc2VfY2IKewoJc3RydWN0IHByb2dyZXNzICpwcm9ncmVzczsKfTsKCnN0YXRpYyBpbnQgZnNja19sb29zZShjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsIGNvbnN0IGNoYXIgKnBhdGgsCgkJICAgICAgdm9pZCAqZGF0YSBVTlVTRUQpCnsKCXN0cnVjdCBvYmplY3QgKm9iajsKCWVudW0gb2JqZWN0X3R5cGUgdHlwZSA9IE9CSl9OT05FOwoJdW5zaWduZWQgbG9uZyBzaXplOwoJdm9pZCAqY29udGVudHMgPSBOVUxMOwoJaW50IGVhdGVuOwoJc3RydWN0IG9iamVjdF9pbmZvIG9pID0gT0JKRUNUX0lORk9fSU5JVDsKCXN0cnVjdCBvYmplY3RfaWQgcmVhbF9vaWQgPSAqbnVsbF9vaWQodGhlX2hhc2hfYWxnbyk7CglpbnQgZXJyID0gMDsKCglvaS5zaXplcCA9ICZzaXplOwoJb2kudHlwZXAgPSAmdHlwZTsKCglpZiAocmVhZF9sb29zZV9vYmplY3QocGF0aCwgb2lkLCAmcmVhbF9vaWQsICZjb250ZW50cywgJm9pKSA8IDApIHsKCQlpZiAoY29udGVudHMgJiYgIW9pZGVxKCZyZWFsX29pZCwgb2lkKSkKCQkJZXJyID0gZXJyb3IoXygiJXM6IGhhc2gtcGF0aCBtaXNtYXRjaCwgZm91bmQgYXQ6ICVzIiksCgkJCQkgICAgb2lkX3RvX2hleCgmcmVhbF9vaWQpLCBwYXRoKTsKCQllbHNlCgkJCWVyciA9IGVycm9yKF8oIiVzOiBvYmplY3QgY29ycnVwdCBvciBtaXNzaW5nOiAlcyIpLAoJCQkJICAgIG9pZF90b19oZXgob2lkKSwgcGF0aCk7Cgl9CglpZiAoZXJyIDwgMCkgewoJCWVycm9yc19mb3VuZCB8PSBFUlJPUl9PQkpFQ1Q7CgkJZnJlZShjb250ZW50cyk7CgkJcmV0dXJuIDA7IC8qIGtlZXAgY2hlY2tpbmcgb3RoZXIgb2JqZWN0cyAqLwoJfQoKCWlmICghY29udGVudHMgJiYgdHlwZSAhPSBPQkpfQkxPQikKCQlCVUcoInJlYWRfbG9vc2Vfb2JqZWN0IHN0cmVhbWVkIGEgbm9uLWJsb2IiKTsKCglvYmogPSBwYXJzZV9vYmplY3RfYnVmZmVyKHRoZV9yZXBvc2l0b3J5LCBvaWQsIHR5cGUsIHNpemUsCgkJCQkgIGNvbnRlbnRzLCAmZWF0ZW4pOwoKCWlmICghb2JqKSB7CgkJZXJyb3JzX2ZvdW5kIHw9IEVSUk9SX09CSkVDVDsKCQllcnJvcihfKCIlczogb2JqZWN0IGNvdWxkIG5vdCBiZSBwYXJzZWQ6ICVzIiksCgkJICAgICAgb2lkX3RvX2hleChvaWQpLCBwYXRoKTsKCQlpZiAoIWVhdGVuKQoJCQlmcmVlKGNvbnRlbnRzKTsKCQlyZXR1cm4gMDsgLyoga2VlcCBjaGVja2luZyBvdGhlciBvYmplY3RzICovCgl9CgoJb2JqLT5mbGFncyAmPSB+KFJFQUNIQUJMRSB8IFNFRU4pOwoJb2JqLT5mbGFncyB8PSBIQVNfT0JKOwoJaWYgKGZzY2tfb2JqKG9iaiwgY29udGVudHMsIHNpemUpKQoJCWVycm9yc19mb3VuZCB8PSBFUlJPUl9PQkpFQ1Q7CgoJaWYgKCFlYXRlbikKCQlmcmVlKGNvbnRlbnRzKTsKCXJldHVybiAwOyAvKiBrZWVwIGNoZWNraW5nIG90aGVyIG9iamVjdHMsIGV2ZW4gaWYgd2Ugc2F3IGFuIGVycm9yICovCn0KCnN0YXRpYyBpbnQgZnNja19jcnVmdChjb25zdCBjaGFyICpiYXNlbmFtZSwgY29uc3QgY2hhciAqcGF0aCwKCQkgICAgICB2b2lkICpkYXRhIFVOVVNFRCkKewoJaWYgKCFzdGFydHNfd2l0aChiYXNlbmFtZSwgInRtcF9vYmpfIikpCgkJZnByaW50Zl9sbihzdGRlcnIsIF8oImJhZCBzaGExIGZpbGU6ICVzIiksIHBhdGgpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgZnNja19zdWJkaXIodW5zaWduZWQgaW50IG5yLCBjb25zdCBjaGFyICpwYXRoIFVOVVNFRCwgdm9pZCAqZGF0YSkKewoJc3RydWN0IGZvcl9lYWNoX2xvb3NlX2NiICpjYl9kYXRhID0gZGF0YTsKCXN0cnVjdCBwcm9ncmVzcyAqcHJvZ3Jlc3MgPSBjYl9kYXRhLT5wcm9ncmVzczsKCWRpc3BsYXlfcHJvZ3Jlc3MocHJvZ3Jlc3MsIG5yICsgMSk7CglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgZnNja19vYmplY3RfZGlyKGNvbnN0IGNoYXIgKnBhdGgpCnsKCXN0cnVjdCBwcm9ncmVzcyAqcHJvZ3Jlc3MgPSBOVUxMOwoJc3RydWN0IGZvcl9lYWNoX2xvb3NlX2NiIGNiX2RhdGEgPSB7CgkJLnByb2dyZXNzID0gcHJvZ3Jlc3MsCgl9OwoKCWlmICh2ZXJib3NlKQoJCWZwcmludGZfbG4oc3RkZXJyLCBfKCJDaGVja2luZyBvYmplY3QgZGlyZWN0b3J5IikpOwoKCWlmIChzaG93X3Byb2dyZXNzKQoJCXByb2dyZXNzID0gc3RhcnRfcHJvZ3Jlc3ModGhlX3JlcG9zaXRvcnksCgkJCQkJICBfKCJDaGVja2luZyBvYmplY3QgZGlyZWN0b3JpZXMiKSwgMjU2KTsKCglmb3JfZWFjaF9sb29zZV9maWxlX2luX29iamRpcihwYXRoLCBmc2NrX2xvb3NlLCBmc2NrX2NydWZ0LCBmc2NrX3N1YmRpciwKCQkJCSAgICAgICZjYl9kYXRhKTsKCWRpc3BsYXlfcHJvZ3Jlc3MocHJvZ3Jlc3MsIDI1Nik7CglzdG9wX3Byb2dyZXNzKCZwcm9ncmVzcyk7Cn0KCnN0YXRpYyBpbnQgZnNja19oZWFkX2xpbmsoY29uc3QgY2hhciAqaGVhZF9yZWZfbmFtZSwKCQkJICBjb25zdCBjaGFyICoqaGVhZF9wb2ludHNfYXQsCgkJCSAgc3RydWN0IG9iamVjdF9pZCAqaGVhZF9vaWQpCnsKCWludCBudWxsX2lzX2Vycm9yID0gMDsKCglpZiAodmVyYm9zZSkKCQlmcHJpbnRmX2xuKHN0ZGVyciwgXygiQ2hlY2tpbmcgJXMgbGluayIpLCBoZWFkX3JlZl9uYW1lKTsKCgkqaGVhZF9wb2ludHNfYXQgPSByZWZzX3Jlc29sdmVfcmVmX3Vuc2FmZShnZXRfbWFpbl9yZWZfc3RvcmUodGhlX3JlcG9zaXRvcnkpLAoJCQkJCQkgIGhlYWRfcmVmX25hbWUsIDAsIGhlYWRfb2lkLAoJCQkJCQkgIE5VTEwpOwoJaWYgKCEqaGVhZF9wb2ludHNfYXQpIHsKCQllcnJvcnNfZm91bmQgfD0gRVJST1JfUkVGUzsKCQlyZXR1cm4gZXJyb3IoXygiaW52YWxpZCAlcyIpLCBoZWFkX3JlZl9uYW1lKTsKCX0KCWlmICghc3RyY21wKCpoZWFkX3BvaW50c19hdCwgaGVhZF9yZWZfbmFtZSkpCgkJLyogZGV0YWNoZWQgSEVBRCAqLwoJCW51bGxfaXNfZXJyb3IgPSAxOwoJZWxzZSBpZiAoIXN0YXJ0c193aXRoKCpoZWFkX3BvaW50c19hdCwgInJlZnMvaGVhZHMvIikpIHsKCQllcnJvcnNfZm91bmQgfD0gRVJST1JfUkVGUzsKCQlyZXR1cm4gZXJyb3IoXygiJXMgcG9pbnRzIHRvIHNvbWV0aGluZyBzdHJhbmdlICglcykiKSwKCQkJICAgICBoZWFkX3JlZl9uYW1lLCAqaGVhZF9wb2ludHNfYXQpOwoJfQoJaWYgKGlzX251bGxfb2lkKGhlYWRfb2lkKSkgewoJCWlmIChudWxsX2lzX2Vycm9yKSB7CgkJCWVycm9yc19mb3VuZCB8PSBFUlJPUl9SRUZTOwoJCQlyZXR1cm4gZXJyb3IoXygiJXM6IGRldGFjaGVkIEhFQUQgcG9pbnRzIGF0IG5vdGhpbmciKSwKCQkJCSAgICAgaGVhZF9yZWZfbmFtZSk7CgkJfQoJCWZwcmludGZfbG4oc3RkZXJyLAoJCQkgICBfKCJub3RpY2U6ICVzIHBvaW50cyB0byBhbiB1bmJvcm4gYnJhbmNoICglcykiKSwKCQkJICAgaGVhZF9yZWZfbmFtZSwgKmhlYWRfcG9pbnRzX2F0ICsgMTEpOwoJfQoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgZnNja19jYWNoZV90cmVlKHN0cnVjdCBjYWNoZV90cmVlICppdCwgY29uc3QgY2hhciAqaW5kZXhfcGF0aCkKewoJaW50IGk7CglpbnQgZXJyID0gMDsKCglpZiAodmVyYm9zZSkKCQlmcHJpbnRmX2xuKHN0ZGVyciwgXygiQ2hlY2tpbmcgY2FjaGUgdHJlZSBvZiAlcyIpLCBpbmRleF9wYXRoKTsKCglpZiAoMCA8PSBpdC0+ZW50cnlfY291bnQpIHsKCQlzdHJ1Y3Qgb2JqZWN0ICpvYmogPSBwYXJzZV9vYmplY3QodGhlX3JlcG9zaXRvcnksICZpdC0+b2lkKTsKCQlpZiAoIW9iaikgewoJCQllcnJvcihfKCIlczogaW52YWxpZCBzaGExIHBvaW50ZXIgaW4gY2FjaGUtdHJlZSBvZiAlcyIpLAoJCQkgICAgICBvaWRfdG9faGV4KCZpdC0+b2lkKSwgaW5kZXhfcGF0aCk7CgkJCWVycm9yc19mb3VuZCB8PSBFUlJPUl9SRUZTOwoJCQlyZXR1cm4gMTsKCQl9CgkJb2JqLT5mbGFncyB8PSBVU0VEOwoJCWZzY2tfcHV0X29iamVjdF9uYW1lKCZmc2NrX3dhbGtfb3B0aW9ucywgJml0LT5vaWQsICI6Iik7CgkJbWFya19vYmplY3RfcmVhY2hhYmxlKG9iaik7CgkJaWYgKG9iai0+dHlwZSAhPSBPQkpfVFJFRSkKCQkJZXJyIHw9IG9iamVycm9yKG9iaiwgXygibm9uLXRyZWUgaW4gY2FjaGUtdHJlZSIpKTsKCX0KCWZvciAoaSA9IDA7IGkgPCBpdC0+c3VidHJlZV9ucjsgaSsrKQoJCWVyciB8PSBmc2NrX2NhY2hlX3RyZWUoaXQtPmRvd25baV0tPmNhY2hlX3RyZWUsIGluZGV4X3BhdGgpOwoJcmV0dXJuIGVycjsKfQoKc3RhdGljIGludCBmc2NrX3Jlc29sdmVfdW5kbyhzdHJ1Y3QgaW5kZXhfc3RhdGUgKmlzdGF0ZSwKCQkJICAgICBjb25zdCBjaGFyICppbmRleF9wYXRoKQp7CglzdHJ1Y3Qgc3RyaW5nX2xpc3RfaXRlbSAqaXRlbTsKCXN0cnVjdCBzdHJpbmdfbGlzdCAqcmVzb2x2ZV91bmRvID0gaXN0YXRlLT5yZXNvbHZlX3VuZG87CgoJaWYgKCFyZXNvbHZlX3VuZG8pCgkJcmV0dXJuIDA7CgoJZm9yX2VhY2hfc3RyaW5nX2xpc3RfaXRlbShpdGVtLCByZXNvbHZlX3VuZG8pIHsKCQljb25zdCBjaGFyICpwYXRoID0gaXRlbS0+c3RyaW5nOwoJCXN0cnVjdCByZXNvbHZlX3VuZG9faW5mbyAqcnUgPSBpdGVtLT51dGlsOwoJCWludCBpOwoKCQlpZiAoIXJ1KQoJCQljb250aW51ZTsKCQlmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7CgkJCXN0cnVjdCBvYmplY3QgKm9iajsKCgkJCWlmICghcnUtPm1vZGVbaV0gfHwgIVNfSVNSRUcocnUtPm1vZGVbaV0pKQoJCQkJY29udGludWU7CgoJCQlvYmogPSBwYXJzZV9vYmplY3QodGhlX3JlcG9zaXRvcnksICZydS0+b2lkW2ldKTsKCQkJaWYgKCFvYmopIHsKCQkJCWVycm9yKF8oIiVzOiBpbnZhbGlkIHNoYTEgcG9pbnRlciBpbiByZXNvbHZlLXVuZG8gb2YgJXMiKSwKCQkJCSAgICAgIG9pZF90b19oZXgoJnJ1LT5vaWRbaV0pLAoJCQkJICAgICAgaW5kZXhfcGF0aCk7CgkJCQllcnJvcnNfZm91bmQgfD0gRVJST1JfUkVGUzsKCQkJCWNvbnRpbnVlOwoJCQl9CgkJCW9iai0+ZmxhZ3MgfD0gVVNFRDsKCQkJZnNja19wdXRfb2JqZWN0X25hbWUoJmZzY2tfd2Fsa19vcHRpb25zLCAmcnUtPm9pZFtpXSwKCQkJCQkgICAgICI6KCVkKTolcyIsIGksIHBhdGgpOwoJCQltYXJrX29iamVjdF9yZWFjaGFibGUob2JqKTsKCQl9Cgl9CglyZXR1cm4gMDsKfQoKc3RhdGljIHZvaWQgZnNja19pbmRleChzdHJ1Y3QgaW5kZXhfc3RhdGUgKmlzdGF0ZSwgY29uc3QgY2hhciAqaW5kZXhfcGF0aCwKCQkgICAgICAgaW50IGlzX2N1cnJlbnRfd29ya3RyZWUpCnsKCXVuc2lnbmVkIGludCBpOwoKCS8qIFRPRE86IGF1ZGl0IGZvciBpbnRlcmFjdGlvbiB3aXRoIHNwYXJzZS1pbmRleC4gKi8KCWVuc3VyZV9mdWxsX2luZGV4KGlzdGF0ZSk7Cglmb3IgKGkgPSAwOyBpIDwgaXN0YXRlLT5jYWNoZV9ucjsgaSsrKSB7CgkJdW5zaWduZWQgaW50IG1vZGU7CgkJc3RydWN0IGJsb2IgKmJsb2I7CgkJc3RydWN0IG9iamVjdCAqb2JqOwoKCQltb2RlID0gaXN0YXRlLT5jYWNoZVtpXS0+Y2VfbW9kZTsKCQlpZiAoU19JU0dJVExJTksobW9kZSkpCgkJCWNvbnRpbnVlOwoJCWJsb2IgPSBsb29rdXBfYmxvYih0aGVfcmVwb3NpdG9yeSwKCQkJCSAgICZpc3RhdGUtPmNhY2hlW2ldLT5vaWQpOwoJCWlmICghYmxvYikKCQkJY29udGludWU7CgkJb2JqID0gJmJsb2ItPm9iamVjdDsKCQlvYmotPmZsYWdzIHw9IFVTRUQ7CgkJZnNja19wdXRfb2JqZWN0X25hbWUoJmZzY2tfd2Fsa19vcHRpb25zLCAmb2JqLT5vaWQsCgkJCQkgICAgICIlczolcyIsCgkJCQkgICAgIGlzX2N1cnJlbnRfd29ya3RyZWUgPyAiIiA6IGluZGV4X3BhdGgsCgkJCQkgICAgIGlzdGF0ZS0+Y2FjaGVbaV0tPm5hbWUpOwoJCW1hcmtfb2JqZWN0X3JlYWNoYWJsZShvYmopOwoJfQoJaWYgKGlzdGF0ZS0+Y2FjaGVfdHJlZSkKCQlmc2NrX2NhY2hlX3RyZWUoaXN0YXRlLT5jYWNoZV90cmVlLCBpbmRleF9wYXRoKTsKCWZzY2tfcmVzb2x2ZV91bmRvKGlzdGF0ZSwgaW5kZXhfcGF0aCk7Cn0KCnN0YXRpYyB2b2lkIG1hcmtfb2JqZWN0X2Zvcl9jb25uZWN0aXZpdHkoY29uc3Qgc3RydWN0IG9iamVjdF9pZCAqb2lkKQp7CglzdHJ1Y3Qgb2JqZWN0ICpvYmogPSBsb29rdXBfdW5rbm93bl9vYmplY3QodGhlX3JlcG9zaXRvcnksIG9pZCk7CglvYmotPmZsYWdzIHw9IEhBU19PQko7Cn0KCnN0YXRpYyBpbnQgbWFya19sb29zZV9mb3JfY29ubmVjdGl2aXR5KGNvbnN0IHN0cnVjdCBvYmplY3RfaWQgKm9pZCwKCQkJCSAgICAgICBjb25zdCBjaGFyICpwYXRoIFVOVVNFRCwKCQkJCSAgICAgICB2b2lkICpkYXRhIFVOVVNFRCkKewoJbWFya19vYmplY3RfZm9yX2Nvbm5lY3Rpdml0eShvaWQpOwoJcmV0dXJuIDA7Cn0KCnN0YXRpYyBpbnQgbWFya19wYWNrZWRfZm9yX2Nvbm5lY3Rpdml0eShjb25zdCBzdHJ1Y3Qgb2JqZWN0X2lkICpvaWQsCgkJCQkJc3RydWN0IHBhY2tlZF9naXQgKnBhY2sgVU5VU0VELAoJCQkJCXVpbnQzMl90IHBvcyBVTlVTRUQsCgkJCQkJdm9pZCAqZGF0YSBVTlVTRUQpCnsKCW1hcmtfb2JqZWN0X2Zvcl9jb25uZWN0aXZpdHkob2lkKTsKCXJldHVybiAwOwp9CgpzdGF0aWMgaW50IGNoZWNrX3BhY2tfcmV2X2luZGV4ZXMoc3RydWN0IHJlcG9zaXRvcnkgKnIsIGludCBzaG93X3Byb2dyZXNzKQp7CglzdHJ1Y3QgcHJvZ3Jlc3MgKnByb2dyZXNzID0gTlVMTDsKCXVpbnQzMl90IHBhY2tfY291bnQgPSAwOwoJaW50IHJlcyA9IDA7CgoJaWYgKHNob3dfcHJvZ3Jlc3MpIHsKCQlmb3IgKHN0cnVjdCBwYWNrZWRfZ2l0ICpwID0gZ2V0X2FsbF9wYWNrcyhyKTsgcDsgcCA9IHAtPm5leHQpCgkJCXBhY2tfY291bnQrKzsKCQlwcm9ncmVzcyA9IHN0YXJ0X2RlbGF5ZWRfcHJvZ3Jlc3ModGhlX3JlcG9zaXRvcnksCgkJCQkJCSAgIlZlcmlmeWluZyByZXZlcnNlIHBhY2staW5kZXhlcyIsIHBhY2tfY291bnQpOwoJCXBhY2tfY291bnQgPSAwOwoJfQoKCWZvciAoc3RydWN0IHBhY2tlZF9naXQgKnAgPSBnZXRfYWxsX3BhY2tzKHIpOyBwOyBwID0gcC0+bmV4dCkgewoJCWludCBsb2FkX2Vycm9yID0gbG9hZF9wYWNrX3JldmluZGV4X2Zyb21fZGlzayhwKTsKCgkJaWYgKGxvYWRfZXJyb3IgPCAwKSB7CgkJCWVycm9yKF8oInVuYWJsZSB0byBsb2FkIHJldi1pbmRleCBmb3IgcGFjayAnJXMnIiksIHAtPnBhY2tfbmFtZSk7CgkJCXJlcyA9IEVSUk9SX1BBQ0tfUkVWX0lOREVYOwoJCX0gZWxzZSBpZiAoIWxvYWRfZXJyb3IgJiYKCQkJICAgIWxvYWRfcGFja19yZXZpbmRleChyLCBwKSAmJgoJCQkgICB2ZXJpZnlfcGFja19yZXZpbmRleChwKSkgewoJCQllcnJvcihfKCJpbnZhbGlkIHJldi1pbmRleCBmb3IgcGFjayAnJXMnIiksIHAtPnBhY2tfbmFtZSk7CgkJCXJlcyA9IEVSUk9SX1BBQ0tfUkVWX0lOREVYOwoJCX0KCQlkaXNwbGF5X3Byb2dyZXNzKHByb2dyZXNzLCArK3BhY2tfY291bnQpOwoJfQoJc3RvcF9wcm9ncmVzcygmcHJvZ3Jlc3MpOwoKCXJldHVybiByZXM7Cn0KCnN0YXRpYyB2b2lkIGZzY2tfcmVmcyhzdHJ1Y3QgcmVwb3NpdG9yeSAqcikKewoJc3RydWN0IGNoaWxkX3Byb2Nlc3MgcmVmc192ZXJpZnkgPSBDSElMRF9QUk9DRVNTX0lOSVQ7CglzdHJ1Y3QgcHJvZ3Jlc3MgKnByb2dyZXNzID0gTlVMTDsKCglpZiAoc2hvd19wcm9ncmVzcykKCQlwcm9ncmVzcyA9IHN0YXJ0X3Byb2dyZXNzKHIsIF8oIkNoZWNraW5nIHJlZiBkYXRhYmFzZSIpLCAxKTsKCglpZiAodmVyYm9zZSkKCQlmcHJpbnRmX2xuKHN0ZGVyciwgXygiQ2hlY2tpbmcgcmVmIGRhdGFiYXNlIikpOwoKCWNoaWxkX3Byb2Nlc3NfaW5pdCgmcmVmc192ZXJpZnkpOwoJcmVmc192ZXJpZnkuZ2l0X2NtZCA9IDE7CglzdHJ2ZWNfcHVzaGwoJnJlZnNfdmVyaWZ5LmFyZ3MsICJyZWZzIiwgInZlcmlmeSIsIE5VTEwpOwoJaWYgKHZlcmJvc2UpCgkJc3RydmVjX3B1c2goJnJlZnNfdmVyaWZ5LmFyZ3MsICItLXZlcmJvc2UiKTsKCWlmIChjaGVja19zdHJpY3QpCgkJc3RydmVjX3B1c2goJnJlZnNfdmVyaWZ5LmFyZ3MsICItLXN0cmljdCIpOwoKCWlmIChydW5fY29tbWFuZCgmcmVmc192ZXJpZnkpKQoJCWVycm9yc19mb3VuZCB8PSBFUlJPUl9SRUZTOwoKCWRpc3BsYXlfcHJvZ3Jlc3MocHJvZ3Jlc3MsIDEpOwoJc3RvcF9wcm9ncmVzcygmcHJvZ3Jlc3MpOwp9CgpzdGF0aWMgY2hhciBjb25zdCAqIGNvbnN0IGZzY2tfdXNhZ2VbXSA9IHsKCU5fKCJnaXQgZnNjayBbLS10YWdzXSBbLS1yb290XSBbLS11bnJlYWNoYWJsZV0gWy0tY2FjaGVdIFstLW5vLXJlZmxvZ3NdXG4iCgkgICAiICAgICAgICAgWy0tW25vLV1mdWxsXSBbLS1zdHJpY3RdIFstLXZlcmJvc2VdIFstLWxvc3QtZm91bmRdXG4iCgkgICAiICAgICAgICAgWy0tW25vLV1kYW5nbGluZ10gWy0tW25vLV1wcm9ncmVzc10gWy0tY29ubmVjdGl2aXR5LW9ubHldXG4iCgkgICAiICAgICAgICAgWy0tW25vLV1uYW1lLW9iamVjdHNdIFstLVtuby1dcmVmZXJlbmNlc10gWzxvYmplY3Q+Li4uXSIpLAoJTlVMTAp9OwoKc3RhdGljIHN0cnVjdCBvcHRpb24gZnNja19vcHRzW10gPSB7CglPUFRfX1ZFUkJPU0UoJnZlcmJvc2UsIE5fKCJiZSB2ZXJib3NlIikpLAoJT1BUX0JPT0woMCwgInVucmVhY2hhYmxlIiwgJnNob3dfdW5yZWFjaGFibGUsIE5fKCJzaG93IHVucmVhY2hhYmxlIG9iamVjdHMiKSksCglPUFRfQk9PTCgwLCAiZGFuZ2xpbmciLCAmc2hvd19kYW5nbGluZywgTl8oInNob3cgZGFuZ2xpbmcgb2JqZWN0cyIpKSwKCU9QVF9CT09MKDAsICJ0YWdzIiwgJnNob3dfdGFncywgTl8oInJlcG9ydCB0YWdzIikpLAoJT1BUX0JPT0woMCwgInJvb3QiLCAmc2hvd19yb290LCBOXygicmVwb3J0IHJvb3Qgbm9kZXMiKSksCglPUFRfQk9PTCgwLCAiY2FjaGUiLCAma2VlcF9jYWNoZV9vYmplY3RzLCBOXygibWFrZSBpbmRleCBvYmplY3RzIGhlYWQgbm9kZXMiKSksCglPUFRfQk9PTCgwLCAicmVmbG9ncyIsICZpbmNsdWRlX3JlZmxvZ3MsIE5fKCJtYWtlIHJlZmxvZ3MgaGVhZCBub2RlcyAoZGVmYXVsdCkiKSksCglPUFRfQk9PTCgwLCAiZnVsbCIsICZjaGVja19mdWxsLCBOXygiYWxzbyBjb25zaWRlciBwYWNrcyBhbmQgYWx0ZXJuYXRlIG9iamVjdHMiKSksCglPUFRfQk9PTCgwLCAiY29ubmVjdGl2aXR5LW9ubHkiLCAmY29ubmVjdGl2aXR5X29ubHksIE5fKCJjaGVjayBvbmx5IGNvbm5lY3Rpdml0eSIpKSwKCU9QVF9CT09MKDAsICJzdHJpY3QiLCAmY2hlY2tfc3RyaWN0LCBOXygiZW5hYmxlIG1vcmUgc3RyaWN0IGNoZWNraW5nIikpLAoJT1BUX0JPT0woMCwgImxvc3QtZm91bmQiLCAmd3JpdGVfbG9zdF9hbmRfZm91bmQsCgkJCQlOXygid3JpdGUgZGFuZ2xpbmcgb2JqZWN0cyBpbiAuZ2l0L2xvc3QtZm91bmQiKSksCglPUFRfQk9PTCgwLCAicHJvZ3Jlc3MiLCAmc2hvd19wcm9ncmVzcywgTl8oInNob3cgcHJvZ3Jlc3MiKSksCglPUFRfQk9PTCgwLCAibmFtZS1vYmplY3RzIiwgJm5hbWVfb2JqZWN0cywgTl8oInNob3cgdmVyYm9zZSBuYW1lcyBmb3IgcmVhY2hhYmxlIG9iamVjdHMiKSksCglPUFRfQk9PTCgwLCAicmVmZXJlbmNlcyIsICZjaGVja19yZWZlcmVuY2VzLCBOXygiY2hlY2sgcmVmZXJlbmNlIGRhdGFiYXNlIGNvbnNpc3RlbmN5IikpLAoJT1BUX0VORCgpLAp9OwoKaW50IGNtZF9mc2NrKGludCBhcmdjLAoJICAgICBjb25zdCBjaGFyICoqYXJndiwKCSAgICAgY29uc3QgY2hhciAqcHJlZml4LAoJICAgICBzdHJ1Y3QgcmVwb3NpdG9yeSAqcmVwbyBVTlVTRUQpCnsKCWludCBpOwoJc3RydWN0IG9kYl9zb3VyY2UgKnNvdXJjZTsKCgkvKiBmc2NrIGtub3dzIGhvdyB0byBoYW5kbGUgbWlzc2luZyBwcm9taXNvciBvYmplY3RzICovCglmZXRjaF9pZl9taXNzaW5nID0gMDsKCgllcnJvcnNfZm91bmQgPSAwOwoJZGlzYWJsZV9yZXBsYWNlX3JlZnMoKTsKCXNhdmVfY29tbWl0X2J1ZmZlciA9IDA7CgoJYXJnYyA9IHBhcnNlX29wdGlvbnMoYXJnYywgYXJndiwgcHJlZml4LCBmc2NrX29wdHMsIGZzY2tfdXNhZ2UsIDApOwoKCWZzY2tfd2Fsa19vcHRpb25zLndhbGsgPSBtYXJrX29iamVjdDsKCWZzY2tfb2JqX29wdGlvbnMud2FsayA9IG1hcmtfdXNlZDsKCWZzY2tfb2JqX29wdGlvbnMuZXJyb3JfZnVuYyA9IGZzY2tfb2JqZWN0c19lcnJvcl9mdW5jOwoJaWYgKGNoZWNrX3N0cmljdCkKCQlmc2NrX29ial9vcHRpb25zLnN0cmljdCA9IDE7CgoJaWYgKHNob3dfcHJvZ3Jlc3MgPT0gLTEpCgkJc2hvd19wcm9ncmVzcyA9IGlzYXR0eSgyKTsKCWlmICh2ZXJib3NlKQoJCXNob3dfcHJvZ3Jlc3MgPSAwOwoKCWlmICh3cml0ZV9sb3N0X2FuZF9mb3VuZCkgewoJCWNoZWNrX2Z1bGwgPSAxOwoJCWluY2x1ZGVfcmVmbG9ncyA9IDA7Cgl9CgoJaWYgKG5hbWVfb2JqZWN0cykKCQlmc2NrX2VuYWJsZV9vYmplY3RfbmFtZXMoJmZzY2tfd2Fsa19vcHRpb25zKTsKCglnaXRfY29uZmlnKGdpdF9mc2NrX2NvbmZpZywgJmZzY2tfb2JqX29wdGlvbnMpOwoJcHJlcGFyZV9yZXBvX3NldHRpbmdzKHRoZV9yZXBvc2l0b3J5KTsKCglpZiAoY2hlY2tfcmVmZXJlbmNlcykKCQlmc2NrX3JlZnModGhlX3JlcG9zaXRvcnkpOwoKCWlmIChjb25uZWN0aXZpdHlfb25seSkgewoJCWZvcl9lYWNoX2xvb3NlX29iamVjdChtYXJrX2xvb3NlX2Zvcl9jb25uZWN0aXZpdHksIE5VTEwsIDApOwoJCWZvcl9lYWNoX3BhY2tlZF9vYmplY3QodGhlX3JlcG9zaXRvcnksCgkJCQkgICAgICAgbWFya19wYWNrZWRfZm9yX2Nvbm5lY3Rpdml0eSwgTlVMTCwgMCk7Cgl9IGVsc2UgewoJCW9kYl9wcmVwYXJlX2FsdGVybmF0ZXModGhlX3JlcG9zaXRvcnktPm9iamVjdHMpOwoJCWZvciAoc291cmNlID0gdGhlX3JlcG9zaXRvcnktPm9iamVjdHMtPnNvdXJjZXM7IHNvdXJjZTsgc291cmNlID0gc291cmNlLT5uZXh0KQoJCQlmc2NrX29iamVjdF9kaXIoc291cmNlLT5wYXRoKTsKCgkJaWYgKGNoZWNrX2Z1bGwpIHsKCQkJc3RydWN0IHBhY2tlZF9naXQgKnA7CgkJCXVpbnQzMl90IHRvdGFsID0gMCwgY291bnQgPSAwOwoJCQlzdHJ1Y3QgcHJvZ3Jlc3MgKnByb2dyZXNzID0gTlVMTDsKCgkJCWlmIChzaG93X3Byb2dyZXNzKSB7CgkJCQlmb3IgKHAgPSBnZXRfYWxsX3BhY2tzKHRoZV9yZXBvc2l0b3J5KTsgcDsKCQkJCSAgICAgcCA9IHAtPm5leHQpIHsKCQkJCQlpZiAob3Blbl9wYWNrX2luZGV4KHApKQoJCQkJCQljb250aW51ZTsKCQkJCQl0b3RhbCArPSBwLT5udW1fb2JqZWN0czsKCQkJCX0KCgkJCQlwcm9ncmVzcyA9IHN0YXJ0X3Byb2dyZXNzKHRoZV9yZXBvc2l0b3J5LAoJCQkJCQkJICBfKCJDaGVja2luZyBvYmplY3RzIiksIHRvdGFsKTsKCQkJfQoJCQlmb3IgKHAgPSBnZXRfYWxsX3BhY2tzKHRoZV9yZXBvc2l0b3J5KTsgcDsKCQkJICAgICBwID0gcC0+bmV4dCkgewoJCQkJLyogdmVyaWZ5IGdpdmVzIGVycm9yIG1lc3NhZ2VzIGl0c2VsZiAqLwoJCQkJaWYgKHZlcmlmeV9wYWNrKHRoZV9yZXBvc2l0b3J5LAoJCQkJCQlwLCBmc2NrX29ial9idWZmZXIsCgkJCQkJCXByb2dyZXNzLCBjb3VudCkpCgkJCQkJZXJyb3JzX2ZvdW5kIHw9IEVSUk9SX1BBQ0s7CgkJCQljb3VudCArPSBwLT5udW1fb2JqZWN0czsKCQkJfQoJCQlzdG9wX3Byb2dyZXNzKCZwcm9ncmVzcyk7CgkJfQoKCQlpZiAoZnNja19maW5pc2goJmZzY2tfb2JqX29wdGlvbnMpKQoJCQllcnJvcnNfZm91bmQgfD0gRVJST1JfT0JKRUNUOwoJfQoKCWZvciAoaSA9IDA7IGkgPCBhcmdjOyBpKyspIHsKCQljb25zdCBjaGFyICphcmcgPSBhcmd2W2ldOwoJCXN0cnVjdCBvYmplY3RfaWQgb2lkOwoJCWlmICghcmVwb19nZXRfb2lkKHRoZV9yZXBvc2l0b3J5LCBhcmcsICZvaWQpKSB7CgkJCXN0cnVjdCBvYmplY3QgKm9iaiA9IGxvb2t1cF9vYmplY3QodGhlX3JlcG9zaXRvcnksCgkJCQkJCQkgICAmb2lkKTsKCgkJCWlmICghb2JqIHx8ICEob2JqLT5mbGFncyAmIEhBU19PQkopKSB7CgkJCQlpZiAoaXNfcHJvbWlzb3Jfb2JqZWN0KHRoZV9yZXBvc2l0b3J5LCAmb2lkKSkKCQkJCQljb250aW51ZTsKCQkJCWVycm9yKF8oIiVzOiBvYmplY3QgbWlzc2luZyIpLCBvaWRfdG9faGV4KCZvaWQpKTsKCQkJCWVycm9yc19mb3VuZCB8PSBFUlJPUl9PQkpFQ1Q7CgkJCQljb250aW51ZTsKCQkJfQoKCQkJb2JqLT5mbGFncyB8PSBVU0VEOwoJCQlmc2NrX3B1dF9vYmplY3RfbmFtZSgmZnNja193YWxrX29wdGlvbnMsICZvaWQsCgkJCQkJICAgICAiJXMiLCBhcmcpOwoJCQltYXJrX29iamVjdF9yZWFjaGFibGUob2JqKTsKCQkJY29udGludWU7CgkJfQoJCWVycm9yKF8oImludmFsaWQgcGFyYW1ldGVyOiBleHBlY3RlZCBzaGExLCBnb3QgJyVzJyIpLCBhcmcpOwoJCWVycm9yc19mb3VuZCB8PSBFUlJPUl9PQkpFQ1Q7Cgl9CgoJLyoKCSAqIElmIHdlJ3ZlIG5vdCBiZWVuIGdpdmVuIGFueSBleHBsaWNpdCBoZWFkIGluZm9ybWF0aW9uLCBkbyB0aGUKCSAqIGRlZmF1bHQgb25lcyBmcm9tIC5naXQvcmVmcy4gV2UgYWxzbyBjb25zaWRlciB0aGUgaW5kZXggZmlsZQoJICogaW4gdGhpcyBjYXNlIChpZSB0aGlzIGltcGxpZXMgLS1jYWNoZSkuCgkgKi8KCWlmICghYXJnYykgewoJCWdldF9kZWZhdWx0X2hlYWRzKCk7CgkJa2VlcF9jYWNoZV9vYmplY3RzID0gMTsKCX0KCglpZiAoa2VlcF9jYWNoZV9vYmplY3RzKSB7CgkJc3RydWN0IHdvcmt0cmVlICoqd29ya3RyZWVzLCAqKnA7CgoJCXZlcmlmeV9pbmRleF9jaGVja3N1bSA9IDE7CgkJdmVyaWZ5X2NlX29yZGVyID0gMTsKCgkJd29ya3RyZWVzID0gZ2V0X3dvcmt0cmVlcygpOwoJCWZvciAocCA9IHdvcmt0cmVlczsgKnA7IHArKykgewoJCQlzdHJ1Y3Qgd29ya3RyZWUgKnd0ID0gKnA7CgkJCXN0cnVjdCBpbmRleF9zdGF0ZSBpc3RhdGUgPQoJCQkJSU5ERVhfU1RBVEVfSU5JVCh0aGVfcmVwb3NpdG9yeSk7CgkJCWNoYXIgKnBhdGgsICp3dF9naXRkaXI7CgoJCQkvKgoJCQkgKiBNYWtlIGEgY29weSBzaW5jZSB0aGUgYnVmZmVyIGlzIHJldXNhYmxlCgkJCSAqIGFuZCBtYXkgZ2V0IG92ZXJ3cml0dGVuIGJ5IG90aGVyIGNhbGxzCgkJCSAqIHdoaWxlIHdlJ3JlIGV4YW1pbmluZyB0aGUgaW5kZXguCgkJCSAqLwoJCQlwYXRoID0geHN0cmR1cCh3b3JrdHJlZV9naXRfcGF0aCh0aGVfcmVwb3NpdG9yeSwgd3QsICJpbmRleCIpKTsKCQkJd3RfZ2l0ZGlyID0gZ2V0X3dvcmt0cmVlX2dpdF9kaXIod3QpOwoKCQkJcmVhZF9pbmRleF9mcm9tKCZpc3RhdGUsIHBhdGgsIHd0X2dpdGRpcik7CgkJCWZzY2tfaW5kZXgoJmlzdGF0ZSwgcGF0aCwgd3QtPmlzX2N1cnJlbnQpOwoKCQkJZGlzY2FyZF9pbmRleCgmaXN0YXRlKTsKCQkJZnJlZSh3dF9naXRkaXIpOwoJCQlmcmVlKHBhdGgpOwoJCX0KCQlmcmVlX3dvcmt0cmVlcyh3b3JrdHJlZXMpOwoJfQoKCWVycm9yc19mb3VuZCB8PSBjaGVja19wYWNrX3Jldl9pbmRleGVzKHRoZV9yZXBvc2l0b3J5LCBzaG93X3Byb2dyZXNzKTsKCWlmICh2ZXJpZnlfYml0bWFwX2ZpbGVzKHRoZV9yZXBvc2l0b3J5KSkKCQllcnJvcnNfZm91bmQgfD0gRVJST1JfQklUTUFQOwoKCWNoZWNrX2Nvbm5lY3Rpdml0eSgpOwoKCWlmICh0aGVfcmVwb3NpdG9yeS0+c2V0dGluZ3MuY29yZV9jb21taXRfZ3JhcGgpIHsKCQlzdHJ1Y3QgY2hpbGRfcHJvY2VzcyBjb21taXRfZ3JhcGhfdmVyaWZ5ID0gQ0hJTERfUFJPQ0VTU19JTklUOwoKCQlvZGJfcHJlcGFyZV9hbHRlcm5hdGVzKHRoZV9yZXBvc2l0b3J5LT5vYmplY3RzKTsKCQlmb3IgKHNvdXJjZSA9IHRoZV9yZXBvc2l0b3J5LT5vYmplY3RzLT5zb3VyY2VzOyBzb3VyY2U7IHNvdXJjZSA9IHNvdXJjZS0+bmV4dCkgewoJCQljaGlsZF9wcm9jZXNzX2luaXQoJmNvbW1pdF9ncmFwaF92ZXJpZnkpOwoJCQljb21taXRfZ3JhcGhfdmVyaWZ5LmdpdF9jbWQgPSAxOwoJCQlzdHJ2ZWNfcHVzaGwoJmNvbW1pdF9ncmFwaF92ZXJpZnkuYXJncywgImNvbW1pdC1ncmFwaCIsCgkJCQkgICAgICJ2ZXJpZnkiLCAiLS1vYmplY3QtZGlyIiwgc291cmNlLT5wYXRoLCBOVUxMKTsKCQkJaWYgKHNob3dfcHJvZ3Jlc3MpCgkJCQlzdHJ2ZWNfcHVzaCgmY29tbWl0X2dyYXBoX3ZlcmlmeS5hcmdzLCAiLS1wcm9ncmVzcyIpOwoJCQllbHNlCgkJCQlzdHJ2ZWNfcHVzaCgmY29tbWl0X2dyYXBoX3ZlcmlmeS5hcmdzLCAiLS1uby1wcm9ncmVzcyIpOwoJCQlpZiAocnVuX2NvbW1hbmQoJmNvbW1pdF9ncmFwaF92ZXJpZnkpKQoJCQkJZXJyb3JzX2ZvdW5kIHw9IEVSUk9SX0NPTU1JVF9HUkFQSDsKCQl9Cgl9CgoJaWYgKHRoZV9yZXBvc2l0b3J5LT5zZXR0aW5ncy5jb3JlX211bHRpX3BhY2tfaW5kZXgpIHsKCQlzdHJ1Y3QgY2hpbGRfcHJvY2VzcyBtaWR4X3ZlcmlmeSA9IENISUxEX1BST0NFU1NfSU5JVDsKCgkJb2RiX3ByZXBhcmVfYWx0ZXJuYXRlcyh0aGVfcmVwb3NpdG9yeS0+b2JqZWN0cyk7CgkJZm9yIChzb3VyY2UgPSB0aGVfcmVwb3NpdG9yeS0+b2JqZWN0cy0+c291cmNlczsgc291cmNlOyBzb3VyY2UgPSBzb3VyY2UtPm5leHQpIHsKCQkJY2hpbGRfcHJvY2Vzc19pbml0KCZtaWR4X3ZlcmlmeSk7CgkJCW1pZHhfdmVyaWZ5LmdpdF9jbWQgPSAxOwoJCQlzdHJ2ZWNfcHVzaGwoJm1pZHhfdmVyaWZ5LmFyZ3MsICJtdWx0aS1wYWNrLWluZGV4IiwKCQkJCSAgICAgInZlcmlmeSIsICItLW9iamVjdC1kaXIiLCBzb3VyY2UtPnBhdGgsIE5VTEwpOwoJCQlpZiAoc2hvd19wcm9ncmVzcykKCQkJCXN0cnZlY19wdXNoKCZtaWR4X3ZlcmlmeS5hcmdzLCAiLS1wcm9ncmVzcyIpOwoJCQllbHNlCgkJCQlzdHJ2ZWNfcHVzaCgmbWlkeF92ZXJpZnkuYXJncywgIi0tbm8tcHJvZ3Jlc3MiKTsKCQkJaWYgKHJ1bl9jb21tYW5kKCZtaWR4X3ZlcmlmeSkpCgkJCQllcnJvcnNfZm91bmQgfD0gRVJST1JfTVVMVElfUEFDS19JTkRFWDsKCQl9Cgl9CgoJcmV0dXJuIGVycm9yc19mb3VuZDsKfQo=",
    "text": "#define USE_THE_REPOSITORY_VARIABLE\n#include \"builtin.h\"\n#include \"gettext.h\"\n#include \"hex.h\"\n#include \"config.h\"\n#include \"commit.h\"\n#include \"tree.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"refs.h\"\n#include \"pack.h\"\n#include \"cache-tree.h\"\n#include \"fsck.h\"\n#include \"parse-options.h\"\n#include \"progress.h\"\n#include \"streaming.h\"\n#include \"packfile.h\"\n#include \"object-file.h\"\n#include \"object-name.h\"\n#include \"odb.h\"\n#include \"path.h\"\n#include \"read-cache-ll.h\"\n#include \"replace-object.h\"\n#include \"resolve-undo.h\"\n#include \"run-command.h\"\n#include \"sparse-index.h\"\n#include \"worktree.h\"\n#include \"pack-revindex.h\"\n#include \"pack-bitmap.h\"\n\n#define REACHABLE 0x0001\n#define SEEN      0x0002\n#define HAS_OBJ   0x0004\n/* This flag is set if something points to this object. */\n#define USED      0x0008\n\nstatic int show_root;\nstatic int show_tags;\nstatic int show_unreachable;\nstatic int include_reflogs = 1;\nstatic int check_full = 1;\nstatic int connectivity_only;\nstatic int check_strict;\nstatic int keep_cache_objects;\nstatic struct fsck_options fsck_walk_options = FSCK_OPTIONS_DEFAULT;\nstatic struct fsck_options fsck_obj_options = FSCK_OPTIONS_DEFAULT;\nstatic int errors_found;\nstatic int write_lost_and_found;\nstatic int verbose;\nstatic int show_progress = -1;\nstatic int show_dangling = 1;\nstatic int name_objects;\nstatic int check_references = 1;\n#define ERROR_OBJECT 01\n#define ERROR_REACHABLE 02\n#define ERROR_PACK 04\n#define ERROR_REFS 010\n#define ERROR_COMMIT_GRAPH 020\n#define ERROR_MULTI_PACK_INDEX 040\n#define ERROR_PACK_REV_INDEX 0100\n#define ERROR_BITMAP 0200\n\nstatic const char *describe_object(const struct object_id *oid)\n{\n\treturn fsck_describe_object(&fsck_walk_options, oid);\n}\n\nstatic const char *printable_type(const struct object_id *oid,\n\t\t\t\t  enum object_type type)\n{\n\tconst char *ret;\n\n\tif (type == OBJ_NONE)\n\t\ttype = odb_read_object_info(the_repository->objects,\n\t\t\t\t\t    oid, NULL);\n\n\tret = type_name(type);\n\tif (!ret)\n\t\tret = _(\"unknown\");\n\n\treturn ret;\n}\n\nstatic int objerror(struct object *obj, const char *err)\n{\n\terrors_found |= ERROR_OBJECT;\n\t/* TRANSLATORS: e.g. error in tree 01bfda: <more explanation> */\n\tfprintf_ln(stderr, _(\"error in %s %s: %s\"),\n\t\t   printable_type(&obj->oid, obj->type),\n\t\t   describe_object(&obj->oid), err);\n\treturn -1;\n}\n\nstatic int fsck_objects_error_func(struct fsck_options *o UNUSED,\n\t\t\t\t   void *fsck_report,\n\t\t\t\t   enum fsck_msg_type msg_type,\n\t\t\t\t   enum fsck_msg_id msg_id UNUSED,\n\t\t\t\t   const char *message)\n{\n\tstruct fsck_object_report *report = fsck_report;\n\tconst struct object_id *oid = report->oid;\n\tenum object_type object_type = report->object_type;\n\n\tswitch (msg_type) {\n\tcase FSCK_WARN:\n\t\t/* TRANSLATORS: e.g. warning in tree 01bfda: <more explanation> */\n\t\tfprintf_ln(stderr, _(\"warning in %s %s: %s\"),\n\t\t\t   printable_type(oid, object_type),\n\t\t\t   describe_object(oid), message);\n\t\treturn 0;\n\tcase FSCK_ERROR:\n\t\t/* TRANSLATORS: e.g. error in tree 01bfda: <more explanation> */\n\t\tfprintf_ln(stderr, _(\"error in %s %s: %s\"),\n\t\t\t   printable_type(oid, object_type),\n\t\t\t   describe_object(oid), message);\n\t\treturn 1;\n\tdefault:\n\t\tBUG(\"%d (FSCK_IGNORE?) should never trigger this callback\",\n\t\t    msg_type);\n\t}\n}\n\nstatic struct object_array pending;\n\nstatic int mark_object(struct object *obj, enum object_type type,\n\t\t       void *data, struct fsck_options *options UNUSED)\n{\n\tstruct object *parent = data;\n\n\t/*\n\t * The only case data is NULL or type is OBJ_ANY is when\n\t * mark_object_reachable() calls us.  All the callers of\n\t * that function has non-NULL obj hence ...\n\t */\n\tif (!obj) {\n\t\t/* ... these references to parent->fld are safe here */\n\t\tprintf_ln(_(\"broken link from %7s %s\"),\n\t\t\t  printable_type(&parent->oid, parent->type),\n\t\t\t  describe_object(&parent->oid));\n\t\tprintf_ln(_(\"broken link from %7s %s\"),\n\t\t\t  (type == OBJ_ANY ? _(\"unknown\") : type_name(type)),\n\t\t\t  _(\"unknown\"));\n\t\terrors_found |= ERROR_REACHABLE;\n\t\treturn 1;\n\t}\n\n\tif (type != OBJ_ANY && obj->type != type)\n\t\t/* ... and the reference to parent is safe here */\n\t\tobjerror(parent, _(\"wrong object type in link\"));\n\n\tif (obj->flags & REACHABLE)\n\t\treturn 0;\n\tobj->flags |= REACHABLE;\n\n\tif (is_promisor_object(the_repository, &obj->oid))\n\t\t/*\n\t\t * Further recursion does not need to be performed on this\n\t\t * object since it is a promisor object (so it does not need to\n\t\t * be added to \"pending\").\n\t\t */\n\t\treturn 0;\n\n\tif (!(obj->flags & HAS_OBJ)) {\n\t\tif (parent && !odb_has_object(the_repository->objects, &obj->oid, 1)) {\n\t\t\tprintf_ln(_(\"broken link from %7s %s\\n\"\n\t\t\t\t    \"              to %7s %s\"),\n\t\t\t\t  printable_type(&parent->oid, parent->type),\n\t\t\t\t  describe_object(&parent->oid),\n\t\t\t\t  printable_type(&obj->oid, obj->type),\n\t\t\t\t  describe_object(&obj->oid));\n\t\t\terrors_found |= ERROR_REACHABLE;\n\t\t}\n\t\treturn 1;\n\t}\n\n\tadd_object_array(obj, NULL, &pending);\n\treturn 0;\n}\n\nstatic void mark_object_reachable(struct object *obj)\n{\n\tmark_object(obj, OBJ_ANY, NULL, NULL);\n}\n\nstatic int traverse_one_object(struct object *obj)\n{\n\tint result = fsck_walk(obj, obj, &fsck_walk_options);\n\n\tif (obj->type == OBJ_TREE) {\n\t\tstruct tree *tree = (struct tree *)obj;\n\t\tfree_tree_buffer(tree);\n\t}\n\treturn result;\n}\n\nstatic int traverse_reachable(void)\n{\n\tstruct progress *progress = NULL;\n\tunsigned int nr = 0;\n\tint result = 0;\n\tif (show_progress)\n\t\tprogress = start_delayed_progress(the_repository,\n\t\t\t\t\t\t  _(\"Checking connectivity\"), 0);\n\twhile (pending.nr) {\n\t\tresult |= traverse_one_object(object_array_pop(&pending));\n\t\tdisplay_progress(progress, ++nr);\n\t}\n\tstop_progress(&progress);\n\treturn !!result;\n}\n\nstatic int mark_used(struct object *obj, enum object_type type UNUSED,\n\t\t     void *data UNUSED, struct fsck_options *options UNUSED)\n{\n\tif (!obj)\n\t\treturn 1;\n\tobj->flags |= USED;\n\treturn 0;\n}\n\nstatic void mark_unreachable_referents(const struct object_id *oid)\n{\n\tstruct fsck_options options = FSCK_OPTIONS_DEFAULT;\n\tstruct object *obj = lookup_object(the_repository, oid);\n\n\tif (!obj || !(obj->flags & HAS_OBJ))\n\t\treturn; /* not part of our original set */\n\tif (obj->flags & REACHABLE)\n\t\treturn; /* reachable objects already traversed */\n\n\t/*\n\t * Avoid passing OBJ_NONE to fsck_walk, which will parse the object\n\t * (and we want to avoid parsing blobs).\n\t */\n\tif (obj->type == OBJ_NONE) {\n\t\tenum object_type type = odb_read_object_info(the_repository->objects,\n\t\t\t\t\t\t\t     &obj->oid, NULL);\n\t\tif (type > 0)\n\t\t\tobject_as_type(obj, type, 0);\n\t}\n\n\toptions.walk = mark_used;\n\tfsck_walk(obj, NULL, &options);\n\tif (obj->type == OBJ_TREE)\n\t\tfree_tree_buffer((struct tree *)obj);\n}\n\nstatic int mark_loose_unreachable_referents(const struct object_id *oid,\n\t\t\t\t\t    const char *path UNUSED,\n\t\t\t\t\t    void *data UNUSED)\n{\n\tmark_unreachable_referents(oid);\n\treturn 0;\n}\n\nstatic int mark_packed_unreachable_referents(const struct object_id *oid,\n\t\t\t\t\t     struct packed_git *pack UNUSED,\n\t\t\t\t\t     uint32_t pos UNUSED,\n\t\t\t\t\t     void *data UNUSED)\n{\n\tmark_unreachable_referents(oid);\n\treturn 0;\n}\n\n/*\n * Check a single reachable object\n */\nstatic void check_reachable_object(struct object *obj)\n{\n\t/*\n\t * We obviously want the object to be parsed,\n\t * except if it was in a pack-file and we didn't\n\t * do a full fsck\n\t */\n\tif (!(obj->flags & HAS_OBJ)) {\n\t\tif (is_promisor_object(the_repository, &obj->oid))\n\t\t\treturn;\n\t\tif (has_object_pack(the_repository, &obj->oid))\n\t\t\treturn; /* it is in pack - forget about it */\n\t\tprintf_ln(_(\"missing %s %s\"),\n\t\t\t  printable_type(&obj->oid, obj->type),\n\t\t\t  describe_object(&obj->oid));\n\t\terrors_found |= ERROR_REACHABLE;\n\t\treturn;\n\t}\n}\n\n/*\n * Check a single unreachable object\n */\nstatic void check_unreachable_object(struct object *obj)\n{\n\t/*\n\t * Missing unreachable object? Ignore it. It's not like\n\t * we miss it (since it can't be reached), nor do we want\n\t * to complain about it being unreachable (since it does\n\t * not exist).\n\t */\n\tif (!(obj->flags & HAS_OBJ))\n\t\treturn;\n\n\t/*\n\t * Unreachable object that exists? Show it if asked to,\n\t * since this is something that is prunable.\n\t */\n\tif (show_unreachable) {\n\t\tprintf_ln(_(\"unreachable %s %s\"),\n\t\t\t  printable_type(&obj->oid, obj->type),\n\t\t\t  describe_object(&obj->oid));\n\t\treturn;\n\t}\n\n\t/*\n\t * \"!USED\" means that nothing at all points to it, including\n\t * other unreachable objects. In other words, it's the \"tip\"\n\t * of some set of unreachable objects, usually a commit that\n\t * got dropped.\n\t *\n\t * Such starting points are more interesting than some random\n\t * set of unreachable objects, so we show them even if the user\n\t * hasn't asked for _all_ unreachable objects. If you have\n\t * deleted a branch by mistake, this is a prime candidate to\n\t * start looking at, for example.\n\t */\n\tif (!(obj->flags & USED)) {\n\t\tif (show_dangling)\n\t\t\tprintf_ln(_(\"dangling %s %s\"),\n\t\t\t\t  printable_type(&obj->oid, obj->type),\n\t\t\t\t  describe_object(&obj->oid));\n\t\tif (write_lost_and_found) {\n\t\t\tchar *filename = repo_git_path(the_repository, \"lost-found/%s/%s\",\n\t\t\t\tobj->type == OBJ_COMMIT ? \"commit\" : \"other\",\n\t\t\t\tdescribe_object(&obj->oid));\n\t\t\tFILE *f;\n\n\t\t\tif (safe_create_leading_directories_const(the_repository, filename)) {\n\t\t\t\terror(_(\"could not create lost-found\"));\n\t\t\t\tfree(filename);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tf = xfopen(filename, \"w\");\n\t\t\tif (obj->type == OBJ_BLOB) {\n\t\t\t\tif (stream_blob_to_fd(fileno(f), &obj->oid, NULL, 1))\n\t\t\t\t\tdie_errno(_(\"could not write '%s'\"), filename);\n\t\t\t} else\n\t\t\t\tfprintf(f, \"%s\\n\", describe_object(&obj->oid));\n\t\t\tif (fclose(f))\n\t\t\t\tdie_errno(_(\"could not finish '%s'\"),\n\t\t\t\t\t  filename);\n\t\t\tfree(filename);\n\t\t}\n\t\treturn;\n\t}\n\n\t/*\n\t * Otherwise? It's there, it's unreachable, and some other unreachable\n\t * object points to it. Ignore it - it's not interesting, and we showed\n\t * all the interesting cases above.\n\t */\n}\n\nstatic void check_object(struct object *obj)\n{\n\tif (verbose)\n\t\tfprintf_ln(stderr, _(\"Checking %s\"), describe_object(&obj->oid));\n\n\tif (obj->flags & REACHABLE)\n\t\tcheck_reachable_object(obj);\n\telse\n\t\tcheck_unreachable_object(obj);\n}\n\nstatic void check_connectivity(void)\n{\n\tint i, max;\n\n\t/* Traverse the pending reachable objects */\n\ttraverse_reachable();\n\n\t/*\n\t * With --connectivity-only, we won't have actually opened and marked\n\t * unreachable objects with USED. Do that now to make --dangling, etc\n\t * accurate.\n\t */\n\tif (connectivity_only && (show_dangling || write_lost_and_found)) {\n\t\t/*\n\t\t * Even though we already have a \"struct object\" for each of\n\t\t * these in memory, we must not iterate over the internal\n\t\t * object hash as we do below. Our loop would potentially\n\t\t * resize the hash, making our iteration invalid.\n\t\t *\n\t\t * Instead, we'll just go back to the source list of objects,\n\t\t * and ignore any that weren't present in our earlier\n\t\t * traversal.\n\t\t */\n\t\tfor_each_loose_object(mark_loose_unreachable_referents, NULL, 0);\n\t\tfor_each_packed_object(the_repository,\n\t\t\t\t       mark_packed_unreachable_referents,\n\t\t\t\t       NULL,\n\t\t\t\t       0);\n\t}\n\n\t/* Look up all the requirements, warn about missing objects.. */\n\tmax = get_max_object_index(the_repository);\n\tif (verbose)\n\t\tfprintf_ln(stderr, _(\"Checking connectivity (%d objects)\"), max);\n\n\tfor (i = 0; i < max; i++) {\n\t\tstruct object *obj = get_indexed_object(the_repository, i);\n\n\t\tif (obj)\n\t\t\tcheck_object(obj);\n\t}\n}\n\nstatic int fsck_obj(struct object *obj, void *buffer, unsigned long size)\n{\n\tint err;\n\n\tif (obj->flags & SEEN)\n\t\treturn 0;\n\tobj->flags |= SEEN;\n\n\tif (verbose)\n\t\tfprintf_ln(stderr, _(\"Checking %s %s\"),\n\t\t\t   printable_type(&obj->oid, obj->type),\n\t\t\t   describe_object(&obj->oid));\n\n\tif (fsck_walk(obj, NULL, &fsck_obj_options))\n\t\tobjerror(obj, _(\"broken links\"));\n\terr = fsck_object(obj, buffer, size, &fsck_obj_options);\n\tif (err)\n\t\tgoto out;\n\n\tif (obj->type == OBJ_COMMIT) {\n\t\tstruct commit *commit = (struct commit *) obj;\n\n\t\tif (!commit->parents && show_root)\n\t\t\tprintf_ln(_(\"root %s\"),\n\t\t\t\t  describe_object(&commit->object.oid));\n\t}\n\n\tif (obj->type == OBJ_TAG) {\n\t\tstruct tag *tag = (struct tag *) obj;\n\n\t\tif (show_tags && tag->tagged) {\n\t\t\tprintf_ln(_(\"tagged %s %s (%s) in %s\"),\n\t\t\t\t  printable_type(&tag->tagged->oid, tag->tagged->type),\n\t\t\t\t  describe_object(&tag->tagged->oid),\n\t\t\t\t  tag->tag,\n\t\t\t\t  describe_object(&tag->object.oid));\n\t\t}\n\t}\n\nout:\n\tif (obj->type == OBJ_TREE)\n\t\tfree_tree_buffer((struct tree *)obj);\n\treturn err;\n}\n\nstatic int fsck_obj_buffer(const struct object_id *oid, enum object_type type,\n\t\t\t   unsigned long size, void *buffer, int *eaten)\n{\n\t/*\n\t * Note, buffer may be NULL if type is OBJ_BLOB. See\n\t * verify_packfile(), data_valid variable for details.\n\t */\n\tstruct object *obj;\n\tobj = parse_object_buffer(the_repository, oid, type, size, buffer,\n\t\t\t\t  eaten);\n\tif (!obj) {\n\t\terrors_found |= ERROR_OBJECT;\n\t\treturn error(_(\"%s: object corrupt or missing\"),\n\t\t\t     oid_to_hex(oid));\n\t}\n\tobj->flags &= ~(REACHABLE | SEEN);\n\tobj->flags |= HAS_OBJ;\n\treturn fsck_obj(obj, buffer, size);\n}\n\nstatic int default_refs;\n\nstatic void fsck_handle_reflog_oid(const char *refname, struct object_id *oid,\n\ttimestamp_t timestamp)\n{\n\tstruct object *obj;\n\n\tif (!is_null_oid(oid)) {\n\t\tobj = lookup_object(the_repository, oid);\n\t\tif (obj && (obj->flags & HAS_OBJ)) {\n\t\t\tif (timestamp)\n\t\t\t\tfsck_put_object_name(&fsck_walk_options, oid,\n\t\t\t\t\t\t     \"%s@{%\"PRItime\"}\",\n\t\t\t\t\t\t     refname, timestamp);\n\t\t\tobj->flags |= USED;\n\t\t\tmark_object_reachable(obj);\n\t\t} else if (!is_promisor_object(the_repository, oid)) {\n\t\t\terror(_(\"%s: invalid reflog entry %s\"),\n\t\t\t      refname, oid_to_hex(oid));\n\t\t\terrors_found |= ERROR_REACHABLE;\n\t\t}\n\t}\n}\n\nstatic int fsck_handle_reflog_ent(struct object_id *ooid, struct object_id *noid,\n\t\t\t\t  const char *email UNUSED,\n\t\t\t\t  timestamp_t timestamp, int tz UNUSED,\n\t\t\t\t  const char *message UNUSED, void *cb_data)\n{\n\tconst char *refname = cb_data;\n\n\tif (verbose)\n\t\tfprintf_ln(stderr, _(\"Checking reflog %s->%s\"),\n\t\t\t   oid_to_hex(ooid), oid_to_hex(noid));\n\n\tfsck_handle_reflog_oid(refname, ooid, 0);\n\tfsck_handle_reflog_oid(refname, noid, timestamp);\n\treturn 0;\n}\n\nstatic int fsck_handle_reflog(const char *logname, void *cb_data)\n{\n\tstruct strbuf refname = STRBUF_INIT;\n\n\tstrbuf_worktree_ref(cb_data, &refname, logname);\n\trefs_for_each_reflog_ent(get_main_ref_store(the_repository),\n\t\t\t\t refname.buf, fsck_handle_reflog_ent,\n\t\t\t\t refname.buf);\n\tstrbuf_release(&refname);\n\treturn 0;\n}\n\nstatic int fsck_handle_ref(const char *refname, const char *referent UNUSED, const struct object_id *oid,\n\t\t\t   int flag UNUSED, void *cb_data UNUSED)\n{\n\tstruct object *obj;\n\n\tobj = parse_object(the_repository, oid);\n\tif (!obj) {\n\t\tif (is_promisor_object(the_repository, oid)) {\n\t\t\t/*\n\t\t\t * Increment default_refs anyway, because this is a\n\t\t\t * valid ref.\n\t\t\t */\n\t\t\t default_refs++;\n\t\t\t return 0;\n\t\t}\n\t\terror(_(\"%s: invalid sha1 pointer %s\"),\n\t\t      refname, oid_to_hex(oid));\n\t\terrors_found |= ERROR_REACHABLE;\n\t\t/* We'll continue with the rest despite the error.. */\n\t\treturn 0;\n\t}\n\tif (obj->type != OBJ_COMMIT && is_branch(refname)) {\n\t\terror(_(\"%s: not a commit\"), refname);\n\t\terrors_found |= ERROR_REFS;\n\t}\n\tdefault_refs++;\n\tobj->flags |= USED;\n\tfsck_put_object_name(&fsck_walk_options,\n\t\t\t     oid, \"%s\", refname);\n\tmark_object_reachable(obj);\n\n\treturn 0;\n}\n\nstatic int fsck_head_link(const char *head_ref_name,\n\t\t\t  const char **head_points_at,\n\t\t\t  struct object_id *head_oid);\n\nstatic void get_default_heads(void)\n{\n\tstruct worktree **worktrees, **p;\n\tconst char *head_points_at;\n\tstruct object_id head_oid;\n\n\trefs_for_each_rawref(get_main_ref_store(the_repository),\n\t\t\t     fsck_handle_ref, NULL);\n\n\tworktrees = get_worktrees();\n\tfor (p = worktrees; *p; p++) {\n\t\tstruct worktree *wt = *p;\n\t\tstruct strbuf ref = STRBUF_INIT;\n\n\t\tstrbuf_worktree_ref(wt, &ref, \"HEAD\");\n\t\tfsck_head_link(ref.buf, &head_points_at, &head_oid);\n\t\tif (head_points_at && !is_null_oid(&head_oid))\n\t\t\tfsck_handle_ref(ref.buf, NULL, &head_oid, 0, NULL);\n\t\tstrbuf_release(&ref);\n\n\t\tif (include_reflogs)\n\t\t\trefs_for_each_reflog(get_worktree_ref_store(wt),\n\t\t\t\t\t     fsck_handle_reflog, wt);\n\t}\n\tfree_worktrees(worktrees);\n\n\t/*\n\t * Not having any default heads isn't really fatal, but\n\t * it does mean that \"--unreachable\" no longer makes any\n\t * sense (since in this case everything will obviously\n\t * be unreachable by definition.\n\t *\n\t * Showing dangling objects is valid, though (as those\n\t * dangling objects are likely lost heads).\n\t *\n\t * So we just print a warning about it, and clear the\n\t * \"show_unreachable\" flag.\n\t */\n\tif (!default_refs) {\n\t\tfprintf_ln(stderr, _(\"notice: No default references\"));\n\t\tshow_unreachable = 0;\n\t}\n}\n\nstruct for_each_loose_cb\n{\n\tstruct progress *progress;\n};\n\nstatic int fsck_loose(const struct object_id *oid, const char *path,\n\t\t      void *data UNUSED)\n{\n\tstruct object *obj;\n\tenum object_type type = OBJ_NONE;\n\tunsigned long size;\n\tvoid *contents = NULL;\n\tint eaten;\n\tstruct object_info oi = OBJECT_INFO_INIT;\n\tstruct object_id real_oid = *null_oid(the_hash_algo);\n\tint err = 0;\n\n\toi.sizep = &size;\n\toi.typep = &type;\n\n\tif (read_loose_object(path, oid, &real_oid, &contents, &oi) < 0) {\n\t\tif (contents && !oideq(&real_oid, oid))\n\t\t\terr = error(_(\"%s: hash-path mismatch, found at: %s\"),\n\t\t\t\t    oid_to_hex(&real_oid), path);\n\t\telse\n\t\t\terr = error(_(\"%s: object corrupt or missing: %s\"),\n\t\t\t\t    oid_to_hex(oid), path);\n\t}\n\tif (err < 0) {\n\t\terrors_found |= ERROR_OBJECT;\n\t\tfree(contents);\n\t\treturn 0; /* keep checking other objects */\n\t}\n\n\tif (!contents && type != OBJ_BLOB)\n\t\tBUG(\"read_loose_object streamed a non-blob\");\n\n\tobj = parse_object_buffer(the_repository, oid, type, size,\n\t\t\t\t  contents, &eaten);\n\n\tif (!obj) {\n\t\terrors_found |= ERROR_OBJECT;\n\t\terror(_(\"%s: object could not be parsed: %s\"),\n\t\t      oid_to_hex(oid), path);\n\t\tif (!eaten)\n\t\t\tfree(contents);\n\t\treturn 0; /* keep checking other objects */\n\t}\n\n\tobj->flags &= ~(REACHABLE | SEEN);\n\tobj->flags |= HAS_OBJ;\n\tif (fsck_obj(obj, contents, size))\n\t\terrors_found |= ERROR_OBJECT;\n\n\tif (!eaten)\n\t\tfree(contents);\n\treturn 0; /* keep checking other objects, even if we saw an error */\n}\n\nstatic int fsck_cruft(const char *basename, const char *path,\n\t\t      void *data UNUSED)\n{\n\tif (!starts_with(basename, \"tmp_obj_\"))\n\t\tfprintf_ln(stderr, _(\"bad sha1 file: %s\"), path);\n\treturn 0;\n}\n\nstatic int fsck_subdir(unsigned int nr, const char *path UNUSED, void *data)\n{\n\tstruct for_each_loose_cb *cb_data = data;\n\tstruct progress *progress = cb_data->progress;\n\tdisplay_progress(progress, nr + 1);\n\treturn 0;\n}\n\nstatic void fsck_object_dir(const char *path)\n{\n\tstruct progress *progress = NULL;\n\tstruct for_each_loose_cb cb_data = {\n\t\t.progress = progress,\n\t};\n\n\tif (verbose)\n\t\tfprintf_ln(stderr, _(\"Checking object directory\"));\n\n\tif (show_progress)\n\t\tprogress = start_progress(the_repository,\n\t\t\t\t\t  _(\"Checking object directories\"), 256);\n\n\tfor_each_loose_file_in_objdir(path, fsck_loose, fsck_cruft, fsck_subdir,\n\t\t\t\t      &cb_data);\n\tdisplay_progress(progress, 256);\n\tstop_progress(&progress);\n}\n\nstatic int fsck_head_link(const char *head_ref_name,\n\t\t\t  const char **head_points_at,\n\t\t\t  struct object_id *head_oid)\n{\n\tint null_is_error = 0;\n\n\tif (verbose)\n\t\tfprintf_ln(stderr, _(\"Checking %s link\"), head_ref_name);\n\n\t*head_points_at = refs_resolve_ref_unsafe(get_main_ref_store(the_repository),\n\t\t\t\t\t\t  head_ref_name, 0, head_oid,\n\t\t\t\t\t\t  NULL);\n\tif (!*head_points_at) {\n\t\terrors_found |= ERROR_REFS;\n\t\treturn error(_(\"invalid %s\"), head_ref_name);\n\t}\n\tif (!strcmp(*head_points_at, head_ref_name))\n\t\t/* detached HEAD */\n\t\tnull_is_error = 1;\n\telse if (!starts_with(*head_points_at, \"refs/heads/\")) {\n\t\terrors_found |= ERROR_REFS;\n\t\treturn error(_(\"%s points to something strange (%s)\"),\n\t\t\t     head_ref_name, *head_points_at);\n\t}\n\tif (is_null_oid(head_oid)) {\n\t\tif (null_is_error) {\n\t\t\terrors_found |= ERROR_REFS;\n\t\t\treturn error(_(\"%s: detached HEAD points at nothing\"),\n\t\t\t\t     head_ref_name);\n\t\t}\n\t\tfprintf_ln(stderr,\n\t\t\t   _(\"notice: %s points to an unborn branch (%s)\"),\n\t\t\t   head_ref_name, *head_points_at + 11);\n\t}\n\treturn 0;\n}\n\nstatic int fsck_cache_tree(struct cache_tree *it, const char *index_path)\n{\n\tint i;\n\tint err = 0;\n\n\tif (verbose)\n\t\tfprintf_ln(stderr, _(\"Checking cache tree of %s\"), index_path);\n\n\tif (0 <= it->entry_count) {\n\t\tstruct object *obj = parse_object(the_repository, &it->oid);\n\t\tif (!obj) {\n\t\t\terror(_(\"%s: invalid sha1 pointer in cache-tree of %s\"),\n\t\t\t      oid_to_hex(&it->oid), index_path);\n\t\t\terrors_found |= ERROR_REFS;\n\t\t\treturn 1;\n\t\t}\n\t\tobj->flags |= USED;\n\t\tfsck_put_object_name(&fsck_walk_options, &it->oid, \":\");\n\t\tmark_object_reachable(obj);\n\t\tif (obj->type != OBJ_TREE)\n\t\t\terr |= objerror(obj, _(\"non-tree in cache-tree\"));\n\t}\n\tfor (i = 0; i < it->subtree_nr; i++)\n\t\terr |= fsck_cache_tree(it->down[i]->cache_tree, index_path);\n\treturn err;\n}\n\nstatic int fsck_resolve_undo(struct index_state *istate,\n\t\t\t     const char *index_path)\n{\n\tstruct string_list_item *item;\n\tstruct string_list *resolve_undo = istate->resolve_undo;\n\n\tif (!resolve_undo)\n\t\treturn 0;\n\n\tfor_each_string_list_item(item, resolve_undo) {\n\t\tconst char *path = item->string;\n\t\tstruct resolve_undo_info *ru = item->util;\n\t\tint i;\n\n\t\tif (!ru)\n\t\t\tcontinue;\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tstruct object *obj;\n\n\t\t\tif (!ru->mode[i] || !S_ISREG(ru->mode[i]))\n\t\t\t\tcontinue;\n\n\t\t\tobj = parse_object(the_repository, &ru->oid[i]);\n\t\t\tif (!obj) {\n\t\t\t\terror(_(\"%s: invalid sha1 pointer in resolve-undo of %s\"),\n\t\t\t\t      oid_to_hex(&ru->oid[i]),\n\t\t\t\t      index_path);\n\t\t\t\terrors_found |= ERROR_REFS;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tobj->flags |= USED;\n\t\t\tfsck_put_object_name(&fsck_walk_options, &ru->oid[i],\n\t\t\t\t\t     \":(%d):%s\", i, path);\n\t\t\tmark_object_reachable(obj);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void fsck_index(struct index_state *istate, const char *index_path,\n\t\t       int is_current_worktree)\n{\n\tunsigned int i;\n\n\t/* TODO: audit for interaction with sparse-index. */\n\tensure_full_index(istate);\n\tfor (i = 0; i < istate->cache_nr; i++) {\n\t\tunsigned int mode;\n\t\tstruct blob *blob;\n\t\tstruct object *obj;\n\n\t\tmode = istate->cache[i]->ce_mode;\n\t\tif (S_ISGITLINK(mode))\n\t\t\tcontinue;\n\t\tblob = lookup_blob(the_repository,\n\t\t\t\t   &istate->cache[i]->oid);\n\t\tif (!blob)\n\t\t\tcontinue;\n\t\tobj = &blob->object;\n\t\tobj->flags |= USED;\n\t\tfsck_put_object_name(&fsck_walk_options, &obj->oid,\n\t\t\t\t     \"%s:%s\",\n\t\t\t\t     is_current_worktree ? \"\" : index_path,\n\t\t\t\t     istate->cache[i]->name);\n\t\tmark_object_reachable(obj);\n\t}\n\tif (istate->cache_tree)\n\t\tfsck_cache_tree(istate->cache_tree, index_path);\n\tfsck_resolve_undo(istate, index_path);\n}\n\nstatic void mark_object_for_connectivity(const struct object_id *oid)\n{\n\tstruct object *obj = lookup_unknown_object(the_repository, oid);\n\tobj->flags |= HAS_OBJ;\n}\n\nstatic int mark_loose_for_connectivity(const struct object_id *oid,\n\t\t\t\t       const char *path UNUSED,\n\t\t\t\t       void *data UNUSED)\n{\n\tmark_object_for_connectivity(oid);\n\treturn 0;\n}\n\nstatic int mark_packed_for_connectivity(const struct object_id *oid,\n\t\t\t\t\tstruct packed_git *pack UNUSED,\n\t\t\t\t\tuint32_t pos UNUSED,\n\t\t\t\t\tvoid *data UNUSED)\n{\n\tmark_object_for_connectivity(oid);\n\treturn 0;\n}\n\nstatic int check_pack_rev_indexes(struct repository *r, int show_progress)\n{\n\tstruct progress *progress = NULL;\n\tuint32_t pack_count = 0;\n\tint res = 0;\n\n\tif (show_progress) {\n\t\tfor (struct packed_git *p = get_all_packs(r); p; p = p->next)\n\t\t\tpack_count++;\n\t\tprogress = start_delayed_progress(the_repository,\n\t\t\t\t\t\t  \"Verifying reverse pack-indexes\", pack_count);\n\t\tpack_count = 0;\n\t}\n\n\tfor (struct packed_git *p = get_all_packs(r); p; p = p->next) {\n\t\tint load_error = load_pack_revindex_from_disk(p);\n\n\t\tif (load_error < 0) {\n\t\t\terror(_(\"unable to load rev-index for pack '%s'\"), p->pack_name);\n\t\t\tres = ERROR_PACK_REV_INDEX;\n\t\t} else if (!load_error &&\n\t\t\t   !load_pack_revindex(r, p) &&\n\t\t\t   verify_pack_revindex(p)) {\n\t\t\terror(_(\"invalid rev-index for pack '%s'\"), p->pack_name);\n\t\t\tres = ERROR_PACK_REV_INDEX;\n\t\t}\n\t\tdisplay_progress(progress, ++pack_count);\n\t}\n\tstop_progress(&progress);\n\n\treturn res;\n}\n\nstatic void fsck_refs(struct repository *r)\n{\n\tstruct child_process refs_verify = CHILD_PROCESS_INIT;\n\tstruct progress *progress = NULL;\n\n\tif (show_progress)\n\t\tprogress = start_progress(r, _(\"Checking ref database\"), 1);\n\n\tif (verbose)\n\t\tfprintf_ln(stderr, _(\"Checking ref database\"));\n\n\tchild_process_init(&refs_verify);\n\trefs_verify.git_cmd = 1;\n\tstrvec_pushl(&refs_verify.args, \"refs\", \"verify\", NULL);\n\tif (verbose)\n\t\tstrvec_push(&refs_verify.args, \"--verbose\");\n\tif (check_strict)\n\t\tstrvec_push(&refs_verify.args, \"--strict\");\n\n\tif (run_command(&refs_verify))\n\t\terrors_found |= ERROR_REFS;\n\n\tdisplay_progress(progress, 1);\n\tstop_progress(&progress);\n}\n\nstatic char const * const fsck_usage[] = {\n\tN_(\"git fsck [--tags] [--root] [--unreachable] [--cache] [--no-reflogs]\\n\"\n\t   \"         [--[no-]full] [--strict] [--verbose] [--lost-found]\\n\"\n\t   \"         [--[no-]dangling] [--[no-]progress] [--connectivity-only]\\n\"\n\t   \"         [--[no-]name-objects] [--[no-]references] [<object>...]\"),\n\tNULL\n};\n\nstatic struct option fsck_opts[] = {\n\tOPT__VERBOSE(&verbose, N_(\"be verbose\")),\n\tOPT_BOOL(0, \"unreachable\", &show_unreachable, N_(\"show unreachable objects\")),\n\tOPT_BOOL(0, \"dangling\", &show_dangling, N_(\"show dangling objects\")),\n\tOPT_BOOL(0, \"tags\", &show_tags, N_(\"report tags\")),\n\tOPT_BOOL(0, \"root\", &show_root, N_(\"report root nodes\")),\n\tOPT_BOOL(0, \"cache\", &keep_cache_objects, N_(\"make index objects head nodes\")),\n\tOPT_BOOL(0, \"reflogs\", &include_reflogs, N_(\"make reflogs head nodes (default)\")),\n\tOPT_BOOL(0, \"full\", &check_full, N_(\"also consider packs and alternate objects\")),\n\tOPT_BOOL(0, \"connectivity-only\", &connectivity_only, N_(\"check only connectivity\")),\n\tOPT_BOOL(0, \"strict\", &check_strict, N_(\"enable more strict checking\")),\n\tOPT_BOOL(0, \"lost-found\", &write_lost_and_found,\n\t\t\t\tN_(\"write dangling objects in .git/lost-found\")),\n\tOPT_BOOL(0, \"progress\", &show_progress, N_(\"show progress\")),\n\tOPT_BOOL(0, \"name-objects\", &name_objects, N_(\"show verbose names for reachable objects\")),\n\tOPT_BOOL(0, \"references\", &check_references, N_(\"check reference database consistency\")),\n\tOPT_END(),\n};\n\nint cmd_fsck(int argc,\n\t     const char **argv,\n\t     const char *prefix,\n\t     struct repository *repo UNUSED)\n{\n\tint i;\n\tstruct odb_source *source;\n\n\t/* fsck knows how to handle missing promisor objects */\n\tfetch_if_missing = 0;\n\n\terrors_found = 0;\n\tdisable_replace_refs();\n\tsave_commit_buffer = 0;\n\n\targc = parse_options(argc, argv, prefix, fsck_opts, fsck_usage, 0);\n\n\tfsck_walk_options.walk = mark_object;\n\tfsck_obj_options.walk = mark_used;\n\tfsck_obj_options.error_func = fsck_objects_error_func;\n\tif (check_strict)\n\t\tfsck_obj_options.strict = 1;\n\n\tif (show_progress == -1)\n\t\tshow_progress = isatty(2);\n\tif (verbose)\n\t\tshow_progress = 0;\n\n\tif (write_lost_and_found) {\n\t\tcheck_full = 1;\n\t\tinclude_reflogs = 0;\n\t}\n\n\tif (name_objects)\n\t\tfsck_enable_object_names(&fsck_walk_options);\n\n\tgit_config(git_fsck_config, &fsck_obj_options);\n\tprepare_repo_settings(the_repository);\n\n\tif (check_references)\n\t\tfsck_refs(the_repository);\n\n\tif (connectivity_only) {\n\t\tfor_each_loose_object(mark_loose_for_connectivity, NULL, 0);\n\t\tfor_each_packed_object(the_repository,\n\t\t\t\t       mark_packed_for_connectivity, NULL, 0);\n\t} else {\n\t\todb_prepare_alternates(the_repository->objects);\n\t\tfor (source = the_repository->objects->sources; source; source = source->next)\n\t\t\tfsck_object_dir(source->path);\n\n\t\tif (check_full) {\n\t\t\tstruct packed_git *p;\n\t\t\tuint32_t total = 0, count = 0;\n\t\t\tstruct progress *progress = NULL;\n\n\t\t\tif (show_progress) {\n\t\t\t\tfor (p = get_all_packs(the_repository); p;\n\t\t\t\t     p = p->next) {\n\t\t\t\t\tif (open_pack_index(p))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\ttotal += p->num_objects;\n\t\t\t\t}\n\n\t\t\t\tprogress = start_progress(the_repository,\n\t\t\t\t\t\t\t  _(\"Checking objects\"), total);\n\t\t\t}\n\t\t\tfor (p = get_all_packs(the_repository); p;\n\t\t\t     p = p->next) {\n\t\t\t\t/* verify gives error messages itself */\n\t\t\t\tif (verify_pack(the_repository,\n\t\t\t\t\t\tp, fsck_obj_buffer,\n\t\t\t\t\t\tprogress, count))\n\t\t\t\t\terrors_found |= ERROR_PACK;\n\t\t\t\tcount += p->num_objects;\n\t\t\t}\n\t\t\tstop_progress(&progress);\n\t\t}\n\n\t\tif (fsck_finish(&fsck_obj_options))\n\t\t\terrors_found |= ERROR_OBJECT;\n\t}\n\n\tfor (i = 0; i < argc; i++) {\n\t\tconst char *arg = argv[i];\n\t\tstruct object_id oid;\n\t\tif (!repo_get_oid(the_repository, arg, &oid)) {\n\t\t\tstruct object *obj = lookup_object(the_repository,\n\t\t\t\t\t\t\t   &oid);\n\n\t\t\tif (!obj || !(obj->flags & HAS_OBJ)) {\n\t\t\t\tif (is_promisor_object(the_repository, &oid))\n\t\t\t\t\tcontinue;\n\t\t\t\terror(_(\"%s: object missing\"), oid_to_hex(&oid));\n\t\t\t\terrors_found |= ERROR_OBJECT;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tobj->flags |= USED;\n\t\t\tfsck_put_object_name(&fsck_walk_options, &oid,\n\t\t\t\t\t     \"%s\", arg);\n\t\t\tmark_object_reachable(obj);\n\t\t\tcontinue;\n\t\t}\n\t\terror(_(\"invalid parameter: expected sha1, got '%s'\"), arg);\n\t\terrors_found |= ERROR_OBJECT;\n\t}\n\n\t/*\n\t * If we've not been given any explicit head information, do the\n\t * default ones from .git/refs. We also consider the index file\n\t * in this case (ie this implies --cache).\n\t */\n\tif (!argc) {\n\t\tget_default_heads();\n\t\tkeep_cache_objects = 1;\n\t}\n\n\tif (keep_cache_objects) {\n\t\tstruct worktree **worktrees, **p;\n\n\t\tverify_index_checksum = 1;\n\t\tverify_ce_order = 1;\n\n\t\tworktrees = get_worktrees();\n\t\tfor (p = worktrees; *p; p++) {\n\t\t\tstruct worktree *wt = *p;\n\t\t\tstruct index_state istate =\n\t\t\t\tINDEX_STATE_INIT(the_repository);\n\t\t\tchar *path, *wt_gitdir;\n\n\t\t\t/*\n\t\t\t * Make a copy since the buffer is reusable\n\t\t\t * and may get overwritten by other calls\n\t\t\t * while we're examining the index.\n\t\t\t */\n\t\t\tpath = xstrdup(worktree_git_path(the_repository, wt, \"index\"));\n\t\t\twt_gitdir = get_worktree_git_dir(wt);\n\n\t\t\tread_index_from(&istate, path, wt_gitdir);\n\t\t\tfsck_index(&istate, path, wt->is_current);\n\n\t\t\tdiscard_index(&istate);\n\t\t\tfree(wt_gitdir);\n\t\t\tfree(path);\n\t\t}\n\t\tfree_worktrees(worktrees);\n\t}\n\n\terrors_found |= check_pack_rev_indexes(the_repository, show_progress);\n\tif (verify_bitmap_files(the_repository))\n\t\terrors_found |= ERROR_BITMAP;\n\n\tcheck_connectivity();\n\n\tif (the_repository->settings.core_commit_graph) {\n\t\tstruct child_process commit_graph_verify = CHILD_PROCESS_INIT;\n\n\t\todb_prepare_alternates(the_repository->objects);\n\t\tfor (source = the_repository->objects->sources; source; source = source->next) {\n\t\t\tchild_process_init(&commit_graph_verify);\n\t\t\tcommit_graph_verify.git_cmd = 1;\n\t\t\tstrvec_pushl(&commit_graph_verify.args, \"commit-graph\",\n\t\t\t\t     \"verify\", \"--object-dir\", source->path, NULL);\n\t\t\tif (show_progress)\n\t\t\t\tstrvec_push(&commit_graph_verify.args, \"--progress\");\n\t\t\telse\n\t\t\t\tstrvec_push(&commit_graph_verify.args, \"--no-progress\");\n\t\t\tif (run_command(&commit_graph_verify))\n\t\t\t\terrors_found |= ERROR_COMMIT_GRAPH;\n\t\t}\n\t}\n\n\tif (the_repository->settings.core_multi_pack_index) {\n\t\tstruct child_process midx_verify = CHILD_PROCESS_INIT;\n\n\t\todb_prepare_alternates(the_repository->objects);\n\t\tfor (source = the_repository->objects->sources; source; source = source->next) {\n\t\t\tchild_process_init(&midx_verify);\n\t\t\tmidx_verify.git_cmd = 1;\n\t\t\tstrvec_pushl(&midx_verify.args, \"multi-pack-index\",\n\t\t\t\t     \"verify\", \"--object-dir\", source->path, NULL);\n\t\t\tif (show_progress)\n\t\t\t\tstrvec_push(&midx_verify.args, \"--progress\");\n\t\t\telse\n\t\t\t\tstrvec_push(&midx_verify.args, \"--no-progress\");\n\t\t\tif (run_command(&midx_verify))\n\t\t\t\terrors_found |= ERROR_MULTI_PACK_INDEX;\n\t\t}\n\t}\n\n\treturn errors_found;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "0084cf7400bd46ba7d8b72a908a67c3536abc907",
  "sha1_ok": true,
  "size": 31166
}
