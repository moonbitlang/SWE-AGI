{
  "content": {
    "base64": "I2luY2x1ZGUgImNhY2hlLmgiCgpzdHJ1Y3QgdHJlZV9lbnRyeSB7Cgl1bnNpZ25lZCBtb2RlOwoJdW5zaWduZWQgY2hhciAqc2hhMTsKCWNoYXIgKnBhdGg7CglzdHJ1Y3QgdHJlZV9lbnRyeSAqbmV4dDsKfTsKCnN0YXRpYyBzdHJ1Y3QgdHJlZV9lbnRyeSAqcmVhZF90cmVlKHVuc2lnbmVkIGNoYXIgKnNoYTEpCnsKCWNoYXIgdHlwZVsyMF07Cgl1bnNpZ25lZCBsb25nIHNpemU7Cgl2b2lkICpidWYgPSByZWFkX3NoYTFfZmlsZShzaGExLCB0eXBlLCAmc2l6ZSk7CglzdHJ1Y3QgdHJlZV9lbnRyeSAqcmV0ID0gTlVMTCwgKip0cCA9ICZyZXQ7CgoJaWYgKCFidWYgfHwgc3RyY21wKHR5cGUsICJ0cmVlIikpCgkJZGllKCJ1bmFibGUgdG8gcmVhZCAndHJlZScgb2JqZWN0ICVzIiwgc2hhMV90b19oZXgoc2hhMSkpOwoJd2hpbGUgKHNpemUpIHsKCQlpbnQgbGVuID0gc3RybGVuKGJ1ZikrMTsKCQlzdHJ1Y3QgdHJlZV9lbnRyeSAqIGVudHJ5ID0gbWFsbG9jKHNpemVvZihzdHJ1Y3QgdHJlZV9lbnRyeSkpOwoJCWlmIChzaXplIDwgbGVuICsgMjAgfHwgc3NjYW5mKGJ1ZiwgIiVvIiwgJmVudHJ5LT5tb2RlKSAhPSAxKQoJCQlkaWUoImNvcnJ1cHQgJ3RyZWUnIG9iamVjdCAlcyIsIHNoYTFfdG9faGV4KHNoYTEpKTsKCQllbnRyeS0+cGF0aCA9IHN0cmNocihidWYsICcgJykrMTsKCQllbnRyeS0+c2hhMSA9IGJ1ZiArIGxlbjsKCQllbnRyeS0+bmV4dCA9IE5VTEw7CgkJKnRwID0gZW50cnk7CgkJdHAgPSAmZW50cnktPm5leHQ7CgkJbGVuICs9IDIwOwoJCWJ1ZiArPSBsZW47CgkJc2l6ZSAtPSBsZW47Cgl9CglyZXR1cm4gcmV0Owp9CgpzdGF0aWMgdm9pZCBzaG93KGNvbnN0IHN0cnVjdCB0cmVlX2VudHJ5ICphLCBjb25zdCBjaGFyICpwYXRoKQp7CglwcmludGYoInNlbGVjdCAlbyAlcyAlcyVjIiwgYS0+bW9kZSwgc2hhMV90b19oZXgoYS0+c2hhMSksIHBhdGgsIDApOwp9CgpzdGF0aWMgdm9pZCBtZXJnZShjb25zdCBzdHJ1Y3QgdHJlZV9lbnRyeSAqYSwgY29uc3Qgc3RydWN0IHRyZWVfZW50cnkgKmIsIGNvbnN0IHN0cnVjdCB0cmVlX2VudHJ5ICpjLCBjb25zdCBjaGFyICpwYXRoKQp7CgljaGFyIGhleF9hWzYwXSwgaGV4X2JbNjBdLCBoZXhfY1s2MF07CglzdHJjcHkoaGV4X2EsIHNoYTFfdG9faGV4KGEtPnNoYTEpKTsKCXN0cmNweShoZXhfYiwgc2hhMV90b19oZXgoYi0+c2hhMSkpOwoJc3RyY3B5KGhleF9jLCBzaGExX3RvX2hleChjLT5zaGExKSk7CglwcmludGYoIm1lcmdlICVvLT4lbywlbyAlcy0+JXMsJXMgJXMlYyIsCgkJYS0+bW9kZSwgYi0+bW9kZSwgYy0+bW9kZSwKCQloZXhfYSwgaGV4X2IsIGhleF9jLCBwYXRoLCAwKTsKfQoKc3RhdGljIGludCBzYW1lKGNvbnN0IHN0cnVjdCB0cmVlX2VudHJ5ICphLCBjb25zdCBzdHJ1Y3QgdHJlZV9lbnRyeSAqYikKewoJcmV0dXJuIGEtPm1vZGUgPT0gYi0+bW9kZSAmJiAhbWVtY21wKGEtPnNoYTEsIGItPnNoYTEsIDIwKTsKfQoKc3RhdGljIHZvaWQgbWVyZ2VfZW50cnkoY29uc3Qgc3RydWN0IHRyZWVfZW50cnkgKnNyYywgY29uc3Qgc3RydWN0IHRyZWVfZW50cnkgKmRzdDEsIGNvbnN0IHN0cnVjdCB0cmVlX2VudHJ5ICpkc3QyKQp7CglzdGF0aWMgdW5zaWduZWQgY2hhciBudWxsc2hhMVsyMF07CglzdGF0aWMgY29uc3Qgc3RydWN0IHRyZWVfZW50cnkgbm9uZSA9IHsgMCwgbnVsbHNoYTEsICIiLCBOVUxMIH07Cgljb25zdCBjaGFyICpwYXRoID0gTlVMTDsKCWNvbnN0IHN0cnVjdCB0cmVlX2VudHJ5ICphLCAqYiwgKmM7CgoJYSA9ICZub25lOwoJYiA9ICZub25lOwoJYyA9ICZub25lOwoJaWYgKHNyYykgeyBhID0gc3JjOyBwYXRoID0gc3JjLT5wYXRoOyB9CglpZiAoZHN0MSkgeyBiID0gZHN0MTsgcGF0aCA9IGRzdDEtPnBhdGg7IH0KCWlmIChkc3QyKSB7IGMgPSBkc3QyOyBwYXRoID0gZHN0Mi0+cGF0aDsgfQoJaWYgKHNhbWUoYiwgYykpIHsKCQlzaG93KGIsIHBhdGgpOwoJCXJldHVybjsKCX0KCWlmIChzYW1lKGEsIGIpKSB7CgkJc2hvdyhjLCBwYXRoKTsKCQlyZXR1cm47Cgl9CglpZiAoc2FtZShhLCBjKSkgewoJCXNob3coYiwgcGF0aCk7CgkJcmV0dXJuOwoJfQoJbWVyZ2UoYSwgYiwgYywgcGF0aCk7Cn0KCi8qIEZvciB0d28gZW50cmllcywgc2VsZWN0IHRoZSBzbWFsbGVyIG9uZSwgY2xlYXIgdGhlIGJpZ2dlciBvbmUgKi8Kc3RhdGljIHZvaWQgc21hbGxlcihzdHJ1Y3QgdHJlZV9lbnRyeSAqKmFwLCBzdHJ1Y3QgdHJlZV9lbnRyeSAqKmJwKQp7CglzdHJ1Y3QgdHJlZV9lbnRyeSAqYSA9ICphcCwgKmIgPSAqYnA7CglpZiAoYSAmJiBiKSB7CgkJaW50IGNtcCA9IGNhY2hlX25hbWVfY29tcGFyZShhLT5wYXRoLCBzdHJsZW4oYS0+cGF0aCksIGItPnBhdGgsIHN0cmxlbihiLT5wYXRoKSk7CgkJaWYgKGNtcCkgewoJCQlpZiAoY21wIDwgMCkKCQkJCSpicCA9IE5VTEw7CgkJCWVsc2UKCQkJCSphcCA9IE5VTEw7CgkJfQoJfQp9CgpzdGF0aWMgdm9pZCBtZXJnZV90cmVlKHN0cnVjdCB0cmVlX2VudHJ5ICpzcmMsIHN0cnVjdCB0cmVlX2VudHJ5ICpkc3QxLCBzdHJ1Y3QgdHJlZV9lbnRyeSAqZHN0MikKewoJd2hpbGUgKHNyYyB8fCBkc3QxIHx8IGRzdDIpIHsKCQlzdHJ1Y3QgdHJlZV9lbnRyeSAqYSwgKmIsICpjOwoJCWEgPSBzcmM7CgkJYiA9IGRzdDE7CgkJYyA9IGRzdDI7CgkJc21hbGxlcigmYSwmYik7CgkJc21hbGxlcigmYSwmYyk7CgkJc21hbGxlcigmYiwmYyk7CgkJaWYgKGEpIHNyYyA9IGEtPm5leHQ7CgkJaWYgKGIpIGRzdDEgPSBiLT5uZXh0OwoJCWlmIChjKSBkc3QyID0gYy0+bmV4dDsKCQltZXJnZV9lbnRyeShhLGIsYyk7Cgl9Cn0KCmludCBtYWluKGludCBhcmdjLCBjaGFyICoqYXJndikKewoJdW5zaWduZWQgY2hhciBzcmNbMjBdLCBkc3QxWzIwXSwgZHN0MlsyMF07CgoJaWYgKGFyZ2MgIT0gNCB8fAoJICAgIGdldF9zaGExX2hleChhcmd2WzFdLCBzcmMpIHx8CgkgICAgZ2V0X3NoYTFfaGV4KGFyZ3ZbMl0sIGRzdDEpIHx8CgkgICAgZ2V0X3NoYTFfaGV4KGFyZ3ZbM10sIGRzdDIpKQoJCXVzYWdlKCJtZXJnZS10cmVlIDxzcmM+IDxkc3QxPiA8ZHN0Mj4iKTsKCW1lcmdlX3RyZWUocmVhZF90cmVlKHNyYyksIHJlYWRfdHJlZShkc3QxKSwgcmVhZF90cmVlKGRzdDIpKTsKCXJldHVybiAwOwp9Cg==",
    "text": "#include \"cache.h\"\n\nstruct tree_entry {\n\tunsigned mode;\n\tunsigned char *sha1;\n\tchar *path;\n\tstruct tree_entry *next;\n};\n\nstatic struct tree_entry *read_tree(unsigned char *sha1)\n{\n\tchar type[20];\n\tunsigned long size;\n\tvoid *buf = read_sha1_file(sha1, type, &size);\n\tstruct tree_entry *ret = NULL, **tp = &ret;\n\n\tif (!buf || strcmp(type, \"tree\"))\n\t\tdie(\"unable to read 'tree' object %s\", sha1_to_hex(sha1));\n\twhile (size) {\n\t\tint len = strlen(buf)+1;\n\t\tstruct tree_entry * entry = malloc(sizeof(struct tree_entry));\n\t\tif (size < len + 20 || sscanf(buf, \"%o\", &entry->mode) != 1)\n\t\t\tdie(\"corrupt 'tree' object %s\", sha1_to_hex(sha1));\n\t\tentry->path = strchr(buf, ' ')+1;\n\t\tentry->sha1 = buf + len;\n\t\tentry->next = NULL;\n\t\t*tp = entry;\n\t\ttp = &entry->next;\n\t\tlen += 20;\n\t\tbuf += len;\n\t\tsize -= len;\n\t}\n\treturn ret;\n}\n\nstatic void show(const struct tree_entry *a, const char *path)\n{\n\tprintf(\"select %o %s %s%c\", a->mode, sha1_to_hex(a->sha1), path, 0);\n}\n\nstatic void merge(const struct tree_entry *a, const struct tree_entry *b, const struct tree_entry *c, const char *path)\n{\n\tchar hex_a[60], hex_b[60], hex_c[60];\n\tstrcpy(hex_a, sha1_to_hex(a->sha1));\n\tstrcpy(hex_b, sha1_to_hex(b->sha1));\n\tstrcpy(hex_c, sha1_to_hex(c->sha1));\n\tprintf(\"merge %o->%o,%o %s->%s,%s %s%c\",\n\t\ta->mode, b->mode, c->mode,\n\t\thex_a, hex_b, hex_c, path, 0);\n}\n\nstatic int same(const struct tree_entry *a, const struct tree_entry *b)\n{\n\treturn a->mode == b->mode && !memcmp(a->sha1, b->sha1, 20);\n}\n\nstatic void merge_entry(const struct tree_entry *src, const struct tree_entry *dst1, const struct tree_entry *dst2)\n{\n\tstatic unsigned char nullsha1[20];\n\tstatic const struct tree_entry none = { 0, nullsha1, \"\", NULL };\n\tconst char *path = NULL;\n\tconst struct tree_entry *a, *b, *c;\n\n\ta = &none;\n\tb = &none;\n\tc = &none;\n\tif (src) { a = src; path = src->path; }\n\tif (dst1) { b = dst1; path = dst1->path; }\n\tif (dst2) { c = dst2; path = dst2->path; }\n\tif (same(b, c)) {\n\t\tshow(b, path);\n\t\treturn;\n\t}\n\tif (same(a, b)) {\n\t\tshow(c, path);\n\t\treturn;\n\t}\n\tif (same(a, c)) {\n\t\tshow(b, path);\n\t\treturn;\n\t}\n\tmerge(a, b, c, path);\n}\n\n/* For two entries, select the smaller one, clear the bigger one */\nstatic void smaller(struct tree_entry **ap, struct tree_entry **bp)\n{\n\tstruct tree_entry *a = *ap, *b = *bp;\n\tif (a && b) {\n\t\tint cmp = cache_name_compare(a->path, strlen(a->path), b->path, strlen(b->path));\n\t\tif (cmp) {\n\t\t\tif (cmp < 0)\n\t\t\t\t*bp = NULL;\n\t\t\telse\n\t\t\t\t*ap = NULL;\n\t\t}\n\t}\n}\n\nstatic void merge_tree(struct tree_entry *src, struct tree_entry *dst1, struct tree_entry *dst2)\n{\n\twhile (src || dst1 || dst2) {\n\t\tstruct tree_entry *a, *b, *c;\n\t\ta = src;\n\t\tb = dst1;\n\t\tc = dst2;\n\t\tsmaller(&a,&b);\n\t\tsmaller(&a,&c);\n\t\tsmaller(&b,&c);\n\t\tif (a) src = a->next;\n\t\tif (b) dst1 = b->next;\n\t\tif (c) dst2 = c->next;\n\t\tmerge_entry(a,b,c);\n\t}\n}\n\nint main(int argc, char **argv)\n{\n\tunsigned char src[20], dst1[20], dst2[20];\n\n\tif (argc != 4 ||\n\t    get_sha1_hex(argv[1], src) ||\n\t    get_sha1_hex(argv[2], dst1) ||\n\t    get_sha1_hex(argv[3], dst2))\n\t\tusage(\"merge-tree <src> <dst1> <dst2>\");\n\tmerge_tree(read_tree(src), read_tree(dst1), read_tree(dst2));\n\treturn 0;\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "00ae4e8d3208e09f2cf7a38202a126f728cadb48",
  "sha1_ok": true,
  "size": 3124
}
