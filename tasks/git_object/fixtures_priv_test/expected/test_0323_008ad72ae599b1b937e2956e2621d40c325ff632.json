{
  "content": {
    "base64": "I2luY2x1ZGUgImh0dHAuaCIKI2luY2x1ZGUgInBhY2suaCIKI2luY2x1ZGUgInNpZGViYW5kLmgiCiNpbmNsdWRlICJydW4tY29tbWFuZC5oIgojaW5jbHVkZSAidXJsLmgiCgppbnQgZGF0YV9yZWNlaXZlZDsKaW50IGFjdGl2ZV9yZXF1ZXN0czsKaW50IGh0dHBfaXNfdmVyYm9zZTsKc2l6ZV90IGh0dHBfcG9zdF9idWZmZXIgPSAxNiAqIExBUkdFX1BBQ0tFVF9NQVg7CgojaWYgTElCQ1VSTF9WRVJTSU9OX05VTSA+PSAweDA3MGEwNgojZGVmaW5lIExJQkNVUkxfQ0FOX0hBTkRMRV9BVVRIX0FOWQojZW5kaWYKCnN0YXRpYyBpbnQgbWluX2N1cmxfc2Vzc2lvbnMgPSAxOwpzdGF0aWMgaW50IGN1cmxfc2Vzc2lvbl9jb3VudDsKI2lmZGVmIFVTRV9DVVJMX01VTFRJCnN0YXRpYyBpbnQgbWF4X3JlcXVlc3RzID0gLTE7CnN0YXRpYyBDVVJMTSAqY3VybG07CiNlbmRpZgojaWZuZGVmIE5PX0NVUkxfRUFTWV9EVVBIQU5ETEUKc3RhdGljIENVUkwgKmN1cmxfZGVmYXVsdDsKI2VuZGlmCgojZGVmaW5lIFBSRVZfQlVGX1NJWkUgNDA5NgojZGVmaW5lIFJBTkdFX0hFQURFUl9TSVpFIDMwCgpjaGFyIGN1cmxfZXJyb3JzdHJbQ1VSTF9FUlJPUl9TSVpFXTsKCnN0YXRpYyBpbnQgY3VybF9zc2xfdmVyaWZ5ID0gLTE7CnN0YXRpYyBjb25zdCBjaGFyICpzc2xfY2VydDsKI2lmIExJQkNVUkxfVkVSU0lPTl9OVU0gPj0gMHgwNzA5MDMKc3RhdGljIGNvbnN0IGNoYXIgKnNzbF9rZXk7CiNlbmRpZgojaWYgTElCQ1VSTF9WRVJTSU9OX05VTSA+PSAweDA3MDkwOApzdGF0aWMgY29uc3QgY2hhciAqc3NsX2NhcGF0aDsKI2VuZGlmCnN0YXRpYyBjb25zdCBjaGFyICpzc2xfY2FpbmZvOwpzdGF0aWMgbG9uZyBjdXJsX2xvd19zcGVlZF9saW1pdCA9IC0xOwpzdGF0aWMgbG9uZyBjdXJsX2xvd19zcGVlZF90aW1lID0gLTE7CnN0YXRpYyBpbnQgY3VybF9mdHBfbm9fZXBzdjsKc3RhdGljIGNvbnN0IGNoYXIgKmN1cmxfaHR0cF9wcm94eTsKc3RhdGljIGNvbnN0IGNoYXIgKmN1cmxfY29va2llX2ZpbGU7CnN0YXRpYyBjaGFyICp1c2VyX25hbWUsICp1c2VyX3Bhc3MsICpkZXNjcmlwdGlvbjsKc3RhdGljIGNvbnN0IGNoYXIgKnVzZXJfYWdlbnQ7CgojaWYgTElCQ1VSTF9WRVJTSU9OX05VTSA+PSAweDA3MTcwMAovKiBVc2UgQ1VSTE9QVF9LRVlQQVNTV0QgYXMgaXMgKi8KI2VsaWYgTElCQ1VSTF9WRVJTSU9OX05VTSA+PSAweDA3MDkwMwojZGVmaW5lIENVUkxPUFRfS0VZUEFTU1dEIENVUkxPUFRfU1NMS0VZUEFTU1dECiNlbHNlCiNkZWZpbmUgQ1VSTE9QVF9LRVlQQVNTV0QgQ1VSTE9QVF9TU0xDRVJUUEFTU1dECiNlbmRpZgoKc3RhdGljIGNoYXIgKnNzbF9jZXJ0X3Bhc3N3b3JkOwpzdGF0aWMgaW50IHNzbF9jZXJ0X3Bhc3N3b3JkX3JlcXVpcmVkOwoKc3RhdGljIHN0cnVjdCBjdXJsX3NsaXN0ICpwcmFnbWFfaGVhZGVyOwpzdGF0aWMgc3RydWN0IGN1cmxfc2xpc3QgKm5vX3ByYWdtYV9oZWFkZXI7CgpzdGF0aWMgc3RydWN0IGFjdGl2ZV9yZXF1ZXN0X3Nsb3QgKmFjdGl2ZV9xdWV1ZV9oZWFkOwoKc2l6ZV90IGZyZWFkX2J1ZmZlcihjaGFyICpwdHIsIHNpemVfdCBlbHRzaXplLCBzaXplX3Qgbm1lbWIsIHZvaWQgKmJ1ZmZlcl8pCnsKCXNpemVfdCBzaXplID0gZWx0c2l6ZSAqIG5tZW1iOwoJc3RydWN0IGJ1ZmZlciAqYnVmZmVyID0gYnVmZmVyXzsKCglpZiAoc2l6ZSA+IGJ1ZmZlci0+YnVmLmxlbiAtIGJ1ZmZlci0+cG9zbikKCQlzaXplID0gYnVmZmVyLT5idWYubGVuIC0gYnVmZmVyLT5wb3NuOwoJbWVtY3B5KHB0ciwgYnVmZmVyLT5idWYuYnVmICsgYnVmZmVyLT5wb3NuLCBzaXplKTsKCWJ1ZmZlci0+cG9zbiArPSBzaXplOwoKCXJldHVybiBzaXplOwp9CgojaWZuZGVmIE5PX0NVUkxfSU9DVEwKY3VybGlvZXJyIGlvY3RsX2J1ZmZlcihDVVJMICpoYW5kbGUsIGludCBjbWQsIHZvaWQgKmNsaWVudHApCnsKCXN0cnVjdCBidWZmZXIgKmJ1ZmZlciA9IGNsaWVudHA7CgoJc3dpdGNoIChjbWQpIHsKCWNhc2UgQ1VSTElPQ01EX05PUDoKCQlyZXR1cm4gQ1VSTElPRV9PSzsKCgljYXNlIENVUkxJT0NNRF9SRVNUQVJUUkVBRDoKCQlidWZmZXItPnBvc24gPSAwOwoJCXJldHVybiBDVVJMSU9FX09LOwoKCWRlZmF1bHQ6CgkJcmV0dXJuIENVUkxJT0VfVU5LTk9XTkNNRDsKCX0KfQojZW5kaWYKCnNpemVfdCBmd3JpdGVfYnVmZmVyKGNoYXIgKnB0ciwgc2l6ZV90IGVsdHNpemUsIHNpemVfdCBubWVtYiwgdm9pZCAqYnVmZmVyXykKewoJc2l6ZV90IHNpemUgPSBlbHRzaXplICogbm1lbWI7CglzdHJ1Y3Qgc3RyYnVmICpidWZmZXIgPSBidWZmZXJfOwoKCXN0cmJ1Zl9hZGQoYnVmZmVyLCBwdHIsIHNpemUpOwoJZGF0YV9yZWNlaXZlZCsrOwoJcmV0dXJuIHNpemU7Cn0KCnNpemVfdCBmd3JpdGVfbnVsbChjaGFyICpwdHIsIHNpemVfdCBlbHRzaXplLCBzaXplX3Qgbm1lbWIsIHZvaWQgKnN0cmJ1ZikKewoJZGF0YV9yZWNlaXZlZCsrOwoJcmV0dXJuIGVsdHNpemUgKiBubWVtYjsKfQoKI2lmZGVmIFVTRV9DVVJMX01VTFRJCnN0YXRpYyB2b2lkIHByb2Nlc3NfY3VybF9tZXNzYWdlcyh2b2lkKQp7CglpbnQgbnVtX21lc3NhZ2VzOwoJc3RydWN0IGFjdGl2ZV9yZXF1ZXN0X3Nsb3QgKnNsb3Q7CglDVVJMTXNnICpjdXJsX21lc3NhZ2UgPSBjdXJsX211bHRpX2luZm9fcmVhZChjdXJsbSwgJm51bV9tZXNzYWdlcyk7CgoJd2hpbGUgKGN1cmxfbWVzc2FnZSAhPSBOVUxMKSB7CgkJaWYgKGN1cmxfbWVzc2FnZS0+bXNnID09IENVUkxNU0dfRE9ORSkgewoJCQlpbnQgY3VybF9yZXN1bHQgPSBjdXJsX21lc3NhZ2UtPmRhdGEucmVzdWx0OwoJCQlzbG90ID0gYWN0aXZlX3F1ZXVlX2hlYWQ7CgkJCXdoaWxlIChzbG90ICE9IE5VTEwgJiYKCQkJICAgICAgIHNsb3QtPmN1cmwgIT0gY3VybF9tZXNzYWdlLT5lYXN5X2hhbmRsZSkKCQkJCXNsb3QgPSBzbG90LT5uZXh0OwoJCQlpZiAoc2xvdCAhPSBOVUxMKSB7CgkJCQljdXJsX211bHRpX3JlbW92ZV9oYW5kbGUoY3VybG0sIHNsb3QtPmN1cmwpOwoJCQkJc2xvdC0+Y3VybF9yZXN1bHQgPSBjdXJsX3Jlc3VsdDsKCQkJCWZpbmlzaF9hY3RpdmVfc2xvdChzbG90KTsKCQkJfSBlbHNlIHsKCQkJCWZwcmludGYoc3RkZXJyLCAiUmVjZWl2ZWQgRE9ORSBtZXNzYWdlIGZvciB1bmtub3duIHJlcXVlc3QhXG4iKTsKCQkJfQoJCX0gZWxzZSB7CgkJCWZwcmludGYoc3RkZXJyLCAiVW5rbm93biBDVVJMIG1lc3NhZ2UgcmVjZWl2ZWQ6ICVkXG4iLAoJCQkJKGludCljdXJsX21lc3NhZ2UtPm1zZyk7CgkJfQoJCWN1cmxfbWVzc2FnZSA9IGN1cmxfbXVsdGlfaW5mb19yZWFkKGN1cmxtLCAmbnVtX21lc3NhZ2VzKTsKCX0KfQojZW5kaWYKCnN0YXRpYyBjaGFyICpnaXRfZ2V0cGFzc193aXRoX2Rlc2NyaXB0aW9uKGNvbnN0IGNoYXIgKndoYXQsIGNvbnN0IGNoYXIgKmRlc2MpCnsKCXN0cnVjdCBzdHJidWYgcHJvbXB0ID0gU1RSQlVGX0lOSVQ7CgljaGFyICpyOwoKCWlmIChkZXNjKQoJCXN0cmJ1Zl9hZGRmKCZwcm9tcHQsICIlcyBmb3IgJyVzJzogIiwgd2hhdCwgZGVzYyk7CgllbHNlCgkJc3RyYnVmX2FkZGYoJnByb21wdCwgIiVzOiAiLCB3aGF0KTsKCS8qCgkgKiBORUVEU1dPUks6IGZvciB1c2VybmFtZXMsIHdlIHNob3VsZCBkbyBzb21ldGhpbmcgbGVzcyBtYWdpY2FsIHRoYXQKCSAqIGFjdHVhbGx5IGVjaG9lcyB0aGUgY2hhcmFjdGVycy4gSG93ZXZlciwgd2UgbmVlZCB0byByZWFkIGZyb20KCSAqIC9kZXYvdHR5IGFuZCBub3Qgc3RkaW8sIHdoaWNoIGlzIG5vdCBwb3J0YWJsZSAoYnV0IGdldHBhc3Mgd2lsbCBkbwoJICogaXQgZm9yIHVzKS4gaHR0cC5jIHVzZXMgdGhlIHNhbWUgd29ya2Fyb3VuZC4KCSAqLwoJciA9IGdpdF9nZXRwYXNzKHByb21wdC5idWYpOwoKCXN0cmJ1Zl9yZWxlYXNlKCZwcm9tcHQpOwoJcmV0dXJuIHhzdHJkdXAocik7Cn0KCnN0YXRpYyBpbnQgaHR0cF9vcHRpb25zKGNvbnN0IGNoYXIgKnZhciwgY29uc3QgY2hhciAqdmFsdWUsIHZvaWQgKmNiKQp7CglpZiAoIXN0cmNtcCgiaHR0cC5zc2x2ZXJpZnkiLCB2YXIpKSB7CgkJY3VybF9zc2xfdmVyaWZ5ID0gZ2l0X2NvbmZpZ19ib29sKHZhciwgdmFsdWUpOwoJCXJldHVybiAwOwoJfQoJaWYgKCFzdHJjbXAoImh0dHAuc3NsY2VydCIsIHZhcikpCgkJcmV0dXJuIGdpdF9jb25maWdfc3RyaW5nKCZzc2xfY2VydCwgdmFyLCB2YWx1ZSk7CiNpZiBMSUJDVVJMX1ZFUlNJT05fTlVNID49IDB4MDcwOTAzCglpZiAoIXN0cmNtcCgiaHR0cC5zc2xrZXkiLCB2YXIpKQoJCXJldHVybiBnaXRfY29uZmlnX3N0cmluZygmc3NsX2tleSwgdmFyLCB2YWx1ZSk7CiNlbmRpZgojaWYgTElCQ1VSTF9WRVJTSU9OX05VTSA+PSAweDA3MDkwOAoJaWYgKCFzdHJjbXAoImh0dHAuc3NsY2FwYXRoIiwgdmFyKSkKCQlyZXR1cm4gZ2l0X2NvbmZpZ19zdHJpbmcoJnNzbF9jYXBhdGgsIHZhciwgdmFsdWUpOwojZW5kaWYKCWlmICghc3RyY21wKCJodHRwLnNzbGNhaW5mbyIsIHZhcikpCgkJcmV0dXJuIGdpdF9jb25maWdfc3RyaW5nKCZzc2xfY2FpbmZvLCB2YXIsIHZhbHVlKTsKCWlmICghc3RyY21wKCJodHRwLnNzbGNlcnRwYXNzd29yZHByb3RlY3RlZCIsIHZhcikpIHsKCQlpZiAoZ2l0X2NvbmZpZ19ib29sKHZhciwgdmFsdWUpKQoJCQlzc2xfY2VydF9wYXNzd29yZF9yZXF1aXJlZCA9IDE7CgkJcmV0dXJuIDA7Cgl9CglpZiAoIXN0cmNtcCgiaHR0cC5taW5zZXNzaW9ucyIsIHZhcikpIHsKCQltaW5fY3VybF9zZXNzaW9ucyA9IGdpdF9jb25maWdfaW50KHZhciwgdmFsdWUpOwojaWZuZGVmIFVTRV9DVVJMX01VTFRJCgkJaWYgKG1pbl9jdXJsX3Nlc3Npb25zID4gMSkKCQkJbWluX2N1cmxfc2Vzc2lvbnMgPSAxOwojZW5kaWYKCQlyZXR1cm4gMDsKCX0KI2lmZGVmIFVTRV9DVVJMX01VTFRJCglpZiAoIXN0cmNtcCgiaHR0cC5tYXhyZXF1ZXN0cyIsIHZhcikpIHsKCQltYXhfcmVxdWVzdHMgPSBnaXRfY29uZmlnX2ludCh2YXIsIHZhbHVlKTsKCQlyZXR1cm4gMDsKCX0KI2VuZGlmCglpZiAoIXN0cmNtcCgiaHR0cC5sb3dzcGVlZGxpbWl0IiwgdmFyKSkgewoJCWN1cmxfbG93X3NwZWVkX2xpbWl0ID0gKGxvbmcpZ2l0X2NvbmZpZ19pbnQodmFyLCB2YWx1ZSk7CgkJcmV0dXJuIDA7Cgl9CglpZiAoIXN0cmNtcCgiaHR0cC5sb3dzcGVlZHRpbWUiLCB2YXIpKSB7CgkJY3VybF9sb3dfc3BlZWRfdGltZSA9IChsb25nKWdpdF9jb25maWdfaW50KHZhciwgdmFsdWUpOwoJCXJldHVybiAwOwoJfQoKCWlmICghc3RyY21wKCJodHRwLm5vZXBzdiIsIHZhcikpIHsKCQljdXJsX2Z0cF9ub19lcHN2ID0gZ2l0X2NvbmZpZ19ib29sKHZhciwgdmFsdWUpOwoJCXJldHVybiAwOwoJfQoJaWYgKCFzdHJjbXAoImh0dHAucHJveHkiLCB2YXIpKQoJCXJldHVybiBnaXRfY29uZmlnX3N0cmluZygmY3VybF9odHRwX3Byb3h5LCB2YXIsIHZhbHVlKTsKCglpZiAoIXN0cmNtcCgiaHR0cC5jb29raWVmaWxlIiwgdmFyKSkKCQlyZXR1cm4gZ2l0X2NvbmZpZ19zdHJpbmcoJmN1cmxfY29va2llX2ZpbGUsIHZhciwgdmFsdWUpOwoKCWlmICghc3RyY21wKCJodHRwLnBvc3RidWZmZXIiLCB2YXIpKSB7CgkJaHR0cF9wb3N0X2J1ZmZlciA9IGdpdF9jb25maWdfaW50KHZhciwgdmFsdWUpOwoJCWlmIChodHRwX3Bvc3RfYnVmZmVyIDwgTEFSR0VfUEFDS0VUX01BWCkKCQkJaHR0cF9wb3N0X2J1ZmZlciA9IExBUkdFX1BBQ0tFVF9NQVg7CgkJcmV0dXJuIDA7Cgl9CgoJaWYgKCFzdHJjbXAoImh0dHAudXNlcmFnZW50IiwgdmFyKSkKCQlyZXR1cm4gZ2l0X2NvbmZpZ19zdHJpbmcoJnVzZXJfYWdlbnQsIHZhciwgdmFsdWUpOwoKCS8qIEZhbGwgYmFjayBvbiB0aGUgZGVmYXVsdCBvbmVzICovCglyZXR1cm4gZ2l0X2RlZmF1bHRfY29uZmlnKHZhciwgdmFsdWUsIGNiKTsKfQoKc3RhdGljIHZvaWQgaW5pdF9jdXJsX2h0dHBfYXV0aChDVVJMICpyZXN1bHQpCnsKCWlmICh1c2VyX25hbWUpIHsKCQlzdHJ1Y3Qgc3RyYnVmIHVwID0gU1RSQlVGX0lOSVQ7CgkJaWYgKCF1c2VyX3Bhc3MpCgkJCXVzZXJfcGFzcyA9IHhzdHJkdXAoZ2l0X2dldHBhc3Nfd2l0aF9kZXNjcmlwdGlvbigiUGFzc3dvcmQiLCBkZXNjcmlwdGlvbikpOwoJCXN0cmJ1Zl9hZGRmKCZ1cCwgIiVzOiVzIiwgdXNlcl9uYW1lLCB1c2VyX3Bhc3MpOwoJCWN1cmxfZWFzeV9zZXRvcHQocmVzdWx0LCBDVVJMT1BUX1VTRVJQV0QsCgkJCQkgc3RyYnVmX2RldGFjaCgmdXAsIE5VTEwpKTsKCX0KfQoKc3RhdGljIGludCBoYXNfY2VydF9wYXNzd29yZCh2b2lkKQp7CglpZiAoc3NsX2NlcnRfcGFzc3dvcmQgIT0gTlVMTCkKCQlyZXR1cm4gMTsKCWlmIChzc2xfY2VydCA9PSBOVUxMIHx8IHNzbF9jZXJ0X3Bhc3N3b3JkX3JlcXVpcmVkICE9IDEpCgkJcmV0dXJuIDA7CgkvKiBPbmx5IHByb21wdCB0aGUgdXNlciBvbmNlLiAqLwoJc3NsX2NlcnRfcGFzc3dvcmRfcmVxdWlyZWQgPSAtMTsKCXNzbF9jZXJ0X3Bhc3N3b3JkID0gZ2l0X2dldHBhc3Nfd2l0aF9kZXNjcmlwdGlvbigiQ2VydGlmaWNhdGUgUGFzc3dvcmQiLCBkZXNjcmlwdGlvbik7CglpZiAoc3NsX2NlcnRfcGFzc3dvcmQgIT0gTlVMTCkgewoJCXNzbF9jZXJ0X3Bhc3N3b3JkID0geHN0cmR1cChzc2xfY2VydF9wYXNzd29yZCk7CgkJcmV0dXJuIDE7Cgl9IGVsc2UKCQlyZXR1cm4gMDsKfQoKc3RhdGljIENVUkwgKmdldF9jdXJsX2hhbmRsZSh2b2lkKQp7CglDVVJMICpyZXN1bHQgPSBjdXJsX2Vhc3lfaW5pdCgpOwoKCWlmICghY3VybF9zc2xfdmVyaWZ5KSB7CgkJY3VybF9lYXN5X3NldG9wdChyZXN1bHQsIENVUkxPUFRfU1NMX1ZFUklGWVBFRVIsIDApOwoJCWN1cmxfZWFzeV9zZXRvcHQocmVzdWx0LCBDVVJMT1BUX1NTTF9WRVJJRllIT1NULCAwKTsKCX0gZWxzZSB7CgkJLyogVmVyaWZ5IGF1dGhlbnRpY2l0eSBvZiB0aGUgcGVlcidzIGNlcnRpZmljYXRlICovCgkJY3VybF9lYXN5X3NldG9wdChyZXN1bHQsIENVUkxPUFRfU1NMX1ZFUklGWVBFRVIsIDEpOwoJCS8qIFRoZSBuYW1lIGluIHRoZSBjZXJ0IG11c3QgbWF0Y2ggd2hvbSB3ZSB0cmllZCB0byBjb25uZWN0ICovCgkJY3VybF9lYXN5X3NldG9wdChyZXN1bHQsIENVUkxPUFRfU1NMX1ZFUklGWUhPU1QsIDIpOwoJfQoKI2lmIExJQkNVUkxfVkVSU0lPTl9OVU0gPj0gMHgwNzA5MDcKCWN1cmxfZWFzeV9zZXRvcHQocmVzdWx0LCBDVVJMT1BUX05FVFJDLCBDVVJMX05FVFJDX09QVElPTkFMKTsKI2VuZGlmCiNpZmRlZiBMSUJDVVJMX0NBTl9IQU5ETEVfQVVUSF9BTlkKCWN1cmxfZWFzeV9zZXRvcHQocmVzdWx0LCBDVVJMT1BUX0hUVFBBVVRILCBDVVJMQVVUSF9BTlkpOwojZW5kaWYKCglpZiAoc3NsX2NlcnQgIT0gTlVMTCkKCQljdXJsX2Vhc3lfc2V0b3B0KHJlc3VsdCwgQ1VSTE9QVF9TU0xDRVJULCBzc2xfY2VydCk7CglpZiAoaGFzX2NlcnRfcGFzc3dvcmQoKSkKCQljdXJsX2Vhc3lfc2V0b3B0KHJlc3VsdCwgQ1VSTE9QVF9LRVlQQVNTV0QsIHNzbF9jZXJ0X3Bhc3N3b3JkKTsKI2lmIExJQkNVUkxfVkVSU0lPTl9OVU0gPj0gMHgwNzA5MDMKCWlmIChzc2xfa2V5ICE9IE5VTEwpCgkJY3VybF9lYXN5X3NldG9wdChyZXN1bHQsIENVUkxPUFRfU1NMS0VZLCBzc2xfa2V5KTsKI2VuZGlmCiNpZiBMSUJDVVJMX1ZFUlNJT05fTlVNID49IDB4MDcwOTA4CglpZiAoc3NsX2NhcGF0aCAhPSBOVUxMKQoJCWN1cmxfZWFzeV9zZXRvcHQocmVzdWx0LCBDVVJMT1BUX0NBUEFUSCwgc3NsX2NhcGF0aCk7CiNlbmRpZgoJaWYgKHNzbF9jYWluZm8gIT0gTlVMTCkKCQljdXJsX2Vhc3lfc2V0b3B0KHJlc3VsdCwgQ1VSTE9QVF9DQUlORk8sIHNzbF9jYWluZm8pOwoJY3VybF9lYXN5X3NldG9wdChyZXN1bHQsIENVUkxPUFRfRkFJTE9ORVJST1IsIDEpOwoKCWlmIChjdXJsX2xvd19zcGVlZF9saW1pdCA+IDAgJiYgY3VybF9sb3dfc3BlZWRfdGltZSA+IDApIHsKCQljdXJsX2Vhc3lfc2V0b3B0KHJlc3VsdCwgQ1VSTE9QVF9MT1dfU1BFRURfTElNSVQsCgkJCQkgY3VybF9sb3dfc3BlZWRfbGltaXQpOwoJCWN1cmxfZWFzeV9zZXRvcHQocmVzdWx0LCBDVVJMT1BUX0xPV19TUEVFRF9USU1FLAoJCQkJIGN1cmxfbG93X3NwZWVkX3RpbWUpOwoJfQoKCWN1cmxfZWFzeV9zZXRvcHQocmVzdWx0LCBDVVJMT1BUX0ZPTExPV0xPQ0FUSU9OLCAxKTsKI2lmIExJQkNVUkxfVkVSU0lPTl9OVU0gPj0gMHgwNzEzMDEKCWN1cmxfZWFzeV9zZXRvcHQocmVzdWx0LCBDVVJMT1BUX1BPU1RSRURJUiwgQ1VSTF9SRURJUl9QT1NUX0FMTCk7CiNlbGlmIExJQkNVUkxfVkVSU0lPTl9OVU0gPj0gMHgwNzExMDEKCWN1cmxfZWFzeV9zZXRvcHQocmVzdWx0LCBDVVJMT1BUX1BPU1QzMDEsIDEpOwojZW5kaWYKCglpZiAoZ2V0ZW52KCJHSVRfQ1VSTF9WRVJCT1NFIikpCgkJY3VybF9lYXN5X3NldG9wdChyZXN1bHQsIENVUkxPUFRfVkVSQk9TRSwgMSk7CgoJY3VybF9lYXN5X3NldG9wdChyZXN1bHQsIENVUkxPUFRfVVNFUkFHRU5ULAoJCXVzZXJfYWdlbnQgPyB1c2VyX2FnZW50IDogR0lUX0hUVFBfVVNFUl9BR0VOVCk7CgoJaWYgKGN1cmxfZnRwX25vX2Vwc3YpCgkJY3VybF9lYXN5X3NldG9wdChyZXN1bHQsIENVUkxPUFRfRlRQX1VTRV9FUFNWLCAwKTsKCglpZiAoY3VybF9odHRwX3Byb3h5KQoJCWN1cmxfZWFzeV9zZXRvcHQocmVzdWx0LCBDVVJMT1BUX1BST1hZLCBjdXJsX2h0dHBfcHJveHkpOwoKCXJldHVybiByZXN1bHQ7Cn0KCnN0YXRpYyB2b2lkIGh0dHBfYXV0aF9pbml0KGNvbnN0IGNoYXIgKnVybCkKewoJY29uc3QgY2hhciAqYXQsICpjb2xvbiwgKmNwLCAqc2xhc2gsICpob3N0OwoKCWNwID0gc3Ryc3RyKHVybCwgIjovLyIpOwoJaWYgKCFjcCkKCQlyZXR1cm47CgoJLyoKCSAqIE9rLCB0aGUgVVJMIGxvb2tzIGxpa2UgInByb3RvOi8vc29tZXRoaW5nIi4gIFdoaWNoIG9uZT8KCSAqICJwcm90bzovLzx1c2VyPjo8cGFzcz5APGhvc3Q+Ly4uLiIsCgkgKiAicHJvdG86Ly88dXNlcj5APGhvc3Q+Ly4uLiIsIG9yIGp1c3QKCSAqICJwcm90bzovLzxob3N0Pi8uLi4iPwoJICovCgljcCArPSAzOwoJYXQgPSBzdHJjaHIoY3AsICdAJyk7Cgljb2xvbiA9IHN0cmNocihjcCwgJzonKTsKCXNsYXNoID0gc3RyY2hybnVsKGNwLCAnLycpOwoJaWYgKCFhdCB8fCBzbGFzaCA8PSBhdCkgewoJCS8qIE5vIGNyZWRlbnRpYWxzLCBidXQgd2UgbWF5IGhhdmUgdG8gYXNrIGZvciBzb21lIGxhdGVyICovCgkJaG9zdCA9IGNwOwoJfQoJZWxzZSBpZiAoIWNvbG9uIHx8IGF0IDw9IGNvbG9uKSB7CgkJLyogT25seSB1c2VybmFtZSAqLwoJCXVzZXJfbmFtZSA9IHVybF9kZWNvZGVfbWVtKGNwLCBhdCAtIGNwKTsKCQl1c2VyX3Bhc3MgPSBOVUxMOwoJCWhvc3QgPSBhdCArIDE7Cgl9IGVsc2UgewoJCXVzZXJfbmFtZSA9IHVybF9kZWNvZGVfbWVtKGNwLCBjb2xvbiAtIGNwKTsKCQl1c2VyX3Bhc3MgPSB1cmxfZGVjb2RlX21lbShjb2xvbiArIDEsIGF0IC0gKGNvbG9uICsgMSkpOwoJCWhvc3QgPSBhdCArIDE7Cgl9CgoJZGVzY3JpcHRpb24gPSB1cmxfZGVjb2RlX21lbShob3N0LCBzbGFzaCAtIGhvc3QpOwp9CgpzdGF0aWMgdm9pZCBzZXRfZnJvbV9lbnYoY29uc3QgY2hhciAqKnZhciwgY29uc3QgY2hhciAqZW52bmFtZSkKewoJY29uc3QgY2hhciAqdmFsID0gZ2V0ZW52KGVudm5hbWUpOwoJaWYgKHZhbCkKCQkqdmFyID0gdmFsOwp9Cgp2b2lkIGh0dHBfaW5pdChzdHJ1Y3QgcmVtb3RlICpyZW1vdGUsIGNvbnN0IGNoYXIgKnVybCkKewoJY2hhciAqbG93X3NwZWVkX2xpbWl0OwoJY2hhciAqbG93X3NwZWVkX3RpbWU7CgoJaHR0cF9pc192ZXJib3NlID0gMDsKCglnaXRfY29uZmlnKGh0dHBfb3B0aW9ucywgTlVMTCk7CgoJY3VybF9nbG9iYWxfaW5pdChDVVJMX0dMT0JBTF9BTEwpOwoKCWlmIChyZW1vdGUgJiYgcmVtb3RlLT5odHRwX3Byb3h5KQoJCWN1cmxfaHR0cF9wcm94eSA9IHhzdHJkdXAocmVtb3RlLT5odHRwX3Byb3h5KTsKCglwcmFnbWFfaGVhZGVyID0gY3VybF9zbGlzdF9hcHBlbmQocHJhZ21hX2hlYWRlciwgIlByYWdtYTogbm8tY2FjaGUiKTsKCW5vX3ByYWdtYV9oZWFkZXIgPSBjdXJsX3NsaXN0X2FwcGVuZChub19wcmFnbWFfaGVhZGVyLCAiUHJhZ21hOiIpOwoKI2lmZGVmIFVTRV9DVVJMX01VTFRJCgl7CgkJY2hhciAqaHR0cF9tYXhfcmVxdWVzdHMgPSBnZXRlbnYoIkdJVF9IVFRQX01BWF9SRVFVRVNUUyIpOwoJCWlmIChodHRwX21heF9yZXF1ZXN0cyAhPSBOVUxMKQoJCQltYXhfcmVxdWVzdHMgPSBhdG9pKGh0dHBfbWF4X3JlcXVlc3RzKTsKCX0KCgljdXJsbSA9IGN1cmxfbXVsdGlfaW5pdCgpOwoJaWYgKGN1cmxtID09IE5VTEwpIHsKCQlmcHJpbnRmKHN0ZGVyciwgIkVycm9yIGNyZWF0aW5nIGN1cmwgbXVsdGkgaGFuZGxlLlxuIik7CgkJZXhpdCgxKTsKCX0KI2VuZGlmCgoJaWYgKGdldGVudigiR0lUX1NTTF9OT19WRVJJRlkiKSkKCQljdXJsX3NzbF92ZXJpZnkgPSAwOwoKCXNldF9mcm9tX2Vudigmc3NsX2NlcnQsICJHSVRfU1NMX0NFUlQiKTsKI2lmIExJQkNVUkxfVkVSU0lPTl9OVU0gPj0gMHgwNzA5MDMKCXNldF9mcm9tX2Vudigmc3NsX2tleSwgIkdJVF9TU0xfS0VZIik7CiNlbmRpZgojaWYgTElCQ1VSTF9WRVJTSU9OX05VTSA+PSAweDA3MDkwOAoJc2V0X2Zyb21fZW52KCZzc2xfY2FwYXRoLCAiR0lUX1NTTF9DQVBBVEgiKTsKI2VuZGlmCglzZXRfZnJvbV9lbnYoJnNzbF9jYWluZm8sICJHSVRfU1NMX0NBSU5GTyIpOwoKCXNldF9mcm9tX2VudigmdXNlcl9hZ2VudCwgIkdJVF9IVFRQX1VTRVJfQUdFTlQiKTsKCglsb3dfc3BlZWRfbGltaXQgPSBnZXRlbnYoIkdJVF9IVFRQX0xPV19TUEVFRF9MSU1JVCIpOwoJaWYgKGxvd19zcGVlZF9saW1pdCAhPSBOVUxMKQoJCWN1cmxfbG93X3NwZWVkX2xpbWl0ID0gc3RydG9sKGxvd19zcGVlZF9saW1pdCwgTlVMTCwgMTApOwoJbG93X3NwZWVkX3RpbWUgPSBnZXRlbnYoIkdJVF9IVFRQX0xPV19TUEVFRF9USU1FIik7CglpZiAobG93X3NwZWVkX3RpbWUgIT0gTlVMTCkKCQljdXJsX2xvd19zcGVlZF90aW1lID0gc3RydG9sKGxvd19zcGVlZF90aW1lLCBOVUxMLCAxMCk7CgoJaWYgKGN1cmxfc3NsX3ZlcmlmeSA9PSAtMSkKCQljdXJsX3NzbF92ZXJpZnkgPSAxOwoKCWN1cmxfc2Vzc2lvbl9jb3VudCA9IDA7CiNpZmRlZiBVU0VfQ1VSTF9NVUxUSQoJaWYgKG1heF9yZXF1ZXN0cyA8IDEpCgkJbWF4X3JlcXVlc3RzID0gREVGQVVMVF9NQVhfUkVRVUVTVFM7CiNlbmRpZgoKCWlmIChnZXRlbnYoIkdJVF9DVVJMX0ZUUF9OT19FUFNWIikpCgkJY3VybF9mdHBfbm9fZXBzdiA9IDE7CgoJaWYgKHVybCkgewoJCWh0dHBfYXV0aF9pbml0KHVybCk7CgkJaWYgKCFzc2xfY2VydF9wYXNzd29yZF9yZXF1aXJlZCAmJgoJCSAgICBnZXRlbnYoIkdJVF9TU0xfQ0VSVF9QQVNTV09SRF9QUk9URUNURUQiKSAmJgoJCSAgICAhcHJlZml4Y21wKHVybCwgImh0dHBzOi8vIikpCgkJCXNzbF9jZXJ0X3Bhc3N3b3JkX3JlcXVpcmVkID0gMTsKCX0KCiNpZm5kZWYgTk9fQ1VSTF9FQVNZX0RVUEhBTkRMRQoJY3VybF9kZWZhdWx0ID0gZ2V0X2N1cmxfaGFuZGxlKCk7CiNlbmRpZgp9Cgp2b2lkIGh0dHBfY2xlYW51cCh2b2lkKQp7CglzdHJ1Y3QgYWN0aXZlX3JlcXVlc3Rfc2xvdCAqc2xvdCA9IGFjdGl2ZV9xdWV1ZV9oZWFkOwoKCXdoaWxlIChzbG90ICE9IE5VTEwpIHsKCQlzdHJ1Y3QgYWN0aXZlX3JlcXVlc3Rfc2xvdCAqbmV4dCA9IHNsb3QtPm5leHQ7CgkJaWYgKHNsb3QtPmN1cmwgIT0gTlVMTCkgewojaWZkZWYgVVNFX0NVUkxfTVVMVEkKCQkJY3VybF9tdWx0aV9yZW1vdmVfaGFuZGxlKGN1cmxtLCBzbG90LT5jdXJsKTsKI2VuZGlmCgkJCWN1cmxfZWFzeV9jbGVhbnVwKHNsb3QtPmN1cmwpOwoJCX0KCQlmcmVlKHNsb3QpOwoJCXNsb3QgPSBuZXh0OwoJfQoJYWN0aXZlX3F1ZXVlX2hlYWQgPSBOVUxMOwoKI2lmbmRlZiBOT19DVVJMX0VBU1lfRFVQSEFORExFCgljdXJsX2Vhc3lfY2xlYW51cChjdXJsX2RlZmF1bHQpOwojZW5kaWYKCiNpZmRlZiBVU0VfQ1VSTF9NVUxUSQoJY3VybF9tdWx0aV9jbGVhbnVwKGN1cmxtKTsKI2VuZGlmCgljdXJsX2dsb2JhbF9jbGVhbnVwKCk7CgoJY3VybF9zbGlzdF9mcmVlX2FsbChwcmFnbWFfaGVhZGVyKTsKCXByYWdtYV9oZWFkZXIgPSBOVUxMOwoKCWN1cmxfc2xpc3RfZnJlZV9hbGwobm9fcHJhZ21hX2hlYWRlcik7Cglub19wcmFnbWFfaGVhZGVyID0gTlVMTDsKCglpZiAoY3VybF9odHRwX3Byb3h5KSB7CgkJZnJlZSgodm9pZCAqKWN1cmxfaHR0cF9wcm94eSk7CgkJY3VybF9odHRwX3Byb3h5ID0gTlVMTDsKCX0KCglpZiAoc3NsX2NlcnRfcGFzc3dvcmQgIT0gTlVMTCkgewoJCW1lbXNldChzc2xfY2VydF9wYXNzd29yZCwgMCwgc3RybGVuKHNzbF9jZXJ0X3Bhc3N3b3JkKSk7CgkJZnJlZShzc2xfY2VydF9wYXNzd29yZCk7CgkJc3NsX2NlcnRfcGFzc3dvcmQgPSBOVUxMOwoJfQoJc3NsX2NlcnRfcGFzc3dvcmRfcmVxdWlyZWQgPSAwOwp9CgpzdHJ1Y3QgYWN0aXZlX3JlcXVlc3Rfc2xvdCAqZ2V0X2FjdGl2ZV9zbG90KHZvaWQpCnsKCXN0cnVjdCBhY3RpdmVfcmVxdWVzdF9zbG90ICpzbG90ID0gYWN0aXZlX3F1ZXVlX2hlYWQ7CglzdHJ1Y3QgYWN0aXZlX3JlcXVlc3Rfc2xvdCAqbmV3c2xvdDsKCiNpZmRlZiBVU0VfQ1VSTF9NVUxUSQoJaW50IG51bV90cmFuc2ZlcnM7CgoJLyogV2FpdCBmb3IgYSBzbG90IHRvIG9wZW4gdXAgaWYgdGhlIHF1ZXVlIGlzIGZ1bGwgKi8KCXdoaWxlIChhY3RpdmVfcmVxdWVzdHMgPj0gbWF4X3JlcXVlc3RzKSB7CgkJY3VybF9tdWx0aV9wZXJmb3JtKGN1cmxtLCAmbnVtX3RyYW5zZmVycyk7CgkJaWYgKG51bV90cmFuc2ZlcnMgPCBhY3RpdmVfcmVxdWVzdHMpCgkJCXByb2Nlc3NfY3VybF9tZXNzYWdlcygpOwoJfQojZW5kaWYKCgl3aGlsZSAoc2xvdCAhPSBOVUxMICYmIHNsb3QtPmluX3VzZSkKCQlzbG90ID0gc2xvdC0+bmV4dDsKCglpZiAoc2xvdCA9PSBOVUxMKSB7CgkJbmV3c2xvdCA9IHhtYWxsb2Moc2l6ZW9mKCpuZXdzbG90KSk7CgkJbmV3c2xvdC0+Y3VybCA9IE5VTEw7CgkJbmV3c2xvdC0+aW5fdXNlID0gMDsKCQluZXdzbG90LT5uZXh0ID0gTlVMTDsKCgkJc2xvdCA9IGFjdGl2ZV9xdWV1ZV9oZWFkOwoJCWlmIChzbG90ID09IE5VTEwpIHsKCQkJYWN0aXZlX3F1ZXVlX2hlYWQgPSBuZXdzbG90OwoJCX0gZWxzZSB7CgkJCXdoaWxlIChzbG90LT5uZXh0ICE9IE5VTEwpCgkJCQlzbG90ID0gc2xvdC0+bmV4dDsKCQkJc2xvdC0+bmV4dCA9IG5ld3Nsb3Q7CgkJfQoJCXNsb3QgPSBuZXdzbG90OwoJfQoKCWlmIChzbG90LT5jdXJsID09IE5VTEwpIHsKI2lmZGVmIE5PX0NVUkxfRUFTWV9EVVBIQU5ETEUKCQlzbG90LT5jdXJsID0gZ2V0X2N1cmxfaGFuZGxlKCk7CiNlbHNlCgkJc2xvdC0+Y3VybCA9IGN1cmxfZWFzeV9kdXBoYW5kbGUoY3VybF9kZWZhdWx0KTsKI2VuZGlmCgkJY3VybF9zZXNzaW9uX2NvdW50Kys7Cgl9CgoJYWN0aXZlX3JlcXVlc3RzKys7CglzbG90LT5pbl91c2UgPSAxOwoJc2xvdC0+bG9jYWwgPSBOVUxMOwoJc2xvdC0+cmVzdWx0cyA9IE5VTEw7CglzbG90LT5maW5pc2hlZCA9IE5VTEw7CglzbG90LT5jYWxsYmFja19kYXRhID0gTlVMTDsKCXNsb3QtPmNhbGxiYWNrX2Z1bmMgPSBOVUxMOwoJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX0NPT0tJRUZJTEUsIGN1cmxfY29va2llX2ZpbGUpOwoJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX0hUVFBIRUFERVIsIHByYWdtYV9oZWFkZXIpOwoJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX0VSUk9SQlVGRkVSLCBjdXJsX2Vycm9yc3RyKTsKCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9DVVNUT01SRVFVRVNULCBOVUxMKTsKCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9SRUFERlVOQ1RJT04sIE5VTEwpOwoJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX1dSSVRFRlVOQ1RJT04sIE5VTEwpOwoJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX1BPU1RGSUVMRFMsIE5VTEwpOwoJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX1VQTE9BRCwgMCk7CgljdXJsX2Vhc3lfc2V0b3B0KHNsb3QtPmN1cmwsIENVUkxPUFRfSFRUUEdFVCwgMSk7CgoJcmV0dXJuIHNsb3Q7Cn0KCmludCBzdGFydF9hY3RpdmVfc2xvdChzdHJ1Y3QgYWN0aXZlX3JlcXVlc3Rfc2xvdCAqc2xvdCkKewojaWZkZWYgVVNFX0NVUkxfTVVMVEkKCUNVUkxNY29kZSBjdXJsbV9yZXN1bHQgPSBjdXJsX211bHRpX2FkZF9oYW5kbGUoY3VybG0sIHNsb3QtPmN1cmwpOwoJaW50IG51bV90cmFuc2ZlcnM7CgoJaWYgKGN1cmxtX3Jlc3VsdCAhPSBDVVJMTV9PSyAmJgoJICAgIGN1cmxtX3Jlc3VsdCAhPSBDVVJMTV9DQUxMX01VTFRJX1BFUkZPUk0pIHsKCQlhY3RpdmVfcmVxdWVzdHMtLTsKCQlzbG90LT5pbl91c2UgPSAwOwoJCXJldHVybiAwOwoJfQoKCS8qCgkgKiBXZSBrbm93IHRoZXJlIG11c3QgYmUgc29tZXRoaW5nIHRvIGRvLCBzaW5jZSB3ZSBqdXN0IGFkZGVkCgkgKiBzb21ldGhpbmcuCgkgKi8KCWN1cmxfbXVsdGlfcGVyZm9ybShjdXJsbSwgJm51bV90cmFuc2ZlcnMpOwojZW5kaWYKCXJldHVybiAxOwp9CgojaWZkZWYgVVNFX0NVUkxfTVVMVEkKc3RydWN0IGZpbGxfY2hhaW4gewoJdm9pZCAqZGF0YTsKCWludCAoKmZpbGwpKHZvaWQgKik7CglzdHJ1Y3QgZmlsbF9jaGFpbiAqbmV4dDsKfTsKCnN0YXRpYyBzdHJ1Y3QgZmlsbF9jaGFpbiAqZmlsbF9jZmc7Cgp2b2lkIGFkZF9maWxsX2Z1bmN0aW9uKHZvaWQgKmRhdGEsIGludCAoKmZpbGwpKHZvaWQgKikpCnsKCXN0cnVjdCBmaWxsX2NoYWluICpuZXcgPSB4bWFsbG9jKHNpemVvZigqbmV3KSk7CglzdHJ1Y3QgZmlsbF9jaGFpbiAqKmxpbmtwID0gJmZpbGxfY2ZnOwoJbmV3LT5kYXRhID0gZGF0YTsKCW5ldy0+ZmlsbCA9IGZpbGw7CgluZXctPm5leHQgPSBOVUxMOwoJd2hpbGUgKCpsaW5rcCkKCQlsaW5rcCA9ICYoKmxpbmtwKS0+bmV4dDsKCSpsaW5rcCA9IG5ldzsKfQoKdm9pZCBmaWxsX2FjdGl2ZV9zbG90cyh2b2lkKQp7CglzdHJ1Y3QgYWN0aXZlX3JlcXVlc3Rfc2xvdCAqc2xvdCA9IGFjdGl2ZV9xdWV1ZV9oZWFkOwoKCXdoaWxlIChhY3RpdmVfcmVxdWVzdHMgPCBtYXhfcmVxdWVzdHMpIHsKCQlzdHJ1Y3QgZmlsbF9jaGFpbiAqZmlsbDsKCQlmb3IgKGZpbGwgPSBmaWxsX2NmZzsgZmlsbDsgZmlsbCA9IGZpbGwtPm5leHQpCgkJCWlmIChmaWxsLT5maWxsKGZpbGwtPmRhdGEpKQoJCQkJYnJlYWs7CgoJCWlmICghZmlsbCkKCQkJYnJlYWs7Cgl9CgoJd2hpbGUgKHNsb3QgIT0gTlVMTCkgewoJCWlmICghc2xvdC0+aW5fdXNlICYmIHNsb3QtPmN1cmwgIT0gTlVMTAoJCQkmJiBjdXJsX3Nlc3Npb25fY291bnQgPiBtaW5fY3VybF9zZXNzaW9ucykgewoJCQljdXJsX2Vhc3lfY2xlYW51cChzbG90LT5jdXJsKTsKCQkJc2xvdC0+Y3VybCA9IE5VTEw7CgkJCWN1cmxfc2Vzc2lvbl9jb3VudC0tOwoJCX0KCQlzbG90ID0gc2xvdC0+bmV4dDsKCX0KfQoKdm9pZCBzdGVwX2FjdGl2ZV9zbG90cyh2b2lkKQp7CglpbnQgbnVtX3RyYW5zZmVyczsKCUNVUkxNY29kZSBjdXJsbV9yZXN1bHQ7CgoJZG8gewoJCWN1cmxtX3Jlc3VsdCA9IGN1cmxfbXVsdGlfcGVyZm9ybShjdXJsbSwgJm51bV90cmFuc2ZlcnMpOwoJfSB3aGlsZSAoY3VybG1fcmVzdWx0ID09IENVUkxNX0NBTExfTVVMVElfUEVSRk9STSk7CglpZiAobnVtX3RyYW5zZmVycyA8IGFjdGl2ZV9yZXF1ZXN0cykgewoJCXByb2Nlc3NfY3VybF9tZXNzYWdlcygpOwoJCWZpbGxfYWN0aXZlX3Nsb3RzKCk7Cgl9Cn0KI2VuZGlmCgp2b2lkIHJ1bl9hY3RpdmVfc2xvdChzdHJ1Y3QgYWN0aXZlX3JlcXVlc3Rfc2xvdCAqc2xvdCkKewojaWZkZWYgVVNFX0NVUkxfTVVMVEkKCWxvbmcgbGFzdF9wb3MgPSAwOwoJbG9uZyBjdXJyZW50X3BvczsKCWZkX3NldCByZWFkZmRzOwoJZmRfc2V0IHdyaXRlZmRzOwoJZmRfc2V0IGV4Y2ZkczsKCWludCBtYXhfZmQ7CglzdHJ1Y3QgdGltZXZhbCBzZWxlY3RfdGltZW91dDsKCWludCBmaW5pc2hlZCA9IDA7CgoJc2xvdC0+ZmluaXNoZWQgPSAmZmluaXNoZWQ7Cgl3aGlsZSAoIWZpbmlzaGVkKSB7CgkJZGF0YV9yZWNlaXZlZCA9IDA7CgkJc3RlcF9hY3RpdmVfc2xvdHMoKTsKCgkJaWYgKCFkYXRhX3JlY2VpdmVkICYmIHNsb3QtPmxvY2FsICE9IE5VTEwpIHsKCQkJY3VycmVudF9wb3MgPSBmdGVsbChzbG90LT5sb2NhbCk7CgkJCWlmIChjdXJyZW50X3BvcyA+IGxhc3RfcG9zKQoJCQkJZGF0YV9yZWNlaXZlZCsrOwoJCQlsYXN0X3BvcyA9IGN1cnJlbnRfcG9zOwoJCX0KCgkJaWYgKHNsb3QtPmluX3VzZSAmJiAhZGF0YV9yZWNlaXZlZCkgewoJCQltYXhfZmQgPSAwOwoJCQlGRF9aRVJPKCZyZWFkZmRzKTsKCQkJRkRfWkVSTygmd3JpdGVmZHMpOwoJCQlGRF9aRVJPKCZleGNmZHMpOwoJCQlzZWxlY3RfdGltZW91dC50dl9zZWMgPSAwOwoJCQlzZWxlY3RfdGltZW91dC50dl91c2VjID0gNTAwMDA7CgkJCXNlbGVjdChtYXhfZmQsICZyZWFkZmRzLCAmd3JpdGVmZHMsCgkJCSAgICAgICAmZXhjZmRzLCAmc2VsZWN0X3RpbWVvdXQpOwoJCX0KCX0KI2Vsc2UKCXdoaWxlIChzbG90LT5pbl91c2UpIHsKCQlzbG90LT5jdXJsX3Jlc3VsdCA9IGN1cmxfZWFzeV9wZXJmb3JtKHNsb3QtPmN1cmwpOwoJCWZpbmlzaF9hY3RpdmVfc2xvdChzbG90KTsKCX0KI2VuZGlmCn0KCnN0YXRpYyB2b2lkIGNsb3NlZG93bl9hY3RpdmVfc2xvdChzdHJ1Y3QgYWN0aXZlX3JlcXVlc3Rfc2xvdCAqc2xvdCkKewoJYWN0aXZlX3JlcXVlc3RzLS07CglzbG90LT5pbl91c2UgPSAwOwp9CgpzdGF0aWMgdm9pZCByZWxlYXNlX2FjdGl2ZV9zbG90KHN0cnVjdCBhY3RpdmVfcmVxdWVzdF9zbG90ICpzbG90KQp7CgljbG9zZWRvd25fYWN0aXZlX3Nsb3Qoc2xvdCk7CglpZiAoc2xvdC0+Y3VybCAmJiBjdXJsX3Nlc3Npb25fY291bnQgPiBtaW5fY3VybF9zZXNzaW9ucykgewojaWZkZWYgVVNFX0NVUkxfTVVMVEkKCQljdXJsX211bHRpX3JlbW92ZV9oYW5kbGUoY3VybG0sIHNsb3QtPmN1cmwpOwojZW5kaWYKCQljdXJsX2Vhc3lfY2xlYW51cChzbG90LT5jdXJsKTsKCQlzbG90LT5jdXJsID0gTlVMTDsKCQljdXJsX3Nlc3Npb25fY291bnQtLTsKCX0KI2lmZGVmIFVTRV9DVVJMX01VTFRJCglmaWxsX2FjdGl2ZV9zbG90cygpOwojZW5kaWYKfQoKdm9pZCBmaW5pc2hfYWN0aXZlX3Nsb3Qoc3RydWN0IGFjdGl2ZV9yZXF1ZXN0X3Nsb3QgKnNsb3QpCnsKCWNsb3NlZG93bl9hY3RpdmVfc2xvdChzbG90KTsKCWN1cmxfZWFzeV9nZXRpbmZvKHNsb3QtPmN1cmwsIENVUkxJTkZPX0hUVFBfQ09ERSwgJnNsb3QtPmh0dHBfY29kZSk7CgoJaWYgKHNsb3QtPmZpbmlzaGVkICE9IE5VTEwpCgkJKCpzbG90LT5maW5pc2hlZCkgPSAxOwoKCS8qIFN0b3JlIHNsb3QgcmVzdWx0cyBzbyB0aGV5IGNhbiBiZSByZWFkIGFmdGVyIHRoZSBzbG90IGlzIHJldXNlZCAqLwoJaWYgKHNsb3QtPnJlc3VsdHMgIT0gTlVMTCkgewoJCXNsb3QtPnJlc3VsdHMtPmN1cmxfcmVzdWx0ID0gc2xvdC0+Y3VybF9yZXN1bHQ7CgkJc2xvdC0+cmVzdWx0cy0+aHR0cF9jb2RlID0gc2xvdC0+aHR0cF9jb2RlOwoJfQoKCS8qIFJ1biBjYWxsYmFjayBpZiBhcHByb3ByaWF0ZSAqLwoJaWYgKHNsb3QtPmNhbGxiYWNrX2Z1bmMgIT0gTlVMTCkKCQlzbG90LT5jYWxsYmFja19mdW5jKHNsb3QtPmNhbGxiYWNrX2RhdGEpOwp9Cgp2b2lkIGZpbmlzaF9hbGxfYWN0aXZlX3Nsb3RzKHZvaWQpCnsKCXN0cnVjdCBhY3RpdmVfcmVxdWVzdF9zbG90ICpzbG90ID0gYWN0aXZlX3F1ZXVlX2hlYWQ7CgoJd2hpbGUgKHNsb3QgIT0gTlVMTCkKCQlpZiAoc2xvdC0+aW5fdXNlKSB7CgkJCXJ1bl9hY3RpdmVfc2xvdChzbG90KTsKCQkJc2xvdCA9IGFjdGl2ZV9xdWV1ZV9oZWFkOwoJCX0gZWxzZSB7CgkJCXNsb3QgPSBzbG90LT5uZXh0OwoJCX0KfQoKLyogSGVscGVycyBmb3IgbW9kaWZ5aW5nIGFuZCBjcmVhdGluZyBVUkxzICovCnN0YXRpYyBpbmxpbmUgaW50IG5lZWRzX3F1b3RlKGludCBjaCkKewoJaWYgKCgoY2ggPj0gJ0EnKSAmJiAoY2ggPD0gJ1onKSkKCQkJfHwgKChjaCA+PSAnYScpICYmIChjaCA8PSAneicpKQoJCQl8fCAoKGNoID49ICcwJykgJiYgKGNoIDw9ICc5JykpCgkJCXx8IChjaCA9PSAnLycpCgkJCXx8IChjaCA9PSAnLScpCgkJCXx8IChjaCA9PSAnLicpKQoJCXJldHVybiAwOwoJcmV0dXJuIDE7Cn0KCnN0YXRpYyBpbmxpbmUgaW50IGhleChpbnQgdikKewoJaWYgKHYgPCAxMCkKCQlyZXR1cm4gJzAnICsgdjsKCWVsc2UKCQlyZXR1cm4gJ0EnICsgdiAtIDEwOwp9CgpzdGF0aWMgY2hhciAqcXVvdGVfcmVmX3VybChjb25zdCBjaGFyICpiYXNlLCBjb25zdCBjaGFyICpyZWYpCnsKCXN0cnVjdCBzdHJidWYgYnVmID0gU1RSQlVGX0lOSVQ7Cgljb25zdCBjaGFyICpjcDsKCWludCBjaDsKCgllbmRfdXJsX3dpdGhfc2xhc2goJmJ1ZiwgYmFzZSk7CgoJZm9yIChjcCA9IHJlZjsgKGNoID0gKmNwKSAhPSAwOyBjcCsrKQoJCWlmIChuZWVkc19xdW90ZShjaCkpCgkJCXN0cmJ1Zl9hZGRmKCZidWYsICIlJSUwMngiLCBjaCk7CgkJZWxzZQoJCQlzdHJidWZfYWRkY2goJmJ1ZiwgKmNwKTsKCglyZXR1cm4gc3RyYnVmX2RldGFjaCgmYnVmLCBOVUxMKTsKfQoKdm9pZCBhcHBlbmRfcmVtb3RlX29iamVjdF91cmwoc3RydWN0IHN0cmJ1ZiAqYnVmLCBjb25zdCBjaGFyICp1cmwsCgkJCSAgICAgIGNvbnN0IGNoYXIgKmhleCwKCQkJICAgICAgaW50IG9ubHlfdHdvX2RpZ2l0X3ByZWZpeCkKewoJZW5kX3VybF93aXRoX3NsYXNoKGJ1ZiwgdXJsKTsKCglzdHJidWZfYWRkZihidWYsICJvYmplY3RzLyUuKnMvIiwgMiwgaGV4KTsKCWlmICghb25seV90d29fZGlnaXRfcHJlZml4KQoJCXN0cmJ1Zl9hZGRmKGJ1ZiwgIiVzIiwgaGV4KzIpOwp9CgpjaGFyICpnZXRfcmVtb3RlX29iamVjdF91cmwoY29uc3QgY2hhciAqdXJsLCBjb25zdCBjaGFyICpoZXgsCgkJCSAgICBpbnQgb25seV90d29fZGlnaXRfcHJlZml4KQp7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoJYXBwZW5kX3JlbW90ZV9vYmplY3RfdXJsKCZidWYsIHVybCwgaGV4LCBvbmx5X3R3b19kaWdpdF9wcmVmaXgpOwoJcmV0dXJuIHN0cmJ1Zl9kZXRhY2goJmJ1ZiwgTlVMTCk7Cn0KCi8qIGh0dHBfcmVxdWVzdCgpIHRhcmdldHMgKi8KI2RlZmluZSBIVFRQX1JFUVVFU1RfU1RSQlVGCTAKI2RlZmluZSBIVFRQX1JFUVVFU1RfRklMRQkxCgpzdGF0aWMgaW50IGh0dHBfcmVxdWVzdChjb25zdCBjaGFyICp1cmwsIHZvaWQgKnJlc3VsdCwgaW50IHRhcmdldCwgaW50IG9wdGlvbnMpCnsKCXN0cnVjdCBhY3RpdmVfcmVxdWVzdF9zbG90ICpzbG90OwoJc3RydWN0IHNsb3RfcmVzdWx0cyByZXN1bHRzOwoJc3RydWN0IGN1cmxfc2xpc3QgKmhlYWRlcnMgPSBOVUxMOwoJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCWludCByZXQ7CgoJc2xvdCA9IGdldF9hY3RpdmVfc2xvdCgpOwoJc2xvdC0+cmVzdWx0cyA9ICZyZXN1bHRzOwoJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX0hUVFBHRVQsIDEpOwoKCWlmIChyZXN1bHQgPT0gTlVMTCkgewoJCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9OT0JPRFksIDEpOwoJfSBlbHNlIHsKCQljdXJsX2Vhc3lfc2V0b3B0KHNsb3QtPmN1cmwsIENVUkxPUFRfTk9CT0RZLCAwKTsKCQljdXJsX2Vhc3lfc2V0b3B0KHNsb3QtPmN1cmwsIENVUkxPUFRfRklMRSwgcmVzdWx0KTsKCgkJaWYgKHRhcmdldCA9PSBIVFRQX1JFUVVFU1RfRklMRSkgewoJCQlsb25nIHBvc24gPSBmdGVsbChyZXN1bHQpOwoJCQljdXJsX2Vhc3lfc2V0b3B0KHNsb3QtPmN1cmwsIENVUkxPUFRfV1JJVEVGVU5DVElPTiwKCQkJCQkgZndyaXRlKTsKCQkJaWYgKHBvc24gPiAwKSB7CgkJCQlzdHJidWZfYWRkZigmYnVmLCAiUmFuZ2U6IGJ5dGVzPSVsZC0iLCBwb3NuKTsKCQkJCWhlYWRlcnMgPSBjdXJsX3NsaXN0X2FwcGVuZChoZWFkZXJzLCBidWYuYnVmKTsKCQkJCXN0cmJ1Zl9yZXNldCgmYnVmKTsKCQkJfQoJCQlzbG90LT5sb2NhbCA9IHJlc3VsdDsKCQl9IGVsc2UKCQkJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX1dSSVRFRlVOQ1RJT04sCgkJCQkJIGZ3cml0ZV9idWZmZXIpOwoJfQoKCXN0cmJ1Zl9hZGRzdHIoJmJ1ZiwgIlByYWdtYToiKTsKCWlmIChvcHRpb25zICYgSFRUUF9OT19DQUNIRSkKCQlzdHJidWZfYWRkc3RyKCZidWYsICIgbm8tY2FjaGUiKTsKCgloZWFkZXJzID0gY3VybF9zbGlzdF9hcHBlbmQoaGVhZGVycywgYnVmLmJ1Zik7CgoJY3VybF9lYXN5X3NldG9wdChzbG90LT5jdXJsLCBDVVJMT1BUX1VSTCwgdXJsKTsKCWN1cmxfZWFzeV9zZXRvcHQoc2xvdC0+Y3VybCwgQ1VSTE9QVF9IVFRQSEVBREVSLCBoZWFkZXJzKTsKCglpZiAoc3RhcnRfYWN0aXZlX3Nsb3Qoc2xvdCkpIHsKCQlydW5fYWN0aXZlX3Nsb3Qoc2xvdCk7CgkJaWYgKHJlc3VsdHMuY3VybF9yZXN1bHQgPT0gQ1VSTEVfT0spCgkJCXJldCA9IEhUVFBfT0s7CgkJZWxzZSBpZiAobWlzc2luZ190YXJnZXQoJnJlc3VsdHMpKQoJCQlyZXQgPSBIVFRQX01JU1NJTkdfVEFSR0VUOwoJCWVsc2UgaWYgKHJlc3VsdHMuaHR0cF9jb2RlID09IDQwMSkgewoJCQlpZiAodXNlcl9uYW1lICYmIHVzZXJfcGFzcykgewoJCQkJcmV0ID0gSFRUUF9OT0FVVEg7CgkJCX0gZWxzZSB7CgkJCQkvKgoJCQkJICogZ2l0X2dldHBhc3MgaXMgbmVlZGVkIGhlcmUgYmVjYXVzZSBpdHMgdmVyeSBsaWtlbHkgc3RkaW4vc3Rkb3V0IGFyZQoJCQkJICogcGlwZXMgdG8gb3VyIHBhcmVudCBwcm9jZXNzLiAgU28gd2UgaW5zdGVhZCBuZWVkIHRvIHVzZSAvZGV2L3R0eSwKCQkJCSAqIGJ1dCB0aGF0IGlzIG5vbi1wb3J0YWJsZS4gIFVzaW5nIGdpdF9nZXRwYXNzKCkgY2FuIGF0IGxlYXN0IGJlIHN0dWJiZWQKCQkJCSAqIG9uIG90aGVyIHBsYXRmb3JtcyB3aXRoIGEgZGlmZmVyZW50IGltcGxlbWVudGF0aW9uIGlmL3doZW4gbmVjZXNzYXJ5LgoJCQkJICovCgkJCQlpZiAoIXVzZXJfbmFtZSkKCQkJCQl1c2VyX25hbWUgPSB4c3RyZHVwKGdpdF9nZXRwYXNzX3dpdGhfZGVzY3JpcHRpb24oIlVzZXJuYW1lIiwgZGVzY3JpcHRpb24pKTsKCQkJCWluaXRfY3VybF9odHRwX2F1dGgoc2xvdC0+Y3VybCk7CgkJCQlyZXQgPSBIVFRQX1JFQVVUSDsKCQkJfQoJCX0gZWxzZSB7CgkJCWlmICghY3VybF9lcnJvcnN0clswXSkKCQkJCXN0cmxjcHkoY3VybF9lcnJvcnN0ciwKCQkJCQljdXJsX2Vhc3lfc3RyZXJyb3IocmVzdWx0cy5jdXJsX3Jlc3VsdCksCgkJCQkJc2l6ZW9mKGN1cmxfZXJyb3JzdHIpKTsKCQkJcmV0ID0gSFRUUF9FUlJPUjsKCQl9Cgl9IGVsc2UgewoJCWVycm9yKCJVbmFibGUgdG8gc3RhcnQgSFRUUCByZXF1ZXN0IGZvciAlcyIsIHVybCk7CgkJcmV0ID0gSFRUUF9TVEFSVF9GQUlMRUQ7Cgl9CgoJc2xvdC0+bG9jYWwgPSBOVUxMOwoJY3VybF9zbGlzdF9mcmVlX2FsbChoZWFkZXJzKTsKCXN0cmJ1Zl9yZWxlYXNlKCZidWYpOwoKCXJldHVybiByZXQ7Cn0KCnN0YXRpYyBpbnQgaHR0cF9yZXF1ZXN0X3JlYXV0aChjb25zdCBjaGFyICp1cmwsIHZvaWQgKnJlc3VsdCwgaW50IHRhcmdldCwKCQkJICAgICAgIGludCBvcHRpb25zKQp7CglpbnQgcmV0ID0gaHR0cF9yZXF1ZXN0KHVybCwgcmVzdWx0LCB0YXJnZXQsIG9wdGlvbnMpOwoJaWYgKHJldCAhPSBIVFRQX1JFQVVUSCkKCQlyZXR1cm4gcmV0OwoJcmV0dXJuIGh0dHBfcmVxdWVzdCh1cmwsIHJlc3VsdCwgdGFyZ2V0LCBvcHRpb25zKTsKfQoKaW50IGh0dHBfZ2V0X3N0cmJ1Zihjb25zdCBjaGFyICp1cmwsIHN0cnVjdCBzdHJidWYgKnJlc3VsdCwgaW50IG9wdGlvbnMpCnsKCXJldHVybiBodHRwX3JlcXVlc3RfcmVhdXRoKHVybCwgcmVzdWx0LCBIVFRQX1JFUVVFU1RfU1RSQlVGLCBvcHRpb25zKTsKfQoKLyoKICogRG93bmxvYWRzIGFuIHVybCBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW4gdGhlIGdpdmVuIGZpbGUuCiAqCiAqIElmIGEgcHJldmlvdXMgaW50ZXJydXB0ZWQgZG93bmxvYWQgaXMgZGV0ZWN0ZWQgKGkuZS4gYSBwcmV2aW91cyB0ZW1wb3JhcnkKICogZmlsZSBpcyBzdGlsbCBhcm91bmQpIHRoZSBkb3dubG9hZCBpcyByZXN1bWVkLgogKi8Kc3RhdGljIGludCBodHRwX2dldF9maWxlKGNvbnN0IGNoYXIgKnVybCwgY29uc3QgY2hhciAqZmlsZW5hbWUsIGludCBvcHRpb25zKQp7CglpbnQgcmV0OwoJc3RydWN0IHN0cmJ1ZiB0bXBmaWxlID0gU1RSQlVGX0lOSVQ7CglGSUxFICpyZXN1bHQ7CgoJc3RyYnVmX2FkZGYoJnRtcGZpbGUsICIlcy50ZW1wIiwgZmlsZW5hbWUpOwoJcmVzdWx0ID0gZm9wZW4odG1wZmlsZS5idWYsICJhIik7CglpZiAoISByZXN1bHQpIHsKCQllcnJvcigiVW5hYmxlIHRvIG9wZW4gbG9jYWwgZmlsZSAlcyIsIHRtcGZpbGUuYnVmKTsKCQlyZXQgPSBIVFRQX0VSUk9SOwoJCWdvdG8gY2xlYW51cDsKCX0KCglyZXQgPSBodHRwX3JlcXVlc3RfcmVhdXRoKHVybCwgcmVzdWx0LCBIVFRQX1JFUVVFU1RfRklMRSwgb3B0aW9ucyk7CglmY2xvc2UocmVzdWx0KTsKCglpZiAoKHJldCA9PSBIVFRQX09LKSAmJiBtb3ZlX3RlbXBfdG9fZmlsZSh0bXBmaWxlLmJ1ZiwgZmlsZW5hbWUpKQoJCXJldCA9IEhUVFBfRVJST1I7CmNsZWFudXA6CglzdHJidWZfcmVsZWFzZSgmdG1wZmlsZSk7CglyZXR1cm4gcmV0Owp9CgppbnQgaHR0cF9lcnJvcihjb25zdCBjaGFyICp1cmwsIGludCByZXQpCnsKCS8qIGh0dHBfcmVxdWVzdCBoYXMgYWxyZWFkeSBoYW5kbGVkIEhUVFBfU1RBUlRfRkFJTEVELiAqLwoJaWYgKHJldCAhPSBIVFRQX1NUQVJUX0ZBSUxFRCkKCQllcnJvcigiJXMgd2hpbGUgYWNjZXNzaW5nICVzIiwgY3VybF9lcnJvcnN0ciwgdXJsKTsKCglyZXR1cm4gcmV0Owp9CgppbnQgaHR0cF9mZXRjaF9yZWYoY29uc3QgY2hhciAqYmFzZSwgc3RydWN0IHJlZiAqcmVmKQp7CgljaGFyICp1cmw7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZmZlciA9IFNUUkJVRl9JTklUOwoJaW50IHJldCA9IC0xOwoKCXVybCA9IHF1b3RlX3JlZl91cmwoYmFzZSwgcmVmLT5uYW1lKTsKCWlmIChodHRwX2dldF9zdHJidWYodXJsLCAmYnVmZmVyLCBIVFRQX05PX0NBQ0hFKSA9PSBIVFRQX09LKSB7CgkJc3RyYnVmX3J0cmltKCZidWZmZXIpOwoJCWlmIChidWZmZXIubGVuID09IDQwKQoJCQlyZXQgPSBnZXRfc2hhMV9oZXgoYnVmZmVyLmJ1ZiwgcmVmLT5vbGRfc2hhMSk7CgkJZWxzZSBpZiAoIXByZWZpeGNtcChidWZmZXIuYnVmLCAicmVmOiAiKSkgewoJCQlyZWYtPnN5bXJlZiA9IHhzdHJkdXAoYnVmZmVyLmJ1ZiArIDUpOwoJCQlyZXQgPSAwOwoJCX0KCX0KCglzdHJidWZfcmVsZWFzZSgmYnVmZmVyKTsKCWZyZWUodXJsKTsKCXJldHVybiByZXQ7Cn0KCi8qIEhlbHBlcnMgZm9yIGZldGNoaW5nIHBhY2tzICovCnN0YXRpYyBjaGFyICpmZXRjaF9wYWNrX2luZGV4KHVuc2lnbmVkIGNoYXIgKnNoYTEsIGNvbnN0IGNoYXIgKmJhc2VfdXJsKQp7CgljaGFyICp1cmwsICp0bXA7CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoKCWlmIChodHRwX2lzX3ZlcmJvc2UpCgkJZnByaW50ZihzdGRlcnIsICJHZXR0aW5nIGluZGV4IGZvciBwYWNrICVzXG4iLCBzaGExX3RvX2hleChzaGExKSk7CgoJZW5kX3VybF93aXRoX3NsYXNoKCZidWYsIGJhc2VfdXJsKTsKCXN0cmJ1Zl9hZGRmKCZidWYsICJvYmplY3RzL3BhY2svcGFjay0lcy5pZHgiLCBzaGExX3RvX2hleChzaGExKSk7Cgl1cmwgPSBzdHJidWZfZGV0YWNoKCZidWYsIE5VTEwpOwoKCXN0cmJ1Zl9hZGRmKCZidWYsICIlcy50ZW1wIiwgc2hhMV9wYWNrX2luZGV4X25hbWUoc2hhMSkpOwoJdG1wID0gc3RyYnVmX2RldGFjaCgmYnVmLCBOVUxMKTsKCglpZiAoaHR0cF9nZXRfZmlsZSh1cmwsIHRtcCwgMCkgIT0gSFRUUF9PSykgewoJCWVycm9yKCJVbmFibGUgdG8gZ2V0IHBhY2sgaW5kZXggJXNcbiIsIHVybCk7CgkJZnJlZSh0bXApOwoJCXRtcCA9IE5VTEw7Cgl9CgoJZnJlZSh1cmwpOwoJcmV0dXJuIHRtcDsKfQoKc3RhdGljIGludCBmZXRjaF9hbmRfc2V0dXBfcGFja19pbmRleChzdHJ1Y3QgcGFja2VkX2dpdCAqKnBhY2tzX2hlYWQsCgl1bnNpZ25lZCBjaGFyICpzaGExLCBjb25zdCBjaGFyICpiYXNlX3VybCkKewoJc3RydWN0IHBhY2tlZF9naXQgKm5ld19wYWNrOwoJY2hhciAqdG1wX2lkeCA9IE5VTEw7CglpbnQgcmV0OwoKCWlmIChoYXNfcGFja19pbmRleChzaGExKSkgewoJCW5ld19wYWNrID0gcGFyc2VfcGFja19pbmRleChzaGExLCBOVUxMKTsKCQlpZiAoIW5ld19wYWNrKQoJCQlyZXR1cm4gLTE7IC8qIHBhcnNlX3BhY2tfaW5kZXgoKSBhbHJlYWR5IGlzc3VlZCBlcnJvciBtZXNzYWdlICovCgkJZ290byBhZGRfcGFjazsKCX0KCgl0bXBfaWR4ID0gZmV0Y2hfcGFja19pbmRleChzaGExLCBiYXNlX3VybCk7CglpZiAoIXRtcF9pZHgpCgkJcmV0dXJuIC0xOwoKCW5ld19wYWNrID0gcGFyc2VfcGFja19pbmRleChzaGExLCB0bXBfaWR4KTsKCWlmICghbmV3X3BhY2spIHsKCQl1bmxpbmsodG1wX2lkeCk7CgkJZnJlZSh0bXBfaWR4KTsKCgkJcmV0dXJuIC0xOyAvKiBwYXJzZV9wYWNrX2luZGV4KCkgYWxyZWFkeSBpc3N1ZWQgZXJyb3IgbWVzc2FnZSAqLwoJfQoKCXJldCA9IHZlcmlmeV9wYWNrX2luZGV4KG5ld19wYWNrKTsKCWlmICghcmV0KSB7CgkJY2xvc2VfcGFja19pbmRleChuZXdfcGFjayk7CgkJcmV0ID0gbW92ZV90ZW1wX3RvX2ZpbGUodG1wX2lkeCwgc2hhMV9wYWNrX2luZGV4X25hbWUoc2hhMSkpOwoJfQoJZnJlZSh0bXBfaWR4KTsKCWlmIChyZXQpCgkJcmV0dXJuIC0xOwoKYWRkX3BhY2s6CgluZXdfcGFjay0+bmV4dCA9ICpwYWNrc19oZWFkOwoJKnBhY2tzX2hlYWQgPSBuZXdfcGFjazsKCXJldHVybiAwOwp9CgppbnQgaHR0cF9nZXRfaW5mb19wYWNrcyhjb25zdCBjaGFyICpiYXNlX3VybCwgc3RydWN0IHBhY2tlZF9naXQgKipwYWNrc19oZWFkKQp7CglpbnQgcmV0ID0gMCwgaSA9IDA7CgljaGFyICp1cmwsICpkYXRhOwoJc3RydWN0IHN0cmJ1ZiBidWYgPSBTVFJCVUZfSU5JVDsKCXVuc2lnbmVkIGNoYXIgc2hhMVsyMF07CgoJZW5kX3VybF93aXRoX3NsYXNoKCZidWYsIGJhc2VfdXJsKTsKCXN0cmJ1Zl9hZGRzdHIoJmJ1ZiwgIm9iamVjdHMvaW5mby9wYWNrcyIpOwoJdXJsID0gc3RyYnVmX2RldGFjaCgmYnVmLCBOVUxMKTsKCglyZXQgPSBodHRwX2dldF9zdHJidWYodXJsLCAmYnVmLCBIVFRQX05PX0NBQ0hFKTsKCWlmIChyZXQgIT0gSFRUUF9PSykKCQlnb3RvIGNsZWFudXA7CgoJZGF0YSA9IGJ1Zi5idWY7Cgl3aGlsZSAoaSA8IGJ1Zi5sZW4pIHsKCQlzd2l0Y2ggKGRhdGFbaV0pIHsKCQljYXNlICdQJzoKCQkJaSsrOwoJCQlpZiAoaSArIDUyIDw9IGJ1Zi5sZW4gJiYKCQkJICAgICFwcmVmaXhjbXAoZGF0YSArIGksICIgcGFjay0iKSAmJgoJCQkgICAgIXByZWZpeGNtcChkYXRhICsgaSArIDQ2LCAiLnBhY2tcbiIpKSB7CgkJCQlnZXRfc2hhMV9oZXgoZGF0YSArIGkgKyA2LCBzaGExKTsKCQkJCWZldGNoX2FuZF9zZXR1cF9wYWNrX2luZGV4KHBhY2tzX2hlYWQsIHNoYTEsCgkJCQkJCSAgICAgIGJhc2VfdXJsKTsKCQkJCWkgKz0gNTE7CgkJCQlicmVhazsKCQkJfQoJCWRlZmF1bHQ6CgkJCXdoaWxlIChpIDwgYnVmLmxlbiAmJiBkYXRhW2ldICE9ICdcbicpCgkJCQlpKys7CgkJfQoJCWkrKzsKCX0KCmNsZWFudXA6CglmcmVlKHVybCk7CglyZXR1cm4gcmV0Owp9Cgp2b2lkIHJlbGVhc2VfaHR0cF9wYWNrX3JlcXVlc3Qoc3RydWN0IGh0dHBfcGFja19yZXF1ZXN0ICpwcmVxKQp7CglpZiAocHJlcS0+cGFja2ZpbGUgIT0gTlVMTCkgewoJCWZjbG9zZShwcmVxLT5wYWNrZmlsZSk7CgkJcHJlcS0+cGFja2ZpbGUgPSBOVUxMOwoJCXByZXEtPnNsb3QtPmxvY2FsID0gTlVMTDsKCX0KCWlmIChwcmVxLT5yYW5nZV9oZWFkZXIgIT0gTlVMTCkgewoJCWN1cmxfc2xpc3RfZnJlZV9hbGwocHJlcS0+cmFuZ2VfaGVhZGVyKTsKCQlwcmVxLT5yYW5nZV9oZWFkZXIgPSBOVUxMOwoJfQoJcHJlcS0+c2xvdCA9IE5VTEw7CglmcmVlKHByZXEtPnVybCk7Cn0KCmludCBmaW5pc2hfaHR0cF9wYWNrX3JlcXVlc3Qoc3RydWN0IGh0dHBfcGFja19yZXF1ZXN0ICpwcmVxKQp7CglzdHJ1Y3QgcGFja2VkX2dpdCAqKmxzdDsKCXN0cnVjdCBwYWNrZWRfZ2l0ICpwID0gcHJlcS0+dGFyZ2V0OwoJY2hhciAqdG1wX2lkeDsKCXN0cnVjdCBjaGlsZF9wcm9jZXNzIGlwOwoJY29uc3QgY2hhciAqaXBfYXJndls4XTsKCgljbG9zZV9wYWNrX2luZGV4KHApOwoKCWZjbG9zZShwcmVxLT5wYWNrZmlsZSk7CglwcmVxLT5wYWNrZmlsZSA9IE5VTEw7CglwcmVxLT5zbG90LT5sb2NhbCA9IE5VTEw7CgoJbHN0ID0gcHJlcS0+bHN0OwoJd2hpbGUgKCpsc3QgIT0gcCkKCQlsc3QgPSAmKCgqbHN0KS0+bmV4dCk7CgkqbHN0ID0gKCpsc3QpLT5uZXh0OwoKCXRtcF9pZHggPSB4c3RyZHVwKHByZXEtPnRtcGZpbGUpOwoJc3RyY3B5KHRtcF9pZHggKyBzdHJsZW4odG1wX2lkeCkgLSBzdHJsZW4oIi5wYWNrLnRlbXAiKSwKCSAgICAgICAiLmlkeC50ZW1wIik7CgoJaXBfYXJndlswXSA9ICJpbmRleC1wYWNrIjsKCWlwX2FyZ3ZbMV0gPSAiLW8iOwoJaXBfYXJndlsyXSA9IHRtcF9pZHg7CglpcF9hcmd2WzNdID0gcHJlcS0+dG1wZmlsZTsKCWlwX2FyZ3ZbNF0gPSBOVUxMOwoKCW1lbXNldCgmaXAsIDAsIHNpemVvZihpcCkpOwoJaXAuYXJndiA9IGlwX2FyZ3Y7CglpcC5naXRfY21kID0gMTsKCWlwLm5vX3N0ZGluID0gMTsKCWlwLm5vX3N0ZG91dCA9IDE7CgoJaWYgKHJ1bl9jb21tYW5kKCZpcCkpIHsKCQl1bmxpbmsocHJlcS0+dG1wZmlsZSk7CgkJdW5saW5rKHRtcF9pZHgpOwoJCWZyZWUodG1wX2lkeCk7CgkJcmV0dXJuIC0xOwoJfQoKCXVubGluayhzaGExX3BhY2tfaW5kZXhfbmFtZShwLT5zaGExKSk7CgoJaWYgKG1vdmVfdGVtcF90b19maWxlKHByZXEtPnRtcGZpbGUsIHNoYTFfcGFja19uYW1lKHAtPnNoYTEpKQoJIHx8IG1vdmVfdGVtcF90b19maWxlKHRtcF9pZHgsIHNoYTFfcGFja19pbmRleF9uYW1lKHAtPnNoYTEpKSkgewoJCWZyZWUodG1wX2lkeCk7CgkJcmV0dXJuIC0xOwoJfQoKCWluc3RhbGxfcGFja2VkX2dpdChwKTsKCWZyZWUodG1wX2lkeCk7CglyZXR1cm4gMDsKfQoKc3RydWN0IGh0dHBfcGFja19yZXF1ZXN0ICpuZXdfaHR0cF9wYWNrX3JlcXVlc3QoCglzdHJ1Y3QgcGFja2VkX2dpdCAqdGFyZ2V0LCBjb25zdCBjaGFyICpiYXNlX3VybCkKewoJbG9uZyBwcmV2X3Bvc24gPSAwOwoJY2hhciByYW5nZVtSQU5HRV9IRUFERVJfU0laRV07CglzdHJ1Y3Qgc3RyYnVmIGJ1ZiA9IFNUUkJVRl9JTklUOwoJc3RydWN0IGh0dHBfcGFja19yZXF1ZXN0ICpwcmVxOwoKCXByZXEgPSB4Y2FsbG9jKDEsIHNpemVvZigqcHJlcSkpOwoJcHJlcS0+dGFyZ2V0ID0gdGFyZ2V0OwoKCWVuZF91cmxfd2l0aF9zbGFzaCgmYnVmLCBiYXNlX3VybCk7CglzdHJidWZfYWRkZigmYnVmLCAib2JqZWN0cy9wYWNrL3BhY2stJXMucGFjayIsCgkJc2hhMV90b19oZXgodGFyZ2V0LT5zaGExKSk7CglwcmVxLT51cmwgPSBzdHJidWZfZGV0YWNoKCZidWYsIE5VTEwpOwoKCXNucHJpbnRmKHByZXEtPnRtcGZpbGUsIHNpemVvZihwcmVxLT50bXBmaWxlKSwgIiVzLnRlbXAiLAoJCXNoYTFfcGFja19uYW1lKHRhcmdldC0+c2hhMSkpOwoJcHJlcS0+cGFja2ZpbGUgPSBmb3BlbihwcmVxLT50bXBmaWxlLCAiYSIpOwoJaWYgKCFwcmVxLT5wYWNrZmlsZSkgewoJCWVycm9yKCJVbmFibGUgdG8gb3BlbiBsb2NhbCBmaWxlICVzIGZvciBwYWNrIiwKCQkgICAgICBwcmVxLT50bXBmaWxlKTsKCQlnb3RvIGFib3J0OwoJfQoKCXByZXEtPnNsb3QgPSBnZXRfYWN0aXZlX3Nsb3QoKTsKCXByZXEtPnNsb3QtPmxvY2FsID0gcHJlcS0+cGFja2ZpbGU7CgljdXJsX2Vhc3lfc2V0b3B0KHByZXEtPnNsb3QtPmN1cmwsIENVUkxPUFRfRklMRSwgcHJlcS0+cGFja2ZpbGUpOwoJY3VybF9lYXN5X3NldG9wdChwcmVxLT5zbG90LT5jdXJsLCBDVVJMT1BUX1dSSVRFRlVOQ1RJT04sIGZ3cml0ZSk7CgljdXJsX2Vhc3lfc2V0b3B0KHByZXEtPnNsb3QtPmN1cmwsIENVUkxPUFRfVVJMLCBwcmVxLT51cmwpOwoJY3VybF9lYXN5X3NldG9wdChwcmVxLT5zbG90LT5jdXJsLCBDVVJMT1BUX0hUVFBIRUFERVIsCgkJbm9fcHJhZ21hX2hlYWRlcik7CgoJLyoKCSAqIElmIHRoZXJlIGlzIGRhdGEgcHJlc2VudCBmcm9tIGEgcHJldmlvdXMgdHJhbnNmZXIgYXR0ZW1wdCwKCSAqIHJlc3VtZSB3aGVyZSBpdCBsZWZ0IG9mZgoJICovCglwcmV2X3Bvc24gPSBmdGVsbChwcmVxLT5wYWNrZmlsZSk7CglpZiAocHJldl9wb3NuPjApIHsKCQlpZiAoaHR0cF9pc192ZXJib3NlKQoJCQlmcHJpbnRmKHN0ZGVyciwKCQkJCSJSZXN1bWluZyBmZXRjaCBvZiBwYWNrICVzIGF0IGJ5dGUgJWxkXG4iLAoJCQkJc2hhMV90b19oZXgodGFyZ2V0LT5zaGExKSwgcHJldl9wb3NuKTsKCQlzcHJpbnRmKHJhbmdlLCAiUmFuZ2U6IGJ5dGVzPSVsZC0iLCBwcmV2X3Bvc24pOwoJCXByZXEtPnJhbmdlX2hlYWRlciA9IGN1cmxfc2xpc3RfYXBwZW5kKE5VTEwsIHJhbmdlKTsKCQljdXJsX2Vhc3lfc2V0b3B0KHByZXEtPnNsb3QtPmN1cmwsIENVUkxPUFRfSFRUUEhFQURFUiwKCQkJcHJlcS0+cmFuZ2VfaGVhZGVyKTsKCX0KCglyZXR1cm4gcHJlcTsKCmFib3J0OgoJZnJlZShwcmVxLT51cmwpOwoJZnJlZShwcmVxKTsKCXJldHVybiBOVUxMOwp9CgovKiBIZWxwZXJzIGZvciBmZXRjaGluZyBvYmplY3RzIChsb29zZSkgKi8Kc3RhdGljIHNpemVfdCBmd3JpdGVfc2hhMV9maWxlKGNoYXIgKnB0ciwgc2l6ZV90IGVsdHNpemUsIHNpemVfdCBubWVtYiwKCQkJICAgICAgIHZvaWQgKmRhdGEpCnsKCXVuc2lnbmVkIGNoYXIgZXhwbls0MDk2XTsKCXNpemVfdCBzaXplID0gZWx0c2l6ZSAqIG5tZW1iOwoJaW50IHBvc24gPSAwOwoJc3RydWN0IGh0dHBfb2JqZWN0X3JlcXVlc3QgKmZyZXEgPQoJCShzdHJ1Y3QgaHR0cF9vYmplY3RfcmVxdWVzdCAqKWRhdGE7CglkbyB7CgkJc3NpemVfdCByZXR2YWwgPSB4d3JpdGUoZnJlcS0+bG9jYWxmaWxlLAoJCQkJCShjaGFyICopIHB0ciArIHBvc24sIHNpemUgLSBwb3NuKTsKCQlpZiAocmV0dmFsIDwgMCkKCQkJcmV0dXJuIHBvc247CgkJcG9zbiArPSByZXR2YWw7Cgl9IHdoaWxlIChwb3NuIDwgc2l6ZSk7CgoJZnJlcS0+c3RyZWFtLmF2YWlsX2luID0gc2l6ZTsKCWZyZXEtPnN0cmVhbS5uZXh0X2luID0gKHZvaWQgKilwdHI7CglkbyB7CgkJZnJlcS0+c3RyZWFtLm5leHRfb3V0ID0gZXhwbjsKCQlmcmVxLT5zdHJlYW0uYXZhaWxfb3V0ID0gc2l6ZW9mKGV4cG4pOwoJCWZyZXEtPnpyZXQgPSBnaXRfaW5mbGF0ZSgmZnJlcS0+c3RyZWFtLCBaX1NZTkNfRkxVU0gpOwoJCWdpdF9TSEExX1VwZGF0ZSgmZnJlcS0+YywgZXhwbiwKCQkJCXNpemVvZihleHBuKSAtIGZyZXEtPnN0cmVhbS5hdmFpbF9vdXQpOwoJfSB3aGlsZSAoZnJlcS0+c3RyZWFtLmF2YWlsX2luICYmIGZyZXEtPnpyZXQgPT0gWl9PSyk7CglkYXRhX3JlY2VpdmVkKys7CglyZXR1cm4gc2l6ZTsKfQoKc3RydWN0IGh0dHBfb2JqZWN0X3JlcXVlc3QgKm5ld19odHRwX29iamVjdF9yZXF1ZXN0KGNvbnN0IGNoYXIgKmJhc2VfdXJsLAoJdW5zaWduZWQgY2hhciAqc2hhMSkKewoJY2hhciAqaGV4ID0gc2hhMV90b19oZXgoc2hhMSk7CgljaGFyICpmaWxlbmFtZTsKCWNoYXIgcHJldmZpbGVbUEFUSF9NQVhdOwoJaW50IHByZXZsb2NhbDsKCWNoYXIgcHJldl9idWZbUFJFVl9CVUZfU0laRV07Cglzc2l6ZV90IHByZXZfcmVhZCA9IDA7Cglsb25nIHByZXZfcG9zbiA9IDA7CgljaGFyIHJhbmdlW1JBTkdFX0hFQURFUl9TSVpFXTsKCXN0cnVjdCBjdXJsX3NsaXN0ICpyYW5nZV9oZWFkZXIgPSBOVUxMOwoJc3RydWN0IGh0dHBfb2JqZWN0X3JlcXVlc3QgKmZyZXE7CgoJZnJlcSA9IHhjYWxsb2MoMSwgc2l6ZW9mKCpmcmVxKSk7CgloYXNoY3B5KGZyZXEtPnNoYTEsIHNoYTEpOwoJZnJlcS0+bG9jYWxmaWxlID0gLTE7CgoJZmlsZW5hbWUgPSBzaGExX2ZpbGVfbmFtZShzaGExKTsKCXNucHJpbnRmKGZyZXEtPnRtcGZpbGUsIHNpemVvZihmcmVxLT50bXBmaWxlKSwKCQkgIiVzLnRlbXAiLCBmaWxlbmFtZSk7CgoJc25wcmludGYocHJldmZpbGUsIHNpemVvZihwcmV2ZmlsZSksICIlcy5wcmV2IiwgZmlsZW5hbWUpOwoJdW5saW5rX29yX3dhcm4ocHJldmZpbGUpOwoJcmVuYW1lKGZyZXEtPnRtcGZpbGUsIHByZXZmaWxlKTsKCXVubGlua19vcl93YXJuKGZyZXEtPnRtcGZpbGUpOwoKCWlmIChmcmVxLT5sb2NhbGZpbGUgIT0gLTEpCgkJZXJyb3IoImZkIGxlYWthZ2UgaW4gc3RhcnQ6ICVkIiwgZnJlcS0+bG9jYWxmaWxlKTsKCWZyZXEtPmxvY2FsZmlsZSA9IG9wZW4oZnJlcS0+dG1wZmlsZSwKCQkJICAgICAgIE9fV1JPTkxZIHwgT19DUkVBVCB8IE9fRVhDTCwgMDY2Nik7CgkvKgoJICogVGhpcyBjb3VsZCBoYXZlIGZhaWxlZCBkdWUgdG8gdGhlICJsYXp5IGRpcmVjdG9yeSBjcmVhdGlvbiI7CgkgKiB0cnkgdG8gbWtkaXIgdGhlIGxhc3QgcGF0aCBjb21wb25lbnQuCgkgKi8KCWlmIChmcmVxLT5sb2NhbGZpbGUgPCAwICYmIGVycm5vID09IEVOT0VOVCkgewoJCWNoYXIgKmRpciA9IHN0cnJjaHIoZnJlcS0+dG1wZmlsZSwgJy8nKTsKCQlpZiAoZGlyKSB7CgkJCSpkaXIgPSAwOwoJCQlta2RpcihmcmVxLT50bXBmaWxlLCAwNzc3KTsKCQkJKmRpciA9ICcvJzsKCQl9CgkJZnJlcS0+bG9jYWxmaWxlID0gb3BlbihmcmVxLT50bXBmaWxlLAoJCQkJICAgICAgIE9fV1JPTkxZIHwgT19DUkVBVCB8IE9fRVhDTCwgMDY2Nik7Cgl9CgoJaWYgKGZyZXEtPmxvY2FsZmlsZSA8IDApIHsKCQllcnJvcigiQ291bGRuJ3QgY3JlYXRlIHRlbXBvcmFyeSBmaWxlICVzOiAlcyIsCgkJICAgICAgZnJlcS0+dG1wZmlsZSwgc3RyZXJyb3IoZXJybm8pKTsKCQlnb3RvIGFib3J0OwoJfQoKCWdpdF9pbmZsYXRlX2luaXQoJmZyZXEtPnN0cmVhbSk7CgoJZ2l0X1NIQTFfSW5pdCgmZnJlcS0+Yyk7CgoJZnJlcS0+dXJsID0gZ2V0X3JlbW90ZV9vYmplY3RfdXJsKGJhc2VfdXJsLCBoZXgsIDApOwoKCS8qCgkgKiBJZiBhIHByZXZpb3VzIHRlbXAgZmlsZSBpcyBwcmVzZW50LCBwcm9jZXNzIHdoYXQgd2FzIGFscmVhZHkKCSAqIGZldGNoZWQuCgkgKi8KCXByZXZsb2NhbCA9IG9wZW4ocHJldmZpbGUsIE9fUkRPTkxZKTsKCWlmIChwcmV2bG9jYWwgIT0gLTEpIHsKCQlkbyB7CgkJCXByZXZfcmVhZCA9IHhyZWFkKHByZXZsb2NhbCwgcHJldl9idWYsIFBSRVZfQlVGX1NJWkUpOwoJCQlpZiAocHJldl9yZWFkPjApIHsKCQkJCWlmIChmd3JpdGVfc2hhMV9maWxlKHByZXZfYnVmLAoJCQkJCQkgICAgIDEsCgkJCQkJCSAgICAgcHJldl9yZWFkLAoJCQkJCQkgICAgIGZyZXEpID09IHByZXZfcmVhZCkgewoJCQkJCXByZXZfcG9zbiArPSBwcmV2X3JlYWQ7CgkJCQl9IGVsc2UgewoJCQkJCXByZXZfcmVhZCA9IC0xOwoJCQkJfQoJCQl9CgkJfSB3aGlsZSAocHJldl9yZWFkID4gMCk7CgkJY2xvc2UocHJldmxvY2FsKTsKCX0KCXVubGlua19vcl93YXJuKHByZXZmaWxlKTsKCgkvKgoJICogUmVzZXQgaW5mbGF0ZS9TSEExIGlmIHRoZXJlIHdhcyBhbiBlcnJvciByZWFkaW5nIHRoZSBwcmV2aW91cyB0ZW1wCgkgKiBmaWxlOyBhbHNvIHJld2luZCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsb2NhbCBmaWxlLgoJICovCglpZiAocHJldl9yZWFkID09IC0xKSB7CgkJbWVtc2V0KCZmcmVxLT5zdHJlYW0sIDAsIHNpemVvZihmcmVxLT5zdHJlYW0pKTsKCQlnaXRfaW5mbGF0ZV9pbml0KCZmcmVxLT5zdHJlYW0pOwoJCWdpdF9TSEExX0luaXQoJmZyZXEtPmMpOwoJCWlmIChwcmV2X3Bvc24+MCkgewoJCQlwcmV2X3Bvc24gPSAwOwoJCQlsc2VlayhmcmVxLT5sb2NhbGZpbGUsIDAsIFNFRUtfU0VUKTsKCQkJaWYgKGZ0cnVuY2F0ZShmcmVxLT5sb2NhbGZpbGUsIDApIDwgMCkgewoJCQkJZXJyb3IoIkNvdWxkbid0IHRydW5jYXRlIHRlbXBvcmFyeSBmaWxlICVzOiAlcyIsCgkJCQkJICBmcmVxLT50bXBmaWxlLCBzdHJlcnJvcihlcnJubykpOwoJCQkJZ290byBhYm9ydDsKCQkJfQoJCX0KCX0KCglmcmVxLT5zbG90ID0gZ2V0X2FjdGl2ZV9zbG90KCk7CgoJY3VybF9lYXN5X3NldG9wdChmcmVxLT5zbG90LT5jdXJsLCBDVVJMT1BUX0ZJTEUsIGZyZXEpOwoJY3VybF9lYXN5X3NldG9wdChmcmVxLT5zbG90LT5jdXJsLCBDVVJMT1BUX1dSSVRFRlVOQ1RJT04sIGZ3cml0ZV9zaGExX2ZpbGUpOwoJY3VybF9lYXN5X3NldG9wdChmcmVxLT5zbG90LT5jdXJsLCBDVVJMT1BUX0VSUk9SQlVGRkVSLCBmcmVxLT5lcnJvcnN0cik7CgljdXJsX2Vhc3lfc2V0b3B0KGZyZXEtPnNsb3QtPmN1cmwsIENVUkxPUFRfVVJMLCBmcmVxLT51cmwpOwoJY3VybF9lYXN5X3NldG9wdChmcmVxLT5zbG90LT5jdXJsLCBDVVJMT1BUX0hUVFBIRUFERVIsIG5vX3ByYWdtYV9oZWFkZXIpOwoKCS8qCgkgKiBJZiB3ZSBoYXZlIHN1Y2Nlc3NmdWxseSBwcm9jZXNzZWQgZGF0YSBmcm9tIGEgcHJldmlvdXMgZmV0Y2gKCSAqIGF0dGVtcHQsIG9ubHkgZmV0Y2ggdGhlIGRhdGEgd2UgZG9uJ3QgYWxyZWFkeSBoYXZlLgoJICovCglpZiAocHJldl9wb3NuPjApIHsKCQlpZiAoaHR0cF9pc192ZXJib3NlKQoJCQlmcHJpbnRmKHN0ZGVyciwKCQkJCSJSZXN1bWluZyBmZXRjaCBvZiBvYmplY3QgJXMgYXQgYnl0ZSAlbGRcbiIsCgkJCQloZXgsIHByZXZfcG9zbik7CgkJc3ByaW50ZihyYW5nZSwgIlJhbmdlOiBieXRlcz0lbGQtIiwgcHJldl9wb3NuKTsKCQlyYW5nZV9oZWFkZXIgPSBjdXJsX3NsaXN0X2FwcGVuZChyYW5nZV9oZWFkZXIsIHJhbmdlKTsKCQljdXJsX2Vhc3lfc2V0b3B0KGZyZXEtPnNsb3QtPmN1cmwsCgkJCQkgQ1VSTE9QVF9IVFRQSEVBREVSLCByYW5nZV9oZWFkZXIpOwoJfQoKCXJldHVybiBmcmVxOwoKYWJvcnQ6CglmcmVlKGZyZXEtPnVybCk7CglmcmVlKGZyZXEpOwoJcmV0dXJuIE5VTEw7Cn0KCnZvaWQgcHJvY2Vzc19odHRwX29iamVjdF9yZXF1ZXN0KHN0cnVjdCBodHRwX29iamVjdF9yZXF1ZXN0ICpmcmVxKQp7CglpZiAoZnJlcS0+c2xvdCA9PSBOVUxMKQoJCXJldHVybjsKCWZyZXEtPmN1cmxfcmVzdWx0ID0gZnJlcS0+c2xvdC0+Y3VybF9yZXN1bHQ7CglmcmVxLT5odHRwX2NvZGUgPSBmcmVxLT5zbG90LT5odHRwX2NvZGU7CglmcmVxLT5zbG90ID0gTlVMTDsKfQoKaW50IGZpbmlzaF9odHRwX29iamVjdF9yZXF1ZXN0KHN0cnVjdCBodHRwX29iamVjdF9yZXF1ZXN0ICpmcmVxKQp7CglzdHJ1Y3Qgc3RhdCBzdDsKCgljbG9zZShmcmVxLT5sb2NhbGZpbGUpOwoJZnJlcS0+bG9jYWxmaWxlID0gLTE7CgoJcHJvY2Vzc19odHRwX29iamVjdF9yZXF1ZXN0KGZyZXEpOwoKCWlmIChmcmVxLT5odHRwX2NvZGUgPT0gNDE2KSB7CgkJd2FybmluZygicmVxdWVzdGVkIHJhbmdlIGludmFsaWQ7IHdlIG1heSBhbHJlYWR5IGhhdmUgYWxsIHRoZSBkYXRhLiIpOwoJfSBlbHNlIGlmIChmcmVxLT5jdXJsX3Jlc3VsdCAhPSBDVVJMRV9PSykgewoJCWlmIChzdGF0KGZyZXEtPnRtcGZpbGUsICZzdCkgPT0gMCkKCQkJaWYgKHN0LnN0X3NpemUgPT0gMCkKCQkJCXVubGlua19vcl93YXJuKGZyZXEtPnRtcGZpbGUpOwoJCXJldHVybiAtMTsKCX0KCglnaXRfaW5mbGF0ZV9lbmQoJmZyZXEtPnN0cmVhbSk7CglnaXRfU0hBMV9GaW5hbChmcmVxLT5yZWFsX3NoYTEsICZmcmVxLT5jKTsKCWlmIChmcmVxLT56cmV0ICE9IFpfU1RSRUFNX0VORCkgewoJCXVubGlua19vcl93YXJuKGZyZXEtPnRtcGZpbGUpOwoJCXJldHVybiAtMTsKCX0KCWlmIChoYXNoY21wKGZyZXEtPnNoYTEsIGZyZXEtPnJlYWxfc2hhMSkpIHsKCQl1bmxpbmtfb3Jfd2FybihmcmVxLT50bXBmaWxlKTsKCQlyZXR1cm4gLTE7Cgl9CglmcmVxLT5yZW5hbWUgPQoJCW1vdmVfdGVtcF90b19maWxlKGZyZXEtPnRtcGZpbGUsIHNoYTFfZmlsZV9uYW1lKGZyZXEtPnNoYTEpKTsKCglyZXR1cm4gZnJlcS0+cmVuYW1lOwp9Cgp2b2lkIGFib3J0X2h0dHBfb2JqZWN0X3JlcXVlc3Qoc3RydWN0IGh0dHBfb2JqZWN0X3JlcXVlc3QgKmZyZXEpCnsKCXVubGlua19vcl93YXJuKGZyZXEtPnRtcGZpbGUpOwoKCXJlbGVhc2VfaHR0cF9vYmplY3RfcmVxdWVzdChmcmVxKTsKfQoKdm9pZCByZWxlYXNlX2h0dHBfb2JqZWN0X3JlcXVlc3Qoc3RydWN0IGh0dHBfb2JqZWN0X3JlcXVlc3QgKmZyZXEpCnsKCWlmIChmcmVxLT5sb2NhbGZpbGUgIT0gLTEpIHsKCQljbG9zZShmcmVxLT5sb2NhbGZpbGUpOwoJCWZyZXEtPmxvY2FsZmlsZSA9IC0xOwoJfQoJaWYgKGZyZXEtPnVybCAhPSBOVUxMKSB7CgkJZnJlZShmcmVxLT51cmwpOwoJCWZyZXEtPnVybCA9IE5VTEw7Cgl9CglpZiAoZnJlcS0+c2xvdCAhPSBOVUxMKSB7CgkJZnJlcS0+c2xvdC0+Y2FsbGJhY2tfZnVuYyA9IE5VTEw7CgkJZnJlcS0+c2xvdC0+Y2FsbGJhY2tfZGF0YSA9IE5VTEw7CgkJcmVsZWFzZV9hY3RpdmVfc2xvdChmcmVxLT5zbG90KTsKCQlmcmVxLT5zbG90ID0gTlVMTDsKCX0KfQo=",
    "text": "#include \"http.h\"\n#include \"pack.h\"\n#include \"sideband.h\"\n#include \"run-command.h\"\n#include \"url.h\"\n\nint data_received;\nint active_requests;\nint http_is_verbose;\nsize_t http_post_buffer = 16 * LARGE_PACKET_MAX;\n\n#if LIBCURL_VERSION_NUM >= 0x070a06\n#define LIBCURL_CAN_HANDLE_AUTH_ANY\n#endif\n\nstatic int min_curl_sessions = 1;\nstatic int curl_session_count;\n#ifdef USE_CURL_MULTI\nstatic int max_requests = -1;\nstatic CURLM *curlm;\n#endif\n#ifndef NO_CURL_EASY_DUPHANDLE\nstatic CURL *curl_default;\n#endif\n\n#define PREV_BUF_SIZE 4096\n#define RANGE_HEADER_SIZE 30\n\nchar curl_errorstr[CURL_ERROR_SIZE];\n\nstatic int curl_ssl_verify = -1;\nstatic const char *ssl_cert;\n#if LIBCURL_VERSION_NUM >= 0x070903\nstatic const char *ssl_key;\n#endif\n#if LIBCURL_VERSION_NUM >= 0x070908\nstatic const char *ssl_capath;\n#endif\nstatic const char *ssl_cainfo;\nstatic long curl_low_speed_limit = -1;\nstatic long curl_low_speed_time = -1;\nstatic int curl_ftp_no_epsv;\nstatic const char *curl_http_proxy;\nstatic const char *curl_cookie_file;\nstatic char *user_name, *user_pass, *description;\nstatic const char *user_agent;\n\n#if LIBCURL_VERSION_NUM >= 0x071700\n/* Use CURLOPT_KEYPASSWD as is */\n#elif LIBCURL_VERSION_NUM >= 0x070903\n#define CURLOPT_KEYPASSWD CURLOPT_SSLKEYPASSWD\n#else\n#define CURLOPT_KEYPASSWD CURLOPT_SSLCERTPASSWD\n#endif\n\nstatic char *ssl_cert_password;\nstatic int ssl_cert_password_required;\n\nstatic struct curl_slist *pragma_header;\nstatic struct curl_slist *no_pragma_header;\n\nstatic struct active_request_slot *active_queue_head;\n\nsize_t fread_buffer(char *ptr, size_t eltsize, size_t nmemb, void *buffer_)\n{\n\tsize_t size = eltsize * nmemb;\n\tstruct buffer *buffer = buffer_;\n\n\tif (size > buffer->buf.len - buffer->posn)\n\t\tsize = buffer->buf.len - buffer->posn;\n\tmemcpy(ptr, buffer->buf.buf + buffer->posn, size);\n\tbuffer->posn += size;\n\n\treturn size;\n}\n\n#ifndef NO_CURL_IOCTL\ncurlioerr ioctl_buffer(CURL *handle, int cmd, void *clientp)\n{\n\tstruct buffer *buffer = clientp;\n\n\tswitch (cmd) {\n\tcase CURLIOCMD_NOP:\n\t\treturn CURLIOE_OK;\n\n\tcase CURLIOCMD_RESTARTREAD:\n\t\tbuffer->posn = 0;\n\t\treturn CURLIOE_OK;\n\n\tdefault:\n\t\treturn CURLIOE_UNKNOWNCMD;\n\t}\n}\n#endif\n\nsize_t fwrite_buffer(char *ptr, size_t eltsize, size_t nmemb, void *buffer_)\n{\n\tsize_t size = eltsize * nmemb;\n\tstruct strbuf *buffer = buffer_;\n\n\tstrbuf_add(buffer, ptr, size);\n\tdata_received++;\n\treturn size;\n}\n\nsize_t fwrite_null(char *ptr, size_t eltsize, size_t nmemb, void *strbuf)\n{\n\tdata_received++;\n\treturn eltsize * nmemb;\n}\n\n#ifdef USE_CURL_MULTI\nstatic void process_curl_messages(void)\n{\n\tint num_messages;\n\tstruct active_request_slot *slot;\n\tCURLMsg *curl_message = curl_multi_info_read(curlm, &num_messages);\n\n\twhile (curl_message != NULL) {\n\t\tif (curl_message->msg == CURLMSG_DONE) {\n\t\t\tint curl_result = curl_message->data.result;\n\t\t\tslot = active_queue_head;\n\t\t\twhile (slot != NULL &&\n\t\t\t       slot->curl != curl_message->easy_handle)\n\t\t\t\tslot = slot->next;\n\t\t\tif (slot != NULL) {\n\t\t\t\tcurl_multi_remove_handle(curlm, slot->curl);\n\t\t\t\tslot->curl_result = curl_result;\n\t\t\t\tfinish_active_slot(slot);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"Received DONE message for unknown request!\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tfprintf(stderr, \"Unknown CURL message received: %d\\n\",\n\t\t\t\t(int)curl_message->msg);\n\t\t}\n\t\tcurl_message = curl_multi_info_read(curlm, &num_messages);\n\t}\n}\n#endif\n\nstatic char *git_getpass_with_description(const char *what, const char *desc)\n{\n\tstruct strbuf prompt = STRBUF_INIT;\n\tchar *r;\n\n\tif (desc)\n\t\tstrbuf_addf(&prompt, \"%s for '%s': \", what, desc);\n\telse\n\t\tstrbuf_addf(&prompt, \"%s: \", what);\n\t/*\n\t * NEEDSWORK: for usernames, we should do something less magical that\n\t * actually echoes the characters. However, we need to read from\n\t * /dev/tty and not stdio, which is not portable (but getpass will do\n\t * it for us). http.c uses the same workaround.\n\t */\n\tr = git_getpass(prompt.buf);\n\n\tstrbuf_release(&prompt);\n\treturn xstrdup(r);\n}\n\nstatic int http_options(const char *var, const char *value, void *cb)\n{\n\tif (!strcmp(\"http.sslverify\", var)) {\n\t\tcurl_ssl_verify = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\tif (!strcmp(\"http.sslcert\", var))\n\t\treturn git_config_string(&ssl_cert, var, value);\n#if LIBCURL_VERSION_NUM >= 0x070903\n\tif (!strcmp(\"http.sslkey\", var))\n\t\treturn git_config_string(&ssl_key, var, value);\n#endif\n#if LIBCURL_VERSION_NUM >= 0x070908\n\tif (!strcmp(\"http.sslcapath\", var))\n\t\treturn git_config_string(&ssl_capath, var, value);\n#endif\n\tif (!strcmp(\"http.sslcainfo\", var))\n\t\treturn git_config_string(&ssl_cainfo, var, value);\n\tif (!strcmp(\"http.sslcertpasswordprotected\", var)) {\n\t\tif (git_config_bool(var, value))\n\t\t\tssl_cert_password_required = 1;\n\t\treturn 0;\n\t}\n\tif (!strcmp(\"http.minsessions\", var)) {\n\t\tmin_curl_sessions = git_config_int(var, value);\n#ifndef USE_CURL_MULTI\n\t\tif (min_curl_sessions > 1)\n\t\t\tmin_curl_sessions = 1;\n#endif\n\t\treturn 0;\n\t}\n#ifdef USE_CURL_MULTI\n\tif (!strcmp(\"http.maxrequests\", var)) {\n\t\tmax_requests = git_config_int(var, value);\n\t\treturn 0;\n\t}\n#endif\n\tif (!strcmp(\"http.lowspeedlimit\", var)) {\n\t\tcurl_low_speed_limit = (long)git_config_int(var, value);\n\t\treturn 0;\n\t}\n\tif (!strcmp(\"http.lowspeedtime\", var)) {\n\t\tcurl_low_speed_time = (long)git_config_int(var, value);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(\"http.noepsv\", var)) {\n\t\tcurl_ftp_no_epsv = git_config_bool(var, value);\n\t\treturn 0;\n\t}\n\tif (!strcmp(\"http.proxy\", var))\n\t\treturn git_config_string(&curl_http_proxy, var, value);\n\n\tif (!strcmp(\"http.cookiefile\", var))\n\t\treturn git_config_string(&curl_cookie_file, var, value);\n\n\tif (!strcmp(\"http.postbuffer\", var)) {\n\t\thttp_post_buffer = git_config_int(var, value);\n\t\tif (http_post_buffer < LARGE_PACKET_MAX)\n\t\t\thttp_post_buffer = LARGE_PACKET_MAX;\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(\"http.useragent\", var))\n\t\treturn git_config_string(&user_agent, var, value);\n\n\t/* Fall back on the default ones */\n\treturn git_default_config(var, value, cb);\n}\n\nstatic void init_curl_http_auth(CURL *result)\n{\n\tif (user_name) {\n\t\tstruct strbuf up = STRBUF_INIT;\n\t\tif (!user_pass)\n\t\t\tuser_pass = xstrdup(git_getpass_with_description(\"Password\", description));\n\t\tstrbuf_addf(&up, \"%s:%s\", user_name, user_pass);\n\t\tcurl_easy_setopt(result, CURLOPT_USERPWD,\n\t\t\t\t strbuf_detach(&up, NULL));\n\t}\n}\n\nstatic int has_cert_password(void)\n{\n\tif (ssl_cert_password != NULL)\n\t\treturn 1;\n\tif (ssl_cert == NULL || ssl_cert_password_required != 1)\n\t\treturn 0;\n\t/* Only prompt the user once. */\n\tssl_cert_password_required = -1;\n\tssl_cert_password = git_getpass_with_description(\"Certificate Password\", description);\n\tif (ssl_cert_password != NULL) {\n\t\tssl_cert_password = xstrdup(ssl_cert_password);\n\t\treturn 1;\n\t} else\n\t\treturn 0;\n}\n\nstatic CURL *get_curl_handle(void)\n{\n\tCURL *result = curl_easy_init();\n\n\tif (!curl_ssl_verify) {\n\t\tcurl_easy_setopt(result, CURLOPT_SSL_VERIFYPEER, 0);\n\t\tcurl_easy_setopt(result, CURLOPT_SSL_VERIFYHOST, 0);\n\t} else {\n\t\t/* Verify authenticity of the peer's certificate */\n\t\tcurl_easy_setopt(result, CURLOPT_SSL_VERIFYPEER, 1);\n\t\t/* The name in the cert must match whom we tried to connect */\n\t\tcurl_easy_setopt(result, CURLOPT_SSL_VERIFYHOST, 2);\n\t}\n\n#if LIBCURL_VERSION_NUM >= 0x070907\n\tcurl_easy_setopt(result, CURLOPT_NETRC, CURL_NETRC_OPTIONAL);\n#endif\n#ifdef LIBCURL_CAN_HANDLE_AUTH_ANY\n\tcurl_easy_setopt(result, CURLOPT_HTTPAUTH, CURLAUTH_ANY);\n#endif\n\n\tif (ssl_cert != NULL)\n\t\tcurl_easy_setopt(result, CURLOPT_SSLCERT, ssl_cert);\n\tif (has_cert_password())\n\t\tcurl_easy_setopt(result, CURLOPT_KEYPASSWD, ssl_cert_password);\n#if LIBCURL_VERSION_NUM >= 0x070903\n\tif (ssl_key != NULL)\n\t\tcurl_easy_setopt(result, CURLOPT_SSLKEY, ssl_key);\n#endif\n#if LIBCURL_VERSION_NUM >= 0x070908\n\tif (ssl_capath != NULL)\n\t\tcurl_easy_setopt(result, CURLOPT_CAPATH, ssl_capath);\n#endif\n\tif (ssl_cainfo != NULL)\n\t\tcurl_easy_setopt(result, CURLOPT_CAINFO, ssl_cainfo);\n\tcurl_easy_setopt(result, CURLOPT_FAILONERROR, 1);\n\n\tif (curl_low_speed_limit > 0 && curl_low_speed_time > 0) {\n\t\tcurl_easy_setopt(result, CURLOPT_LOW_SPEED_LIMIT,\n\t\t\t\t curl_low_speed_limit);\n\t\tcurl_easy_setopt(result, CURLOPT_LOW_SPEED_TIME,\n\t\t\t\t curl_low_speed_time);\n\t}\n\n\tcurl_easy_setopt(result, CURLOPT_FOLLOWLOCATION, 1);\n#if LIBCURL_VERSION_NUM >= 0x071301\n\tcurl_easy_setopt(result, CURLOPT_POSTREDIR, CURL_REDIR_POST_ALL);\n#elif LIBCURL_VERSION_NUM >= 0x071101\n\tcurl_easy_setopt(result, CURLOPT_POST301, 1);\n#endif\n\n\tif (getenv(\"GIT_CURL_VERBOSE\"))\n\t\tcurl_easy_setopt(result, CURLOPT_VERBOSE, 1);\n\n\tcurl_easy_setopt(result, CURLOPT_USERAGENT,\n\t\tuser_agent ? user_agent : GIT_HTTP_USER_AGENT);\n\n\tif (curl_ftp_no_epsv)\n\t\tcurl_easy_setopt(result, CURLOPT_FTP_USE_EPSV, 0);\n\n\tif (curl_http_proxy)\n\t\tcurl_easy_setopt(result, CURLOPT_PROXY, curl_http_proxy);\n\n\treturn result;\n}\n\nstatic void http_auth_init(const char *url)\n{\n\tconst char *at, *colon, *cp, *slash, *host;\n\n\tcp = strstr(url, \"://\");\n\tif (!cp)\n\t\treturn;\n\n\t/*\n\t * Ok, the URL looks like \"proto://something\".  Which one?\n\t * \"proto://<user>:<pass>@<host>/...\",\n\t * \"proto://<user>@<host>/...\", or just\n\t * \"proto://<host>/...\"?\n\t */\n\tcp += 3;\n\tat = strchr(cp, '@');\n\tcolon = strchr(cp, ':');\n\tslash = strchrnul(cp, '/');\n\tif (!at || slash <= at) {\n\t\t/* No credentials, but we may have to ask for some later */\n\t\thost = cp;\n\t}\n\telse if (!colon || at <= colon) {\n\t\t/* Only username */\n\t\tuser_name = url_decode_mem(cp, at - cp);\n\t\tuser_pass = NULL;\n\t\thost = at + 1;\n\t} else {\n\t\tuser_name = url_decode_mem(cp, colon - cp);\n\t\tuser_pass = url_decode_mem(colon + 1, at - (colon + 1));\n\t\thost = at + 1;\n\t}\n\n\tdescription = url_decode_mem(host, slash - host);\n}\n\nstatic void set_from_env(const char **var, const char *envname)\n{\n\tconst char *val = getenv(envname);\n\tif (val)\n\t\t*var = val;\n}\n\nvoid http_init(struct remote *remote, const char *url)\n{\n\tchar *low_speed_limit;\n\tchar *low_speed_time;\n\n\thttp_is_verbose = 0;\n\n\tgit_config(http_options, NULL);\n\n\tcurl_global_init(CURL_GLOBAL_ALL);\n\n\tif (remote && remote->http_proxy)\n\t\tcurl_http_proxy = xstrdup(remote->http_proxy);\n\n\tpragma_header = curl_slist_append(pragma_header, \"Pragma: no-cache\");\n\tno_pragma_header = curl_slist_append(no_pragma_header, \"Pragma:\");\n\n#ifdef USE_CURL_MULTI\n\t{\n\t\tchar *http_max_requests = getenv(\"GIT_HTTP_MAX_REQUESTS\");\n\t\tif (http_max_requests != NULL)\n\t\t\tmax_requests = atoi(http_max_requests);\n\t}\n\n\tcurlm = curl_multi_init();\n\tif (curlm == NULL) {\n\t\tfprintf(stderr, \"Error creating curl multi handle.\\n\");\n\t\texit(1);\n\t}\n#endif\n\n\tif (getenv(\"GIT_SSL_NO_VERIFY\"))\n\t\tcurl_ssl_verify = 0;\n\n\tset_from_env(&ssl_cert, \"GIT_SSL_CERT\");\n#if LIBCURL_VERSION_NUM >= 0x070903\n\tset_from_env(&ssl_key, \"GIT_SSL_KEY\");\n#endif\n#if LIBCURL_VERSION_NUM >= 0x070908\n\tset_from_env(&ssl_capath, \"GIT_SSL_CAPATH\");\n#endif\n\tset_from_env(&ssl_cainfo, \"GIT_SSL_CAINFO\");\n\n\tset_from_env(&user_agent, \"GIT_HTTP_USER_AGENT\");\n\n\tlow_speed_limit = getenv(\"GIT_HTTP_LOW_SPEED_LIMIT\");\n\tif (low_speed_limit != NULL)\n\t\tcurl_low_speed_limit = strtol(low_speed_limit, NULL, 10);\n\tlow_speed_time = getenv(\"GIT_HTTP_LOW_SPEED_TIME\");\n\tif (low_speed_time != NULL)\n\t\tcurl_low_speed_time = strtol(low_speed_time, NULL, 10);\n\n\tif (curl_ssl_verify == -1)\n\t\tcurl_ssl_verify = 1;\n\n\tcurl_session_count = 0;\n#ifdef USE_CURL_MULTI\n\tif (max_requests < 1)\n\t\tmax_requests = DEFAULT_MAX_REQUESTS;\n#endif\n\n\tif (getenv(\"GIT_CURL_FTP_NO_EPSV\"))\n\t\tcurl_ftp_no_epsv = 1;\n\n\tif (url) {\n\t\thttp_auth_init(url);\n\t\tif (!ssl_cert_password_required &&\n\t\t    getenv(\"GIT_SSL_CERT_PASSWORD_PROTECTED\") &&\n\t\t    !prefixcmp(url, \"https://\"))\n\t\t\tssl_cert_password_required = 1;\n\t}\n\n#ifndef NO_CURL_EASY_DUPHANDLE\n\tcurl_default = get_curl_handle();\n#endif\n}\n\nvoid http_cleanup(void)\n{\n\tstruct active_request_slot *slot = active_queue_head;\n\n\twhile (slot != NULL) {\n\t\tstruct active_request_slot *next = slot->next;\n\t\tif (slot->curl != NULL) {\n#ifdef USE_CURL_MULTI\n\t\t\tcurl_multi_remove_handle(curlm, slot->curl);\n#endif\n\t\t\tcurl_easy_cleanup(slot->curl);\n\t\t}\n\t\tfree(slot);\n\t\tslot = next;\n\t}\n\tactive_queue_head = NULL;\n\n#ifndef NO_CURL_EASY_DUPHANDLE\n\tcurl_easy_cleanup(curl_default);\n#endif\n\n#ifdef USE_CURL_MULTI\n\tcurl_multi_cleanup(curlm);\n#endif\n\tcurl_global_cleanup();\n\n\tcurl_slist_free_all(pragma_header);\n\tpragma_header = NULL;\n\n\tcurl_slist_free_all(no_pragma_header);\n\tno_pragma_header = NULL;\n\n\tif (curl_http_proxy) {\n\t\tfree((void *)curl_http_proxy);\n\t\tcurl_http_proxy = NULL;\n\t}\n\n\tif (ssl_cert_password != NULL) {\n\t\tmemset(ssl_cert_password, 0, strlen(ssl_cert_password));\n\t\tfree(ssl_cert_password);\n\t\tssl_cert_password = NULL;\n\t}\n\tssl_cert_password_required = 0;\n}\n\nstruct active_request_slot *get_active_slot(void)\n{\n\tstruct active_request_slot *slot = active_queue_head;\n\tstruct active_request_slot *newslot;\n\n#ifdef USE_CURL_MULTI\n\tint num_transfers;\n\n\t/* Wait for a slot to open up if the queue is full */\n\twhile (active_requests >= max_requests) {\n\t\tcurl_multi_perform(curlm, &num_transfers);\n\t\tif (num_transfers < active_requests)\n\t\t\tprocess_curl_messages();\n\t}\n#endif\n\n\twhile (slot != NULL && slot->in_use)\n\t\tslot = slot->next;\n\n\tif (slot == NULL) {\n\t\tnewslot = xmalloc(sizeof(*newslot));\n\t\tnewslot->curl = NULL;\n\t\tnewslot->in_use = 0;\n\t\tnewslot->next = NULL;\n\n\t\tslot = active_queue_head;\n\t\tif (slot == NULL) {\n\t\t\tactive_queue_head = newslot;\n\t\t} else {\n\t\t\twhile (slot->next != NULL)\n\t\t\t\tslot = slot->next;\n\t\t\tslot->next = newslot;\n\t\t}\n\t\tslot = newslot;\n\t}\n\n\tif (slot->curl == NULL) {\n#ifdef NO_CURL_EASY_DUPHANDLE\n\t\tslot->curl = get_curl_handle();\n#else\n\t\tslot->curl = curl_easy_duphandle(curl_default);\n#endif\n\t\tcurl_session_count++;\n\t}\n\n\tactive_requests++;\n\tslot->in_use = 1;\n\tslot->local = NULL;\n\tslot->results = NULL;\n\tslot->finished = NULL;\n\tslot->callback_data = NULL;\n\tslot->callback_func = NULL;\n\tcurl_easy_setopt(slot->curl, CURLOPT_COOKIEFILE, curl_cookie_file);\n\tcurl_easy_setopt(slot->curl, CURLOPT_HTTPHEADER, pragma_header);\n\tcurl_easy_setopt(slot->curl, CURLOPT_ERRORBUFFER, curl_errorstr);\n\tcurl_easy_setopt(slot->curl, CURLOPT_CUSTOMREQUEST, NULL);\n\tcurl_easy_setopt(slot->curl, CURLOPT_READFUNCTION, NULL);\n\tcurl_easy_setopt(slot->curl, CURLOPT_WRITEFUNCTION, NULL);\n\tcurl_easy_setopt(slot->curl, CURLOPT_POSTFIELDS, NULL);\n\tcurl_easy_setopt(slot->curl, CURLOPT_UPLOAD, 0);\n\tcurl_easy_setopt(slot->curl, CURLOPT_HTTPGET, 1);\n\n\treturn slot;\n}\n\nint start_active_slot(struct active_request_slot *slot)\n{\n#ifdef USE_CURL_MULTI\n\tCURLMcode curlm_result = curl_multi_add_handle(curlm, slot->curl);\n\tint num_transfers;\n\n\tif (curlm_result != CURLM_OK &&\n\t    curlm_result != CURLM_CALL_MULTI_PERFORM) {\n\t\tactive_requests--;\n\t\tslot->in_use = 0;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * We know there must be something to do, since we just added\n\t * something.\n\t */\n\tcurl_multi_perform(curlm, &num_transfers);\n#endif\n\treturn 1;\n}\n\n#ifdef USE_CURL_MULTI\nstruct fill_chain {\n\tvoid *data;\n\tint (*fill)(void *);\n\tstruct fill_chain *next;\n};\n\nstatic struct fill_chain *fill_cfg;\n\nvoid add_fill_function(void *data, int (*fill)(void *))\n{\n\tstruct fill_chain *new = xmalloc(sizeof(*new));\n\tstruct fill_chain **linkp = &fill_cfg;\n\tnew->data = data;\n\tnew->fill = fill;\n\tnew->next = NULL;\n\twhile (*linkp)\n\t\tlinkp = &(*linkp)->next;\n\t*linkp = new;\n}\n\nvoid fill_active_slots(void)\n{\n\tstruct active_request_slot *slot = active_queue_head;\n\n\twhile (active_requests < max_requests) {\n\t\tstruct fill_chain *fill;\n\t\tfor (fill = fill_cfg; fill; fill = fill->next)\n\t\t\tif (fill->fill(fill->data))\n\t\t\t\tbreak;\n\n\t\tif (!fill)\n\t\t\tbreak;\n\t}\n\n\twhile (slot != NULL) {\n\t\tif (!slot->in_use && slot->curl != NULL\n\t\t\t&& curl_session_count > min_curl_sessions) {\n\t\t\tcurl_easy_cleanup(slot->curl);\n\t\t\tslot->curl = NULL;\n\t\t\tcurl_session_count--;\n\t\t}\n\t\tslot = slot->next;\n\t}\n}\n\nvoid step_active_slots(void)\n{\n\tint num_transfers;\n\tCURLMcode curlm_result;\n\n\tdo {\n\t\tcurlm_result = curl_multi_perform(curlm, &num_transfers);\n\t} while (curlm_result == CURLM_CALL_MULTI_PERFORM);\n\tif (num_transfers < active_requests) {\n\t\tprocess_curl_messages();\n\t\tfill_active_slots();\n\t}\n}\n#endif\n\nvoid run_active_slot(struct active_request_slot *slot)\n{\n#ifdef USE_CURL_MULTI\n\tlong last_pos = 0;\n\tlong current_pos;\n\tfd_set readfds;\n\tfd_set writefds;\n\tfd_set excfds;\n\tint max_fd;\n\tstruct timeval select_timeout;\n\tint finished = 0;\n\n\tslot->finished = &finished;\n\twhile (!finished) {\n\t\tdata_received = 0;\n\t\tstep_active_slots();\n\n\t\tif (!data_received && slot->local != NULL) {\n\t\t\tcurrent_pos = ftell(slot->local);\n\t\t\tif (current_pos > last_pos)\n\t\t\t\tdata_received++;\n\t\t\tlast_pos = current_pos;\n\t\t}\n\n\t\tif (slot->in_use && !data_received) {\n\t\t\tmax_fd = 0;\n\t\t\tFD_ZERO(&readfds);\n\t\t\tFD_ZERO(&writefds);\n\t\t\tFD_ZERO(&excfds);\n\t\t\tselect_timeout.tv_sec = 0;\n\t\t\tselect_timeout.tv_usec = 50000;\n\t\t\tselect(max_fd, &readfds, &writefds,\n\t\t\t       &excfds, &select_timeout);\n\t\t}\n\t}\n#else\n\twhile (slot->in_use) {\n\t\tslot->curl_result = curl_easy_perform(slot->curl);\n\t\tfinish_active_slot(slot);\n\t}\n#endif\n}\n\nstatic void closedown_active_slot(struct active_request_slot *slot)\n{\n\tactive_requests--;\n\tslot->in_use = 0;\n}\n\nstatic void release_active_slot(struct active_request_slot *slot)\n{\n\tclosedown_active_slot(slot);\n\tif (slot->curl && curl_session_count > min_curl_sessions) {\n#ifdef USE_CURL_MULTI\n\t\tcurl_multi_remove_handle(curlm, slot->curl);\n#endif\n\t\tcurl_easy_cleanup(slot->curl);\n\t\tslot->curl = NULL;\n\t\tcurl_session_count--;\n\t}\n#ifdef USE_CURL_MULTI\n\tfill_active_slots();\n#endif\n}\n\nvoid finish_active_slot(struct active_request_slot *slot)\n{\n\tclosedown_active_slot(slot);\n\tcurl_easy_getinfo(slot->curl, CURLINFO_HTTP_CODE, &slot->http_code);\n\n\tif (slot->finished != NULL)\n\t\t(*slot->finished) = 1;\n\n\t/* Store slot results so they can be read after the slot is reused */\n\tif (slot->results != NULL) {\n\t\tslot->results->curl_result = slot->curl_result;\n\t\tslot->results->http_code = slot->http_code;\n\t}\n\n\t/* Run callback if appropriate */\n\tif (slot->callback_func != NULL)\n\t\tslot->callback_func(slot->callback_data);\n}\n\nvoid finish_all_active_slots(void)\n{\n\tstruct active_request_slot *slot = active_queue_head;\n\n\twhile (slot != NULL)\n\t\tif (slot->in_use) {\n\t\t\trun_active_slot(slot);\n\t\t\tslot = active_queue_head;\n\t\t} else {\n\t\t\tslot = slot->next;\n\t\t}\n}\n\n/* Helpers for modifying and creating URLs */\nstatic inline int needs_quote(int ch)\n{\n\tif (((ch >= 'A') && (ch <= 'Z'))\n\t\t\t|| ((ch >= 'a') && (ch <= 'z'))\n\t\t\t|| ((ch >= '0') && (ch <= '9'))\n\t\t\t|| (ch == '/')\n\t\t\t|| (ch == '-')\n\t\t\t|| (ch == '.'))\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic inline int hex(int v)\n{\n\tif (v < 10)\n\t\treturn '0' + v;\n\telse\n\t\treturn 'A' + v - 10;\n}\n\nstatic char *quote_ref_url(const char *base, const char *ref)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tconst char *cp;\n\tint ch;\n\n\tend_url_with_slash(&buf, base);\n\n\tfor (cp = ref; (ch = *cp) != 0; cp++)\n\t\tif (needs_quote(ch))\n\t\t\tstrbuf_addf(&buf, \"%%%02x\", ch);\n\t\telse\n\t\t\tstrbuf_addch(&buf, *cp);\n\n\treturn strbuf_detach(&buf, NULL);\n}\n\nvoid append_remote_object_url(struct strbuf *buf, const char *url,\n\t\t\t      const char *hex,\n\t\t\t      int only_two_digit_prefix)\n{\n\tend_url_with_slash(buf, url);\n\n\tstrbuf_addf(buf, \"objects/%.*s/\", 2, hex);\n\tif (!only_two_digit_prefix)\n\t\tstrbuf_addf(buf, \"%s\", hex+2);\n}\n\nchar *get_remote_object_url(const char *url, const char *hex,\n\t\t\t    int only_two_digit_prefix)\n{\n\tstruct strbuf buf = STRBUF_INIT;\n\tappend_remote_object_url(&buf, url, hex, only_two_digit_prefix);\n\treturn strbuf_detach(&buf, NULL);\n}\n\n/* http_request() targets */\n#define HTTP_REQUEST_STRBUF\t0\n#define HTTP_REQUEST_FILE\t1\n\nstatic int http_request(const char *url, void *result, int target, int options)\n{\n\tstruct active_request_slot *slot;\n\tstruct slot_results results;\n\tstruct curl_slist *headers = NULL;\n\tstruct strbuf buf = STRBUF_INIT;\n\tint ret;\n\n\tslot = get_active_slot();\n\tslot->results = &results;\n\tcurl_easy_setopt(slot->curl, CURLOPT_HTTPGET, 1);\n\n\tif (result == NULL) {\n\t\tcurl_easy_setopt(slot->curl, CURLOPT_NOBODY, 1);\n\t} else {\n\t\tcurl_easy_setopt(slot->curl, CURLOPT_NOBODY, 0);\n\t\tcurl_easy_setopt(slot->curl, CURLOPT_FILE, result);\n\n\t\tif (target == HTTP_REQUEST_FILE) {\n\t\t\tlong posn = ftell(result);\n\t\t\tcurl_easy_setopt(slot->curl, CURLOPT_WRITEFUNCTION,\n\t\t\t\t\t fwrite);\n\t\t\tif (posn > 0) {\n\t\t\t\tstrbuf_addf(&buf, \"Range: bytes=%ld-\", posn);\n\t\t\t\theaders = curl_slist_append(headers, buf.buf);\n\t\t\t\tstrbuf_reset(&buf);\n\t\t\t}\n\t\t\tslot->local = result;\n\t\t} else\n\t\t\tcurl_easy_setopt(slot->curl, CURLOPT_WRITEFUNCTION,\n\t\t\t\t\t fwrite_buffer);\n\t}\n\n\tstrbuf_addstr(&buf, \"Pragma:\");\n\tif (options & HTTP_NO_CACHE)\n\t\tstrbuf_addstr(&buf, \" no-cache\");\n\n\theaders = curl_slist_append(headers, buf.buf);\n\n\tcurl_easy_setopt(slot->curl, CURLOPT_URL, url);\n\tcurl_easy_setopt(slot->curl, CURLOPT_HTTPHEADER, headers);\n\n\tif (start_active_slot(slot)) {\n\t\trun_active_slot(slot);\n\t\tif (results.curl_result == CURLE_OK)\n\t\t\tret = HTTP_OK;\n\t\telse if (missing_target(&results))\n\t\t\tret = HTTP_MISSING_TARGET;\n\t\telse if (results.http_code == 401) {\n\t\t\tif (user_name && user_pass) {\n\t\t\t\tret = HTTP_NOAUTH;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * git_getpass is needed here because its very likely stdin/stdout are\n\t\t\t\t * pipes to our parent process.  So we instead need to use /dev/tty,\n\t\t\t\t * but that is non-portable.  Using git_getpass() can at least be stubbed\n\t\t\t\t * on other platforms with a different implementation if/when necessary.\n\t\t\t\t */\n\t\t\t\tif (!user_name)\n\t\t\t\t\tuser_name = xstrdup(git_getpass_with_description(\"Username\", description));\n\t\t\t\tinit_curl_http_auth(slot->curl);\n\t\t\t\tret = HTTP_REAUTH;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!curl_errorstr[0])\n\t\t\t\tstrlcpy(curl_errorstr,\n\t\t\t\t\tcurl_easy_strerror(results.curl_result),\n\t\t\t\t\tsizeof(curl_errorstr));\n\t\t\tret = HTTP_ERROR;\n\t\t}\n\t} else {\n\t\terror(\"Unable to start HTTP request for %s\", url);\n\t\tret = HTTP_START_FAILED;\n\t}\n\n\tslot->local = NULL;\n\tcurl_slist_free_all(headers);\n\tstrbuf_release(&buf);\n\n\treturn ret;\n}\n\nstatic int http_request_reauth(const char *url, void *result, int target,\n\t\t\t       int options)\n{\n\tint ret = http_request(url, result, target, options);\n\tif (ret != HTTP_REAUTH)\n\t\treturn ret;\n\treturn http_request(url, result, target, options);\n}\n\nint http_get_strbuf(const char *url, struct strbuf *result, int options)\n{\n\treturn http_request_reauth(url, result, HTTP_REQUEST_STRBUF, options);\n}\n\n/*\n * Downloads an url and stores the result in the given file.\n *\n * If a previous interrupted download is detected (i.e. a previous temporary\n * file is still around) the download is resumed.\n */\nstatic int http_get_file(const char *url, const char *filename, int options)\n{\n\tint ret;\n\tstruct strbuf tmpfile = STRBUF_INIT;\n\tFILE *result;\n\n\tstrbuf_addf(&tmpfile, \"%s.temp\", filename);\n\tresult = fopen(tmpfile.buf, \"a\");\n\tif (! result) {\n\t\terror(\"Unable to open local file %s\", tmpfile.buf);\n\t\tret = HTTP_ERROR;\n\t\tgoto cleanup;\n\t}\n\n\tret = http_request_reauth(url, result, HTTP_REQUEST_FILE, options);\n\tfclose(result);\n\n\tif ((ret == HTTP_OK) && move_temp_to_file(tmpfile.buf, filename))\n\t\tret = HTTP_ERROR;\ncleanup:\n\tstrbuf_release(&tmpfile);\n\treturn ret;\n}\n\nint http_error(const char *url, int ret)\n{\n\t/* http_request has already handled HTTP_START_FAILED. */\n\tif (ret != HTTP_START_FAILED)\n\t\terror(\"%s while accessing %s\", curl_errorstr, url);\n\n\treturn ret;\n}\n\nint http_fetch_ref(const char *base, struct ref *ref)\n{\n\tchar *url;\n\tstruct strbuf buffer = STRBUF_INIT;\n\tint ret = -1;\n\n\turl = quote_ref_url(base, ref->name);\n\tif (http_get_strbuf(url, &buffer, HTTP_NO_CACHE) == HTTP_OK) {\n\t\tstrbuf_rtrim(&buffer);\n\t\tif (buffer.len == 40)\n\t\t\tret = get_sha1_hex(buffer.buf, ref->old_sha1);\n\t\telse if (!prefixcmp(buffer.buf, \"ref: \")) {\n\t\t\tref->symref = xstrdup(buffer.buf + 5);\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\tstrbuf_release(&buffer);\n\tfree(url);\n\treturn ret;\n}\n\n/* Helpers for fetching packs */\nstatic char *fetch_pack_index(unsigned char *sha1, const char *base_url)\n{\n\tchar *url, *tmp;\n\tstruct strbuf buf = STRBUF_INIT;\n\n\tif (http_is_verbose)\n\t\tfprintf(stderr, \"Getting index for pack %s\\n\", sha1_to_hex(sha1));\n\n\tend_url_with_slash(&buf, base_url);\n\tstrbuf_addf(&buf, \"objects/pack/pack-%s.idx\", sha1_to_hex(sha1));\n\turl = strbuf_detach(&buf, NULL);\n\n\tstrbuf_addf(&buf, \"%s.temp\", sha1_pack_index_name(sha1));\n\ttmp = strbuf_detach(&buf, NULL);\n\n\tif (http_get_file(url, tmp, 0) != HTTP_OK) {\n\t\terror(\"Unable to get pack index %s\\n\", url);\n\t\tfree(tmp);\n\t\ttmp = NULL;\n\t}\n\n\tfree(url);\n\treturn tmp;\n}\n\nstatic int fetch_and_setup_pack_index(struct packed_git **packs_head,\n\tunsigned char *sha1, const char *base_url)\n{\n\tstruct packed_git *new_pack;\n\tchar *tmp_idx = NULL;\n\tint ret;\n\n\tif (has_pack_index(sha1)) {\n\t\tnew_pack = parse_pack_index(sha1, NULL);\n\t\tif (!new_pack)\n\t\t\treturn -1; /* parse_pack_index() already issued error message */\n\t\tgoto add_pack;\n\t}\n\n\ttmp_idx = fetch_pack_index(sha1, base_url);\n\tif (!tmp_idx)\n\t\treturn -1;\n\n\tnew_pack = parse_pack_index(sha1, tmp_idx);\n\tif (!new_pack) {\n\t\tunlink(tmp_idx);\n\t\tfree(tmp_idx);\n\n\t\treturn -1; /* parse_pack_index() already issued error message */\n\t}\n\n\tret = verify_pack_index(new_pack);\n\tif (!ret) {\n\t\tclose_pack_index(new_pack);\n\t\tret = move_temp_to_file(tmp_idx, sha1_pack_index_name(sha1));\n\t}\n\tfree(tmp_idx);\n\tif (ret)\n\t\treturn -1;\n\nadd_pack:\n\tnew_pack->next = *packs_head;\n\t*packs_head = new_pack;\n\treturn 0;\n}\n\nint http_get_info_packs(const char *base_url, struct packed_git **packs_head)\n{\n\tint ret = 0, i = 0;\n\tchar *url, *data;\n\tstruct strbuf buf = STRBUF_INIT;\n\tunsigned char sha1[20];\n\n\tend_url_with_slash(&buf, base_url);\n\tstrbuf_addstr(&buf, \"objects/info/packs\");\n\turl = strbuf_detach(&buf, NULL);\n\n\tret = http_get_strbuf(url, &buf, HTTP_NO_CACHE);\n\tif (ret != HTTP_OK)\n\t\tgoto cleanup;\n\n\tdata = buf.buf;\n\twhile (i < buf.len) {\n\t\tswitch (data[i]) {\n\t\tcase 'P':\n\t\t\ti++;\n\t\t\tif (i + 52 <= buf.len &&\n\t\t\t    !prefixcmp(data + i, \" pack-\") &&\n\t\t\t    !prefixcmp(data + i + 46, \".pack\\n\")) {\n\t\t\t\tget_sha1_hex(data + i + 6, sha1);\n\t\t\t\tfetch_and_setup_pack_index(packs_head, sha1,\n\t\t\t\t\t\t      base_url);\n\t\t\t\ti += 51;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tdefault:\n\t\t\twhile (i < buf.len && data[i] != '\\n')\n\t\t\t\ti++;\n\t\t}\n\t\ti++;\n\t}\n\ncleanup:\n\tfree(url);\n\treturn ret;\n}\n\nvoid release_http_pack_request(struct http_pack_request *preq)\n{\n\tif (preq->packfile != NULL) {\n\t\tfclose(preq->packfile);\n\t\tpreq->packfile = NULL;\n\t\tpreq->slot->local = NULL;\n\t}\n\tif (preq->range_header != NULL) {\n\t\tcurl_slist_free_all(preq->range_header);\n\t\tpreq->range_header = NULL;\n\t}\n\tpreq->slot = NULL;\n\tfree(preq->url);\n}\n\nint finish_http_pack_request(struct http_pack_request *preq)\n{\n\tstruct packed_git **lst;\n\tstruct packed_git *p = preq->target;\n\tchar *tmp_idx;\n\tstruct child_process ip;\n\tconst char *ip_argv[8];\n\n\tclose_pack_index(p);\n\n\tfclose(preq->packfile);\n\tpreq->packfile = NULL;\n\tpreq->slot->local = NULL;\n\n\tlst = preq->lst;\n\twhile (*lst != p)\n\t\tlst = &((*lst)->next);\n\t*lst = (*lst)->next;\n\n\ttmp_idx = xstrdup(preq->tmpfile);\n\tstrcpy(tmp_idx + strlen(tmp_idx) - strlen(\".pack.temp\"),\n\t       \".idx.temp\");\n\n\tip_argv[0] = \"index-pack\";\n\tip_argv[1] = \"-o\";\n\tip_argv[2] = tmp_idx;\n\tip_argv[3] = preq->tmpfile;\n\tip_argv[4] = NULL;\n\n\tmemset(&ip, 0, sizeof(ip));\n\tip.argv = ip_argv;\n\tip.git_cmd = 1;\n\tip.no_stdin = 1;\n\tip.no_stdout = 1;\n\n\tif (run_command(&ip)) {\n\t\tunlink(preq->tmpfile);\n\t\tunlink(tmp_idx);\n\t\tfree(tmp_idx);\n\t\treturn -1;\n\t}\n\n\tunlink(sha1_pack_index_name(p->sha1));\n\n\tif (move_temp_to_file(preq->tmpfile, sha1_pack_name(p->sha1))\n\t || move_temp_to_file(tmp_idx, sha1_pack_index_name(p->sha1))) {\n\t\tfree(tmp_idx);\n\t\treturn -1;\n\t}\n\n\tinstall_packed_git(p);\n\tfree(tmp_idx);\n\treturn 0;\n}\n\nstruct http_pack_request *new_http_pack_request(\n\tstruct packed_git *target, const char *base_url)\n{\n\tlong prev_posn = 0;\n\tchar range[RANGE_HEADER_SIZE];\n\tstruct strbuf buf = STRBUF_INIT;\n\tstruct http_pack_request *preq;\n\n\tpreq = xcalloc(1, sizeof(*preq));\n\tpreq->target = target;\n\n\tend_url_with_slash(&buf, base_url);\n\tstrbuf_addf(&buf, \"objects/pack/pack-%s.pack\",\n\t\tsha1_to_hex(target->sha1));\n\tpreq->url = strbuf_detach(&buf, NULL);\n\n\tsnprintf(preq->tmpfile, sizeof(preq->tmpfile), \"%s.temp\",\n\t\tsha1_pack_name(target->sha1));\n\tpreq->packfile = fopen(preq->tmpfile, \"a\");\n\tif (!preq->packfile) {\n\t\terror(\"Unable to open local file %s for pack\",\n\t\t      preq->tmpfile);\n\t\tgoto abort;\n\t}\n\n\tpreq->slot = get_active_slot();\n\tpreq->slot->local = preq->packfile;\n\tcurl_easy_setopt(preq->slot->curl, CURLOPT_FILE, preq->packfile);\n\tcurl_easy_setopt(preq->slot->curl, CURLOPT_WRITEFUNCTION, fwrite);\n\tcurl_easy_setopt(preq->slot->curl, CURLOPT_URL, preq->url);\n\tcurl_easy_setopt(preq->slot->curl, CURLOPT_HTTPHEADER,\n\t\tno_pragma_header);\n\n\t/*\n\t * If there is data present from a previous transfer attempt,\n\t * resume where it left off\n\t */\n\tprev_posn = ftell(preq->packfile);\n\tif (prev_posn>0) {\n\t\tif (http_is_verbose)\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Resuming fetch of pack %s at byte %ld\\n\",\n\t\t\t\tsha1_to_hex(target->sha1), prev_posn);\n\t\tsprintf(range, \"Range: bytes=%ld-\", prev_posn);\n\t\tpreq->range_header = curl_slist_append(NULL, range);\n\t\tcurl_easy_setopt(preq->slot->curl, CURLOPT_HTTPHEADER,\n\t\t\tpreq->range_header);\n\t}\n\n\treturn preq;\n\nabort:\n\tfree(preq->url);\n\tfree(preq);\n\treturn NULL;\n}\n\n/* Helpers for fetching objects (loose) */\nstatic size_t fwrite_sha1_file(char *ptr, size_t eltsize, size_t nmemb,\n\t\t\t       void *data)\n{\n\tunsigned char expn[4096];\n\tsize_t size = eltsize * nmemb;\n\tint posn = 0;\n\tstruct http_object_request *freq =\n\t\t(struct http_object_request *)data;\n\tdo {\n\t\tssize_t retval = xwrite(freq->localfile,\n\t\t\t\t\t(char *) ptr + posn, size - posn);\n\t\tif (retval < 0)\n\t\t\treturn posn;\n\t\tposn += retval;\n\t} while (posn < size);\n\n\tfreq->stream.avail_in = size;\n\tfreq->stream.next_in = (void *)ptr;\n\tdo {\n\t\tfreq->stream.next_out = expn;\n\t\tfreq->stream.avail_out = sizeof(expn);\n\t\tfreq->zret = git_inflate(&freq->stream, Z_SYNC_FLUSH);\n\t\tgit_SHA1_Update(&freq->c, expn,\n\t\t\t\tsizeof(expn) - freq->stream.avail_out);\n\t} while (freq->stream.avail_in && freq->zret == Z_OK);\n\tdata_received++;\n\treturn size;\n}\n\nstruct http_object_request *new_http_object_request(const char *base_url,\n\tunsigned char *sha1)\n{\n\tchar *hex = sha1_to_hex(sha1);\n\tchar *filename;\n\tchar prevfile[PATH_MAX];\n\tint prevlocal;\n\tchar prev_buf[PREV_BUF_SIZE];\n\tssize_t prev_read = 0;\n\tlong prev_posn = 0;\n\tchar range[RANGE_HEADER_SIZE];\n\tstruct curl_slist *range_header = NULL;\n\tstruct http_object_request *freq;\n\n\tfreq = xcalloc(1, sizeof(*freq));\n\thashcpy(freq->sha1, sha1);\n\tfreq->localfile = -1;\n\n\tfilename = sha1_file_name(sha1);\n\tsnprintf(freq->tmpfile, sizeof(freq->tmpfile),\n\t\t \"%s.temp\", filename);\n\n\tsnprintf(prevfile, sizeof(prevfile), \"%s.prev\", filename);\n\tunlink_or_warn(prevfile);\n\trename(freq->tmpfile, prevfile);\n\tunlink_or_warn(freq->tmpfile);\n\n\tif (freq->localfile != -1)\n\t\terror(\"fd leakage in start: %d\", freq->localfile);\n\tfreq->localfile = open(freq->tmpfile,\n\t\t\t       O_WRONLY | O_CREAT | O_EXCL, 0666);\n\t/*\n\t * This could have failed due to the \"lazy directory creation\";\n\t * try to mkdir the last path component.\n\t */\n\tif (freq->localfile < 0 && errno == ENOENT) {\n\t\tchar *dir = strrchr(freq->tmpfile, '/');\n\t\tif (dir) {\n\t\t\t*dir = 0;\n\t\t\tmkdir(freq->tmpfile, 0777);\n\t\t\t*dir = '/';\n\t\t}\n\t\tfreq->localfile = open(freq->tmpfile,\n\t\t\t\t       O_WRONLY | O_CREAT | O_EXCL, 0666);\n\t}\n\n\tif (freq->localfile < 0) {\n\t\terror(\"Couldn't create temporary file %s: %s\",\n\t\t      freq->tmpfile, strerror(errno));\n\t\tgoto abort;\n\t}\n\n\tgit_inflate_init(&freq->stream);\n\n\tgit_SHA1_Init(&freq->c);\n\n\tfreq->url = get_remote_object_url(base_url, hex, 0);\n\n\t/*\n\t * If a previous temp file is present, process what was already\n\t * fetched.\n\t */\n\tprevlocal = open(prevfile, O_RDONLY);\n\tif (prevlocal != -1) {\n\t\tdo {\n\t\t\tprev_read = xread(prevlocal, prev_buf, PREV_BUF_SIZE);\n\t\t\tif (prev_read>0) {\n\t\t\t\tif (fwrite_sha1_file(prev_buf,\n\t\t\t\t\t\t     1,\n\t\t\t\t\t\t     prev_read,\n\t\t\t\t\t\t     freq) == prev_read) {\n\t\t\t\t\tprev_posn += prev_read;\n\t\t\t\t} else {\n\t\t\t\t\tprev_read = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t} while (prev_read > 0);\n\t\tclose(prevlocal);\n\t}\n\tunlink_or_warn(prevfile);\n\n\t/*\n\t * Reset inflate/SHA1 if there was an error reading the previous temp\n\t * file; also rewind to the beginning of the local file.\n\t */\n\tif (prev_read == -1) {\n\t\tmemset(&freq->stream, 0, sizeof(freq->stream));\n\t\tgit_inflate_init(&freq->stream);\n\t\tgit_SHA1_Init(&freq->c);\n\t\tif (prev_posn>0) {\n\t\t\tprev_posn = 0;\n\t\t\tlseek(freq->localfile, 0, SEEK_SET);\n\t\t\tif (ftruncate(freq->localfile, 0) < 0) {\n\t\t\t\terror(\"Couldn't truncate temporary file %s: %s\",\n\t\t\t\t\t  freq->tmpfile, strerror(errno));\n\t\t\t\tgoto abort;\n\t\t\t}\n\t\t}\n\t}\n\n\tfreq->slot = get_active_slot();\n\n\tcurl_easy_setopt(freq->slot->curl, CURLOPT_FILE, freq);\n\tcurl_easy_setopt(freq->slot->curl, CURLOPT_WRITEFUNCTION, fwrite_sha1_file);\n\tcurl_easy_setopt(freq->slot->curl, CURLOPT_ERRORBUFFER, freq->errorstr);\n\tcurl_easy_setopt(freq->slot->curl, CURLOPT_URL, freq->url);\n\tcurl_easy_setopt(freq->slot->curl, CURLOPT_HTTPHEADER, no_pragma_header);\n\n\t/*\n\t * If we have successfully processed data from a previous fetch\n\t * attempt, only fetch the data we don't already have.\n\t */\n\tif (prev_posn>0) {\n\t\tif (http_is_verbose)\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Resuming fetch of object %s at byte %ld\\n\",\n\t\t\t\thex, prev_posn);\n\t\tsprintf(range, \"Range: bytes=%ld-\", prev_posn);\n\t\trange_header = curl_slist_append(range_header, range);\n\t\tcurl_easy_setopt(freq->slot->curl,\n\t\t\t\t CURLOPT_HTTPHEADER, range_header);\n\t}\n\n\treturn freq;\n\nabort:\n\tfree(freq->url);\n\tfree(freq);\n\treturn NULL;\n}\n\nvoid process_http_object_request(struct http_object_request *freq)\n{\n\tif (freq->slot == NULL)\n\t\treturn;\n\tfreq->curl_result = freq->slot->curl_result;\n\tfreq->http_code = freq->slot->http_code;\n\tfreq->slot = NULL;\n}\n\nint finish_http_object_request(struct http_object_request *freq)\n{\n\tstruct stat st;\n\n\tclose(freq->localfile);\n\tfreq->localfile = -1;\n\n\tprocess_http_object_request(freq);\n\n\tif (freq->http_code == 416) {\n\t\twarning(\"requested range invalid; we may already have all the data.\");\n\t} else if (freq->curl_result != CURLE_OK) {\n\t\tif (stat(freq->tmpfile, &st) == 0)\n\t\t\tif (st.st_size == 0)\n\t\t\t\tunlink_or_warn(freq->tmpfile);\n\t\treturn -1;\n\t}\n\n\tgit_inflate_end(&freq->stream);\n\tgit_SHA1_Final(freq->real_sha1, &freq->c);\n\tif (freq->zret != Z_STREAM_END) {\n\t\tunlink_or_warn(freq->tmpfile);\n\t\treturn -1;\n\t}\n\tif (hashcmp(freq->sha1, freq->real_sha1)) {\n\t\tunlink_or_warn(freq->tmpfile);\n\t\treturn -1;\n\t}\n\tfreq->rename =\n\t\tmove_temp_to_file(freq->tmpfile, sha1_file_name(freq->sha1));\n\n\treturn freq->rename;\n}\n\nvoid abort_http_object_request(struct http_object_request *freq)\n{\n\tunlink_or_warn(freq->tmpfile);\n\n\trelease_http_object_request(freq);\n}\n\nvoid release_http_object_request(struct http_object_request *freq)\n{\n\tif (freq->localfile != -1) {\n\t\tclose(freq->localfile);\n\t\tfreq->localfile = -1;\n\t}\n\tif (freq->url != NULL) {\n\t\tfree(freq->url);\n\t\tfreq->url = NULL;\n\t}\n\tif (freq->slot != NULL) {\n\t\tfreq->slot->callback_func = NULL;\n\t\tfreq->slot->callback_data = NULL;\n\t\trelease_active_slot(freq->slot);\n\t\tfreq->slot = NULL;\n\t}\n}\n",
    "type": "blob"
  },
  "kind": "blob",
  "oid": "008ad72ae599b1b937e2956e2621d40c325ff632",
  "sha1_ok": true,
  "size": 34484
}
