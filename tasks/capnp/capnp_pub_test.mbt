///|
fn decode_simple_root(bytes : Bytes) -> @capnp.StructDecoder raise {
  let decoder = @capnp.Decoder::from_bytes(bytes[:])
  decoder.root().as_struct()
}

///|
fn decode_medium_root(bytes : Bytes) -> @capnp.StructDecoder raise {
  let decoder = @capnp.Decoder::from_bytes(bytes[:])
  decoder.root().as_struct()
}

///|
fn decode_difficult_root(bytes : Bytes) -> @capnp.StructDecoder raise {
  let decoder = @capnp.Decoder::from_bytes(bytes[:])
  decoder.root().as_struct()
}

///|
let primitives_fixture : Bytes = [
  0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00,
  0x00, 0x00, 0x01, 0xd6, 0x18, 0xfc, 0x60, 0x79, 0xfe, 0xff, 0x00, 0x1c, 0xf4, 0xab,
  0xfd, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xd0, 0x0f, 0x49, 0x40, 0x00, 0x00, 0x00, 0x00,
  0x18, 0x2d, 0x44, 0x54, 0xfb, 0x21, 0x09, 0x40,
]


///|
let list_fixture : Bytes = [
  0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x04, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x2a, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00,
  0x1c, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x1d, 0x00,
  0x00, 0x00, 0x1d, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x00, 0x00, 0x00,
  0x0a, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
  0x32, 0x00, 0x00, 0x00, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x00, 0x00, 0x00, 0x77, 0x6f,
  0x72, 0x6c, 0x64, 0x00, 0x00, 0x00, 0x9a, 0x99, 0x99, 0x99, 0x99, 0x99, 0xf1, 0x3f,
  0x9a, 0x99, 0x99, 0x99, 0x99, 0x99, 0x01, 0x40, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
  0x0a, 0x40,
]


///|
let complex_fixture : Bytes = [
  0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
  0x02, 0x00, 0x15, 0xcd, 0x5b, 0x07, 0x00, 0x00, 0x00, 0x00, 0x6e, 0x86, 0x1b, 0xf0,
  0xf9, 0x21, 0x09, 0x40, 0x05, 0x00, 0x00, 0x00, 0x62, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x74, 0x65, 0x73, 0x74, 0x20, 0x73, 0x74, 0x72,
  0x69, 0x6e, 0x67, 0x00, 0x00, 0x00, 0x00, 0x00,
]


///|
fn assert_bytes_eq(actual : Bytes, expected : Bytes) -> Unit raise {
  assert_eq(actual.length(), expected.length())
  for i = 0; i < actual.length(); i = i + 1 {
    assert_eq(actual[i], expected[i])
  }
}

///|
let empty_single_segment_message : Bytes = b"\x00\x00\x00\x00\x00\x00\x00\x00"


///|
let single_segment_message : Bytes = b"\x00\x00\x00\x00\x01\x00\x00\x00\x00\x01\x02\x03\x04\x05\x06\x07"


///|
let two_segment_message : Bytes = b"\x01\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x01\x02\x03\x04\x05\x06\x07\x00\x01\x02\x03\x04\x05\x06\x07"


///|
let two_segment_missing_padding_message : Bytes = b"\x01\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\x00\x01\x02\x03\x04\x05\x06\x07\x00\x01\x02\x03\x04\x05\x06\x07"


///|
let incomplete_segment_count_message : Bytes = b"\x01"


///|
let incomplete_segment_size_message : Bytes = b"\x00\x00\x00\x00\x00"


///|
let missing_segment_data_message : Bytes = b"\x00\x00\x00\x00\x01\x00\x00\x00"


///|
let missing_segment_size_message : Bytes = b"\x01\x00\x00\x00\x00\x00\x00\x00"


///|
let missing_segment_size_padding_message : Bytes = b"\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"


///|
let empty_stream_message : Bytes = b""


///|
let http_request_message : Bytes = b"GET / HTTP/1.1\r\n\r\n"


///|
let max_segment_message : Bytes = [
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff,
]

// Code generated by scripts/gen_category_fixtures.py; DO NOT EDIT.
// Schema: test/category_fixtures.capnp


///|
let simple_bool_fixture : Bytes = b"\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00"


///|
let simple_int32_fixture : Bytes = b"\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\xc0\x1d\xfe\xff\x00\x00\x00\x00"


///|
let simple_int8_fixture : Bytes = b"\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\xd6\x00\x00\x00\x00\x00\x00\x00"


///|
let simple_uint64_fixture : Bytes = b"\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x84\xe2Pl\xe6|"


///|
let simple_uint16_fixture : Bytes = b"\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\xff\xff\x00\x00\x00\x00\x00\x00"


///|
let simple_float64_fixture : Bytes = b"\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\xc0"


///|
let simple_float32_fixture : Bytes = b"\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00`@\x00\x00\x00\x00"


///|
let simple_text_fixture : Bytes = b"\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x01\x00\x00\x002\x00\x00\x00hello\x00\x00\x00"


///|
let simple_bytes_fixture : Bytes = b"\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x01\x00\x00\x00\"\x00\x00\x00\x00\x01\x02\xff\x00\x00\x00\x00"


///|
let simple_bool_list_fixture : Bytes = b"\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x01\x00\x00\x00!\x00\x00\x00\x0d\x00\x00\x00\x00\x00\x00\x00"


///|
let simple_text_list_fixture : Bytes = [
  0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00,
  0x12, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x09, 0x00,
  0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x62, 0x62, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00,
]


///|
let medium_root_fixture : Bytes = [
  0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x04, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x3a, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00,
  0x1b, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x15, 0x00,
  0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x6d, 0x65, 0x64, 0x69, 0x75, 0x6d, 0x00, 0x00,
  0x0a, 0x00, 0xec, 0xff, 0x1e, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x63, 0x68, 0x69, 0x6c,
  0x64, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00,
  0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x22, 0x00,
  0x00, 0x00, 0x6f, 0x6e, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x74, 0x77, 0x6f, 0x00,
  0x00, 0x00, 0x00, 0x00,
]


///|
let medium_list_fixture : Bytes = [
  0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x02, 0x00, 0x05, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x00,
  0x21, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0xff, 0xff,
  0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00,
  0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x1a, 0x00,
  0x00, 0x00, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0x62, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
]


///|
let medium_numbers_fixture : Bytes = [
  0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x03, 0x00, 0x09, 0x00, 0x00, 0x00, 0x2a, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00,
  0x1c, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x6e, 0x75,
  0x6d, 0x73, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x02, 0x00, 0x00, 0x00,
  0x2c, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00,
]


///|
let medium_mixed_fixture : Bytes = [
  0x00, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
  0x03, 0x00, 0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00,
  0x16, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x14, 0x00,
  0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x05, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00,
  0x05, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x79, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x08, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
  0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x6b, 0x69, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00,
]


///|
let difficult_nested_fixture : Bytes = [
  0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x04, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x2a, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00,
  0x16, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x31, 0x00,
  0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x64, 0x65, 0x65, 0x70, 0x00, 0x00, 0x00, 0x00,
  0x05, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x1b, 0x00,
  0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfd, 0xff, 0x04, 0x00,
  0x05, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x07, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00,
  0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x1a, 0x00,
  0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x79, 0x79, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0xff, 0x00, 0x00, 0x00, 0x00,
]


///|
let difficult_union_fixture : Bytes = [
  0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
  0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x09, 0x00,
  0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0xf7, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
  0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x17, 0x00,
  0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xff,
  0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
]


///|
let difficult_deeplist_fixture : Bytes = [
  0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x03, 0x00, 0x09, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00,
  0x16, 0x00, 0x00, 0x00, 0x39, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x64, 0x65,
  0x65, 0x70, 0x32, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00,
  0x1d, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00,
  0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00,
  0x12, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00,
  0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x62, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00,
  0x01, 0x00, 0xfd, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x12, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00,
  0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00,
]


///|
let difficult_mixed_fixture : Bytes = [
  0x00, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x03, 0x00, 0x09, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00,
  0x47, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x6d, 0x69,
  0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,
  0x1d, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x00, 0x0b, 0x00,
  0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x25, 0x00, 0x00, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x25, 0x00,
  0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00,
  0x2d, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x6d, 0x31, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x78, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00,
  0x6d, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x02, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x12, 0x00, 0x00, 0x00, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,
  0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x7a, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
  0x0a, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
]

// Code generated by scripts/gen_convert_fixtures.py; DO NOT EDIT.
// Schema: test/fixtures.capnp
// Type: Root


///|
let convert_root_single_segment : Bytes = [
  0x00, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x06, 0x00, 0x15, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00,
  0x1c, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x25, 0x00,
  0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00,
  0x2d, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x32, 0x00,
  0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x2a, 0x00, 0x00, 0x00, 0x61, 0x6c, 0x70, 0x68,
  0x61, 0x00, 0x00, 0x00, 0x62, 0x65, 0x74, 0x61, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
  0x00, 0x00, 0xfe, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0xff, 0xff, 0x00, 0x00,
  0x00, 0x00, 0x7b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x22, 0x00, 0x00, 0x00, 0x6b, 0x69, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
  0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x09, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x6f, 0x6e, 0x65, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x74, 0x77, 0x6f, 0x00, 0x00, 0x00, 0x00, 0x00,
]


///|
let convert_root_multi_segment : Bytes = [
  0x0c, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x03, 0x00,
  0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
  0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x02, 0x00,
  0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
  0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x06, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
  0x05, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x02, 0x00,
  0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
  0x02, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x16, 0x00,
  0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
  0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x61, 0x6c,
  0x70, 0x68, 0x61, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x2a, 0x00, 0x00, 0x00,
  0x62, 0x65, 0x74, 0x61, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1c, 0x00,
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x05, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00,
  0x01, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
  0x01, 0x00, 0x7b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
  0x09, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x6b, 0x69,
  0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00,
  0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x01, 0x00,
  0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x6f, 0x6e, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x74, 0x77, 0x6f, 0x00, 0x00, 0x00,
  0x00, 0x00,
]


///|
fn assert_convert_root(root : @capnp.StructDecoder) -> Unit raise {
  let texts = root.read_list(0)
  let text_values : Array[String] = []
  for i = 0; i < texts.length(); i = i + 1 {
    text_values.push(texts.get_text(i))
  }
  inspect(text_values, content="[\"alpha\", \"beta\"]")
  let ints = root.read_list(1)
  let int_values : Array[Int] = []
  for i = 0; i < ints.length(); i = i + 1 {
    int_values.push(ints.get_int32(i))
  }
  inspect(int_values, content="[1, -2, 3]")
  let flags = root.read_list(2)
  let flag_values : Array[Bool] = []
  for i = 0; i < flags.length(); i = i + 1 {
    flag_values.push(flags.get_bool(i))
  }
  inspect(flag_values, content="[true, false, true]")
  let u16s = root.read_list(3)
  let u16_values : Array[Int] = []
  for i = 0; i < u16s.length(); i = i + 1 {
    u16_values.push(u16s.get_uint16(i).to_int())
  }
  inspect(u16_values, content="[1, 65535]")
  let child = root.read_pointer(4).as_struct()
  inspect((child.read_uint32(0), child.read_text(0)), content="(123, \"kid\")")
  let children = root.read_list(5)
  let child_values : Array[String] = []
  for i = 0; i < children.length(); i = i + 1 {
    let item = children.get_struct(i)
    child_values.push("\{item.read_uint32(0)}:\{item.read_text(0)}")
  }
  inspect(child_values, content="[\"1:one\", \"2:two\"]")
}

///|
test "simple_bool" {
  let bytes = simple_bool_fixture
  let root = decode_simple_root(bytes)
  inspect(root.read_bool(0), content="true")
}

///|
test "simple_int32" {
  let bytes = simple_int32_fixture
  let root = decode_simple_root(bytes)
  inspect(root.read_int32(0), content="-123456")
}

///|
test "simple_text" {
  let bytes = simple_text_fixture
  let root = decode_simple_root(bytes)
  inspect(root.read_text(0), content="hello")
}

///|
test "roundtrip_empty_single_segment" {
  let bytes = empty_single_segment_message
  let msg = @capnp.Message::parse(bytes[:])
  let encoded = msg.encode()
  assert_bytes_eq(encoded, bytes)
}

///|
test "error/truncated_header" {
  // Message with incomplete header (less than 8 bytes)
  let bytes : Bytes = [0x00, 0x00, 0x00]
  let result : Result[@capnp.Pointer, Error] = try? @capnp.Decoder::from_bytes(
    bytes[:],
  ).root()
  guard result is Err(_) else { fail("Expected error for truncated header") }
}

///|
test "error/invalid_segment_count" {
  // Header with segmentCountMinusOne = 0xFFFFFFFF (segment count too large)
  let bytes : Bytes = [
    0xFF, 0xFF, 0xFF, 0xFF, // Segment count = 0xFFFFFFFF (invalid)
     0x00, 0x00, 0x00, 0x00,
  ]
  let result : Result[@capnp.Pointer, Error] = try? @capnp.Decoder::from_bytes(
    bytes[:],
  ).root()
  guard result is Err(_) else {
    fail("Expected error for invalid segment count")
  }
}

///|
test "error/pointer_out_of_bounds" {
  // Valid header but pointer references beyond data
  let bytes : Bytes = [
    0x00, 0x00, 0x00, 0x00, // 1 segment
     0x01, 0x00, 0x00, 0x00, // Segment size = 1 word (8 bytes)
    // Root pointer pointing way beyond segment
     0x00, 0x00, 0xFF, 0xFF, // Struct pointer with large offset
     0x00, 0x00, 0x00, 0x00,
  ]
  let result : Result[@capnp.Pointer, Error] = try? @capnp.Decoder::from_bytes(
    bytes[:],
  ).root()
  guard result is Err(_) else {
    fail("Expected error for pointer out of bounds")
  }
}

///|
test "error/invalid_pointer_kind" {
  // Pointer with invalid kind bits (kind = 3)
  let bytes : Bytes = [
    0x00, 0x00, 0x00, 0x00, // 1 segment
     0x01, 0x00, 0x00, 0x00, // Segment size = 1 word
     0x03, 0x00, 0x00, 0x00, // Invalid pointer kind (bits 0-1 = 3)
     0x00, 0x00, 0x00, 0x00,
  ]
  let result : Result[@capnp.StructDecoder, Error] = try? {
    let decoder = @capnp.Decoder::from_bytes(bytes[:])
    decoder.root().as_struct()
  }
  guard result is Err(_) else {
    fail("Expected error for invalid pointer kind")
  }
}

///|
test "list/get_int16/empty" {
  let writer = @capnp.MessageWriter::new()
  let list = @capnp.MessageWriter::init_root_list(
    writer,
    @capnp.ListElementKind::Byte2,
    0,
  )
  let _ = list
  let bytes = writer.to_bytes()
  let decoder = @capnp.Decoder::from_bytes(bytes[:])
  let list_decoder = decoder.root().as_list()
  inspect(list_decoder.length(), content="0")
}

///|
test "list/get_int16/values" {
  let writer = @capnp.MessageWriter::new()
  let list = @capnp.MessageWriter::init_root_list(
    writer,
    @capnp.ListElementKind::Byte2,
    4,
  )
  list.set_int16(0, (0 : Int16))
  list.set_int16(1, (32767 : Int16))
  list.set_int16(2, (-32768 : Int16))
  list.set_int16(3, (-1 : Int16))
  let bytes = writer.to_bytes()
  let decoder = @capnp.Decoder::from_bytes(bytes[:])
  let list_decoder = decoder.root().as_list()
  let values : Array[Int] = []
  for i = 0; i < list_decoder.length(); i = i + 1 {
    values.push(list_decoder.get_int16(i).to_int())
  }
  inspect(values, content="[0, 32767, -32768, -1]")
}

///|
test "list/get_uint16/values" {
  let writer = @capnp.MessageWriter::new()
  let list = @capnp.MessageWriter::init_root_list(
    writer,
    @capnp.ListElementKind::Byte2,
    3,
  )
  list.set_uint16(0, (0 : UInt16))
  list.set_uint16(1, (65535 : UInt16))
  list.set_uint16(2, (1000 : UInt16))
  let bytes = writer.to_bytes()
  let decoder = @capnp.Decoder::from_bytes(bytes[:])
  let list_decoder = decoder.root().as_list()
  let values : Array[Int] = []
  for i = 0; i < list_decoder.length(); i = i + 1 {
    values.push(list_decoder.get_uint16(i).to_int())
  }
  inspect(values, content="[0, 65535, 1000]")
}
