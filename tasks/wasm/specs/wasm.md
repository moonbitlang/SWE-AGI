# WebAssembly Core (binary format + validation) — specification for this repo

This document is a **practical, test-oriented spec** for the `wasm`
package. It summarizes the WebAssembly binary decoding + validation behaviors
required by this repository’s MoonBit API and tests.

It is **not** a verbatim copy of the WebAssembly specification.

## Objectives (what the implementation must do)

The `wasm` package expects an implementation that can:

1. Decode a `.wasm` binary into a `Module` AST (`decode_module`).
2. Validate the decoded module for structural/semantic correctness
   (`validate_module`).
3. Print a decoded module to canonical text format (`Module::print`) matching
   the snapshots generated by `wasm-tools print`.
4. Raise `DecodeError` for malformed binaries and `ValidationError` for invalid
   modules that are well-formed at the binary level.

## Primary references

- WebAssembly Core Spec (linked by this repo): `wasm/specs/w3.txt`
  - Current link in repo: https://www.w3.org/TR/wasm-core-2/
- wasm-tools (canonical printer used by tests):
  - https://github.com/bytecodealliance/wasm-tools

## Scope and explicit non-goals

### Scope

- Binary format decoding sufficient to parse modules produced by the test corpus.
- Validation rules sufficient to match the test corpus’s “valid” vs “invalid”
  classification.
- Deterministic printing in the same style as `wasm-tools print`.

### Non-goals

- Execution / interpreter / JIT.
- Full feature-gating across all proposals beyond what the corpus requires.
- Text-format parser (WAT → WASM) (not part of this suite).

## API contract (from `wasm/wasm_spec.mbt`)

- `decode_module(data : Bytes) -> Module raise DecodeError`
  - `DecodeError` includes: `InvalidMagicNumber`, `UnsupportedVersion`,
    `UnexpectedEnd`, `LengthOutOfBounds`, `ParseError(String)`.
- `validate_module(mod_ : Module) -> Unit raise ValidationError`
  - `ValidationError::InvalidModule(String)` for validation failures.
- `Module::print(self : Module) -> String`
  - Must match the snapshot style used in tests.

## Binary decoding (test-oriented summary)

### Header

- Magic: `\0asm` (`0x00 0x61 0x73 0x6d`)
- Version: little-endian u32, typically `0x01 0x00 0x00 0x00`

Invalid magic → `InvalidMagicNumber`.
Unsupported version → `UnsupportedVersion`.

### Integers and lengths

The binary format uses LEB128 for many integers:

- `varuint32`, `varint32`, `varint64`, etc.
- Section sizes and vector lengths are encoded as varuint32.

Decoder requirements:

- Detect truncated inputs → `UnexpectedEnd`.
- Detect out-of-bounds section lengths → `LengthOutOfBounds`.
- Validate that vectors do not claim sizes that exceed available bytes.

### Sections

Modules are sequences of sections (some custom, some known). The decoder must:

- Parse known sections needed by the corpus (type, import, function, table,
  memory, global, export, start, element, code, data, and custom).
- Preserve enough information in `Module` for `print` and `validate`.
- Parse function bodies: locals, instruction stream, and `end` markers.

Unknown/custom sections:

- Custom sections should be skipped/recorded as needed for printing.
- Unknown non-custom section IDs should be rejected as malformed.

## Validation (test-oriented summary)

Validation checks the decoded module’s internal consistency. Key rules commonly
exercised by corpora include:

- Index bounds: function/type/table/memory/global references must exist.
- Type checking of instructions: stack discipline and operand/result types.
- Function body correctness: reachable `end`, structured control blocks properly
  nested.
- Limits and constraints: e.g. memory/table limits and element/data segment
  validity.

The test corpus (`wasm_smith_reference_valid_test.mbt` and
`wasm_smith_reference_invalid_test.mbt`) distinguishes decode errors from
validation errors; implementers should aim to:

- Raise `DecodeError` when the binary is not well-formed.
- Raise `ValidationError` when well-formed but invalid.

## Printing

`Module::print()` must match the canonical text form emitted by `wasm-tools print`
(tests snapshot that output). Practical implications:

- Use the same naming/indexing conventions as wasm-tools for functions, locals,
  types, etc.
- Preserve ordering of sections/definitions as printed by wasm-tools.
- Emit deterministically (no hash-map iteration nondeterminism).

## Conformance checklist (high value test coverage)

- Header + version checks
- LEB128 decoding and length/bounds enforcement
- Section parsing, especially Code section + instruction decoding
- Distinguish decode vs validation failures
- Canonical printing matching wasm-tools snapshots

## Binary format details commonly exercised by corpora

This suite is derived from a reference corpus (see `wasm_spec.mbt`). In
practice, wasm corpora frequently stress:

### LEB128 corner cases

- Minimal-length encodings vs overlong encodings (where validation demands).
- Signed vs unsigned interpretation (e.g. `i32.const` uses signed LEB128).
- Very large lengths that would overflow host integers:
  - Must be rejected as `LengthOutOfBounds` (or `ParseError(...)`) rather than
    allocating huge buffers.

### Section boundaries

Every section is encoded as:

- `section_id : byte`
- `section_size : varuint32`
- `section_payload : bytes[section_size]`

Decoder expectations:

- Reject `section_size` that points beyond available data.
- For known sections, reject malformed payloads (bad vector lengths, etc.).
- Preserve enough structure in `Module` for printing and validation.

### Code section structure

Function bodies are encoded as:

- `body_size : varuint32`
- `local_decls : vec(local_decl)`
- `instructions` terminated by `end`

Common failure modes:

- Missing `end` (decode error vs validation error depending on encoding).
- Declared `body_size` not matching consumed bytes.
- Truncated locals or instruction streams.

## Validation: practical “must check” list

While the full spec has many rules, corpora typically ensure at least:

- Indices are in range:
  - function/type/table/memory/global indices referenced must exist.
- Function body type correctness:
  - Stack operand types match instruction requirements.
  - Block signatures and `if`/`else`/`end` structure is consistent.
- Limits are sane:
  - tables/memories respect min/max and page sizing rules.
- Element/data segments are well-typed and reference valid indices.

Return `ValidationError::InvalidModule(...)` for semantic failures.

## Printing stability requirements

Because tests compare the output of `Module::print` against a canonical printer:

- Never iterate hash maps in an unstable order when emitting text.
- Ensure printing uses the same section ordering and canonical forms as
  `wasm-tools print` for constructs present in the corpus.

If the implementation keeps extra metadata in `Module`, it must not leak into
printing unless wasm-tools would print it.

## Test suite mapping

- `wasm/wasm_smith_reference_valid_test.mbt`: decoding+printing+validation of valid modules
- `wasm/wasm_smith_reference_invalid_test.mbt`: decoding/validation failures for invalid modules
- `wasm/wasm_helpers.mbt`: corpus helpers and printing comparison glue

