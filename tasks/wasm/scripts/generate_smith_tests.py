#!/usr/bin/env python3
"""Generate MoonBit tests from `wasm-tools smith`.

This script produces a MoonBit `.mbt` file containing many small Wasm binaries
(and a few intentionally malformed variants) as test cases.

It is deterministic: given the same CLI arguments, it emits the same output.

Examples:
  python3 scripts/generate_smith_tests.py --count 200 --seed 0 --seed-size 64
  python3 scripts/generate_smith_tests.py --count 50 --seed 123 --config smith.json
"""

from __future__ import annotations

import argparse
import hashlib
import subprocess
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable, List, Optional


ROOT_DIR = Path(__file__).resolve().parents[1]

OUTPUT_VALID = ROOT_DIR / "wasm_smith_reference_valid_test.mbt"
OUTPUT_INVALID = ROOT_DIR / "wasm_smith_reference_invalid_test.mbt"

LICENSE_HEADER = """// ============================================================================
// AUTO-GENERATED FILE - DO NOT MODIFY MANUALLY
// Generated by: scripts/generate_smith_tests.py
// Regenerate with: python3 scripts/generate_smith_tests.py
// ============================================================================

///|
/// WebAssembly Decoder/Validator - Generated Reference Tests
///
/// Generation:
/// - `wasm-tools smith` for generating candidates
/// - `wasm-tools print` for parsing (well-formedness)
/// - `wasm-tools validate` for validation (semantic validity)
///
/// Expectations in this file are snapshots of reference tool error strings.
/// Implementations are expected to match these messages (after escaping).

"""


def sanitize_test_name(s: str) -> str:
    out = []
    for ch in s:
        if ch.isalnum() or ch in "_-/": 
            out.append(ch)
        else:
            out.append("_")
    return "".join(out)


def escape_moonbit_string(s: str) -> str:
    s = s.replace("\\", "\\\\")
    s = s.replace('"', "\\\"")
    s = s.replace("\r", "")
    s = s.replace("\n", "\\n")
    s = s.replace("\t", "\\t")
    return s


def bytes_to_moonbit_chunks(data: bytes, chunk_size: int) -> List[str]:
    chunks: List[str] = []
    for i in range(0, len(data), chunk_size):
        part = data[i : i + chunk_size]
        chunks.append("".join(f"\\x{b:02x}" for b in part))
    return chunks


def moonbit_bytes_expr(data: bytes, chunk_size: int) -> str:
    chunks = bytes_to_moonbit_chunks(data, chunk_size=chunk_size)
    if not chunks:
        return 'b""'
    if len(chunks) == 1:
        return f'b"{chunks[0]}"'
    lines = ["bytes_concat(["]
    for c in chunks:
        lines.append(f'  b"{c}",')
    lines.append("])\n")
    return "\n".join(lines).rstrip("\n")


def ensure_wasm_tools() -> None:
    try:
        subprocess.run(["wasm-tools", "--version"], check=True, capture_output=True, text=True)
    except FileNotFoundError:
        print("Error: wasm-tools not found in PATH", file=sys.stderr)
        sys.exit(1)
    except subprocess.CalledProcessError as e:
        print(f"Error: wasm-tools failed: {e}", file=sys.stderr)
        sys.exit(1)


def run_wasm_smith(seed_bytes: bytes, config_path: Optional[Path]) -> bytes:
    cmd = ["wasm-tools", "smith"]
    if config_path is not None:
        cmd.extend(["--config", str(config_path)])
    proc = subprocess.run(
        cmd,
        input=seed_bytes,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
    )
    if proc.returncode == 0:
        return proc.stdout
    if proc.returncode == 2:
        raise RuntimeError("smith failed to generate module from seed")
    raise RuntimeError(proc.stderr.decode("utf-8", errors="replace").strip() or "smith failed")


def run_wasm_tools_print(data: bytes, *, skeleton: bool, name_unnamed: bool) -> tuple[bool, str, str]:
    cmd = ["wasm-tools", "print"]
    if skeleton:
        cmd.append("--skeleton")
    if name_unnamed:
        cmd.append("--name-unnamed")
    cmd.append("-")
    proc = subprocess.run(
        cmd,
        input=data,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
    )
    out = proc.stdout.decode("utf-8", errors="replace").replace("\r\n", "\n")
    err = proc.stderr.decode("utf-8", errors="replace").strip()
    return (proc.returncode == 0, out, err)


def run_wasm_tools_validate(data: bytes, features: str) -> tuple[bool, str]:
    proc = subprocess.run(
        ["wasm-tools", "validate", "--features", features, "-"],
        input=data,
        stdout=subprocess.DEVNULL,
        stderr=subprocess.PIPE,
    )
    msg = proc.stderr.decode("utf-8", errors="replace").strip()
    return (proc.returncode == 0, msg)


def derive_seed_bytes(seed: int, index: int, seed_size: int) -> bytes:
    # Hash-based derivation gives stable, widely-distributed bytes.
    h = hashlib.sha256(f"{seed}:{index}".encode("utf-8")).digest()
    out = bytearray()
    while len(out) < seed_size:
        out.extend(h)
        h = hashlib.sha256(h).digest()
    return bytes(out[:seed_size])


@dataclass(frozen=True)
class Case:
    name: str
    bytes_data: bytes
    kind: str  # "valid" | "malformed" | "invalid"
    expected_print: Optional[str] = None
    expected_error: Optional[str] = None


def generate_cases(
    *,
    count: int,
    malformed_count: int,
    seed: int,
    seed_size: int,
    chunk_size: int,
    config_path: Optional[Path],
    malformed_per_valid: int,
    max_retries: int,
    features: str,
    print_skeleton: bool,
    print_name_unnamed: bool,
) -> List[Case]:
    cases: List[Case] = []

    valid_modules: List[bytes] = []

    for i in range(count):
        base_seed = derive_seed_bytes(seed, i, seed_size)
        wasm_bytes: Optional[bytes] = None
        for attempt in range(max_retries):
            try_seed = base_seed + bytes([attempt])
            try:
                candidate = run_wasm_smith(try_seed, config_path=config_path)
                parse_ok, _wat, _parse_err = run_wasm_tools_print(
                    candidate,
                    skeleton=print_skeleton,
                    name_unnamed=print_name_unnamed,
                )
                if not parse_ok:
                    continue
                ok, _msg = run_wasm_tools_validate(candidate, features=features)
                if ok:
                    wasm_bytes = candidate
                    break
            except RuntimeError:
                continue
        if wasm_bytes is None:
            continue
        valid_modules.append(wasm_bytes)

    for i, wasm_bytes in enumerate(valid_modules):
        _ok, wat, _err = run_wasm_tools_print(
            wasm_bytes,
            skeleton=print_skeleton,
            name_unnamed=print_name_unnamed,
        )
        cases.append(
            Case(
                name=f"smith/valid/seed_{seed}/case_{i:04d}",
                bytes_data=wasm_bytes,
                kind="valid",
                expected_print=wat,
            )
        )

    # Malformed/invalid variants based on valid modules.
    if malformed_per_valid > 0:
        for i, wasm_bytes in enumerate(valid_modules):
            variants: List[tuple[str, bytes]] = []

            if len(wasm_bytes) > 0:
                variants.append(("truncated_last_byte", wasm_bytes[:-1]))
            variants.append(("append_section_id_only", wasm_bytes + b"\x00"))
            if len(wasm_bytes) >= 8:
                bad = bytearray(wasm_bytes)
                bad[4:8] = b"\x00\x00\x00\x00"
                variants.append(("bad_version", bytes(bad)))

            for tag, data in variants[:malformed_per_valid]:
                parse_ok, _wat, parse_err = run_wasm_tools_print(
                    data,
                    skeleton=print_skeleton,
                    name_unnamed=print_name_unnamed,
                )
                if not parse_ok:
                    cases.append(
                        Case(
                            name=f"smith/malformed/{tag}/seed_{seed}/case_{i:04d}",
                            bytes_data=data,
                            kind="malformed",
                            expected_error=parse_err,
                        )
                    )
                    continue

                valid_ok, valid_msg = run_wasm_tools_validate(data, features=features)
                if not valid_ok:
                    cases.append(
                        Case(
                            name=f"smith/invalid/{tag}/seed_{seed}/case_{i:04d}",
                            bytes_data=data,
                            kind="invalid",
                            expected_error=valid_msg,
                        )
                    )

    # Extra malformed cases from arbitrary bytes (deterministic).
    for i in range(malformed_count):
        raw = derive_seed_bytes(seed + 999_983, i, seed_size)
        parse_ok, _wat, parse_err = run_wasm_tools_print(
            raw,
            skeleton=print_skeleton,
            name_unnamed=print_name_unnamed,
        )
        if not parse_ok:
            cases.append(
                Case(
                    name=f"raw/malformed/seed_{seed}/case_{i:04d}",
                    bytes_data=raw,
                    kind="malformed",
                    expected_error=parse_err,
                )
            )

    return cases


def moonbit_multiline_raw_block_lines(s: str, *, indent: str) -> List[str]:
    # Emit MoonBit raw multiline string using `#|` per line.
    # Keep a trailing newline if present in reference output.
    s = s.replace("\r\n", "\n")
    lines = s.split("\n")
    return [f"{indent}#|{line}" for line in lines]


def emit_moonbit_tests(cases: Iterable[Case], chunk_size: int, features: str) -> str:
    out_lines: List[str] = [LICENSE_HEADER]
    out_lines.append(f"// Reference validation features: {features}\n")

    for case in cases:
        test_name = sanitize_test_name(case.name)
        out_lines.append("///|")
        out_lines.append(f'test "{test_name}" {{')
        out_lines.append(
            f"  let bytes : Bytes = {moonbit_bytes_expr(case.bytes_data, chunk_size=chunk_size)}"
        )

        if case.kind == "valid":
            out_lines.append("  let m = @wasm.decode_module(bytes)")
            out_lines.append("  inspect(m.print(), content=(")
            out_lines.extend(
                moonbit_multiline_raw_block_lines(case.expected_print or "", indent="    ")
            )
            out_lines.append("  ))")
            out_lines.append("  @wasm.validate_module(m)")
        elif case.kind == "invalid":
            out_lines.append("  let m = @wasm.decode_module(bytes)")
            expected = escape_moonbit_string(case.expected_error or "")
            out_lines.append("  try @wasm.validate_module(m) catch {")
            out_lines.append(f'    e => inspect(e.to_string(), content="{expected}")')
            out_lines.append("  } noraise {")
            out_lines.append('    _ => fail("expected ValidationError, got Ok")')
            out_lines.append("  }")
        else:
            expected = escape_moonbit_string(case.expected_error or "")
            out_lines.append("  try @wasm.decode_module(bytes) catch {")
            out_lines.append(f'    e => inspect(e.to_string(), content="{expected}")')
            out_lines.append("  } noraise {")
            out_lines.append('    _ => fail("expected DecodeError, got Ok")')
            out_lines.append("  }")

        out_lines.append("}")
        out_lines.append("")

    return "\n".join(out_lines)


def main() -> None:
    parser = argparse.ArgumentParser()
    parser.add_argument("--count", type=int, default=200, help="number of valid modules")
    parser.add_argument("--seed", type=int, default=0, help="base seed for deterministic generation")
    parser.add_argument("--seed-size", type=int, default=64, help="seed byte length passed to smith")
    parser.add_argument(
        "--chunk-size",
        type=int,
        default=32,
        help="bytes per MoonBit bytes-literal chunk",
    )
    parser.add_argument(
        "--config",
        type=str,
        default=None,
        help="optional wasm-smith JSON config file (passed to wasm-tools smith --config)",
    )
    parser.add_argument(
        "--malformed-per-valid",
        type=int,
        default=2,
        help="how many malformed variants to keep per valid module",
    )
    parser.add_argument(
        "--malformed-count",
        type=int,
        default=200,
        help="how many additional random malformed cases to try",
    )
    parser.add_argument(
        "--features",
        type=str,
        default="all",
        help="features passed to `wasm-tools validate --features`",
    )
    parser.add_argument(
        "--print-skeleton",
        action="store_true",
        help="use `wasm-tools print --skeleton` for reference output",
    )
    parser.add_argument(
        "--print-name-unnamed",
        action="store_true",
        help="use `wasm-tools print --name-unnamed` for reference output",
    )
    parser.add_argument(
        "--max-retries",
        type=int,
        default=16,
        help="max attempts per case when smith fails (rc=2)",
    )

    args = parser.parse_args()

    ensure_wasm_tools()

    config_path = Path(args.config).resolve() if args.config else None
    if config_path is not None and not config_path.exists():
        print(f"Error: config not found: {config_path}", file=sys.stderr)
        sys.exit(1)

    print("Generating wasm-smith tests...")
    cases = generate_cases(
        count=args.count,
        malformed_count=max(0, args.malformed_count),
        seed=args.seed,
        seed_size=args.seed_size,
        chunk_size=args.chunk_size,
        config_path=config_path,
        malformed_per_valid=max(0, args.malformed_per_valid),
        max_retries=max(1, args.max_retries),
        features=args.features,
        print_skeleton=bool(args.print_skeleton),
        print_name_unnamed=bool(args.print_name_unnamed),
    )

    cases = sorted(cases, key=lambda c: c.name)

    valid_cases = [c for c in cases if c.kind == "valid"]
    invalid_cases = [c for c in cases if c.kind != "valid"]

    for path, subset in [
        (OUTPUT_VALID, valid_cases),
        (OUTPUT_INVALID, invalid_cases),
    ]:
        print(f"Writing {len(subset)} tests to: {path}")
        path.write_text(
            emit_moonbit_tests(subset, chunk_size=args.chunk_size, features=args.features),
            encoding="utf-8",
        )


if __name__ == "__main__":
    main()
