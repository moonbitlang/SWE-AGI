# C99 (ISO/IEC 9899:1999) — parser-oriented specification

This document is a **practical, test-oriented spec** of the C language as standardized by **ISO/IEC 9899:1999 (C99)**: clear rules, examples, and explicit scoping notes.

It is **not** a reproduction of the ISO standard text. For authoritative wording and full grammar, consult the references below.

## Objectives

This `c99` package expects an implementation that can:

1. Parse a C99 **translation unit** (roughly: a `.c` file after preprocessing) into an AST (`CProgram`).
2. Produce a stable JSON view of the AST (`CProgram::to_test_json()`), used by `c99_valid_test.mbt` as a conformance oracle.

Unless noted otherwise, “must” in this document means “required to match the test suite’s intent”.

## Primary references

### ISO/IEC text (normative; paywalled)

- **ISO/IEC 9899:1999 — Programming languages — C** (1999-12).  
  ISO catalog: https://www.iso.org/standard/29237.html  
  IEC webstore: https://webstore.iec.ch/en/publication/21714

### Freely accessible working draft (reading reference)

- **WG14 N1256** (“C99 + TC3” working draft reference)
  - PDF: https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf
  - HTML (anchored): https://port70.net/~nsz/c/c99/n1256.html

### Corrigenda (normative fixes; availability varies)

- Cor 1 (2001): https://www.iso.org/standard/35952.html
- Cor 2 (2004): https://www.iso.org/standard/41326.html
- Cor 3 (2007): https://www.iso.org/standard/50510.html

### Secondary pointers

- GCC language modes overview: https://gcc.gnu.org/onlinedocs/gcc/Standards.html
- Curated standards/drafts index (incl. N1256): https://c-resources.github.io/reference/standard.html

## Table of contents

- [Scope and non-goals](#scope-and-non-goals)
- [Preliminaries](#preliminaries)
- [Translation phases (context)](#translation-phases-context)
- [Lexical elements](#lexical-elements)
- [Operators and punctuators](#operators-and-punctuators)
- [Syntax overview](#syntax-overview)
- [Declarations and types](#declarations-and-types)
- [Initializers](#initializers)
- [Statements](#statements)
- [Expressions](#expressions)
- [Constraints and diagnostics](#constraints-and-diagnostics)
- [Environment-dependent behavior](#environment-dependent-behavior)
- [AST/JSON expectations (this repo)](#astjson-expectations-this-repo)

## Scope and non-goals

### Scope

- **Language**: C99 core language (Clause 6), with the common corrigenda folded in where relevant.
- **Input**: The parser consumes a *translation unit*, i.e. a stream of tokens corresponding to C source **after preprocessing** (see translation phases).
- **Output**: An AST annotated with enough type information to satisfy `c99_valid_test.mbt`.

### Non-goals (unless your implementation chooses to go further)

- Full preprocessing: macro expansion, conditional inclusion, header search, etc.
- Complete semantic analysis and diagnostics as a production compiler would do (e.g. full constraint checking, type checking of all expressions, UB analysis).
- Code generation / evaluation.

If your parser chooses to accept additional extensions or implement preprocessing, keep behavior compatible with the tests.

## Preliminaries

### Source text model

- Treat the input as a sequence of characters. The tests primarily use ASCII; a robust implementation should accept UTF-8 as byte input and operate on Unicode scalar values, but the C standard’s core model is defined in terms of *source character set* and *execution character set*.
- Newlines may appear as LF (`\n`) or CRLF (`\r\n`). Treat both as line breaks.

### Whitespace and comments

Whitespace separates tokens but is otherwise insignificant except where it would break a token.

- Spaces, tabs, and newlines are whitespace.
- Comments behave like whitespace:
  - Block comments: `/* ... */` (not nestable).
  - Line comments: `// ...` (to end of line).

Examples:

```c
int/*comment*/x;   // same as: int x;
```

Unterminated comments are invalid:

```c
int x; /* INVALID
```

## Translation phases (context)

C99 defines multiple translation phases. For this test suite, the important takeaway is:

- A C parser is typically specified over the token stream **after** preprocessing has produced the final sequence of preprocessing tokens, removed directives, performed macro expansion, and handled line splicing.
- The tests in `c99_valid_test.mbt` are written as ordinary C snippets and do not rely on `#include` / `#define`-style preprocessing.

Practical requirement for this repo:

- You may implement a “direct” lexer+parser over the raw characters, but the tokenization should correspond to what a C99 implementation would see after preprocessing (e.g. `//` comments, `...` token, maximal-munch on operators).

## Lexical elements

### Token classes

At a high level, a translation unit tokenizes into:

- identifiers
- keywords
- constants (integer, floating, character)
- string literals
- punctuators (operators and separators)

Tokens are recognized using a **maximal munch** rule: when multiple tokenizations are possible at a position, choose the longest token (with the usual C caveats around preprocessing vs parsing).

### Keywords (C99)

Core C99 keywords (not exhaustive in this summary) include:

`auto`, `break`, `case`, `char`, `const`, `continue`, `default`, `do`, `double`,
`else`, `enum`, `extern`, `float`, `for`, `goto`, `if`, `inline`, `int`,
`long`, `register`, `restrict`, `return`, `short`, `signed`, `sizeof`, `static`,
`struct`, `switch`, `typedef`, `union`, `unsigned`, `void`, `volatile`,
`while`, `_Bool`, `_Complex`, `_Imaginary`.

Notes:

- `_Imaginary` and complex arithmetic are optional in many toolchains, but they are part of C99’s keyword set.
- If your parser doesn’t implement complex types, you can still lex them as keywords and reject or treat them as unsupported type specifiers.

### Identifiers

Identifiers start with a nondigit and continue with nondigits/digits. In practice:

```text
identifier := (A-Z | a-z | _) (A-Z | a-z | 0-9 | _)*
```

C99 also allows universal character names and other source character set rules; this suite does not require deep coverage of those.

### Constants

#### Integer constants

Integer constants may be:

- decimal: `0` or `[1-9][0-9]*`
- octal: `0[0-7]*`
- hexadecimal: `0x[0-9a-fA-F]+` or `0X...`

Suffixes can specify width/sign:

- `u` / `U` (unsigned)
- `l` / `L` (long)
- `ll` / `LL` (long long)

Examples:

```c
42
0
0777
0xff
42U
42L
42ULL
```

The *type* of an integer constant in C99 is chosen by a rule set based on base, suffix, and value range. For this repo, the tests focus on values/suffixes that make the intended type unambiguous.

#### Floating constants

Floating constants come in:

- decimal floating: `3.14`, `1e9`, `1.0e-3`
- hexadecimal floating (C99): `0x1.2p3`

Suffixes:

- `f` / `F` → `float`
- `l` / `L` → `long double`
- (no suffix) → `double`

Examples:

```c
42.0f
3.0
1e-9
0x1.8p+1
```

#### Character constants

Character constants are enclosed in single quotes:

```c
'a'
'\\n'
'\\x41'
```

Wide character constants use `L'…'`.

Multi-character constants (e.g. `'ab'`) exist in C but are implementation-defined; avoid relying on them in spec tests unless you specify a concrete policy.

#### String literals

String literals are enclosed in double quotes and may contain escapes:

```c
"hello"
"line\\n"
"\\x48\\x69"
```

Adjacent string literals are concatenated at translation time:

```c
"hello" " " "world"   // equivalent to "hello world"
```

## Operators and punctuators

The C99 punctuators include (grouped informally):

- Separators: `(` `)` `[` `]` `{` `}` `,` `;` `:` `?`
- Member/indirection: `.` `->`
- Arithmetic/bitwise: `+` `-` `*` `/` `%` `~` `^` `|` `&`
- Inc/dec: `++` `--`
- Shifts: `<<` `>>`
- Comparisons: `<` `>` `<=` `>=` `==` `!=`
- Logical: `!` `&&` `||`
- Assignment: `=` `*=` `/=` `%=` `+=` `-=` `<<=` `>>=` `&=` `^=` `|=`
- Variadic / ellipsis: `...`

Preprocessor-only punctuators (like `#` and `##`) exist at preprocessing time; this suite does not require implementing them as part of the parser.

## Syntax overview

The full grammar is specified in the standard (see N1256 for an accessible form). This section provides a **parser-focused skeleton** and a few key disambiguation notes.

### Translation unit

- A translation unit is a sequence of external declarations:

```text
translation-unit := external-declaration*
external-declaration := function-definition | declaration
```

### Function definitions vs declarations

In C, the same leading sequence of specifiers can start either a declaration or a function definition:

```c
int f(int x);         // declaration
int f(int x) { ... }  // definition
```

Disambiguation depends on whether a compound statement (`{ ... }`) follows the declarator.

### Expression precedence (core for parsing)

From tightest to loosest (highest precedence to lowest):

1. Postfix: `()`, `[]`, `.`, `->`, postfix `++/--`
2. Unary: prefix `++/--`, unary `+ - ! ~`, `*` (indirection), `&` (address), `sizeof`, cast
3. Multiplicative: `* / %`
4. Additive: `+ -`
5. Shift: `<< >>`
6. Relational: `< > <= >=`
7. Equality: `== !=`
8. Bitwise AND: `&`
9. Bitwise XOR: `^`
10. Bitwise OR: `|`
11. Logical AND: `&&`
12. Logical OR: `||`
13. Conditional: `?:`
14. Assignment: `=, *=, ...`
15. Comma: `,`

## Declarations and types

### Type specifiers

The core scalar type specifiers include:

- `void`
- integer types: `char`, `short`, `int`, `long`, `long long`, with `signed`/`unsigned`
- floating types: `float`, `double`, `long double`
- `_Bool`
- `_Complex` / `_Imaginary` (complex/imaginary variants of arithmetic types)

User-defined and composite types:

- `struct` / `union` specifiers
- `enum` specifiers
- `typedef` names (contextual: identifier that refers to a typedef)

### Type qualifiers and storage-class specifiers

Qualifiers:

- `const`, `volatile`, `restrict`

Storage classes:

- `typedef`, `extern`, `static`, `auto`, `register`

Function specifier (C99):

- `inline`

### Declarators (the “inside-out” part)

C declarators bind in a way that often surprises people:

```c
int *p;        // p: pointer to int
int (*fp)(int);// fp: pointer to function(int)->int
int a[10];     // a: array[10] of int
```

Parsing rule of thumb:

- `*` and qualifiers build pointer layers around a “direct declarator”.
- Parentheses can group declarators to override default binding.

### Derived types and composition

C builds derived types from base types via:

- pointers (`T *`)
- arrays (`T [n]`, including VLAs)
- functions (`T (params...)`)

## Initializers

### Scalar initialization

Scalars can be initialized from an assignment expression:

```c
int x = 1 + 2;
```

### Aggregate initialization

Arrays/structs can be initialized with brace-enclosed initializer lists:

```c
int a[3] = { 1, 2, 3 };
```

### Designated initializers (C99)

Designators select which element/field is initialized:

```c
struct S { int x; int y; };
struct S s = { .y = 2, .x = 1 };
```

Array designators:

```c
int a[5] = { [3] = 7 };
```

## Statements

C99 statements include:

- labeled statements: `id: stmt`, `case ...: stmt`, `default: stmt`
- compound statements: `{ ... }`
- expression statements: `expr?;`
- selection: `if (...) ... else ...`, `switch (...) ...`
- iteration: `while`, `do ... while`, `for`
- jumps: `goto`, `continue`, `break`, `return`

Declarations can appear as block items in compound statements (mixed declarations and statements are allowed).

## Expressions

This section highlights a few areas that affect parsing and type annotation in typical ASTs.

### Primary and postfix

Primary expressions include identifiers, constants, string literals, and parenthesized expressions.

Postfix expressions add:

- function calls: `f(a, b)`
- subscripting: `a[i]`
- member access: `s.x`, `p->x`
- postfix `++/--`

### Casts

Cast syntax:

```c
(int)expr
```

In parsing, casts can conflict with parenthesized expressions; disambiguation relies on whether the parenthesized content parses as a type name (including typedef names).

### `sizeof`

`sizeof` applies to either an expression or a parenthesized type name:

```c
sizeof x
sizeof(int)
```

### Conditional operator

The conditional operator is right-associative:

```c
a ? b : c ? d : e   // parses as: a ? b : (c ? d : e)
```

## Constraints and diagnostics

The C standard distinguishes:

- **syntax rules** (grammar)
- **constraints** (“shall” rules in constraint sections; violations require a diagnostic)
- **undefined/unspecified/implementation-defined behavior**

For this repo’s parser:

- **Must reject** malformed tokens (e.g. unterminated string/comment) and grammar-invalid programs.
- Constraint checking beyond syntax is useful but only required insofar as the test suite expects it.

Recommended behavior for `ParseError`:

- Include a short message and (if available) a line/column offset; the tests generally compare JSON outputs, not error strings.

## Environment-dependent behavior

Many C99 rules depend on implementation choices:

- sizes and ranges of integer types
- signedness of `char`
- representation of floating-point
- multi-character constants, trigraphs/digraphs, etc.

For this repository’s AST JSON schema (as observed in `c99_valid_test.mbt`), the type universe is intentionally simplified. Common scalar kinds include:

| C spelling | Example `repr` | Example `dataKind` |
|---|---|---|
| `void` | `void` | `Void` |
| `char` | `char` | `Char` |
| `short` | `short` | `Int16` |
| `int` | `int` | `Int` |
| `long` | `long` | `Long` |
| `long long` | `long long` | `LongLong` |
| `unsigned int` | `unsigned int` | `UInt` |
| `unsigned long` | `unsigned long` | `ULong` |
| `unsigned long long` | `unsigned long long` | `ULongLong` |
| `float` | `float` | `Float` |
| `double` | `double` | `Double` |

Note: This table reflects what appears in the current tests; it is not a claim that other C99 types do not exist.

## AST/JSON expectations (this repo)

The test suite asserts a stable JSON encoding of the AST. The encoding is intentionally explicit (tagged unions, explicit option encoding, and normalized type representations).

To understand the expected shape:

- See `c99_valid_test.mbt` for concrete examples of programs and JSON output.

At a very high level, the AST contains (names simplified):

- a `Program` with a list of `ExternalDeclaration`s
- function definitions (name, params, return type, body)
- declarations (local/global)
- statements and expressions annotated with `CType` information

